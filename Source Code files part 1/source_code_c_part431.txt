r;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = celt;

	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_SKIP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Skip)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->Skip(celt);
	_JumpIfError(hr, error, "Skip");
    }

error:
    return(hr);
}


HRESULT
ViewRow_Reset(
    IN DISPATCHINTERFACE *pdiViewRow)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_RESET,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->Reset();
	_JumpIfError(hr, error, "Reset");
    }

error:
    return(hr);
}


HRESULT
ViewRow_Clone(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT DISPATCHINTERFACE *pdiViewRowClone)
{
    HRESULT hr;
    IEnumCERTVIEWROW *pEnumRow = NULL;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_CLONE,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumRow);
	_JumpIfError(hr, error, "Invoke(Clone)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->Clone(&pEnumRow);
	_JumpIfError(hr, error, "Clone");
    }
    hr = ViewRow_Init2(
		    NULL != pdiViewRow->pDispatch,
		    pEnumRow,
		    pdiViewRowClone);
    _JumpIfError(hr, error, "ViewRow_Init2");

error:
    if (NULL != pEnumRow)
    {
	pEnumRow->Release();
    }
    return(hr);
}


HRESULT
ViewRow_GetMaxIndex(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_GETMAXINDEX,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(GetMaxIndex)", E_UNEXPECTED);
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->GetMaxIndex(pIndex);
	_JumpIfError2(hr, error, "GetMaxIndex", E_UNEXPECTED);
    }

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\viewext.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       viewext.cpp
//
//  Contents:   IEnumCERTVIEWEXTENSION IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTLIB_VIEWEXT_CPP__


//+------------------------------------------------------------------------
// IEnumCERTVIEWEXTENSION dispatch support

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// GetName method:

static OLECHAR *_apszGetName[] = {
    TEXT("GetName"),
};

//+------------------------------------
// GetFlags method:

static OLECHAR *_apszGetFlags[] = {
    TEXT("GetFlags"),
};

//+------------------------------------
// GetValue method:

static OLECHAR *_apszGetValue[] = {
    TEXT("GetValue"),
    TEXT("Type"),
    TEXT("Flags"),
};

//+------------------------------------
// Skip method:

static OLECHAR *_apszSkip[] = {
    TEXT("Skip"),
    TEXT("celt"),
};

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
};

//+------------------------------------
// Clone method:

static OLECHAR *_apszClone[] = {
    TEXT("Clone"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtViewExtension[] =
{
#define VIEWEXT_NEXT		0
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define VIEWEXT_GETNAME		1
    DECLARE_DISPATCH_ENTRY(_apszGetName)

#define VIEWEXT_GETFLAGS	2
    DECLARE_DISPATCH_ENTRY(_apszGetFlags)

#define VIEWEXT_GETVALUE	3
    DECLARE_DISPATCH_ENTRY(_apszGetValue)

#define VIEWEXT_SKIP		4
    DECLARE_DISPATCH_ENTRY(_apszSkip)

#define VIEWEXT_RESET		5
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define VIEWEXT_CLONE		6
    DECLARE_DISPATCH_ENTRY(_apszClone)
};
#define CVIEWEXTDISPATCH	(ARRAYSIZE(g_adtViewExtension))


HRESULT
ViewExtension_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWEXTENSION *pEnumExtension,
    OUT DISPATCHINTERFACE *pdiViewExtension)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;
    static BOOL s_fInitialized = FALSE;

    pdiViewExtension->pDispatchTable = NULL;
    pdiViewExtension->pDispatch = NULL;
    pdiViewExtension->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pEnumExtension->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CVIEWEXTDISPATCH,
			g_adtViewExtension,
			pdiViewExtension);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiViewExtension->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pEnumExtension->AddRef();
	pdiViewExtension->pUnknown = (IUnknown *) pEnumExtension;
	hr = S_OK;
    }
    pdiViewExtension->pDispatchTable = g_adtViewExtension;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}


VOID
ViewExtension_Release(
    IN OUT DISPATCHINTERFACE *pdiViewExtension)
{
    DispatchRelease(pdiViewExtension);
}


HRESULT
ViewExtension_Next(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(Next)", S_FALSE);
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->Next(pIndex);
	_JumpIfError2(hr, error, "Next", S_FALSE);
    }

error:
    return(hr);
}


HRESULT
ViewExtension_GetName(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_GETNAME,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetName)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->GetName(pstrOut);
	_JumpIfError(hr, error, "GetName");
    }

error:
    return(hr);
}


HRESULT
ViewExtension_GetFlags(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT LONG *pFlags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_GETFLAGS,
			0,
			NULL,
			VT_I4,
			pFlags);
	_JumpIfError(hr, error, "Invoke(GetFlags)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->GetFlags(pFlags);
	_JumpIfError(hr, error, "GetFlags");
    }

error:
    return(hr);
}


HRESULT
ViewExtension_GetValue(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN LONG Type,
    IN LONG Flags,
    OUT VOID *pValue)
{
    HRESULT hr;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    switch (Type)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiViewExtension->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = Type;
	avar[1].vt = VT_I4;
	avar[1].lVal = Flags;

	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_GETVALUE,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pValue);
	_JumpIfError(hr, error, "Invoke(GetValue)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->GetValue(
								Type,
								Flags,
								&varResult);
	_JumpIfError2(hr, error, "GetValue", CERTSRV_E_PROPERTY_EMPTY);

	hr = DispatchGetReturnValue(&varResult, RetType, pValue);
	_JumpIfError2(hr, error, "DispatchGetReturnValue", CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    VariantClear(&varResult);
    return(hr);
}


HRESULT
ViewExtension_Skip(
    IN DISPATCHINTERFACE *pdiViewExtension,
    IN LONG celt)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = celt;

	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_SKIP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Skip)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->Skip(celt);
	_JumpIfError(hr, error, "Skip");
    }

error:
    return(hr);
}


HRESULT
ViewExtension_Reset(
    IN DISPATCHINTERFACE *pdiViewExtension)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_RESET,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->Reset();
	_JumpIfError(hr, error, "Reset");
    }

error:
    return(hr);
}


HRESULT
ViewExtension_Clone(
    IN DISPATCHINTERFACE *pdiViewExtension,
    OUT DISPATCHINTERFACE *pdiViewExtensionClone)
{
    HRESULT hr;
    IEnumCERTVIEWEXTENSION *pEnumExtension = NULL;

    CSASSERT(NULL != pdiViewExtension && NULL != pdiViewExtension->pDispatchTable);

    if (NULL != pdiViewExtension->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewExtension,
			VIEWEXT_CLONE,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumExtension);
	_JumpIfError(hr, error, "Invoke(Clone)");
    }
    else
    {
	hr = ((IEnumCERTVIEWEXTENSION *) pdiViewExtension->pUnknown)->Clone(
							    &pEnumExtension);
	_JumpIfError(hr, error, "Clone");
    }
    hr = ViewExtension_Init2(
		    NULL != pdiViewExtension->pDispatch,
		    pEnumExtension,
		    pdiViewExtensionClone);
    _JumpIfError(hr, error, "ViewExtension_Init2");

error:
    if (NULL != pEnumExtension)
    {
	pEnumExtension->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\casec.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       casec.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	casec.cpp
//
//	ISecurityInformation implementation for CA objects
//  and the new acl editor
//
//	PURPOSE

//
//
//  DYNALOADED LIBRARIES
//
//	HISTORY
//	5-Nov-1998		petesk		Copied template from privobsi.cpp sample.
//
/////////////////////////////////////////////////////////////////////


#include <stdafx.h>
#include <accctrl.h>
#include <certca.h>
#include <sddl.h>
#include "certsrvd.h"
#include "certacl.h"

#define __dwFILE__	__dwFILE_CERTMMC_CASEC_CPP__


//
// defined in Security.cpp 
//
// // define our generic mapping structure for our private objects // 


#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)


GENERIC_MAPPING ObjMap = 
{     
    ACTRL_CERTSRV_READ,
    DELETE | WRITE_DAC | WRITE_OWNER | ACTRL_DS_WRITE_PROP,     
    0, 
    ACTRL_CERTSRV_MANAGE 
}; 


//
// DESCRIPTION OF ACCESS FLAG AFFECTS
//
// SI_ACCESS_GENERAL shows up on general properties page
// SI_ACCESS_SPECIFIC shows up on advanced page 
// SI_ACCESS_CONTAINER shows on general page IF object is a container
//

SI_ACCESS g_siObjAccesses[] = {CERTSRV_SI_ACCESS_LIST};

#define g_iObjDefAccess    3   // ENROLL enabled by default

// The following array defines the inheritance types for my containers.
SI_INHERIT_TYPE g_siObjInheritTypes[] =
{
    &GUID_NULL, 0,                                            MAKEINTRESOURCE(IDS_INH_NONE),
};


HRESULT
LocalAllocString(LPWSTR* ppResult, LPCWSTR pString)
{
    if (!ppResult || !pString)
        return E_INVALIDARG;

    *ppResult = (LPWSTR)LocalAlloc(LPTR, (lstrlen(pString) + 1) * sizeof(WCHAR));

    if (!*ppResult)
        return E_OUTOFMEMORY;

    lstrcpy(*ppResult, pString);
    return S_OK;
}

void
LocalFreeString(LPWSTR* ppString)
{
    if (ppString)
    {
        if (*ppString)
            LocalFree(*ppString);
        *ppString = NULL;
    }   
}

class CCASecurityObject : public ISecurityInformation
{
protected:
    ULONG                   m_cRef;
    CertSvrCA *             m_pSvrCA;
//    PSECURITY_DESCRIPTOR    m_pSD;

public:
    CCASecurityObject() : m_cRef(1) 
    { 
        m_pSvrCA = NULL;
//        m_pSD = NULL;
    }
    virtual ~CCASecurityObject();

    STDMETHOD(Initialize)(CertSvrCA *pCA);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);

protected:
    HRESULT GetSecurityDCOM(PSECURITY_DESCRIPTOR *ppSD);
    HRESULT GetSecurityRegistry(PSECURITY_DESCRIPTOR *ppSD);
    HRESULT SetSecurityDCOM(PSECURITY_DESCRIPTOR pSD);
    HRESULT SetSecurityRegistry(PSECURITY_DESCRIPTOR pSD);
};

///////////////////////////////////////////////////////////////////////////////
//
//  This is the entry point function called from our code that establishes
//  what the ACLUI interface is going to need to know.
//
//
///////////////////////////////////////////////////////////////////////////////

extern "C"
HRESULT
CreateCASecurityInfo(  CertSvrCA *pCA,
                        LPSECURITYINFO *ppObjSI)
{
    HRESULT hr;
    CCASecurityObject *psi;

    *ppObjSI = NULL;

    psi = new CCASecurityObject;
    if (!psi)
        return E_OUTOFMEMORY;

    hr = psi->Initialize(pCA);

    if (SUCCEEDED(hr))
        *ppObjSI = psi;
    else
        delete psi;

    return hr;
}


CCASecurityObject::~CCASecurityObject()
{
}

STDMETHODIMP
CCASecurityObject::Initialize(CertSvrCA *pCA)
{
    m_pSvrCA = pCA;
    return S_OK;
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CCASecurityObject::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CCASecurityObject::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CCASecurityObject::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CCASecurityObject::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{


    if(pObjectInfo == NULL)
    {
        return E_POINTER;
    }
    if(m_pSvrCA == NULL)
    {
        return E_POINTER;
    }

    ZeroMemory(pObjectInfo, sizeof(SI_OBJECT_INFO));
    pObjectInfo->dwFlags = SI_EDIT_PERMS | 
                           SI_NO_TREE_APPLY |
                           SI_EDIT_AUDITS |
                           SI_NO_ACL_PROTECT |
                           SI_NO_ADDITIONAL_PERMISSION;

    if(!m_pSvrCA->AccessAllowed(CA_ACCESS_ADMIN))
        pObjectInfo->dwFlags |= SI_READONLY;

    pObjectInfo->hInstance = g_hInstance;

    if(m_pSvrCA->m_pParentMachine)
    {
        pObjectInfo->pszServerName = const_cast<WCHAR *>((LPCTSTR)m_pSvrCA->m_pParentMachine->m_strMachineName);
    }

    pObjectInfo->pszObjectName = const_cast<WCHAR *>((LPCTSTR)m_pSvrCA->m_strCommonName);

    return S_OK;
}

HRESULT CCASecurityObject::GetSecurityDCOM(PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT hr = S_OK;

    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 0;	// 0 required by myOpenAdminDComConnection
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbSD;
	ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    CSASSERT(m_pSvrCA);

    hr = myOpenAdminDComConnection(
                    m_pSvrCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
		&dwServerVersion,
                    &pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

	if (2 > dwServerVersion)
	{
	    hr = RPC_E_VERSION_MISMATCH;
	    _JumpError(hr, error, "old server");
	}

    __try
    {
        hr = pICertAdminD->GetCASecurity(
                 pwszAuthority,
                 &ctbSD);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->GetCASecurity");

    myRegisterMemAlloc(ctbSD.pb, ctbSD.cb, CSM_COTASKALLOC);

    // take the return
    *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, ctbSD.cb);
    if (NULL == *ppSD)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    MoveMemory(*ppSD, ctbSD.pb, ctbSD.cb);

error:
    myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);
    if (NULL != ctbSD.pb)
    {
        CoTaskMemFree(ctbSD.pb);
    }

    return hr;
}

HRESULT CCASecurityObject::GetSecurityRegistry(PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT hr = S_OK;
    variant_t var;
    DWORD dwType;
    DWORD dwSize;
    BYTE* pbTmp;

    hr = m_pSvrCA->GetConfigEntry(
                NULL,
                wszREGCASECURITY,
                &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    hr = myVariantToRegValue(
            &var,
            &dwType,
            &dwSize,
            &pbTmp);
    _JumpIfError(hr, error, "myVariantToRegValue");

    *ppSD = pbTmp;

error:
    return hr;
}


STDMETHODIMP
CCASecurityObject::GetSecurity(
    SECURITY_INFORMATION, // si
    PSECURITY_DESCRIPTOR *ppSD,
    BOOL /* fDefault */ )
{
    HRESULT hr = S_OK;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_DACL_PROTECTED;
    DWORD dwRevision;

    hr = GetSecurityDCOM(ppSD);
    _PrintIfError(hr, "GetSecurityDCOM");
    if(S_OK!=hr)
    {
        hr = GetSecurityRegistry(ppSD);
        _JumpIfError(hr, error, "GetSecurityRegistry");
    }

    CSASSERT(*ppSD);

    if(GetSecurityDescriptorControl(*ppSD, &Control, &dwRevision))
    {
        Control &= SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED;
        SetSecurityDescriptorControl(*ppSD, 
                                     SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED, 
                                     Control);
    }

error:
    return hr;
}


HRESULT CCASecurityObject::SetSecurityDCOM(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    HANDLE hClientToken = NULL;
    HANDLE hHandle = NULL;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 0;
    CERTTRANSBLOB ctbSD;
    WCHAR const *pwszAuthority;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = myHLastError();
    }
    else
    {
        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = myHLastError();
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = myHLastError();
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;

            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = myHLastError();
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = myHLastError();
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }

    if(hr != S_OK)
    {
        goto error;
    }

    hr = myOpenAdminDComConnection(
		    m_pSvrCA->m_bstrConfig,
		    &pwszAuthority,
		    NULL,
		    &dwServerVersion,
		    &pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
	hr = RPC_E_VERSION_MISMATCH;
	_JumpError(hr, error, "old server");
    }

    __try
    {
        ctbSD.cb = GetSecurityDescriptorLength(pSD);
        ctbSD.pb = (BYTE*)pSD;
        hr = pICertAdminD->SetCASecurity(
                     pwszAuthority,
                     &ctbSD);

        if(hr == HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE))
        {
            // Attempt to fix enrollment object, see bug# 193388
            m_pSvrCA->FixEnrollmentObject();

            // try again
            hr = pICertAdminD->SetCASecurity(
                         pwszAuthority,
                         &ctbSD);
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->SetCASecurity");

error:
    myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);
    if(hClientToken)
    {
        CloseHandle(hClientToken);
    }
    if(hHandle)
    {
        CloseHandle(hHandle);
    }

    return hr;
}

HRESULT CCASecurityObject::SetSecurityRegistry(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    variant_t var;
    CertSrv::CCertificateAuthoritySD CASD;

    // SD passed in contains only a DACL. We need to fully construct the
    // CA SD as certsrv would do

    hr = CASD.InitializeFromTemplate(WSZ_EMPTY_CA_SECURITY, L"");
    _JumpIfError(hr, error, "CCertificateAuthoritySD::Initialize");

    hr = CASD.Set(pSD, false);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::Set");

    hr = myRegValueToVariant(
        REG_BINARY,
        GetSecurityDescriptorLength(CASD.Get()),
        (BYTE const*)CASD.Get(),
        &var);
    _JumpIfError(hr, error, "myRegValueToVariant");

    hr = m_pSvrCA->SetConfigEntry(
                NULL,
                wszREGCASECURITY,
                &var);
    _JumpIfErrorStr(hr, error, "SetConfigEntry", wszREGCASECURITY);

    // set status bit to signal certsrv to pick up changes next
    // time it starts
    hr = m_pSvrCA->GetConfigEntry(
        NULL,
        wszREGSETUPSTATUS,
        &var);
    _JumpIfErrorStr(hr, error, "GetConfigEntry", wszREGSETUPSTATUS);

    V_I4(&var) |= SETUP_SECURITY_CHANGED;

    hr = m_pSvrCA->SetConfigEntry(
        NULL,
        wszREGSETUPSTATUS,
        &var);
    _JumpIfErrorStr(hr, error, "SetConfigEntry", wszREGSETUPSTATUS);
    
error:
    return hr;
}

STDMETHODIMP
CCASecurityObject::SetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_DACL_PROTECTED;
    DWORD  dwSize;
    DWORD dwRevision;
    PSECURITY_DESCRIPTOR pSDSelfRel = NULL;

    if (DACL_SECURITY_INFORMATION!=si)
        return E_NOTIMPL;

    if(si & DACL_SECURITY_INFORMATION)
    {
        if(GetSecurityDescriptorControl(pSD, &Control, &dwRevision))
        {
            Control &= SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED;
            SetSecurityDescriptorControl(pSD, 
                                         SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED, 
                                         Control);
        }
    }

    dwSize = GetSecurityDescriptorLength(pSD);

    pSDSelfRel = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
    if(NULL == pSDSelfRel)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!MakeSelfRelativeSD(pSD, pSDSelfRel, &dwSize))
    {
        LocalFree(pSDSelfRel);
        pSDSelfRel = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
        if(NULL == pSDSelfRel)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if(!MakeSelfRelativeSD(pSD, pSDSelfRel, &dwSize))
        {
            hr = myHLastError();
            _JumpError(hr, error, "LocalAlloc");
        }
    }

    hr = SetSecurityDCOM(pSDSelfRel);
    if (S_OK != hr)
    {
	HRESULT hr2 = hr;

	_PrintError(hr, "SetSecurityDCOM");

	if (E_ACCESSDENIED == hr ||
	    (HRESULT) RPC_S_SERVER_UNAVAILABLE == hr ||
	    HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr)
	{
	    
	    hr2 = SetSecurityRegistry(pSDSelfRel);
	    _JumpIfError(hr2, error, "SetSecurityRegistry");
	}
        DisplayCertSrvErrorWithContext(NULL, hr, IDS_CANNOT_UPDATE_SECURITY_ON_CA);
	if (S_OK == hr2)
	{
	    hr = S_OK;
	}
    }

error:

    if(NULL != pSDSelfRel)
    {
        LocalFree(pSDSelfRel);
    }

    return hr;
}

STDMETHODIMP
CCASecurityObject::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    *ppAccesses = g_siObjAccesses;
    *pcAccesses = sizeof(g_siObjAccesses)/sizeof(g_siObjAccesses[0]);
    *piDefaultAccess = g_iObjDefAccess;

    return S_OK;
}

STDMETHODIMP
CCASecurityObject::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CCASecurityObject::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    *ppInheritTypes = g_siObjInheritTypes;
    *pcInheritTypes = sizeof(g_siObjInheritTypes)/sizeof(g_siObjInheritTypes[0]);

    return S_OK;
}

STDMETHODIMP
CCASecurityObject::PropertySheetPageCallback(HWND /*hwnd*/,
                                         UINT /*uMsg*/,
                                         SI_PAGE_TYPE /*uPage*/)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\certif.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       certif.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "csprop.h"
#include "ciinit.h"

#define __dwFILE__	__dwFILE_CERTMMC_CERTIF_CPP__


FNCIGETPROPERTY PropCIGetProperty;
FNCISETPROPERTY PropCISetProperty;
FNCIGETEXTENSION PropCIGetExtension;
FNCISETPROPERTY PropCISetExtension;
FNCIENUMSETUP PropCIEnumSetup;
FNCIENUMNEXT PropCIEnumNext;
FNCIENUMCLOSE PropCIEnumClose;

SERVERCALLBACKS ThunkedCallbacks = 
{
    PropCIGetProperty,  //    FNCIGETPROPERTY  *pfnGetProperty;
    PropCISetProperty,  //    FNCISETPROPERTY  *pfnSetProperty;
    PropCIGetExtension, //    FNCIGETEXTENSION *pfnGetExtension;
    PropCISetExtension, //    FNCISETEXTENSION *pfnSetExtension;
    PropCIEnumSetup,    //    FNCIENUMSETUP    *pfnEnumSetup;
    PropCIEnumNext,     //    FNCIENUMNEXT     *pfnEnumNext;
    PropCIEnumClose,    //    FNCIENUMCLOSE    *pfnEnumClose;
};

CertSvrCA* g_pCA = NULL;

HRESULT ThunkServerCallbacks(CertSvrCA* pCA)
{
    HRESULT hr = S_OK;
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        fInitialized = TRUE;

        // initialize certif.dll
        hr = CertificateInterfaceInit(
            &ThunkedCallbacks,
            sizeof(ThunkedCallbacks));

    }
    
    g_pCA = pCA;

    return hr;
}




HRESULT
PropCIGetProperty(
    IN LONG, // Context
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    
    if (NULL != pvarPropertyValue)
    {
        VariantInit(pvarPropertyValue);
    }
    if (NULL == pwszPropertyName || NULL == pvarPropertyValue)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    
    hr = E_INVALIDARG;
    if ((PROPCALLER_MASK & Flags) != PROPCALLER_POLICY &&
        (PROPCALLER_MASK & Flags) != PROPCALLER_EXIT)
    {
        _JumpError(hr, error, "Flags: Invalid caller");
    }
    
    // Special, hard-coded properties we need to support
    if (0 == LSTRCMPIS(pwszPropertyName, wszPROPCATYPE))
    {
        ENUM_CATYPES caType = g_pCA->GetCAType();
        hr = myUnmarshalVariant(
		        Flags,
		        sizeof(DWORD),
		        (PBYTE)&caType,
		        pvarPropertyValue);
        _JumpIfError(hr, error, "myUnmarshalVariant");
    }
    else if (0 == LSTRCMPIS(pwszPropertyName, wszPROPUSEDS))
    {
       BOOL fUseDS = g_pCA->FIsUsingDS();
       hr = myUnmarshalVariant(
                        Flags,
                        sizeof(BOOL),
                        (PBYTE)&fUseDS,
                        pvarPropertyValue);
        _JumpIfError(hr, error, "myUnmarshalVariant");
    }
    else
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
    }

error:

    return(myHError(hr));
}




HRESULT
PropCISetProperty(
    IN LONG, // Context
    IN DWORD, // Flags
    IN WCHAR const *, // pwszPropertyName
    IN VARIANT const * /* pvarPropertyValue */ )
{
    return E_NOTIMPL;
}



HRESULT
PropCIGetExtension(
    IN LONG, // Context
    IN DWORD, // Flags
    IN WCHAR const *, // pwszExtensionName
    OUT DWORD *, // pdwExtFlags
    OUT VARIANT * /* pvarValue */ )
{
    return E_NOTIMPL;
}


HRESULT
PropCISetExtension(
    IN LONG, // Context
    IN DWORD, // Flags
    IN WCHAR const *, // pwszExtensionName
    IN DWORD, // ExtFlags
    IN VARIANT const * /* pvarValue */ )
{
    return E_NOTIMPL;
}



HRESULT 
PropCIEnumSetup(
    IN LONG, // Context
    IN LONG, // Flags
    IN OUT CIENUM * /* pciEnum */ )
{
    return E_NOTIMPL;
}



HRESULT PropCIEnumNext(
    IN OUT CIENUM *, // pciEnum
    OUT BSTR * /* pstrPropertyName */ )
{
    return E_NOTIMPL;
}


HRESULT
PropCIEnumClose(
    IN OUT CIENUM * /* pciEnum */ )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\certwrap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certwrap.cpp
//
//--------------------------------------------------------------------------
#include <stdafx.h>
#include "csdisp.h"
#include "certsrv.h"
#include "genpage.h"
#include "progress.h"
#include "misc.h"
#include "certacl.h"
#include <dsgetdc.h>
#include <winldap.h>
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTMMC_CERTWRAP_CPP__


_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);

//////////////////////////
// CertSvrCA class
CertSvrCA::CertSvrCA(CertSvrMachine* pParent) :
        m_pParentMachine(pParent)
{
    m_hCACertStore = NULL;
    m_fCertStoreOpenAttempted = FALSE;
    m_hrCACertStoreOpen = S_OK;

    m_hRootCertStore = NULL;
    m_fRootStoreOpenAttempted = FALSE;
    m_hrRootCertStoreOpen = S_OK;

    m_hKRACertStore = NULL;
    m_fKRAStoreOpenAttempted = FALSE;
    m_hrKRACertStoreOpen = S_OK;

    m_bstrConfig = NULL;

    m_enumCAType = ENUM_UNKNOWN_CA;
    m_fCATypeKnown = FALSE;

    m_fIsUsingDS = FALSE;
    m_fIsUsingDSKnown = FALSE;

    m_fAdvancedServer = FALSE;
    m_fAdvancedServerKnown = FALSE;

    if(m_pParentMachine)
        m_pParentMachine->AddRef();

    m_dwRoles = MAXDWORD; // assume all roles are enabled, in case we fail to retrieve them
    m_fRolesKnown = FALSE;
}

CertSvrCA::~CertSvrCA()
{
    if (m_hCACertStore)
    {
        CertCloseStore(m_hCACertStore, 0);
        m_hCACertStore = NULL;
    }

    if (m_hRootCertStore)
    {
        CertCloseStore(m_hRootCertStore, 0);
        m_hRootCertStore = NULL;
    }

    if (m_hKRACertStore)
    {
        CertCloseStore(m_hKRACertStore, 0);
        m_hKRACertStore = NULL;
    }

    if (m_bstrConfig)
        SysFreeString(m_bstrConfig);

    if(m_pParentMachine)
        m_pParentMachine->Release();
}

BOOL CertSvrCA::AccessAllowed(DWORD dwAccess)
{
    return (dwAccess & GetMyRoles())?TRUE:FALSE;
}

DWORD CertSvrCA::GetMyRoles()
{
    HRESULT hr = S_OK;
    ICertAdmin2Ptr pCertAdmin;
    LONG dwRoles;

    if(!m_fRolesKnown)
    {
	    hr = m_pParentMachine->GetAdmin2(&pCertAdmin);
        _JumpIfError(hr, error, "CertSvrMachine::GetAdmin2");

	    hr = pCertAdmin->GetMyRoles(
		    m_bstrConfig,
            &dwRoles);
        _JumpIfError(hr, error, "ICertAdmin2::GetCAProperty");

        m_dwRoles = dwRoles;
        m_fRolesKnown = TRUE;
    }

error:
    return m_dwRoles;
}

HRESULT CertSvrCA::GetCAFlagsFromDS(PDWORD pdwFlags)
{
    HRESULT hr = S_OK;
    LPWSTR pwszSanitizedDSName = NULL;
    HCAINFO hCAInfo = NULL;

    hr = mySanitizedNameToDSName(m_strSanitizedName, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
        pwszSanitizedDSName,
        NULL,
        0,
        &hCAInfo);
    _JumpIfErrorStr(hr, error, "CAFindByName", pwszSanitizedDSName);

    hr = CAGetCAFlags(
        hCAInfo,
        pdwFlags);
    _JumpIfError(hr, error, "CAGetCAFlags");

error:
    LOCAL_FREE(pwszSanitizedDSName);
    if(hCAInfo)
        CACloseCA(hCAInfo);

    return hr;
}


// CA machine should have full control over the enrollment object in DS.
// This function checks if the machine has the rights and adds a new
// ace allowing CA machine obj (eg TESTDOMAIN\BOGDANTTEST$) full control
// over its enrollment object
// See bug# 193388.
HRESULT CertSvrCA::FixEnrollmentObject()
{
    HRESULT hr = S_OK;
    IDirectoryObject *pADEnrollObj = NULL;
    LPWSTR pwszAttr = L"nTSecurityDescriptor";
    PADS_ATTR_INFO paai = NULL;
    DWORD dwAttrReturned;
    
    LPWSTR pwszSanitizedDSName = NULL;
    CString strEnrollDN;
    HCAINFO hCAInfo = NULL;
    PSID pSid = NULL;
    bool fAllowed = false;
    PSECURITY_DESCRIPTOR pSDRead = NULL; // no free
    PSECURITY_DESCRIPTOR pSDWrite = NULL;

    hr = mySanitizedNameToDSName(m_strSanitizedName, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
        pwszSanitizedDSName,
        NULL,
        CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
        &hCAInfo);
    _JumpIfErrorStr(hr, error, "CAFindByName", pwszSanitizedDSName);

    strEnrollDN = L"LDAP://";
    strEnrollDN += myCAGetDN(hCAInfo);
    if (strEnrollDN.IsEmpty())
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCAGetDN");
    }

    hr = ADsGetObject(strEnrollDN, IID_IDirectoryObject, (void**)&pADEnrollObj);
    _JumpIfErrorStr(hr, error, "ADsGetObject", strEnrollDN);

    hr = pADEnrollObj->GetObjectAttributes(
        &pwszAttr,
        1,
        &paai,
        &dwAttrReturned);
    _JumpIfErrorStr(hr, error, "Get SD", strEnrollDN);

    pSDRead = paai[0].pADsValues[0].SecurityDescriptor.lpValue;

    CSASSERT(IsValidSecurityDescriptor(pSDRead));

    hr = FindComputerObjectSid(
        m_strServer,
        pSid);
    _JumpIfErrorStr(hr, error, "FindCAComputerObjectSid", m_strServer);

    // look in DACL for a ace allowing CA full control
    hr = IsCAAllowedFullControl(
            pSDRead,
            pSid,
            fAllowed);
    _JumpIfError(hr, error, "IsCAAllowedFullControl");

    if(!fAllowed)
    {
        // build new SD allowing CA full control and write it back
        // to DS
        ADSVALUE  snValue;
        ADS_ATTR_INFO  attrInfo[] = 
        {{
            pwszAttr,
            ADS_ATTR_UPDATE,
            ADSTYPE_NT_SECURITY_DESCRIPTOR,
            &snValue,
            1} 
        };

        hr = AllowCAFullControl(
            pSDRead,
            pSid,
            pSDWrite);
        _JumpIfError(hr, error, "AllowCAFullControl");

        CSASSERT(IsValidSecurityDescriptor(pSDWrite));

        snValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
        snValue.SecurityDescriptor.dwLength = 
            GetSecurityDescriptorLength(pSDWrite);
        snValue.SecurityDescriptor.lpValue = (LPBYTE)pSDWrite;

        hr = pADEnrollObj->SetObjectAttributes(
            attrInfo,
            1,
            &dwAttrReturned);
        _JumpIfErrorStr(hr, error, "Set SD", strEnrollDN);
    }

error:

    if(paai)
        FreeADsMem(paai);
    if(pADEnrollObj)
        pADEnrollObj->Release();
    if(hCAInfo)
        CACloseCA(hCAInfo);
    LOCAL_FREE(pwszSanitizedDSName);
    LOCAL_FREE(pSid);
    LOCAL_FREE(pSDWrite);
    return hr;
}

HRESULT CertSvrCA::IsCAAllowedFullControl(
    PSECURITY_DESCRIPTOR pSDRead,
    PSID pSid,
    bool& fAllowed)
{
    HRESULT hr = S_OK;
    PACL pDacl; // no free
    ACL_SIZE_INFORMATION AclInfo;
    PACCESS_ALLOWED_ACE pAce; // no free
    DWORD dwIndex;
    
    fAllowed = false;

    hr = myGetSecurityDescriptorDacl(
        pSDRead,
        &pDacl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");


    if(!GetAclInformation(pDacl,
                          &AclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    for(dwIndex = 0; dwIndex < AclInfo.AceCount; dwIndex++)
    {
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE &&
           (pAce->Mask & ACTRL_CERTSRV_MANAGE) == ACTRL_CERTSRV_MANAGE &&
           EqualSid((PSID)&pAce->SidStart, pSid))
        {
            fAllowed = true;
            break;
        }
    }

error:
    return hr;
}

HRESULT CertSvrCA::AllowCAFullControl(
    PSECURITY_DESCRIPTOR pSDRead,
    PSID pSid,
    PSECURITY_DESCRIPTOR& pSDWrite)
{
    HRESULT hr = S_OK;
    BOOL fRet = 0;
    LPBYTE pSDTemp = NULL;
    PACL pDaclWrite = NULL;
    PACL pDaclRead = NULL; // no free
    PVOID pAce = NULL; // no free
    DWORD dwAbsoluteSDSize = 0;
    DWORD dwDaclSize = 0;
    DWORD dwSaclSize = 0;
    DWORD dwOwnerSize = 0;
    DWORD dwGroupSize = 0;
    DWORD dwSDWriteSize = 0;
    DWORD dwDaclWriteSize = 0;

    hr = myGetSecurityDescriptorDacl(
        pSDRead,
        &pDaclRead);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");
    
    fRet = MakeAbsoluteSD(
        pSDRead,
        NULL,
        &dwAbsoluteSDSize,
        NULL,
        &dwDaclSize,
        NULL,
        &dwSaclSize,
        NULL,
        &dwOwnerSize,
        NULL,
        &dwGroupSize); // should always fail with insufficient buffer
    if(fRet || ERROR_INSUFFICIENT_BUFFER!=GetLastError())
    {
        hr = fRet? E_FAIL : myHLastError();
        _JumpError(hr, error, "MakeAbsoluteSD");
    }

    // alloc all buffers together
    pSDTemp = (LPBYTE)LocalAlloc(
        LMEM_FIXED,
        dwAbsoluteSDSize+dwDaclSize+dwSaclSize+dwOwnerSize+dwGroupSize);
    _JumpIfAllocFailed(pSDTemp, error);
    
    fRet = MakeAbsoluteSD(
        pSDRead,
        (PSECURITY_DESCRIPTOR)pSDTemp,
        &dwAbsoluteSDSize,
        (PACL)(pSDTemp+dwAbsoluteSDSize),
        &dwDaclSize,
        (PACL)(pSDTemp+dwAbsoluteSDSize+dwDaclSize),
        &dwSaclSize,
        (PSID)(pSDTemp+dwAbsoluteSDSize+dwDaclSize+dwSaclSize),
        &dwOwnerSize,
        (PSID)(pSDTemp+dwAbsoluteSDSize+dwDaclSize+dwSaclSize+dwOwnerSize),
        &dwGroupSize); // should always fail with insufficient buffer
    if(!fRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "MakeAbsoluteSD");
    }

    dwDaclWriteSize = dwDaclSize+sizeof(ACCESS_ALLOWED_ACE)-sizeof(DWORD)+
        GetLengthSid(pSid);

    pDaclWrite = (PACL) LocalAlloc(LMEM_FIXED, dwDaclWriteSize);
    _JumpIfAllocFailed(pDaclWrite, error);

    fRet = InitializeAcl(pDaclWrite, dwDaclWriteSize, ACL_REVISION_DS);
    if(!fRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    fRet = GetAce(pDaclRead, 0, &pAce);
    if(!fRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAce");
    }

    fRet = AddAce(pDaclWrite, ACL_REVISION_DS, 0, pAce, dwDaclSize-sizeof(ACL));
    if(!fRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "AddAce");
    }

    fRet = AddAccessAllowedAce(
        pDaclWrite,
        ACL_REVISION_DS,
        ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS,
        pSid);
    if(!fRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "AddAccessAllowedAce");
    }

    fRet = SetSecurityDescriptorDacl(
        pSDTemp,
        TRUE,
        pDaclWrite,
        FALSE);
    if(!fRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    fRet = MakeSelfRelativeSD(
        pSDTemp,
        NULL,
        &dwSDWriteSize);
    if(fRet || ERROR_INSUFFICIENT_BUFFER!=GetLastError())
    {
        hr = fRet? E_FAIL : myHLastError();
        _JumpError(hr, error, "MakeSelfRelativeSD");
    }

    pSDWrite = LocalAlloc(LMEM_FIXED, dwSDWriteSize);
    _JumpIfAllocFailed(pSDWrite, error);

    fRet = MakeSelfRelativeSD(
        pSDTemp,
        pSDWrite,
        &dwSDWriteSize);
    if(!fRet)
    {
        hr = myHLastError();
        _JumpError(hr, error, "MakeSelfRelativeSD");
    }

error:

    LOCAL_FREE(pSDTemp);
    LOCAL_FREE(pDaclWrite);
    return hr;
}


BOOL  CertSvrCA::FIsUsingDS()
{
    DWORD dwRet;
    variant_t varUsingDS;

    if (m_fIsUsingDSKnown)
       return m_fIsUsingDS;

    dwRet = GetConfigEntry(
            NULL,
            wszREGCAUSEDS,
            &varUsingDS);
    _JumpIfError(dwRet, Ret, "GetConfigEntry");

    CSASSERT ((V_VT(&varUsingDS)== VT_I4));
    m_fIsUsingDS = V_I4(&varUsingDS);

Ret:
    m_fIsUsingDSKnown = TRUE;
    return m_fIsUsingDS;
}

BOOL  CertSvrCA::FIsAdvancedServer()
{
    HRESULT hr = S_OK;
    variant_t var;
    ICertAdmin2Ptr pCertAdmin;
    CString strCADN, strCALDAP = L"LDAP://";
    IADsPtr pADs;

    if (!m_fAdvancedServerKnown)
    {

	    hr = m_pParentMachine->GetAdmin2(&pCertAdmin);
        if(S_OK==hr)
        {

	        hr = pCertAdmin->GetCAProperty(
		        m_bstrConfig,
		        CR_PROP_ADVANCEDSERVER, // PropId 
		        0, // Index
		        PROPTYPE_LONG, // PropType 
		        0, // Flags 
		        &var);
        }
	    if(S_OK != hr)
        {
            // couldn't figure it out from CA, try DS
            DWORD dwFlags;
            hr = GetCAFlagsFromDS(&dwFlags);
            _JumpIfError(hr, error, "GetCAFlags");
            
            m_fAdvancedServer = 
                (dwFlags & CA_FLAG_CA_SERVERTYPE_ADVANCED)?
                TRUE:
                FALSE;
            m_fAdvancedServerKnown = TRUE;
        }
        else
        {
            CSASSERT ((V_VT(&var)== VT_I4));
            m_fAdvancedServer = V_I4(&var);
            m_fAdvancedServerKnown = TRUE;
        }
        _JumpIfError(hr, error, "GetCAProperty");
    }

error:

    return m_fAdvancedServer;
}


ENUM_CATYPES CertSvrCA::GetCAType()
{
    DWORD dwRet;
    variant_t varCAType;

    if (m_fCATypeKnown)
        return m_enumCAType;

    dwRet = GetConfigEntry(
            NULL,
            wszREGCATYPE, 
            &varCAType);
    _JumpIfError(dwRet, Ret, "GetConfigEntry");

    CSASSERT ((V_VT(&varCAType)== VT_I4));
    m_enumCAType = (ENUM_CATYPES)V_I4(&varCAType);

Ret:
    m_fCATypeKnown = TRUE;
    return m_enumCAType;
}

HRESULT CertSvrCA::_GetSetupStatus(DWORD &rdwStatus)
{
    HRESULT hr;
    variant_t varSetupStatus;

    hr = GetConfigEntry(
         NULL,
         wszREGSETUPSTATUS,
         &varSetupStatus);
    _JumpIfErrorStr(hr, Ret, "GetConfigEntry", wszREGSETUPSTATUS);

    CSASSERT ((V_VT(&varSetupStatus)== VT_I4));
    rdwStatus = V_I4(&varSetupStatus);

Ret:
    return hr;
}

HRESULT CertSvrCA::_SetSetupStatus(DWORD dwStatus)
{
    HRESULT hr;
    variant_t varSetupStatus;

    V_VT(&varSetupStatus) = VT_I4;
    V_I4(&varSetupStatus) = dwStatus;

    hr = SetConfigEntry(
         NULL,
         wszREGSETUPSTATUS,
         &varSetupStatus);
    _JumpIfErrorStr(hr, Ret, "SetConfigEntry", wszREGSETUPSTATUS);

Ret:
    return hr;
}

HRESULT CertSvrCA::CleanSetupStatusBits(DWORD dwBitsToClean)
{
    HRESULT hr;
    DWORD dwStatus = 0;

    hr = _GetSetupStatus(dwStatus);
    _JumpIfError(hr, Ret, "_GetSetupStatus");

    dwStatus = dwStatus & ~dwBitsToClean;

    hr = _SetSetupStatus(dwStatus);
    _JumpIfError(hr, Ret, "_SetSetupStatus");

Ret:
    return hr;
}

BOOL CertSvrCA::FIsIncompleteInstallation()
{
    DWORD dwStatus = 0;
    _GetSetupStatus(dwStatus);
    return ((SETUP_SUSPEND_FLAG & dwStatus)?TRUE:FALSE);
}

BOOL CertSvrCA::FIsRequestOutstanding()
{
    DWORD dwStatus = 0;
    _GetSetupStatus(dwStatus);
    return ((SETUP_REQUEST_FLAG & dwStatus)?TRUE:FALSE);
}

BOOL CertSvrCA::FDoesSecurityNeedUpgrade()
{
    DWORD dwStatus = 0;
    _GetSetupStatus(dwStatus);
    return ((SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG & dwStatus)?TRUE:FALSE);
}

BOOL  CertSvrCA::FDoesServerAllowForeignCerts()
{
    HRESULT hr;
    DWORD dwStatus;
    variant_t varKRAFlags;

    hr = GetConfigEntry(
         NULL,
         wszREGKRAFLAGS,
         &varKRAFlags);
    _JumpIfError(hr, Ret, "GetConfigEntry");

    CSASSERT ((V_VT(&varKRAFlags)== VT_I4));
    dwStatus = V_I4(&varKRAFlags);

    return ((dwStatus & KRAF_ENABLEFOREIGN) != 0);

Ret:
    return FALSE;
}




DWORD CertSvrCA::GetCACertByKeyIndex(PCCERT_CONTEXT* ppCertCtxt, int iKeyIndex)
{
    // don't cache CA cert

    DWORD dwErr;
    ICertAdmin2* pCertAdmin = NULL; // must free this!!
	VARIANT varPropertyValue;
	VariantInit(&varPropertyValue);

    *ppCertCtxt = NULL;

	dwErr = m_pParentMachine->GetAdmin2(&pCertAdmin);
    _JumpIfError(dwErr, Ret, "GetAdmin2");
	
	// To get key's Cert
	dwErr = pCertAdmin->GetCAProperty(
		m_bstrConfig,
		CR_PROP_CASIGCERT, // PropId 
		iKeyIndex, // PropIndex key index 
		PROPTYPE_BINARY, // PropType 
		CR_OUT_BINARY, // Flags 
		&varPropertyValue);
	_JumpIfError(dwErr, Ret, "GetCAProperty");

	// varPropertyValue.vt will be VT_BSTR
	if (VT_BSTR != varPropertyValue.vt)
	{
		dwErr = ERROR_INVALID_PARAMETER;
		_JumpError(dwErr, Ret, "GetCAProperty");
	}

    *ppCertCtxt = CertCreateCertificateContext(
        CRYPT_ASN_ENCODING,
        (PBYTE)varPropertyValue.bstrVal,
        SysStringByteLen(varPropertyValue.bstrVal));
    if (*ppCertCtxt == NULL)
    {
        dwErr = GetLastError();
        _JumpError(dwErr, Ret, "CertCreateCertContext");
    }

    dwErr = ERROR_SUCCESS;
Ret:
    VariantClear(&varPropertyValue);

    if (pCertAdmin)
        pCertAdmin->Release();

    return dwErr;
}


DWORD CertSvrCA::GetCurrentCRL(PCCRL_CONTEXT* ppCRLCtxt, BOOL fBaseCRL)
{
	return GetCRLByKeyIndex(ppCRLCtxt, fBaseCRL, -1);
}

DWORD CertSvrCA::GetCRLByKeyIndex(PCCRL_CONTEXT* ppCRLCtxt, BOOL fBaseCRL, int iKeyIndex)
{
    // don't cache CRL

    DWORD dwErr;
    ICertAdmin2* pCertAdmin = NULL; // must free this!!
	VARIANT varPropertyValue;
	VariantInit(&varPropertyValue);

    *ppCRLCtxt = NULL;

    dwErr = m_pParentMachine->GetAdmin2(&pCertAdmin);
    _JumpIfError(dwErr, Ret, "GetAdmin2");
	
	// To get each key's BASE CRL
	dwErr = pCertAdmin->GetCAProperty(
		m_bstrConfig,
		fBaseCRL ? CR_PROP_BASECRL : CR_PROP_DELTACRL, // PropId 
		iKeyIndex, // PropIndex key index 
		PROPTYPE_BINARY, // PropType 
		CR_OUT_BINARY, // Flags 
		&varPropertyValue);
	_JumpIfError(dwErr, Ret, "GetCAProperty");

	// varPropertyValue.vt will be VT_BSTR
	if (VT_BSTR != varPropertyValue.vt)
	{
		dwErr = ERROR_INVALID_PARAMETER;
		_JumpError(dwErr, Ret, "GetCAProperty");
	}


    *ppCRLCtxt = CertCreateCRLContext(
        CRYPT_ASN_ENCODING,
        (PBYTE)varPropertyValue.bstrVal,
        SysStringByteLen(varPropertyValue.bstrVal));
    if (*ppCRLCtxt == NULL)
    {
        dwErr = GetLastError();
        _JumpError(dwErr, Ret, "CertCreateCRLContext");
    }

    dwErr = ERROR_SUCCESS;
Ret:
    VariantClear(&varPropertyValue);

    if (pCertAdmin)
        pCertAdmin->Release();

    return dwErr;
}


HRESULT CertSvrCA::GetConfigEntry(
    LPWSTR szConfigSubKey,
    LPWSTR szConfigEntry,
    VARIANT *pvarOut)
{
    HRESULT hr = S_OK;
    ICertAdmin2Ptr pAdmin;
    LPWSTR pwszLocalMachine = NULL;
    CString strConfig = m_pParentMachine->m_strMachineName;

    if(m_pParentMachine->m_strMachineName.IsEmpty())
    {
        hr = myGetMachineDnsName(&pwszLocalMachine);
        _JumpIfError(hr, Err, "myGetMachineDnsName");
        strConfig = pwszLocalMachine;
    }
    
    strConfig += L"\\";
    strConfig += m_strSanitizedName;

    VariantInit(pvarOut);

	hr = m_pParentMachine->GetAdmin2(&pAdmin, true);
    _JumpIfError(hr, Err, "GetAdmin2");

    hr = pAdmin->GetConfigEntry(
            _bstr_t(strConfig.GetBuffer()),
            _bstr_t(szConfigSubKey),
            _bstr_t(szConfigEntry),
            pvarOut);
    _JumpIfError2(hr, Err, "GetConfigEntry", 
        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

Err:
    LOCAL_FREE(pwszLocalMachine);
    return hr;
}



HRESULT CertSvrCA::SetConfigEntry(
    LPWSTR szConfigSubKey,
    LPWSTR szConfigEntry,
    VARIANT *pvarIn)
{
    HRESULT hr = S_OK;
    ICertAdmin2Ptr pAdmin;
    LPWSTR pwszLocalMachine = NULL;
    CString strConfig = m_pParentMachine->m_strMachineName;

    if(m_pParentMachine->m_strMachineName.IsEmpty())
    {
        hr = myGetMachineDnsName(&pwszLocalMachine);
        _JumpIfError(hr, Err, "myGetMachineDnsName");
        strConfig = pwszLocalMachine;
    }
    
    strConfig += L"\\";
    strConfig += m_strSanitizedName;

	hr = m_pParentMachine->GetAdmin2(&pAdmin, true);
    _JumpIfError(hr, Err, "GetAdmin2");

    hr = pAdmin->SetConfigEntry(
            _bstr_t(strConfig.GetBuffer()),
            _bstr_t(szConfigSubKey),
            _bstr_t(szConfigEntry),
            pvarIn);
    _JumpIfError(hr, Err, "SetConfigEntry");

Err:
    LOCAL_FREE(pwszLocalMachine);
    return hr;
}

////////////////////////////////////////////////////////////////
// CertStor stub
DWORD CertSvrCA::GetRootCertStore(HCERTSTORE* phCertStore)
{
    if (m_fRootStoreOpenAttempted)
    {
        *phCertStore = m_hRootCertStore;
        return m_hrRootCertStoreOpen;
    }
    m_fRootStoreOpenAttempted = TRUE;

    LONG dwRet;
    CString cstrCertStorePath;

    if (! m_pParentMachine->IsLocalMachine())
    {
        // if remote, prefix with "\\mattt3\"
        cstrCertStorePath = m_strServer;
        cstrCertStorePath += L"\\";
    }
    cstrCertStorePath += wszROOT_CERTSTORE;

    m_hRootCertStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM,
        CRYPT_ASN_ENCODING,
        NULL,   // hCryptProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE | 
        CERT_STORE_OPEN_EXISTING_FLAG   |
        CERT_STORE_MAXIMUM_ALLOWED_FLAG,
        (const void *)(LPCWSTR)cstrCertStorePath);
    if (m_hRootCertStore == NULL)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "CertOpenStore");
    }
   
    dwRet = ERROR_SUCCESS;
Ret:
    *phCertStore = m_hRootCertStore;
    m_hrRootCertStoreOpen = HRESULT_FROM_WIN32(dwRet);

    return dwRet;
}

DWORD CertSvrCA::GetCACertStore(HCERTSTORE* phCertStore)
{
    if (m_fCertStoreOpenAttempted)
    {
        *phCertStore = m_hCACertStore;
        return m_hrCACertStoreOpen;
    }
    m_fCertStoreOpenAttempted = TRUE;

    LONG dwRet;
    CString cstrCertStorePath;
    
    if (! m_pParentMachine->IsLocalMachine())
    {
        // if remote, prefix with "\\mattt3\"
        cstrCertStorePath = m_strServer;
        cstrCertStorePath += L"\\";
    }
	cstrCertStorePath += wszCA_CERTSTORE;

    m_hCACertStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM,
        CRYPT_ASN_ENCODING,
        NULL,   // hCryptProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE | 
        CERT_STORE_OPEN_EXISTING_FLAG   |
        CERT_STORE_MAXIMUM_ALLOWED_FLAG,
        (const void *)(LPCWSTR)cstrCertStorePath);
    if (m_hCACertStore == NULL)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "CertOpenStore");
    }
   
    dwRet = ERROR_SUCCESS;
Ret:

    *phCertStore = m_hCACertStore;
    m_hrCACertStoreOpen = HRESULT_FROM_WIN32(dwRet);

    return dwRet;
}

DWORD CertSvrCA::GetKRACertStore(HCERTSTORE* phCertStore)
{
    if (m_fKRAStoreOpenAttempted)
    {
        *phCertStore = m_hKRACertStore;
        return m_hrKRACertStoreOpen;
    }
    m_fKRAStoreOpenAttempted = TRUE;

    LONG dwRet;
    CString cstrCertStorePath;
    
/*
    if (! m_pParentMachine->IsLocalMachine())
    {
        // if remote, prefix with "\\mattt3\"
        cstrCertStorePath = m_strServer;
        cstrCertStorePath += L"\\";
    }
    cstrCertStorePath += wszKRA_CERTSTORE;
*/
    cstrCertStorePath = wszKRA_CERTSTORE;

    m_hKRACertStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM,
        CRYPT_ASN_ENCODING,
        NULL,   // hCryptProv
        CERT_SYSTEM_STORE_LOCAL_MACHINE|
        CERT_STORE_MAXIMUM_ALLOWED_FLAG,
        (const void *)(LPCWSTR)cstrCertStorePath);
    if (m_hKRACertStore == NULL)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "CertOpenStore");
    }
   
    dwRet = ERROR_SUCCESS;
Ret:
    *phCertStore = m_hKRACertStore;
    m_hrKRACertStoreOpen = HRESULT_FROM_WIN32(dwRet);

    return dwRet;
}

//////////////////////////
// CertSvrMachine class
CertSvrMachine::CertSvrMachine()
{
    m_dwServiceStatus = ERROR_SERVICE_NOT_ACTIVE;

    m_hCachedConfigBaseKey = NULL;
    m_bAttemptedBaseKeyOpen = FALSE;
    
    m_fLocalIsKnown = FALSE;

    m_fIsWhistlerMachine = FALSE;
    m_fIsWhistlerMachineKnown = FALSE;

    m_cRef = 1; // one "Release()" will initiate clean up

}

CertSvrMachine::~CertSvrMachine()
{
    CSASSERT(m_cRef == 0);
    // delete any CAs that we still hold on to -- we own this memory
    for (int i=0; i<m_CAList.GetSize(); i++)
    {
        delete m_CAList[i];
    }

    Init();
}

void CertSvrMachine::Init()
{
    // on initialization, caller owns memory contents of m_CAList --
    // we no longer do
    m_dwServiceStatus = ERROR_SERVICE_NOT_ACTIVE;

    if (m_hCachedConfigBaseKey)
    {
        RegCloseKey(m_hCachedConfigBaseKey);
        m_hCachedConfigBaseKey = NULL;
    }
    m_bAttemptedBaseKeyOpen = FALSE;

    // clean other objects
    m_CAList.Init();    // scope owns memory
    m_strMachineNamePersist.Init();
    m_strMachineName.Init();
}


BOOL CertSvrMachine::FIsWhistlerMachine()
{
    HRESULT hr = S_OK;
    VARIANT varTmp;
    VariantInit(&varTmp);

    if(!m_fIsWhistlerMachineKnown)
    {
        hr = GetRootConfigEntry(
                wszREGVERSION,
                &varTmp);
        _JumpIfError(hr, Err, "GetConfigEntry");

        DBGPRINT((DBG_SS_INFO, "Found version: 0x%x", V_I4(&varTmp)));

        CSASSERT ((V_VT(&varTmp)== VT_I4));
        m_fIsWhistlerMachine =  (CSVER_EXTRACT_MAJOR(V_I4(&varTmp)) >= CSVER_MAJOR_WHISTLER); // bigger than or equal to major Whistler version? return TRUE!
        m_fIsWhistlerMachineKnown = TRUE;
        DBGPRINT((DBG_SS_INFO, m_fIsWhistlerMachine?"This is a Whistler CA":"This is a Win2k CA"));
    }

Err:

    VariantClear(&varTmp);
    return m_fIsWhistlerMachine;
}

HRESULT CertSvrMachine::GetRootConfigEntry(
    LPWSTR szConfigEntry,
    VARIANT *pvarOut)
{
    HRESULT hr = S_OK;
    ICertAdmin2Ptr pAdmin;
    LPWSTR pwszLocalMachine = NULL;
    CString strConfig = m_strMachineName;

    if(m_strMachineName.IsEmpty())
    {
        hr = myGetMachineDnsName(&pwszLocalMachine);
        _JumpIfError(hr, Err, "myGetMachineDnsName");
        strConfig = pwszLocalMachine;
    }
    
    VariantInit(pvarOut);

    hr = GetAdmin2(&pAdmin, true);
    _JumpIfError(hr, Err, "GetAdmin2");

    hr = pAdmin->GetConfigEntry(
            _bstr_t(strConfig.GetBuffer()),
            NULL,
            _bstr_t(szConfigEntry),
            pvarOut);
    _JumpIfError(hr, Err, "GetConfigEntry");

Err:
    LOCAL_FREE(pwszLocalMachine);
    return hr;

}

HRESULT CertSvrMachine::GetAdmin(ICertAdmin** ppAdmin)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;

    if (!IsCertSvrServiceRunning())
    {
        *ppAdmin = NULL;
        return RPC_S_NOT_LISTENING;
    }

    // ensure this thread initialized
    hr = CoInitialize(NULL);
    if ((S_OK == hr) || (S_FALSE == hr))
        fCoInit = TRUE;

    // create interface, pass back
    hr = CoCreateInstance(
			CLSID_CCertAdmin,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertAdmin,
			(void **) ppAdmin);
    _PrintIfError(hr, "CoCreateInstance");

    if (fCoInit)
        CoUninitialize();

    return hr;
}

HRESULT CertSvrMachine::GetAdmin2(
    ICertAdmin2** ppAdmin, 
    bool fIgnoreServiceDown /* = false*/)
{
    HRESULT hr = S_OK, hr1;
    BOOL fCoInit = FALSE;

    if (!fIgnoreServiceDown && !IsCertSvrServiceRunning())
    {
        *ppAdmin = NULL;
        return RPC_S_NOT_LISTENING;
    }

    hr1 = CoInitialize(NULL);
    if ((S_OK == hr1) || (S_FALSE == hr1))
        fCoInit = TRUE;

    // create interface, pass back
    hr = CoCreateInstance(
			CLSID_CCertAdmin,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertAdmin2,
			(void **) ppAdmin);
    _PrintIfError(hr, "CoCreateInstance");

    if (fCoInit)
        CoUninitialize();


    return hr;
}

#define STARTSTOP_MAX_RETRY_SECONDS 30

DWORD CertSvrMachine::CertSvrStartStopService(HWND hwndParent, BOOL fStartSvc)
{
    DWORD       dwRet;
    SC_HANDLE   schService = NULL;
    SC_HANDLE   schSCManager = NULL;
    SERVICE_STATUS ServiceStatus;
    HANDLE hProgressDlg = NULL;

    CWaitCursor cwait;

    ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    schSCManager = OpenSCManagerW(
                        GetNullMachineName(&m_strMachineName),// machine (NULL == local)
                        NULL,               // database (NULL == default)
                        SC_MANAGER_CONNECT  // access required
                        );
    if ( NULL == schSCManager )
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "OpenSCManagerW");
    }

    schService = OpenServiceW(
                    schSCManager,
                    wszSERVICE_NAME,
                    ( fStartSvc ? SERVICE_START : SERVICE_STOP ) | SERVICE_QUERY_STATUS 
                    );

    if (NULL == schService)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "OpenServiceW");
    }


    // UNDONE: TRY/EXCEPT
    hProgressDlg = StartProgressDlg(
                        g_hInstance, 
                        hwndParent, 
                        STARTSTOP_MAX_RETRY_SECONDS, 
                        0,
                        fStartSvc ? IDS_STARTING_SVC : IDS_STOPPING_SVC);

    //
    // try to start the service
    //
    if (fStartSvc)
    {
        if (!StartService( schService, 0, NULL))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_SERVICE_ALREADY_RUNNING)
                dwRet = ERROR_SUCCESS;
            _JumpError2(dwRet, Ret, "StartService", ERROR_SUCCESS);
        }
    }
    else
    {
        if (! ControlService( schService, SERVICE_CONTROL_STOP, &ServiceStatus ) )
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_SERVICE_NOT_ACTIVE)
                dwRet = ERROR_SUCCESS;
            _JumpError2(dwRet, Ret, "ControlService", ERROR_SUCCESS);
        }
    }

    while( QueryServiceStatus( schService, &ServiceStatus ) )
    {
        //
        // FProgressDlgRunning sets upper time bound on loop 
        //

        if( !FProgressDlgRunning() )
            break;

        if (fStartSvc)
        {
            // demorgan's on (pending OR (running AND !pausable))

            if ((ServiceStatus.dwCurrentState != (DWORD) SERVICE_START_PENDING) &&      // not pending AND
                ((ServiceStatus.dwCurrentState != (DWORD) SERVICE_RUNNING) ||           // (not running OR is pausable)
                 (0 != (ServiceStatus.dwControlsAccepted & (DWORD) SERVICE_ACCEPT_PAUSE_CONTINUE) )) )
               break;
        }
        else
        {
            if (ServiceStatus.dwCurrentState != (DWORD) SERVICE_STOP_PENDING)
                break;
        }

        Sleep( 500 );
    }

    if ( ServiceStatus.dwCurrentState != (DWORD)(fStartSvc ? SERVICE_RUNNING : SERVICE_STOPPED))
    {
        dwRet = ServiceStatus.dwWin32ExitCode;

        if (ERROR_SERVICE_SPECIFIC_ERROR  == dwRet)
            dwRet = ServiceStatus.dwServiceSpecificExitCode;

        _JumpError(dwRet, Ret, "ServiceStatus.dwServiceSpecificExitCode");
    }
    dwRet = ERROR_SUCCESS;

Ret:
    if (hProgressDlg)
        EndProgressDlg(hProgressDlg);

    if (schService)
        CloseServiceHandle(schService);
    if (schSCManager)
        CloseServiceHandle(schSCManager);

    if (ERROR_SUCCESS == dwRet)
        m_dwServiceStatus = ServiceStatus.dwCurrentState;
    else
        m_dwServiceStatus = SERVICE_STOPPED;

    return dwRet;
}

DWORD CertSvrMachine::RefreshServiceStatus()
{
    DWORD       dwRet;
    SC_HANDLE   schService = NULL;
    SC_HANDLE   schSCManager = NULL;
    SERVICE_STATUS ServiceStatus;

    HCURSOR hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    m_dwServiceStatus = 0;

    schSCManager = OpenSCManagerW(
                        GetNullMachineName(&m_strMachineName),// machine (NULL == local)
                        NULL,               // database (NULL == default)
                        SC_MANAGER_CONNECT  // access required
                        );
    if ( NULL == schSCManager )
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "OpenSCManagerW");
    }

    schService = OpenServiceW(
                    schSCManager,
                    wszSERVICE_NAME,
                    SERVICE_INTERROGATE
                    );

    if (NULL == schService)
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "OpenServiceW");
    }


    if (!ControlService(schService, SERVICE_CONTROL_INTERROGATE, &ServiceStatus) )
    {
        dwRet = GetLastError();
        if (dwRet != ERROR_SERVICE_NOT_ACTIVE)
        {
            _JumpError(dwRet, Ret, "ControlService");
        }
    }

    m_dwServiceStatus = ServiceStatus.dwCurrentState;

    
    dwRet = ERROR_SUCCESS;
Ret:
    SetCursor(hPrevCur);

    if (schService)
        CloseServiceHandle(schService);
    if (schSCManager)
        CloseServiceHandle(schSCManager);

    return dwRet;
}

LPCWSTR CertSvrMachine::GetCaCommonNameAtPos(DWORD iPos)
{
//    if (iPos > (m_cCAList-1))
    if (iPos > (DWORD)m_CAList.GetUpperBound())
        return NULL;

    return GetCaAtPos(iPos)->m_strCommonName;
}

CertSvrCA* CertSvrMachine::GetCaAtPos(DWORD iPos)
{
//    if (iPos > (m_cCAList-1))
    if (iPos > (DWORD)m_CAList.GetUpperBound())
        return NULL;

    return m_CAList[iPos];
//    return m_rgpCAList[iPos];
}

DWORD CertSvrMachine::PrepareData(HWND hwndParent)
{
    // hwndParent: we will display a dlg describing what we're waiting for

    HANDLE hDlg = NULL;
    DWORD dwRet; 
    
    dwRet = ERROR_SUCCESS;
    __try
    {
        CSASSERT(hwndParent);
        hDlg = StartProgressDlg(g_hInstance, hwndParent, 10, 0, IDS_CA_REDISCOVER);    // don't time out
   
        dwRet = RefreshServiceStatus();
        _LeaveIfError(dwRet, "RefreshServiceStatus");
    
        dwRet = RetrieveCertSvrCAs(0);
        _LeaveIfError(dwRet, "RetrieveCertSvrCAs");
    }
    __finally
    {
        if (hDlg)
            EndProgressDlg(hDlg);
    }

    return dwRet;
}



#include "csdisp.h"

DWORD
CertSvrMachine::RetrieveCertSvrCAs(
    IN DWORD /* Flags */ )
{
    HRESULT hr;
    LONG Index;
    LPWSTR szTargetMachine = NULL;
    LPWSTR szTargetMachine2 = NULL;
    WCHAR* szRegActive; // no delete;
    LPWSTR pwszzCAList = NULL;
    ICertAdmin2Ptr pAdmin;
    LPWSTR pwszSanitizedName = NULL;
    LPWSTR pwszCAList = NULL;
    size_t len;
    bool fNameIsAlreadySanitized = false;
    DWORD dwVersion;
    CertSvrCA *pIssuer = NULL;

    // init var containing machine sans whacks
    Index = sizeof(szTargetMachine);
    if (!m_strMachineName.IsEmpty())
    {
        const WCHAR* pch = (LPCWSTR)m_strMachineName;
        // skip whack whack
        if ((pch[0] == '\\') && (pch[1] == '\\'))
            pch+=2;
        
        szTargetMachine = (LPWSTR)LocalAlloc(LPTR, WSZ_BYTECOUNT(pch));
        _JumpIfOutOfMemory(hr, error, szTargetMachine);

        wcscpy(szTargetMachine, pch);
    }
    else
    {
        hr = myGetComputerNames(&szTargetMachine, &szTargetMachine2);
        _JumpIfError(hr, error, "myGetComputerNames");
    }

    // Don't go to DS for this, just RegConnect
    // DS would give us: strConfig, szMachine, and Template info.
    // we already can derive strConfig, szMachine; we weren't using template info here

    // look for CAs that aren't yet completely set up
    do 
    {
        DWORD dwType;

        hr = myPingCertSrv(
                   szTargetMachine,
                   NULL,
                   &pwszzCAList,
                   NULL,
                   NULL,
                   &dwVersion,
                   NULL);

        if(S_OK==hr)
        {
            if(dwVersion<2)
                hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
            _JumpIfError(hr, error, "Whistler CA snapin cannot connect to older CAs");
        }


        // If for any reason we couldn't ping the CA, fail over to 
        // registry; we currently support only one CA per machine, if this
        // changes in the future, replace the code below with an enumeration
        // of nodes under configuration regkey.
        if(S_OK!=hr)
        {
            hr = myGetCertRegValue(
                szTargetMachine,
                NULL,
                NULL,
                NULL,
                wszREGACTIVE,
                (BYTE**)&pwszCAList,
                NULL,
                &dwType);
            _JumpIfError(hr, error, "myGetCertRegValue");

            CSASSERT(dwType==REG_SZ);

            len = wcslen(pwszCAList)+1;
            pwszzCAList = (LPWSTR)LocalAlloc(LMEM_FIXED, (len+1)*sizeof(WCHAR));
            _JumpIfAllocFailed(pwszzCAList, error);

            wcscpy(pwszzCAList, pwszCAList);
            pwszzCAList[len] = L'\0';

            // regactive gives us already sanitized ca name
            fNameIsAlreadySanitized = true;
        }
        _JumpIfError(hr, error, "myPingCertSrv");

        szRegActive = pwszzCAList;

        while (szRegActive && szRegActive[0] != '\0') // while we don't hit end-of-string
        {
            for (int ii=0; ii<m_CAList.GetSize(); ii++)
            {
                // Common name match? break early
                if (m_CAList[ii]->m_strCommonName.IsEqual(szRegActive))
                    break;
            }

            // not found?
            if (ii == m_CAList.GetSize())
            {
                // and insert it into the list
                pIssuer = new CertSvrCA(this);
                _JumpIfOutOfMemory(hr, error, pIssuer);

                pIssuer->m_strServer = szTargetMachine;

                if(!fNameIsAlreadySanitized)
                {
                    hr = mySanitizeName(szRegActive, &pwszSanitizedName);
                    _JumpIfError(hr, error, "mySanitizeName");

                    pIssuer->m_strSanitizedName = pwszSanitizedName;
                }
                else
                {
                    pIssuer->m_strSanitizedName = szRegActive;
                }

                variant_t varCommonName;
            
                // get prettified common name 
                hr = pIssuer->GetConfigEntry(
                        NULL, 
                        wszREGCOMMONNAME, 
                        &varCommonName);
                _JumpIfError(hr, error, "GetConfigEntry");

                if (V_VT(&varCommonName)!=VT_BSTR || 
                    V_BSTR(&varCommonName)==NULL)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
                    _JumpError(hr, error, "GetConfigEntry");
                }

                pIssuer->m_strCommonName = V_BSTR(&varCommonName);
                varCommonName.Clear();

                // config is common name (not sanitized)
                pIssuer->m_strConfig = szTargetMachine;
                pIssuer->m_strConfig += L"\\";
                pIssuer->m_strConfig += pIssuer->m_strCommonName;

                // Last: get description if exists
                if (S_OK == pIssuer->GetConfigEntry(
                        NULL, 
                        wszREGCADESCRIPTION, 
                        &varCommonName))
                {
                    if (V_VT(&varCommonName)==VT_BSTR &&
                        V_BSTR(&varCommonName)!=NULL)
                    {
                        pIssuer->m_strComment = V_BSTR(&varCommonName);
                    }
                }

                // create oft-used bstr 
                pIssuer->m_bstrConfig = pIssuer->m_strConfig.AllocSysString();
                _JumpIfOutOfMemory(hr, error, pIssuer->m_bstrConfig);

                m_CAList.Add(pIssuer);
		pIssuer = NULL;
            }

            // REG_MULTI_SZ: fwd to next string
            szRegActive += wcslen(szRegActive)+1;
        }

    } while(0);

error:
    delete pIssuer;
    LOCAL_FREE(pwszzCAList);
    LOCAL_FREE(pwszSanitizedName);
    LOCAL_FREE(pwszCAList);

    if (szTargetMachine)
        LocalFree(szTargetMachine);

    if (szTargetMachine2)
        LocalFree(szTargetMachine2);

    return(hr);
}


STDMETHODIMP 
CertSvrMachine::Load(IStream *pStm)
{
    CSASSERT(pStm);
    HRESULT hr;

    // no header magic ?

    // Read the string
    hr = CStringLoad(m_strMachineNamePersist, pStm);
    m_strMachineName = m_strMachineNamePersist;

    if (FAILED(hr))
        return E_FAIL;

    return S_OK;
}

STDMETHODIMP 
CertSvrMachine::Save(IStream *pStm, BOOL fClearDirty)
{
    CSASSERT(pStm);
    HRESULT hr;

    // no header magic ?

    // save the string
    hr = CStringSave(m_strMachineNamePersist, pStm, fClearDirty);
    _PrintIfError(hr, "CStringSave");

    // Verify that the write operation succeeded
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    return S_OK;
}

STDMETHODIMP CertSvrMachine::GetSizeMax(int *pcbSize)
{
    CSASSERT(pcbSize);

    *pcbSize = (m_strMachineNamePersist.GetLength()+1)* sizeof(WCHAR);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\certwrap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certwrap.h
//
//--------------------------------------------------------------------------

#ifndef _CERTWRAP_H_
#define _CERTWRAP_H_

#include <iads.h>
#include <adshlp.h>

// fwd
class CertSvrMachine;


class CertSvrCA
{
protected:

    HCERTSTORE          m_hCACertStore;          // our cert store
    BOOL                m_fCertStoreOpenAttempted;
    HRESULT             m_hrCACertStoreOpen;

    HCERTSTORE          m_hRootCertStore;        // root store on machine
    BOOL                m_fRootStoreOpenAttempted;
    HRESULT             m_hrRootCertStoreOpen;

    HCERTSTORE          m_hKRACertStore;        // KRA store on machine
    BOOL                m_fKRAStoreOpenAttempted;
    HRESULT             m_hrKRACertStoreOpen;

    BOOL 		m_fIsUsingDS;
    BOOL 		m_fIsUsingDSKnown;

    ENUM_CATYPES	m_enumCAType;
    BOOL 		m_fCATypeKnown;

    BOOL m_fAdvancedServer;
    BOOL m_fAdvancedServerKnown;

    DWORD m_dwRoles;
    BOOL  m_fRolesKnown;


public:
    CertSvrMachine*     m_pParentMachine;

    CString m_strServer;
    CString m_strCommonName;
    CString m_strSanitizedName;
    CString m_strConfig;
    CString m_strComment;
    CString m_strCAObjectDN;

    BSTR    m_bstrConfig;   // oft used as BSTR
public:
    CertSvrCA(CertSvrMachine* pParent);
    ~CertSvrCA();

public:

    DWORD GetMyRoles();
    BOOL AccessAllowed(DWORD dwAccess);

    HRESULT GetConfigEntry(
            LPWSTR szConfigSubKey,
            LPWSTR szConfigEntry, 
            VARIANT *pvarOut);

    HRESULT SetConfigEntry(
            LPWSTR szConfigSubKey,
            LPWSTR szConfigEntry, 
            VARIANT *pvarIn);

    DWORD DeleteConfigEntry(
        LPWSTR szConfigSubKey,
        LPWSTR szConfigEntry);

    ENUM_CATYPES GetCAType();
    BOOL  FIsUsingDS();
    BOOL  FIsIncompleteInstallation();
    BOOL  FIsRequestOutstanding();
    BOOL  FIsAdvancedServer();
    BOOL  FDoesSecurityNeedUpgrade();
    BOOL  FDoesServerAllowForeignCerts();


    DWORD GetCACertStore(HCERTSTORE* phCertStore);  // class frees
    DWORD GetRootCertStore(HCERTSTORE* phCertStore); // class frees
    DWORD GetKRACertStore(HCERTSTORE* phCertStore); // class frees

	DWORD GetCurrentCRL(PCCRL_CONTEXT* ppCRLCtxt, BOOL fBaseCRL); // use CertFreeCRLContext()
	DWORD GetCRLByKeyIndex(PCCRL_CONTEXT* ppCRLCtxt, BOOL fBaseCRL, int iKeyIndex); // use CertFreeCRLContext()
	DWORD GetCACertByKeyIndex(PCCERT_CONTEXT*ppCertCtxt, int iKeyIndex); // use CertFreeCertificateContext()

    HRESULT FixEnrollmentObject();
    HRESULT CleanSetupStatusBits(DWORD dwBitsToClean);

protected:

    HRESULT IsCAAllowedFullControl(
        PSECURITY_DESCRIPTOR pSDRead,
        PSID pSid,
        bool& fAllowed);
   
    HRESULT AllowCAFullControl(
        PSECURITY_DESCRIPTOR pSDRead,
        PSID pSid,
        PSECURITY_DESCRIPTOR& pSDWrite);

    HRESULT GetCAFlagsFromDS(
        PDWORD pdwFlags);

    HRESULT _GetSetupStatus(DWORD &rdwStatus);
    HRESULT _SetSetupStatus(DWORD dwStatus);

};

class CertSvrMachine
{
friend CComponentDataImpl;

public:

// IPersistStream interface members
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(int *pcbSize);

#if DBG
    bool m_bInitializedCD;
    bool m_bLoadedCD;
    bool m_bDestroyedCD;
#endif

public:
    CString m_strMachineNamePersist;	// Machine name to persist into .msc file
    CString m_strMachineName;           // Effective machine name

    DWORD   m_dwServiceStatus;          // 

    HKEY    m_hCachedConfigBaseKey;     // base registry key
    BOOL    m_bAttemptedBaseKeyOpen;

    BOOL 		m_fIsWhistlerMachine;
    BOOL 		m_fIsWhistlerMachineKnown;

protected:

    CArray<CertSvrCA*, CertSvrCA*> m_CAList;

public:
    CertSvrMachine();
    ~CertSvrMachine();

    ULONG AddRef() { return(InterlockedIncrement(&m_cRef)); }
    ULONG Release() 
    { 
        ULONG cRef = InterlockedDecrement(&m_cRef);

        if (0 == cRef)
        {
	    delete this;
        }
        return cRef;
    }

private:
    DWORD RetrieveCertSvrCAs(DWORD dwFlags);

    LONG m_cRef;

    BOOL m_fLocalIsKnown, m_fIsLocal;

    void Init();

public:
    HRESULT GetAdmin(ICertAdmin** ppAdmin);
    HRESULT GetAdmin2(ICertAdmin2** ppAdmin, bool fIgnoreServiceDown = false);

    // Fills local cache with CAs for current machine
    DWORD   PrepareData(HWND hwndParent);

    // enum CAs on current machine
    LPCWSTR GetCaCommonNameAtPos(DWORD iPos);
    CertSvrCA* GetCaAtPos(DWORD iPos);


    HRESULT GetRootConfigEntry(
        LPWSTR szConfigEntry,
        VARIANT *pvarOut);

    DWORD GetCaCount()
    { return m_CAList.GetSize(); }

    BOOL  FIsWhistlerMachine();

    // control CA on current machine
    DWORD   CertSvrStartStopService(HWND hwndParent, BOOL fStartSvc);
    DWORD   RefreshServiceStatus();
    DWORD   GetCertSvrServiceStatus()
        { return m_dwServiceStatus; };
    BOOL    IsCertSvrServiceRunning()
        { return (m_dwServiceStatus == SERVICE_RUNNING); };

    BOOL    IsLocalMachine() 
    { 
        if (!m_fLocalIsKnown) 
        {
            m_fLocalIsKnown = TRUE; 
            m_fIsLocal = FIsCurrentMachine(m_strMachineName);
        }
        return m_fIsLocal;
    };

};



#endif // _CERTWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\compdata.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// Compdata.h : Declaration of the CComponentDataImpl

#ifndef _COMPDATA_H_
#define _COMPDATA_H_

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

class CFolder; 


/////////////////////////////
// File Versions

// current version
// VER_CCOMPDATA_SAVE_STREAM_3 includes dwFlags,
// m_cLastKnownSchema, m_rgLastKnownSchema
#define VER_CCOMPDATA_SAVE_STREAM_3  0x003

// version written through Win2000 beta 3 
#define VER_CCOMPDATA_SAVE_STREAM_2  0x002
/////////////////////////////


// CCompDataImpl dwFlags
#define WSZ_MACHINE_OVERRIDE_SWITCH L"/MACHINE:"



#define CERTMMC_PROPERTY_CHANGE_REFRESHVIEWS  0x200

// Note - This is the offset in my image list that represents the folder
enum IMAGE_INDEXES
{
    IMGINDEX_FOLDER = 0,
    IMGINDEX_FOLDER_OPEN,
    IMGINDEX_CRL,
    IMGINDEX_CERT,
    IMGINDEX_PENDING_CERT,
    IMGINDEX_CERTSVR,
    IMGINDEX_CERTSVR_RUNNING,
    IMGINDEX_CERTSVR_STOPPED,
    IMGINDEX_NO_IMAGE,
};

// Event Values
#define IDC_STOPSERVER              0x100
#define IDC_STARTSERVER             0x101

#define IDC_PUBLISHCRL              0x110
#define IDC_REVOKECERT              0x112
#define IDC_RESUBMITREQUEST         0x113
#define IDC_DENYREQUEST             0x114
#define IDC_BACKUP_CA               0x115
#define IDC_RESTORE_CA              0x116
#define IDC_INSTALL_CA              0x117
#define IDC_REQUEST_CA              0x118
#define IDC_ROLLOVER_CA             0x119
#define IDC_SUBMITREQUEST           0x11a

#define IDC_VIEW_CERT_PROPERTIES    0x140
#define IDC_VIEW_ALLRECORDS         0x141
#define IDC_VIEW_FILTER             0x142
#define IDC_VIEW_ATTR_EXT           0x143

#define IDC_RETARGET_SNAPIN         0x150

#define IDC_UNREVOKE_CERT           0x160

#define HTMLHELP_FILENAME L"cs.chm"
#define HTMLHELP_COLLECTION_FILENAME 	L"\\help\\" HTMLHELP_FILENAME 
#define HTMLHELP_COLLECTIONLINK_FILENAME 	L"\\help\\csconcepts.chm"


#define MFS_HIDDEN 0xFFFFFFFF

#define MAX_RESOURCE_STRLEN 256
typedef struct _MY_CONTEXTMENUITEM
{
    CONTEXTMENUITEM item;
    UINT uiString1;
    UINT uiString2;
    DWORD dwRoles;
    WCHAR szString1[MAX_RESOURCE_STRLEN];
    WCHAR szString2[MAX_RESOURCE_STRLEN];
} MY_CONTEXTMENUITEM, *PMY_CONTEXTMENUITEM;


#define TASKITEM_FLAG_RESULTITEM 0x1 
#define TASKITEM_FLAG_LOCALONLY  0x2

typedef struct _TASKITEM
{
    FOLDER_TYPES    type;
    DWORD           dwFlags;
    MY_CONTEXTMENUITEM myitem;
} TASKITEM;


MY_CONTEXTMENUITEM menuItems[];
MY_CONTEXTMENUITEM  taskStartStop[];
TASKITEM        taskItems[];
TASKITEM        viewItems[];
TASKITEM        topItems[];

// ICompData inserted
TASKITEM taskResultItemsSingleSel[];
MY_CONTEXTMENUITEM viewResultItems[];



// m_dwPersistFlags
#define CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE 0x1


class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IPersistStream,
    public CComObjectRoot,
    public ISnapinHelp2
{

BEGIN_COM_MAP(CComponentDataImpl)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP_X()
public:

    friend class CSnapin;
    friend class CDataObject;

    CComponentDataImpl();
    virtual ~CComponentDataImpl();

public:
    virtual const CLSID& GetCoClassID() = 0;
    virtual const BOOL IsPrimaryImpl() = 0;

public:
// ISnapinHelp2 interface members
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);       
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, 
                        LONG_PTR handle, 
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendContextMenu 
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, 
                            LONG *pInsertionAllowed);
    STDMETHOD(Command)(LONG nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

#if DBG
    bool m_bInitializedCD;
    bool m_bLoadedCD;
    bool m_bDestroyedCD;
#endif

// Notify handler declarations
private:
    HRESULT OnDelete(MMC_COOKIE cookie);
    HRESULT OnRemoveChildren(LPARAM arg);
    HRESULT OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);


public:
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();
    LONG _cRefs;

// Scope item creation helpers
private:
    BOOL AddStartStopTasks(
            CFolder *pFolder,
            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
            BOOL fSvcRunning);

    void UpdateScopeIcons();
    HRESULT DisplayProperRootNodeName(HSCOPEITEM hScopeItem);

private:
    CFolder* FindObject(MMC_COOKIE cookie); 

    // display synchronization code
    HRESULT SynchDisplayedCAList(LPDATAOBJECT lpDataObject);
    HRESULT BaseFolderInsertIntoScope(CFolder* pFolder, CertSvrCA* pCA);
    HRESULT CreateTemplateFolders(CertSvrCA* pCA);
    void EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM pParent);

    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);    

private:
    LPCONSOLENAMESPACE2     m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE2              m_pConsole;     // My interface pointer to the console
    HSCOPEITEM              m_pStaticRoot;

    DWORD                   m_dwNextViewIndex; // assign to CComponent to keep them seperate

    BOOL                    m_bIsDirty;
    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    ////////
    // persist

    // General-purpose flags to be persisted into .msc file
    DWORD           m_dwFlagsPersist;				

    CertSvrMachine* m_pCertMachine;
    CFolder*        m_pCurSelFolder;
    
    GUID            m_guidInstance;     // keeps column data straight -- new id for each instance

    DWORD           m_cLastKnownSchema;
    CString*        m_rgcstrLastKnownSchema;
    // end persist
    ///////////////

    // non-persistent schema info
    LONG*           m_rgltypeLastKnownSchema;
    BOOL*           m_rgfindexedLastKnownSchema;

    BOOL            m_fSchemaWasResolved;   // only resolve once
    BOOL            m_fCertView;

public:

    int FindColIdx(IN LPCWSTR szHeading);
    DWORD   GetSchemaEntries() { return m_cLastKnownSchema; }
    HRESULT GetDBSchemaEntry(int iIndex, LPCWSTR* pszHeading, LONG* plType, BOOL* pfIndexed);
    HRESULT SetDBSchema(CString* rgcstr, LONG* rgtype, BOOL* rgfIndexed, DWORD cEntries);

    void ResetPersistedColumnInformation()
    {
	HRESULT hr = UuidCreate(&m_guidInstance);
	UNREFERENCED_PARAMETER(hr);
    }

private:
    CList<CFolder*, CFolder*> m_scopeItemList; 

    BOOL    m_fScopeAlreadyEnumerated;
};


class CComponentDataPrimaryImpl : public CComponentDataImpl,
    public CComCoClass<CComponentDataPrimaryImpl, &CLSID_Snapin>
{
public:
    DECLARE_REGISTRY(CSnapin, _T("CertSvrAdmin Snapin.Snapin.1"), _T("CertSvrAdmin Snapin.Snapin"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID() { return CLSID_Snapin; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }
    
};

#endif // #define _COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\dataobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "stdafx.h"

#define __dwFILE__	__dwFILE_CERTMMC_DATAOBJ_CPP__


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

unsigned int CDataObject::m_cfNodeType       = 0;
unsigned int CDataObject::m_cfNodeID         = 0;
unsigned int CDataObject::m_cfCoClass        = 0; 
unsigned int CDataObject::m_cfNodeTypeString = 0;  
unsigned int CDataObject::m_cfDisplayName    = 0; 

unsigned int CDataObject::m_cfInternal       = 0;
unsigned int CDataObject::m_cfObjInMultiSel  = 0;
unsigned int CDataObject::m_cfIsMultiSel     = 0;
unsigned int CDataObject::m_cfPreloads       = 0;

                                                 

    
// The only additional clipboard format supported is to get the workstation name.
unsigned int CDataObject::m_cfSelectedCA_InstallType  = 0;
unsigned int CDataObject::m_cfSelectedCA_CommonName   = 0;
unsigned int CDataObject::m_cfSelectedCA_SanitizedName= 0;
unsigned int CDataObject::m_cfSelectedCA_MachineName  = 0;
unsigned int CDataObject::m_cfSelectedCA_Roles        = 0;

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations

CDataObject::CDataObject()
{
	USES_CONVERSION;

	m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
    m_cfNodeID         = RegisterClipboardFormat(CCF_COLUMN_SET_ID);
	m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID); 
	m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);  
	m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME); 

    m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL);
    m_cfObjInMultiSel  = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
    m_cfIsMultiSel     = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
    m_cfPreloads       = RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);


    m_cfSelectedCA_InstallType  = RegisterClipboardFormat(SNAPIN_CA_INSTALL_TYPE);
    m_cfSelectedCA_CommonName   = RegisterClipboardFormat(SNAPIN_CA_COMMON_NAME);
    m_cfSelectedCA_MachineName  = RegisterClipboardFormat(SNAPIN_CA_MACHINE_NAME);
    m_cfSelectedCA_SanitizedName   = RegisterClipboardFormat(SNAPIN_CA_SANITIZED_NAME);
    m_cfSelectedCA_Roles = RegisterClipboardFormat(SNAPIN_CA_ROLES);

    m_pComponentData = NULL;
    #ifdef _DEBUG
        dbg_refCount = 0;
    #endif

    m_cbMultiSelData = 0;
    m_bMultiSelDobj = FALSE;

    m_dwViewID = MAXDWORD;
}

STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC lpFormatetc)
{
	HRESULT hr = S_FALSE;

    if ( lpFormatetc )
    {
		const CLIPFORMAT cf = lpFormatetc->cfFormat;

        if ( cf == m_cfIsMultiSel )
        {
        hr = S_FALSE;   // always return this; MMC returns S_OK if ptr to SI_MS_DO 
//            hr = (m_bMultiSelDobj ? S_OK : S_FALSE);
        }
		else if (	cf == m_cfNodeType ||
                    cf == m_cfNodeID ||
					cf == m_cfCoClass ||
					cf == m_cfNodeTypeString ||
					cf == m_cfDisplayName ||
                    cf == m_cfObjInMultiSel ||
					cf == m_cfInternal ||
                    cf == m_cfPreloads ||
                    cf == m_cfSelectedCA_SanitizedName ||
                    cf == m_cfSelectedCA_MachineName ||
                    cf == m_cfSelectedCA_CommonName ||
                    cf == m_cfSelectedCA_InstallType

				)
			{
				hr = S_OK;
			}
    }

    return hr;
}

STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfObjInMultiSel)
    {
        hr = CreateObjInMultiSel(lpMedium);
    }
    else if (cf == m_cfNodeID)
    {
        hr = CreateNodeIDData(lpMedium);
    }

    return hr;
}

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
    else if (cf == m_cfPreloads)
    {
        hr = CreatePreloadsData(lpMedium);
    }
    else if (cf == m_cfSelectedCA_CommonName)
    {
        hr = CreateSelectedCA_CommonName(lpMedium);
    }
    else if (cf == m_cfSelectedCA_SanitizedName)
    {
        hr = CreateSelectedCA_SanitizedName(lpMedium);
    }
    else if (cf == m_cfSelectedCA_MachineName)
    {
        hr = CreateSelectedCA_MachineName(lpMedium);
    }
    else if (cf == m_cfSelectedCA_InstallType)
    {
        hr = CreateSelectedCA_InstallType(lpMedium);
    }
    else if (cf == m_cfSelectedCA_Roles)
    {
        hr = CreateSelectedCA_Roles(lpMedium);
    }
    return hr;
}


STDMETHODIMP
CDataObject::EnumFormatEtc(
    DWORD, // dwDirection
    LPENUMFORMATETC * /* ppEnumFormatEtc */ )
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            ULONG written;

            if (NULL == lpMedium->hGlobal) 
            {
                // always return a valid hGlobal for the caller
                hr = GetHGlobalFromStream(lpStream, &lpMedium->hGlobal);
                if (hr != S_OK)
                    goto err;
            }

            // Write to the stream the number of bytes
            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

err:
    return hr;
}

HRESULT CDataObject::CreateVariableLen(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;
    BYTE* pb;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "Invalid args");
    }

    // Make sure the type medium is HGLOBAL
    lpMedium->tymed = TYMED_HGLOBAL; 

    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, (len));
    _JumpIfOutOfMemory(hr, Ret, lpMedium->hGlobal);

    pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    CopyMemory(pb, pBuffer, len);
    ::GlobalUnlock(lpMedium->hGlobal);

    hr = S_OK;

Ret:
    return hr;
}

const GUID* FolderTypeToNodeGUID(DATA_OBJECT_TYPES type, CFolder* pFolder)
{
    const GUID* pcObjectType = NULL;

    if (pFolder == NULL)
    {
        pcObjectType = &cNodeTypeMachineInstance;
    }
    else if (type == CCT_SCOPE)
    {
        switch (pFolder->GetType())
        {
        case SERVER_INSTANCE:
            pcObjectType = &cNodeTypeServerInstance;
            break;

        case SERVERFUNC_CRL_PUBLICATION:
            pcObjectType = &cNodeTypeCRLPublication;
            break;

        case SERVERFUNC_ISSUED_CERTIFICATES:
            pcObjectType = &cNodeTypeIssuedCerts;
            break;

        case SERVERFUNC_PENDING_CERTIFICATES:
            pcObjectType = &cNodeTypePendingCerts;
            break;

        case SERVERFUNC_FAILED_CERTIFICATES:
            pcObjectType = &cNodeTypeFailedCerts;
            break;

        case SERVERFUNC_ALIEN_CERTIFICATES:
            pcObjectType = &cNodeTypeAlienCerts;
            break;
        
        case SERVERFUNC_ISSUED_CRLS:
            pcObjectType = &cNodeTypeIssuedCRLs;
            break;
        
        default:
            ASSERT(0);
            pcObjectType = &cNodeTypeDynamic;
            break;
        }
    }
    else if (type == CCT_RESULT)
    {
        // RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(m_internal.m_cookie);
        
        pcObjectType = &cObjectTypeResultItem;
    }
    else
    {
        ASSERT(0);
    }

    return pcObjectType;
}

HRESULT CDataObject::CreateNodeIDData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    const GUID* pFolderGuid = NULL;
    PBYTE pbWritePtr;

// Instance guid, node guid, dwViewIndex
#define CDO_CNID_SIZE ( (2*sizeof(GUID))+ sizeof(DWORD) + FIELD_OFFSET(SNodeID2, id) )

    BYTE bSNodeID2[CDO_CNID_SIZE];
    ZeroMemory(bSNodeID2, CDO_CNID_SIZE);
    SNodeID2* psColID = (SNodeID2*)bSNodeID2;

    pFolderGuid = FolderTypeToNodeGUID(m_internal.m_type, reinterpret_cast<CFolder*>(m_internal.m_cookie));
    if (pFolderGuid == NULL)
        return E_FAIL;

    if (m_pComponentData == NULL)
        return E_FAIL;

    // node ID is {GUIDInstance|GUIDNode}
    psColID->cBytes = 2*sizeof(GUID) + sizeof(DWORD);

    pbWritePtr = psColID->id;
    CopyMemory(pbWritePtr, &m_pComponentData->m_guidInstance, sizeof(GUID));
    pbWritePtr += sizeof(GUID);

    CopyMemory(pbWritePtr, pFolderGuid, sizeof(GUID));
    pbWritePtr += sizeof(GUID);

//    ASSERT(m_dwViewID != -1);
//  UNDONE UNDONE: MMC will soon call for this data through IComponent, not IComponentData
//    this will allow us to set this as we desire
    *(DWORD*)pbWritePtr = m_dwViewID;

    // copy structure only
    return CreateVariableLen(reinterpret_cast<const void*>(psColID), CDO_CNID_SIZE, lpMedium);
}

HRESULT CDataObject::CreateObjInMultiSel(LPSTGMEDIUM lpMedium)
{
    HRESULT hr;
    ASSERT(m_cbMultiSelData != 0);

    ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
    if (m_internal.m_cookie != MMC_MULTI_SELECT_COOKIE)
        return E_FAIL;
    
    // copy guid + len
    hr = CreateVariableLen(&m_sGuidObjTypes, m_cbMultiSelData, lpMedium);

//Ret:
    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    const GUID* pcObjectType = NULL;

    pcObjectType = FolderTypeToNodeGUID(m_internal.m_type, reinterpret_cast<CFolder*>(m_internal.m_cookie));
    if (pcObjectType == NULL)
        return E_FAIL;

    return Create(reinterpret_cast<const void*>(pcObjectType), sizeof(GUID), 
                  lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    const WCHAR* cszObjectType = NULL;

    if (m_internal.m_cookie == NULL)
    {
        cszObjectType = cszNodeTypeMachineInstance;
    }
    else if (m_internal.m_type == CCT_SCOPE)
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);
        ASSERT(pFolder != NULL);
        if (pFolder == NULL)
            return E_UNEXPECTED;

        switch (pFolder->GetType())
        {
        case SERVER_INSTANCE:
            cszObjectType = cszNodeTypeServerInstance;
            break;
    
        case SERVERFUNC_CRL_PUBLICATION:
            cszObjectType = cszNodeTypeCRLPublication;
            break;

        case SERVERFUNC_ISSUED_CERTIFICATES:
            cszObjectType = cszNodeTypeIssuedCerts;
            break;

        case SERVERFUNC_PENDING_CERTIFICATES:
            cszObjectType = cszNodeTypePendingCerts;
            break;

        case SERVERFUNC_FAILED_CERTIFICATES:
            cszObjectType = cszNodeTypeFailedCerts;
            break;

        default:
            ASSERT(0);
            cszObjectType = cszNodeTypeDynamic;
            break;
        }
    }
    else if (m_internal.m_type == CCT_RESULT)
    {
        // RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(m_internal.m_cookie);
        
        cszObjectType = cszObjectTypeResultItem;
    }
    else
        return E_UNEXPECTED;

    return Create(cszObjectType, ((wcslen(cszObjectType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name to display
    // Note - if this is not provided, the console will used the snap-in name
    CString strFormat, strMachine, strFinished;
    strFormat.LoadString(IDS_NODENAME_FORMAT);

    if (NULL == m_pComponentData)
        return E_POINTER;

    if (m_pComponentData->m_pCertMachine->m_strMachineName.IsEmpty())
        strMachine.LoadString(IDS_LOCALMACHINE);
    else
        strMachine = m_pComponentData->m_pCertMachine->m_strMachineName;

    strFinished.Format(strFormat, strMachine);

	return Create(strFinished, ((strFinished.GetLength()+1)* sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_CommonName(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();

    ASSERT(pCA != NULL);
    ASSERT(pCA->m_strCommonName.GetLength() != 0);


    // Add 1 for the NULL and calculate the bytes for the stream
    return Create(pCA->m_strCommonName, ((pCA->m_strCommonName.GetLength()+1)*sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_SanitizedName(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();

    ASSERT(pCA != NULL);
    ASSERT(pCA->m_strSanitizedName.GetLength() != 0);


    // Add 1 for the NULL and calculate the bytes for the stream
    return Create(pCA->m_strSanitizedName, ((pCA->m_strSanitizedName.GetLength()+1)* sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_MachineName(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();
    ASSERT(pCA != NULL);
    
    // Add 1 for the NULL and calculate the bytes for the stream
    return Create(pCA->m_strServer, ((pCA->m_strServer.GetLength()+1)* sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_InstallType(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();
    ASSERT(pCA != NULL);
    
    DWORD adwFlags[2] = 
    {
        (DWORD) pCA->GetCAType(),
        (DWORD) pCA->FIsAdvancedServer(),
    };

    return Create(adwFlags, sizeof(adwFlags), lpMedium);
}

HRESULT CDataObject::CreateSelectedCA_Roles(LPSTGMEDIUM lpMedium)
{
    CertSvrCA* pCA = NULL;

    CFolder* pFolder = GetParentFolder(&m_internal);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_UNEXPECTED;

    pCA = pFolder->GetCA();
    ASSERT(pCA != NULL);
    
    DWORD dwRoles = pCA->GetMyRoles();

    return Create(&dwRoles, sizeof(dwRoles), lpMedium);
}


HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}


HRESULT CDataObject::CreatePreloadsData(LPSTGMEDIUM lpMedium)
{
    BOOL bPreload = TRUE;

    return Create((LPVOID)&bPreload, sizeof(bPreload), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\chooser.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       chooser.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	Chooser.h
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef __CHOOSER_H_INCLUDED__
#define __CHOOSER_H_INCLUDED__

#include "tfcprop.h"

LPCTSTR PchGetMachineNameOverride();

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CAutoDeletePropPage
//
//	This object is the backbone for property page
//	that will *destroy* itself when no longer needed.
//	The purpose of this object is to maximize code reuse
//	among the various pages in the snapin wizards.
//
//	INHERITANCE TREE (so far)
//	CAutoDeletePropPage - Base object
//		CChooseMachinePropPage - Dialog to select a machine name
//			CFileMgmtGeneral - Dialog to select "File Services" (snapin\filemgmt\snapmgr.h)
//			CMyComputerGeneral - Dialog for the "My Computer" (snapin\mycomput\snapmgr.h)
//		CChoosePrototyperPropPage - Dialog to select prototyper demo (NYI)
//	
//	HISTORY
//	15-May-1997		t-danm		Creation. Split of CChooseMachinePropPage
//					to allow property pages to have more flexible dialog
//					templates.
//
class CAutoDeletePropPage : public PropertyPage
{
public:
// Construction
	CAutoDeletePropPage(UINT uIDD);
	virtual ~CAutoDeletePropPage();

protected:
// Dialog Data

// Overrides
	virtual BOOL OnSetActive();

// Implementation
protected:
    void OnHelp(LPHELPINFO lpHelp);
    void OnContextHelp(HWND hwnd);
    bool HasContextHelp(int nDlgItem);

    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    
	// This mechanism deletes the CAutoDeletePropPage object
	// when the wizard is finished
	struct
    {
        INT cWizPages;	// Number of pages in wizard
        LPFNPSPCALLBACK pfnOriginalPropSheetPageProc;
    } m_autodeleteStuff;

	static UINT CALLBACK S_PropSheetPageProc(HWND hwnd,	UINT uMsg, LPPROPSHEETPAGE ppsp);


protected:
    CString m_strCaption;               // Covers for MFC4.2's missing support for Wiz97. 
                                        // without this override, CPropertyPage::m_strCaption 
                                        // address is miscalculated and GPF ensues.

	CString m_strHelpFile;				// Name for the .hlp file
	const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs
	
public:
	/////////////////////////////////////////////////////////////////////	
	void SetCaption(UINT uStringID);
	void SetCaption(LPCTSTR pszCaption);
	void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
	void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);
}; // CAutoDeletePropPage


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CChooseMachinePropPage
//
//	This object is a stand-alone property page used to
//	select a computer name.
//
//	The object CChooseMachinePropPage can have its dialog
//	template replaced to allow a new wizard without any new code.
//	The object can also be inherited, allowing easy extentionability.
//
//	RESTRICTIONS:
//	If the user wishes to provide its own dialog template, here
//	are the dialog IDs that must present:
//		IDC_CHOOSER_RADIO_LOCAL_MACHINE - Select local machine.
//		IDC_CHOOSER_RADIO_SPECIFIC_MACHINE - Select a specific machine.
//		IDC_CHOOSER_EDIT_MACHINE_NAME - Edit field to enter the machine name.
//	There are also optional IDs:
//		IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES - Browse to select a machine name.
//		IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME - Checkbox to allow the machine name to be overriden by command line.
//
class CChooseMachinePropPage : public CAutoDeletePropPage
{
public:
	enum { IID_DEFAULT = IDD_CHOOSER_CHOOSE_MACHINE };

public:
// Construction
	CChooseMachinePropPage(UINT uIDD = IID_DEFAULT);
	virtual ~CChooseMachinePropPage();

protected:
	void InitChooserControls();

    // MFC replacements
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    
// Dialog Data
	BOOL m_fIsRadioLocalMachine;
	BOOL m_fEnableMachineBrowse;
    CString	m_strMachineName;
    DWORD* m_pdwFlags;

// Overrides
	public:
	virtual BOOL OnWizardFinish();
	protected:

// Implementation
protected:
	virtual BOOL OnInitDialog();
	void OnRadioLocalMachine();
	void OnRadioSpecificMachine();
    void OnBrowse();


protected:
	CString * m_pstrMachineNameOut;	// OUT: Pointer to the CString object to store the machine name
	CString * m_pstrMachineNameEffectiveOut;	// OUT: Pointer to the CString object to store the effective machine name

public:
	void InitMachineName(LPCTSTR pszMachineName);
	void SetOutputBuffers(
		OUT CString * pstrMachineNamePersist,
		OUT OPTIONAL CString * pstrMachineNameEffective,
        OUT DWORD* m_pdwFlags);

}; // CChooseMachinePropPage


#endif // ~__CHOOSER_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\compdata.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.



#include "stdafx.h"
#include "setupids.h"
#include "resource.h"
#include "genpage.h"  

#include "chooser.h"
#include "misc.h"

#include "csdisp.h" // picker
#include <esent.h>   // database error
#include <aclui.h>
#include <winldap.h>
#include "csldap.h"

#include <atlimpl.cpp>

#define __dwFILE__	__dwFILE_CERTMMC_COMPDATA_CPP__


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



struct FOLDER_DATA
{
    FOLDER_TYPES    type;
    UINT            iNameRscID;
};
static FOLDER_DATA SvrFuncFolderData[] =
{
    {SERVERFUNC_CRL_PUBLICATION, IDS_CERTS_REVOKED},
    {SERVERFUNC_ISSUED_CERTIFICATES, IDS_CERTS_ISSUED},
    {SERVERFUNC_PENDING_CERTIFICATES, IDS_CERTS_PENDING},
    {SERVERFUNC_FAILED_CERTIFICATES, IDS_CERTS_FAILED},
    {SERVERFUNC_ALIEN_CERTIFICATES, IDS_CERTS_IMPORTED},
    {SERVERFUNC_ISSUED_CRLS, IDS_CRL_TITLE},
};
// keep this enum in synch with SvrFuncFolderData[]
enum ENUM_FOLDERS
{
ENUM_FOLDER_CRL=0,
ENUM_FOLDER_ISSUED,
ENUM_FOLDER_PENDING,
ENUM_FOLDER_FAILED,
ENUM_FOLDER_ALIEN,
ENUM_FOLDER_CRLS,
};



// Array of view items to be inserted into the context menu.
// keep this enum in synch with viewItems[]
enum ENUM_TASK_STARTSTOP_ITEMS
{
    ENUM_TASK_START=0,
    ENUM_TASK_STOP, 
    ENUM_TASK_SEPERATOR,
};

MY_CONTEXTMENUITEM  taskStartStop[] = 
{
    {
        {
        L"", L"",
        IDC_STARTSERVER, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0
        },
        IDS_TASKMENU_STARTSERVICE,
        IDS_TASKMENU_STATUSBAR_STARTSERVICE,
        CA_ACCESS_ADMIN,
    },

    {
        {
        L"", L"",
        IDC_STOPSERVER, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0
        },
        IDS_TASKMENU_STOPSERVICE,
        IDS_TASKMENU_STATUSBAR_STOPSERVICE,
        CA_ACCESS_ADMIN,
    },

    {
        { NULL, NULL, 0, 0, 0 },
        IDS_EMPTY,
        IDS_EMPTY,
    },
};


// Array of view items to be inserted into the context menu.
// WARNING: keep this enum in synch with taskItems[]
enum ENUM_TASK_ITEMS
{
    ENUM_TASK_CRLPUB=0,
    ENUM_TASK_ATTREXTS_CRL,
    ENUM_TASK_ATTREXTS_ISS,
    ENUM_TASK_ATTREXTS_PEND,
    ENUM_TASK_ATTREXTS_FAIL,
    ENUM_TASK_DUMP_ASN_CRLPUB,
    ENUM_TASK_DUMP_ASN_ISS,
    ENUM_TASK_DUMP_ASN_PEND,
    ENUM_TASK_DUMP_ASN_FAIL,
    ENUM_TASK_DUMP_ASN_ALIEN,
    ENUM_TASK_DUMP_ASN_CRL,
    ENUM_TASK_SEPERATOR1,
    ENUM_TASK_SEPERATOR4,
    ENUM_TASK_SUBMIT_REQUEST,
    ENUM_TASK_REVOKECERT,
    ENUM_TASK_RESUBMITREQ,
    ENUM_TASK_DENYREQ,
    ENUM_TASK_RESUBMITREQ2,
    ENUM_TASK_SEPERATOR2,
    ENUM_TASK_BACKUP,
    ENUM_TASK_RESTORE,
    ENUM_TASK_SEPERATOR3,
    ENUM_TASK_INSTALL,
    ENUM_TASK_REQUEST,
    ENUM_TASK_ROLLOVER,
};

TASKITEM taskItems[] = 
{ 

    {   SERVERFUNC_CRL_PUBLICATION,
        0,
        {
            {
            L"", L"",
            IDC_PUBLISHCRL, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_PUBLISHCRL,
            IDS_TASKMENU_STATUSBAR_PUBLISHCRL,
            CA_ACCESS_ADMIN,
        }
    },

/////////////////////
// BEGIN ATTR/EXT
    {   SERVERFUNC_CRL_PUBLICATION,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_ATTR_EXT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_VIEWATTREXT,    
            IDS_TASKMENU_STATUSBAR_VIEWATTREXT, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
    {   SERVERFUNC_ISSUED_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_ATTR_EXT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_VIEWATTREXT,    
            IDS_TASKMENU_STATUSBAR_VIEWATTREXT, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
    {   SERVERFUNC_PENDING_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_ATTR_EXT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_VIEWATTREXT,    
            IDS_TASKMENU_STATUSBAR_VIEWATTREXT, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
    {   SERVERFUNC_FAILED_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_ATTR_EXT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_VIEWATTREXT,    
            IDS_TASKMENU_STATUSBAR_VIEWATTREXT, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },

// END ATTR/EXT
/////////////////////

/////////////////////
// BEGIN ENUM_TASK_DUMP_ASN*
    {   SERVERFUNC_CRL_PUBLICATION,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
    {   SERVERFUNC_ISSUED_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
    {   SERVERFUNC_PENDING_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
    {   SERVERFUNC_FAILED_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
    {   SERVERFUNC_ALIEN_CERTIFICATES,     // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
    {   SERVERFUNC_ISSUED_CRLS,         // where
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DUMP_ASN, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DUMPASN,    
            IDS_TASKMENU_STATUSBAR_DUMPASN, 
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },
// END ENUM_TASK_DUMP_ASN*
/////////////////////


    // seperator
    {	SERVERFUNC_ALL_FOLDERS,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
		{
			{
			L"", L"", 
			0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
			},
			IDS_EMPTY,
			IDS_EMPTY,
		}
    },

    // seperator
    {	SERVER_INSTANCE,
        0,       // dwFlags
		{
			{
			L"", L"", 
			0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
			},
			IDS_EMPTY,
			IDS_EMPTY,
		}
    },

    {   SERVER_INSTANCE,
        0,
        {
            {
            L"", L"",
            IDC_SUBMITREQUEST, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_SUBMITREQUEST,
            IDS_TASKMENU_STATUSBAR_SUBMITREQUEST,
            CA_ACCESS_ENROLL,
        }
    },

    {   SERVERFUNC_ISSUED_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_REVOKECERT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_REVOKECERT,
            IDS_TASKMENU_STATUSBAR_REVOKECERT,
            CA_ACCESS_OFFICER,
        }
    },

    {   SERVERFUNC_PENDING_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_RESUBMITREQUEST, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_RESUBMIT,
            IDS_TASKMENU_STATUSBAR_RESUBMIT,
            CA_ACCESS_OFFICER,
        }
    },

    {   SERVERFUNC_PENDING_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_DENYREQUEST, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_DENYREQUEST,
            IDS_TASKMENU_STATUSBAR_DENYREQUEST,
            CA_ACCESS_OFFICER,
        }
    },

    {   SERVERFUNC_FAILED_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_RESUBMITREQUEST, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_RESUBMIT,
            IDS_TASKMENU_STATUSBAR_RESUBMIT,
            CA_ACCESS_OFFICER,
        }
    },

    // seperator
    {	SERVERFUNC_ALL_FOLDERS,
        0,       // dwFlags
		{
			{
			L"", L"", 
			0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
			},
			IDS_EMPTY,
			IDS_EMPTY,
		}
    },

	{   SERVER_INSTANCE,
        TASKITEM_FLAG_LOCALONLY,
        {
            {
            L"", L"",
            IDC_BACKUP_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_BACKUP,
            IDS_TASKMENU_STATUSBAR_BACKUP,
            CA_ACCESS_OPERATOR,
        }
    },

	{   SERVER_INSTANCE,
        TASKITEM_FLAG_LOCALONLY,
        {
            {
            L"", L"",
            IDC_RESTORE_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_RESTORE,
            IDS_TASKMENU_STATUSBAR_RESTORE,
            CA_ACCESS_OPERATOR,
        }
    },

    // seperator
    {	SERVER_INSTANCE,
		0,
		{
			{
			L"", L"", 
			0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
			},
			IDS_EMPTY,
			IDS_EMPTY,
		}
    },


    {   SERVER_INSTANCE,
        0,
        {
            {
            L"", L"",
            IDC_INSTALL_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_INSTALL_CA,
            IDS_TASKMENU_STATUSBAR_INSTALL_CA,
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // not based on roles, enable for all roles
        }
    },

    {   SERVER_INSTANCE,
        0,
        {
            {
            L"", L"",
            IDC_REQUEST_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_REQUEST_CA,
            IDS_TASKMENU_STATUSBAR_REQUEST_CA,
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // not based on roles, enable for all roles
        }
   },

    {   SERVER_INSTANCE,
        TASKITEM_FLAG_LOCALONLY,
        {
            {
            L"", L"",
            IDC_ROLLOVER_CA, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_GRAYED, 0
            },
            IDS_TASKMENU_ROLLOVER,
            IDS_TASKMENU_STATUSBAR_ROLLOVER,
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // not based on roles, enable for all roles
        }
    },


   {   NONE, 
        FALSE, 
        {
            { NULL, NULL, 0, 0, 0 },
            IDS_EMPTY,
            IDS_EMPTY,
        }
    }
};


// Array of view items to be inserted into the context menu.
// keep this enum in synch with topItems[]
enum ENUM_TOP_ITEMS
{
    ENUM_TOP_REVOKEDOPEN=0,
    ENUM_TOP_ISSUEDOPEN,
    ENUM_TOP_ALIENOPEN,
    ENUM_RETARGET_SNAPIN,
};

TASKITEM topItems[] = 
{ 

    {   SERVERFUNC_CRL_PUBLICATION,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_CERT_PROPERTIES, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, CCM_SPECIAL_DEFAULT_ITEM
            },
            IDS_TOPMENU_OPEN,
            IDS_TOPMENU_STATUSBAR_OPEN,
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },

    {   SERVERFUNC_ISSUED_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_CERT_PROPERTIES, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, CCM_SPECIAL_DEFAULT_ITEM
            },
            IDS_TOPMENU_OPEN,
            IDS_TOPMENU_STATUSBAR_OPEN,
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },

    {   SERVERFUNC_ALIEN_CERTIFICATES,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_CERT_PROPERTIES, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, CCM_SPECIAL_DEFAULT_ITEM
            },
            IDS_TOPMENU_OPEN,
            IDS_TOPMENU_STATUSBAR_OPEN,
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },

    {   SERVERFUNC_ISSUED_CRLS,
        TASKITEM_FLAG_RESULTITEM,       // dwFlags
        {
            {
            L"", L"",
            IDC_VIEW_CERT_PROPERTIES, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, CCM_SPECIAL_DEFAULT_ITEM
            },
            IDS_TOPMENU_OPEN,
            IDS_TOPMENU_STATUSBAR_OPEN,
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },

    {
        MACHINE_INSTANCE,
        0,
        {
            {
            L"", L"",
            IDC_RETARGET_SNAPIN, CCM_INSERTIONPOINTID_PRIMARY_TOP, MF_ENABLED, 0
            },
            IDS_RETARGET_SNAPIN,
            IDS_STATUSBAR_RETARGET_SNAPIN,
            CA_ACCESS_MASKROLES|CA_ACCESS_READ, // any role with read acccess
        }
    },

    {   NONE, 
        0, 
        {
            { NULL, NULL, 0, 0, 0 },
            IDS_EMPTY,
            IDS_EMPTY,
        }
    }
};

BOOL g_fCertViewOnly = TRUE;



///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl()
    : m_bIsDirty(TRUE), m_pScope(NULL), m_pConsole(NULL) 
#if DBG
    , m_bInitializedCD(false), m_bDestroyedCD(false)
#endif
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    m_dwFlagsPersist = 0;
    
    m_pStaticRoot = NULL;
    m_pCurSelFolder = NULL;

    m_fScopeAlreadyEnumerated = FALSE;
    m_fSchemaWasResolved = FALSE;   // resolve schema once per load
    m_fCertView = TRUE;

    // checked in ::Initialize, ::CreatePropertyPages
    m_pCertMachine = new CertSvrMachine;

    m_cLastKnownSchema = 0;
    m_rgcstrLastKnownSchema = NULL;
    m_rgltypeLastKnownSchema = NULL;
    m_rgfindexedLastKnownSchema = NULL;

    m_dwNextViewIndex = 0;
}

CComponentDataImpl::~CComponentDataImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pScope == NULL);
    ASSERT(!m_bInitializedCD || m_bDestroyedCD);

    // Delete enumerated scope items
    // note: we don't own pCA memory, m_pCertMachine does
    POSITION pos = m_scopeItemList.GetHeadPosition();
    while (pos)
        delete m_scopeItemList.GetNext(pos);
    m_scopeItemList.RemoveAll();

    m_pCurSelFolder = NULL;
    m_fScopeAlreadyEnumerated = FALSE;

    if (m_pCertMachine)
        m_pCertMachine->Release();

    m_cLastKnownSchema = 0;
    if (m_rgcstrLastKnownSchema)
        delete [] m_rgcstrLastKnownSchema;
    if (m_rgltypeLastKnownSchema)
        delete [] m_rgltypeLastKnownSchema;
    if (m_rgfindexedLastKnownSchema)
        delete [] m_rgfindexedLastKnownSchema;
}


STDMETHODIMP_(ULONG)
CComponentDataImpl::AddRef()
{
    return InterlockedIncrement((LONG *) &_cRefs);
}

STDMETHODIMP_(ULONG)
CComponentDataImpl::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}

int CComponentDataImpl::FindColIdx(IN LPCWSTR szHeading)
{
    for (DWORD dw=0; dw<m_cLastKnownSchema; dw++)
    {
        if (m_rgcstrLastKnownSchema[dw].IsEqual(szHeading))
            return dw;
    }
    
    return -1;
}

HRESULT CComponentDataImpl::GetDBSchemaEntry(
            IN int iIndex, 
            OUT OPTIONAL LPCWSTR* pszHeading, 
            OUT OPTIONAL LONG* plType, 
            OUT OPTIONAL BOOL* pfIndexed)
{
    if (m_cLastKnownSchema<= (DWORD)iIndex)
        return HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);

    if (pszHeading)
        *pszHeading = m_rgcstrLastKnownSchema[iIndex];
    if (plType)
        *plType = m_rgltypeLastKnownSchema[iIndex];
    if (pfIndexed)
        *pfIndexed = m_rgfindexedLastKnownSchema[iIndex];

    return S_OK;
}

HRESULT CComponentDataImpl::SetDBSchema(
            IN CString* rgcstr, 
            LONG* rgtype, 
            BOOL* rgfIndexed, 
            DWORD cEntries)
{
    if (m_rgcstrLastKnownSchema)
        delete [] m_rgcstrLastKnownSchema;
    m_rgcstrLastKnownSchema = rgcstr;

    if (m_rgltypeLastKnownSchema)
        delete [] m_rgltypeLastKnownSchema;
    m_rgltypeLastKnownSchema = rgtype;

    if (m_rgfindexedLastKnownSchema)
        delete [] m_rgfindexedLastKnownSchema;
    m_rgfindexedLastKnownSchema = rgfIndexed;

    m_cLastKnownSchema = cEntries;

    return S_OK;
}



STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    // NOTA BENE: Init is called when a snap-in is being 
    // created and has items to enumerate in the scope pane ... NOT BEFORE
    // Example: Add/Remove snapin, Add...
    //  -> CComponentDataImpl will get called for CreatePropertyPages() before ::Initialize is called

#if DBG
    m_bInitializedCD = true;
#endif

    ASSERT(pUnknown != NULL);
    HRESULT hr;

    LPIMAGELIST lpScopeImage = NULL;
    CBitmap bmpResultStrip16x16, bmpResultStrip32x32;

    g_pResources = new CLocalizedResources;
    if (NULL == g_pResources)
    {
	hr = E_OUTOFMEMORY;
        _JumpError(hr, Ret, "Alloc Resources");
    }

    // Load resources
    if (!g_pResources->Load())
    {
        hr = GetLastError();
        _JumpError(hr, Ret, "Load Resources");
    }

    // create a per-instance id (failure not fatal)
    ResetPersistedColumnInformation();

    // MMC should only call ::Initialize once!

    // m_pCertMachine created in constructor, but verified here
    ASSERT(m_pCertMachine != NULL);
    _JumpIfOutOfMemory(hr, Ret, m_pCertMachine);
    
    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, reinterpret_cast<void**>(&m_pScope));
    _JumpIfError(hr, Ret, "QueryInterface IID_IConsoleNameSpace2");

    // add the images for the scope tree
    hr = pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);
    _JumpIfError(hr, Ret, "QueryInterface IID_IConsole2");

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(hr == S_OK);
    _JumpIfError(hr, Ret, "QueryScopeImageList");

    if ( (NULL == bmpResultStrip16x16.LoadBitmap(IDB_16x16)) || 
         (NULL == bmpResultStrip32x32.LoadBitmap(IDB_32x32)) )
    {
        hr = S_FALSE;
        _JumpError(hr, Ret, "LoadBitmap");
    }

    // Load the bitmaps from the dll
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmpResultStrip16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmpResultStrip32x32)),
                       0, RGB(255, 0, 255));
    _JumpIfError(hr, Ret, "ImageListSetStrip");


Ret:
    if (lpScopeImage)
        lpScopeImage->Release();
    
    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
    // release all references to the console here
    ASSERT(m_bInitializedCD);
#if DBG
    m_bDestroyedCD = true;
#endif

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    HRESULT hr = S_OK;
    ASSERT(ppComponent != NULL);

    CComObject<CSnapin>* pObject;
    CComObject<CSnapin>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    _JumpIfOutOfMemory(hr, Ret, pObject);

    // Store IComponentData
    pObject->SetIComponentData(this);
    pObject->SetViewID(m_dwNextViewIndex++);

    hr = pObject->QueryInterface(IID_IComponent, 
                    reinterpret_cast<void**>(ppComponent));
Ret:
    return hr;
}


STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pScope != NULL);
    HRESULT hr = S_OK;
    INTERNAL* pInternal = NULL;
    MMC_COOKIE cookie = NULL;

    // handle events with (NULL == lpDataObject)
    switch(event)
    {
        case MMCN_PROPERTY_CHANGE:
        {
            // Notification from property page "notify change"
            //
            // arg == fIsScopeItem
            // lParam == page param value
            // return value unused

            if (param == CERTMMC_PROPERTY_CHANGE_REFRESHVIEWS)
            {
                m_pConsole->UpdateAllViews(
                    lpDataObject,
                    0,
                    0);
            }

            goto Ret;
        }

        default: // all others
            break; 
    }


    pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal == NULL)
    {
        return S_OK;
    }

    cookie = pInternal->m_cookie;
    FREE_DATA(pInternal);

    switch(event)
    {
    case MMCN_PASTE:
        DBGPRINT((DBG_SS_CERTMMC, "CComponentDataImpl::MMCN_PASTE"));
        break;
    
    case MMCN_DELETE:
        hr = OnDelete(cookie);
        break;

    case MMCN_REMOVE_CHILDREN:
        hr = OnRemoveChildren(arg);
        break;

    case MMCN_RENAME:
        hr = OnRename(cookie, arg, param);
        break;

    case MMCN_EXPAND:
        hr = OnExpand(lpDataObject, arg, param);
        break;

    case MMCN_PRELOAD:
        {
            if (NULL == cookie)
            {
                // base node 

                // this call gave us time to load our dynamic base nodename (Certification Authority on %ws)
                DisplayProperRootNodeName((HSCOPEITEM)arg);
            }
        }

    default:
        break;
    }

Ret:
    return hr;
}

HRESULT CComponentDataImpl::DisplayProperRootNodeName(HSCOPEITEM hRoot)
{
    // hRoot not optional
    if (hRoot == NULL)
        return E_POINTER;

    // if static root not yet set, save it (CASE: load from file)
    if (m_pStaticRoot == NULL)
        m_pStaticRoot = hRoot;

    // let us have time to load our dynamic base nodename (Certification Authority on %ws)
    SCOPEDATAITEM item;
    item.mask = SDI_STR;
    item.ID = hRoot;

    CString cstrMachineName;
    CString cstrDisplayStr, cstrFormatStr, cstrMachine;

    cstrFormatStr.LoadString(IDS_NODENAME_FORMAT);
    if (m_pCertMachine->m_strMachineName.IsEmpty())
        cstrMachine.LoadString(IDS_LOCALMACHINE);
    else
        cstrMachine = m_pCertMachine->m_strMachineName;
    
    if (!cstrFormatStr.IsEmpty())
    {
        cstrMachineName.Format(cstrFormatStr, cstrMachine);
        item.displayname = (LPWSTR)(LPCWSTR)cstrMachineName;
    }
    else
    {  
        // protect against null formatstring
        item.displayname = (LPWSTR)(LPCWSTR)cstrMachine;
    }
    m_pScope->SetItem (&item);
    
    return S_OK;
}


STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
#ifdef _DEBUG
    if (cookie == 0)
    {
        ASSERT(type != CCT_RESULT);
    }
    else 
    {
        ASSERT(type == CCT_SCOPE);
        
        DWORD dwItemType = *reinterpret_cast<DWORD*>(cookie);
        ASSERT((dwItemType == SCOPE_LEVEL_ITEM) || (dwItemType == CA_LEVEL_ITEM));
    }
#endif 

    return _QueryDataObject(cookie, type, MAXDWORD, this, ppDataObject);
}

///////////////////////////////////////////////////////////////////////////////
//// ISnapinHelp interface
STDMETHODIMP CComponentDataImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
     return E_POINTER;

  UINT cbWindows = 0;
  WCHAR szWindows[MAX_PATH];
  szWindows[0] = L'\0';

  cbWindows = GetSystemWindowsDirectory(szWindows, MAX_PATH);
  if (cbWindows == 0)
     return S_FALSE;
  cbWindows++;  // include null term
  cbWindows *= sizeof(WCHAR);   // make this bytes, not chars

  *lpCompiledHelpFile = (LPOLESTR) CoTaskMemAlloc(sizeof(HTMLHELP_COLLECTION_FILENAME) + cbWindows);
  if (*lpCompiledHelpFile == NULL)
     return E_OUTOFMEMORY;
  myRegisterMemFree(*lpCompiledHelpFile, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


  USES_CONVERSION;
  wcscpy(*lpCompiledHelpFile, T2OLE(szWindows));
  wcscat(*lpCompiledHelpFile, T2OLE(HTMLHELP_COLLECTION_FILENAME));

  return S_OK;
}

// tells of other topics my chm links to
STDMETHODIMP CComponentDataImpl::GetLinkedTopics(LPOLESTR* lpCompiledHelpFiles)
{
  if (lpCompiledHelpFiles == NULL)
     return E_POINTER;

  UINT cbWindows = 0;
  WCHAR szWindows[MAX_PATH];
  szWindows[0] = L'\0';

  cbWindows = GetSystemWindowsDirectory(szWindows, MAX_PATH);
  if (cbWindows == 0)
     return S_FALSE;
  cbWindows++;  // include null term
  cbWindows *= sizeof(WCHAR);   // make this bytes, not chars

  *lpCompiledHelpFiles = (LPOLESTR) CoTaskMemAlloc(sizeof(HTMLHELP_COLLECTIONLINK_FILENAME) + cbWindows);
  if (*lpCompiledHelpFiles == NULL)
     return E_OUTOFMEMORY;
  myRegisterMemFree(*lpCompiledHelpFiles, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


  USES_CONVERSION;
  wcscpy(*lpCompiledHelpFiles, T2OLE(szWindows));
  wcscat(*lpCompiledHelpFiles, T2OLE(HTMLHELP_COLLECTIONLINK_FILENAME));

  return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}


STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    // Read the string
    BOOL fMachineOverrideFound = FALSE;
    DWORD dwVer;

    CertSvrCA* pDummyCA = NULL;
    HRESULT hr;

    // read version
    hr = ReadOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Read dwVer");

    // flags is version-dependent
    if (VER_CCOMPDATA_SAVE_STREAM_3 == dwVer)
    {
        // version 3 includes file flags

        hr = ReadOfSize(pStm, &m_dwFlagsPersist, sizeof(DWORD));
        _JumpIfError(hr, Ret, "Read m_dwFlagsPersist");
    }
    else if (VER_CCOMPDATA_SAVE_STREAM_2 != dwVer)
    {
        // not version 2 or 3
        return STG_E_OLDFORMAT;
    }

    // load machine data
    hr = m_pCertMachine->Load(pStm);
    _JumpIfError(hr, Ret, "Load m_pCertMachine")

    if (m_dwFlagsPersist & CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE)
    {
        // override m_pCertMachine->m_strMachineName (not to be persisted)
        LPWSTR lpCommandLine = GetCommandLine();    // no need to free
        DBGPRINT((DBG_SS_CERTMMC, "CComponentData::Load: Command line switch override enabled.  Searching command line(%ws)\n", lpCommandLine));

        LPWSTR pszMachineStart, pszMachineEnd;

        // search for "/machine" in cmd line
        _wcsupr(lpCommandLine);  // convert to uppercase
        pszMachineStart = wcsstr(lpCommandLine, WSZ_MACHINE_OVERRIDE_SWITCH);

        do  // not a loop
        {
            if (NULL == pszMachineStart)    // user did not override
                break;

            pszMachineStart += WSZARRAYSIZE(WSZ_MACHINE_OVERRIDE_SWITCH);   // skip past "/machine:"

            //
            // Found the hint switch
            //
            pszMachineEnd = wcschr(pszMachineStart, L' ');  // look for first space char, call this end
            if (NULL == pszMachineEnd)
                pszMachineEnd = &pszMachineStart[wcslen(pszMachineStart)];  // space not found in this string; 
            
            m_pCertMachine->m_strMachineName = pszMachineStart;
            m_pCertMachine->m_strMachineName.SetAt(SAFE_SUBTRACT_POINTERS(pszMachineEnd, pszMachineStart), L'\0'); 

            DBGPRINT((DBG_SS_CERTMMC,  "CComponentData::Load: Found machinename (%ws)\n", m_pCertMachine->m_strMachineName));
            fMachineOverrideFound = TRUE;

        } while (0);
    }

    if (!fMachineOverrideFound) 
    {
        // Get CA count
        DWORD dwNumCAs;
        hr = ReadOfSize(pStm, &dwNumCAs, sizeof(DWORD));
        _JumpIfError(hr, Ret, "Load dwNumCAs");

        // for each CA, get folder data
        for (DWORD dwCA=0; dwCA< dwNumCAs; dwCA++)
        {
            CString cstrThisCA;

            hr = CStringLoad(cstrThisCA, pStm);
            _JumpIfError(hr, Ret, "CStringLoad");
        
            // create a dummy CA with the correct common name; we'll fix this later (see Synch CA)
            pDummyCA = new CertSvrCA(m_pCertMachine);
            _JumpIfOutOfMemory(hr, Ret, pDummyCA);

            pDummyCA->m_strCommonName = cstrThisCA;

            if (VER_CCOMPDATA_SAVE_STREAM_2 < dwVer)
            {
                m_fSchemaWasResolved = FALSE;   // resolve schema once per CComponentData load

                // LOAD last known schema
                hr = ReadOfSize(pStm, &m_cLastKnownSchema, sizeof(DWORD));
                _JumpIfError(hr, Ret, "Load m_cLastKnownSchema");
            
                // alloc
                if (m_cLastKnownSchema != 0)
                {
                    m_rgcstrLastKnownSchema = new CString[m_cLastKnownSchema];
                    _JumpIfOutOfMemory(hr, Ret, m_rgcstrLastKnownSchema);
                 
                    for (unsigned int i=0; i<m_cLastKnownSchema; i++)
                    {
                        hr = CStringLoad(m_rgcstrLastKnownSchema[i], pStm);
                        _JumpIfError(hr, Ret, "Load m_rgcstrLastKnownSchema");

                    }
                }
            }

            // find out how many folders are in the stream under this CA
            DWORD dwNumFolders=0;
            hr = ReadOfSize(pStm, &dwNumFolders, sizeof(DWORD));
            _JumpIfError(hr, Ret, "Load dwNumFolders");

            // load each of these
            for(DWORD dwCount=0; dwCount<dwNumFolders; dwCount++)
            {
                CFolder* pFolder = new CFolder();
                _JumpIfOutOfMemory(hr, Ret, pFolder);
 
                // point at previously constructed dummy ca; we'll fix this later
                pFolder->m_pCertCA = pDummyCA;

                hr = pFolder->Load(pStm);
                _JumpIfError(hr, Ret, "Load CFolder");

                m_scopeItemList.AddTail(pFolder);
            }
            pDummyCA = NULL; // owned by at least one folder
        }
    }
    
    // version-dependent info
    if (VER_CCOMPDATA_SAVE_STREAM_2 < dwVer)
    {
        // per-instance guid for identifying columns uniquely
        hr = ReadOfSize(pStm, &m_guidInstance, sizeof(GUID));
        _JumpIfError(hr, Ret, "ReadOfSize instance guid");

        hr = ReadOfSize(pStm, &m_dwNextViewIndex, sizeof(DWORD));
        _JumpIfError(hr, Ret, "ReadOfSize view index");
    }
    
Ret:
    if (pDummyCA)
        delete pDummyCA;

    ClearDirty();

    return hr;
}



STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    HRESULT hr;
    DWORD dwVer;
    DWORD dwCA;
    DWORD dwNumCAs;

#if DBG_CERTSRV
    bool fSaveConsole = false;

    LPWSTR lpCommandLine = GetCommandLine();    // no need to free
    _wcsupr(lpCommandLine);  // convert to uppercase
    fSaveConsole = (NULL!=wcsstr(lpCommandLine, L"/certsrv_saveconsole"));
#endif

    // Write the version
    dwVer = VER_CCOMPDATA_SAVE_STREAM_3;
    hr = WriteOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Save dwVer");

    // write dwFlags (a VERSION 3 addition)
    hr = WriteOfSize(pStm, &m_dwFlagsPersist, sizeof(DWORD));
    _JumpIfError(hr, Ret, "pStm->Write m_dwFlagsPersist");

#if DBG_CERTSRV
    if(fSaveConsole)
        m_pCertMachine->m_strMachineNamePersist.Empty();
#endif

    hr = m_pCertMachine->Save(pStm, fClearDirty);
    _JumpIfError(hr, Ret, "Save m_pCertMachine");

    // save CA count
    dwNumCAs = m_pCertMachine->GetCaCount();
    hr = WriteOfSize(pStm, &dwNumCAs, sizeof(DWORD));
    _JumpIfError(hr, Ret, "pStm->Write dwNumCAs");

    // for each CA, save folder info
    for (dwCA=0; dwCA < dwNumCAs; dwCA++)
    {
        DWORD dwNumFolders=0;
        CString cstrThisCA, cstrThisCASave;
        cstrThisCASave = cstrThisCA = m_pCertMachine->GetCaCommonNameAtPos(dwCA);

#if DBG_CERTSRV
        if(fSaveConsole)
            cstrThisCASave.Empty();
#endif
        hr = CStringSave(cstrThisCASave, pStm, fClearDirty);
        _JumpIfError(hr, Ret, "CStringSave");

        // SAVE last known schema
        hr = WriteOfSize(pStm, &m_cLastKnownSchema, sizeof(DWORD));
        _JumpIfError(hr, Ret, "pStm->Write m_cLastKnownSchema");

        for (unsigned int i=0; i<m_cLastKnownSchema; i++)
        {
            hr = CStringSave(m_rgcstrLastKnownSchema[i], pStm, fClearDirty);
            _JumpIfError(hr, Ret, "CStringSave");
        }

        // walk through every folder, find how many folders to save
        POSITION pos = m_scopeItemList.GetHeadPosition();
        while(pos)
        {
            CFolder* pFolder = m_scopeItemList.GetNext(pos);
            if (pFolder->GetCA()->m_strCommonName.IsEqual(cstrThisCA))
                dwNumFolders++;
        }

        // write how many folders under this CA
        hr = WriteOfSize(pStm, &dwNumFolders, sizeof(DWORD));
        _JumpIfError(hr, Ret, "pStm->Write dwNumFolders");

        pos = m_scopeItemList.GetHeadPosition();
        while(pos)
        {
            CFolder* pFolder = m_scopeItemList.GetNext(pos);
            if (pFolder->GetCA()->m_strCommonName.IsEqual(cstrThisCA))
            {
                hr = pFolder->Save(pStm, fClearDirty);
                _JumpIfError(hr, Ret, "Save CFolder");
            }
        }
    }

    // per-instance guid for identifying columns uniquely
    hr = WriteOfSize(pStm, &m_guidInstance, sizeof(GUID));
    _JumpIfError(hr, Ret, "WriteOfSize instance guid");

    hr = WriteOfSize(pStm, &m_dwNextViewIndex,  sizeof(DWORD));
    _JumpIfError(hr, Ret, "WriteOfSize view index");
     
Ret:
    if (fClearDirty)
        ClearDirty();

    return hr;
}

STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    int iTotalSize=0;

    // version 
    iTotalSize = sizeof(DWORD) + sizeof(m_dwFlagsPersist);

    // machine info
    int iSize;
    m_pCertMachine->GetSizeMax(&iSize);
    iTotalSize += iSize;

    // CA count
    iTotalSize += sizeof(DWORD);

    DWORD dwNumCAs = m_pCertMachine->GetCaCount();
    for (DWORD dwCA=0; dwCA < dwNumCAs; dwCA++)
    {
        CString cstrThisCA;
        cstrThisCA = m_pCertMachine->GetCaCommonNameAtPos(dwCA);
        CStringGetSizeMax(cstrThisCA, &iSize);
        iTotalSize += iSize;

        // Number of folders under this CA
        iTotalSize += sizeof(DWORD);

        // walk through every folder, find how many folders to save
        POSITION pos = m_scopeItemList.GetHeadPosition();
        while(pos)
        {
            CFolder* pFolder = m_scopeItemList.GetNext(pos);
            if (pFolder->GetCA()->m_strCommonName.IsEqual(cstrThisCA))
            {
                // folder size
                pFolder->GetSizeMax(&iSize);
                iTotalSize += iSize;
            }
        }
    }

    // per-instance guid for identifying columns uniquely
    iTotalSize += sizeof(GUID);
    
    // next View Index to assign
    iTotalSize += sizeof(DWORD);
 

    // size of string to be saved
    pcbSize->QuadPart = iTotalSize;


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT
CComponentDataImpl::OnDelete(
    MMC_COOKIE /* cookie */ )
{
    return S_OK;
}

HRESULT
CComponentDataImpl::OnRemoveChildren(
    LPARAM /* arg */ )
{
    return S_OK;
}

VOID SetCertView()
{
    LPWSTR lpCommandLine = GetCommandLine();    // no need to free
    LPWSTR pwsz;
    DWORD dw;
    static BOOL s_fFirst = TRUE;
    #define wszCOMMANDLINEE	L"/E"

    if (s_fFirst)
    {
	// search for "/e" in cmd line
	_wcsupr(lpCommandLine);  // convert to uppercase
	pwsz = wcsstr(lpCommandLine, wszCOMMANDLINEE);

	do  // not a loop
	{
	    if (NULL == pwsz)    // user did not override
		break;

	    pwsz += WSZARRAYSIZE(wszCOMMANDLINEE);   // skip past "/e"
	    if (L'\0' != *pwsz && L' ' != *pwsz)
		break;
	    g_fCertViewOnly = FALSE;
	} while (0);
	if (g_fCertViewOnly && NULL != getenv("certsrv_crl"))
	    g_fCertViewOnly = FALSE;
	if (g_fCertViewOnly &&
	    S_OK == myGetCertRegDWValue(NULL, NULL, NULL, L"CRL", &dw) &&
	    0 != dw)
	    g_fCertViewOnly = FALSE;
	s_fFirst = FALSE;
    }
}

HRESULT CComponentDataImpl::OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    // cookie is cookie
    // arg is fRenamed (ask for permission/notify of rename)
    // param (szNewName)

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    BOOL fRenamed = (BOOL)arg;

    if (!fRenamed)
    {
        if (pFolder)
            return S_FALSE; // don't allow children to be renamed
        else
            return S_OK; // allow root to be renamed
    }

    LPOLESTR pszNewName = reinterpret_cast<LPOLESTR>(param);
    if (pszNewName == NULL)
        return E_INVALIDARG;

    if (pFolder)
    {
        ASSERT(pFolder != NULL);
        if (pFolder == NULL)
            return E_INVALIDARG;

        pFolder->SetName(pszNewName);
    }
    
    return S_OK;
}

HRESULT CComponentDataImpl::OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        EnumerateScopePane(lpDataObject, param);
    }

    return S_OK;
}


HRESULT CComponentDataImpl::SynchDisplayedCAList(LPDATAOBJECT lpDataObject)
{
    HRESULT hr;
    BOOL fFound;
    POSITION pos, nextpos;
    DWORD dwKnownCAs;

    m_fScopeAlreadyEnumerated = TRUE;  // don't need to refresh view automagically from enum if we get here 

    // should never get here otherwise
    ASSERT(m_pStaticRoot);
    if (NULL == m_pStaticRoot)
        return E_POINTER;

    // select root node, delete all items in UI underneath (we'll readd if necessary)
    hr = m_pConsole->SelectScopeItem(m_pStaticRoot);
    _PrintIfError2(hr, "SelectScopeItem", hr);

    hr = m_pScope->DeleteItem(m_pStaticRoot, FALSE);     // remove everything from UI
    _PrintIfError2(hr, "DeleteItem", hr);


    // build knowledge of current CAs
    // note: this may orphan some pCAs, but we'll catch it during cleanup
    HWND hwndMain = NULL;
    hr = m_pConsole->GetMainWindow(&hwndMain);
    if (hr != S_OK)
        hwndMain = NULL;        // this should work

    // this hr gets returned after we're done
    hr = m_pCertMachine->PrepareData(hwndMain);

    // don't fail out if PrepareData fails -- we still need to 
    // make the snapin state reflect no known nodes!
    ASSERT((hr == S_OK) || (0 == m_pCertMachine->GetCaCount()) );  // make sure m_pCertMachine zeros itself

    // Tasks
    // #1: Remove folders in m_scopeItemList for CAs that no longer exist in m_pCertMachine.m_rgpCAList[]

    // #2: Add folders to m_scopeItemList for CAs that now exist in m_pCertMachine.m_rgpCAList[]

    // Task #1
    // scour m_scopeItemList for entries we already know about, delete stale folders

    for (pos = m_scopeItemList.GetHeadPosition(); (NULL != pos); )
    {
        // ASSERTION: every folder has an associated m_pCertCA
        ASSERT(NULL != m_scopeItemList.GetAt(pos)->m_pCertCA);

        nextpos = pos;             // save next position off
        fFound = FALSE;

        // for each scope item, walk through m_rgpCAList looking for current
        for (dwKnownCAs=0; dwKnownCAs<(DWORD)m_pCertMachine->m_CAList.GetSize(); dwKnownCAs++)
        {
            if (m_scopeItemList.GetAt(pos)->m_pCertCA->m_strCommonName.IsEqual(m_pCertMachine->GetCaCommonNameAtPos(dwKnownCAs)))
            {
                fFound = TRUE;
                break;
            }
        }

        CFolder* pFolder = m_scopeItemList.GetAt(pos);
        ASSERT(pFolder); // this should never happen
        if (pFolder == NULL)
        {
            hr = E_POINTER;
            _JumpError(hr, Ret, "GetAt");
        }

        if (fFound)
        {
            // always point to latest pCA:
            // NOTE: this allows for load to populate us with dummy CAs!
            pFolder->m_pCertCA = m_pCertMachine->GetCaAtPos(dwKnownCAs);

            // if base node, do insert (other nodes get inserted during Expand() notification)
            if (SERVER_INSTANCE == pFolder->GetType())
                BaseFolderInsertIntoScope(pFolder, pFolder->m_pCertCA);

            // fwd to next elt
            m_scopeItemList.GetNext(pos);
        }
        else // !fFound
        {
            // delete immediately from m_scopeItemList
            m_scopeItemList.GetNext(nextpos);

            delete pFolder;                     // destroy the elt
            m_scopeItemList.RemoveAt(pos);

            pos = nextpos;                      // restore next position
        }
    }

    // Task #2
    // scour m_pCertMachine[] for new entries, create default folders

    for (dwKnownCAs=0; dwKnownCAs<(DWORD)m_pCertMachine->m_CAList.GetSize(); dwKnownCAs++)
    {
        fFound = FALSE;
        for (pos = m_scopeItemList.GetHeadPosition(); (NULL != pos); m_scopeItemList.GetNext(pos))
        {
            if (m_scopeItemList.GetAt(pos)->m_pCertCA->m_strCommonName.IsEqual(m_pCertMachine->GetCaCommonNameAtPos(dwKnownCAs)))
            {
                fFound = TRUE;
                break;  // if matches something in the refreshed list, we're fine 
            }
        }

        // found? 
        if (!fFound)
        {
            CertSvrCA* pCA;
            CFolder* pFolder;

            pCA = m_pCertMachine->GetCaAtPos(dwKnownCAs);
            if (NULL == pCA)
            {
                hr = E_POINTER;
                _JumpError(hr, Ret, "m_pCertMachine->GetCaAtPos(iCAPos)");
            }

            // create base node, add to list, insert into scope pane
            pFolder = new CFolder();
            _JumpIfOutOfMemory(hr, Ret, pFolder);

            m_scopeItemList.AddTail(pFolder);
            
            hr = BaseFolderInsertIntoScope(pFolder, pCA);
            _JumpIfError(hr, Ret, "BaseFolderInsertIntoScope");

            // and create all template folders underneath
            hr = CreateTemplateFolders(pCA);
            _JumpIfError(hr, Ret, "CreateTemplateFolders");
        }
        else
        {
            // no need to do anything, ca is already known & inserted into scope
        }
    }


// BOGDANT

    // Task #3
    // for each CA, offer to do any one-time per-CA upgrades
    for (dwKnownCAs=0; dwKnownCAs<(DWORD)m_pCertMachine->m_CAList.GetSize(); dwKnownCAs++)
    {
            CertSvrCA* pCA;

            pCA = m_pCertMachine->GetCaAtPos(dwKnownCAs);
            if (NULL == pCA)
            {
                hr = E_POINTER;
                _JumpError(hr, Ret, "m_pCertMachine->GetCaAtPos(iCAPos)");
            }

            if (pCA->FDoesSecurityNeedUpgrade())
            {
                bool fUserHasWriteAccess = false;
                CString cstrMsg, cstrTitle;
                cstrMsg.LoadString(IDS_W2K_SECURITY_UPGRADE_DESCR);
                cstrTitle.LoadString(IDS_W2K_UPGRADE_DETECTED_TITLE);

                hr = CurrentUserCanInstallCA(fUserHasWriteAccess);
                _JumpIfError(hr, Ret, "IsUserDomainAdministrator");

                if (fUserHasWriteAccess)
                {
                    // ask to upgrade security

                    // confirm this action
                    CString cstrTmp;
                    cstrTmp.LoadString(IDS_CONFIRM_W2K_SECURITY_UPGRADE);
                    cstrMsg += cstrTmp;

                    int iRet;
                    if ((S_OK == m_pConsole->MessageBox(cstrMsg, cstrTitle, MB_YESNO, &iRet)) &&
                        (iRet == IDYES))
                    {
                        // do stuff
                        hr = pCA->FixEnrollmentObject();
                        _JumpIfError(hr, error, "FixEnrollmentObject");

                        hr = AddCAMachineToCertPublishers();
                        _JumpIfError(hr, error, "AddCAMachineToCertPublishers");

                        if(pCA->FIsAdvancedServer())
                        {
                            hr = AddCAMachineToPreWin2kGroup();
                            _JumpIfError(hr, error, "AddCAMachineToPreWin2kGroup");
                        }

                        if(RestartService(hwndMain, pCA->m_pParentMachine))
                            m_pConsole->UpdateAllViews(
                                lpDataObject,
                                0,
                                0);

                        error:
                        if (hr != S_OK)
                            DisplayGenericCertSrvError(m_pConsole, hr);
                        else
                        {
                            hr = pCA->CleanSetupStatusBits(
                                SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG);
                            _PrintIfError(hr, 
                                "Failed to clear SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG setup flag");
                            hr = S_OK;
                        }
                    }
                }
                else
                {
                    // just warn
                    CString cstrTmp;
                    cstrTmp.LoadString(IDS_BLOCK_W2K_SECURITY_UPGRADE);
                    cstrMsg += cstrTmp;

                    m_pConsole->MessageBoxW(cstrMsg, cstrTitle, MB_OK, NULL);
                }
            }
    }


Ret:

    return hr;
}

HRESULT CComponentDataImpl::BaseFolderInsertIntoScope(CFolder* pFolder, CertSvrCA* pCA)
{
    HRESULT hr = S_OK;
    int nImage;
    
    HSCOPEITEM pParent = m_pStaticRoot; // we'll always be initialized by this time if parent exists
    ASSERT(m_pStaticRoot);
    if (NULL == m_pStaticRoot)
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "m_pStaticRoot");
    }

    if ((NULL == pFolder) || (NULL == pCA))
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "NULL ptr");
    }


    if (pCA->m_strCommonName.IsEmpty())
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "m_strCommonName");
    }

    if (m_pCertMachine->IsCertSvrServiceRunning())
        nImage = IMGINDEX_CERTSVR_RUNNING;
    else
        nImage = IMGINDEX_CERTSVR_STOPPED;

    pFolder->SetScopeItemInformation(nImage, nImage);
    pFolder->SetProperties(
            pCA->m_strCommonName, 
            SCOPE_LEVEL_ITEM, 
            SERVER_INSTANCE, 
            TRUE);

    pFolder->m_pCertCA = pCA; // fill this in as root

    // Set the parent
    pFolder->m_ScopeItem.mask |= SDI_PARENT;
    pFolder->m_ScopeItem.relativeID = pParent;

    // Set the folder as the cookie
    pFolder->m_ScopeItem.mask |= SDI_PARAM;
    pFolder->m_ScopeItem.lParam = reinterpret_cast<LPARAM>(pFolder);
    pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));

    // insert SCOPE_LEVEL_ITEM into scope pane
    m_pScope->InsertItem(&pFolder->m_ScopeItem);


    // Note - On return, the ID member of 'm_ScopeItem' 
    // contains the handle to the newly inserted item!
    ASSERT(pFolder->m_ScopeItem.ID != NULL);
Ret:

    return hr;
}

HRESULT CComponentDataImpl::CreateTemplateFolders(CertSvrCA* pCA)
{
    HRESULT hr = S_OK;

    SetCertView();

    // add all template folders under it
    for (int iUnder=0; iUnder < ARRAYLEN(SvrFuncFolderData); iUnder++)
    {
        // skip alien if svr doesn't support
        if ((iUnder==ENUM_FOLDER_ALIEN) && !pCA->FDoesServerAllowForeignCerts())
            continue;

        if ((iUnder==ENUM_FOLDER_CRLS) && g_fCertViewOnly)
            continue;

        CString cstrRsc;
        cstrRsc.LoadString(SvrFuncFolderData[iUnder].iNameRscID);

        CFolder* pFolder;
        pFolder = new CFolder();
        _JumpIfOutOfMemory(hr, Ret, pFolder);

        pFolder->m_pCertCA = pCA;
        pFolder->SetScopeItemInformation(IMGINDEX_FOLDER, IMGINDEX_FOLDER_OPEN);
        pFolder->SetProperties(
                        cstrRsc, 
                        CA_LEVEL_ITEM,
                        SvrFuncFolderData[iUnder].type, 
                        FALSE);

        m_scopeItemList.AddTail(pFolder);
    }

Ret:
    return hr;
}


void CComponentDataImpl::EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM pParent)
{
    ASSERT(m_pScope != NULL); // make sure we QI'ed for the interface
    ASSERT(lpDataObject != NULL);

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal == NULL)
        return;

    MMC_COOKIE cookie = pInternal->m_cookie;

    FREE_DATA(pInternal);

    // Enumerate the scope pane
    // return the folder object that represents the cookie
    // Note - for large list, use dictionary
    CFolder* pStatic = FindObject(cookie);
    if (pStatic)
        ASSERT(!pStatic->IsEnumerated());

    if (NULL == cookie)    
    {
        if (!m_fScopeAlreadyEnumerated)               // if base node and we've never inserted nodes
        {
            // TASK: expand machine node

            // Note - Each cookie in the scope pane represents a folder.
            // Cache the HSCOPEITEM of the static root.
            ASSERT(pParent != NULL); 
            m_pStaticRoot = pParent;    // add/remove: EXPAND case

            // synch folder list if asking to expand machine node
            // SyncDisplayedCAList adds all necessary folders
            HRESULT hr = SynchDisplayedCAList(lpDataObject);
            if (hr != S_OK)
            {
                HWND hwnd;
                DWORD dwErr2 = m_pConsole->GetMainWindow(&hwnd);
                ASSERT(dwErr2 == ERROR_SUCCESS);
                if (dwErr2 != ERROR_SUCCESS)
                    hwnd = NULL;        // should work

                if (((HRESULT)RPC_S_SERVER_UNAVAILABLE) == hr)
                {
                    DisplayCertSrvErrorWithContext(hwnd, hr, IDS_SERVER_UNAVAILABLE);
                }
                else if(HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION)==hr ||
                        ((HRESULT)ERROR_OLD_WIN_VERSION)==hr)
                {
                    DisplayCertSrvErrorWithContext(hwnd, hr, IDS_OLD_CA);
                }
                else
                {
                    DisplayCertSrvErrorWithContext(hwnd, hr, IDS_CANNOT_OPEN_CERT_SERVICES);
                }
            }
        }
    }
    else
    {
        // TASK: expand non-machine node
        if (NULL == pStatic)
            return;

        switch(pStatic->GetType())
        {
        case SERVER_INSTANCE:
            {
                // TASK: expand CA instance node

                POSITION pos = m_scopeItemList.GetHeadPosition();
                while(pos)
                {
                    CFolder* pFolder;
                    pFolder = m_scopeItemList.GetNext(pos);
                    if (pFolder==NULL)
                        break;

                    // only expand folders that belong under the SERVER_INSTANCE
                    if (pFolder->m_itemType != CA_LEVEL_ITEM)
                        continue;

                    // and only those under the correct CA
                    if (pFolder->m_pCertCA != pStatic->m_pCertCA)
                        continue;

                    // Set the parent
                    pFolder->m_ScopeItem.relativeID = pParent;

                    // Set the folder as the cookie
                    pFolder->m_ScopeItem.mask |= SDI_PARAM;
                    pFolder->m_ScopeItem.lParam = reinterpret_cast<LPARAM>(pFolder);
                    pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));
                    m_pScope->InsertItem(&pFolder->m_ScopeItem);

                    // Note - On return, the ID member of 'm_ScopeItem' 
                    // contains the handle to the newly inserted item!
                    ASSERT(pFolder->m_ScopeItem.ID != NULL);
                }
            }
            break;
        default:
            // TASK: expand nodes with no folders under them
            break;
        }
    }
}


CFolder* CComponentDataImpl::FindObject(MMC_COOKIE cookie)
{
    CFolder* pFolder = NULL;
    POSITION pos = m_scopeItemList.GetHeadPosition();

    while(pos)
    {
        pFolder = m_scopeItemList.GetNext(pos);

        if (*pFolder == cookie)
            return pFolder;
    }

    return NULL;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    CFolder* pFolder = reinterpret_cast<CFolder*>(pScopeDataItem->lParam);

    if ((pScopeDataItem->mask & SDI_STR) && (pFolder != NULL))
    {
        pScopeDataItem->displayname = pFolder->m_pszName;
    }

    // I was told by Ravi Rudrappa that these notifications 
    // would never be given. If it is given, move UpdateScopeIcons() 
    // functionality here!!!
    ASSERT(0 == (pScopeDataItem->mask & SDI_IMAGE));
    ASSERT(0 == (pScopeDataItem->mask & SDI_OPENIMAGE));

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    HRESULT hr = S_FALSE;

    // Make sure both data object are mine
    INTERNAL* pA = ExtractInternalFormat(lpDataObjectA);
    INTERNAL* pB = ExtractInternalFormat(lpDataObjectA);

   if (pA != NULL && pB != NULL)
        hr = (*pA == *pB) ? S_OK : S_FALSE;

   
   FREE_DATA(pA);
   FREE_DATA(pB);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                    LONG_PTR handle, 
                    LPDATAOBJECT lpIDataObject)
{
    HRESULT hr = S_OK;

    // Look at the data object and determine if this an extension or a primary
    ASSERT(lpIDataObject != NULL);

    PropertyPage* pBasePage;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    if (pInternal == NULL)
        return S_OK;
   
    switch (pInternal->m_type)
    {
    case CCT_SNAPIN_MANAGER:
        {
            CChooseMachinePropPage* pPage = new CChooseMachinePropPage();
            _JumpIfOutOfMemory(hr, Ret, pPage);

            // this alloc might have failed (should be in ctor)
            _JumpIfOutOfMemory(hr, Ret, m_pCertMachine);

            pPage->SetCaption(IDS_SCOPE_MYCOMPUTER);

	        // Initialize state of object
        	pPage->InitMachineName(NULL);
           
            // point to our member vars
            pPage->SetOutputBuffers(
		        &m_pCertMachine->m_strMachineNamePersist,
		        &m_pCertMachine->m_strMachineName,
                &m_dwFlagsPersist);	

            pBasePage = pPage;

            // Object gets deleted when the page is destroyed
            ASSERT(lpProvider != NULL);

            ASSERT(pBasePage != NULL);
            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
            if (hPage == NULL)
            {
                hr = myHLastError();
                _JumpError(hr, Ret, "CreatePropertySheetPage");
            }

            lpProvider->AddPage(hPage);

            break;
        }
    case CCT_SCOPE:
        {
            // if not base scope
            if (0 != pInternal->m_cookie)
            {
                // switch on folder type
                CFolder* pFolder = GetParentFolder(pInternal);
                ASSERT(pFolder != NULL);
                if (pFolder == NULL)
                {
                    hr = E_POINTER;
                    _JumpError(hr, Ret, "GetParentFolder");
                }

                switch(pFolder->m_type) 
                {
                case SERVER_INSTANCE:
                {
                    //1 
                    CSvrSettingsGeneralPage* pControlPage = new CSvrSettingsGeneralPage(pFolder->m_pCertCA);
                    if (pControlPage != NULL)
                    {
                        pControlPage->m_hConsoleHandle = handle;   // only do this on primary
                        pBasePage = pControlPage;
                        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                        if (hPage == NULL)
                        {
                            hr = myHLastError();
                            _JumpError(hr, Ret, "CreatePropertySheetPage");
                        }
                        lpProvider->AddPage(hPage);
                    }

                    //2
                    {
                        CSvrSettingsPolicyPage* pPage = new CSvrSettingsPolicyPage(pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                    }

                    //3
                    {
                        CSvrSettingsExitPage* pPage = new CSvrSettingsExitPage(pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                    }
            
                    //4 
                    {
                        // Centralized extensions page available only in whistler
                        if (pFolder->m_pCertCA->m_pParentMachine->FIsWhistlerMachine())
                        {

                        CSvrSettingsExtensionPage* pPage = new CSvrSettingsExtensionPage(pFolder->m_pCertCA, pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                        } 
                    }

                    //5
                    {
                        CSvrSettingsStoragePage* pPage = new CSvrSettingsStoragePage(pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                    }
                    //6
                    {
                        // restricted officers available only in whistler advanced server
                        if(pFolder->m_pCertCA->m_pParentMachine->FIsWhistlerMachine() && pFolder->m_pCertCA->FIsAdvancedServer())
                        {
                            CSvrSettingsCertManagersPage* pPage = 
                                new CSvrSettingsCertManagersPage(pControlPage);
                            if (pPage != NULL)
                            {
                                pBasePage = pPage;
                                HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                                if (hPage == NULL)
                                {
                                    hr = myHLastError();
                                    _JumpError(hr, Ret, "CreatePropertySheetPage");
                                }
                                lpProvider->AddPage(hPage);
                            }
                        }
                    }
                    //7
                    {
                        // audit available only in whistler
                        if(pFolder->m_pCertCA->m_pParentMachine->FIsWhistlerMachine())
                        {
                            CSvrSettingsAuditFilterPage* pPage = 
                                new CSvrSettingsAuditFilterPage(pControlPage);
                            if (pPage != NULL)
                            {
                                pBasePage = pPage;
                                HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                                if (hPage == NULL)
                                {
                                    hr = myHLastError();
                                    _JumpError(hr, Ret, "CreatePropertySheetPage");
                                }
                                lpProvider->AddPage(hPage);
                            }
                        }
                    }
                    //8
                    {
                        // audit available only in whistler advanced server, enterprise
                        if(pFolder->m_pCertCA->m_pParentMachine->FIsWhistlerMachine() && pFolder->m_pCertCA->FIsAdvancedServer() && IsEnterpriseCA(pFolder->m_pCertCA->GetCAType()) )
                        {
                        CSvrSettingsKRAPage* pPage = new CSvrSettingsKRAPage(
                                                            pFolder->m_pCertCA,
                                                            pControlPage);
                        if (pPage != NULL)
                        {
                            pBasePage = pPage;
                            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                        }
                    }
                    //9
                    {
                        // if error, don't display this page
                        LPSECURITYINFO pCASecurity = NULL;

                        hr = CreateCASecurityInfo(pFolder->m_pCertCA,  &pCASecurity);
                        _PrintIfError(hr, "CreateCASecurityInfo");
                        
                        if (hr == S_OK)
                        {
                            // allow proppages to clean up security info
                            pControlPage->SetAllocedSecurityInfo(pCASecurity);
                        
                            HPROPSHEETPAGE hPage = CreateSecurityPage(pCASecurity);
                            if (hPage == NULL)
                            {
                                hr = myHLastError();
                                _JumpError(hr, Ret, "CreatePropertySheetPage");
                            }
                            lpProvider->AddPage(hPage);
                        }
                    }    

                    hr = S_OK;
                    break;
                }// end  case SERVER_INSTANCE
                case SERVERFUNC_CRL_PUBLICATION:
                {
                    //1
                    CCRLPropPage* pControlPage = new CCRLPropPage(pFolder->m_pCertCA);
                    if (pControlPage != NULL)
                    {
                        pControlPage->m_hConsoleHandle = handle;
                        pBasePage = pControlPage;

                        // Object gets deleted when the page is destroyed
                        ASSERT(lpProvider != NULL);
        
                        ASSERT(pBasePage != NULL);
                        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                        if (hPage == NULL)
                        {
                            hr = myHLastError();
                            _JumpError(hr, Ret, "CreatePropertySheetPage");
                        }

                        lpProvider->AddPage(hPage);
                    }
                    //2
                    {
                    CCRLViewPage* pPage = new CCRLViewPage(pControlPage);
                    if (pPage != NULL)
                    {
                        pBasePage = pPage;
                        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                        if (hPage == NULL)
                        {
                            hr = myHLastError();
                            _JumpError(hr, Ret, "CreatePropertySheetPage");
                        }

                        lpProvider->AddPage(hPage);
                    }
                    }
                    break;
                }
                default:
                    break;
                }   // end  switch(pFolder->m_type)
        
            } // end  switch(scope)
        }
        break;
    default:
        break;
    }

Ret:
    FREE_DATA(pInternal);
    return hr;
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (NULL == pInternal)
        return S_FALSE;

    if (pInternal->m_cookie != NULL)
    {
        CFolder* pFolder = GetParentFolder(pInternal);
        if (pFolder != NULL)
        {
            switch(pFolder->m_type)
            {
            case SERVER_INSTANCE:
            case SERVERFUNC_CRL_PUBLICATION:
                bResult = TRUE;
            default:
                break;
            }
        }
    }
    else
    {
        // say YES to snapin manager
        if (CCT_SNAPIN_MANAGER == pInternal->m_type)
            bResult = TRUE;
    }
            
    FREE_DATA(pInternal);
    return (bResult) ? S_OK : S_FALSE;

    // Look at the data object and see if it an item in the scope pane
    // return IsScopePaneNode(lpDataObject) ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject, 
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TASKITEM* pm = NULL;

    // Note - snap-ins need to look at the data object and determine
    // in what context, menu items need to be added. They must also
    // observe the insertion allowed flags to see what items can be 
    // added.


    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (NULL == pInternal)
        return S_OK;

    BOOL fResultItem = (pInternal->m_type == CCT_RESULT);
    BOOL fMultiSel = IsMMCMultiSelectDataObject(pDataObject);

    CFolder* pFolder;
    if (!fResultItem)
        pFolder = GetParentFolder(pInternal);
    else
    {
        // GetParent might work, but doesn't for virtual items...
        ASSERT(m_pCurSelFolder);
        pFolder = m_pCurSelFolder;
    }

    FOLDER_TYPES folderType = NONE;
    if (pFolder == NULL)
        folderType = MACHINE_INSTANCE;
    else
        folderType = pFolder->GetType();

    // Loop through and add each of the "topItems"
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
    {
        // don't do for multisel
        if (!fMultiSel)
        {
            pm = (TASKITEM*) LocalAlloc(LMEM_FIXED, sizeof(topItems));
            _JumpIfAllocFailed(pm, Ret);

            memcpy(pm, topItems, sizeof(topItems));

            // Disable retarget if we haven't yet clicked on the static root. Otherwise, 
            // DisplayProperRootNodeName handles load-from-file
            // MMCN_EXPAND handles add/remove and expanded
            pm[ENUM_RETARGET_SNAPIN].myitem.item.fFlags = m_pStaticRoot ? MFS_ENABLED : MFS_GRAYED;

            for (TASKITEM* pm1=pm; pm1->myitem.item.strName; pm1++)
            {
                // does it match scope/result type?
                if (fResultItem != ((pm1->dwFlags & TASKITEM_FLAG_RESULTITEM) != 0) )
                    continue;

                // does it match area it should be in?
                // for each task, insert if matches the current folder
                if ((pm1->type != SERVERFUNC_ALL_FOLDERS) && (folderType != pm1->type))
                    continue;

                hr = pContextMenuCallback->AddItem(&pm1->myitem.item);
                _JumpIfError(hr, Ret, "AddItem");
            }

            LocalFree(pm);
            pm = NULL;
        }
    }

    // this is the end of the line if folder nonexistant
    if (pFolder == NULL)
        goto Ret;

    // Loop through and add each of the view items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        // ptr to tasks
        pm = (TASKITEM*) LocalAlloc(LMEM_FIXED, sizeof(taskItems));
        _JumpIfAllocFailed(pm, Ret);

        memcpy(pm, taskItems, sizeof(taskItems));

        BOOL fRunningLocally = m_pCertMachine->IsLocalMachine();
        BOOL fSvcRunning = m_pCertMachine->IsCertSvrServiceRunning();
        if ( IsAllowedStartStop(pFolder, m_pCertMachine) )
            AddStartStopTasks(pFolder, pContextMenuCallback, fSvcRunning);

        // only fixup on server instance
        if (folderType == SERVER_INSTANCE)
        {
            // fixup entries depending on install type/state
            if (IsRootCA(pFolder->GetCA()->GetCAType()))  // root ca?
            {
                pm[ENUM_TASK_INSTALL].myitem.item.fFlags = MFS_HIDDEN; // not available
                pm[ENUM_TASK_REQUEST].myitem.item.fFlags = MFS_HIDDEN; // not available
                pm[ENUM_TASK_ROLLOVER].myitem.item.fFlags = MFS_ENABLED; 
            }
            else   // sub ca
            {
                if (pFolder->GetCA()->FIsRequestOutstanding())
                    pm[ENUM_TASK_INSTALL].myitem.item.fFlags = MFS_ENABLED; 
                else
                    pm[ENUM_TASK_INSTALL].myitem.item.fFlags = MFS_HIDDEN; 
      
                if (pFolder->GetCA()->FIsIncompleteInstallation()) // incomplete
                {
                    pm[ENUM_TASK_REQUEST].myitem.item.fFlags = MFS_ENABLED; 
                    pm[ENUM_TASK_ROLLOVER].myitem.item.fFlags = MFS_HIDDEN;     // not available
                }
                else // complete install
                {
                    pm[ENUM_TASK_REQUEST].myitem.item.fFlags = MFS_HIDDEN; // not available
                    pm[ENUM_TASK_ROLLOVER].myitem.item.fFlags = MFS_ENABLED; 
                }
            }

            static bool fIsMember;
            static bool fIsMemberChecked = false;

            if(!fIsMemberChecked)
            {
                hr = myIsCurrentUserBuiltinAdmin(&fIsMember);
                if(S_OK==hr)
                {
                    fIsMemberChecked = true;
                }
            }

            // Hide renew/install CA cert item if not local admin or if we
            // failed to figure it out. Ignore the error.

            // !!! Post Whistler when we get renew CA cert to work for non
            // local admin we should change the code here to hide the item
            // based on the role that is allowed to do it.
            if(S_OK != hr || !fIsMember)
            {
                pm[ENUM_TASK_ROLLOVER].myitem.item.fFlags = MFS_HIDDEN;
                
                hr = S_OK;
            }
        }


        // don't allow properties on multisel
        pm[ENUM_TASK_ATTREXTS_CRL].myitem.item.fFlags = fMultiSel ? MFS_HIDDEN : MFS_ENABLED;
        pm[ENUM_TASK_ATTREXTS_ISS].myitem.item.fFlags = fMultiSel ? MFS_HIDDEN : MFS_ENABLED;
        pm[ENUM_TASK_ATTREXTS_PEND].myitem.item.fFlags = fMultiSel ? MFS_HIDDEN : MFS_ENABLED;
        pm[ENUM_TASK_ATTREXTS_FAIL].myitem.item.fFlags = fMultiSel ? MFS_HIDDEN : MFS_ENABLED;

        // disable based on roles
        for(TASKITEM* pm1=pm; pm1->myitem.item.strName; pm1++)
        {
            if((pm1->myitem.item.fFlags == MFS_ENABLED) &&
                !((pm1->myitem.dwRoles) & (pFolder->m_pCertCA->GetMyRoles())))
                pm1->myitem.item.fFlags = MFS_GRAYED;
        }

        // insert all other tasks per folder
        for (TASKITEM* pm1=pm; pm1->myitem.item.strName; pm1++)
        {
            // does it match scope/result type?
            if (fResultItem != ((pm1->dwFlags & TASKITEM_FLAG_RESULTITEM) != 0))
                continue;

            // are we remote, and is it marked localonly? (not yes/no like other tests here)
            if (((pm1->dwFlags & TASKITEM_FLAG_LOCALONLY)) && (!fRunningLocally))
                continue;

            // does it match area it should be in?
            // for each task, insert if matches the current folder
            if ((pm1->type != SERVERFUNC_ALL_FOLDERS) && (folderType != pm1->type))
                continue;

            // is this task supposed to be hidden?
            if (MFS_HIDDEN == pm1->myitem.item.fFlags)
                continue;

            hr = pContextMenuCallback->AddItem(&pm1->myitem.item);
            _JumpIfError(hr, Ret, "AddItem");
        }

        LocalFree(pm);
        pm = NULL;
    }

Ret:
    LOCAL_FREE(pm);
    FREE_DATA(pInternal);
    return hr;
}


BOOL CComponentDataImpl::AddStartStopTasks(
            CFolder *pFolder,
            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
            BOOL fSvcRunning)
{
    HRESULT hr;
    MY_CONTEXTMENUITEM* pm = taskStartStop; 

    bool fUserCanStart = (pm[ENUM_TASK_START].dwRoles) & (pFolder->m_pCertCA->GetMyRoles())?
        true:false;
    bool fUserCanStop  = (pm[ENUM_TASK_STOP].dwRoles) & (pFolder->m_pCertCA->GetMyRoles())?
        true:false;

    pm[ENUM_TASK_START].item.fFlags = 
        (fSvcRunning || !fUserCanStart)?
        MF_GRAYED : MF_ENABLED;
    hr = pContextMenuCallback->AddItem(&pm[ENUM_TASK_START].item);
    _JumpIfError(hr, Ret, "AddItem");

    pm[ENUM_TASK_STOP].item.fFlags = 
         (fSvcRunning && fUserCanStop)?
         MF_ENABLED : MF_GRAYED;
    hr = pContextMenuCallback->AddItem(&pm[ENUM_TASK_STOP].item);
    _JumpIfError(hr, Ret, "AddItem");

Ret:
    return (hr == ERROR_SUCCESS);
}

STDMETHODIMP CComponentDataImpl::Command(LONG nCommandID, LPDATAOBJECT pDataObject)
{
    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.
    HRESULT dwErr = S_OK;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    ASSERT(pInternal);
    if (NULL == pInternal)
        return S_OK;

    BOOL fMustRefresh = FALSE;
    BOOL fPopup = TRUE;

    CFolder* pFolder = GetParentFolder(pInternal);

    // Handle each of the commands.
    switch (nCommandID)
    {
    case IDC_STOPSERVER:
    {
        HWND hwndMain;
        dwErr = m_pConsole->GetMainWindow(&hwndMain);

        if (dwErr == S_OK)
            dwErr = m_pCertMachine->CertSvrStartStopService(hwndMain, FALSE);


        // notify views: refresh service toolbar buttons
        fMustRefresh = TRUE;
        break;
    }
    case IDC_STARTSERVER:
    {
        HWND hwndMain;
        dwErr = m_pConsole->GetMainWindow(&hwndMain);
        
        if (S_OK == dwErr)
            dwErr = m_pCertMachine->CertSvrStartStopService(hwndMain, TRUE);


        // check for ERROR_INSTALL_SUSPEND or HR(ERROR_INSTALL_SUSPEND)!!
        if ((((HRESULT)ERROR_INSTALL_SUSPEND) == dwErr) || (HRESULT_FROM_WIN32(ERROR_INSTALL_SUSPEND) == dwErr))
        {
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_COMPLETE_HIERARCHY_INSTALL_MSG); 
            cstrTitle.LoadString(IDS_MSG_TITLE);

            CertSvrCA* pCA;

            for (DWORD i=0; i<m_pCertMachine->GetCaCount(); i++)
            {
                pCA = m_pCertMachine->GetCaAtPos(i);

                // search for any/all incomplete hierarchies
                if (pCA->FIsIncompleteInstallation())
                {
                    int iRet;
                    WCHAR sz[512];
                    wsprintf(sz, (LPCWSTR)cstrMsg, (LPCWSTR)pCA->m_strCommonName, (LPCWSTR)pCA->m_strServer);

                    m_pConsole->MessageBox(
                        sz, 
                        cstrTitle,
                        MB_YESNO,
                        &iRet);
            
                    if (IDYES != iRet)
                        break;

	            dwErr = CARequestInstallHierarchyWizard(pCA, hwndMain, FALSE, FALSE);
                    if (dwErr != S_OK)
                    {
//                         fPopup = FALSE;// sometimes no notification -- better to have 2 dlgs
                         break;
                    }
                }
            }

            // my responsibility to start the service again
            if (dwErr == S_OK)
                dwErr = m_pCertMachine->CertSvrStartStopService(hwndMain, TRUE);
        }
        else if ((((HRESULT)ERROR_FILE_NOT_FOUND) == dwErr) || (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == dwErr))
        {
            // file not found error could be related to policy module
            WCHAR const *pwsz = myGetErrorMessageText(dwErr, TRUE);
            CString cstrFullMessage = pwsz;
	    if (NULL != pwsz)
	    {
		LocalFree(const_cast<WCHAR *>(pwsz));
	    }
            cstrFullMessage += L"\n\n";

            CString cstrHelpfulMessage;
            cstrHelpfulMessage.LoadString(IDS_POSSIBLEERROR_NO_POLICY_MODULE);
            cstrFullMessage += cstrHelpfulMessage;

            CString cstrTitle;
            cstrTitle.LoadString(IDS_MSG_TITLE);

            int iRet;
            m_pConsole->MessageBox(
                cstrFullMessage, 
                cstrTitle,
                MB_OK,
                &iRet);

            dwErr = ERROR_SUCCESS;
        }

        // notify views: refresh service toolbar buttons
        fMustRefresh = TRUE;
        break;
    }
    case IDC_PUBLISHCRL:
        {
        ASSERT(pInternal->m_type != CCT_RESULT);
        if (NULL == pFolder)
            break;

        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        ASSERT(dwErr == ERROR_SUCCESS);
        if (dwErr != ERROR_SUCCESS)
            hwnd = NULL;        // should work

        dwErr = PublishCRLWizard(pFolder->m_pCertCA, hwnd);
        break;

        // no refresh
        }
    case IDC_BACKUP_CA:
        {
        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        if (NULL == pFolder)
            break;

        dwErr = CABackupWizard(pFolder->GetCA(), hwnd);

        // refresh the status of the CA -- may have started it during this operation
        fMustRefresh = TRUE;
        break;
        }
    case IDC_RESTORE_CA:
        {
        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        if (NULL == pFolder)
            break;
         
        dwErr = CARestoreWizard(pFolder->GetCA(), hwnd);

        if ((myJetHResult(JET_errDatabaseDuplicate) == dwErr) || 
            HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY) == dwErr)
        {
            DisplayCertSrvErrorWithContext(hwnd, dwErr, IDS_ERR_RESTORE_OVER_EXISTING_DATABASE);
            dwErr = S_OK;
        }

        if (HRESULT_FROM_WIN32(ERROR_DIRECTORY) == dwErr)
        {
            DisplayCertSrvErrorWithContext(hwnd, dwErr, IDS_ERR_RESTORE_OUT_OF_ORDER);
            dwErr = S_OK;
        }

        // refresh after restore
        fMustRefresh = TRUE;

        break;
        }
    case IDC_SUBMITREQUEST:
        {
        HWND hwnd;
        WCHAR szCmdLine[MAX_PATH], szSysDir[MAX_PATH];

        STARTUPINFO sStartup;
        ZeroMemory(&sStartup, sizeof(sStartup));
        PROCESS_INFORMATION sProcess;
        ZeroMemory(&sProcess, sizeof(sProcess));
        sStartup.cb = sizeof(sStartup);

        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        if (NULL == pFolder)
            break;

 
        if (0 == GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)))
        {
           dwErr = GetLastError();
           break;
        }

        // exec "certutil -dump szReqFile szTempFile"
        wsprintf(szCmdLine, L"%ws\\certreq.exe -config \"%ws\"", szSysDir, (LPCWSTR)pFolder->GetCA()->m_strConfig);
        wcscat(szSysDir, L"\\certreq.exe");

        if (!CreateProcess(
          szSysDir, // exe
          szCmdLine, // full cmd line
          NULL,
          NULL,
          FALSE,
          CREATE_NO_WINDOW,
          NULL,
          NULL,
          &sStartup,
          &sProcess))
        {
            dwErr = GetLastError();
            break;
        }

        dwErr = S_OK;
        break;
        }
    case IDC_INSTALL_CA:
    case IDC_REQUEST_CA:
    case IDC_ROLLOVER_CA:
        {
        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        if (NULL == pFolder)
        {
            dwErr = E_UNEXPECTED;
            break;
        }
        dwErr = CARequestInstallHierarchyWizard(pFolder->GetCA(), hwnd, (nCommandID==IDC_ROLLOVER_CA), TRUE);
        if (S_OK != dwErr)
        {
            // low level lib had popup 
//            fPopup = FALSE; // sometimes no notification -- better to have 2 dlgs
        }

        // notify views: refresh service toolbar buttons
        fMustRefresh = TRUE;

        break;
        }
    case IDC_RETARGET_SNAPIN:
        {
        HWND hwnd;
        dwErr = m_pConsole->GetMainWindow(&hwnd);
        // NULL should work
        if (S_OK != dwErr)
            hwnd = NULL;

        // this should be base folder ONLY
        if(pFolder != NULL)
        {
            dwErr = E_POINTER;
            break;
        }

        CString strMachineNamePersist, strMachineName;
        CChooseMachinePropPage* pPage = new CChooseMachinePropPage();       // autodelete proppage -- don't delete
        if (pPage == NULL)
        {
            dwErr = E_OUTOFMEMORY;
            break;
        }

        pPage->SetCaption(IDS_SCOPE_MYCOMPUTER);

	    // Initialize state of object
        pPage->InitMachineName(NULL);
       
        // populate UI 
        strMachineNamePersist = m_pCertMachine->m_strMachineNamePersist;
        strMachineName = m_pCertMachine->m_strMachineName;

        // point to our member vars
        pPage->SetOutputBuffers(
		    &strMachineNamePersist,
		    &strMachineName,
            &m_dwFlagsPersist);	

        ASSERT(pPage != NULL);
        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pPage->m_psp);
        if (hPage == NULL)
        {
            dwErr = E_UNEXPECTED;
            break;
        }

        PROPSHEETHEADER sPsh;
        ZeroMemory(&sPsh, sizeof(sPsh));
        sPsh.dwSize = sizeof(sPsh);
        sPsh.dwFlags = PSH_WIZARD;
        sPsh.hwndParent = hwnd;
        sPsh.hInstance = g_hInstance;
        sPsh.nPages = 1;
        sPsh.phpage = &hPage;

        dwErr = (DWORD) PropertySheet(&sPsh);
        if (dwErr == (HRESULT)-1)
        {
            // error
            dwErr = GetLastError();
            break;
        }
        if (dwErr == (HRESULT)0)
        {
            // cancel
            break;
        }

        // we've grabbed the user's choice by now, finish retargetting
        CertSvrMachine* pOldMachine = m_pCertMachine;
        m_pCertMachine = new CertSvrMachine;
        if (NULL == m_pCertMachine)
        {
            m_pCertMachine = pOldMachine;
            break;  // bail!
        }

        // copy to machine object
        m_pCertMachine->m_strMachineNamePersist = strMachineNamePersist;
        m_pCertMachine->m_strMachineName = strMachineName;

        dwErr = DisplayProperRootNodeName(m_pStaticRoot); // fix display
        _PrintIfError(dwErr, "DisplayProperRootNodeName");

        dwErr = SynchDisplayedCAList(pDataObject);      // add/remove folders 
        _PrintIfError(dwErr, "SynchDisplayedCAList");
            
        // after Synch, we remove old machine -- there are no references left to it
        if (pOldMachine)
            pOldMachine->Release();

        fMustRefresh = TRUE;    // update folder icons, descriptions

        break;
        }
    default:
        ASSERT(FALSE); // Unknown command!
        break;
    }



    FREE_DATA(pInternal);

    if ((dwErr != ERROR_SUCCESS) && 
        (dwErr != ERROR_CANCELLED) && 
        (dwErr != HRESULT_FROM_WIN32(ERROR_CANCELLED)) && 
        (dwErr != HRESULT_FROM_WIN32(ERROR_NOT_READY))
        && fPopup)
    {
        HWND hwnd;
        DWORD dwErr2 = m_pConsole->GetMainWindow(&hwnd);
        ASSERT(dwErr2 == ERROR_SUCCESS);
        if (dwErr2 != ERROR_SUCCESS)
            hwnd = NULL;        // should work

        if (((HRESULT)RPC_S_SERVER_UNAVAILABLE) == dwErr)
        {
            DisplayCertSrvErrorWithContext(hwnd, dwErr, IDS_SERVER_UNAVAILABLE);
        }
        else if(HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION)==dwErr ||
                ((HRESULT)ERROR_OLD_WIN_VERSION)==dwErr)
        {
            DisplayCertSrvErrorWithContext(hwnd, dwErr, IDS_OLD_CA);
        }
        else
        {
            DisplayGenericCertSrvError(hwnd, dwErr);
        }
    }

    // only do this once
    if (fMustRefresh)
    {
        // notify views: refresh service toolbar buttons
        m_pConsole->UpdateAllViews(
            pDataObject,
            0,
            0);
    }

    return S_OK;
}

void CComponentDataImpl::UpdateScopeIcons()
{
    CFolder* pFolder;
    POSITION pos;
    
    int nImage;
    
    // walk through our internal list, modify, and resend to scope
    pos = m_scopeItemList.GetHeadPosition();
    while(pos)
    {
        pFolder = m_scopeItemList.GetNext(pos);
        ASSERT(pFolder);
        if (NULL == pFolder)
            break;

        // only modify server instances
        if (pFolder->GetType() != SERVER_INSTANCE)
            continue;

        if (pFolder->m_pCertCA->m_pParentMachine->IsCertSvrServiceRunning())
            nImage = IMGINDEX_CERTSVR_RUNNING;
        else
            nImage = IMGINDEX_CERTSVR_STOPPED;

        // folder currently has these values defined, right?
        ASSERT(pFolder->m_ScopeItem.mask & SDI_IMAGE);
        ASSERT(pFolder->m_ScopeItem.mask & SDI_OPENIMAGE);

        // These are the only values we wish to reset
        pFolder->m_ScopeItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
        
        pFolder->m_ScopeItem.nImage = nImage;
        pFolder->m_ScopeItem.nOpenImage = nImage;

        // and send these changes back to scope
        m_pScope->SetItem(&pFolder->m_ScopeItem);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

const GUID* FolderTypeToNodeGUID(DATA_OBJECT_TYPES type, CFolder* pFolder);

class CDataObject : 
    public IDataObject, 
    public CComObjectRoot
{

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()


// Construction/Destruction
    CDataObject();
    virtual ~CDataObject() 
    {
        if (m_pComponentData)
        {
            m_pComponentData->Release();        
            m_pComponentData = NULL;
        }
    };

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;        // Required by the console
    static unsigned int    m_cfNodeID;          // per-node column identifiers
    static unsigned int    m_cfNodeTypeString;  // Required by the console
    static unsigned int    m_cfDisplayName;     // Required by the console
    static unsigned int    m_cfCoClass;         // Required by the console
    static unsigned int    m_cfIsMultiSel;      // Required by the console
    static unsigned int    m_cfObjInMultiSel;   // Required by the console
    static unsigned int    m_cfPreloads;        // Required by the console

    static unsigned int    m_cfInternal;        // 
    static unsigned int    m_cfSelectedCA_InstallType;   // published information
    static unsigned int	   m_cfSelectedCA_CommonName;    // Published information
    static unsigned int	   m_cfSelectedCA_MachineName;   // Published information
    static unsigned int	   m_cfSelectedCA_SanitizedName; // Published information
    static unsigned int    m_cfSelectedCA_Roles;         // Published information

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

// Not Implemented
private:

    STDMETHOD(GetCanonicalFormatEtc)(
		LPFORMATETC, // lpFormatetcIn
		LPFORMATETC /* lpFormatetcOut */ )
    {
	return E_NOTIMPL;
    }

    STDMETHOD(SetData)(
		LPFORMATETC, // lpFormatetc
		LPSTGMEDIUM, // lpMedium
		BOOL /* bRelease */ )
    {
	return E_NOTIMPL;
    }

    STDMETHOD(DAdvise)(
		LPFORMATETC, // lpFormatetc
		DWORD, // advf
                LPADVISESINK, // pAdvSink
		LPDWORD /* pdwConnection */ )
    {
	return E_NOTIMPL;
    }
    
    STDMETHOD(DUnadvise)(
		DWORD /* dwConnection */ )
    {
	return E_NOTIMPL;
    };

    STDMETHOD(EnumDAdvise)(
		LPENUMSTATDATA * /* ppEnumAdvise */ )
    {
	return E_NOTIMPL;
    };

// Implementation

    // This is used only as a diagnostic in debug builds to track if 
    // anyone is hanging on to any data objects that's have been handed out
    // Snapins should view context data objects as ephemeral.
public:
    void SetComponentData(CComponentDataImpl* pCCD) 
    {
        if (NULL != pCCD)
        {           
            ASSERT(m_pComponentData == NULL); 
            m_pComponentData = pCCD;
            m_pComponentData->AddRef();
        }
    } 
private:
    CComponentDataImpl* m_pComponentData;



public:
    void SetViewID(
	    DWORD /* dwView */ )
    {
	// m_dwViewID = dwView;
    }
    void SetType(DATA_OBJECT_TYPES type) { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }
    void SetCookie(MMC_COOKIE cookie)   { m_internal.m_cookie = cookie; } 
    void SetString(LPTSTR lpString)     { m_internal.m_string = lpString; }
    void SetClsid(const CLSID& clsid)   { m_internal.m_clsid = clsid; }

    void SetMultiSelData(SMMCObjectTypes *psGuidObjTypes, UINT cbMultiSelData)
    {
        // make sure [1] still good enough
        ASSERT(cbMultiSelData == sizeof(m_sGuidObjTypes));
        if (cbMultiSelData == sizeof(m_sGuidObjTypes))
        {
            m_cbMultiSelData = cbMultiSelData;
            CopyMemory(&m_sGuidObjTypes, psGuidObjTypes, cbMultiSelData);
        }
    }

    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = TRUE;
    }

#ifdef _DEBUG
    UINT dbg_refCount;

    void AddRefMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        ++dbg_refCount;
    }

    void ReleaseMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        --dbg_refCount;
    }
#endif

private:
    HRESULT CreateObjInMultiSel(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeIDData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); 
    HRESULT CreateWorkstationName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreatePreloadsData(LPSTGMEDIUM lpMedium);
    
    HRESULT CreateSelectedCA_InstallType(LPSTGMEDIUM lpMedium);
    HRESULT CreateSelectedCA_CommonName(LPSTGMEDIUM lpMedium);
    HRESULT CreateSelectedCA_MachineName(LPSTGMEDIUM lpMedium);
    HRESULT CreateSelectedCA_SanitizedName(LPSTGMEDIUM lpMedium);
    HRESULT CreateSelectedCA_Roles(LPSTGMEDIUM lpMedium);

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
    HRESULT CreateVariableLen(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);


private:
    INTERNAL m_internal;    

    SMMCObjectTypes m_sGuidObjTypes; // length[1] good enough for now
    UINT m_cbMultiSelData;
    BOOL m_bMultiSelDobj;

    DWORD m_dwViewID;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\chooser.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chooser.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	Chooser.cpp
//
//	Dialog to choose a machine name.
//
//	PURPOSE
//	What you have to do is to copy all the files from the
//	snapin\chooser\ directory into your project (you may add
//	\nt\private\admin\snapin\chooser\ to your include directory if
//	you prefer not copying the code).
//	If you decide to copy the code to your project, please send mail
//	to Dan Morin (T-DanM) and cc to Jon Newman (JonN) so we can
//	mail you when we have updates available.  The next update will
//	be the "Browse" button to select a machine name.
//
//
//  DYNALOADED LIBRARIES
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//	23-May-1997		t-danm		Checkin into public tree. Comments updates.
//	25-May-1997		t-danm		Added MMCPropPageCallback().
//      31-Oct-1997             mattt           Added dynaload, fixed user <CANCEL> logic
//       1-Oct-1998             mattt           Removed reliance on MFC, changed default look to enable certsvr picker
//
/////////////////////////////////////////////////////////////////////

#include <stdafx.h>

#include "chooser.h"
#include "csdisp.h" // certsrv picker

#define __dwFILE__	__dwFILE_CERTMMC_CHOOSER_CPP__


#ifdef _DEBUG
#undef THIS_FILE
#define THIS_FILE __FILE__
#endif

#ifndef INOUT		
// The following defines are found in \nt\private\admin\snapin\filemgmt\stdafx.h

#define INOUT
#define	Endorse(f)		// Dummy macro
#define LENGTH(x)		(sizeof(x)/sizeof(x[0]))
#define Assert(f)		ASSERT(f)
#endif

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Replacement for BEGIN_MESSAGE_MAP
BOOL
CAutoDeletePropPage::OnCommand(
    WPARAM, // wParam
    LPARAM /* lParam */ )
{
/*
    switch(LOWORD(wParam))
    {
    }
*/
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
//	Constructor
CAutoDeletePropPage::CAutoDeletePropPage(UINT uIDD) : PropertyPage(uIDD)
{
    m_prgzHelpIDs = NULL;
    m_autodeleteStuff.cWizPages = 1; // Number of pages in wizard
    m_autodeleteStuff.pfnOriginalPropSheetPageProc = m_psp.pfnCallback;

    m_psp.dwFlags |= PSP_USECALLBACK;
    m_psp.pfnCallback = S_PropSheetPageProc;
    m_psp.lParam = reinterpret_cast<LPARAM>(this);
}

CAutoDeletePropPage::~CAutoDeletePropPage()
{
}


/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(LPCTSTR pszCaption)
{
    m_strCaption = pszCaption;		// Copy the caption
    m_psp.pszTitle = m_strCaption;	// Set the title
    m_psp.dwFlags |= PSP_USETITLE;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(UINT uStringID)
{
    VERIFY(m_strCaption.LoadString(uStringID));
    SetCaption(m_strCaption);
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    m_strHelpFile = szHelpFile;
    m_prgzHelpIDs = rgzHelpIDs;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
{
    Assert(IsWindow(::GetDlgItem(m_hWnd, nIdDlgItem)));
    ::EnableWindow(::GetDlgItem(m_hWnd, nIdDlgItem), fEnable);
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnSetActive()
{
    HWND hwndParent = ::GetParent(m_hWnd);
    Assert(IsWindow(hwndParent));
    ::PropSheet_SetWizButtons(hwndParent, PSWIZB_FINISH);
    return PropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::OnHelp(LPHELPINFO pHelpInfo)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    if (pHelpInfo != NULL && 
        pHelpInfo->iContextType == HELPINFO_WINDOW &&
        HasContextHelp(pHelpInfo->iCtrlId))
    {
        // Display context help for a control
        ::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::OnContextHelp(HWND hwnd)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    Assert(IsWindow(hwnd));

    if(HasContextHelp(GetDlgCtrlID(hwnd)))
    {
        ::WinHelp(
            hwnd, 
            m_strHelpFile, 
            HELP_CONTEXTMENU, 
            (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}

/////////////////////////////////////////////////////////////////////
bool CAutoDeletePropPage::HasContextHelp(int nDlgItem)
{
    const DWORD * pdwHelpIDs;

    for(pdwHelpIDs = m_prgzHelpIDs; 
        *pdwHelpIDs; 
        pdwHelpIDs += 2)
    {
        if(nDlgItem == (int) *pdwHelpIDs)
            return true;
    }
    return false;
}


/////////////////////////////////////////////////////////////////////
//	S_PropSheetPageProc()
//
//	Static member function used to delete the CAutoDeletePropPage object
//	when wizard terminates
//

UINT CALLBACK
CAutoDeletePropPage::S_PropSheetPageProc(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp)
{
    Assert(ppsp != NULL);
    CAutoDeletePropPage * pThis;
    pThis = reinterpret_cast<CAutoDeletePropPage*>(ppsp->lParam);
    Assert(pThis != NULL);

    BOOL fDefaultRet;

    fDefaultRet = FALSE;
    switch (uMsg)
    {
    case PSPCB_RELEASE:

        if (--(pThis->m_autodeleteStuff.cWizPages) <= 0)
        {
            // Remember callback on stack since "this" will be deleted
            LPFNPSPCALLBACK pfnOrig = pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc;
            delete pThis;

            if (pfnOrig)
                return (pfnOrig)(hwnd, uMsg, ppsp);
            else
                return fDefaultRet;
        }
        break;
    case PSPCB_CREATE:
        fDefaultRet = TRUE;
        // do not increase refcount, PSPCB_CREATE may or may not be called
        // depending on whether the page was created.  PSPCB_RELEASE can be
        // depended upon to be called exactly once per page however.
        break;

    } // switch

    if (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)
        return (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)(hwnd, uMsg, ppsp);
    else
        return fDefaultRet;
} // CAutoDeletePropPage::S_PropSheetPageProc()





/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Replacement for BEGIN_MESSAGE_MAP
BOOL
CChooseMachinePropPage::OnCommand(
    WPARAM wParam,
    LPARAM /* lParam */ )
{
    switch(LOWORD(wParam))
    {
    case IDC_CHOOSER_RADIO_LOCAL_MACHINE:
        OnRadioLocalMachine();
        break;
    case IDC_CHOOSER_RADIO_SPECIFIC_MACHINE:
        OnRadioSpecificMachine();
        break;
    case IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES:
        OnBrowse();
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


#ifdef _DEBUG
static void AssertValidDialogTemplate(HWND hwnd)
{
    ASSERT(::IsWindow(hwnd));
    // Mandatory controls for a valid dialog template
    static const UINT rgzidDialogControl[] =
    {
        IDC_CHOOSER_RADIO_LOCAL_MACHINE,
            IDC_CHOOSER_RADIO_SPECIFIC_MACHINE,
            IDC_CHOOSER_EDIT_MACHINE_NAME,
            0
    };

    for (int i = 0; rgzidDialogControl[i] != 0; i++)
    {
        ASSERT(NULL != GetDlgItem(hwnd, rgzidDialogControl[i]) &&
            "Control ID not found in dialog template.");
    }
} // AssertValidDialogTemplate()
#else
#define AssertValidDialogTemplate(hwnd)
#endif	// ~_DEBUG

/////////////////////////////////////////////////////////////////////
//	Constructor
CChooseMachinePropPage::CChooseMachinePropPage(UINT uIDD) : CAutoDeletePropPage(uIDD)
{
    m_fIsRadioLocalMachine = TRUE;
    m_fEnableMachineBrowse = FALSE;

    m_pstrMachineNameOut = NULL;
    m_pstrMachineNameEffectiveOut = NULL;
    m_pdwFlags = NULL;
}

/////////////////////////////////////////////////////////////////////
CChooseMachinePropPage::~CChooseMachinePropPage()
{
}

/////////////////////////////////////////////////////////////////////
//	Load the initial state of CChooseMachinePropPage
void CChooseMachinePropPage::InitMachineName(LPCTSTR pszMachineName)
{
    m_strMachineName = pszMachineName;
    m_fIsRadioLocalMachine = m_strMachineName.IsEmpty();
}

/////////////////////////////////////////////////////////////////////
//	SetOutputBuffers()
//
//	- Set the pointer to the CString object to store the machine name.
//	- Set the pointer to the boolean flag for command line override.
//	- Set the pointer pointer to store the overriden machine name.
//
void CChooseMachinePropPage::SetOutputBuffers(
                                              OUT CString * pstrMachineNamePersist,	// Machine name the user typed.  Empty string == local machine.
                                              OUT CString * pstrMachineNameEffective,
                                              OUT DWORD*    pdwFlags)
{
    Assert(pstrMachineNamePersist != NULL && "Invalid output buffer");

    // point members at params
    m_pstrMachineNameOut = pstrMachineNamePersist;
    m_pstrMachineNameEffectiveOut = pstrMachineNameEffective;
    m_pdwFlags = pdwFlags;
    *m_pdwFlags = 0;
}

/////////////////////////////////////////////////////////////////////
// Replacement for DoDataExchange
BOOL CChooseMachinePropPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_strMachineName.FromWindow(GetDlgItem(m_hWnd, IDC_CHOOSER_EDIT_MACHINE_NAME));

        int iCheck = (int)SendMessage(GetDlgItem(m_hWnd, IDC_CHOOSER_MACHINE_OVERRIDE), BM_GETCHECK, 0, 0);
        if (iCheck == BST_CHECKED)
            *m_pdwFlags |= CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE;
        else
            *m_pdwFlags &= ~CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE;
    }
    else
    {
        m_strMachineName.ToWindow(GetDlgItem(m_hWnd, IDC_CHOOSER_EDIT_MACHINE_NAME));

        int iCheck;
        iCheck = (*m_pdwFlags & CCOMPDATAIMPL_FLAGS_ALLOW_MACHINE_OVERRIDE) ? BST_CHECKED : BST_UNCHECKED;
        SendMessage(GetDlgItem(m_hWnd, IDC_CHOOSER_MACHINE_OVERRIDE), BM_SETCHECK, iCheck, 0);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnInitDialog()
{
    AssertValidDialogTemplate(m_hWnd);
    CAutoDeletePropPage::OnInitDialog();
    InitChooserControls();

    PropSheet_SetWizButtons(GetParent(), PSWIZB_FINISH);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnWizardFinish()
{
    if (!UpdateData())		// Do the data exchange to collect data
        return FALSE;       // don't destroy on error

    if (m_fIsRadioLocalMachine)
        m_strMachineName.Empty();
    else
        if (m_strMachineName.IsEmpty())
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_MUST_CHOOSE_MACHINE);
            return FALSE;
        }

    if (m_pstrMachineNameOut != NULL)
    {
        // Store the machine name into its output buffer
        *m_pstrMachineNameOut = m_strMachineName;
        if (m_pstrMachineNameEffectiveOut != NULL)
        {
            *m_pstrMachineNameEffectiveOut = m_strMachineName;
        } // if
    }
    else
        Assert(FALSE && "FYI: You have not specified any output buffer to store the machine name.");

    return CAutoDeletePropPage::OnWizardFinish();
}

void CChooseMachinePropPage::InitChooserControls()
{
    SendDlgItemMessage(IDC_CHOOSER_RADIO_LOCAL_MACHINE, BM_SETCHECK, m_fIsRadioLocalMachine);
    SendDlgItemMessage(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, BM_SETCHECK, !m_fIsRadioLocalMachine);
    EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, !m_fIsRadioLocalMachine);

    PCCRYPTUI_CA_CONTEXT  pCAContext = NULL;
    DWORD dwCACount;
    HRESULT hr = myGetConfigFromPicker(
              m_hWnd,
              NULL, //sub title
              NULL, //title
              NULL,
	      GCFPF_USEDS,
              TRUE, // count only
              &dwCACount,
              &pCAContext);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
    {
        _PrintError(hr, "myGetConfigFromPicker");
        goto done;
    }
    m_fEnableMachineBrowse = (0 == dwCACount) ? FALSE : TRUE;
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }

done:
    EnableDlgItem(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES,
                  !m_fIsRadioLocalMachine && m_fEnableMachineBrowse);
}

void CChooseMachinePropPage::OnRadioLocalMachine()
{
    m_fIsRadioLocalMachine = TRUE;
    EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, FALSE);
    EnableDlgItem(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, FALSE);
}

void CChooseMachinePropPage::OnRadioSpecificMachine()
{
    m_fIsRadioLocalMachine = FALSE;
    EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, TRUE);
    EnableDlgItem(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, m_fEnableMachineBrowse);
}

void CChooseMachinePropPage::OnBrowse()
{
    HRESULT hr;
    WCHAR *szConfig = NULL;
    CWaitCursor cwait;

    // UNDONE: expand config picker to non-published (DS chooser dlg)
    hr = myGetConfigStringFromPicker(m_hWnd,
        NULL, //use default prompt
        NULL, //use default title
        NULL, //use default shared folder
        GCFPF_USEDS,
        &szConfig);
    if (hr == S_OK)
    {
        LPWSTR szWhack = wcschr(szConfig, L'\\');
        if (szWhack != NULL)
            szWhack[0] = L'\0';
        m_strMachineName = szConfig;

        LocalFree(szConfig);
    }

    // push result back to ui
    UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\csnapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.



#include "stdafx.h"
#include "resource.h"
#include "genpage.h"

#include "chooser.h"
#include "cryptui.h"

#include "misc.h"

#include <htmlhelp.h>

#define __dwFILE__	__dwFILE_CERTMMC_CSNAPIN_CPP__


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// approx convert chars->pixels
#define CHARS_TO_MMCCOLUMNWIDTH(__strlen__)  ((int)(__strlen__ * 7))



enum ENUM_MMCBUTTONS
{
    ENUM_BUTTON_STARTSVC=0,
    ENUM_BUTTON_STOPSVC,
};

MY_MMCBUTTON SvrMgrToolbar1Buttons[] =
{
    {
        { 0, IDC_STARTSERVER, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"", L"" },
        IDS_TASKMENU_STARTSERVICE,
        IDS_TASKMENU_STATUSBAR_STARTSERVICE,
    },

    {
        { 1, IDC_STOPSERVER,  TBSTATE_ENABLED, TBSTYLE_BUTTON, L"",  L"" },
        IDS_TASKMENU_STOPSERVICE,
        IDS_TASKMENU_STATUSBAR_STOPSERVICE,
    },

    {
        { 0, 0, 0, 0, NULL, NULL },
        IDS_EMPTY,
        IDS_EMPTY,
    }
};

// Array of view items to be inserted into the context menu.
// keep this enum in synch with viewItems[]
enum ENUM_VIEW_ITEMS
{
    ENUM_VIEW_ALL=0,
    ENUM_VIEW_FILTER,
    ENUM_VIEW_SEPERATOR,
};

MY_CONTEXTMENUITEM viewResultItems[] =
{
    {
        {
        L"", L"",
        IDC_VIEW_ALLRECORDS, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0
        },
        IDS_VIEWMENU_ALL_RECORDS,
        IDS_VIEWMENU_STATUSBAR_ALL_RECORDS,
    },

    {
        {
        L"", L"",
        IDC_VIEW_FILTER, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0
        },
        IDS_VIEWMENU_FILTER,
        IDS_VIEWMENU_STATUSBAR_FILTER,
    },

    // seperator
    {
        {
        L"", L"",
        0, CCM_INSERTIONPOINTID_PRIMARY_VIEW, MF_ENABLED, CCM_SPECIAL_SEPARATOR
        },
        IDS_EMPTY,
        IDS_EMPTY,
    },

    {
        { NULL, NULL, 0, 0, 0 },
        IDS_EMPTY,
        IDS_EMPTY,
    }
};

enum ENUM_TASK_SINGLESELITEMS
{
    ENUM_TASK_SEPERATOR1=0,
    ENUM_TASK_UNREVOKE,
};

TASKITEM taskResultItemsSingleSel[] =
{
    // seperator

    {   SERVERFUNC_CRL_PUBLICATION,
        TRUE,
    {
        {
        L"", L"",
        0, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, CCM_SPECIAL_SEPARATOR
        },
        IDS_EMPTY,
        IDS_EMPTY,
    }
    },

    {   SERVERFUNC_CRL_PUBLICATION,
        TRUE,
        {
            {
            L"", L"",
            IDC_UNREVOKE_CERT, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_ENABLED, 0
            },
            IDS_TASKMENU_UNREVOKECERT,
            IDS_TASKMENU_STATUSBAR_UNREVOKECERT,
            CA_ACCESS_OFFICER,
        }
    },

    {   NONE,
        FALSE,
        {
            { NULL, NULL, 0, 0, 0 },
            IDS_EMPTY,
            IDS_EMPTY,
        }
    }
};


//
// Extracts the coclass guid format from the data object
//
template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, unsigned int cf)
{
    ASSERT(lpDataObject != NULL);

    TYPE* p = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)cf, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    int len;

    if (cf == CDataObject::m_cfSelectedCA_CommonName)
        len = (MAX_PATH+1) * sizeof(TYPE);
    else if (cf == CDataObject::m_cfSelectedCA_MachineName)
        len = (MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE);
    else
        len = sizeof(TYPE);


    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);

    // Get the workstation name from the data object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;

        p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

        if (p == NULL)
            break;

    } while (FALSE);

    return p;
}

BOOL IsMMCMultiSelectDataObject(LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    FORMATETC fmt = {(CLIPFORMAT)CDataObject::m_cfIsMultiSel, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}

// rip real pDataObject out of SMMCDataObjects struct
HGLOBAL GetMMCMultiSelDataObject(LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    static unsigned int s_cf = 0;
    if (s_cf == 0)
        s_cf = RegisterClipboardFormatW(CCF_MULTI_SELECT_SNAPINS);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC fmt = {(CLIPFORMAT)s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (FAILED(pDataObject->GetData(&fmt, &stgmedium)))
        return NULL;

    return stgmedium.hGlobal;
}

// Data object extraction helpers
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject)
{
    return Extract<CLSID>(lpDataObject, CDataObject::m_cfCoClass);
}

HGLOBAL ExtractNodeID(LPDATAOBJECT lpDataObject)
{
    if (lpDataObject == NULL)
        return FALSE;

    static unsigned int s_cf = 0;
    if (s_cf == 0)
        s_cf = RegisterClipboardFormatW(CCF_COLUMN_SET_ID);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC fmt = {(CLIPFORMAT)s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (FAILED(lpDataObject->GetData(&fmt, &stgmedium)))
        return NULL;

    return stgmedium.hGlobal;
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
    return Extract<GUID>(lpDataObject, CDataObject::m_cfNodeType);
}

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    HRESULT hr;
    if (lpDataObject == NULL)
        return NULL;

    // see if this is a multisel object
    HGLOBAL hMem = NULL;
    SMMCDataObjects* pRealObjectStruct = NULL;
    INTERNAL* pRet = NULL;

    if (IsMMCMultiSelectDataObject(lpDataObject))
    {
        // multisel object: extract real SMMCDataObjects
        hMem = GetMMCMultiSelDataObject(lpDataObject);
        _JumpIfOutOfMemory(hr, Ret, hMem);

        pRealObjectStruct = (SMMCDataObjects*)::GlobalLock(hMem);
        _JumpIfOutOfMemory(hr, Ret, pRealObjectStruct);

        // may be a number of data objs in here; find OURS
        BOOL fFound = FALSE;
        for (DWORD i=0; i<pRealObjectStruct->count; i++)
        {
            CLSID* pExtractedID = ExtractClassID(pRealObjectStruct->lpDataObject[i]);
            if (NULL != pExtractedID)
            {
                if (IsEqualCLSID(CLSID_Snapin, *pExtractedID))
                {
                    fFound = TRUE;
                    break;
                }

                // Free resources
                GlobalFree(reinterpret_cast<HANDLE>(pExtractedID));
           }
        }

        if (!fFound)
            goto Ret;

        // data obj that matches our CLSID
        lpDataObject = pRealObjectStruct->lpDataObject[i];
    }
    pRet = Extract<INTERNAL>(lpDataObject, CDataObject::m_cfInternal);
    if (pRet == NULL)
    {
        hr = myHLastError();
        _PrintIfError(hr, "Extract CDO::m_cfInternal returned NULL");
    }

Ret:
    // free hMem
    if (NULL != hMem)
    {
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }

    return pRet;
}


/*
// only for use by OnRefresh -- this is a worker fxn
void CSnapin::RefreshFolder(CFolder* pFolder)
{
    MMC_COOKIE cookie = (MMC_COOKIE)pFolder;

    if (pFolder != NULL)    // not base folder
    {
        // HIDE, remove all items, remove header, SHOW
        OnShow(cookie, FALSE, 0);              // emulate HIDE
        m_pResult->DeleteAllRsltItems();                    // delete items from m_pResult
        while(S_OK == m_pHeader->DeleteColumn(0)) {};       // remove all cols from header

        OnShow(cookie, TRUE, 0);               // emulate SHOW
    }
    return;
}
*/

CFolder*    CSnapin::GetParentFolder(INTERNAL* pInternal)
{
    CFolder* p;

    if(m_bVirtualView)
        p = GetVirtualFolder();
    else
        p = ::GetParentFolder(pInternal);

#if DBG
    if (p != m_pCurrentlySelectedScopeFolder)
    {
        if (NULL == p)
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived NULL, current saved folder is <%ws>\n", m_pCurrentlySelectedScopeFolder->m_pszName));
        else if (NULL == m_pCurrentlySelectedScopeFolder)
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived as <%ws>, current saved folder is NULL\n", p->m_pszName));
        else
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived as <%ws>, current saved folder is <%ws>\n", p->m_pszName, m_pCurrentlySelectedScopeFolder->m_pszName));
    }
#endif

    return p;
}

// independent of scope/result type, will return parent folder
CFolder*    GetParentFolder(INTERNAL* pInternal)
{
    if (NULL == pInternal)
        return NULL;

    if (CCT_SCOPE == pInternal->m_type)
    {
        return reinterpret_cast<CFolder*>(pInternal->m_cookie);
    }
    else if (CCT_RESULT == pInternal->m_type)
    {
        RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->pParentFolder;
    }

    return NULL;
}


HRESULT _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, DWORD dwViewID,
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    ASSERT(pImpl != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    if (pObject == NULL)
        return E_OUTOFMEMORY;

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);
    pObject->SetViewID(dwViewID);

    // tell dataobj who we are
    pObject->SetComponentData(pImpl);

    // Store the coclass with the data object
    pObject->SetClsid(pImpl->GetCoClassID());

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}



/////////////////////////////////////////////////////////////////////////////
// Return TRUE if we are enumerating our main folder

BOOL CSnapin::IsEnumerating(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    ASSERT(lpDataObject);
    GUID* nodeType = ExtractNodeType(lpDataObject);

    if (NULL != nodeType)
    {
	    // Is this my main node (static folder node type)
	    if (::IsEqualGUID(*nodeType, cNodeTypeMachineInstance))
	        bResult = TRUE;

	    // Free resources
	    ::GlobalFree(reinterpret_cast<HANDLE>(nodeType));
    }
    return bResult;
}



/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation

STDMETHODIMP
CSnapin::GetResultViewType(
    MMC_COOKIE cookie,
    LPOLESTR *, // ppViewType
    LONG *pViewOptions)
{
    m_bVirtualView = FALSE;

    // custom view: check guid

    if (NULL == cookie)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        return S_FALSE;
    }

    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT | MMC_VIEW_OPTIONS_NOLISTVIEWS;

    // if ISSUED_CERT then make virtual list
    CFolder* pFolder = (CFolder*)cookie;
    if ((SERVERFUNC_CRL_PUBLICATION == pFolder->GetType()) ||
        (SERVERFUNC_ISSUED_CERTIFICATES == pFolder->GetType()) ||
        (SERVERFUNC_PENDING_CERTIFICATES == pFolder->GetType()) ||
        (SERVERFUNC_FAILED_CERTIFICATES == pFolder->GetType())  ||
        (SERVERFUNC_ALIEN_CERTIFICATES == pFolder->GetType()) ||
        (SERVERFUNC_ISSUED_CRLS == pFolder->GetType()) )
    {
        *pViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST;
        m_bVirtualView = TRUE;
    }

    // if list view
    return S_FALSE;
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    ASSERT(lpConsole != NULL);
    m_bInitializedC = true;

    // Save the IConsole pointer
    if (lpConsole == NULL)
        return E_POINTER;
    hr = lpConsole->QueryInterface(IID_IConsole2,
                        reinterpret_cast<void**>(&m_pConsole));
    _JumpIfError(hr, Ret, "QI IID_IConsole2");

    // QI for a IHeaderCtrl
    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));
    _JumpIfError(hr, Ret, "QI IID_IHeaderCtrl");

    // Give the console the header control interface pointer
    m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));
    _JumpIfError(hr, Ret, "QI IID_IResultData");

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    _JumpIfError(hr, Ret, "QueryResultImageList");

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    _JumpIfError(hr, Ret, "QueryConsoleVerb");

    hr = m_pConsole->QueryInterface(IID_IColumnData,
                        reinterpret_cast<void**>(&m_pViewData));
    _JumpIfError(hr, Ret, "QI IID_IViewData");

Ret:
    return hr;
}

// called by CompDataImpl on creation
void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}

STDMETHODIMP
CSnapin::Destroy(
    MMC_COOKIE) // cookie
{
    ASSERT(m_bInitializedC);
    m_bDestroyedC = true;

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        SAFE_RELEASE(m_pComponentData); // QI'ed in CSnapin::SetIComponent

        SAFE_RELEASE(m_pConsoleVerb);
        SAFE_RELEASE(m_pViewData);
    }

    return S_OK;
}


STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MMC_COOKIE cookie=0;

    if (IS_SPECIAL_DATAOBJECT(lpDataObject))
    {
        if (event == MMCN_BTN_CLICK)
        {
            if (m_CustomViewID != VIEW_DEFAULT_LV)
            {
                switch (param)
                {
                case MMC_VERB_REFRESH:

                    OnRefresh(lpDataObject);
                    break;

                case MMC_VERB_PROPERTIES:
                    break;

                default:
                    DBGPRINT((DBG_SS_CERTMMC, "MMCN_BTN_CLICK::param unknown"));
                    break;
                }
            }
        }
        else
        {
            switch (event)
            {
            case MMCN_VIEW_CHANGE:
            case MMCN_REFRESH:
                OnRefresh(lpDataObject);
                break;

            case MMCN_COLUMN_CLICK:

                // On click, we need to fix sorting.
                // Sorting info is usually retrieved from the view, but if a user column-clicks,
                // IComponent::Sort is called before GetColumnSortData() is updated.
                // In this case, we capture notification here and override GetColumnSortData() wrapper,
                // and force a folder refresh.

                // ask "IComponent::SortItems" if this is a valid column to sort on
                hr = SortItems((int)arg, (DWORD)param, NULL);

                // is sort allowed?
                if (S_OK == hr)
                {
                    m_ColSortOverride.colIdx = (int)arg;
                    m_ColSortOverride.dwOptions = (DWORD)param;
                }
                else
                {
                    // don't allow sort
                    m_ColSortOverride.colIdx = -1;
                }

                m_ColSortOverride.fClickOverride = TRUE;

                // notify view: sort was chosen
                OnRefresh(lpDataObject);

                m_ColSortOverride.fClickOverride = FALSE;

                // bug 322746: since we're add/removing columns we should send Sort request
            //    m_pResult->Sort((int)arg, (DWORD)param, NULL);

                break;
            }
        }

        return S_OK;
    }

    switch(event)
    {
    case MMCN_VIEW_CHANGE:
        hr = OnUpdateView(lpDataObject, arg);
        break;
    case MMCN_DESELECT_ALL:
        break;
    case MMCN_COLUMN_CLICK:
        break;
    case MMCN_SNAPINHELP:
        break;
    case MMCN_HELP:
    default:
        {
            INTERNAL* pInternal = NULL;

            if (IsMMCMultiSelectDataObject(lpDataObject) == FALSE)
            {
                pInternal = ExtractInternalFormat(lpDataObject);

                if (pInternal == NULL)
                {
                    ASSERT(FALSE);
                    return S_OK;
                }

                if (pInternal)
                    cookie = pInternal->m_cookie;
            }

            switch(event)
            {
            case MMCN_ACTIVATE:
                break;

            case MMCN_CLICK:
                hr = S_OK;
                break;

            case MMCN_DBLCLICK:

                // handle dblclick on Issued, CRL result items
                if (pInternal && (CCT_RESULT == pInternal->m_type))
                {
                    CFolder* pFolder = GetParentFolder(pInternal);

                    // if not base scope
                    ASSERT(pFolder != NULL);
                    if (pFolder == NULL)
                    {
                        hr = S_FALSE;
                        break;
                    }

                    // switch on folder type
                    switch(pFolder->m_type)
                    {
                    case SERVERFUNC_ISSUED_CERTIFICATES:
                    case SERVERFUNC_CRL_PUBLICATION:
                    case SERVERFUNC_ALIEN_CERTIFICATES:
                    case SERVERFUNC_ISSUED_CRLS:
                        ASSERT(!IsMMCMultiSelectDataObject(lpDataObject));
                        if (!IsMMCMultiSelectDataObject(lpDataObject))
                            Command(IDC_VIEW_CERT_PROPERTIES, lpDataObject);
                        break;
                    default:
                        break;
                    }
                }

                hr = S_FALSE; // returning S_FALSE here means "Do the default verb"
                break;

            case MMCN_ADD_IMAGES:
                OnAddImages(cookie, arg, param);
                break;

            case MMCN_SHOW:
                hr = OnShow(cookie, arg, param);
                break;

            case MMCN_MINIMIZED:
                hr = S_OK;
                break;

            case MMCN_INITOCX:
                break;

            case MMCN_DESELECT_ALL:
            case MMCN_SELECT:
                HandleStandardVerbs((event == MMCN_DESELECT_ALL),
                                    arg, lpDataObject);
                break;

            case MMCN_PASTE:
                break;

            case MMCN_DELETE:
                break;

            case MMCN_CONTEXTHELP:
                hr = OnContextHelp(lpDataObject);
                break;

            case MMCN_REFRESH:
                OnRefresh(lpDataObject);
                break;

            case MMCN_RENAME:
                break;

            case MMCN_COLUMNS_CHANGED:
                {
                    MMC_VISIBLE_COLUMNS* psMMCCols = (MMC_VISIBLE_COLUMNS*)param;
                    if (psMMCCols == NULL)
                        break;

                    MMC_COLUMN_SET_DATA* pColSetData;
#if DEBUG_COLUMNS_CHANGED

                    hr = GetColumnSetData(cookie, &pColSetData);
                    if (hr == S_OK)
                    {
                        DBGPRINT((DBG_SS_CERTMMC, "GetColumnSetData:\n"));
                        for (int i=0; i<pColSetData->nNumCols; i++)
                        {
                            DBGPRINT((DBG_SS_CERTMMC, 
                                L"pColData[%i]->nColIndex=%i (%hs)\n", i, pColSetData->pColData[i].nColIndex, 
                                (pColSetData->pColData[i].dwFlags == HDI_HIDDEN) ? "hidden" : "shown"));
                        }

                        DBGPRINT((DBG_SS_CERTMMC, "VISIBLE_COLUMNS structure:\n"));
                        for (i=0; i<psMMCCols->nVisibleColumns; i++)
                        {
                            DBGPRINT((DBG_SS_CERTMMC, L"Col %i is shown\n", psMMCCols->rgVisibleCols[i]));
                        }

                        if (pColSetData)
                            CoTaskMemFree(pColSetData);
                    }
#endif // DEBUG_COLUMNS_CHANGED

                    // On click, we need to fix column data
                    // This is analagous to the sort problem above -- we're given this notification
                    // before we can properly call GetColumnSetData(). Refresh does this, so we 
                    // have to inform GetColumnSetData() of our true intent.

                    // fill in a fake COLUMN_SET_DATA, make it override 
                    DWORD dwSize = sizeof(MMC_COLUMN_SET_DATA) + (psMMCCols->nVisibleColumns)*sizeof(MMC_COLUMN_DATA);
                    pColSetData = (MMC_COLUMN_SET_DATA* )LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, dwSize);
                
                    if (pColSetData)
                    {
                        pColSetData->cbSize = sizeof(MMC_COLUMN_SET_DATA);
                        pColSetData->nNumCols = psMMCCols->nVisibleColumns;
                        pColSetData->pColData = (MMC_COLUMN_DATA*) ((PBYTE)pColSetData + sizeof(MMC_COLUMN_SET_DATA)); // point just after struct
                        MMC_COLUMN_DATA* pEntry = pColSetData->pColData;
                        for (int i=0; i<pColSetData->nNumCols ; i++)
                        {
                            pEntry->nColIndex = psMMCCols->rgVisibleCols[i];
                            pEntry++;
                        }
                        m_ColSetOverride.pColSetData = pColSetData;
                        m_ColSetOverride.fClickOverride = TRUE;
                    }
          
                    // refresh to kick off requery: columns changed!
                    OnRefresh(lpDataObject);

                    // teardown
                    m_ColSetOverride.fClickOverride = FALSE;
                    if (m_ColSetOverride.pColSetData)
                        LocalFree(m_ColSetOverride.pColSetData);
                }
                break;

            // Note - Future expansion of notify types possible
            default:
                hr = E_UNEXPECTED;
                break;
            }

            FREE_DATA(pInternal);

            break;
        }
    }

    return hr;
}

HRESULT
CSnapin::OnUpdateView(
    LPDATAOBJECT pDataObject,
    LPARAM) // arg
{
    OnRefresh(pDataObject);
    return S_OK;
}


void CSnapin::OnRefresh(LPDATAOBJECT pDataObject)
{
    CWaitCursor cwait;  // Could be long operation

    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    ASSERT(pData != NULL);

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

    // only allow scope refresh
    if ((pInternal == NULL) || (pInternal->m_type == CCT_SCOPE))
    {
        if(pData)
        {
            // refresh toolbars
            pData->m_pCertMachine->RefreshServiceStatus();
            pData->UpdateScopeIcons();
        }
        SmartEnableServiceControlButtons();
    }
/*
    // Refresh the selected folder
    CFolder* pFolder = GetParentFolder(pInternal);
    RefreshFolder(pFolder);
*/
    // Instead, re-select the current folder (acts like refresh)
    // note side-effect: it causes race condition between redraw and 
    // MMCN_COLUMN_CLICKED database query -- MMC asks to draw cols that don't exist
    if (m_pConsole && m_pCurrentlySelectedScopeFolder)
        m_pConsole->SelectScopeItem(m_pCurrentlySelectedScopeFolder->m_ScopeItem.ID);

    FREE_DATA(pInternal);
}


HRESULT
CSnapin::OnContextHelp(
    LPDATAOBJECT) // pdtobj
{
    HRESULT	hr = S_OK;

    CString cstrHelpFile;
    IDisplayHelp*	pDisplayHelp = NULL;
    WCHAR szWindows[MAX_PATH];
    szWindows[0] = L'\0';

    hr = m_pConsole->QueryInterface (IID_IDisplayHelp, (void**)&pDisplayHelp);
    _JumpIfError(hr, Ret, "QI IDisplayHelp");

    if (0 == GetSystemWindowsDirectory(szWindows, MAX_PATH))
    {
        hr = myHLastError();
        _JumpError(hr, Ret, "GetSystemWindowsDirectory");
    }

    cstrHelpFile = szWindows;
    cstrHelpFile += HTMLHELP_COLLECTIONLINK_FILENAME;
    cstrHelpFile += L"::/sag_cs_topnode.htm";

    hr = pDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR)cstrHelpFile));
    _JumpIfError(hr, Ret, "ShowTopic");

Ret:
    if (pDisplayHelp)
        pDisplayHelp->Release();

    return hr;
}

HRESULT CSnapin::QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                            LPDATAOBJECT* ppDataObject)
{
    const GUID* pguid;

    ASSERT(ppDataObject != NULL);
    if (ppDataObject == NULL)
        return E_POINTER;

    pguid = NULL;
    if (m_bVirtualView)
    {
        ASSERT(GetVirtualFolder());
        switch(GetVirtualFolder()->GetType())
        {
            case SERVERFUNC_CRL_PUBLICATION:
                pguid = &cNodeTypeCRLPublication;
                break;
            case SERVERFUNC_ISSUED_CERTIFICATES:
                pguid = &cNodeTypeIssuedCerts;
                break;
            case SERVERFUNC_PENDING_CERTIFICATES:
                pguid = &cNodeTypePendingCerts;
                break;
            case SERVERFUNC_FAILED_CERTIFICATES:
                pguid = &cNodeTypeFailedCerts;
                break;
            case SERVERFUNC_ALIEN_CERTIFICATES:
                pguid = &cNodeTypeAlienCerts;
                break;
            case SERVERFUNC_ISSUED_CRLS:
                pguid = &cNodeTypeIssuedCRLs;
                break;
            default:
                return E_FAIL;
        }
    }

    CComObject<CDataObject>* pObject;
    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    if (NULL == pObject)
        return E_FAIL;

    // Save cookie and type for delayed rendering

    // fix type if unknown (is this valid?)
    if (type == CCT_UNINITIALIZED)
        type = CCT_RESULT;

    pObject->SetType(type);
    pObject->SetCookie(cookie);
    pObject->SetMultiSelDobj();

    CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
#ifdef _DEBUG
    pObject->SetComponentData(pImpl);
#endif

    // Store the coclass with the data object
    pObject->SetClsid(pImpl->GetCoClassID());

    // right now we know we have just 1 objtype
    SMMCObjectTypes sGuidObjTypes;
    sGuidObjTypes.count = 1;
    CopyMemory(&sGuidObjTypes.guid[0], pguid, sizeof(GUID));
    pObject->SetMultiSelData(&sGuidObjTypes, sizeof(sGuidObjTypes));

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

STDMETHODIMP CSnapin::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    HRESULT hr;
    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        hr = QueryMultiSelectDataObject(cookie, type, ppDataObject);
    }
    else
    {
        // behavior: we may query for result or scope pane dataobjects
        // Delegate it to the IComponentData
        ASSERT(m_pComponentData != NULL);
        CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pImpl != NULL);

        // Query for dataobj -- cookie is index
        hr = _QueryDataObject(cookie, type, m_dwViewID, pImpl, ppDataObject);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
: m_hCertTypeList(NULL), m_bIsDirty(TRUE), m_bInitializedC(false), m_bDestroyedC(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
    Construct();
}

CSnapin::~CSnapin()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

    SAFE_RELEASE(m_pSvrMgrToolbar1);

    if (m_pControlbar)
        SAFE_RELEASE(m_pControlbar);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
    ASSERT(m_pSvrMgrToolbar1 == NULL);

    ASSERT(!m_bInitializedC || m_bDestroyedC);

    Construct();

    if(m_hCertTypeList)
    {
        CACloseCertType(m_hCertTypeList);
        m_hCertTypeList = NULL;
    }
}

void CSnapin::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;

    m_bVirtualView = FALSE;
    m_pCurrentlySelectedScopeFolder = NULL;

    m_pControlbar = NULL;

    m_pSvrMgrToolbar1 = NULL;

    m_pConsoleVerb = NULL;

    m_ColSortOverride.fClickOverride = FALSE;
    m_ColSetOverride.fClickOverride = FALSE;
    m_ColSetOverride.pColSetData = NULL;

    m_CustomViewID = VIEW_DEFAULT_LV;
    m_dwViewID = MAXDWORD;

    m_cViewCalls = 0;
}

HRESULT CSnapin::SynchColumns(MMC_COOKIE cookie)
{
    HRESULT hr = S_OK;


    CString*    rgcstrCurSchemaHeading  = NULL;
    LONG*       rglCurSchemaType        = NULL;
    BOOL*       rgfCurSchemaIndexed     = NULL;
    DWORD       cCurSchemaEntries       = 0;

    BOOL        fSchemaChanged = FALSE;
    BOOL        fCertView;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if ((pFolder == NULL) || (NULL == pData))
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "pFolder or pData");
    }

    // if CCompDataImpl.m_rgLastKnownSchema is empty
    //      enumerate "Current Schema" and save in CCompDataImpl.m_rgLastKnownSchema

    fCertView = SERVERFUNC_ISSUED_CRLS != pFolder->GetType();
    // only resolve schema once per ccompdataimpl load
    if (!pData->m_fSchemaWasResolved ||   // really, "SchemaWasUpdated"
	pData->m_fCertView != fCertView)
    {
        pData->m_fSchemaWasResolved = TRUE;
	pData->m_fCertView = fCertView;

        // get new schema
        hr = GetCurrentColumnSchema(
            pFolder->m_pCertCA->m_strConfig,
	    pData->m_fCertView,
            &rgcstrCurSchemaHeading,
            &rglCurSchemaType,
            &rgfCurSchemaIndexed,
            (LONG*) &cCurSchemaEntries);
        _JumpIfError(hr, Ret, "GetCurrentColumnSchema");

        if (cCurSchemaEntries != pData->GetSchemaEntries())
        {
            fSchemaChanged = TRUE;
            DBGPRINT((DBG_SS_CERTMMC, "Schema change detected: knew %i, now %i entries\n", pData->GetSchemaEntries(), cCurSchemaEntries));
        }
        else
        {
            // for each entry, compare headings
            // report any diffc
            for (DWORD iEntry=0; iEntry<cCurSchemaEntries; iEntry++)
            {
                LPCWSTR sz;
                hr = pData->GetDBSchemaEntry(iEntry, &sz, NULL, NULL);
                _JumpIfError(hr, Ret, "GetDbSchemaEntry");

                if (!rgcstrCurSchemaHeading[iEntry].IsEqual(sz))
                {
                    fSchemaChanged = TRUE;
                    DBGPRINT((DBG_SS_CERTMMC, "Schema change detected: entry %i changed\n", iEntry));
                    break;
                }
            }
        }

        // boot old schema which only included strings.
        // now we have types and indexes
        DBGPRINT((DBG_SS_CERTMMC, "Updating saved schema\n"));
        hr = pData->SetDBSchema(rgcstrCurSchemaHeading, rglCurSchemaType, rgfCurSchemaIndexed, cCurSchemaEntries);
        _JumpIfError(hr, Ret, "SetDBSchema");

        // these are now owned by the class
        rgcstrCurSchemaHeading  = NULL;
        rglCurSchemaType        = NULL;
        rgfCurSchemaIndexed     = NULL;
        cCurSchemaEntries       = 0;

        if (fSchemaChanged)
        {
            DBGPRINT((DBG_SS_CERTMMC, "Resetting folders\n"));

            pData->ResetPersistedColumnInformation();    // create a new instance id (throws away all column width info)

            // whack every loaded folder
            POSITION pos = pData->m_scopeItemList.GetHeadPosition();
            while (pos)
            {
                CFolder* pTmp = pData->m_scopeItemList.GetNext(pos);
                ASSERT(pTmp);
                if (pTmp == NULL)
                    hr = E_UNEXPECTED;
                _JumpIfError(hr, Ret, "GetNext(pos) returns NULL");

                // if we find a folder with the same CA
                if (pTmp->GetCA() == pFolder->GetCA())
                {
                    switch (pTmp->GetType())
                    {
                    case SERVERFUNC_PENDING_CERTIFICATES:
                    case SERVERFUNC_CRL_PUBLICATION:
                    case SERVERFUNC_ISSUED_CERTIFICATES:
                    case SERVERFUNC_FAILED_CERTIFICATES:
                    case SERVERFUNC_ALIEN_CERTIFICATES:
                    case SERVERFUNC_ISSUED_CRLS:
                        // clear out cached data, it is stale
                        m_RowEnum.ResetColumnCount(pData->GetSchemaEntries());
                        break;

                    default:
                        break;
                    }   // end case
                }   // end if
            }   // end while folders
        }   // end if schema changed
    }

Ret:
    if (rgcstrCurSchemaHeading)
        delete [] rgcstrCurSchemaHeading;
    if (rglCurSchemaType)
        delete [] rglCurSchemaType;
    if (rgfCurSchemaIndexed)
        delete [] rgfCurSchemaIndexed;

    return hr;
}



HRESULT CSnapin::GetColumnSetData(MMC_COOKIE cookie, MMC_COLUMN_SET_DATA** ppColSetData)
{
    HRESULT hr;

    if (m_ColSetOverride.fClickOverride)
    {
        // give caller structure to free, but caller doesn't care that
        // he just gets a reference to our COLUMN_DATA array...

        *ppColSetData = (MMC_COLUMN_SET_DATA*)CoTaskMemAlloc(sizeof(MMC_COLUMN_SET_DATA));
        if (NULL != *ppColSetData)
        {
            CopyMemory(*ppColSetData, m_ColSetOverride.pColSetData, sizeof(MMC_COLUMN_SET_DATA));
            return S_OK;
        }
        // else fall through; worst case is "Err Invalid Index..." in UI
    }

    HGLOBAL hSNode2 = NULL;
    SColumnSetID* pColID = NULL;

    LPDATAOBJECT lpDataObject = NULL;

    hr = _QueryDataObject(cookie, CCT_SCOPE, m_dwViewID,
                         reinterpret_cast<CComponentDataImpl*>(m_pComponentData), &lpDataObject);
    _JumpIfError(hr, Ret, "_QueryDataObject");

    hSNode2 = ExtractNodeID(lpDataObject);
    _JumpIfOutOfMemory(hr, Ret, hSNode2);

    pColID = (SColumnSetID*)GlobalLock(hSNode2);
    _JumpIfOutOfMemory(hr, Ret, pColID);

    hr = m_pViewData->GetColumnConfigData(pColID, ppColSetData);
    _PrintIfError(hr, "GetColumnConfigData");

    if (*ppColSetData == NULL)
    {
        hr = E_FAIL;
        _JumpError(hr, Ret, "*ppColSetData NULL");
    }
    // register this allocation
    myRegisterMemAlloc(*ppColSetData, -1, CSM_COTASKALLOC);

Ret:
    if (hSNode2)
    {
        GlobalUnlock(hSNode2);
        GlobalFree(hSNode2);
    }

    if (lpDataObject)
        lpDataObject->Release();


    return hr;
}

HRESULT CSnapin::GetColumnSortData(MMC_COOKIE cookie, int* piColSortIdx, BOOL* pfAscending)
{
    HRESULT hr;

    if (m_ColSortOverride.fClickOverride)
    {
        // remove sort
        if (m_ColSortOverride.colIdx == -1)
            return E_FAIL;

        *piColSortIdx = m_ColSortOverride.colIdx;
        *pfAscending = ((m_ColSortOverride.dwOptions  & RSI_DESCENDING) == 0) ? TRUE : FALSE;
        return S_OK;
    }

    HGLOBAL hSNode2 = NULL;
    SColumnSetID* pColID = NULL;
    MMC_SORT_SET_DATA* pSortSetData = NULL;

    LPDATAOBJECT lpDataObject = NULL;

    hr = _QueryDataObject(cookie, CCT_SCOPE, m_dwViewID,
                         reinterpret_cast<CComponentDataImpl*>(m_pComponentData), &lpDataObject);
    _JumpIfError(hr, Ret, "_QueryDataObject");

    hSNode2 = ExtractNodeID(lpDataObject);
    _JumpIfOutOfMemory(hr, Ret, hSNode2);

    pColID = (SColumnSetID*)GlobalLock(hSNode2);
    _JumpIfOutOfMemory(hr, Ret, pColID);

    hr = m_pViewData->GetColumnSortData(pColID, &pSortSetData);
    _JumpIfError(hr, Ret, "GetColumnSortData");

    if (NULL == pSortSetData)
    {
        hr = E_FAIL;
        _JumpError(hr, Ret, "pSortSetData NULL");
    }
    myRegisterMemAlloc(pSortSetData, -1, CSM_COTASKALLOC);

    ASSERT(pSortSetData->nNumItems <= 1);
    if (pSortSetData->nNumItems == 0)
    {
        hr = E_FAIL;
        _JumpError(hr, Ret, "pSortSetData no sort");
    }

    *piColSortIdx = pSortSetData->pSortData[0].nColIndex;
    *pfAscending = ((pSortSetData->pSortData[0].dwSortOptions & RSI_DESCENDING) == 0) ? TRUE : FALSE;

Ret:
    if (hSNode2)
    {
        GlobalUnlock(hSNode2);
        GlobalFree(hSNode2);
    }

    if (lpDataObject)
        lpDataObject->Release();

    if (pSortSetData)
        CoTaskMemFree(pSortSetData);

    return hr;
}

HRESULT CSnapin::InsertAllColumns(MMC_COOKIE cookie, CertViewRowEnum* pCertViewRowEnum)
{
    HRESULT hr = S_OK;
    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    IEnumCERTVIEWCOLUMN* pColEnum = NULL;

    BOOL fColumnDataBad = FALSE;
    LONG iResultColCount;
    int iCache, i;
    BSTR bstrColumn = NULL;

    MMC_COLUMN_SET_DATA* pColConfigData = NULL;

    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (NULL == pData)
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "pData NULL");
    }

    ICertView* pICertView;  // this is const, don't free
    hr = pCertViewRowEnum->GetView(pFolder->GetCA(), &pICertView);
    _JumpIfError(hr, Ret, "GetView");

    // always reset our column cache map
    hr = m_RowEnum.ResetColumnCount(pData->m_cLastKnownSchema);
    _JumpIfError(hr, Ret, "ResetColumnCount");

    // attempt to get column set data
    hr = GetColumnSetData(cookie, &pColConfigData);
    _PrintIfError2(hr, "GetColumnConfigData", E_FAIL);


    // call SetColumnCacheInfo to update final Result Indexes
    if ((hr != S_OK) ||                     // given    1) canned view or
        (pData->m_cLastKnownSchema != (unsigned int)pColConfigData->nNumCols) )
                                            //          2) pColConfigData doesn't agree with schema
    {
        if (hr == S_OK)
            fColumnDataBad = TRUE;

        // get col enumerator
        hr = pICertView->EnumCertViewColumn(TRUE, &pColEnum);
        _JumpIfError(hr, Ret, "EnumCertViewColumn");

        // get # of result cols
        hr = pICertView->GetColumnCount(TRUE, &iResultColCount);
        _JumpIfError(hr, Ret, "GetColumnCount");

        // this doesn't agree with schema -- throw it away
        if (pColConfigData)
        {
            CoTaskMemFree(pColConfigData);
            pColConfigData = NULL;
        }
        ASSERT(pColConfigData == NULL);

        // rig up a column set data as if we got it from mmc
        pColConfigData = (MMC_COLUMN_SET_DATA*)CoTaskMemAlloc(sizeof(MMC_COLUMN_SET_DATA) + (sizeof(MMC_COLUMN_DATA)*pData->m_cLastKnownSchema));
        _JumpIfOutOfMemory(hr, Ret, pColConfigData);

        ZeroMemory(pColConfigData, sizeof(MMC_COLUMN_SET_DATA) + (sizeof(MMC_COLUMN_DATA)*pData->m_cLastKnownSchema));
        pColConfigData->pColData = (MMC_COLUMN_DATA*) (((BYTE*)pColConfigData) + sizeof(MMC_COLUMN_SET_DATA)); // points to just after our struct
        pColConfigData->cbSize = sizeof(MMC_COLUMN_SET_DATA);
        pColConfigData->nNumCols = pData->m_cLastKnownSchema;

        for (i=0; i<(int)pData->m_cLastKnownSchema; i++)
        {
            pColConfigData->pColData[i].nColIndex = i;
            pColConfigData->pColData[i].dwFlags = HDI_HIDDEN;
        }

        for (i=0; i< iResultColCount; i++)
        {
            hr = pColEnum->Next((LONG*)&iCache);
            _JumpIfError(hr, Ret, "Next");

            hr = pColEnum->GetName(&bstrColumn);
            _JumpIfError(hr, Ret, "GetName");

            iCache = pData->FindColIdx(bstrColumn);
            _JumpIfError(hr, Ret, "FindColIdx");

            SysFreeString(bstrColumn);
            bstrColumn = NULL;

             // rig up column set data as if we got it from mmc
            pColConfigData->pColData[iCache].dwFlags = (DWORD) AUTO_WIDTH;

            hr = m_RowEnum.SetColumnCacheInfo(iCache, i);
            _JumpIfError(hr, Ret, "SetColumnCacheInfo");
        }
    }
    else
    {
        // get # of cols
        iResultColCount = m_RowEnum.GetColumnCount();

        // set col cache correctly
        int iResultIdx = 0;
        for (i=0; i< iResultColCount; i++)
        {
            BOOL fShown;
            hr = IsColumnShown(pColConfigData, i, &fShown);
            _JumpIfError(hr, Ret, "IsColumnShown");

            // update idxViewCol
            if (fShown)
            {
                hr = m_RowEnum.SetColumnCacheInfo(pColConfigData->pColData[i].nColIndex, iResultIdx);
                _JumpIfError(hr, Ret, "SetColumnCacheInfo");

                iResultIdx++;
            }
        }
    }

    hr = DoInsertAllColumns(pColConfigData);
    _JumpIfError(hr, Ret, "DoInsertAllColumns");

Ret:
    if (pColEnum)
        pColEnum->Release();

    if (bstrColumn)
        SysFreeString(bstrColumn);

    if(pColConfigData)
        CoTaskMemFree(pColConfigData);

    return hr;
}

HRESULT CSnapin::DoInsertAllColumns(MMC_COLUMN_SET_DATA* pCols)
{
    HRESULT hr = S_OK;

    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    int i;

    if ((pCols == NULL) || (pData == NULL))
    {
        hr = E_POINTER;
        _JumpError(hr, Ret, "pCols or pData");
    }

    for (i=0; i<pCols->nNumCols; i++)
    {
        LPCWSTR pszLocal, pszUnlocal;
        BOOL fShown;

        hr = IsColumnShown(pCols, i, &fShown);
        _JumpIfError(hr, Ret, "IsColumnShown");

        hr = pData->GetDBSchemaEntry(i, &pszUnlocal, NULL, NULL);
        _JumpIfError(hr, Ret, "GetDBSchemaEntry");

        // returns pointer to static data; don't bother to free
        hr = myGetColumnDisplayName(
            pszUnlocal,
            &pszLocal);
        _PrintIfError(hr, "myGetColumnDisplayName");

        // if localized version not found, slap with raw name
        if (pszLocal == NULL)
            pszLocal = pszUnlocal;

        m_pHeader->InsertColumn(i, pszLocal, LVCFMT_LEFT, fShown ? AUTO_WIDTH : HIDE_COLUMN);
    }

Ret:
    return hr;
}


HRESULT CSnapin::InitializeHeaders(MMC_COOKIE cookie)
{
    ASSERT(m_pHeader);

    HRESULT hr = S_OK;
    BOOL fInsertedHeaders=FALSE;

    USES_CONVERSION;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    MMC_COLUMN_SET_DATA* pColSetData = NULL;

    // Put the correct headers depending on the cookie
    if (pFolder == NULL)
    {
        // base scope
        m_pHeader->InsertColumn(0, W2COLE(g_pResources->m_ColumnHead_Name), LVCFMT_LEFT, 180);     // Name
        m_pHeader->InsertColumn(1, W2COLE(g_pResources->m_ColumnHead_Description), LVCFMT_LEFT, 180);     // Description
        fInsertedHeaders = TRUE;
    }
    else
    {
        switch (pFolder->m_type)
        {
        case SERVERFUNC_ISSUED_CERTIFICATES:
        case SERVERFUNC_CRL_PUBLICATION:    // or server functions
        case SERVERFUNC_PENDING_CERTIFICATES:
        case SERVERFUNC_ALIEN_CERTIFICATES:
        case SERVERFUNC_FAILED_CERTIFICATES:
        case SERVERFUNC_ISSUED_CRLS:
            {
                ICertView* pICertView;  // this is const, don't free
		BOOL fCertView;

                m_dwViewErrorMsg = S_OK; // assume everything OK when initializing view

                // although we don't allow unsetting this mode,
                // we may inherit it from another snapin. Force report mode.
                hr = m_pResult->SetViewMode(MMCLV_VIEWSTYLE_REPORT);
                if (hr != S_OK)
                    break;

                // force reload of view (otherwise: multiple restriction error)
                ResetKnowResultRows();
                m_RowEnum.ClearCachedCertView();
                m_RowEnum.InvalidateCachedRowEnum();
		fCertView = SERVERFUNC_ISSUED_CRLS != pFolder->m_type;
                hr = m_RowEnum.GetView(pFolder->GetCA(), &pICertView);
                if (hr != S_OK)
                    break;

                int iSortOrder = CVR_SORT_NONE;
                int idxSortCol = -1;

                ASSERT(pICertView != NULL);
                VARIANT var;
                VariantInit(&var);

		if (!fCertView)
		{
		    hr = ((ICertView2 *) pICertView)->SetTable(CVRC_TABLE_CRL);
		    _PrintIfError(hr, "SetTable");
		}
                {
                    BOOL fAscending;
                    hr = GetColumnSortData(cookie, &idxSortCol, &fAscending);
                    _PrintIfError2(hr, "GetColumnSortData", E_FAIL);

                    if (hr == S_OK)
                    {
                        if (fAscending)
                            iSortOrder = CVR_SORT_ASCEND;
                        else
                            iSortOrder = CVR_SORT_DESCEND;

                    }
                }

                // first restriction is always sort request
                if (iSortOrder != CVR_SORT_NONE)
                {
                    ASSERT( (iSortOrder == CVR_SORT_ASCEND) ||
                              (iSortOrder == CVR_SORT_DESCEND));

                    var.vt = VT_EMPTY;

                    if (S_OK == hr)
                    {
                        hr = pICertView->SetRestriction(
			                idxSortCol,	// ColumnIndex
			                CVR_SEEK_NONE,	// SeekOperator
					iSortOrder,	// SortOrder
			                &var);		// pvarValue
                    }
                    VariantClear(&var);
                }



                // set restriction on rows to view
                if (m_RowEnum.FAreQueryRestrictionsActive(fCertView) &&
                    (m_RowEnum.GetQueryRestrictions(fCertView) != NULL))
                {
                    PQUERY_RESTRICTION pCurRestrict = m_RowEnum.GetQueryRestrictions(fCertView);
                    while (pCurRestrict)
                    {
                        LONG idxCol;
                        hr = pICertView->GetColumnIndex(FALSE, _bstr_t(pCurRestrict->szField), &idxCol);
                        if (hr == S_OK)
                        {
                            // set restriction if column found
                            hr = pICertView->SetRestriction(
			                        idxCol,		                // Request Disposition's ColumnIndex
			                        pCurRestrict->iOperation,	// SeekOperator
			                        CVR_SORT_NONE,              // SortOrder
			                        &pCurRestrict->varValue);	// Value
                        }

                        // don't VarClear here!
                        pCurRestrict = pCurRestrict->pNext;
                    }
                }

                // set query restrictions
                if (SERVERFUNC_CRL_PUBLICATION == pFolder->m_type)
                {
                    // build special Revoked view
                    var.lVal = DB_DISP_REVOKED;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, _bstr_t(wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION), &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_EQ,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_ISSUED_CERTIFICATES == pFolder->m_type)
                {
                    var.lVal = DB_DISP_ISSUED;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, _bstr_t(wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION), &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_EQ,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_PENDING_CERTIFICATES == pFolder->m_type)
                {
                    var.lVal = DB_DISP_PENDING; //DB_DISP_QUEUE_MAX;    // don't include active
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, _bstr_t(wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION), &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_EQ,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_FAILED_CERTIFICATES == pFolder->m_type)
                {
                    var.lVal = DB_DISP_LOG_FAILED_MIN;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, _bstr_t(wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION), &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_GE,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_ALIEN_CERTIFICATES == pFolder->m_type)
                {
                    var.lVal = DB_DISP_FOREIGN;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, _bstr_t(wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION), &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_EQ,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else if (SERVERFUNC_ISSUED_CRLS == pFolder->m_type)
                {
                    var.lVal = 0;
                    var.vt = VT_I4;
                    LONG idxCol;

                    hr = pICertView->GetColumnIndex(FALSE, _bstr_t(wszPROPCRLROWID), &idxCol);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetRestriction(
			                idxCol,		                    // Request Disposition's ColumnIndex
			                CVR_SEEK_GE,	                // SeekOperator
			                CVR_SORT_NONE,                  // SortOrder
			                &var);		                    // pvarValue

                    VariantClear(&var);
                    if (hr != S_OK)
                        break;
                }
                else
                {
                    ASSERT(FALSE); // do we ever get here??
                    break;
                }

                // RESOLVE schema changes here
                hr = SynchColumns(cookie);
                _PrintIfError(hr, "SynchColumns");

                hr = GetColumnSetData(cookie, &pColSetData);
                if ((hr != S_OK) || (pColSetData == NULL))
                {
                    LONG lViewType;

                    // problem or no column set data? Revert to the default canned view
                    if (SERVERFUNC_PENDING_CERTIFICATES == pFolder->m_type)
                        lViewType = CV_COLUMN_QUEUE_DEFAULT;
                    else if (SERVERFUNC_FAILED_CERTIFICATES == pFolder->m_type)
                        lViewType = CV_COLUMN_LOG_FAILED_DEFAULT;
                    else if (SERVERFUNC_CRL_PUBLICATION == pFolder->m_type)
                        lViewType = pFolder->GetCA()->m_pParentMachine->FIsWhistlerMachine() ?  CV_COLUMN_LOG_REVOKED_DEFAULT : CV_COLUMN_LOG_DEFAULT; // w2k doesn't understand revoked view
                    else if (SERVERFUNC_ALIEN_CERTIFICATES == pFolder->m_type)
                        lViewType = CV_COLUMN_LOG_DEFAULT;
                    else if (SERVERFUNC_ISSUED_CRLS == pFolder->m_type)
                        lViewType = CV_COLUMN_CRL_DEFAULT;
                    else
                        lViewType = CV_COLUMN_LOG_DEFAULT;

                    hr = pICertView->SetResultColumnCount(lViewType);
                    if (hr != S_OK)
                        break;
                }
                else
                {
                    // manual view
                    ULONG lColCount;

                    hr = CountShownColumns(pColSetData, &lColCount);
                    if (hr != S_OK)
                        break;

                    hr = pICertView->SetResultColumnCount(lColCount);
                    if (hr != S_OK)
                        break;

                     // for all non-hidden columns, add to Query
                     for (lColCount=0; lColCount<(ULONG)pColSetData->nNumCols; lColCount++)
                     {
                        BOOL fShown;
                        hr = IsColumnShown(pColSetData, lColCount, &fShown);
                        if ((hr != S_OK) || (!fShown))
                            continue;

                        hr = pICertView->SetResultColumn(pColSetData->pColData[lColCount].nColIndex);
                        if (hr != S_OK)
                           break;
                      }
                }
                // Open the view
                IEnumCERTVIEWROW* pRowEnum;  // don't free
                hr = m_RowEnum.GetRowEnum(pFolder->GetCA(), &pRowEnum);
                if (hr != S_OK)
                    break;


                hr = InsertAllColumns(cookie, &m_RowEnum);
                _PrintIfError(hr, "InsertAllColumns");

                if (hr == S_OK)
                    fInsertedHeaders = TRUE;


                // set description bar text
                {
                    CString cstrStatusBar;
                    BOOL fFiltered = FALSE;

                    if (m_RowEnum.FAreQueryRestrictionsActive(fCertView) &&
                        (m_RowEnum.GetQueryRestrictions(fCertView) != NULL))
                    {
                        cstrStatusBar = g_pResources->m_szFilterApplied;
                        fFiltered = TRUE;
                    }

                    if (iSortOrder != CVR_SORT_NONE)
                    {
                        LPCWSTR pszTemplate = NULL;
                        if (iSortOrder == CVR_SORT_ASCEND)
                            pszTemplate = (LPCWSTR)g_pResources->m_szSortedAscendingTemplate;

                        if (iSortOrder == CVR_SORT_DESCEND)
                            pszTemplate = (LPCWSTR)g_pResources->m_szSortedDescendingTemplate;

                        if (pszTemplate)
                        {
                            // localize
                            LPCWSTR szUnlocalizedCol;
                            LPCWSTR szLocalizedCol;

                            hr = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->GetDBSchemaEntry(idxSortCol, &szUnlocalizedCol, NULL, NULL);
                            if (hr == S_OK)
                            {
                                hr = myGetColumnDisplayName(
                                        szUnlocalizedCol,
                                        &szLocalizedCol);
                                if ((S_OK == hr) && (NULL != szLocalizedCol))
                                {
                                    WCHAR rgszSortText[MAX_PATH+1];
                                    ASSERT((MAX_PATH*sizeof(WCHAR)) > (WSZ_BYTECOUNT(pszTemplate) + WSZ_BYTECOUNT(szLocalizedCol)));
                                    wsprintf(rgszSortText, pszTemplate, szLocalizedCol);

                                    if (fFiltered)
                                        cstrStatusBar += L"; ";
                                    cstrStatusBar += rgszSortText;
                                }
                            }
                        }
                    }

                    // Progress: cstrStatusBar += L"|%69";
                    //m_pResult->SetDescBarText((LPWSTR)(LPCWSTR)cstrStatusBar);
                    m_pConsole->SetStatusText((LPWSTR)(LPCWSTR)cstrStatusBar);
                }

                break;
            }

        case SERVER_INSTANCE:   // any issuing server instance
            m_pHeader->InsertColumn(0, W2COLE(g_pResources->m_ColumnHead_Name), LVCFMT_LEFT, 260);     // Name
            fInsertedHeaders = TRUE;
            break;
        default:
            // other scopes
            m_pHeader->InsertColumn(0, W2COLE(g_pResources->m_ColumnHead_Name), LVCFMT_LEFT, 180);     // Name
            m_pHeader->InsertColumn(1, W2COLE(g_pResources->m_ColumnHead_Size), LVCFMT_LEFT, 90);      // Size
            m_pHeader->InsertColumn(2, W2COLE(g_pResources->m_ColumnHead_Type), LVCFMT_LEFT, 160);     // Type
            fInsertedHeaders = TRUE;
        }
    }

    if (!fInsertedHeaders)
    {
        // insert error msg
        CString cstrViewErrorMsg, cstrStatusText;

        if ((pFolder != NULL ) && (!pFolder->GetCA()->m_pParentMachine->IsCertSvrServiceRunning()))
        {
            // handle server stopped msg
            cstrViewErrorMsg = g_pResources->m_szStoppedServerMsg;
        }
        else
        {
            // handle any other error (except empty db)
            cstrViewErrorMsg = myGetErrorMessageText(hr, TRUE);
        }

        cstrStatusText.Format(g_pResources->m_szStatusBarErrorFormat, cstrViewErrorMsg);

        m_pHeader->InsertColumn(0, W2COLE(L" "), LVCFMT_LEFT, 500);     // Error
        m_pConsole->SetStatusText((LPWSTR)(LPCWSTR)cstrStatusText);
    }

//Ret:
    if (pColSetData)
        CoTaskMemFree(pColSetData);

    return hr;
}


LPCWSTR DescriptionStringFromFolderType(FOLDER_TYPES type)
{
    ASSERT(NULL != g_pResources && g_pResources->m_fLoaded);

    switch (type)
    {
    case SERVER_INSTANCE:
        return (LPCWSTR) g_pResources->m_DescrStr_CA;
    default:
        break;
    }
    return (LPCWSTR)g_pResources->m_DescrStr_Unknown;
}

#define MMCVIEW_DB_MINPAGESIZE      32
#define MAX_VIEWABLE_STRING_LEN     MAX_PATH
static WCHAR szVirtualStrBuf[MAX_VIEWABLE_STRING_LEN+1];
static DWORD cbVirtualStrBuf = sizeof(szVirtualStrBuf);

STDMETHODIMP CSnapin::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    HRESULT hr = S_OK;
    ASSERT(pResult != NULL);

    if ((pResult) && (pResult->mask))
    {
        // a folder or a result?
        if (pResult->bScopeItem)
        {
            CFolder* pFolder = reinterpret_cast<CFolder*>(pResult->lParam);
            ASSERT(pFolder);

            if (pResult->mask & RDI_STR)
            {
                switch (pFolder->m_type)
                {
                case MACHINE_INSTANCE:
                case SERVER_INSTANCE:
                    switch(pResult->nCol)
                    {
                    case 0:
                        pResult->str = pFolder->m_pszName;
                        break;
                    case 1:
                        pResult->str = (LPOLESTR)DescriptionStringFromFolderType(pFolder->m_type);
                    default:
                        break;
                    }
                    break;

                case SERVERFUNC_CRL_PUBLICATION:
                case SERVERFUNC_ISSUED_CERTIFICATES:
                case SERVERFUNC_PENDING_CERTIFICATES:
                case SERVERFUNC_FAILED_CERTIFICATES:
                case SERVERFUNC_ALIEN_CERTIFICATES:
                case SERVERFUNC_ISSUED_CRLS:
                    // just a single column here
                    pResult->str = pFolder->m_pszName;
                default:
                    break;
                }

                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                if (pResult->nState & TVIS_EXPANDED)
                    pResult->nImage = pFolder->m_ScopeItem.nOpenImage;
                else
                    pResult->nImage = pFolder->m_ScopeItem.nImage;
            }
        }
        else
        {
            RESULT_DATA*    pData = NULL;
            CFolder*        pFolder = NULL;

            // if non-virtual, lParam is the item pointer
            if (m_bVirtualView)
                pFolder = GetVirtualFolder();
            else
            {
                pData= reinterpret_cast<RESULT_DATA*>(pResult->lParam);
                pFolder = pData->pParentFolder;

                ASSERT(pData->pParentFolder == m_pCurrentlySelectedScopeFolder);
            }


            if (pResult->mask & RDI_STR)
            {
                switch(pFolder->GetType())
                {
                case SERVERFUNC_CRL_PUBLICATION:
                case SERVERFUNC_PENDING_CERTIFICATES:
                case SERVERFUNC_ISSUED_CERTIFICATES:
                case SERVERFUNC_FAILED_CERTIFICATES:
                case SERVERFUNC_ALIEN_CERTIFICATES:
                case SERVERFUNC_ISSUED_CRLS:
                    {
                        szVirtualStrBuf[0] = L'\0'; // zero
                        pResult->str = szVirtualStrBuf;


                        // have we had an error enumerating elts?
                        if (S_OK != m_dwViewErrorMsg)
                        {
                            // rtn err msg or blank
//                            ASSERT(pResult->nIndex == 0);
                            if (pResult->nIndex == 0)
                                pResult->str = (LPWSTR)(LPCWSTR)m_cstrViewErrorMsg;

                            break;
                        }

                        // Don't attempt to cache iViewCol -- we're asked
                        int iViewCol;

                        // if this request isn't the last one that came through, look it up
                        hr = m_RowEnum.GetColumnCacheInfo(
                            pResult->nCol,
                            &iViewCol);
                        _PrintIfError(hr, "GetColumnCacheInfo");

                        // HACKHACK
                        // if we get ErrorContinue, we should just take it
                        // in stride and return \0 (see GetColumnCacheInfo for details)
                        if (hr == HRESULT_FROM_WIN32(ERROR_CONTINUE))
                            break;                            

                        if (hr != S_OK)
                        {
                            // assume error
                            iViewCol = 0;
                        }

                        DWORD cbSize = cbVirtualStrBuf;

                        // protect ICertAdminD->EnumView from reentrant calls (see bug 339811)
                        if(2>InterlockedIncrement(&m_cViewCalls))
                        {
                            hr = GetCellContents(
                                        &m_RowEnum,
                                        pFolder->GetCA(),
                                        pResult->nIndex,
                                        pResult->nCol,
                                        (PBYTE)szVirtualStrBuf,
                                        &cbSize,
                                        TRUE);
                            _PrintIfError2(hr, "GetCellContents", S_FALSE); // ignore end of db msg
                        }
                        
                        InterlockedDecrement(&m_cViewCalls);

                        // only deal with 1st col
                        if (iViewCol != 0)
                            break;

                        // On Error
                        if ( (S_OK != hr) && (S_FALSE != hr) )
                        {
                            // stash error return
                            m_dwViewErrorMsg = hr;

                            if (!pFolder->GetCA()->m_pParentMachine->IsCertSvrServiceRunning())
                            {
                                // handle server stopped msg

                                // copy to stateful str
                                m_cstrViewErrorMsg = g_pResources->m_szStoppedServerMsg;

                                // copy to output
                                pResult->str = (LPWSTR)(LPCWSTR)g_pResources->m_szStoppedServerMsg;
                            }
                            else
                            {
                                // handle any other error (except empty db)
                                m_cstrViewErrorMsg = myGetErrorMessageText(hr, TRUE);

                                // truncate if necessary
                                ASSERT(MAX_VIEWABLE_STRING_LEN >= wcslen((LPWSTR)(LPCWSTR)m_cstrViewErrorMsg) );
                                if (MAX_VIEWABLE_STRING_LEN < wcslen((LPWSTR)(LPCWSTR)m_cstrViewErrorMsg) )
                                    m_cstrViewErrorMsg.SetAt(MAX_VIEWABLE_STRING_LEN, L'\0');

                                pResult->str = (LPWSTR)(LPCWSTR)m_cstrViewErrorMsg;
                            }

                            // on error, just display this msg
                            if (!m_RowEnum.m_fKnowNumResultRows)
                            {
                                // upd view
                                SetKnowResultRows(1);
                                m_pResult->SetItemCount(1, MMCLV_UPDATE_NOSCROLL | MMCLV_UPDATE_NOINVALIDATEALL);

                                // don't destroy column widths!
                                // OLD: make col width large enough to hold msg
//                                m_pHeader->SetColumnWidth(0, CHARS_TO_MMCCOLUMNWIDTH(wcslen(pResult->str)));
                            }
                            break;
                        }

                        // if 1st col and don't know the final tally, might have to update best guess
                        if (hr == S_OK)
                        {
                            if (KnownResultRows() == (DWORD)(pResult->nIndex+1))
                                                                // if asking for the last element (ones based)
                            {
                                // next guess at end
                                BOOL fSetViewCount = FALSE;
                                DWORD dwNextEnd = 0;

                                if (!m_RowEnum.m_fKnowNumResultRows) // only make guess if enum doesn't have a clue yet
                                {
                                    // double where we are now, make sure we're at least moving MMCVIEW_DB_MINPAGESIZE rows
                                    dwNextEnd = max( ((pResult->nIndex+1)*2), MMCVIEW_DB_MINPAGESIZE);

                                    DBGPRINT((DBG_SS_CERTMMC, "RowEnum dwResultRows = %i, requested Index = %i. Creating Guess = %i\n", m_RowEnum.m_dwResultRows, pResult->nIndex, dwNextEnd));

                                    // upd enumerator with our best guess
                                    fSetViewCount = TRUE;
                                }
                                else if (KnownResultRows() != m_RowEnum.m_dwResultRows)
                                {
                                    dwNextEnd = m_RowEnum.m_dwResultRows;
                                    fSetViewCount = TRUE;
                                }

                                // upd view
                                if (fSetViewCount)
                                {
                                    SetKnowResultRows(dwNextEnd);
                                    m_pResult->SetItemCount(dwNextEnd, MMCLV_UPDATE_NOSCROLL | MMCLV_UPDATE_NOINVALIDATEALL);
                                }

                            } // if the enumerator doesn't have a clue yet
                        }
                        else
                        {
                            ASSERT(hr == S_FALSE);

                            // end-of-db should only come on first col
                            // if error while retrieving first elt in row, ASSUME end of DB
                            LONG lRetrievedIndex;
                            hr = m_RowEnum.GetRowMaxIndex(pFolder->GetCA(), &lRetrievedIndex);
                            if (S_OK != hr)
                                break;

                            DBGPRINT((DBG_SS_CERTMMC, "Hit end, setting max index to %i\n", lRetrievedIndex));

                            SetKnowResultRows(lRetrievedIndex);
                            m_pResult->SetItemCount(lRetrievedIndex, MMCLV_UPDATE_NOSCROLL | MMCLV_UPDATE_NOINVALIDATEALL);
//                                m_pResult->ModifyItemState(lRetrievedIndex-1, 0, (LVIS_FOCUSED | LVIS_SELECTED), 0);  // set focus to last item
// BUG BUG MMC fails to re-select scope pane when we set selection here, so just set focus (build 2010)
                            if (lRetrievedIndex != 0)
                                m_pResult->ModifyItemState(lRetrievedIndex-1, 0, LVIS_FOCUSED, 0);  // set focus to last item
                        }
                    } // end case
                    break;
                case SERVER_INSTANCE:
                default:                    // try this, no guarantee
                    if (NULL == pData)
                        break;
                    ASSERT(pResult->nCol < (int)pData->cStringArray);
                    pResult->str = (LPOLESTR)pData->szStringArray[pResult->nCol];
                    break;
                }

                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            // MMC can request image and indent for virtual data
            if (pResult->mask & RDI_IMAGE)
            {
                if ((pResult->nIndex >= (int)m_RowEnum.m_dwResultRows) || (hr != S_OK) || (S_OK != m_dwViewErrorMsg))
                {
                    // MMC bug: using SetItemCount doesn't stick early enough to keep it from
                    // asking for icons for the first page.
                    pResult->nImage = IMGINDEX_NO_IMAGE;
                }
                else
                {
                    switch(pFolder->GetType())
                    {
                    case SERVERFUNC_FAILED_CERTIFICATES:
                    case SERVERFUNC_CRL_PUBLICATION:
                        pResult->nImage = IMGINDEX_CRL;
                        break;
                    case SERVERFUNC_PENDING_CERTIFICATES:
                        pResult->nImage = IMGINDEX_PENDING_CERT;
                        break;
                    case SERVERFUNC_ISSUED_CERTIFICATES:
                    case SERVERFUNC_ALIEN_CERTIFICATES:
		    case SERVERFUNC_ISSUED_CRLS:
                        pResult->nImage = IMGINDEX_CERT;
                        break;
                    default:
                        // should never get here
                        ASSERT(0);
                        pResult->nImage = IMGINDEX_NO_IMAGE;
                        break;
                    } // end switch
                } // end > rows test
            }
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation
STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    LONG *pInsertionAllowed)
{
    dynamic_cast<CComponentDataImpl*>(m_pComponentData)->m_pCurSelFolder = m_pCurrentlySelectedScopeFolder;

    HRESULT hr;
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (NULL == pInternal)
        return S_OK;

    BOOL bMultiSel =  IsMMCMultiSelectDataObject(pDataObject);

    BOOL fResultItem = (pInternal->m_type == CCT_RESULT);

    CFolder* pFolder = m_pCurrentlySelectedScopeFolder;

    FOLDER_TYPES folderType = NONE;
    if (pFolder == NULL)
        folderType = MACHINE_INSTANCE;
    else
        folderType = pFolder->GetType();

    hr = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
            AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
    if (hr != S_OK)
       goto Ret;

    // Loop through and add each of the view items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        // fixup entries
        MY_CONTEXTMENUITEM* pm = viewResultItems;

        if (m_RowEnum.FAreQueryRestrictionsActive(SERVERFUNC_ISSUED_CRLS != folderType)) // filtered?
        {
            pm[ENUM_VIEW_FILTER].item.fFlags =
                MFT_RADIOCHECK | MFS_CHECKED | MFS_ENABLED;
            pm[ENUM_VIEW_ALL].item.fFlags =
                MFS_ENABLED;
        }
        else
        {
            pm[ENUM_VIEW_FILTER].item.fFlags =
                MFS_ENABLED;
            pm[ENUM_VIEW_ALL].item.fFlags =
                MFT_RADIOCHECK | MFS_CHECKED | MFS_ENABLED;
        }

        for (; pm->item.strName; pm++)
        {
            // show in both scope/result panes
            // fResultItem

            // Only support views in known containers
            // for each task, insert if matches the current folder
            if ((folderType  == SERVERFUNC_CRL_PUBLICATION) ||
                (folderType  == SERVERFUNC_ISSUED_CERTIFICATES) ||
                (folderType  == SERVERFUNC_PENDING_CERTIFICATES) ||
                (folderType  == SERVERFUNC_ALIEN_CERTIFICATES) ||
                (folderType  == SERVERFUNC_FAILED_CERTIFICATES) ||
                (folderType  == SERVERFUNC_ISSUED_CERTIFICATES) ||
                (folderType  == SERVERFUNC_ISSUED_CRLS))
            {
                hr = pContextMenuCallback->AddItem(&pm->item);
                _JumpIfError(hr, Ret, "AddItem");
            }
        }
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        // ptr to tasks
        TASKITEM* pm = taskResultItemsSingleSel;

        if (!bMultiSel)
        {
            // insert all other tasks per folder
            for (; pm->myitem.item.strName; pm++)
            {
                // does it match scope/result type?
                // if (value where we are !=
                //    whether or not the resultitem bit is set)
                if (fResultItem != (0 != (pm->dwFlags & TASKITEM_FLAG_RESULTITEM)) )
                    continue;

                // does it match area it should be in?
                // for each task, insert if matches the current folder
                if (folderType != pm->type)
                    continue;

                // is this task supposed to be hidden?
                if (MFS_HIDDEN == pm->myitem.item.fFlags)
                    continue;

                if(!((pm->myitem.dwRoles) & (pFolder->m_pCertCA->GetMyRoles())))
                    pm->myitem.item.fFlags = MFS_GRAYED;

                hr = pContextMenuCallback->AddItem(&pm->myitem.item);
                _JumpIfError(hr, Ret, "AddItem");
            }
        }
    }

Ret:
    FREE_DATA(pInternal);

    return hr;
}


STDMETHODIMP CSnapin::Command(LONG nCommandID, LPDATAOBJECT pDataObject)
{
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (pInternal == NULL)
        return E_FAIL;

    BOOL fConfirmedAction = FALSE;
    BOOL fMustRefresh = FALSE;

    LONG lReasonCode = CRL_REASON_UNSPECIFIED;

    HRESULT hr = S_OK;

    CFolder* pFolder = GetParentFolder(pInternal);
    ICertAdmin* pAdmin = NULL;      // free this
    CWaitCursor* pcwait = NULL; // some of these commands are multiselect and could take awhile.  
                         // On those that are lengthy, this will be created and needs to be deleted at exit

    if (pInternal->m_type == CCT_SCOPE)
    {
        // Handle view specific commands here
        switch (nCommandID)
        {
        case MMCC_STANDARD_VIEW_SELECT:
            m_CustomViewID = VIEW_DEFAULT_LV;
            break;
        case IDC_VIEW_ALLRECORDS:
            {
            if (NULL == pFolder)
                break;

            // if restricted view, change
	    BOOL fCertView = SERVERFUNC_ISSUED_CRLS != pFolder->GetType();
            if (m_RowEnum.FAreQueryRestrictionsActive(fCertView))
            {
                // switch off active flag
                m_RowEnum.SetQueryRestrictionsActive(FALSE, fCertView);

                // refresh just this folder
                OnRefresh(pDataObject);
                SetDirty();
            }

            break;
            }
        case IDC_VIEW_FILTER:
            {
            if (NULL == pFolder)
                break;

            HWND hwnd;
            hr = m_pConsole->GetMainWindow(&hwnd);
            ASSERT(hr == ERROR_SUCCESS);
            if (hr != ERROR_SUCCESS)
                hwnd = NULL;        // should work

            hr = ModifyQueryFilter(hwnd, &m_RowEnum, dynamic_cast<CComponentDataImpl*>(m_pComponentData), SERVERFUNC_ISSUED_CRLS != pFolder->GetType());

            // refresh only if successful
            if (hr == ERROR_SUCCESS)
            {
                // refresh just this folder
                OnRefresh(pDataObject);
                SetDirty();
            }

            break;
            }


        default:
            // Pass non-view specific commands to ComponentData
            return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(nCommandID, pDataObject);
        }
    }
    else if (pInternal->m_type == CCT_RESULT)
    {
        // get this only ONCE, it's freed later
        if ((nCommandID == IDC_RESUBMITREQUEST) ||
            (nCommandID == IDC_DENYREQUEST) ||
            (nCommandID == IDC_REVOKECERT) ||
            (nCommandID == IDC_UNREVOKE_CERT))
        {
            if (pFolder == NULL)
            {
               hr = E_POINTER;
               goto ExitCommand;
            }

            // have pAdmin allocated
            hr = pFolder->GetCA()->m_pParentMachine->GetAdmin(&pAdmin);
            if (S_OK != hr)
                goto ExitCommand;
        }

        // snag the selected items

        RESULTDATAITEM rdi;
        rdi.mask = RDI_STATE;

        rdi.nState = LVIS_SELECTED;
        rdi.nIndex = -1;


        // must sit outside loop so multi-select works
        LPCWSTR szCol=NULL; // don't free
        BOOL fSaveInstead = FALSE;


        while(S_OK == m_pResult->GetNextItem(&rdi))
        {
            // Handle each of the commands seperately
            switch (nCommandID)
            {
            case IDC_VIEW_CERT_PROPERTIES:
            {
                if (NULL == pFolder)
                    break;

                switch (pFolder->GetType())
                {
                case SERVERFUNC_ISSUED_CERTIFICATES:
                case SERVERFUNC_CRL_PUBLICATION:
                case SERVERFUNC_ALIEN_CERTIFICATES:
                    {
                    CertSvrCA* pCA = pFolder->GetCA();
                    CRYPTUI_VIEWCERTIFICATE_STRUCTW sViewCert;
                    ZeroMemory(&sViewCert, sizeof(sViewCert));
                    HCERTSTORE rghStores[2];    // don't close these stores

                    // get this cert
                    PBYTE pbCert = NULL;
                    DWORD cbCert;
                    hr = GetRowColContents(pFolder, rdi.nIndex, wszPROPRAWCERTIFICATE, &pbCert, &cbCert);
                    if (S_OK != hr)
                        break;

                    sViewCert.pCertContext = CertCreateCertificateContext(
                        CRYPT_ASN_ENCODING,
                        pbCert,
                        cbCert);
                    delete [] pbCert;

                    if (sViewCert.pCertContext == NULL)
                        break;

                    hr = m_pConsole->GetMainWindow(&sViewCert.hwndParent);
                    if (S_OK != hr)
                        sViewCert.hwndParent = NULL;    // should work

                    sViewCert.dwSize = sizeof(sViewCert);
                    sViewCert.dwFlags = CRYPTUI_ENABLE_REVOCATION_CHECKING | CRYPTUI_DISABLE_ADDTOSTORE;
                   
		    // if we're opening remotely, don't open local stores
		    if (! pCA->m_pParentMachine->IsLocalMachine())
		    {
			DWORD dw; 

			// get remote stores
			dw = pCA->GetRootCertStore(&rghStores[0]);
			_PrintIfError(dw, "GetRootCertStore");

			if (S_OK == dw)
			{
			    dw = pCA->GetCACertStore(&rghStores[1]);
			    _PrintIfError(dw, "GetCACertStore");
			} 

			if (S_OK == dw)
			{
			    // rely only on remote machine's stores
			    sViewCert.cStores = 2;
			    sViewCert.rghStores = rghStores;
			    sViewCert.dwFlags |= CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
			}
			else
			{
			    // tell user we're only doing this locally
			    sViewCert.dwFlags |= CRYPTUI_WARN_REMOTE_TRUST;
			}
		    }

                    if (!CryptUIDlgViewCertificateW(&sViewCert, NULL))
                        hr = GetLastError();

                    VERIFY(CertFreeCertificateContext(sViewCert.pCertContext));
                    }
		    break;

                case SERVERFUNC_ISSUED_CRLS:
                    {
                    CertSvrCA* pCA = pFolder->GetCA();
                    CRYPTUI_VIEWCRL_STRUCTW sViewCRL;
                    ZeroMemory(&sViewCRL, sizeof(sViewCRL));
                    HCERTSTORE rghStores[2];    // don't close these stores

                    // get this CRL
                    PBYTE pbCRL = NULL;
                    DWORD cbCRL;
                    hr = GetRowColContents(pFolder, rdi.nIndex, wszPROPCRLRAWCRL, &pbCRL, &cbCRL);
                    if (S_OK != hr)
                        break;

                    sViewCRL.pCRLContext = CertCreateCRLContext(
                        CRYPT_ASN_ENCODING,
                        pbCRL,
                        cbCRL);
                    delete [] pbCRL;

                    if (sViewCRL.pCRLContext == NULL)
                        break;

                    hr = m_pConsole->GetMainWindow(&sViewCRL.hwndParent);
                    if (S_OK != hr)
                        sViewCRL.hwndParent = NULL;    // should work

                    sViewCRL.dwSize = sizeof(sViewCRL);
                    //sViewCRL.dwFlags = 0;
                   
		    // if we're opening remotely, don't open local stores
		    if (! pCA->m_pParentMachine->IsLocalMachine())
		    {
			DWORD dw; 

			// get remote stores
			dw = pCA->GetRootCertStore(&rghStores[0]);
			_PrintIfError(dw, "GetRootCertStore");

			if (S_OK == dw)
			{
			    dw = pCA->GetCACertStore(&rghStores[1]);
			    _PrintIfError(dw, "GetCACertStore");
			} 

			if (S_OK == dw)
			{
			    // rely only on remote machine's stores
			    sViewCRL.cStores = 2;
			    sViewCRL.rghStores = rghStores;
			    sViewCRL.dwFlags |= CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
			}
			else
			{
			    // tell user we're only doing this locally
			    sViewCRL.dwFlags |= CRYPTUI_WARN_REMOTE_TRUST;
			}
		    }

                    if (!CryptUIDlgViewCRLW(&sViewCRL))
                        hr = GetLastError();

                    VERIFY(CertFreeCRLContext(sViewCRL.pCRLContext));
                    }
		    break;

                default:
                    break;
                }
            }
            break;
        case IDC_RESUBMITREQUEST:
            {
            LPWSTR szReqID = NULL;
            DWORD cbReqID;
            LONG lReqID;
            if (NULL == pFolder)
                break;

            if (pcwait == NULL)		// this might take awhile
                pcwait = new CWaitCursor;

            // "Request.RequestID"
            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, (PBYTE*)&szReqID, &cbReqID, TRUE);
            if (S_OK != hr)
                break;

            lReqID = _wtol(szReqID);
            delete [] szReqID;

            hr = CertAdminResubmitRequest(pFolder->GetCA(), pAdmin, lReqID);
            if (hr != S_OK)
                break;

            // dirty pane: refresh
            fMustRefresh = TRUE;

            break;
            }
        case IDC_DENYREQUEST:
            {
            LPWSTR szReqID = NULL;
            DWORD cbReqID;
            LONG lReqID;

            if (NULL == pFolder)
                break;

            // "Request.RequestID"
            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, (PBYTE*)&szReqID, &cbReqID, TRUE);
            if (S_OK != hr)
                break;

            lReqID = _wtol(szReqID);
            delete [] szReqID;

            if (!fConfirmedAction)
            {
                // confirm this action
                CString cstrMsg, cstrTitle;
                cstrMsg.LoadString(IDS_CONFIRM_DENY_REQUEST);
                cstrTitle.LoadString(IDS_DENY_REQUEST_TITLE);
                int iRet;
                if ((S_OK != m_pConsole->MessageBox(cstrMsg, cstrTitle, MB_YESNO, &iRet)) ||
                    (iRet != IDYES))
                {
                    hr = ERROR_CANCELLED;
                    goto ExitCommand;
                }

                fConfirmedAction = TRUE;
            }

            if (pcwait == NULL)		// this might take awhile
                pcwait = new CWaitCursor;

            hr = CertAdminDenyRequest(pFolder->GetCA(), pAdmin, lReqID);
            if (hr != S_OK)
                break;

            // dirty pane: refresh
            fMustRefresh = TRUE;

            break;
            }
        case IDC_VIEW_ATTR_EXT:
        {
            IEnumCERTVIEWEXTENSION* pExtn = NULL;
            IEnumCERTVIEWATTRIBUTE* pAttr = NULL;
            LPWSTR szReqID = NULL;
            DWORD cbReqID;
            HWND hwnd;

            ASSERT(pInternal->m_type == CCT_RESULT);

            if (NULL == pFolder)
                break;

            hr = m_pConsole->GetMainWindow(&hwnd);
            if (S_OK != hr)
                hwnd = NULL;    // should work

            // "Request.RequestID"
            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, (PBYTE*)&szReqID, &cbReqID, TRUE);
            if (S_OK != hr)
                break;

            // pollute the row enumerator we've got (doesn't alloc new IF)
            hr = m_RowEnum.SetRowEnumPos(rdi.nIndex);
            if (hr != S_OK)
               break;

            IEnumCERTVIEWROW* pRow; 
            hr = m_RowEnum.GetRowEnum(pFolder->GetCA(), &pRow);
            if (hr != S_OK)
                break;

            hr = pRow->EnumCertViewAttribute(0, &pAttr);
            if (hr != S_OK)
               break;

            hr = pRow->EnumCertViewExtension(0, &pExtn);
            if (hr != S_OK)
               break;

            hr = ViewRowAttributesExtensions(hwnd, pAttr, pExtn, szReqID);
            delete [] szReqID;
            if (pExtn)
                pExtn->Release();
            if (pAttr)
                pAttr->Release();

            if (hr != S_OK)
                break;

            break;
        }

        case IDC_DUMP_ASN:
        {
            PBYTE pbReq = NULL;
            DWORD cbReq;
			CString cstrFileName;
			LPCWSTR pszLocalizedCol = NULL;

            ASSERT(pInternal->m_type == CCT_RESULT);
            if (NULL == pFolder)
                break;

            CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
            HWND hwnd;

            hr = m_pConsole->GetMainWindow(&hwnd);
            if (S_OK != hr)
                hwnd = NULL;    // should work

            if (!fConfirmedAction)
            {
				hr = ChooseBinaryColumnToDump(hwnd, pData, &szCol, &fSaveInstead);
				if (hr != S_OK)
				   break;

				if (szCol == NULL) // strangeness
				{
				   hr = E_UNEXPECTED;
				   break;
				}
					fConfirmedAction = TRUE;
            }

            // "Request.RequestID"
            hr  = GetRowColContents(
				pFolder,
				rdi.nIndex,
				SERVERFUNC_ISSUED_CRLS == pFolder->GetType()?
				    wszPROPCRLROWID :
				    wszPROPREQUESTDOT wszPROPREQUESTREQUESTID,
				(PBYTE*)&pbReq,
				&cbReq,
				TRUE);
            if (S_OK != hr)
                break;

			hr = myGetColumnDisplayName(szCol, &pszLocalizedCol);
			if ((hr != S_OK) || (pszLocalizedCol == NULL))
				pszLocalizedCol = L"";
				
			cstrFileName = pszLocalizedCol;
			cstrFileName += L" - ";
			cstrFileName += (LPCWSTR)pbReq;
                        cstrFileName += L".tmp";
            delete [] pbReq;

            // get the request
            hr = GetRowColContents(pFolder, rdi.nIndex, szCol, &pbReq, &cbReq);
            if (S_OK != hr)
                break;

            hr = ViewRowRequestASN(hwnd, cstrFileName, pbReq, cbReq, fSaveInstead);
            delete [] pbReq;
            if (hr != S_OK)
                break;

            break;
        }
        case IDC_UNREVOKE_CERT:
            {
            ASSERT(pInternal->m_type == CCT_RESULT);
            if (NULL == pFolder)
                break;

            LPWSTR szCertSerNum = NULL;
            DWORD cbSerNum;
            PBYTE pbRevocationReason = NULL;
            DWORD cbRevocationReason;

            HWND hwnd;
            hr = m_pConsole->GetMainWindow(&hwnd);
            if (S_OK != hr)
                hwnd = NULL;    // should work

            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPREQUESTDOT wszPROPREQUESTREVOKEDREASON, &pbRevocationReason, &cbRevocationReason);
            if (S_OK != hr)
                break;
            if ((cbRevocationReason != sizeof(DWORD)) || (*(DWORD*)pbRevocationReason != CRL_REASON_CERTIFICATE_HOLD))
            {
                delete [] pbRevocationReason;
                DisplayCertSrvErrorWithContext(hwnd, S_OK, IDS_UNREVOKE_FAILED);   // don't display hokey "invalid state" error, just nice text

                hr = S_OK;
                break;
            }
            delete [] pbRevocationReason;
            // otherwise, continue

            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPCERTIFICATESERIALNUMBER, (PBYTE*)&szCertSerNum, &cbSerNum);
            if (S_OK != hr)
                break;

            // zero terminate
            WCHAR szTmpSerNum[MAX_PATH+1];
            CopyMemory(szTmpSerNum, szCertSerNum, cbSerNum);
            ASSERT((cbSerNum & 0x1) == 0x00);   // better be even!
            szTmpSerNum[cbSerNum>>1] = 0x00;
            delete [] szCertSerNum;

            hr = CertAdminRevokeCert(pFolder->GetCA(), pAdmin, MAXDWORD, szTmpSerNum);  // MAXDWORD == unrevoke
            if (hr != S_OK)
                break;

            // dirty pane: refresh
            fMustRefresh = TRUE;
            break;
            }

        case IDC_REVOKECERT:
            {
            ASSERT(pInternal->m_type == CCT_RESULT);
            if (NULL == pFolder)
                break;

            LPWSTR szCertSerNum = NULL;
            DWORD cbSerNum;

            hr  = GetRowColContents(pFolder, rdi.nIndex, wszPROPCERTIFICATESERIALNUMBER, (PBYTE*)&szCertSerNum, &cbSerNum);
            if (S_OK != hr)
                break;

            // zero terminate
            WCHAR szTmpSerNum[MAX_PATH+1];
            CopyMemory(szTmpSerNum, szCertSerNum, cbSerNum);
            ASSERT((cbSerNum & 0x1) == 0x00);   // better be even!
            szTmpSerNum[cbSerNum>>1] = 0x00;
            delete [] szCertSerNum;

            if (!fConfirmedAction)
            {
                HWND hwnd;
                hr = m_pConsole->GetMainWindow(&hwnd);
                if (S_OK != hr)
                    hwnd = NULL;    // should work

                hr = GetUserConfirmRevocationReason(&lReasonCode, hwnd);
                if (hr != S_OK)
                    goto ExitCommand;

                fConfirmedAction = TRUE;
            }
            if (pcwait == NULL)		// this might take awhile
                pcwait = new CWaitCursor;

            hr = CertAdminRevokeCert(pFolder->GetCA(), pAdmin, lReasonCode, szTmpSerNum);
            if (hr != S_OK)
                break;

            // dirty pane: refresh
            fMustRefresh = TRUE;
            break;
            }

        default:
                ASSERT(FALSE);  // Unknown command!
                break;
            }


            // if ever the user says stop, halt everything
            if (((HRESULT)ERROR_CANCELLED) == hr)
                goto ExitCommand;
        } // end loop
    } // if result
    else
    {
        ASSERT(FALSE);
    }

ExitCommand:
    FREE_DATA(pInternal);

    if (pcwait != NULL)
        delete pcwait;

    // might've been cached over multiple selections
    if (pAdmin)
        pAdmin->Release();

    if ((hr != S_OK) && (hr != ERROR_CANCELLED) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
        DisplayGenericCertSrvError(m_pConsole, hr);

    // only do this once
    if (fMustRefresh)
    {
        // notify views: refresh service toolbar buttons
        m_pConsole->UpdateAllViews(
            pDataObject,
            0,
            0);
    }

    return S_OK;
}

STDMETHODIMP CSnapin::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return E_NOTIMPL;
}

STDMETHODIMP CSnapin::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CSnapin::Load(IStream *pStm)
{
    HRESULT hr;
    ASSERT(m_bInitializedC);
    ASSERT(pStm);

    // Read the string
    DWORD dwVer;

    hr = ReadOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Load: dwVer");

    ASSERT((VER_CSNAPIN_SAVE_STREAM_3 == dwVer) || (VER_CSNAPIN_SAVE_STREAM_2 == dwVer));
    if ((VER_CSNAPIN_SAVE_STREAM_3 != dwVer) &&
        (VER_CSNAPIN_SAVE_STREAM_2 != dwVer))
    {
        hr = STG_E_OLDFORMAT;
        _JumpError(hr, Ret, "dwVer");
    }

    // version-dependent info
    if (VER_CSNAPIN_SAVE_STREAM_3 == dwVer)
    {
        // View ID
        hr = ReadOfSize(pStm, &m_dwViewID, sizeof(DWORD));
        _JumpIfError(hr, Ret, "Load: m_dwViewID");

        // row enum
        hr = m_RowEnum.Load(pStm);
        _JumpIfError(hr, Ret, "Load::m_RowEnum");
    }

Ret:
    ClearDirty();

    return hr;
}


STDMETHODIMP CSnapin::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr;

    ASSERT(m_bInitializedC);
    ASSERT(pStm);

    // Write the version
    DWORD dwVer = VER_CSNAPIN_SAVE_STREAM_3;

    hr = WriteOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Save: dwVer");

    // View ID
    hr = WriteOfSize(pStm, &m_dwViewID, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Save: m_dwViewID");

    hr = m_RowEnum.Save(pStm, fClearDirty);
    _JumpIfError(hr, Ret, "Save::m_RowEnum");

Ret:
    if (fClearDirty)
        ClearDirty();
    return hr;
}

STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    DWORD cbSize;
    cbSize = sizeof(DWORD);     // Version

    cbSize += sizeof(DWORD);    // m_dwViewID

    int iAdditionalSize = 0;
    m_RowEnum.GetSizeMax(&iAdditionalSize);
    cbSize += iAdditionalSize;

    // Set the size of the string to be saved
    ULISet32(*pcbSize, cbSize);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet implementation
//
STDMETHODIMP
CSnapin::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK, // lpProvider
    LONG_PTR, // handle
    LPDATAOBJECT) // lpIDataObject
{
    // no property pages
    return S_OK;
}

STDMETHODIMP
CSnapin::QueryPagesFor(
    LPDATAOBJECT) // lpDataObject
{
    // Get the node type and see if it's one of mine

    // if (nodetype == one of mine)
    //      do this
    // else
    //      see which node type it is and answer the question

    BOOL bResult = FALSE;

    return (bResult) ? S_OK : S_FALSE;

    // Look at the data object and see if it an item in the scope pane
    // return IsScopePaneNode(lpDataObject) ? S_OK : S_FALSE;
}



///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//


STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar)
{
    if (m_pControlbar)
        SAFE_RELEASE(m_pControlbar);

    if (pControlbar != NULL)
    {
        // Hold on to the controlbar interface.
        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        HRESULT hr=S_FALSE;

        // SvrMgrToolbar1
        if (!m_pSvrMgrToolbar1)
        {
            hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pSvrMgrToolbar1));
            ASSERT(SUCCEEDED(hr));

            // Add the bitmap
	    ASSERT(NULL != g_pResources && g_pResources->m_fLoaded);
            hr = m_pSvrMgrToolbar1->AddBitmap(2, g_pResources->m_bmpSvrMgrToolbar1, 16, 16, RGB(192,192,192));
            ASSERT(SUCCEEDED(hr));

            // Add the buttons to the toolbar
            for (int i=0; ((SvrMgrToolbar1Buttons[i].item.lpButtonText != NULL) && (SvrMgrToolbar1Buttons[i].item.lpTooltipText != NULL)); i++)
            {
                hr = m_pSvrMgrToolbar1->AddButtons(1, &SvrMgrToolbar1Buttons[i].item);
                ASSERT(SUCCEEDED(hr));
            }
        }
    }

    return S_OK;
}


void CSnapin::OnButtonClick(LPDATAOBJECT pdtobj, int idBtn)
{

    switch(idBtn)
    {
    case IDC_STOPSERVER:
    case IDC_STARTSERVER:
        // bubble this to our other handler
        dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(idBtn, pdtobj);
        break;
    default:
        {
        ASSERT(FALSE);
        }
        break;
    }
}


STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    switch (event)
    {
    case MMCN_BTN_CLICK:
        OnButtonClick(reinterpret_cast<LPDATAOBJECT>(arg), (INT)param);
        break;

    case MMCN_DESELECT_ALL:
    case MMCN_SELECT:
        HandleExtToolbars((event == MMCN_DESELECT_ALL), arg, param);
        break;

    case MMCN_MENU_BTNCLICK:
        HandleExtMenus(arg, param);
        break;

    default:
        break;
    }
    return S_OK;
}

// This compares two data objects to see if they are the same object.
// return
//    S_OK if equal otherwise S_FALSE
//
// Note: check to make sure both objects belong to the snap-in.
//

STDMETHODIMP
CSnapin::CompareObjects(
    LPDATAOBJECT, // lpDataObjectA
    LPDATAOBJECT) // lpDataObjectB
{
    return S_FALSE;
}


// This compare is used to sort the items in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort() was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assume sort is ascending when comparing -- mmc reverses the result if it needs to
STDMETHODIMP
CSnapin::Compare(
    LPARAM, // lUserParam
    MMC_COOKIE cookieA,
    MMC_COOKIE cookieB,
    int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    LONG nCol = (LONG) *pnResult;
    ASSERT(nCol >=0);

    *pnResult = 0;

    USES_CONVERSION;

    LPWSTR szStringA;
    LPWSTR szStringB;

    RESULT_DATA* pDataA = reinterpret_cast<RESULT_DATA*>(cookieA);
    RESULT_DATA* pDataB = reinterpret_cast<RESULT_DATA*>(cookieB);


    ASSERT(pDataA != NULL && pDataB != NULL);

    ASSERT(nCol < (int)pDataA->cStringArray);
    ASSERT(nCol < (int)pDataB->cStringArray);

    szStringA = OLE2T(pDataA->szStringArray[nCol]);
    szStringB = OLE2T(pDataB->szStringArray[nCol]);

    ASSERT(szStringA != NULL);
    ASSERT(szStringB != NULL);

    if ((szStringA == NULL) || (szStringB == NULL))
        return E_POINTER;


    // return simple strcmp
    *pnResult = wcscmp(szStringA, szStringB);

    return S_OK;
}

STDMETHODIMP
CSnapin::FindItem(
    LPRESULTFINDINFO, // pFindInfo
    int *) // pnFoundIndex
{
    // not implemented: S_FALSE == no find
    return S_FALSE;
}


STDMETHODIMP
CSnapin::CacheHint(
    int, // nStartIndex
    int) // nEndIndex
{
    return S_OK;
}


STDMETHODIMP
CSnapin::SortItems(
    int nColumn,
    DWORD, // dwSortOptions
    LPARAM) // lUserParam
{
    HRESULT hr;

    LPCWSTR pszHeading;
    BOOL fIndexed = FALSE;
    CComponentDataImpl* pCompData;
    CFolder* pFolder;

    // if non-virtual, report "we don't allow sort"
    if (!m_bVirtualView)
        goto Ret;

    pCompData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (pCompData == NULL)
        goto Ret;

    pFolder = GetVirtualFolder();
    if (pFolder == NULL)
        goto Ret;

    // responding S_OK to this allows ^ and down arrow display
    hr = pCompData->GetDBSchemaEntry(nColumn, &pszHeading, NULL, &fIndexed);
    _JumpIfError(hr, Ret, "GetDBSchemaEntry");

    if (fIndexed)
    {
        // special case: disallow sort on serial# in failed, pending folders
        // this column has "ignore null" bit set, and sort results in {} set.
        if ((pFolder->GetType() == SERVERFUNC_FAILED_CERTIFICATES) ||
            (pFolder->GetType() == SERVERFUNC_PENDING_CERTIFICATES))
        {
            // if serial number click, act like not indexed -- NO SORT
            if (0 == wcscmp(pszHeading, wszPROPCERTIFICATESERIALNUMBER))
                fIndexed = FALSE;
        }
    }


Ret:
    // S_FALSE == no sort
    return fIndexed ? S_OK : S_FALSE;
}



#define HIDEVERB(__x__) \
    do {                \
        m_pConsoleVerb->SetVerbState(__x__, HIDDEN, TRUE);  \
        m_pConsoleVerb->SetVerbState(__x__, ENABLED, FALSE); \
    } while(0)

#define SHOWVERB(__x__) \
    do {                \
        m_pConsoleVerb->SetVerbState(__x__, HIDDEN, FALSE);  \
        m_pConsoleVerb->SetVerbState(__x__, ENABLED, TRUE); \
    } while(0)


void CSnapin::HandleStandardVerbs(bool bDeselectAll, LPARAM arg,
                                  LPDATAOBJECT lpDataObject)
{
    // You should crack the data object and enable/disable/hide standard
    // commands appropriately.  The standard commands are reset everytime you get
    // called. So you must reset them back.


    if (m_CustomViewID != VIEW_DEFAULT_LV)
    {
        // UNDONE: When is this executed?
        SHOWVERB(MMC_VERB_REFRESH);
        SHOWVERB(MMC_VERB_PROPERTIES);

        return;
    }

    if (!bDeselectAll && lpDataObject == NULL)
        return;

    WORD bScope = LOWORD(arg);
    WORD bSelect = HIWORD(arg);


    //
    // Derive internal, pfolder
    //
    INTERNAL* pInternal = lpDataObject ? ExtractInternalFormat(lpDataObject) : NULL;
    // if scope item, derive parent folder from pInternal.
    // if result item, recall parent folder from saved state
    CFolder* pFolder = (bScope) ? ::GetParentFolder(pInternal) : GetParentFolder(pInternal);

    //
    // set state appropriately
    //
    if (bDeselectAll || !bSelect)
    {
        // deselection notification

        // verbs cleared for us, right?
    }
    else if (m_pConsoleVerb && pInternal)   // selected
    {
        _MMC_CONSOLE_VERB verbDefault = MMC_VERB_NONE;

        // unsupported properties
        HIDEVERB(MMC_VERB_OPEN);
        HIDEVERB(MMC_VERB_COPY);
        HIDEVERB(MMC_VERB_PASTE);
        HIDEVERB(MMC_VERB_DELETE);
        HIDEVERB(MMC_VERB_PRINT);
        HIDEVERB(MMC_VERB_RENAME); // could easily be supported, but was removed (bug 217502)
        // MMC_VERB_REFRESH is supported
        // MMC_VERB_PROPERTIES is supported

        if (pInternal->m_type == CCT_SCOPE)
        {
            if(!pFolder)
            {
                _PrintError2(E_POINTER, "GetParentFolder", E_POINTER);
                return;
            }

            // selected scope item

            // Standard functionality support by scope items
            SHOWVERB(MMC_VERB_REFRESH);

            // Disable properties for static node,
            // enable properties only for server instance, crl
            if  ((pInternal->m_cookie != 0) &&
                 ((SERVER_INSTANCE == pFolder->m_type) ||
                  (SERVERFUNC_CRL_PUBLICATION == pFolder->m_type)) )
            {
                SHOWVERB(MMC_VERB_PROPERTIES);
            }
            else
                HIDEVERB(MMC_VERB_PROPERTIES);

            // default folder verb is open
            verbDefault = MMC_VERB_OPEN;
        }
        else
        {
            // selected result item

            // Standard functionality supported by result items
            SHOWVERB(MMC_VERB_REFRESH);

            HIDEVERB(MMC_VERB_PROPERTIES);
        }

        m_pConsoleVerb->SetDefaultVerb(verbDefault);
    }

    FREE_DATA(pInternal);
}

void CSnapin::SmartEnableServiceControlButtons()
{
    BOOL fSvcRunning;
    CComponentDataImpl* pCompData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (pCompData)
    {

    fSvcRunning = pCompData->m_pCertMachine->IsCertSvrServiceRunning();
    if (m_pSvrMgrToolbar1)
    {
        m_pSvrMgrToolbar1->SetButtonState(SvrMgrToolbar1Buttons[ENUM_BUTTON_STARTSVC].item.idCommand, ENABLED, !fSvcRunning);
        m_pSvrMgrToolbar1->SetButtonState(SvrMgrToolbar1Buttons[ENUM_BUTTON_STOPSVC].item.idCommand, ENABLED, fSvcRunning);
    }

    }
}

void CSnapin::HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param)
{
    INTERNAL* pInternal = NULL;
    HRESULT hr;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

    if (param)
        pInternal = ExtractInternalFormat(reinterpret_cast<LPDATAOBJECT>(param));


    // Deselection Notification?
    if (bDeselectAll || bSelect == FALSE)
        return;


    ASSERT(bSelect == TRUE);
    bool bFileExBtn = false;


    if (pInternal == NULL)
        return;

    CFolder* pFolder = GetParentFolder(pInternal);

    if (bScope)
    {
        // special stuff to do at SCOPE level?
    }
    else // result item selected: result or subfolder
    {
        // special stuff to do at RESULTS level
        if (pInternal->m_type == CCT_RESULT)
        {
            bFileExBtn = true;

            // UNDONE: what to do here with SvrMgrToolbar1Buttons1?
            // For now, do nothing: allow them to remain in same state
        }
    }

    CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    ASSERT(pData != NULL);

    if (IsPrimaryImpl() &&
        (IsAllowedStartStop(pFolder, pData->m_pCertMachine)) )
    {
        // Attach the SvrMgrToolbar1 to the window
        hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        // Detach the SvrMgrToolbar1 to the window
        hr = m_pControlbar->Detach((LPUNKNOWN) m_pSvrMgrToolbar1);
        ASSERT(SUCCEEDED(hr));
    }

    SmartEnableServiceControlButtons();

    FREE_DATA(pInternal);
}

// dropdown menu addition
void
CSnapin::HandleExtMenus(
    LPARAM, // arg
    LPARAM) // param
{
}


CFolder* CSnapin::GetVirtualFolder()
{
    ASSERT(m_bVirtualView);
    return m_pCurrentlySelectedScopeFolder;
}

// caller needs to CACloseCertType(hCertType)

HRESULT
CSnapin::FindCertType(
    IN LPCWSTR pcwszCert,
    OUT HCERTTYPE& hCertType)
{
    HRESULT hr;

    if(NULL==m_hCertTypeList)
    {
        hr = CAEnumCertTypes(
        CT_ENUM_USER_TYPES |
        CT_ENUM_MACHINE_TYPES |
        CT_FLAG_NO_CACHE_LOOKUP,
        &m_hCertTypeList);
        _JumpIfError(hr, error, "CAEnumCertTypes");
    }

    hr = myFindCertTypeByNameOrOID(
        m_hCertTypeList,
        pcwszCert, // we don't know if this is a name or an OID
        pcwszCert,
        hCertType);	// OUT by reference!!!
    _JumpIfError(hr, error, "myFindCertTypeByNameOrOID");

    if (m_hCertTypeList == hCertType)
    {
        m_hCertTypeList = NULL;
        hr = CAEnumCertTypes(
            CT_ENUM_USER_TYPES |
            CT_ENUM_MACHINE_TYPES,
            &m_hCertTypeList);
	if (S_OK != hr)
	{
	    m_hCertTypeList = hCertType;
	    hCertType = NULL;
	    _JumpError(hr, error, "CAEnumCertTypes");
	}
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\csnapin.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// CSnapin.h : Declaration of the CSnapin

#ifndef _CSNAPIN_H_
#define _CSNAPIN_H_

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

typedef struct _MY_MMCBUTTON
{
    MMCBUTTON item;
    UINT uiString1;
    UINT uiString2;
    WCHAR szString1[MAX_RESOURCE_STRLEN];
    WCHAR szString2[MAX_RESOURCE_STRLEN];
} MY_MMCBUTTON, *PMY_MMCBUTTON;

MY_MMCBUTTON SvrMgrToolbar1Buttons[];

// File Versions
// current version
#define VER_CSNAPIN_SAVE_STREAM_3     0x03
// includes  m_dwViewID, m_RowEnum

// version written through Win2000 beta 3
#define VER_CSNAPIN_SAVE_STREAM_2     0x02
/////////////////////////////

template <class TYPE>
TYPE*       Extract(LPDATAOBJECT lpDataObject, CLIPFORMAT cf);
CLSID*      ExtractClassID(LPDATAOBJECT lpDataObject);
GUID*       ExtractNodeType(LPDATAOBJECT lpDataObject);
INTERNAL*   ExtractInternalFormat(LPDATAOBJECT lpDataObject);

BOOL        IsMMCMultiSelectDataObject(IDataObject* pDataObject);
HRESULT     _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, DWORD dwViewID,
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject);

CFolder*    GetParentFolder(INTERNAL* pInternal);


/////////////////////////////////////////////////////////////////////////////
// Snapin

//
// helper methods extracting data from data object
//
INTERNAL *   ExtractInternalFormat(LPDATAOBJECT lpDataObject);
wchar_t *    ExtractWorkstation(LPDATAOBJECT lpDataObject);
GUID *       ExtractNodeType(LPDATAOBJECT lpDataObject);
CLSID *      ExtractClassID(LPDATAOBJECT lpDataObject);


#define         g_szEmptyHeader L" "



enum CUSTOM_VIEW_ID
{
    VIEW_DEFAULT_LV = 0,
    VIEW_MICROSOFT_URL = 2,
};

class CSnapin :
    public IComponent,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IExtendControlbar,
    public IResultDataCompare,
    public IResultOwnerData,
    public IPersistStream,
    public CComObjectRoot
{
public:
    CSnapin();
    virtual ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompare)
    COM_INTERFACE_ENTRY(IResultOwnerData)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()


// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, LONG* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IResultOwnerData
    STDMETHOD(FindItem)(LPRESULTFINDINFO pFindInfo, int* pnFoundIndex);
    STDMETHOD(CacheHint)(int nStartIndex, int nEndIndex);
    STDMETHOD(SortItems)(int nColumn, DWORD dwSortOptions, LPARAM lUserParam);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    // Only for debug purpose
    bool m_bInitializedC;
    bool m_bLoadedC;
    bool m_bDestroyedC;

// Helpers for CSnapin
public:
    void SmartEnableServiceControlButtons();
    void SetIComponentData(CComponentDataImpl* pData);

//    void RefreshFolder(CFolder* pFolder);
    CFolder* GetVirtualFolder();
    CFolder* GetParentFolder(INTERNAL* pInternal);

    BOOL IsPrimaryImpl()
    {
        CComponentDataImpl* pData =
            dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->IsPrimaryImpl();

        return FALSE;
    }

    void SetViewID(DWORD id) { m_dwViewID = id; }

#if DBG
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG

// Notify event handlers
protected:
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject, LPARAM arg);
    HRESULT OnContextHelp(LPDATAOBJECT lpDataObject);
    void    OnButtonClick(LPDATAOBJECT pdtobj, int idBtn);

    HRESULT QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                   LPDATAOBJECT* ppDataObject);

// IExtendContextMenu
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                            LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            LONG *pInsertionAllowed);
    STDMETHOD(Command)(LONG nCommandID, LPDATAOBJECT pDataObject);


// Helper functions
protected:
    BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
    void Construct();

    HRESULT GetColumnSetData(MMC_COOKIE cookie, MMC_COLUMN_SET_DATA** ppColSetData);
    HRESULT GetColumnSortData(MMC_COOKIE cookie, int* piColSortIdx, BOOL* pfAscending);

    HRESULT BuildTemplateDisplayName(
        LPCWSTR pcwszFriendlyName, 
        LPCWSTR pcwszTemplateName,
        VARIANT& varDisplayName);

    HRESULT InitializeHeaders(MMC_COOKIE cookie);
    HRESULT InsertAllColumns(MMC_COOKIE cookie, CertViewRowEnum* pCertViewRowEnum);
    HRESULT DoInsertAllColumns(MMC_COLUMN_SET_DATA* pCols);
    HRESULT SynchColumns(MMC_COOKIE cookie);

    HRESULT FindCertType(LPCWSTR pcwszCert, HCERTTYPE& hCertType);

// Result Helpers
    HRESULT GetRowColContents(CFolder* pFolder, LONG idxRow, LPCWSTR szColHead, PBYTE* ppbData, DWORD* pcbData, BOOL fStringFmt=FALSE);
    HRESULT GetCellContents(CertViewRowEnum* pCRowEnum, CertSvrCA* pCA, LONG idxRow, LONG idxCol, PBYTE pbData, DWORD* pcbData, BOOL fStringFmt);

// UI Helpers
    void HandleStandardVerbs(bool bDeselectAll, LPARAM arg, LPDATAOBJECT lpDataObject);
    void HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param);
	void HandleExtMenus(LPARAM arg, LPARAM param);
    void OnRefresh(LPDATAOBJECT pDataObject);

// Interface pointers
protected:
    LPCONSOLE2          m_pConsole;         // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;          // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    LPRESULTDATA        m_pResult;          // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult;     // My interface pointer to the result pane image list

    LPCONTROLBAR        m_pControlbar;      // control bar to hold my tool bars
    LPCONSOLEVERB       m_pConsoleVerb;     // pointer the console verb

    LPTOOLBAR           m_pSvrMgrToolbar1;    // Toolbar for view
    LPCOLUMNDATA        m_pViewData;        // info on our columns


    CFolder*            m_pCurrentlySelectedScopeFolder;    // keep track of who has focus

    // all interesting view data here
    CertViewRowEnum     m_RowEnum;

    HCERTTYPE           m_hCertTypeList;

private:
    BOOL                m_bIsDirty;
    CUSTOM_VIEW_ID      m_CustomViewID;
    BOOL                m_bVirtualView;

    // HACK HACK
    // used to override the sort order on MMCN_CLICK notifications --
    // the view data isn't set early enough in the process for us to use it
    // This must remain with view, there might be multiple near-simultaneous clicks happening
    typedef struct _COLCLICK_SORT_OVERRIDE
    {
        BOOL    fClickOverride;
        int     colIdx;
        DWORD   dwOptions;
    } COLCLICK_SORT_OVERRIDE;
    COLCLICK_SORT_OVERRIDE m_ColSortOverride;

    // HACK HACK
    // used to override the column selection on MMCN_COLUMNS_CHANGED notifications --
    // the view data isn't set early enough in the process for us to use it
    // This must remain with view, there might be multiple near-simultaneous insertions happening
    typedef struct _COLCLICK_SET_OVERRIDE
    {
        BOOL    fClickOverride;
        MMC_COLUMN_SET_DATA* pColSetData;
    } COLCLICK_SET_OVERRIDE;
    COLCLICK_SET_OVERRIDE m_ColSetOverride;


    // result row flag
    DWORD               m_dwKnownResultRows;
    DWORD KnownResultRows()      { return m_dwKnownResultRows; };
    void SetKnowResultRows(DWORD dwRows)     { m_dwKnownResultRows = dwRows; };
    void ResetKnowResultRows()   { m_dwKnownResultRows = 1; m_dwViewErrorMsg = S_OK; };

    DWORD               m_dwViewErrorMsg;
    CString             m_cstrViewErrorMsg;

    // keeps our col views seperate
    DWORD               m_dwViewID;

    // counter used to protect from reentrancy in ICertView (bug 339811)
    LONG   m_cViewCalls;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }
};



class CSnapinAboutImpl :
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass<CSnapinAboutImpl, &CLSID_About>
{
public:
    CSnapinAboutImpl();
    ~CSnapinAboutImpl();

public:
DECLARE_REGISTRY(CSnapin, _T("Snapin.About.1"), _T("Snapin.About"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CSnapinAboutImpl)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage,
                                    HBITMAP* hSmallImageOpen,
                                    HBITMAP* hLargeImage,
                                    COLORREF* cLargeMask);

// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
    HRESULT AboutHelper2(LPSTR str, LPOLESTR* lpPtr);
};



#endif // #define _CSNAPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "certsrv.h"
#include "csprop.h"
#include "setupids.h"
#include "misc.h"

#define __dwFILE__	__dwFILE_CERTMMC_EVENTS_CPP__


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

HRESULT
CSnapin::OnAddImages(
    MMC_COOKIE, // cookie
    LPARAM arg,
    LPARAM /* param */ )
{
    if (arg == 0)
        return E_INVALIDARG;
    
    ASSERT(m_pImageResult != NULL);
    ASSERT((IImageList*)arg == m_pImageResult);

    CBitmap bmpResultStrip16x16, bmpResultStrip32x32;
    if (NULL == bmpResultStrip16x16.LoadBitmap(IDB_16x16))
        return S_FALSE;
    
    if (NULL == bmpResultStrip32x32.LoadBitmap(IDB_32x32))
        return S_FALSE;

    // Set the images
    m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmpResultStrip16x16)),
                      reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmpResultStrip32x32)),
                       0, RGB(255, 0, 255));

    return S_OK;
}


HRESULT
CSnapin::OnShow(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM /* param */ )
{
    HRESULT hr;
    CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie);

    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
        m_pCurrentlySelectedScopeFolder = pFolder;

        // if list view on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
             // Show the headers for this nodetype
             hr = InitializeHeaders(cookie);

            // virtual list support
            if (m_bVirtualView)
                m_pResult->SetItemCount(1, 0);
        }
    }
    else
    {
        // if list view is on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
            // Free data associated with the result pane items, because
            // your node is no longer being displayed.
        }


        // Note: The console will remove the items from the result pane
    }

    return S_OK;
}


HRESULT CSnapin::GetRowColContents(CFolder* pFolder, LONG idxRow, LPCWSTR szColHead, PBYTE* ppbData, DWORD* pcbData, BOOL fStringFmt /*FALSE*/)
{
    HRESULT hr;
    LONG idxCol;
    IEnumCERTVIEWROW* pRow = NULL;
    ICertView* pView = NULL;

#if DBG
    DWORD dwVerifySize;
#endif

    CComponentDataImpl* pCompData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    ASSERT(pCompData != NULL);
    if (pCompData == NULL)
        return E_POINTER;

    ASSERT(pFolder != NULL);

    // pollute the row enumerator we've got
    hr = m_RowEnum.GetRowEnum(pFolder->GetCA(), &pRow);
    _JumpIfError(hr, Ret, "GetRowEnum");

    hr = m_RowEnum.SetRowEnumPos(idxRow);
    _JumpIfError(hr, Ret, "SetRowEnumPos");

    // now we have the correct row; siphon data out of the correct column
    hr = m_RowEnum.GetView(pFolder->GetCA(), &pView);
    _JumpIfError(hr, Ret, "GetView");

    // get column number in schema
    idxCol = pCompData->FindColIdx(szColHead);

    // retrieve and alloc
    *pcbData = 0;
    hr = GetCellContents(&m_RowEnum, pFolder->GetCA(), idxRow, idxCol, NULL, pcbData, fStringFmt);
    _JumpIfError(hr, Ret, "GetCellContents");

    *ppbData = new BYTE[*pcbData];
    _JumpIfOutOfMemory(hr, Ret, *ppbData);

#if DBG
    dwVerifySize = *pcbData;
#endif
    hr = GetCellContents(&m_RowEnum, pFolder->GetCA(), idxRow, idxCol, *ppbData, pcbData, fStringFmt);
    _JumpIfError(hr, Ret, "GetCellContents");

#if DBG
    ASSERT(dwVerifySize == *pcbData);
#endif

Ret:
    // catch column inclusion errors, handle in a smart way
    if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_INDEX) ||
        hr == HRESULT_FROM_WIN32(ERROR_CONTINUE))
    {
        CString cstrFormat;
        cstrFormat.LoadString(IDS_COLUMN_INCLUSION_ERROR);

        LPCWSTR pszLocalizedCol = NULL;
        hr = myGetColumnDisplayName(szColHead, &pszLocalizedCol);
        ASSERT ((hr == S_OK) && (NULL != pszLocalizedCol));

        CString cstrTmp;
        cstrTmp.Format(cstrFormat, pszLocalizedCol);

        cstrFormat.Empty();
        cstrFormat.LoadString(IDS_MSG_TITLE);
        m_pConsole->MessageBoxW(cstrTmp, cstrFormat, MB_OK, NULL);
        
        hr = ERROR_CANCELLED;   // this is a cancellation so bail silently, we've shown error
    }

    return hr;
}


HRESULT
GetBinaryColumnFormat(
    IN WCHAR const *pwszColumnName,
    OUT LONG *pFormat)
{
    LONG Format = CV_OUT_BINARY;

    if (0 == LSTRCMPIS(
		pwszColumnName,
		wszPROPREQUESTDOT wszPROPREQUESTRAWREQUEST))
    {
	Format = CV_OUT_BASE64REQUESTHEADER;
    }
    else
    if (0 == LSTRCMPIS(pwszColumnName, wszPROPRAWCERTIFICATE) ||
	0 == LSTRCMPIS(
		pwszColumnName,
		wszPROPREQUESTDOT wszPROPREQUESTRAWOLDCERTIFICATE))
    {
	Format = CV_OUT_BASE64HEADER;
    }
    else
    if (0 == LSTRCMPIS(pwszColumnName, wszPROPCRLRAWCRL))
    {
	Format = CV_OUT_BASE64X509CRLHEADER;
    }
    else
    {
	Format = CV_OUT_HEX;
    }

    *pFormat = Format;
    return(S_OK);
}


// Build the display name for templates: "friendly name (internal name)"
HRESULT CSnapin::BuildTemplateDisplayName(
    LPCWSTR pcwszFriendlyName, 
    LPCWSTR pcwszTemplateName,
    VARIANT& varDisplayName)
{

    CString strName;
    strName = pcwszFriendlyName;
    strName += L" (";
    strName += pcwszTemplateName;
    strName += L")";
    V_VT(&varDisplayName) = VT_BSTR;
    V_BSTR(&varDisplayName) = ::SysAllocString(strName);
    if(!V_BSTR(&varDisplayName))
        return E_OUTOFMEMORY;
    return S_OK;
}

// copies cell to pbData, truncates if necessary. Real size passed out in pcbData
HRESULT CSnapin::GetCellContents(CertViewRowEnum* pCRowEnum, CertSvrCA* pCA, LONG idxRow, LONG idxCol, PBYTE pbData, DWORD* pcbData, BOOL fStringFmt)
{
    HRESULT hr;

    CComponentDataImpl* pCompData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (NULL == pCompData)
         return E_POINTER;

    VARIANT varCert;
    VariantInit(&varCert);

    LONG idxViewCol;

    IEnumCERTVIEWROW* pRow;
    IEnumCERTVIEWCOLUMN* pCol = NULL;

    hr = pCRowEnum->GetRowEnum(pCA, &pRow);
    if (hr != S_OK)
        return hr;

    do 
    {
        hr = pCRowEnum->SetRowEnumPos(idxRow);
        if (hr != S_OK)
            break;

        LONG lType;
        LPCWSTR szColHead;  // no free needed
        hr = pCRowEnum->GetColumnCacheInfo(idxCol, (int*)&idxViewCol);
        if (hr != S_OK)
            break;

        // get col enumerator object
        hr = pRow->EnumCertViewColumn(&pCol);
        if (hr != S_OK)
            break;

        hr = pCol->Skip(idxViewCol);
        if (hr != S_OK)
            break;
        // get value there
        hr = pCol->Next(&idxViewCol);
        if (hr != S_OK)
            break;


        if (fStringFmt)
        {
            LONG lFormat = CV_OUT_BINARY;
            VARIANT varTmp;
            VariantInit(&varTmp);

            hr = pCompData->GetDBSchemaEntry(idxCol, &szColHead, &lType, NULL);
            if (hr != S_OK)
                break;

            // New: translate _some_ cols to readable strings
            
            if (PROPTYPE_BINARY == lType)
            {
                hr = GetBinaryColumnFormat(szColHead, &lFormat);
                if (hr != S_OK)
                   break;
            }

            hr = pCol->GetValue(lFormat, &varTmp);
            if (hr != S_OK)
                break;
            
            if (0 == LSTRCMPIS(szColHead, wszPROPREQUESTDOT wszPROPREQUESTRAWARCHIVEDKEY))
            {
                if (VT_EMPTY != varTmp.vt)
                {
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szYes);
                    varCert.vt = VT_BSTR;
                }
            }
            else if (0 == LSTRCMPIS(szColHead, wszPROPCERTTEMPLATE))
            {
                LPCWSTR pcwszOID = NULL;
                
                if (VT_BSTR == varTmp.vt)
                {
                    // Map OID or template name to friendly name

                    // Try name first
                    HCERTTYPE hCertType;
                    LPWSTR *pwszCertTypeName;

                    hr = FindCertType(
                        varTmp.bstrVal,
                        hCertType);

                    if(S_OK==hr)
                    {
                        hr = CAGetCertTypeProperty(
                                    hCertType,
                                    CERTTYPE_PROP_FRIENDLY_NAME,
                                    &pwszCertTypeName);
                        if(S_OK==hr)
                        {
			    hr = S_FALSE;
                            if (NULL != pwszCertTypeName)
			    {
				if (NULL != pwszCertTypeName[0])
				{
				    BuildTemplateDisplayName(
					pwszCertTypeName[0],
					varTmp.bstrVal,
					varCert);
				    hr = S_OK;
				}
			    }
                            CAFreeCertTypeProperty(
                                hCertType,
                                pwszCertTypeName);
                        }
                        CACloseCertType(hCertType);
                    }
                    // Failed to find by name, try OID
                    if(S_OK!=hr)
                    {
                        pcwszOID = myGetOIDName(varTmp.bstrVal);
                        if(!pcwszOID)
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }

                        hr = S_OK;
                        varCert.vt = VT_BSTR;
                        if (EmptyString(pcwszOID))
                        {
                            varCert.bstrVal = ::SysAllocString(varTmp.bstrVal);
                            if(!varCert.bstrVal)
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                        }
                        else
                        {
                            hr = BuildTemplateDisplayName(
                                pcwszOID,
                                varTmp.bstrVal,
                                varCert);
                            if(S_OK != hr)
                                break;
                        }
                    }
                }
            }
            else if (0 == LSTRCMPIS(szColHead, wszPROPREQUESTDOT wszPROPREQUESTSTATUSCODE) ||
		     0 == LSTRCMPIS(szColHead, wszPROPCRLPUBLISHSTATUSCODE))
            {
                if (VT_I4 == varTmp.vt)   // don't be empty
                {
		    WCHAR const *pwszError = myGetErrorMessageText(varTmp.lVal, TRUE);
                    varCert.bstrVal = ::SysAllocString(pwszError);
                    varCert.vt = VT_BSTR;
		    if (NULL != pwszError)
		    {
			LocalFree(const_cast<WCHAR *>(pwszError));
		    }
                }
            }
            else if (0 == LSTRCMPIS(szColHead, wszPROPREQUESTDOT wszPROPREQUESTREVOKEDREASON))
            {
                if (VT_I4 == varTmp.vt)   // don't be empty
                {

                // Request.Disposition
                ASSERT(VT_I4 == varTmp.vt); // we'd better be looking at a dword

                switch(varTmp.lVal)
                {
                case CRL_REASON_KEY_COMPROMISE:
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szRevokeReason_KeyCompromise);
                    break;
                case CRL_REASON_CA_COMPROMISE:
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szRevokeReason_CaCompromise);
                    break;
                case CRL_REASON_AFFILIATION_CHANGED:
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szRevokeReason_Affiliation);
                    break;
                case CRL_REASON_SUPERSEDED:
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szRevokeReason_Superseded);
                    break;
                case CRL_REASON_CESSATION_OF_OPERATION:
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szRevokeReason_Cessatation);
                    break;
                case CRL_REASON_CERTIFICATE_HOLD:
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szRevokeReason_CertHold);
                    break;
                case CRL_REASON_UNSPECIFIED:
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szRevokeReason_Unspecified);
                    break;
                case CRL_REASON_REMOVE_FROM_CRL:
                    varCert.bstrVal = ::SysAllocString(g_pResources->m_szRevokeReason_RemoveFromCRL);
                    break;
                default:
                  {
                    // sprint this into a buffer for display
                    CString cstrSprintVal;
                    cstrSprintVal.Format(L"%i", varTmp.lVal);
                    varCert.bstrVal = cstrSprintVal.AllocSysString();
                    break;
                  }
                }

                if (varCert.bstrVal == NULL)
                {
                     hr = E_OUTOFMEMORY;
                     break;
                }

                varCert.vt = VT_BSTR;
                }
            }
            else if (0 == LSTRCMPIS(szColHead, wszPROPCERTIFICATEISSUERNAMEID) ||
		     0 == LSTRCMPIS(szColHead, wszPROPCRLNAMEID))
	    {
                if (VT_I4 == varTmp.vt)   // don't be empty
                {
                    // sprint this into a buffer for display
                    CString cstrSprintVal;
                    cstrSprintVal.Format(L"V%u.%u", CANAMEIDTOICERT(varTmp.lVal), CANAMEIDTOIKEY(varTmp.lVal));
                    varCert.bstrVal = cstrSprintVal.AllocSysString();
		    varCert.vt = VT_BSTR;
		}
	    }

            if (varCert.vt != VT_BSTR)    // if this hasn't been converted yet
            {
                // default: conversion to string

                // returns localized string time (even for date!)
                VERIFY( MakeDisplayStrFromDBVariant(&varTmp, &varCert) ); // variant type change failed!?

                InplaceStripControlChars(varCert.bstrVal);
            }

            VariantClear(&varTmp);
        }
        else
        {
            hr = pCol->GetValue(CV_OUT_BINARY, &varCert);
            if (hr != S_OK)
                break;

            if (VT_EMPTY == varCert.vt)
            {
                hr = CERTSRV_E_PROPERTY_EMPTY;
                break;
            }
        }


        // finally, copy this value out to pb

        // copy, truncate if necessary
        DWORD cbTruncate = *pcbData;
        if (varCert.vt == VT_BSTR)
        {
            *pcbData = SysStringByteLen(varCert.bstrVal) + ((fStringFmt)? sizeof(WCHAR):0);
            CopyMemory(pbData, varCert.bstrVal, min(cbTruncate, *pcbData));
        }
        else if (varCert.vt == VT_I4)
        {
            *pcbData = sizeof(LONG);
            if (pbData != NULL)
                *(DWORD*)pbData = varCert.lVal;
        }
        else 
        {
            hr = E_INVALIDARG;
            break;
        }


    }while(0);

    VariantClear(&varCert);

    if (pCol)
        pCol->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\folders.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTMMC_FOLDERS_CPP__


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void CFolder::SetProperties(LPCWSTR szName, SCOPE_TYPES itemType,
                                FOLDER_TYPES type, int iChildren)
{
    // Set folder type 
    m_type = type;

    // Set scope
    m_itemType = itemType;


    // Add node name
    if (szName != NULL)
    {
        m_ScopeItem.mask |= SDI_STR;
    	m_ScopeItem.displayname = MMC_CALLBACK;
        
        UINT uiByteLen = (wcslen(szName) + 1) * sizeof(OLECHAR);
        LPOLESTR psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);
    
        if (psz != NULL)
        {
            wcscpy(psz, szName);
            m_pszName = psz;
        }
    }

    // Always tell view if we have children or not
    m_ScopeItem.mask |= SDI_CHILDREN;
    m_ScopeItem.cChildren = iChildren;
}

void CFolder::SetScopeItemInformation(int nImage, int nOpenImage)
{ 
    // Add close image
    m_ScopeItem.mask |= SDI_IMAGE;
    m_ScopeItem.nImage = nImage;

    // Add open image
    m_ScopeItem.mask |= SDI_OPENIMAGE;
    m_ScopeItem.nOpenImage = nOpenImage;
}

// IPersistStream interface members
HRESULT 
CFolder::Load(IStream *pStm)
{
    HRESULT hr;
    ASSERT(pStm);

    DWORD dwVer;
    CString cstr;
    int nImage;
    int nOpenImage;
    SCOPE_TYPES itemScopeType;
    FOLDER_TYPES itemFolderType;
    int iChildren;

    // load important properties
    hr = ReadOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Load dwVer");

    // check to see if correct version
    ASSERT(dwVer == VER_FOLDER_SAVE_STREAM_2 || dwVer == VER_FOLDER_SAVE_STREAM_1);
    if ((VER_FOLDER_SAVE_STREAM_2 != dwVer) && (dwVer != VER_FOLDER_SAVE_STREAM_1))
    {
        hr = STG_E_OLDFORMAT;
        _JumpError(hr, Ret, "Unsupported Version");
    }

    // LPCWSTR szName
    hr = CStringLoad(cstr, pStm);
    _JumpIfError(hr, Ret, "CStringLoad");

    hr = ReadOfSize(pStm, &nImage, sizeof(int));
    _JumpIfError(hr, Ret, "ReadOfSize nImage");

    hr = ReadOfSize(pStm, &nOpenImage, sizeof(int));
    _JumpIfError(hr, Ret, "ReadOfSize nOpenImage");

    hr = ReadOfSize(pStm, &itemScopeType, sizeof(SCOPE_TYPES));
    _JumpIfError(hr, Ret, "ReadOfSize itemScopeType");

    hr = ReadOfSize(pStm, &itemFolderType, sizeof(FOLDER_TYPES));
    _JumpIfError(hr, Ret, "ReadOfSize itemFolderType");

    hr = ReadOfSize(pStm, &iChildren, sizeof(int));
    _JumpIfError(hr, Ret, "ReadOfSize iChildren");

    // call create with this data
    SetProperties(cstr, itemScopeType, itemFolderType, iChildren);
    SetScopeItemInformation(nImage, nOpenImage);

    // old ver: pull out dead enumerator
    if (dwVer == VER_FOLDER_SAVE_STREAM_1)
    {
        CertViewRowEnum cRowEnum;
        hr = cRowEnum.Load(pStm);
        _JumpIfError(hr, Ret, "Load cRowEnum");
    }

Ret:

    return hr;
}

HRESULT
CFolder::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr;
    ASSERT(pStm);

    DWORD dwVer;
    CString cstr;


    // save important properties
    // Write the version
    dwVer = VER_FOLDER_SAVE_STREAM_2;
    hr = WriteOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "WriteOfSize dwVer");

    // LPCWSTR szName
    cstr = (LPCWSTR)m_pszName;
    hr = CStringSave(cstr, pStm, fClearDirty);
    _JumpIfError(hr, Ret, "CStringSave");

    // int nImage
    hr = WriteOfSize(pStm, &m_ScopeItem.nImage, sizeof(int));
    _JumpIfError(hr, Ret, "WriteOfSize nImage");

    // int nOpenImage
    hr = WriteOfSize(pStm, &m_ScopeItem.nOpenImage, sizeof(int));
    _JumpIfError(hr, Ret, "WriteOfSize nOpenImage");

    // SCOPE_TYPES itemType
    hr = WriteOfSize(pStm, &m_itemType, sizeof(SCOPE_TYPES));
    _JumpIfError(hr, Ret, "WriteOfSize m_itemType");

    // FOLDER_TYPES type
    hr = WriteOfSize(pStm, &m_type, sizeof(FOLDER_TYPES));
    _JumpIfError(hr, Ret, "WriteOfSize m_type");

    // int iChildren
    hr = WriteOfSize(pStm, &m_ScopeItem.cChildren, sizeof(int));
    _JumpIfError(hr, Ret, "WriteOfSize cChildren");

//    hr = m_RowEnum.Save(pStm, fClearDirty);
//    _JumpIfError(hr, Ret, "Save m_RowEnum");

Ret:

    return hr;
}

HRESULT
CFolder::GetSizeMax(int *pcbSize)
{
    ASSERT(pcbSize);
    int iSize;
    
    // version
    iSize = sizeof(DWORD);

    // LPCWSTR szName
    CString cstr = m_pszName;
    CStringGetSizeMax(cstr, &iSize);

    // int nImage
    iSize += sizeof(int);

    // int nOpenImage
    iSize += sizeof(int);

    // SCOPE_TYPES
    iSize += sizeof(SCOPE_TYPES);

    // FOLDER_TYPES
    iSize += sizeof(FOLDER_TYPES);

    // BOOL bHasChildren   (actually saved as int)
    iSize += sizeof(int);

//    int iAdditionalSize = 0;
//    m_RowEnum.GetSizeMax(&iAdditionalSize);
//    iSize += iAdditionalSize;

    *pcbSize = iSize;

    return S_OK;
}



BOOL IsAllowedStartStop(CFolder* pFolder, CertSvrMachine* pMachine)
{
    BOOL fRightPlace = (pFolder == NULL) || (SERVER_INSTANCE == pFolder->GetType());

    ASSERT(NULL != pMachine);

    // must be at right node and there must be CAs here
    return ( fRightPlace && (0 != pMachine->GetCaCount()) );
}


HRESULT GetCurrentColumnSchema(
            IN  LPCWSTR             szConfig, 
	    IN  BOOL                fCertView,
            OUT CString**           pprgcstrColumns, 
            OUT OPTIONAL LONG**     pprglTypes, 
            OUT OPTIONAL BOOL**     pprgfIndexed, 
            OUT LONG*               plEntries)
{
    HRESULT hr; 
    
    BOOL fGetTypes = pprglTypes != NULL;
    LONG* prglTypes = NULL;

    BOOL fGetIsIndexed = pprgfIndexed != NULL;
    BOOL* prgfIndexed = NULL;

    ICertView* pICertView = NULL;
    IEnumCERTVIEWCOLUMN* pColEnum = NULL;
    IEnumCERTVIEWROW *pRowEnum = NULL;

    BSTR bstrColumn = NULL;
    int colIdx=0;
    
    //LPWSTR* prgszCols = NULL;
    CString* prgcstrColumns = NULL;
    LONG lCols; 

    int i;

    hr = CoCreateInstance(
        CLSID_CCertView,
        NULL,		// pUnkOuter
        CLSCTX_INPROC_SERVER,
	fCertView? IID_ICertView : IID_ICertView2,
        (VOID **) &pICertView);
    _JumpIfError(hr, Ret, "CoCreateInstance");
    
    ASSERT(NULL != szConfig);
    hr = pICertView->OpenConnection(_bstr_t(szConfig));
    _JumpIfError(hr, Ret, "OpenConnection");

    if (!fCertView)
    {
	hr = ((ICertView2 *) pICertView)->SetTable(CVRC_TABLE_CRL);
	_JumpIfError(hr, Ret, "SetTable");
    }
    hr = pICertView->OpenView(&pRowEnum);
    _JumpIfError(hr, Ret, "OpenView");
    
    hr = pICertView->GetColumnCount(FALSE, &lCols);
    _JumpIfError(hr, Ret, "GetColumnCount");
    
    // we need a place to store each LPWSTR
    prgcstrColumns = new CString[lCols];
    _JumpIfOutOfMemory(hr, Ret, prgcstrColumns);

    if (fGetTypes)
    {   
        prglTypes = new LONG[lCols];
        _JumpIfOutOfMemory(hr, Ret, prglTypes);
    }

    if (fGetIsIndexed)
    {
        prgfIndexed = new BOOL[lCols];
        _JumpIfOutOfMemory(hr, Ret, prgfIndexed);
    }

    // get column enumerator
    hr = pICertView->EnumCertViewColumn(FALSE, &pColEnum);
    _JumpIfError(hr, Ret, "EnumCertViewColumn");
    
    
    for (i=0; i<lCols; i++)
    {
        hr = pColEnum->Next((LONG*)&colIdx);
        _JumpIfError(hr, Ret, "Next");

        hr = pColEnum->GetName(&bstrColumn);
        if (NULL == bstrColumn)
            hr = E_UNEXPECTED;
        _JumpIfError(hr, Ret, "GetName");

        prgcstrColumns[i] = bstrColumn;    // wcscpy

        if (fGetTypes)
        {   
            hr = pColEnum->GetType(&prglTypes[i]);
            _JumpIfError(hr, Ret, "GetType");
        }

        if (fGetIsIndexed)
        {
            hr = pColEnum->IsIndexed((LONG*)&prgfIndexed[i]);
            _JumpIfError(hr, Ret, "IsIndexed");
        }

        // next GetName call will free bstrColumn
        // SysFreeString(bstrColumn); 
        // bstrColumn = NULL;
    }
    

    // assign to out param
    if (fGetTypes)
    {
        *pprglTypes = prglTypes;
        prglTypes = NULL;
    }
    
    if (fGetIsIndexed)
    {
        *pprgfIndexed = prgfIndexed;
        prgfIndexed = NULL;
    }

    *pprgcstrColumns = prgcstrColumns;
    prgcstrColumns = NULL;

    *plEntries = lCols;

    hr = S_OK;
Ret:
    if (pICertView)
        pICertView->Release();

    if (pColEnum)
        pColEnum->Release();

    if (pRowEnum)
        pRowEnum->Release();

    if (bstrColumn)
        SysFreeString(bstrColumn);

    if (prglTypes)
        delete [] prglTypes;

    if (prgfIndexed)
        delete [] prgfIndexed;

    if (prgcstrColumns)
        delete [] prgcstrColumns;

    return hr;
}

// row operations
CertViewRowEnum::CertViewRowEnum()
{
    m_pICertView = NULL;
    m_fCertViewOpenAttempted = FALSE;

    m_pRowEnum = NULL;

    m_pRestrictions[0] = NULL;
    m_pRestrictions[1] = NULL;
    m_fRestrictionsActive[0] = FALSE;
    m_fRestrictionsActive[1] = FALSE;

    m_dwColumnCount = 0;
    m_prgColPropCache = NULL;

    m_dwErr = 0;
    m_fCertView = TRUE;

    InvalidateCachedRowEnum();
}

CertViewRowEnum::~CertViewRowEnum()
{
    InvalidateCachedRowEnum();
    FreeColumnCacheInfo();

    if (m_pICertView)
    {
        VERIFY(0 == m_pICertView->Release());
        m_pICertView = NULL; 
    }
    for (int i = 0; i < ARRAYSIZE(m_pRestrictions); i++)
    {
	if (m_pRestrictions[i])
	{
	    FreeQueryRestrictionList(m_pRestrictions[i]);
	    m_pRestrictions[i] = NULL;
	}
	m_fRestrictionsActive[i] = FALSE;
    }
}

HRESULT IsColumnShown(MMC_COLUMN_SET_DATA* pCols, ULONG idxCol, BOOL* pfShown)
{
    if (idxCol > (ULONG)pCols->nNumCols)
        return ERROR_INVALID_INDEX;

    *pfShown = (pCols->pColData[idxCol].dwFlags != HDI_HIDDEN);

    return S_OK;
}


HRESULT CountShownColumns(MMC_COLUMN_SET_DATA* pCols, ULONG* plCols)
{
    HRESULT hr = S_OK;
    *plCols = 0;

    // set col cache correctly
    for (int i=0; i<pCols->nNumCols; i++)
    {
        BOOL fShown;
        hr = IsColumnShown(pCols, i, &fShown);
        _JumpIfError(hr, Ret, "IsColumnShown");

        // update 
        if (fShown)
            (*plCols)++;
    }
Ret:
    return hr;
}


HRESULT CertViewRowEnum::Load(IStream *pStm)
{
    HRESULT hr;
    ASSERT(pStm);

    DWORD dwVer;
    DWORD iRestrictions;
    PQUERY_RESTRICTION pCurRestriction = NULL;
    DWORD iRestrictionNum;

    // load important properties
    hr = ReadOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "Load dwVer");
    
    // check to see if this is a supported version
    ASSERT((dwVer == VER_CERTVIEWROWENUM_SAVE_STREAM_3) || 
           (dwVer == VER_CERTVIEWROWENUM_SAVE_STREAM_4));
    if ((VER_CERTVIEWROWENUM_SAVE_STREAM_4 != dwVer) && 
        (VER_CERTVIEWROWENUM_SAVE_STREAM_3 != dwVer))
    {
        hr = STG_E_OLDFORMAT;
        _JumpError(hr, Ret, "dwVer");
    }

    // version-dependent: throw away sort order
    if (VER_CERTVIEWROWENUM_SAVE_STREAM_3 == dwVer)
    {
        LONG lSortOrder;
        CString cstrSortCol;

        ReadOfSize(pStm, &lSortOrder, sizeof(LONG));
        _JumpIfError(hr, Ret, "ReadOfSize lSortOrder");

        CStringLoad(cstrSortCol, pStm);
    }

    // fRestrictionsActive;
    hr = ReadOfSize(pStm, &m_fRestrictionsActive, sizeof(BOOL));
    _JumpIfError(hr, Ret, "ReadOfSize m_fRestrictionsActive");


    hr = ReadOfSize(pStm, &iRestrictions, sizeof(DWORD));
    _JumpIfError(hr, Ret, "ReadOfSize iRestrictions");

    for(iRestrictionNum=0; iRestrictionNum<iRestrictions; iRestrictionNum++)
    {
        // LPCWSTR szField
        CString cstr;
        UINT iOperation;
        VARIANT varValue;

        hr = CStringLoad(cstr, pStm);
        _JumpIfError(hr, Ret, "CStringLoad");

        // UINT iOperation
        hr = ReadOfSize(pStm, &iOperation, sizeof(int));
        _JumpIfError(hr, Ret, "ReadOfSize");

        // VARIANT varValue
        hr = VariantLoad(varValue, pStm);
        _JumpIfError(hr, Ret, "VariantLoad");

        // insert at end of list
        if (NULL == pCurRestriction)
        {
            // 1st restriction
            m_pRestrictions[1] = NewQueryRestriction((LPCWSTR)cstr, iOperation, &varValue);
            _JumpIfOutOfMemory(hr, Ret, m_pRestrictions[1]);

            pCurRestriction = m_pRestrictions[1];
        }
        else
        {
            pCurRestriction->pNext = NewQueryRestriction((LPCWSTR)cstr, iOperation, &varValue);
            _JumpIfOutOfMemory(hr, Ret, pCurRestriction->pNext);

            pCurRestriction = pCurRestriction->pNext;
        }
    }

    // version-dependent data: column sizes
    if (dwVer == VER_CERTVIEWROWENUM_SAVE_STREAM_3)
    {
        // now load column sizes (NOW DEFUNCT -- mmc saves for us)

        // number of cols DWORD dwColSize
        DWORD dwColSize;
        DWORD dwCol;
        LONG lViewType;

        hr = ReadOfSize(pStm, &dwColSize, sizeof(DWORD));
        _JumpIfError(hr, Ret, "ReadOfSize dwColSize");


        for(dwCol=0; dwCol<dwColSize; dwCol++)
        {
            // BOOL fValid
            BOOL fValid;
            int iSize;
            BOOL fUnLocColHead;

            hr = ReadOfSize(pStm, &fValid, sizeof(BOOL));
            _JumpIfError(hr, Ret, "ReadOfSize fValid");

            // int iSize
            hr = ReadOfSize(pStm, &iSize, sizeof(int));
            _JumpIfError(hr, Ret, "ReadOfSize iSize");

            // BOOL fUnLocColHead
            hr = ReadOfSize(pStm, &fUnLocColHead, sizeof(BOOL));
            _JumpIfError(hr, Ret, "ReadOfSize fUnLocColHead");

            // load only if exists
            if (fUnLocColHead)
            {
                CString cstrUnLocColHead;
                hr = CStringLoad(cstrUnLocColHead, pStm);
                _JumpIfError(hr, Ret, "CStringLoad");
            }
        }

        // view type
        hr = ReadOfSize(pStm, &lViewType, sizeof(LONG));
        _JumpIfError(hr, Ret, "ReadOfSize lViewType");

    } // version 3 data

Ret:

    return hr;
}

HRESULT CertViewRowEnum::Save(IStream *pStm, BOOL fClearDirty)
{
    ASSERT(pStm);
    HRESULT hr;

    DWORD dwVer;
    int iRestrictions = 0;
    PQUERY_RESTRICTION pRestrict;

    // save important properties

    // Write the version
    dwVer = VER_CERTVIEWROWENUM_SAVE_STREAM_4;
    hr = WriteOfSize(pStm, &dwVer, sizeof(DWORD));
    _JumpIfError(hr, Ret, "WriteOfSize dwVer");

    // BOOL fRestrictionsActive
    hr = WriteOfSize(pStm, &m_fRestrictionsActive, sizeof(BOOL));
    _JumpIfError(hr, Ret, "WriteOfSize m_fRestrictionsActive");


    // count restrictions
    pRestrict = m_pRestrictions[1];
    while(pRestrict)
    {
        iRestrictions++;
        pRestrict = pRestrict->pNext;
    }

    // int iRestrictions
    hr = WriteOfSize(pStm, &iRestrictions, sizeof(int));
    _JumpIfError(hr, Ret, "WriteOfSize iRestrictions");

    // write each restriction in turn
    pRestrict = m_pRestrictions[1];
    while(pRestrict)
    {
        // LPCWSTR szField
        CString cstr = pRestrict->szField;
        hr = CStringSave(cstr, pStm, fClearDirty);
        _JumpIfError(hr, Ret, "CStringSave");

        // UINT iOperation
        hr = WriteOfSize(pStm, &pRestrict->iOperation, sizeof(UINT));
        _JumpIfError(hr, Ret, "WriteOfSize iOperation");

        // VARIANT varValue
        hr = VariantSave(pRestrict->varValue, pStm, fClearDirty);
        _JumpIfError(hr, Ret, "VariantSave varValue");

        pRestrict = pRestrict->pNext;
    }

   
Ret:
    return hr;
}

HRESULT CertViewRowEnum::GetSizeMax(int *pcbSize)
{
    ASSERT(pcbSize);
    
    // version
    *pcbSize = sizeof(DWORD);

    // fRestrictionsActive
    *pcbSize += sizeof(BOOL);

    // iRestrictions
    *pcbSize += sizeof(int);

    // size each restriction
    PQUERY_RESTRICTION pRestrict = m_pRestrictions[1];
    while(pRestrict)
    {
        // LPCWSTR szField
        int iSize;
        CString cstr = pRestrict->szField;
        CStringGetSizeMax(cstr, &iSize);
        *pcbSize += iSize;
        
        // UINT iOperation        
        *pcbSize += sizeof(UINT);

        // VARIANT
        VariantGetSizeMax(pRestrict->varValue, &iSize);
        *pcbSize += iSize;
    }

    return S_OK;
}


HRESULT CertViewRowEnum::GetView(CertSvrCA* pCA, ICertView** ppView)
{
    HRESULT hr = S_OK;

    // if tried to get result 
    if (m_fCertViewOpenAttempted)
    {
        *ppView = m_pICertView;
        ASSERT(m_pICertView || m_dwErr);
        return (m_pICertView==NULL) ? m_dwErr : S_OK;
    }

    if (m_pICertView)
    {
        m_pICertView->Release();
        m_pICertView = NULL;
    }

    if (!pCA->m_pParentMachine->IsCertSvrServiceRunning())
    {
        *ppView = NULL;
        hr = RPC_S_NOT_LISTENING;
        _JumpError(hr, Ret, "IsCertSvrServiceRunning");
    }
    m_fCertViewOpenAttempted = TRUE;


    hr = CoCreateInstance(
		    CLSID_CCertView,
		    NULL,		// pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    g_fCertViewOnly? IID_ICertView : IID_ICertView2,
		    (VOID **) &m_pICertView);
    _JumpIfError(hr, Ret, "CoCreateInstance");

    ASSERT(NULL != pCA->m_bstrConfig);
    hr = m_pICertView->OpenConnection(pCA->m_bstrConfig);
    _JumpIfError(hr, Ret, "OpenConnection");
    
Ret:
    if (hr != S_OK)
    {
        if (m_pICertView)
        {
            m_pICertView->Release();
            m_pICertView = NULL;
        }
    }
    m_dwErr = hr;

    *ppView = m_pICertView;
    return hr;
}

HRESULT CertViewRowEnum::GetRowEnum(CertSvrCA* pCA, IEnumCERTVIEWROW**   ppRowEnum)
{
    if (m_fRowEnumOpenAttempted)
    {
        *ppRowEnum = m_pRowEnum;
        ASSERT(m_pRowEnum || m_dwErr);
        return (m_pRowEnum == NULL) ? m_dwErr : S_OK;
    }

    ASSERT(m_pRowEnum == NULL);
    ASSERT(m_idxRowEnum == -1);

    m_fRowEnumOpenAttempted = TRUE;

    HRESULT hr;
    ICertView* pView;

    hr = GetView(pCA, &pView);
    _JumpIfError(hr, Ret, "GetView");

    hr = pView->OpenView(&m_pRowEnum);
    _JumpIfError(hr, Ret, "OpenView");

Ret:
    *ppRowEnum = m_pRowEnum;
    m_dwErr = hr;

    return hr;
};


void CertViewRowEnum::InvalidateCachedRowEnum()
{
    if (m_pRowEnum)
    {
        m_pRowEnum->Release();
        m_pRowEnum = NULL;
    }

    m_idxRowEnum = -1;
    m_fRowEnumOpenAttempted = FALSE;

    // results
    m_fKnowNumResultRows = FALSE;
    m_dwResultRows = 0;
}

HRESULT CertViewRowEnum::ResetCachedRowEnum()
{   
    HRESULT hr = S_OK;

    if (m_pRowEnum)
    {   
        hr = m_pRowEnum->Reset(); 
        m_idxRowEnum = -1;
    }

    return hr;
};

HRESULT CertViewRowEnum::GetRowMaxIndex(CertSvrCA* pCA, LONG* pidxMax)
{
    HRESULT hr;
    IEnumCERTVIEWROW*   pRowEnum;   // don't have to free, just a ref to class member

    ASSERT(pidxMax);

    hr = GetRowEnum(pCA, &pRowEnum);
    _JumpIfError(hr, Ret, "GetRowEnum");


    hr = pRowEnum->GetMaxIndex(pidxMax);
    _JumpIfError(hr, Ret, "GetMaxIndex");

    // update max
    if (!m_fKnowNumResultRows)
    {
        m_dwResultRows = *pidxMax;
        m_fKnowNumResultRows = TRUE;
    }

Ret:
    return hr;
}

#if 0// DBG
void ReportMove(LONG idxCur, LONG idxDest, LONG skip)
{
    if ((idxDest == 0) && (skip == 0))
    {
        DBGPRINT((DBG_SS_CERTMMC, "Cur %i Dest 0 <RESET><NEXT>\n", idxCur));
        return;
    }

    DBGPRINT((DBG_SS_CERTMMC, "Cur %i Dest %i <SKIP %i><NEXT>\n", idxCur, idxDest, skip));
}
#else
#define ReportMove(_x_, _y_, _z_)
#endif

HRESULT CertViewRowEnum::SetRowEnumPos(LONG idxRow)
{   
    // make input ones-based

    // seek there smartly
    HRESULT hr;

    // already positioned correctly
    if (idxRow == m_idxRowEnum)
        return S_OK;

    // Next() could take awhile
    CWaitCursor cwait;

    ResetCachedRowEnum();
    hr = m_pRowEnum->Skip(idxRow);
    _JumpIfError(hr, Ret, "Skip");

    LONG lTmp;
    hr = m_pRowEnum->Next(&lTmp);
    if (hr != S_OK)
    {
        // ignore reentrance error in ICertView (bug 339811)
        if(hr != E_UNEXPECTED)
        {
            ResetCachedRowEnum();
        }

        _JumpError2(hr, Ret, "Next", S_FALSE);
    }

    // we should be successfully seeked to result row (ones-based)
    ASSERT(lTmp == idxRow+1);

    // else okay, we seeked correctly
    m_idxRowEnum = idxRow;

    // update max if necessary
    if (m_idxRowEnum+1 > (int)m_dwResultRows)
        m_dwResultRows = m_idxRowEnum+1;

Ret:
    // ignore reentrance error in ICertView (bug 339811)
    if(hr==E_UNEXPECTED)
    {
	hr = S_OK;
    }
    return hr;


};


// DB Column Property Caches
void CertViewRowEnum::FreeColumnCacheInfo()
{
    if (m_prgColPropCache)
    {
        LocalFree(m_prgColPropCache);
        m_prgColPropCache = NULL;
    }
    m_dwColumnCount = 0;
}

HRESULT CertViewRowEnum::SetColumnCacheInfo(
            IN int iIndex,         // db col
            IN int     idxViewCol) // 0...X
{
    if (m_dwColumnCount <= (DWORD)iIndex)
        return HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);

    m_prgColPropCache[iIndex].iViewCol = idxViewCol;
    return S_OK;
}

HRESULT CertViewRowEnum::GetColumnCacheInfo(
            int     iIndex,        // 0..x
            int*    piViewIndex)   // db col
{
    if (m_dwColumnCount <= (DWORD)iIndex)
        return HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);

    // don't let uninitialized elements get through
    if (m_prgColPropCache[iIndex].iViewCol == -1)
    {
        // Handle mmc bug:
        // This is commonly caused by race condition between time
        // we get an MMCN_COLUMNS_CHANGED for a col removal and the 
        // listview asking to update the removed column. AnandhaG knows about
        // this bug.

        // so that we don't fail the whole view, just go on about your business

        DBGPRINT((DBG_SS_CERTMMC, "GetColumnCacheInfo error: unknown dbcol = %i\n", iIndex));
        return HRESULT_FROM_WIN32(ERROR_CONTINUE);
    }

    if (piViewIndex)
        *piViewIndex = m_prgColPropCache[iIndex].iViewCol;

    return S_OK;
}


// This is a destructive operation, and resets EVERYTHING about the column cache
HRESULT CertViewRowEnum::ResetColumnCount(LONG lCols)
{
    HRESULT hr = S_OK;

    if ((DWORD)lCols != m_dwColumnCount)
    {
        void* pvNewAlloc;

        // for view properties
        if (m_prgColPropCache)
            pvNewAlloc = LocalReAlloc(m_prgColPropCache, sizeof(COLUMN_TYPE_CACHE)*lCols, LMEM_MOVEABLE);
        else
            pvNewAlloc = LocalAlloc(LMEM_FIXED, sizeof(COLUMN_TYPE_CACHE)*lCols);
        if (NULL == pvNewAlloc)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, Ret, "Local(Re)Alloc");
        }

        m_prgColPropCache = (COLUMN_TYPE_CACHE*)pvNewAlloc;
        m_dwColumnCount = lCols;
    }

    // initialize with -1s -- invalidate cache
    FillMemory(m_prgColPropCache, m_dwColumnCount * sizeof(COLUMN_TYPE_CACHE), 0xff);

Ret:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\folders.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _FOLDERS_H
#define _FOLDERS_H


/////////////////////
// File Versions
// current version
// removal of m_RowEnum
#define VER_FOLDER_SAVE_STREAM_2        0x2
                  
// B3 version
#define VER_FOLDER_SAVE_STREAM_1        0x1
/////////////////////

/////////////////////
// File Versions
// current version
// removal of column sizes, sort order info, view type
#define VER_CERTVIEWROWENUM_SAVE_STREAM_4 0x4

// this version (written prior through Win2000 B3) includes column sizes
#define VER_CERTVIEWROWENUM_SAVE_STREAM_3 0x3
/////////////////////



// Forward declarations
class CSnapin;
class CFolder;
class CertSvrCA;
class CertSvrMachine;


struct RESULT_DATA
{
    SCOPE_TYPES itemType; 
    CFolder*    pParentFolder;

    DWORD       cStringArray;
    LPWSTR      szStringArray[3];   // name, size, type
};
enum 
{
    RESULTDATA_ARRAYENTRY_NAME =0,
    RESULTDATA_ARRAYENTRY_SIZE,
    RESULTDATA_ARRAYENTRY_TYPE,
};

HRESULT IsColumnShown(MMC_COLUMN_SET_DATA* pCols, ULONG idxCol, BOOL* pfShown);
HRESULT CountShownColumns(MMC_COLUMN_SET_DATA* pCols, ULONG* plCols);

//////////////////////////////////////////////////////////////////////////
// COLUMN TYPE cache
//
// This cache holds data that populated while setting column headings.
// The data applies to the column view, not the database view.
// Caching here allows an easy type-check during a compare() call, etc.

typedef struct _COLUMN_TYPE_CACHE
{
    // volatile members
    int     iViewCol;

} COLUMN_TYPE_CACHE;


class CertViewRowEnum
{
protected: 

    // View Interface
    ICertView*          m_pICertView;
    BOOL                m_fCertViewOpenAttempted;

    // Row Enum
    IEnumCERTVIEWROW*   m_pRowEnum;
    LONG                m_idxRowEnum;
    BOOL                m_fRowEnumOpenAttempted;

    // Query Restrictions
    PQUERY_RESTRICTION  m_pRestrictions[2];
    BOOL                m_fRestrictionsActive[2];

    // Column property cache
    COLUMN_TYPE_CACHE*  m_prgColPropCache;
    DWORD               m_dwColumnCount;

    DWORD               m_dwErr;

public:
    CertViewRowEnum();
    virtual ~CertViewRowEnum();

public:
    BOOL                m_fKnowNumResultRows;
    DWORD               m_dwResultRows;
    BOOL		m_fCertView;

public:
    HRESULT GetLastError() { return m_dwErr; }

    // View Interface
    HRESULT GetView(CertSvrCA* pCA, ICertView** ppView);
    void    ClearCachedCertView()
        {   m_fCertViewOpenAttempted = FALSE;    }

    // Row Enum
    HRESULT GetRowEnum(CertSvrCA* pCA, IEnumCERTVIEWROW**   ppRowEnum);
    HRESULT GetRowMaxIndex(CertSvrCA* pCA, LONG* pidxMax);

    LONG    GetRowEnumPos()   {   return m_idxRowEnum; }
    HRESULT SetRowEnumPos(LONG idxRow);
   
    HRESULT ResetCachedRowEnum();        // back to 0th row
    void    InvalidateCachedRowEnum();   // refresh

    // Query Restrictions
    void SetQueryRestrictions(PQUERY_RESTRICTION pQR, int i)
        {   if (m_pRestrictions[i]) 
                FreeQueryRestrictionList(m_pRestrictions[i]);
            m_pRestrictions[i] = pQR;
        }
    PQUERY_RESTRICTION GetQueryRestrictions(int i)
        {   return m_pRestrictions[i];  }
    BOOL FAreQueryRestrictionsActive(int i)
        {   return m_fRestrictionsActive[i]; }
    void SetQueryRestrictionsActive(BOOL fRestrict, int i)
        {   m_fRestrictionsActive[i] = fRestrict; }


    HRESULT ResetColumnCount(LONG lCols);
    LONG GetColumnCount()
        {   return m_dwColumnCount; }
    
    // DB Column property cache
    void FreeColumnCacheInfo();
    
    HRESULT GetColumnCacheInfo(
        IN int iIndex, 
        OUT OPTIONAL int* pidxViewCol);

    // sets column width by heading
    HRESULT SetColumnCacheInfo(
        IN int iIndex,
        IN int idxViewCol);

public:
// IPersistStream interface members
    HRESULT Load(IStream *pStm);
    HRESULT Save(IStream *pStm, BOOL fClearDirty);
    HRESULT GetSizeMax(int *pcbSize);

};


class CFolder 
{
    SCOPE_TYPES  m_itemType;    // Used for debug purposes. This should be the first 
                                // member. The class should not have any virtual fuctions.

    friend class CSnapin;
    friend class CComponentDataImpl;

public:
    CFolder()
    { 
        m_itemType = UNINITIALIZED_ITEM;  
        m_cookie = UNINITIALIZED;       // invalid memory address -- good cookie initializer
        m_enumed = FALSE; 
        m_type = NONE;
        m_pszName = NULL;

        m_pCertCA = NULL;

        ZeroMemory(&m_ScopeItem, sizeof(SCOPEDATAITEM));
    }

    ~CFolder() 
    { 
        if (m_pszName) 
            CoTaskMemFree(m_pszName); 
    }

// Interface
public:
    BOOL IsEnumerated() { return  m_enumed; }
    void Set(BOOL state) { m_enumed = state; }
    void SetCookie(MMC_COOKIE cookie) { m_cookie = cookie; }
    void SetScopeItemInformation(int nImage, int nOpenImage);

    FOLDER_TYPES GetType() { ASSERT(m_type != NONE); return m_type; }
    CertSvrCA* GetCA() { ASSERT(m_pCertCA != NULL); return m_pCertCA; }
    BOOL operator == (const CFolder& rhs) const { return rhs.m_cookie == m_cookie; }
    BOOL operator == (MMC_COOKIE cookie) const { return cookie == m_cookie; }
    LPCWSTR GetName() { return m_pszName; }
    void SetName(LPWSTR pszIn) 
    { 
        UINT len = wcslen(pszIn) + 1;
        LPWSTR psz = (LPWSTR)CoTaskMemAlloc(len * sizeof(WCHAR));
        if (psz != NULL)
        {
            wcscpy(psz, pszIn);
            CoTaskMemFree(m_pszName);
            m_pszName = psz;
        }
    }

// IPersistStream interface members
    HRESULT Load(IStream *pStm);
    HRESULT Save(IStream *pStm, BOOL fClearDirty);
    HRESULT GetSizeMax(int *pcbSize);

// Implementation
private:
    void SetProperties(
                LPCWSTR szName, 
                SCOPE_TYPES itemType,
                FOLDER_TYPES type, 
                int iChildren = 0);

// Attributes
private:
    SCOPEDATAITEM   m_ScopeItem;
    MMC_COOKIE      m_cookie;
    BOOL            m_enumed;
    FOLDER_TYPES    m_type;
    LPOLESTR        m_pszName;

    CertSvrCA*      m_pCertCA;
};

BOOL IsAllowedStartStop(CFolder* pFolder, CertSvrMachine* pMachine);
HRESULT GetCurrentColumnSchema(
            IN  LPCWSTR             szConfig, 
	    IN  BOOL                fCertView,
            OUT CString**           pprgcstrColumns, 
            OUT OPTIONAL LONG**     pprglTypes, 
            OUT OPTIONAL BOOL**     pprgfIndexed, 
            OUT LONG*               plEntries);


#endif  // _FOLDERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\genpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       genpage.h
//
//--------------------------------------------------------------------------

// genpage.h : header file
//

#define SERVERSETTINGS_PROPPAGE_GENERAL 0x1
#define SERVERSETTINGS_PROPPAGE_POLICY  0x2
#define SERVERSETTINGS_PROPPAGE_EXIT    0x4
#define SERVERSETTINGS_PROPPAGE_STORAGE 0x8
#define SERVERSETTINGS_PROPPAGE_KRA     0x10

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage dialog
#include "chooser.h"
#include "csw97ppg.h"
#include "urls.h"
#include "officer.h"
#include "roles.h"

//////////////////////////////
// hand-hewn pages
class CSvrSettingsGeneralPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE1 };

// Construction
public:
	CSvrSettingsGeneralPage(CertSvrCA* pCA, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsGeneralPage();

// Dialog Data
    CString m_cstrCAName;
    CString m_cstrOrg;
    CString m_cstrDescription;
    CString m_cstrProvName;
    CString m_cstrHashAlg;


// Overrides
    public:
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
	void OnDestroy();
	void OnEditChange();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	void OnViewCert(HWND hwnd);
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

public:
    
    void NeedServiceRestart(WORD wPage) { m_fRestartServer = TRUE; m_wRestart |= wPage; }
    void TryServiceRestart(WORD wPage);

    void SetAllocedSecurityInfo(LPSECURITYINFO pToBeReleased) {m_pReleaseMe = pToBeReleased; }

    LONG_PTR        m_hConsoleHandle; // Handle given to the snap-in by the console
    CertSvrCA*  m_pCA;

private:
    BOOL    m_bUpdate;
    BOOL    m_fRestartServer;
    WORD    m_wRestart;

	BOOL	m_fWin2kCA;

    LPSECURITYINFO m_pReleaseMe;
    ICertAdmin2 *m_pAdmin;
};

class CSvrSettingsPolicyPage : public CAutoDeletePropPage, public CRolesSupportInPropPage
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE2 };

    static RoleAccessToControl sm_ControlToRoleMap[];

// Construction
public:
	CSvrSettingsPolicyPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsPolicyPage();

// Dialog Data
    CString m_cstrModuleName;
    CString m_cstrModuleDescr;
    CString m_cstrModuleVersion;
    CString m_cstrModuleCopyright;

    BOOL   m_fLoadedActiveModule;

    LPOLESTR m_pszprogidPolicyModule;
    CLSID  m_clsidPolicyModule;

// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
	void OnDestroy();
    void OnSetActiveModule();
    void OnConfigureModule();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    HRESULT GetCurrentModuleProperties();

public:
    CSvrSettingsGeneralPage* m_pControlPage;

private:
    BOOL    m_bUpdate;

};

// everything you could want to describe a policy/exit module
typedef struct _COM_CERTSRV_MODULEDEFN
{
    LPOLESTR    szModuleProgID;
    CLSID       clsidModule;
} COM_CERTSRV_MODULEDEFN, *PCOM_CERTSRV_MODULEDEFN;

class CSvrSettingsExitPage : public CAutoDeletePropPage, public CRolesSupportInPropPage
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE3 };
    static RoleAccessToControl sm_ControlToRoleMap[];

// Construction
public:
	CSvrSettingsExitPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsExitPage();

// Dialog Data
    CString m_cstrModuleName;
    CString m_cstrModuleDescr;
    CString m_cstrModuleVersion;
    CString m_cstrModuleCopyright;

    BOOL   m_fLoadedActiveModule;
    int    m_iSelected;


    CArray<COM_CERTSRV_MODULEDEFN, COM_CERTSRV_MODULEDEFN> m_arrExitModules;

// Overrides
    public:
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    void OnDestroy();

    BOOL UpdateSelectedModule();

    void OnAddActiveModule();
    void OnRemoveActiveModule();

    void OnConfigureModule();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);


    HRESULT InitializeExitLB();
public:
    CSvrSettingsGeneralPage* m_pControlPage;
private:
    BOOL m_bUpdate;
};

typedef struct _EXTENSIONWIZ_DATA
{
    int          idExtensionName;  //resource id of extension name
    int          idExtensionExplain;//resource id of extension explaination
    int          idCheckboxText; // resource id of 'include in...' checkbox text
    int          idCheckboxText2; // resource id of 'OCSP' vs. 'publish Deltas here' chkbox text
    WCHAR       *wszRegName;       //value name in registry
    DWORD        dwFlagsMask;      //flag mask of compatible bits
    CSURLTEMPLATENODE *pURLList;   //list of url templates
} EXTENSIONWIZ_DATA;

class CSvrSettingsExtensionPage : public CAutoDeletePropPage, public CRolesSupportInPropPage
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE4 };
    static RoleAccessToControl sm_ControlToRoleMap[];

// Construction
public:
	CSvrSettingsExtensionPage(
        CertSvrCA                *pCA,
        CSvrSettingsGeneralPage *pControlPage,
        UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsExtensionPage();

// Dialog Data

// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    virtual BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

    virtual void OnHelp(LPHELPINFO lpHelp);
    virtual void OnContextHelp(HWND hwnd);


// Implementation
protected:
	void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    CSvrSettingsGeneralPage* m_pControlPage;
private:
    void UpdateURLFlags(
             IN EXTENSIONWIZ_DATA *pExt,
             IN OPTIONAL CSURLTEMPLATENODE *pURLNode);
    void UpdateURLFlagControl(
             IN int                idCtrl,
             IN DWORD              dwFlag,
             IN EXTENSIONWIZ_DATA *pExt,
             IN CSURLTEMPLATENODE *pURLNode);
    void OnExtensionChange();
    void OnURLChange();
    void OnURLCopy();
    void OnFlagChange(DWORD dwFlag);
    BOOL OnURLRemove();
    BOOL OnURLAdd();
    CSURLTEMPLATENODE *GetCurrentURL(LRESULT *pnIndex);
    EXTENSIONWIZ_DATA *GetCurrentExtension();

    BOOL    m_bUpdate;
    LRESULT m_nIndexReset;
    EXTENSIONWIZ_DATA *m_pExtData;  // point to array of extensions
};


class CSvrSettingsStoragePage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE5 };

// Construction
public:
	CSvrSettingsStoragePage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsStoragePage();

// Dialog Data
    CString m_cstrDatabasePath;
    CString m_cstrLogPath;
    CString m_cstrSharedFolder;


// Overrides
	public:
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

public:
    CSvrSettingsGeneralPage* m_pControlPage;
private:
    BOOL    m_bUpdate;
};


typedef struct _KRA_NODE
{
    CERT_CONTEXT const *pCert;
    DWORD dwDisposition;
    DWORD               dwFlags;
    struct _KRA_NODE   *next;
} KRA_NODE;

class CSvrSettingsKRAPage : public CAutoDeletePropPage, public CRolesSupportInPropPage 
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE_CHOOSE_KRA };
    static RoleAccessToControl sm_ControlToRoleMap[];

// Construction
public:
	CSvrSettingsKRAPage(
        CertSvrCA                *pCA,
        CSvrSettingsGeneralPage*  pControlPage,
        UINT                      uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsKRAPage();

// Dialog Data

// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    static LPCWSTR MapDispositionToString(DWORD dwDisp);

// Implementation
protected:
	void OnDestroy();
    void OnAddKRA();
    void OnRemoveKRA();
    void OnViewKRA();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    void EnableKRARemoveViewListButtons(BOOL fEnabled);
    void EnableKRAAddListButton(BOOL fEnabled);
    void EnableKRARadioButtons(BOOL fMoreThanZero);
    void EnableKRAListView(BOOL fEnabled);
    void EnableKRAEdit(BOOL fEnabled);
    void UpdateKRARadioControls();
    void LoadKRADispositions();
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
    HRESULT SaveKRAList(ICertAdmin2 *pAdmin);
    HRESULT LoadKRAList(ICertAdmin2 *pAdmin);
    bool IsCurrentItemValidCert();

public:
    CSvrSettingsGeneralPage* m_pControlPage;

private:
    BOOL        m_fDirty;
    BOOL        m_fArchiveKey;
    BOOL        m_fCountUpdate;
    BOOL        m_fKRAUpdate;
    KRA_NODE   *m_pKRAList; //list of KRAs
    DWORD       m_dwKRAUsedCount;
    DWORD       m_dwKRACount;

    static CString m_strDispositions[];
};


/////////////////////////////////////////
// CCRLPropPage
class CCRLPropPage : public CAutoDeletePropPage, public CRolesSupportInPropPage  
{
public:
    enum { IID_DEFAULT = IDD_CRL_PROPPAGE };
    static RoleAccessToControl sm_ControlToRoleMap[];

// Construction
public:
	CCRLPropPage(CertSvrCA* pCA, UINT uIDD = IID_DEFAULT);
	virtual ~CCRLPropPage();

// Dialog Data
    CString   m_cstrPublishPeriodCount;
    CComboBox m_cboxPublishPeriodString;
    CString   m_cstrLastCRLPublish;
//    int       m_iNoAutoPublish;

    CString   m_cstrDeltaPublishPeriodCount;
    CComboBox m_cboxDeltaPublishPeriodString;
    CString   m_cstrDeltaLastCRLPublish;
    int       m_iDeltaPublish;


// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
	void OnDestroy();
	void OnEditChange();
    void OnCheckBoxChange(BOOL fDisableBaseCRL);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    void GetDeltaNextPublish();

public:
    LONG_PTR        m_hConsoleHandle; // Handle given to the snap-in by the console

private:
    BOOL    m_bUpdate;
};


/////////////////////////////////////////
// CCRLViewPage
class CCRLViewPage : public CAutoDeletePropPage 
{
public:
    enum { IID_DEFAULT = IDD_CRL_VIEWPAGE };

// Construction
public:
	CCRLViewPage(CCRLPropPage* pControlPage, UINT uIDD = IID_DEFAULT);

	virtual ~CCRLViewPage();

// Dialog Data


// Overrides

public:
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    void OnViewCRL(BOOL fViewBaseCRL);
    void OnSelectCRL(BOOL fBaseCRL);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    void OnDestroy();
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

public:
    CCRLPropPage* m_pControlPage;

};


typedef struct _BACKUPWIZ_STATE
{
    CertSvrCA* pCA;

    BOOL    fBackupKeyCert;
    BOOL    fBackupLogs;
    BOOL    fIncremental;

    LPWSTR  szLogsPath;

    LPWSTR  szPassword;
} BACKUPWIZ_STATE, *PBACKUPWIZ_STATE;


/////////////////////////////////////////
// CBackupWizPage
class CBackupWizPage1 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_BACKUPWIZ_WELCOME };

// Construction
public:
    CBackupWizPage1(PBACKUPWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);
    ~CBackupWizPage1();

// Dialog Data


// Overrides
    public:
    virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PBACKUPWIZ_STATE m_pState;

    CWizard97PropertySheet* m_pParentSheet;
};
/////////////////////////////////////////
// CBackupWizPage2
class CBackupWizPage2 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_BACKUPWIZ_SELECT_DATA};

// Construction
public:
	CBackupWizPage2(PBACKUPWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data
    CString m_cstrLogsPath;
    int m_iKeyCertCheck;
    int m_iLogsCheck;
    int m_iIncrementalCheck;
    BOOL m_fIncrementalAllowed;

// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    void OnBrowse();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    HRESULT ConvertLogsPathToFullPath();

public:
    PBACKUPWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};

/////////////////////////////////////////
// CBackupWizPage3
class CBackupWizPage3 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_BACKUPWIZ_SELECT_PASSWORD};

// Construction
public:
	CBackupWizPage3(PBACKUPWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data
    CString m_cstrPwd;
    CString m_cstrPwdVerify;


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PBACKUPWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};

/////////////////////////////////////////
// CBackupWizPage5
class CBackupWizPage5 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_BACKUPWIZ_COMPLETION };

// Construction
public:
	CBackupWizPage5(PBACKUPWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PBACKUPWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};



typedef struct _RESTOREWIZ_STATE
{
    CertSvrCA* pCA;

    BOOL    fRestoreKeyCert;
    LPWSTR  szKeyCertPath;

    LPWSTR  szConfigPath;

    BOOL    fRestoreLogs;
    LPWSTR  szLogsPath;

    LPWSTR  szPassword;

    BOOL    fIncremental;

} RESTOREWIZ_STATE, *PRESTOREWIZ_STATE;


/////////////////////////////////////////
// CRestoreWizPage
class CRestoreWizPage1 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_RESTOREWIZ_WELCOME };

// Construction
public:
    CRestoreWizPage1(PRESTOREWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);
    ~CRestoreWizPage1();

// Dialog Data


// Overrides
    public:
    virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PRESTOREWIZ_STATE m_pState;

    CWizard97PropertySheet* m_pParentSheet;
};
/////////////////////////////////////////
// CRestoreWizPage2
class CRestoreWizPage2 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_RESTOREWIZ_SELECT_DATA};

// Construction
public:
	CRestoreWizPage2(PRESTOREWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data
    CString m_cstrLogsPath;
    int m_iKeyCertCheck;
    int m_iLogsCheck;


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    void OnBrowse();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PRESTOREWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};

/////////////////////////////////////////
// CRestoreWizPage3
class CRestoreWizPage3 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_RESTOREWIZ_SELECT_PASSWORD};

// Construction
public:
	CRestoreWizPage3(PRESTOREWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data
    CString m_cstrPwd;


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PRESTOREWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};

/////////////////////////////////////////
// CRestoreWizPage5
class CRestoreWizPage5 : public CWizard97PropertyPage
{
public:
    enum { IID_DEFAULT = IDD_RESTOREWIZ_COMPLETION };

// Construction
public:
	CRestoreWizPage5(PRESTOREWIZ_STATE pState, CWizard97PropertySheet *pcDlg, UINT uIDD = IID_DEFAULT);

// Dialog Data


// Overrides
    public:
    virtual BOOL OnInitDialog();
    virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    PRESTOREWIZ_STATE m_pState;
    CWizard97PropertySheet* m_pParentSheet;
};


/////////////////////////////////////////
// CViewAttrib 
class CViewAttrib : public CAutoDeletePropPage
{
    enum { IID_DEFAULT = IDD_ATTR_PROPPAGE };

public:
    CViewAttrib(UINT uIDD = IID_DEFAULT);

// Dialog Data

// Overrides
    public:
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:

            IEnumCERTVIEWATTRIBUTE* m_pAttr;
};

/////////////////////////////////////////
// CViewExtn 
class CViewExtn : public CAutoDeletePropPage
{
    enum { IID_DEFAULT = IDD_EXTN_PROPPAGE };

public:
    CViewExtn(UINT uIDD = IID_DEFAULT);
    ~CViewExtn();


// Dialog Data

// Overrides
    public:
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    void OnReselectItem();

public:
            IEnumCERTVIEWEXTENSION* m_pExtn;

    CArray<CString*, CString*> m_carrExtnValues;
};

/////////////////////////////////////////
// CSvrSettingsCertManagersPage
class CSvrSettingsCertManagersPage : public CAutoDeletePropPage, public CRolesSupportInPropPage 
{
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE6 };
    static RoleAccessToControl sm_ControlToRoleMap[];

public:
	CSvrSettingsCertManagersPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
    ~CSvrSettingsCertManagersPage();


// Dialog Data

// Overrides
    public:
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

// Implementation
protected:
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
	void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    void OnAddSubject();
    void OnRemoveSubject();
    void OnOfficerListSelChange(DWORD dwIndexSelected);
    void OnAllowDeny();
    void OnEnableOfficers(bool fEnable);
    void OnOfficerChange();
    void SetDirty()
    {
        SendMessage (GetParent(), PSM_CHANGED, (WPARAM) m_hWnd, 0);
        m_fDirty = TRUE;
    }
    void ClearDirty() { m_fDirty = FALSE; }
    BOOL IsDirty() { return m_fDirty; }

    HRESULT BrowseForSubject(HWND hwnd, PSID &rpSid);
    HRESULT GetOfficerRights();
    HRESULT SetOfficerRights();
    HRESULT BuildVirtualOfficerRights();
    void FillOfficerList();
    void FillClientList(DWORD dwOfficerIndex);
    void SetAllowDeny();
    void EnableControls();

    DWORD GetCurrentOfficerIndex()
    {
        LRESULT lSel = SendMessage(
            GetDlgItem(m_hWnd, IDC_LIST_CERTMANAGERS), 
            CB_GETCURSEL,
            0, 
            0);
        return (CB_ERR == lSel) ? 0 : (DWORD)lSel;
    }

    DWORD GetCurrentClientIndex()
    {
        LRESULT lSel = ListView_GetNextItem(
            GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS), -1, LVNI_SELECTED);

        return (-1==lSel) ? 0 : (DWORD)lSel;
    }

    CSvrSettingsGeneralPage* m_pControlPage;
    CertSrv::COfficerRightsList m_OfficerRightsList;
    BOOL m_fEnabled;
    BOOL m_fDirty;
    static CString m_strButtonAllow;
    static CString m_strButtonDeny;
    static CString m_strTextAllow; 
    static CString m_strTextDeny;

};

/////////////////////////////////////////
// CSvrSettingsAuditFilterPage
class CSvrSettingsAuditFilterPage : public CAutoDeletePropPage, public CRolesSupportInPropPage  
{
public:
    enum { IID_DEFAULT = IDD_CERTSRV_PROPPAGE7 };
    static RoleAccessToControl sm_ControlToRoleMap[];

// Construction
public:
	CSvrSettingsAuditFilterPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD = IID_DEFAULT);
	virtual ~CSvrSettingsAuditFilterPage();

// Overrides
	public:
	virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    HRESULT GetAuditFilter();
    HRESULT SetAuditFilter();

// Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    HRESULT GetAuditFilterDCOM();
    HRESULT GetAuditFilterRegistry();
    HRESULT SetAuditFilterDCOM();
    HRESULT SetAuditFilterRegistry();

public:
    CSvrSettingsGeneralPage* m_pControlPage;
private:
    BOOL    m_fDirty;
    DWORD   m_dwFilter;

    static int m_iCheckboxID[];
};


// Wizard pages
DWORD PublishCRLWizard(CertSvrCA* pCertCA, HWND hwnd);

DWORD CertAdminRevokeCert(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lReason, LPWSTR szCertSerNum);
DWORD CertAdminResubmitRequest(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lRequestID);
DWORD CertAdminDenyRequest(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lRequestID);

DWORD CABackupWizard(CertSvrCA* pCertCA, HWND hwnd);
DWORD CARestoreWizard(CertSvrCA* pCertCA, HWND hwnd);
DWORD CARequestInstallHierarchyWizard(CertSvrCA* pCertCA, HWND hwnd, BOOL fRenewal, BOOL fAttemptRestart);

// misc dialogs
DWORD ModifyQueryFilter(HWND hwnd, CertViewRowEnum* pRowEnum, CComponentDataImpl* pCompData, int i);
DWORD GetUserConfirmRevocationReason(LONG* plReasonCode, HWND hwnd);

DWORD ViewRowAttributesExtensions(HWND hwnd, IEnumCERTVIEWATTRIBUTE* pAttr, IEnumCERTVIEWEXTENSION* pExtn, LPCWSTR szReqID);
DWORD ViewRowRequestASN(HWND hwnd, LPCWSTR szTempFileName, PBYTE pbReq, DWORD cbReq, IN BOOL fSaveToFile);

DWORD ChooseBinaryColumnToDump(IN HWND hwnd, IN CComponentDataImpl* pComp, OUT LPCWSTR* pcwszColumn, OUT BOOL* pfSaveToFileOnly);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       misc.cpp
//
//--------------------------------------------------------------------------
#include <stdafx.h>
#include <float.h>
#include "certsrv.h"
#include "misc.h"
#include "clibres.h"
#include "setupids.h"
#include "csresstr.h"
#include <activeds.h>
#include <dsgetdc.h>
#include <lm.h>
#include <common.ver>
#include "urls.h"
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTMMC_MISC_CPP__


bool operator==(
    const struct _QUERY_RESTRICTION& lhs,
    const struct _QUERY_RESTRICTION& rhs)
{
    return 
        0==_wcsicmp(lhs.szField, rhs.szField) &&
        lhs.iOperation==rhs.iOperation &&
        variant_t(&lhs.varValue)==variant_t(&rhs.varValue);
}

PQUERY_RESTRICTION QueryRestrictionFound(
    PQUERY_RESTRICTION pQR, 
    PQUERY_RESTRICTION pQRListHead)
{
    while(pQRListHead)
    {
        if(*pQR==*pQRListHead)
            return pQRListHead;
        pQRListHead = pQRListHead->pNext;
    }
    return NULL;
}

// returns (if cstr.IsEmpty()) ? NULL : cstr)
LPCWSTR GetNullMachineName(CString* pcstr)
{
    LPCWSTR     szMachine = (pcstr->IsEmpty()) ? NULL : (LPCWSTR)*pcstr;
    return szMachine;
}

BOOL FIsCurrentMachine(LPCWSTR str)
{
    BOOL fIsCurrentMachine = FALSE;
    LPWSTR szName1 = NULL, szName2 = NULL;
    DWORD dwErr;

    dwErr = myGetComputerNames(&szName1, &szName2);
    _JumpIfError(dwErr, error, "myGetComputerNames");

    if ((str != NULL) && 
        (wcslen(str) > 2) &&
        (str[0] == '\\')  &&
        (str[1] == '\\') )
        str = &str[2];  // skip whackwhack

    // if machine specified as not current machine
    if ( (NULL == str) || 
         (str[0] == '\0') ||
         (0 == mylstrcmpiL(str, szName1)) ||
         (0 == mylstrcmpiL(str, szName2)) )
        fIsCurrentMachine = TRUE;

error:

    if (szName1)
        LocalFree(szName1);
    if (szName2)
        LocalFree(szName2);

    return fIsCurrentMachine;
}



/////////////////////////////////////////
// fxns to load/save cstrings to a streams
STDMETHODIMP CStringLoad(CString& cstr, IStream *pStm)
{
    ASSERT(pStm);
    HRESULT hr;

    DWORD cbSize=0;

    // get cbSize (bytes)
    hr = ReadOfSize(pStm, &cbSize, sizeof(cbSize));
    _JumpIfError(hr, Ret, "ReadOfSize cbSize");

    // get string
    hr = ReadOfSize(
        pStm, 
        cstr.GetBuffer(cbSize/sizeof(WCHAR)-1), // less terminator, GetBuffer adds 1 for it
        cbSize);
    
    cstr.ReleaseBuffer(); // not clear why we do this...

    _JumpIfError(hr, Ret, "Read cstr.GetBuffer");

    if(!cstr.IsZeroTerminated())
    {
        hr = ERROR_FILE_CORRUPT;
        _JumpError(hr, Ret, "zero terminated string expected");
    }

Ret:
    return hr;
}

STDMETHODIMP
CStringSave(
    CString& cstr,
    IStream *pStm,
    BOOL /* fClearDirty */ )
{
    ASSERT(pStm);
    HRESULT hr;

    // Write the string (null cstr will return 0 chars, output nullstr "")
    DWORD cbSize = (cstr.GetLength()+1)*sizeof(WCHAR);

    // write size in bytes
    hr = WriteOfSize(pStm, &cbSize, sizeof(cbSize));
    _JumpIfError(hr, error, "WriteOfSize cbSize");


    // write string (null cstr will return 0 chars, output nullstr "")
    hr = WriteOfSize(pStm, (LPWSTR)(LPCWSTR)cstr, cbSize);
    _JumpIfError(hr, error, "Write cstr");

error:
    return hr;
}

STDMETHODIMP CStringGetSizeMax(CString& cstr, int* piSize)
{
    *piSize = sizeof(DWORD);
    *piSize += (cstr.GetLength()+1)* sizeof(WCHAR);

    return S_OK;
}

STDMETHODIMP VariantLoad(VARIANT& var, IStream *pStm)
{
    HRESULT hr;
    VARIANT varTmp;
    DWORD dwSize;

    VariantInit(&varTmp);
    VariantInit(&var);

    // get target variant type
    hr = ReadOfSize(pStm, &var.vt, sizeof(var.vt));
    _JumpIfError(hr, error, "Read type");

    // get cb
    hr = ReadOfSize(pStm, &dwSize, sizeof(DWORD));
    _JumpIfError(hr, error, "Read cb");

    varTmp.vt = VT_BSTR;
    varTmp.bstrVal = SysAllocStringByteLen(NULL, dwSize);
    _JumpIfOutOfMemory(hr, error, varTmp.bstrVal);

    // get pb
    hr = ReadOfSize(pStm, varTmp.bstrVal, dwSize);
    _JumpIfError(hr, error, "Read pb");

    // change type to target type var.vt
    hr = VariantChangeType(&var, &varTmp, 0, var.vt);
    _JumpIfError(hr, error, "VariantChangeType");

error:
    VariantClear(&varTmp);

    return hr;
}

STDMETHODIMP
VariantSave(
    VARIANT& var,
    IStream *pStm,
    BOOL /* fClearDirty */ )
{
    HRESULT hr;
    DWORD dwSize;

    VARIANT varTmp;
    VariantInit(&varTmp);

    // write variant type
    hr = WriteOfSize(pStm, &var.vt, sizeof(var.vt));
    _JumpIfError(hr, error, "Write type");

    // convert to bstr
    hr = VariantChangeType(&varTmp, &var, 0, VT_BSTR);
    _JumpIfError(hr, error, "VariantChangeType");

    // write cb
    dwSize = SysStringByteLen(varTmp.bstrVal);
    hr = WriteOfSize(pStm, &dwSize, sizeof(DWORD));
    _JumpIfError(hr, error, "Write cb");
    
    // write pb
    hr = WriteOfSize(pStm, varTmp.bstrVal, dwSize);
    _JumpIfError(hr, error, "Write pb");

error:
    VariantClear(&varTmp);

    return hr;
}

STDMETHODIMP VariantGetSizeMax(VARIANT& var, int* piSize)
{
    HRESULT hr;

    VARIANT varTmp;
    VariantInit(&varTmp);

    // write var type, cb
    *piSize = sizeof(var.vt) + sizeof(DWORD);

    // write pb len: convert to bstr
    hr = VariantChangeType(&varTmp, &var, 0, VT_BSTR);
    _JumpIfError(hr, error, "VariantChangeType");

    *piSize += SysStringByteLen(varTmp.bstrVal);
    
error:
    VariantClear(&varTmp);

    return hr;
}

DWORD AllocAndReturnConfigValue(HKEY hKey, LPCWSTR szConfigEntry, PBYTE* ppbOut, DWORD* pcbOut, DWORD* pdwType)
{
    DWORD dwRet;

    dwRet = RegQueryValueExW(
            hKey,
            szConfigEntry,
            NULL,
            pdwType,
            NULL,
            pcbOut);
    _JumpIfError(dwRet, Ret, "RegQueryValueExW");

    ASSERT(ppbOut != NULL);
    *ppbOut = new BYTE[*pcbOut];
    if (NULL == *ppbOut)
    {
	dwRet = (DWORD) E_OUTOFMEMORY;
	_JumpError(dwRet, Ret, "new");
    }
 
    dwRet = RegQueryValueExW(
            hKey,
            szConfigEntry,
            NULL,
            pdwType,
            *ppbOut,
            pcbOut);
    if (dwRet != ERROR_SUCCESS)
    {
        delete [] *ppbOut;
        *ppbOut = NULL;
        _JumpError(dwRet, Ret, "RegQueryValueExW");
    }
Ret:

    return dwRet;
}




//////////////////////////////////////////////////////////////////
// given an error code and a console pointer, will pop error dlg
void DisplayCertSrvErrorWithContext(HWND hwnd, DWORD dwErr, UINT iRscContext)
{
    CString cstrContext;
    cstrContext.LoadString(iRscContext);

    DisplayCertSrvErrorWithContext(hwnd, dwErr, (LPCWSTR)cstrContext);
}

void DisplayCertSrvErrorWithContext(HWND hwnd, DWORD dwErr, LPCWSTR szContext)
{
    CString cstrTitle, cstrFullText;
    cstrTitle.LoadString(IDS_MSG_TITLE);

    cstrFullText = szContext;

    if (dwErr != ERROR_SUCCESS)
    {
        if (!cstrFullText.IsEmpty())
            cstrFullText += L"\n\n";

	WCHAR const *pwszError = myGetErrorMessageText(dwErr, TRUE);

        cstrFullText += pwszError;

        // Free the buffer
        if (NULL != pwszError)
	{
            LocalFree(const_cast<WCHAR *>(pwszError));
	}
    }

    ::MessageBoxW(hwnd, cstrFullText, cstrTitle, 
        MB_OK|
        (S_OK!=dwErr?MB_ICONERROR:MB_ICONINFORMATION));
}

void DisplayGenericCertSrvError(HWND hwnd, DWORD dwErr)
{
    DisplayCertSrvErrorWithContext(hwnd, dwErr, (UINT)0);
}

void DisplayGenericCertSrvError(LPCONSOLE pConsole, DWORD dwErr)
{
    ASSERT(pConsole);

    WCHAR const *pwszError = myGetErrorMessageText(dwErr, TRUE);

    // ...
    // Display the string.
    CString cstrTitle;
    cstrTitle.LoadString(IDS_MSG_TITLE);
    pConsole->MessageBoxW(pwszError, cstrTitle, MB_OK, NULL);
    
    // Free the buffer.
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
}

enum ENUM_PERIOD DurationEnumFromNonLocalizedString(LPCWSTR szPeriod)
{
    if (0 == LSTRCMPIS(szPeriod, wszPERIODYEARS))
        return ENUM_PERIOD_YEARS;
    if (0 == LSTRCMPIS(szPeriod, wszPERIODMONTHS))
        return ENUM_PERIOD_MONTHS;
    if (0 == LSTRCMPIS(szPeriod, wszPERIODWEEKS))
        return ENUM_PERIOD_WEEKS;
    if (0 == LSTRCMPIS(szPeriod, wszPERIODDAYS))
        return ENUM_PERIOD_DAYS;
    if (0 == LSTRCMPIS(szPeriod, wszPERIODHOURS))
        return ENUM_PERIOD_HOURS;
    if (0 == LSTRCMPIS(szPeriod, wszPERIODMINUTES))
        return ENUM_PERIOD_MINUTES;
    if (0 == LSTRCMPIS(szPeriod, wszPERIODSECONDS))
        return ENUM_PERIOD_SECONDS;

    return ENUM_PERIOD_INVALID;
}

BOOL StringFromDurationEnum(int iEnum, CString* pcstr, BOOL fLocalized)
{
    if (NULL == pcstr)
        return FALSE;

    switch (iEnum) 
    {
    case(ENUM_PERIOD_YEARS):
        if (fLocalized)
            *pcstr = g_pResources->m_szPeriod_Years;
        else
            *pcstr = wszPERIODYEARS;
        break;
    case(ENUM_PERIOD_MONTHS):
        if (fLocalized)
            *pcstr = g_pResources->m_szPeriod_Months;
        else
            *pcstr = wszPERIODMONTHS;
        break;
    case(ENUM_PERIOD_WEEKS):
        if (fLocalized)
            *pcstr = g_pResources->m_szPeriod_Weeks;
        else
            *pcstr = wszPERIODWEEKS;
        break;
    case(ENUM_PERIOD_DAYS):
        if (fLocalized)
            *pcstr = g_pResources->m_szPeriod_Days;
        else
            *pcstr = wszPERIODDAYS;
        break;
    case(ENUM_PERIOD_HOURS):
        if (fLocalized)
            *pcstr = g_pResources->m_szPeriod_Hours;
        else
            *pcstr = wszPERIODHOURS;
        break;
    case(ENUM_PERIOD_MINUTES):
        if (fLocalized)
            *pcstr = g_pResources->m_szPeriod_Minutes;
        else
            *pcstr = wszPERIODMINUTES;
        break;
    case(ENUM_PERIOD_SECONDS):
        if (fLocalized)
            *pcstr = g_pResources->m_szPeriod_Seconds;
        else
            *pcstr = wszPERIODSECONDS;
        break;
    }

    if (! (pcstr->IsEmpty()) )
        return TRUE;

    return FALSE;
}

LPCWSTR OperationToStr(int iOperation)
{
    switch(iOperation)
    {
    case CVR_SEEK_EQ:
        return L"=";
    case CVR_SEEK_LT:
        return L"<";
    case CVR_SEEK_LE:
        return L"<=";
    case CVR_SEEK_GE:
        return L">=";
    case CVR_SEEK_GT:
        return L">";
    }
    
    return NULL;
}

int StrToOperation(LPCWSTR  szOperation)
{
    if      (0 == wcscmp(szOperation, L"="))
        return CVR_SEEK_EQ;
    else if (0 == wcscmp(szOperation, L"<"))
        return CVR_SEEK_LT;
    else if (0 == wcscmp(szOperation, L"<="))
        return CVR_SEEK_LE;
    else if (0 == wcscmp(szOperation, L">="))
        return CVR_SEEK_GE;
    else if (0 == wcscmp(szOperation, L">"))
        return CVR_SEEK_GT;

    return 0;
}

// returns localized string time (even for date!)
BOOL MakeDisplayStrFromDBVariant(VARIANT* pvt, VARIANT* pvOut)
{
    HRESULT hr;
    VariantInit(pvOut);
    LPWSTR szLocalTime = NULL;

    ASSERT(pvt);
    ASSERT(pvOut);
    if ((NULL == pvt) || (NULL == pvOut))
        return FALSE;

    if (pvt->vt == VT_DATE)
    {
        hr = myGMTDateToWszLocalTime(
				&pvt->date,
				FALSE,
				&szLocalTime);
        _JumpIfError(hr, error, "myGMTDateToWszLocalTime");
        
        pvOut->bstrVal = ::SysAllocString(szLocalTime);
        _JumpIfOutOfMemory(hr, error, pvOut->bstrVal);

        pvOut->vt = VT_BSTR;
    }
    else
    {
        hr = VariantChangeType(pvOut, pvt, 0, VT_BSTR);
        _JumpIfError(hr, error, "VariantChangeType");
    }

error:
    if (szLocalTime)
        LocalFree(szLocalTime);

    return (pvOut->vt == VT_BSTR);
}


DWORD CryptAlgToStr(CString* pcstrAlgName, LPCWSTR szProv, DWORD dwProvType, DWORD dwAlg)
{
    DWORD dwRet;
    HCRYPTPROV hCrypt = NULL;
    DWORD Flags = CRYPT_FIRST;
    DWORD cb;
    PROV_ENUMALGS Alg;
    
    pcstrAlgName->Empty();

    if (!CryptAcquireContext(
            &hCrypt, 
            NULL,
            szProv, 
            dwProvType,
            CRYPT_VERIFYCONTEXT))
    {
        dwRet = GetLastError();
        _JumpError(dwRet, Ret, "CryptAcquireContext");
    }

    while (TRUE)
    {
        cb = sizeof(Alg);
        if (!CryptGetProvParam(hCrypt, PP_ENUMALGS, (BYTE *) &Alg, &cb, Flags))
                 break;

        if (Alg.aiAlgid == dwAlg)
        {
            *pcstrAlgName = Alg.szName;
             break;
        }
    	Flags = 0;
    }

    dwRet = ERROR_SUCCESS;
Ret:

    if (hCrypt)
        CryptReleaseContext(hCrypt, 0);

    return dwRet;
}




LPCWSTR FindUnlocalizedColName(LPCWSTR strColumn)
{
    HRESULT hr = S_OK;
    LPCWSTR szTrial = NULL;

    for(DWORD dwIndex=0; (S_OK == hr); dwIndex++)
    {
        hr = myGetColumnName(
            dwIndex,
            FALSE,      // unlocalized
            &szTrial);
        _PrintIfError(hr, "myGetColumnName");
        
        if ((S_OK == hr) && (NULL != szTrial))
        {
            if (0 == wcscmp(strColumn, szTrial))
                return szTrial;
        }
    }
    
    return NULL;
}




// given field, op, variant, copies into data struct
PQUERY_RESTRICTION NewQueryRestriction(LPCWSTR szField, UINT iOp, VARIANT* pvarValue)
{
    DWORD dwLen = sizeof(QUERY_RESTRICTION);
    dwLen += WSZ_BYTECOUNT(szField);

    PQUERY_RESTRICTION pNew = (QUERY_RESTRICTION*)LocalAlloc(LPTR, dwLen);
    if (NULL == pNew)
        return NULL;

    PBYTE pCurWrite = ((PBYTE)pNew) + sizeof(QUERY_RESTRICTION) ;
    pNew->szField = (LPWSTR)pCurWrite;
    wcscpy(pNew->szField, szField);

    pNew->iOperation = iOp;

    // copy data pointed to by pvarValue
    CopyMemory(&pNew->varValue, pvarValue, sizeof(VARIANT));

    // good enough except for string -- alloc for it
    if (VT_BSTR == pvarValue->vt)
    {
        pNew->varValue.bstrVal = SysAllocString(pvarValue->bstrVal);
        if (NULL == pNew->varValue.bstrVal)
        {
            // failed!
            FreeQueryRestriction(pNew);
            pNew = NULL;
        }
    }

    return pNew;
}

void FreeQueryRestriction(PQUERY_RESTRICTION pQR)
{
    VariantClear(&pQR->varValue);
    LocalFree(pQR);
}

void FreeQueryRestrictionList(PQUERY_RESTRICTION pQR)
{
    PQUERY_RESTRICTION pTmp;
    while(pQR)
    {   
        pTmp = pQR->pNext;
        FreeQueryRestriction(pQR);
        pQR = pTmp;
    }
}


void ListInsertAtEnd(void** ppList, void* pElt)
{
    if (pElt != NULL)
    {
    
    // he's always at the end of the list
    ((PELT_PTR)pElt)->pNext = NULL;
    void* pCurPtr = *ppList;

    if (*ppList == NULL)
    {
        *ppList = pElt;
    }
    else
    {
        while( ((PELT_PTR)pCurPtr)->pNext != NULL )
        {
            pCurPtr = ((PELT_PTR)pCurPtr)->pNext;
        }

        ((PELT_PTR)pCurPtr)->pNext = (PELT_PTR) pElt;
    }
    }

    return;
}


// dwIndex should be zero at first, then passed in for each consecutive call
LPWSTR RegEnumKeyContaining(
    HKEY hBaseKey,
    LPCWSTR szContainsString, 
    DWORD* pdwIndex)
{
    HRESULT hr = S_OK;
    LPWSTR szBuf = NULL;
    DWORD cbBuf = 0, cbBufUsed;
    FILETIME ft;
    
    ASSERT(pdwIndex);


    hr = RegQueryInfoKey(
        hBaseKey,
        NULL,
        NULL,   // classes
        NULL,   // reserved
        NULL,   // cSubkeys
        &cbBuf, // maxsubkeylen in chars (not counting null term)
        NULL,   // max class len
        NULL,   // num values
        NULL,   // max value name len
        NULL,   // max value len
        NULL,   // sec descr
        NULL    // last filetime
        );
    _JumpIfError(hr, Ret, "RegQueryInfoKey");

    cbBuf += 1;
    cbBuf *= sizeof(WCHAR);
    szBuf = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf);
    _JumpIfOutOfMemory(hr, Ret, szBuf);


    for (; ; (*pdwIndex)++)
    {
        // tell api how much memory we have (incl NULL char)
        cbBufUsed = cbBuf;

        hr = RegEnumKeyEx(
            hBaseKey, 
            *pdwIndex, 
            szBuf, 
            &cbBufUsed,    // doesn't get updated in small buffer case?!
            NULL, 
            NULL, 
            NULL, 
            &ft);
        _JumpIfError2(hr, Ret, "RegEnumKeyEx", ERROR_NO_MORE_ITEMS);
        
        // we have data, check if it is one we're interested in
        if (NULL != wcsstr(szBuf, szContainsString))
            break;
    }

    // don't point at this one again
    (*pdwIndex)++;
    hr = S_OK;

Ret:
    if (S_OK != hr)
    {
        LocalFree(szBuf);
        szBuf = NULL;
    }

    return ( szBuf );
}



DISPLAYSTRING_EXPANSION g_displayStrings[11] =
{
    { wszFCSAPARM_SERVERDNSNAME,            IDS_TOKEN_SERVERDNSNAME,        IDS_TOKENDESC_SERVERDNSNAME         },       //%1
    { wszFCSAPARM_SERVERSHORTNAME,          IDS_TOKEN_SERVERSHORTNAME,      IDS_TOKENDESC_SERVERSHORTNAME       },     //%2
    { wszFCSAPARM_SANITIZEDCANAME,          IDS_TOKEN_SANITIZEDCANAME,      IDS_TOKENDESC_SANITIZEDCANAME       },     //%3
    { wszFCSAPARM_CERTFILENAMESUFFIX,       IDS_TOKEN_CERTFILENAMESUFFIX,   IDS_TOKENDESC_CERTFILENAMESUFFIX    },  //%4
    { L"",                                  IDS_DESCR_UNKNOWN,              IDS_DESCR_UNKNOWN }, // %5 not available 
    { wszFCSAPARM_CONFIGDN,                 IDS_TOKEN_CONFIGDN,             IDS_TOKENDESC_CONFIGDN              },            //%6
    { wszFCSAPARM_SANITIZEDCANAMEHASH,      IDS_TOKEN_SANITIZEDCANAMEHASH,  IDS_TOKENDESC_SANITIZEDCANAMEHASH   }, //%7
    { wszFCSAPARM_CRLFILENAMESUFFIX,        IDS_TOKEN_CRLFILENAMESUFFIX,    IDS_TOKENDESC_CRLFILENAMESUFFIX     },   //%8
    { wszFCSAPARM_CRLDELTAFILENAMESUFFIX,   IDS_TOKEN_CRLDELTAFILENAMESUFFIX,IDS_TOKENDESC_CRLDELTAFILENAMESUFFIX},  //%9
    { wszFCSAPARM_DSCRLATTRIBUTE,           IDS_TOKEN_DSCRLATTRIBUTE,       IDS_TOKENDESC_DSCRLATTRIBUTE        },      //%10
    { wszFCSAPARM_DSCACERTATTRIBUTE,        IDS_TOKEN_DSCACERTATTRIBUTE,    IDS_TOKENDESC_DSCACERTATTRIBUTE     },   //%11
};



/////////////////////////////////////////
// fxns to load resources automatically
CLocalizedResources *g_pResources = NULL;

CLocalizedResources::CLocalizedResources()
{
    m_fLoaded = FALSE;
}

BOOL CLocalizedResources::Load()
{
    if (!m_fLoaded)
    {
        HINSTANCE hRsrc = AfxGetResourceHandle();

	myVerifyResourceStrings(g_hInstance);

        // Load strings from resources
        m_ColumnHead_Name.LoadString(IDS_COLUMN_NAME);             
        m_ColumnHead_Size.LoadString(IDS_COLUMN_SIZE);             
        m_ColumnHead_Type.LoadString(IDS_COLUMN_TYPE);             
        m_ColumnHead_Description.LoadString(IDS_COLUMN_DESCRIPTION);

        m_DescrStr_CA.LoadString(IDS_DESCR_CA);
        m_DescrStr_Unknown.LoadString(IDS_DESCR_UNKNOWN);

        m_szFilterApplied.LoadString(IDS_STATUSBAR_FILTER_APPLIED);
        m_szSortedAscendingTemplate.LoadString(IDS_STATUSBAR_SORTEDBY_ASCEND);
        m_szSortedDescendingTemplate.LoadString(IDS_STATUSBAR_SORTEDBY_DESCEND);
        m_szStoppedServerMsg.LoadString(IDS_STOPPED_SERVER_MSG);
        m_szStatusBarErrorFormat.LoadString(IDS_STATUSBAR_ERRORTEMPLATE);

        m_szRevokeReason_Unspecified.LoadString(IDS_CRL_REASON_UNSPECIFIED);
        m_szRevokeReason_KeyCompromise.LoadString(IDS_CRL_REASON_KEY_COMPROMISE);
        m_szRevokeReason_CaCompromise.LoadString(IDS_CRL_REASON_CA_COMPROMISE);
        m_szRevokeReason_Affiliation.LoadString(IDS_CRL_REASON_AFFILIATION_CHANGED);
        m_szRevokeReason_Superseded.LoadString(IDS_CRL_REASON_SUPERSEDED);
        m_szRevokeReason_Cessatation.LoadString(IDS_CRL_REASON_CESSATION_OF_OPERATION);
        m_szRevokeReason_CertHold.LoadString(IDS_CRL_REASON_CERTIFICATE_HOLD);
        m_szRevokeReason_RemoveFromCRL.LoadString(IDS_CRL_REASON_REMOVE_FROM_CRL);

        m_szPeriod_Seconds.LoadString(IDS_PERIOD_SECONDS);
        m_szPeriod_Minutes.LoadString(IDS_PERIOD_MINUTES);
        m_szPeriod_Hours.LoadString(IDS_PERIOD_HOURS);  
        m_szPeriod_Days.LoadString(IDS_PERIOD_DAYS);
        m_szPeriod_Weeks.LoadString(IDS_PERIOD_WEEKS);
        m_szPeriod_Months.LoadString(IDS_PERIOD_MONTHS);
        m_szPeriod_Years.LoadString(IDS_PERIOD_YEARS);

        m_szYes.LoadString(IDS_YES);

        // Load the bitmaps from the dll
        m_bmpSvrMgrToolbar1.LoadBitmap(IDB_TOOLBAR_SVRMGR1);

        // load view strings to struct members, point to struct members
        int i;

        // viewResult items
        for(i=0; ((viewResultItems[i].item.strName != NULL) && (viewResultItems[i].item.strStatusBarText != NULL)); i++)
        {
            LoadString(hRsrc, viewResultItems[i].uiString1, viewResultItems[i].szString1, ARRAYSIZE(viewResultItems[i].szString1));
            viewResultItems[i].item.strName = viewResultItems[i].szString1;

            LoadString(hRsrc, viewResultItems[i].uiString2, viewResultItems[i].szString2, ARRAYSIZE(viewResultItems[i].szString2));
            viewResultItems[i].item.strStatusBarText = viewResultItems[i].szString2;
        }
        
        // taskResultItemsSingleSel
        for(i=0; ((taskResultItemsSingleSel[i].myitem.item.strName != NULL) && (taskResultItemsSingleSel[i].myitem.item.strStatusBarText != NULL)); i++)
        {
            LoadString(hRsrc, taskResultItemsSingleSel[i].myitem.uiString1, taskResultItemsSingleSel[i].myitem.szString1, ARRAYSIZE(taskResultItemsSingleSel[i].myitem.szString1));
            taskResultItemsSingleSel[i].myitem.item.strName = taskResultItemsSingleSel[i].myitem.szString1;

            LoadString(hRsrc, taskResultItemsSingleSel[i].myitem.uiString2, taskResultItemsSingleSel[i].myitem.szString2, ARRAYSIZE(taskResultItemsSingleSel[i].myitem.szString2));
            taskResultItemsSingleSel[i].myitem.item.strStatusBarText = taskResultItemsSingleSel[i].myitem.szString2;
        }

        // task start/stop
        for(i=0; ((taskStartStop[i].item.strName != NULL) && (taskStartStop[i].item.strStatusBarText != NULL)); i++) 
        {
            LoadString(hRsrc, taskStartStop[i].uiString1, taskStartStop[i].szString1, ARRAYSIZE(taskStartStop[i].szString1));
            taskStartStop[i].item.strName = taskStartStop[i].szString1;

            LoadString(hRsrc, taskStartStop[i].uiString2, taskStartStop[i].szString2, ARRAYSIZE(taskStartStop[i].szString2));
            taskStartStop[i].item.strStatusBarText = taskStartStop[i].szString2;
        }

        // taskitems
        for(i=0; ((taskItems[i].myitem.item.strName != NULL) && (taskItems[i].myitem.item.strStatusBarText != NULL)); i++)
        {
            LoadString(hRsrc, taskItems[i].myitem.uiString1, taskItems[i].myitem.szString1, ARRAYSIZE(taskItems[i].myitem.szString1));
            taskItems[i].myitem.item.strName = taskItems[i].myitem.szString1;

            LoadString(hRsrc, taskItems[i].myitem.uiString2, taskItems[i].myitem.szString2, ARRAYSIZE(taskItems[i].myitem.szString2));
            taskItems[i].myitem.item.strStatusBarText = taskItems[i].myitem.szString2;
        }

        // topitems
        for(i=0; ((topItems[i].myitem.item.strName != NULL) && (topItems[i].myitem.item.strStatusBarText != NULL)); i++)
        {
            LoadString(hRsrc, topItems[i].myitem.uiString1, topItems[i].myitem.szString1, ARRAYSIZE(topItems[i].myitem.szString1));
            topItems[i].myitem.item.strName = topItems[i].myitem.szString1;

            LoadString(hRsrc, topItems[i].myitem.uiString2, topItems[i].myitem.szString2, ARRAYSIZE(topItems[i].myitem.szString2));
            topItems[i].myitem.item.strStatusBarText = topItems[i].myitem.szString2;
        }

        for (i=0; ((SvrMgrToolbar1Buttons[i].item.lpButtonText != NULL) && (SvrMgrToolbar1Buttons[i].item.lpTooltipText != NULL)); i++)
        {
            LoadString(hRsrc, SvrMgrToolbar1Buttons[i].uiString1, SvrMgrToolbar1Buttons[i].szString1, ARRAYSIZE(SvrMgrToolbar1Buttons[i].szString1));
            SvrMgrToolbar1Buttons[i].item.lpButtonText = SvrMgrToolbar1Buttons[i].szString1;

            LoadString(hRsrc, SvrMgrToolbar1Buttons[i].uiString2, SvrMgrToolbar1Buttons[i].szString2, ARRAYSIZE(SvrMgrToolbar1Buttons[i].szString2));
            SvrMgrToolbar1Buttons[i].item.lpTooltipText = SvrMgrToolbar1Buttons[i].szString2;
        }

	// load replacement tokens
        for (i=0; i<DISPLAYSTRINGS_TOKEN_COUNT; i++)
        {
            g_displayStrings[i].pcstrExpansionString = new CString;
            if (g_displayStrings[i].pcstrExpansionString != NULL)
                g_displayStrings[i].pcstrExpansionString->LoadString(g_displayStrings[i].uTokenID);

            g_displayStrings[i].pcstrExpansionStringDescr = new CString;
            if (g_displayStrings[i].pcstrExpansionStringDescr != NULL)
                g_displayStrings[i].pcstrExpansionStringDescr->LoadString(g_displayStrings[i].uTokenDescrID);
        }

        m_fLoaded = TRUE;
    }

    return m_fLoaded;
}

CLocalizedResources::~CLocalizedResources()
{
    m_fLoaded = FALSE;

    for (int i=0; i<DISPLAYSTRINGS_TOKEN_COUNT; i++)
    {
        if (g_displayStrings[i].pcstrExpansionString)
            delete g_displayStrings[i].pcstrExpansionString;

        if (g_displayStrings[i].pcstrExpansionStringDescr)
            delete g_displayStrings[i].pcstrExpansionStringDescr;
    }

}

HRESULT ReadOfSize(IStream* pStm, void* pbData, ULONG cbData)
{
    HRESULT hr; 
    ULONG nBytesRead;
    hr = pStm->Read(pbData, cbData, &nBytesRead);
    if ((hr == S_OK) && (nBytesRead != cbData))
        hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
    return hr;        
}

HRESULT WriteOfSize(IStream* pStm, void* pbData, ULONG cbData)
{
    HRESULT hr; 
    ULONG nBytesWritten;
    hr = pStm->Write(pbData, cbData, &nBytesWritten);
    if ((hr == S_OK) && (nBytesWritten != cbData))
        hr = HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL);
    return hr;        
}


HRESULT
myOIDToName(
    IN WCHAR const *pwszObjId,
    OUT LPWSTR*     pszName)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszName1 = L"";
    WCHAR const *pwszName2;
    WCHAR *pwszT = NULL;
    WCHAR rgwchName[64];
    
    if (pszName == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pszName NULL");
    }

    pwszT = (LPWSTR) LocalAlloc(LMEM_FIXED, (1 + 1 + wcslen(pwszObjId)) * sizeof(WCHAR));
    if (NULL == pwszT)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "no memory for skip counts array");
    }
    wcscpy(&pwszT[1], pwszObjId);
    
    *pwszT = L'+';
    pwszName1 = myGetOIDName(pwszT);	// Group OID lookup
    
    *pwszT = L'-';
    pwszName2 = myGetOIDName(pwszT);	// Generic OID lookup
    
    if (0 == mylstrcmpiL(pwszName1, pwszName2))
    {
        pwszName2 = L"";		// display only one if they're the same
    }
    if (L'\0' == *pwszName1)
    {
        pwszName1 = pwszName2;
        pwszName2 = L"";
    }
    
    if (L'\0' != *pwszName2 &&
        ARRAYSIZE(rgwchName) > wcslen(pwszName1) + wcslen(pwszName2) + 3)
    {
        wcscpy(rgwchName, pwszName1);
        wcscat(rgwchName, L" " wszLPAREN);
        wcscat(rgwchName, pwszName2);
        wcscat(rgwchName, wszRPAREN);
        pwszName1 = rgwchName;
    }

    *pszName = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(pwszName1)+1)*sizeof(WCHAR));
    if (NULL == *pszName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "pszName");
    }
    wcscpy(*pszName, pwszName1);
    
error:
    if (NULL != pwszT)
    {
    	LocalFree(pwszT);
    }

    return hr;
}

#include "csdisp.h"

HRESULT
myDumpFormattedObject(
    IN WCHAR const *pwszObjId,
    IN BYTE const *pbObject,
    IN DWORD cbObject,
    OUT LPWSTR* ppwszFormatted)
{
    HRESULT hr = S_OK;
    char * pszObjId = NULL;
    DWORD cbFormatted;

    if (ppwszFormatted == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL param");
    }
    
    if (!ConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToSz");
    }

    // format the object using the installed formatting function
    if (!CryptFormatObject(
        X509_ASN_ENCODING,
        0,
        CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
        NULL,
        pszObjId,
        pbObject,
        cbObject,
        NULL,
        &cbFormatted))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "CryptFormatObject");
    }
    
    *ppwszFormatted = (WCHAR *) LocalAlloc(LMEM_FIXED, cbFormatted);
    if (NULL == *ppwszFormatted)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    
    if (!CryptFormatObject(
        X509_ASN_ENCODING,
        0,
        CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
        NULL,
        pszObjId,
        pbObject,
        cbObject,
        *ppwszFormatted,
        &cbFormatted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptFormatObject");
    }

    /*
    if (g_fVerbose)
    {
        if (0 == strcmp(szOID_SUBJECT_ALT_NAME, pszObjId) ||
            0 == strcmp(szOID_SUBJECT_ALT_NAME2, pszObjId) ||
            0 == strcmp(szOID_ISSUER_ALT_NAME, pszObjId) ||
            0 == strcmp(szOID_ISSUER_ALT_NAME2, pszObjId))
        {
            DumpAltName(pbObject, cbObject);
        }
    }
    */
error:
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr || CRYPT_E_ASN1_BADTAG == hr)
    {
        // fix up nonfatal errors
        CString cstrUnknown;
        cstrUnknown.LoadString(IDS_UNKNOWN_EXTENSION);
        hr = myDupString((LPCWSTR)cstrUnknown, ppwszFormatted);
        _PrintIfError(hr, "myDupString failure");
    }

    if (pszObjId)
        LocalFree(pszObjId);

    return hr;
}

void 
InplaceStripControlChars(WCHAR* szString)
{
   // remove \r and \n AND \t formatting through end-of-string
   if (NULL != szString)
   {
       while (*szString != L'\0')
       {
          switch(*szString)
          {
              case L'\r':
              case L'\n':
              case L'\t':
              *szString = L' ';
                 break;
          }
          szString++;
       }
   }
}


HANDLE EnablePrivileges(LPCWSTR ppcwszPrivileges[], ULONG cPrivileges)
{
    BOOL                fResult = FALSE;
    HANDLE              hToken = INVALID_HANDLE_VALUE;
    HANDLE              hOriginalThreadToken = INVALID_HANDLE_VALUE;
    PTOKEN_PRIVILEGES   ptp;
    ULONG               nBufferSize;

    // Note that TOKEN_PRIVILEGES includes a single LUID_AND_ATTRIBUTES
    nBufferSize = sizeof(TOKEN_PRIVILEGES) + (cPrivileges - 1)*sizeof(LUID_AND_ATTRIBUTES);
    ptp = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, nBufferSize);
    if (!ptp)
        return INVALID_HANDLE_VALUE;
    //
    // Initialize the Privileges Structure
    //
    ptp->PrivilegeCount = cPrivileges;
    for (ULONG i = 0; i < cPrivileges; i++)
    {
        fResult = LookupPrivilegeValue(NULL, ppcwszPrivileges[i], &ptp->Privileges[i].Luid);
        if (!fResult)
            break;
        ptp->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    if(fResult)
    {
        //
        // Open the Token
        //
        hToken = hOriginalThreadToken = INVALID_HANDLE_VALUE;
        fResult = OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, FALSE, &hToken);
        if (fResult)
            hOriginalThreadToken = hToken;  // Remember the thread token
        else
            fResult = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);
    }

    if (fResult)
    {
        HANDLE hNewToken;

        //
        // Duplicate that Token
        //
        fResult = DuplicateTokenEx(hToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   NULL,                   // PSECURITY_ATTRIBUTES
                                   SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                                   TokenImpersonation,     // TokenType
                                   &hNewToken);            // Duplicate token
        if (fResult)
        {
            //
            // Add new privileges
            //
            fResult = AdjustTokenPrivileges(hNewToken,  // TokenHandle
                                            FALSE,      // DisableAllPrivileges
                                            ptp,        // NewState
                                            0,          // BufferLength
                                            NULL,       // PreviousState
                                            NULL);      // ReturnLength
            if (fResult)
            {
                //
                // Begin impersonating with the new token
                //
                fResult = SetThreadToken(NULL, hNewToken);
            }

            CloseHandle(hNewToken);
        }
    }

    // If something failed, don't return a token
    if (!fResult)
        hOriginalThreadToken = INVALID_HANDLE_VALUE;

    // Close the original token if we aren't returning it
    if (hOriginalThreadToken == INVALID_HANDLE_VALUE && hToken != INVALID_HANDLE_VALUE)
        CloseHandle(hToken);

    // If we succeeded, but there was no original thread token,
    // return NULL to indicate we need to do SetThreadToken(NULL, NULL)
    // to release privs.
    if (fResult && hOriginalThreadToken == INVALID_HANDLE_VALUE)
        hOriginalThreadToken = NULL;

    LocalFree(ptp);

    return hOriginalThreadToken;
}


void ReleasePrivileges(HANDLE hToken)
{
    BOOL fResult;
    if (INVALID_HANDLE_VALUE != hToken)
    {
        fResult = SetThreadToken(NULL, hToken);
        if (hToken)
            CloseHandle(hToken);
    }
}


HRESULT
myGetActiveModule(
    CertSvrCA *pCA,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OPTIONAL OUT LPOLESTR *ppwszProgIdModule,   // CoTaskMem*
    OPTIONAL OUT CLSID *pclsidModule)
{
    HRESULT hr;
    WCHAR *pwsz;
    variant_t var;
    
    hr = pCA->GetConfigEntry(
            fPolicyModule?wszREGKEYPOLICYMODULES:wszREGKEYEXITMODULES,
            wszREGACTIVE,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);

    if(V_VT(&var)==VT_BSTR)
    {
        pwsz = V_BSTR(&var);
    }
    else if(V_VT(&var)==(VT_ARRAY|VT_BSTR))
    {
        SafeArrayEnum<BSTR> saenum(V_ARRAY(&var));
        hr = saenum.GetAt(Index, pwsz);
        _JumpIfError(hr, error, "GetConfigEntry");
    }
    else
    {
        _JumpError(hr, error, "Bad active entry type");
    }

    if(!pwsz)
    {
        _JumpError(hr, error, "empty entry");
    }

    if (NULL != pclsidModule)
    {
        hr = CLSIDFromProgID(pwsz, pclsidModule);
        _JumpIfError(hr, error, "CLSIDFromProgID");
    }
    
    if (NULL != ppwszProgIdModule)
    {
        *ppwszProgIdModule = (LPOLESTR) CoTaskMemAlloc(
            (wcslen(pwsz) + 1) * sizeof(WCHAR));
        if (NULL == *ppwszProgIdModule)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "CoTaskMemAlloc");
        }
        wcscpy(*ppwszProgIdModule, pwsz);
    }
    hr = S_OK;      // not reset after ERROR_MOD_NOT_FOUND in all cases

error:
    return(hr);
}

HRESULT FindComputerObjectSid(
    LPCWSTR pcwszCAComputerDNSName,
    PSID &pSid)
{
    HRESULT hr = S_OK;
    ADS_SEARCHPREF_INFO asi[1];
    IDirectorySearch *pSearch = NULL;
    LPWSTR pwszAttr = L"objectSid";
    ADS_SEARCH_HANDLE hADS = NULL;
    static LPCWSTR pwszgc = L"GC://";
    static LPCWSTR pwszformat = L"(&(objectClass=computer)(servicePrincipalName=host/%ws))";
    LPWSTR pwszSearchFilter = NULL;
    LPWSTR pwszGC = NULL;
    DWORD dwres;
    PDOMAIN_CONTROLLER_INFO pdci = NULL;
    ADS_SEARCH_COLUMN col;
    
    dwres = DsGetDcName(
                NULL, 
                NULL, 
                NULL, 
                NULL, 
                DS_RETURN_DNS_NAME|DS_DIRECTORY_SERVICE_REQUIRED, 
                &pdci);
    if(NO_ERROR != dwres)
    {
        hr = myHError(dwres);
        _JumpIfError(hr, error, "DsGetDcName");
    }
    
    pwszGC = (LPWSTR)LocalAlloc(LMEM_FIXED, 
        sizeof(WCHAR)*(wcslen(pwszgc)+wcslen(pdci->DnsForestName)+1));
    _JumpIfAllocFailed(pwszGC, error);

    wcscpy(pwszGC, pwszgc);
    wcscat(pwszGC, pdci->DnsForestName);

    hr = ADsGetObject(pwszGC, IID_IDirectorySearch, (void**)&pSearch);
    _JumpIfError(hr, error, "ADsGetObject(GC:)");

    asi[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    asi[0].vValue.dwType = ADSTYPE_INTEGER;
    asi[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    hr = pSearch->SetSearchPreference(asi, 1);
    _JumpIfError(hr, error, "SetSearchPreference");

    pwszSearchFilter = (LPWSTR)LocalAlloc(LMEM_FIXED, 
        sizeof(WCHAR)*(wcslen(pwszformat)+wcslen(pcwszCAComputerDNSName)+1));

    wsprintf(pwszSearchFilter, pwszformat, pcwszCAComputerDNSName);
    
    hr = pSearch->ExecuteSearch(
            pwszSearchFilter, 
            &pwszAttr,
            1,
            &hADS);
    _JumpIfErrorStr(hr, error, "ExecuteSearch", pwszSearchFilter);

    hr = pSearch->GetFirstRow(hADS);
    _JumpIfError(hr, error, "GetFirstRow");

    hr = pSearch->GetColumn(hADS, pwszAttr, &col);
    _JumpIfErrorStr(hr, error, "GetColumn", pwszAttr);

    CSASSERT(IsValidSid(col.pADsValues[0].OctetString.lpValue));
    CSASSERT(GetLengthSid(col.pADsValues[0].OctetString.lpValue)==
        col.pADsValues[0].OctetString.dwLength);

    pSid = LocalAlloc(LMEM_FIXED, col.pADsValues[0].OctetString.dwLength);
    _JumpIfAllocFailed(pSid, error);

    CopySid(col.pADsValues[0].OctetString.dwLength,
            pSid, 
            col.pADsValues[0].OctetString.lpValue);

error:

    if(pdci)
        NetApiBufferFree(pdci);

    if(pSearch)
    {
        pSearch->FreeColumn(&col);

        if(hADS)
            pSearch->CloseSearchHandle(hADS);
        pSearch->Release();
    }
    LOCAL_FREE(pwszSearchFilter);
    LOCAL_FREE(pwszGC);
    return hr;
}



HRESULT IsUserDomainAdministrator(BOOL* pfIsAdministrator)
{
	HRESULT	hr = S_OK;

	*pfIsAdministrator = FALSE;

		PSID						psidAdministrators;
		SID_IDENTIFIER_AUTHORITY	siaNtAuthority = SECURITY_NT_AUTHORITY;

		BOOL bResult = AllocateAndInitializeSid (&siaNtAuthority, 2,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
				0, 0, 0, 0, 0, 0, &psidAdministrators);
		if ( bResult )
		{
			bResult = CheckTokenMembership (0, psidAdministrators,
					pfIsAdministrator);
			ASSERT (bResult);
			if ( !bResult )
			{
				hr = myHLastError ();
                                _PrintError(hr, "CheckTokenMembership");
			}
			FreeSid (psidAdministrators);
		}
		else
		{
			hr = myHLastError ();
                        _PrintError(hr, "AllocateAndInitializeSid");
		}
	return hr;
}


BOOL RestartService(HWND hWnd, CertSvrMachine* pMachine)
{
        // notify user we can't apply immediately
        CString cstrText;
        cstrText.LoadString(IDS_CONFIRM_SERVICE_RESTART);

        if (IDYES == ::MessageBox(hWnd, (LPCWSTR)cstrText, (LPCWSTR)g_pResources->m_DescrStr_CA, MB_YESNO | MB_ICONWARNING ))
        {
            DWORD dwErr;

            // stop the service
            if (pMachine->IsCertSvrServiceRunning())
                pMachine->CertSvrStartStopService(hWnd, FALSE);

            // start the serviec
            dwErr = pMachine->CertSvrStartStopService(hWnd, TRUE);
            if (S_OK != dwErr)
                DisplayGenericCertSrvError(hWnd, dwErr);

            return TRUE;
        }

    return FALSE; // didn't restart
}


static BOOL s_fLogOpened = FALSE;

VOID
LogOpen(
    IN BOOL fForceOpen)
{
    BOOL fOpenLog;

    DbgPrintfInit("+");		// reinitialize debug print mask first
    fOpenLog = DbgIsSSActive(DBG_SS_OPENLOG);

    if (fOpenLog || fForceOpen)
    {
	if (!s_fLogOpened)
	{
	    csiLogOpen("+certmmc.log");
	    s_fLogOpened = TRUE;
	    CSILOGFILEVERSION(0, L"certmmc.dll", szCSVER_STR);
	}
    }
}


VOID
LogClose()
{
    if (s_fLogOpened)
    {
	csiLogClose();
	s_fLogOpened = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\misc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       misc.h
//
//--------------------------------------------------------------------------

#ifndef _MISC_H_
#define _MISC_H_

#define _JumpIfOutOfMemory(hr, label, pMem) \
    { \
        if (NULL == (pMem)) \
        { \
            (hr) = E_OUTOFMEMORY; \
            _JumpError((hr), label, "Out of Memory"); \
        } \
    }

__inline
void FREE_DATA(void* pData)
{
    if (pData)
        GlobalFree(pData);
}

// count the number of bytes needed to fully store the WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )

// fwds
class CertSvrCA;
class CertSvrMachine;



BOOL            FixupFilterString(LPWSTR szFilter);

LPCWSTR         GetNullMachineName(CString* pcstr);
BOOL            FIsCurrentMachine(LPCWSTR);



STDMETHODIMP    CStringLoad(CString& cstr, IStream *pStm);
STDMETHODIMP    CStringSave(CString& cstr, IStream *pStm, BOOL fClearDirty);
STDMETHODIMP    CStringGetSizeMax(CString& cstr, int* piSize);

STDMETHODIMP    VariantLoad(VARIANT& var, IStream *pStm);
STDMETHODIMP    VariantSave(VARIANT& var, IStream *pStm, BOOL fClearDirty);
STDMETHODIMP    VariantGetSizeMax(VARIANT& var, int* piSize);

DWORD           AllocAndReturnConfigValue(HKEY hKey, LPCWSTR szConfigEntry, PBYTE* ppbOut, DWORD* pcbOut, DWORD* pdwType);

void            DisplayCertSrvErrorWithContext(HWND hwnd, DWORD dwErr, UINT iRscContext);
void            DisplayCertSrvErrorWithContext(HWND hwnd, DWORD dwErr, LPCWSTR szContext);
void            DisplayGenericCertSrvError(HWND hwnd, DWORD dwErr);
void            DisplayGenericCertSrvError(LPCONSOLE pConsole, DWORD dwErr);

DWORD           CryptAlgToStr(CString* pcstrAlgName, LPCWSTR szProv, DWORD dwProvType, DWORD dwAlg);

enum ENUM_PERIOD DurationEnumFromNonLocalizedString(LPCWSTR szPeriod);
BOOL StringFromDurationEnum(int iEnum, CString* pcstr, BOOL fLocalized);

LPCWSTR         OperationToStr(int iOperation);
int             StrToOperation(LPCWSTR  szOperation);

// Column name localization
LPCWSTR         FindUnlocalizedColName(LPCWSTR strColumn);  // returns ptr to rsc

// returns localized string 
BOOL MakeDisplayStrFromDBVariant(VARIANT* pvt, VARIANT* pvOut);

typedef struct _QUERY_RESTRICTION
{
    _QUERY_RESTRICTION* pNext;

    LPWSTR  szField;
    UINT    iOperation;
    
    VARIANT varValue;

    friend bool operator==(
        const struct _QUERY_RESTRICTION& lhs,
        const struct _QUERY_RESTRICTION& rhs);

} QUERY_RESTRICTION, *PQUERY_RESTRICTION;


PQUERY_RESTRICTION  NewQueryRestriction(LPCWSTR szField, UINT iOp, VARIANT* pvarValue);
void                FreeQueryRestriction(PQUERY_RESTRICTION pQR);
void                FreeQueryRestrictionList(PQUERY_RESTRICTION pQR);

PQUERY_RESTRICTION QueryRestrictionFound(
    PQUERY_RESTRICTION pQR, 
    PQUERY_RESTRICTION pQRListHead);

void ListInsertAtEnd(void** ppList, void* pElt);

LPWSTR RegEnumKeyContaining(
    HKEY hBaseKey,
    LPCWSTR szContainsString, 
    DWORD* pdwIndex);

HRESULT
myGetActiveModule(
    CertSvrCA *pCA,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OPTIONAL OUT LPOLESTR *ppwszProgIdModule,   // CoTaskMem*
    OPTIONAL OUT CLSID *pclsidModule);

/////////////////////////////////////////
// fxns to load resources automatically
class CLocalizedResources
{
public:
    CLocalizedResources();
    ~CLocalizedResources();
    BOOL    Load();

public:
    BOOL        m_fLoaded;
    CBitmap     m_bmpSvrMgrToolbar1; // Imagelist for the STOP/START toolbar

    CString     m_ColumnHead_Name;
    CString     m_ColumnHead_Size;
    CString     m_ColumnHead_Type;
    CString     m_ColumnHead_Description;

    CString     m_DescrStr_CA;
    CString     m_DescrStr_Unknown;

    CString     m_szFilterApplied;
    CString     m_szSortedAscendingTemplate;
    CString     m_szSortedDescendingTemplate;
    CString     m_szStoppedServerMsg;
    CString     m_szStatusBarErrorFormat;

    CString     m_szRevokeReason_Unspecified;
    CString     m_szRevokeReason_KeyCompromise;
    CString     m_szRevokeReason_CaCompromise;
    CString     m_szRevokeReason_Affiliation;
    CString     m_szRevokeReason_Superseded;
    CString     m_szRevokeReason_Cessatation;
    CString     m_szRevokeReason_CertHold;
    CString     m_szRevokeReason_RemoveFromCRL;

    CString     m_szPeriod_Seconds;
    CString     m_szPeriod_Minutes;
    CString     m_szPeriod_Hours;
    CString     m_szPeriod_Days;
    CString     m_szPeriod_Weeks;
    CString     m_szPeriod_Months;
    CString     m_szPeriod_Years;

    CString     m_szYes;
};

extern CLocalizedResources *g_pResources;



BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);


HRESULT ReadOfSize(IStream* pStm, void* pbData, ULONG cbData);
HRESULT WriteOfSize(IStream* pStm, void* pbData, ULONG cbData);

HRESULT myOIDToName(
    IN WCHAR const *pwszObjId, 
    OUT LPWSTR* pszName);

HRESULT myDumpFormattedObject(
    IN WCHAR const *pszObjId, 
    IN BYTE const *pbObject,
    IN DWORD cbObject,
    OUT LPWSTR* pwszFormatted);


void InplaceStripControlChars(WCHAR* szString);

HANDLE EnablePrivileges(LPCWSTR ppcwszPrivileges[], ULONG cPrivileges);
void ReleasePrivileges(HANDLE hToken);

HRESULT IsUserDomainAdministrator(BOOL* pfIsAdministrator);

BOOL RestartService(HWND hWnd, CertSvrMachine* pMachine);

//
// defined in casec.cpp
//
extern "C"
HRESULT
CreateCASecurityInfo(  CertSvrCA *pCA,
                        LPSECURITYINFO *ppObjSI);

_COM_SMARTPTR_TYPEDEF(ICertAdmin2, IID_ICertAdmin2);

HRESULT FindComputerObjectSid(
    LPCWSTR pcwszCAComputerDNSName,
    PSID &pSid);

VOID LogOpen(IN BOOL fForceOpen);
VOID LogClose();

#endif _MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\krapage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       krapage.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "genpage.h"

#include "csmmchlp.h"
#include "cslistvw.h"

#define __dwFILE__	__dwFILE_CERTMMC_KRAPAGE_CPP__


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//defines
//dwFlags in KRA_NODE
#define KRA_FROM_CACHE    0x00000001
#define KRA_MARK_ADDED    0x00000002

static const int nImageValidCert = 3;
static const int nImageInvalidCert = 2;
//macros

//local globals

CString CSvrSettingsKRAPage::m_strDispositions[7];

//add a new into the link list
HRESULT
AddNewKRANode(
    IN CERT_CONTEXT const   *pCert,
    IN DWORD dwDisposition,
    IN DWORD                 dwFlags,
    IN OUT KRA_NODE        **ppKRAList,
    OUT OPTIONAL KRA_NODE  **ppKRA)
{
    CSASSERT(NULL != ppKRAList);

    HRESULT hr;
    KRA_NODE *pKRANode = NULL;
    KRA_NODE *pKRA = *ppKRAList;

    pKRANode = (KRA_NODE*)LocalAlloc(LMEM_FIXED, sizeof(KRA_NODE));
    if (NULL == pKRANode)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Out of memory");
    }

    //assign node data and put it at the end
    pKRANode->pCert = pCert;
    pKRANode->dwFlags = dwFlags;
    pKRANode->next = NULL;
    pKRANode->dwDisposition = dwDisposition;

    if (NULL == pKRA)
    {
        //empty list, 1st one
        *ppKRAList = pKRANode;
    }
    else
    {
        //always add to the end
        while (NULL != pKRA->next)
        {
            pKRA = pKRA->next;
        }
        //add
        pKRA->next = pKRANode;
    }

    if (NULL != ppKRA)
    {
        //optional return
        *ppKRA = pKRANode;
    }

    hr = S_OK;
error:
    return hr;
}

void
FreeKRANode(
    KRA_NODE *pKRA)
{
    if (NULL != pKRA->pCert)
    {
        CertFreeCertificateContext(pKRA->pCert);
        pKRA->pCert = NULL;
    }
    LocalFree(pKRA);
}

void
FreeKRAList(
    KRA_NODE  *pKRAList)
{
    KRA_NODE  *pKRA = pKRAList; //point to list
    KRA_NODE  *pKRATemp;

    while (NULL != pKRA)
    {
        pKRATemp= pKRA;  //save it for free
        // update for the loop
        pKRA= pKRA->next;
        FreeKRANode(pKRATemp);
    }
}

//remove a kra node from the link list
void
RemoveKRANode(
    IN OUT KRA_NODE  **ppKRAList,
    IN KRA_NODE      *pKRA)
{
    CSASSERT(NULL != ppKRAList && NULL != *ppKRAList && NULL != pKRA);

    KRA_NODE *pKRACurrent = *ppKRAList;
    KRA_NODE *pKRALast = NULL;

    //find the node
    while (NULL != pKRACurrent && pKRACurrent != pKRA)
    {
        pKRALast = pKRACurrent; //remember last one
        pKRACurrent = pKRACurrent->next;
    }
    CSASSERT(NULL != pKRACurrent); //node must be in the list

    if (NULL != pKRACurrent)
    {
	if (NULL != pKRACurrent->next)
	{
	    if (NULL == pKRALast)
	    {
		//means the node is the begining
		CSASSERT(pKRA == *ppKRAList);
		*ppKRAList = pKRA->next; //make next as begining
	    }
	    else
	    {
		//make next pointer of the last node to the next
		pKRALast->next = pKRACurrent->next;
	    }
	}
	else
	{
	    if (NULL == pKRALast)
	    {
		//this is the only node
		*ppKRAList = NULL; //empty list
	    }
	    else
	    {
		//the node is the end, make last as the end
		pKRALast->next = NULL;
	    }
	}

	//now, remove the current node
	FreeKRANode(pKRACurrent);
    }
}    

BOOL
DoesKRACertExist(
    IN KRA_NODE             *pKRAList,
    IN CERT_CONTEXT const   *pKRACert)
{
    BOOL fExists = FALSE;

    while (NULL != pKRAList)
    {
        if(pKRAList->pCert)
        {
	    fExists = myAreCertContextBlobsSame(pKRAList->pCert, pKRACert);
            if (fExists)
            {
                //done
                break;
            }
        }
        pKRAList = pKRAList->next;
    }
    return fExists;
}

DWORD
GetKRACount(
    IN KRA_NODE const *pKRAList)
{
    DWORD count = 0;

    while(NULL != pKRAList)
    {
        pKRAList = pKRAList->next;
        ++count;
    }
    return count;
}

LPCWSTR CSvrSettingsKRAPage::MapDispositionToString(DWORD dwDisp)
{
    if(dwDisp>ARRAYSIZE(m_strDispositions))
        dwDisp = KRA_DISP_INVALID;
    return CSvrSettingsKRAPage::m_strDispositions[dwDisp];
}

void CSvrSettingsKRAPage::LoadKRADispositions()
{
    DWORD cKRA = GetKRACount(m_pKRAList);
    variant_t var;
    HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_KRA);
    LVITEM lvitem;
    ICertAdmin2 *pAdmin = NULL;
    bool fInvalidKRAs = false;

    // Don't use a cached admin interface, we need latest KRA cert
    // state from the server, not a cached result
    m_pCA->m_pParentMachine->GetAdmin2(&pAdmin);
    if(!pAdmin)
        return;

    lvitem.mask = LVIF_IMAGE;
    lvitem.iSubItem = 0;
        
    for(DWORD cCrtKRA=0;cCrtKRA<cKRA;cCrtKRA++)
    {
        V_I4(&var) = KRA_DISP_INVALID;
        pAdmin->GetCAProperty(
            m_pCA->m_bstrConfig,
            CR_PROP_KRACERTSTATE,
            cCrtKRA,
            PROPTYPE_LONG,
            0,
            &var);

        ListView_SetItemText(
            hwndList, 
            cCrtKRA, 
            3,
            (LPWSTR)MapDispositionToString(V_I4(&var)));

        lvitem.iImage = V_I4(&var)==KRA_DISP_VALID?
                        nImageValidCert:nImageInvalidCert;
        lvitem.iItem = cCrtKRA;
        ListView_SetItem(
            hwndList, 
            &lvitem);

        if(V_I4(&var)!=KRA_DISP_VALID)
        {
            fInvalidKRAs = true;
        }
    }

    if(pAdmin)
        pAdmin->Release();

    if(m_fArchiveKey && fInvalidKRAs)
    {
        DisplayCertSrvErrorWithContext(
            m_hWnd, 
            S_OK, 
            IDS_WARN_INVALID_KRAS);
    }
}

HRESULT
CSvrSettingsKRAPage::LoadKRAList(ICertAdmin2 *pAdmin)
{
    HRESULT hr;
    KRA_NODE  *pKRAList = NULL;
    DWORD     i;
    const CERT_CONTEXT *pCertContext;
    KRA_NODE **ppKRAList = &m_pKRAList;
    variant_t var;

    hr = pAdmin->GetCAProperty(
                m_pCA->m_bstrConfig,
                CR_PROP_KRACERTCOUNT,
                0,
                PROPTYPE_LONG,
                0,
                &var);
    _JumpIfError(hr, error, "GetCAProperty CR_PROP_KRACERTCOUNT");

    CSASSERT(V_VT(&var)==VT_I4);
    m_dwKRACount = V_I4(&var);

    for (i = 0; i < m_dwKRACount; ++i)
    {
        variant_t varCert;
        variant_t varDisp;

        pCertContext = NULL;

        hr = pAdmin->GetCAProperty(
                    m_pCA->m_bstrConfig,
                    CR_PROP_KRACERT,
                    i,
                    PROPTYPE_BINARY,
                    CR_OUT_BINARY,
                    &varCert);
        if(S_OK==hr)
        {
            CSASSERT(V_VT(&varCert)==VT_BSTR);
            CSASSERT(V_BSTR(&varCert));

            pCertContext = CertCreateCertificateContext(
                X509_ASN_ENCODING,
                (BYTE*)V_BSTR(&varCert),
                SysStringByteLen(V_BSTR(&varCert)));
            if(!pCertContext)
            {
                hr = myHLastError();
                _JumpError(hr, error, "CertCreateCertificateContext");
            }
        }
        
        V_I4(&varDisp) = KRA_DISP_INVALID;
        pAdmin->GetCAProperty(
            m_pCA->m_bstrConfig,
            CR_PROP_KRACERTSTATE,
            i,
            PROPTYPE_LONG,
            0,
            &varDisp);
        
        hr = AddNewKRANode(
                pCertContext, V_I4(&varDisp), KRA_FROM_CACHE, &pKRAList, NULL);
        _JumpIfError(hr, error, "AddNewKRANode");
    }

    *ppKRAList = pKRAList;
    pKRAList = NULL;

    hr = pAdmin->GetCAProperty(
                m_pCA->m_bstrConfig,
                CR_PROP_KRACERTUSEDCOUNT,
                0,
                PROPTYPE_LONG,
                0,
                &var);
    _JumpIfError(hr, error, "GetCAProperty wszREGKRACERTCOUNT");

    CSASSERT(VT_I4==V_VT(&var));
    m_dwKRAUsedCount = V_I4(&var);

    m_fArchiveKey = m_dwKRAUsedCount?TRUE:FALSE;

    hr = S_OK;
error:
    if (NULL != pKRAList)
    {
        FreeKRAList(pKRAList);
    }
    return hr;
}

HRESULT
CSvrSettingsKRAPage::SaveKRAList(ICertAdmin2 *pAdmin)
{
    HRESULT hr;
    KRA_NODE *pKRA = m_pKRAList; //point to the list
    DWORD     dwIndex = 0;
    DWORD dwNewKRACount;
    variant_t var;
    
    if (m_fKRAUpdate)
    {
        while (NULL != pKRA)
        {
            if(pKRA->pCert)
            {
            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = NULL;
    
            hr = EncodeCertString(
                    pKRA->pCert->pbCertEncoded, 
                    pKRA->pCert->cbCertEncoded,
                    CV_OUT_BINARY, 
                    &(V_BSTR(&var)));
            _JumpIfError(hr, error, "EncodeCertString");
    
            hr = pAdmin->SetCAProperty(
                        m_pCA->m_bstrConfig,
                        CR_PROP_KRACERT,
                        dwIndex,
                        PROPTYPE_BINARY,
                        &var);
            _JumpIfError(hr, error, "GetCAProperty CR_PROP_KRACERT");

            var.Clear();
            }

            ++dwIndex;
            pKRA = pKRA->next;
        }

        dwNewKRACount = dwIndex;

        // Update total cert count only if the new list is smaller than the old
        // list, otherwise SetCAProperty calls above already extended the list
        if(dwNewKRACount<m_dwKRACount)
        {
            V_VT(&var) = VT_I4;
            V_I4(&var) = dwNewKRACount;

            hr = pAdmin->SetCAProperty(
                        m_pCA->m_bstrConfig,
                        CR_PROP_KRACERTCOUNT,
                        0,
                        PROPTYPE_LONG,
                        &var);
            _JumpIfError(hr, error, "GetCAProperty CR_PROP_KRACERTCOUNT");
        }
        
        m_dwKRACount = dwNewKRACount;
    }

    if (m_fCountUpdate)
    {
        V_VT(&var) = VT_I4;
        V_I4(&var) = m_dwKRAUsedCount;

        hr = pAdmin->SetCAProperty(
                    m_pCA->m_bstrConfig,
                    CR_PROP_KRACERTUSEDCOUNT,
                    0,
                    PROPTYPE_LONG,
                    &var);
        _JumpIfError(hr, error, "GetCAProperty CR_PROP_KRACERTUSEDCOUNT");
    }

    hr = S_OK;

error:
    var.Clear();
    return hr;
}

HRESULT
KRACertGetName(
    IN CERT_CONTEXT const *pCert,
    IN DWORD               dwFlags,  //dwFlags in CertGetNameString
    OUT WCHAR            **ppwszName)
{
    HRESULT hr;
    DWORD   dwTypeParam;
    DWORD   cch = 0;
    WCHAR  *pwszName = NULL;
    LPCWSTR pcwszEmpty = L"";

    CSASSERT(NULL != ppwszName);

    cch = 0;
    while (TRUE)
    {
        if(pCert)
        {
            cch = CertGetNameString(
                    pCert,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    dwFlags,  //subject or issuer
                    &dwTypeParam,
                    pwszName,
                    cch);
        }
        else
        {
            if(!pwszName)
                cch = sizeof(WCHAR)*(wcslen(pcwszEmpty)+1);
            else
                wcscpy(pwszName, pcwszEmpty);
        }
        if (0 == cch)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertGetNameString");
        }
        if (NULL != pwszName)
        {
            //done
            break;
        }
        pwszName = (WCHAR*)LocalAlloc(LMEM_FIXED, cch * sizeof(WCHAR));
        if (NULL == pwszName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }
    *ppwszName = pwszName;
    pwszName = NULL;

    hr = S_OK;
error:
    if (NULL != pwszName)
    {
        LocalFree(pwszName);
    }
    return hr;
}

void
ListView_AddKRAItem(
    HWND      hwndListKRA,
    int       iItem,
    KRA_NODE *pKRA)
{
    HRESULT  hr;
    WCHAR   *pwszSubject = NULL;
    WCHAR   *pwszIssuer = NULL;

    CSASSERT(NULL != pKRA);

    //get subject name
    hr = KRACertGetName(pKRA->pCert, 0x0, &pwszSubject);

    if (S_OK != hr)
    {
        CSASSERT(NULL == pwszSubject);
        _PrintError(hr, "Invalid KRA cert");
    }

    //create a new item, 1st column, subject name, item data point to KRA
    ListView_NewItem(hwndListKRA, iItem, pwszSubject, (LPARAM)pKRA, 
        pKRA->dwDisposition==KRA_DISP_VALID?nImageValidCert:nImageInvalidCert);

    if(pKRA->pCert)
    {
        //get issuer name
        hr = KRACertGetName(pKRA->pCert, CERT_NAME_ISSUER_FLAG, &pwszIssuer);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszIssuer);
            _PrintError(hr, "KRACertGetName(issuer)");
        }

        //2nd column, issuer name
        ListView_SetItemText(hwndListKRA, iItem, 1, pwszIssuer); 

        //3rd column, expiration date
        ListView_SetItemFiletime(hwndListKRA, iItem, 2,
                                 &pKRA->pCert->pCertInfo->NotAfter);
    }

    //4th column, status
    ListView_SetItemText(hwndListKRA, iItem, 3, 
        (LPWSTR)CSvrSettingsKRAPage::MapDispositionToString(
            pKRA->dwDisposition)); 


    if (NULL != pwszSubject)
    {
        LocalFree(pwszSubject);
    }
    if (NULL != pwszIssuer)
    {
        LocalFree(pwszIssuer);
    }
}

////
// Settings: KRA page
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsKRAPage property page

RoleAccessToControl CSvrSettingsKRAPage::sm_ControlToRoleMap[] = 
{
    { IDC_KRA_DISABLE,  CA_ACCESS_ADMIN},
    { IDC_KRA_ENABLE,   CA_ACCESS_ADMIN},
    { IDC_KRA_EDITCOUNT,CA_ACCESS_ADMIN},
    { IDC_KRA_ADD,      CA_ACCESS_ADMIN},
    { IDC_KRA_REMOVE,   CA_ACCESS_ADMIN},
};

CSvrSettingsKRAPage::CSvrSettingsKRAPage(
    CertSvrCA               *pCA,
    CSvrSettingsGeneralPage *pControlPage,
    UINT                     uIDD) 
    : CAutoDeletePropPage(uIDD), 
      CRolesSupportInPropPage(
        pCA,
        sm_ControlToRoleMap,
        ARRAYSIZE(sm_ControlToRoleMap)),
      m_pControlPage(pControlPage)
{
    m_fArchiveKey = FALSE;
    m_fCountUpdate = FALSE;
    m_fKRAUpdate = FALSE;
    m_pKRAList = NULL;
    m_dwKRAUsedCount = 0;
    m_dwKRACount = 0;

    for(DWORD cStr=0;cStr<ARRAYSIZE(m_strDispositions);cStr++)
    {
        // IDS_DISPOSITION_* order must match KRA_DISP_*
        if(m_strDispositions[cStr].IsEmpty())
            m_strDispositions[cStr].LoadString(IDS_DISPOSITION_EXPIRED+cStr);
    }
    
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE_CHOOSE_KRA);
}

CSvrSettingsKRAPage::~CSvrSettingsKRAPage()
{
    if (NULL != m_pKRAList)
    {
        FreeKRAList(m_pKRAList);
    }
}

// replacement for DoDataExchange
BOOL CSvrSettingsKRAPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_dwKRAUsedCount = GetDlgItemInt(
            m_hWnd, IDC_KRA_EDITCOUNT, NULL, FALSE);
    }
    else
    {
        SetDlgItemInt(m_hWnd, IDC_KRA_EDITCOUNT, m_dwKRAUsedCount, FALSE);
    }
    return TRUE;
}

void CSvrSettingsKRAPage::EnableKRAEdit(BOOL fEnabled)
{
    EnableControl(m_hWnd, IDC_KRA_EDITCOUNT, fEnabled);
}

void CSvrSettingsKRAPage::EnableKRAListView(BOOL fEnabled)
{
    // when disabling the list, deselect any item
    if(!fEnabled)
    {
        ListView_SetItemState(GetDlgItem(m_hWnd, IDC_LIST_KRA), 
        -1, 0, LVIS_SELECTED);
    }
    // when enabling the list, select first item
    else
    {
        ListView_SetItemState(GetDlgItem(m_hWnd, IDC_LIST_KRA), 
        0, LVIS_SELECTED, LVIS_SELECTED);
    }

    ::EnableWindow(GetDlgItem(m_hWnd, IDC_LIST_KRA), fEnabled);

}

bool CSvrSettingsKRAPage::IsCurrentItemValidCert()
{
    HWND hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);
    // get kra index # from the current selection
    int iSel = ListView_GetCurSel(hwndListKRA);
    if (-1 == iSel)
    {
        return false;
    }

    // get item data
    KRA_NODE* pKRA = (KRA_NODE*)ListView_GetItemData(hwndListKRA, iSel);

    if(pKRA)
        return pKRA->pCert?true:false;
    else
        return false;
}

void CSvrSettingsKRAPage::EnableKRARemoveViewListButtons(BOOL fEnabled)
{
    EnableControl(m_hWnd, IDC_KRA_REMOVE, fEnabled);

    ::EnableWindow(GetDlgItem(m_hWnd, IDC_KRA_VIEW), fEnabled && 
        IsCurrentItemValidCert());
}

void CSvrSettingsKRAPage::EnableKRAAddListButton(BOOL fEnabled)
{
    EnableControl(m_hWnd, IDC_KRA_ADD, fEnabled);
}


void CSvrSettingsKRAPage::EnableKRARadioButtons(BOOL fMoreThanZero)
{
    EnableControl(m_hWnd, IDC_KRA_ENABLE, fMoreThanZero);
    EnableControl(m_hWnd, IDC_KRA_DISABLE, fMoreThanZero);
}

void
CSvrSettingsKRAPage::OnAddKRA()
{
    HRESULT hr;
    CERT_CONTEXT const *pKRACert = NULL;  //don't free
    KRA_NODE           *pKRA = NULL;  //don't free
	HWND hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);

    hr = myGetKRACertificateFromPicker(
                g_hInstance,
                hwndListKRA,
                IDS_KRA_ADD_TITLE,
                IDS_KRA_ADD_SUBTITLE,
                NULL,
                m_pCA->FIsUsingDS(),
		FALSE,		// fSilent
                &pKRACert);
    if ((S_OK == hr) && (pKRACert == NULL))
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    if (S_OK != hr)
    {
        CSASSERT(NULL == pKRACert);
        _PrintError(hr, "myGetKRACertificateFromPicker");
        return;
    }

    if (!DoesKRACertExist(m_pKRAList, pKRACert))
    {
        hr = AddNewKRANode(
                    pKRACert,
                    KRA_DISP_NOTLOADED,
                    KRA_MARK_ADDED,
                    &m_pKRAList,
                    &pKRA);
        if (S_OK == hr)
        {
            //add to the kra to the end of the list
            int iItem = ListView_GetItemCount(hwndListKRA);
            ListView_AddKRAItem(hwndListKRA, iItem, pKRA);
            ListView_SetItemState(hwndListKRA, iItem, LVIS_SELECTED, LVIS_SELECTED);
            if (0 == iItem)
            {
                //first item, buttons must have been disabled
                EnableKRARemoveViewListButtons(TRUE);
                EnableKRARadioButtons(TRUE);
                EnableKRAListView(TRUE);
                if(IsWindowEnabled(GetDlgItem(m_hWnd, IDC_KRA_ENABLE)))
                    SendMessage(GetDlgItem(m_hWnd, IDC_KRA_ENABLE),
                                    BM_CLICK, (WPARAM)0, (LPARAM)0);
            }
            SetModified(TRUE);
            m_fDirty = TRUE;
            m_fKRAUpdate = TRUE;
        }
        else
        {
            //pop up???
            _PrintError(hr, "AddNewKRANode");
        }
    }
    else
    {
        //UNDONE, ideally, pass m_pKRAList to picker to filter them out
        _PrintError(S_OK, "KRA cert from the picker already in the list");
    }
}

void 
CSvrSettingsKRAPage::OnRemoveKRA()
{
    KRA_NODE *pKRA;
    int       cItem;
	HWND hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);

    //get the selected KRA
    int iSel = ListView_GetCurSel(hwndListKRA);
    if (-1 == iSel)
    {
        return;
    }
    
    //get current count
    cItem = ListView_GetItemCount(hwndListKRA);

    pKRA = (KRA_NODE*)ListView_GetItemData(hwndListKRA, iSel);
    CSASSERT(NULL != pKRA);
    //remove it from the link list
    RemoveKRANode(&m_pKRAList, pKRA);

    //remove it from UI
    if (ListView_DeleteItem(hwndListKRA, iSel))
    {
        //determine which item is selected
        if (iSel == cItem - 1)
        {
            //the item removed was the last, modify the index
            --iSel;
        }
        if (NULL != m_pKRAList)
        {
            ListView_SetItemState(hwndListKRA, iSel, LVIS_SELECTED, LVIS_SELECTED);
        }
        else
        {
            CSASSERT(1 == cItem);
            //should check disable radio

            if(IsWindowEnabled(GetDlgItem(m_hWnd, IDC_KRA_DISABLE)))
                SendMessage(GetDlgItem(m_hWnd, IDC_KRA_DISABLE),
                                BM_CLICK, (WPARAM)0, (LPARAM)0);
        }
        SetModified(TRUE);
        m_fKRAUpdate = TRUE;
    }
    else
    {
        _PrintError(E_UNEXPECTED, "ListView_DeleteItem");
    }
}

void 
CSvrSettingsKRAPage::OnViewKRA()
{
    HRESULT hr;
    HCERTSTORE rghStores[2];
    KRA_NODE  *pKRA;
    HWND hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);

    CRYPTUI_VIEWCERTIFICATE_STRUCTW sViewCert;
    ZeroMemory(&sViewCert, sizeof(sViewCert));

    // get kra index # from the current selection
    int iSel = ListView_GetCurSel(hwndListKRA);
    if (-1 == iSel)
    {
        return;
    }

    // get item data
    pKRA = (KRA_NODE*)ListView_GetItemData(hwndListKRA, iSel);
    CSASSERT(NULL != pKRA);

    sViewCert.pCertContext = pKRA->pCert;
    sViewCert.hwndParent = m_hWnd;
    sViewCert.dwSize = sizeof(sViewCert);
    sViewCert.dwFlags = CRYPTUI_ENABLE_REVOCATION_CHECKING |
                        CRYPTUI_DISABLE_ADDTOSTORE;

    // if we're opening remotely, don't open local stores
    if (! m_pCA->m_pParentMachine->IsLocalMachine())
    {
        DWORD dw;
        
        // get remote stores
        dw = m_pCA->GetRootCertStore(&rghStores[0]);
        _PrintIfError(dw, "GetRootCertStore");

        if (S_OK == dw)
        {
            dw = m_pCA->GetCACertStore(&rghStores[1]);
            _PrintIfError(dw, "GetCACertStore");
        } 

        if (S_OK == dw)
        {
            // rely only on remote machine's stores
            sViewCert.cStores = 2;
            sViewCert.rghStores = rghStores;
            sViewCert.dwFlags |= CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
        }
        else
        {
            // tell user we're only doing this locally
            sViewCert.dwFlags |= CRYPTUI_WARN_REMOTE_TRUST;
        }
    }

        if (!CryptUIDlgViewCertificateW(&sViewCert, NULL))
        {
            hr = myHLastError();
            if (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
            {
                _PrintError(hr, "CryptUIDlgViewCertificateW");
            }
        }
}

// replacement for BEGIN_MESSAGE_MAP
BOOL
CSvrSettingsKRAPage::OnCommand(
    WPARAM wParam,
    LPARAM /* lParam */ )
{
    BOOL  fRet = TRUE;
    DWORD dwNewVal;

    switch(LOWORD(wParam))
    {
        case IDC_KRA_ADD:
            OnAddKRA();
        break;
        case IDC_KRA_REMOVE:
            OnRemoveKRA();
        break;
        case IDC_KRA_VIEW:
            OnViewKRA();
        break;

        case IDC_KRA_DISABLE:
            if ((BN_CLICKED == HIWORD(wParam)) && (m_dwKRAUsedCount != 0)) // if click to change state
            {
                SetModified(TRUE);
                m_fArchiveKey = FALSE;
                m_fCountUpdate = TRUE;
                m_dwKRAUsedCount = 0;
                EnableKRAListView(FALSE);
                EnableKRARemoveViewListButtons(FALSE);
                EnableKRAAddListButton(FALSE);
                EnableKRAEdit(FALSE);
                UpdateData(FALSE);
            }
        break;

        case IDC_KRA_ENABLE:
            if ((BN_CLICKED == HIWORD(wParam)) && (m_dwKRAUsedCount == 0)) // if click to change state
            {
                SetModified(TRUE);
                m_fArchiveKey = TRUE;
                m_fCountUpdate = TRUE;
                m_dwKRAUsedCount = 1;
                EnableKRAListView(TRUE);
                EnableKRARemoveViewListButtons(GetKRACount(m_pKRAList));
                EnableKRAAddListButton(TRUE);
                EnableKRAEdit(TRUE);
                UpdateData(FALSE);
            }
        break;

        case IDC_KRA_EDITCOUNT:
            dwNewVal = GetDlgItemInt(
                m_hWnd, IDC_KRA_EDITCOUNT, NULL, FALSE);

            switch(HIWORD(wParam))
            {
            case EN_CHANGE:
                if(dwNewVal != m_dwKRAUsedCount)
                {
                    SetModified(TRUE);
                    m_fCountUpdate = TRUE;
                }
            break;
            
            default:
                fRet = FALSE;
            break;
            }
        break;

        case IDC_LIST_KRA:
            switch(HIWORD(wParam))
            {
                
            case LBN_SELCHANGE:
                int selected = ListView_GetCurSel(
                    GetDlgItem(m_hWnd, IDC_LIST_KRA));
                EnableKRARemoveViewListButtons(selected!=-1);
                break;
            }
        break;

        default:
            fRet = FALSE;
        break;
    }
    return fRet;
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsKRAPage radio controls handlers
void CSvrSettingsKRAPage::UpdateKRARadioControls()
{
    int iRadio = IDC_KRA_ENABLE;
    if (0 == m_dwKRAUsedCount)
    {
        iRadio = IDC_KRA_DISABLE;
    }

    if(IsWindowEnabled(GetDlgItem(m_hWnd, iRadio))) // clicking on a disabled radio
                                                    // button would hang
    {
        SendMessage(GetDlgItem(m_hWnd, iRadio), BM_CLICK, (WPARAM)0, (LPARAM)0);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsKRAPage message handlers
BOOL CSvrSettingsKRAPage::OnInitDialog()
{
    HRESULT hr;
    HWND    hwndListKRA;
    int     iItem;
    CString cstrItemName;
    KRA_NODE *pKRA;
    variant_t var;
    ICertAdmin2 *pAdmin = NULL;
    HIMAGELIST hImageList = NULL;
    CWaitCursor WaitCursor;

    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    hr = m_pCA->m_pParentMachine->GetAdmin2(&pAdmin);
    _JumpIfError(hr, error, "GetAdmin2");

    // set edit max char limit
    SendDlgItemMessage(
        IDC_KRA_EDITCOUNT,
        EM_SETLIMITTEXT,
        (WPARAM)4,
        (LPARAM)0);

    // init listview
	hwndListKRA = GetDlgItem(m_hWnd, IDC_LIST_KRA);

    //make listviews whole row selection
    ListView_SetExtendedListViewStyle(hwndListKRA, LVS_EX_FULLROWSELECT);

    hImageList = ImageList_LoadBitmap(
                    g_hInstance, 
                    MAKEINTRESOURCE(IDB_16x16), 
                    16, 
                    1, 
                    RGB(255, 0, 255));
    ListView_SetImageList(hwndListKRA, hImageList, LVSIL_SMALL);

    //set kra list as default focus
    SetFocus(hwndListKRA);

    //add multiple columns
    //column 0
    cstrItemName.LoadString(IDS_LISTCOL_SUBJECT);
    ListView_NewColumn(hwndListKRA, 0, 90, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 1
    cstrItemName.LoadString(IDS_LISTCOL_ISSUER);
    ListView_NewColumn(hwndListKRA, 1, 90, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 2
    cstrItemName.LoadString(IDS_LISTCOL_EXPIRATION_DATE);
    ListView_NewColumn(hwndListKRA, 2, 90, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 3
    cstrItemName.LoadString(IDS_LISTCOL_STATUS);
    ListView_NewColumn(hwndListKRA, 3, 65, (LPWSTR)(LPCWSTR)cstrItemName);
    
    CSASSERT(NULL == m_pKRAList);

    //load all KRA certs
    hr = LoadKRAList(pAdmin);
    if (S_OK != hr)
    {
        CSASSERT(NULL == m_pKRAList);
        _JumpError(hr, error, "LoadKRAList");
    }

    //list KRA certs in UI
    pKRA = m_pKRAList;
    iItem = 0;
    while (NULL != pKRA)
    {
        ListView_AddKRAItem(hwndListKRA, iItem, pKRA);
        ++iItem;
        pKRA = pKRA->next;
    }
   
    //enable view/remove buttons
    if (m_fArchiveKey && 0 < iItem)
    {
        //select first one
        ListView_SetItemState(hwndListKRA, 0, LVIS_SELECTED, LVIS_SELECTED);
    }

    UpdateKRARadioControls();

    UpdateData(FALSE);

    EnableKRARemoveViewListButtons(m_fArchiveKey && 0 < iItem);
    EnableKRAAddListButton(m_fArchiveKey);
    EnableKRARadioButtons(TRUE);
    EnableKRAEdit(m_dwKRAUsedCount);
    EnableKRAListView(m_dwKRAUsedCount);

error:
	if(pAdmin)
        pAdmin->Release();

    if (hr != S_OK)
    {
        // hide all controls and show error text
        HideControls();

        EnableWindow(GetDlgItem(IDC_UNAVAILABLE), TRUE);
        ShowWindow(GetDlgItem(IDC_UNAVAILABLE), SW_SHOW);
        return FALSE;
    }

    return TRUE;
}

void CSvrSettingsKRAPage::OnDestroy() 
{
    // Note - This needs to be called only once.  
    // If called more than once, it will gracefully return an error.
//    if (m_hConsoleHandle)
//        MMCFreeNotifyHandle(m_hConsoleHandle);
//    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}



BOOL CSvrSettingsKRAPage::OnApply() 
{
    HRESULT hr = S_OK;
    ICertAdmin2 *pAdmin = NULL;
    HWND hwndEdit = GetDlgItem(m_hWnd, IDC_KRA_EDITCOUNT);
    DWORD dwNewVal = GetDlgItemInt(
                m_hWnd, IDC_KRA_EDITCOUNT, NULL, FALSE);


    // If key archival is enabled, you must have at least one
    // KRA defined and the number of used KRAs must be between
    // 1 and total number of KRAs defined
    if(m_fArchiveKey)
    {
        if(0==GetKRACount(m_pKRAList))
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_KRA_NOKRADEFINED);
            SetFocus(GetDlgItem(m_hWnd, IDC_KRA_ADD));//focus on add button
            return FALSE;
        }
    
        if(dwNewVal < 1 || dwNewVal > GetKRACount(m_pKRAList))
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_KRA_COUNT_TOO_BIG);
            SetFocus(hwndEdit); // focus on edit box
            SendMessage(hwndEdit, EM_SETSEL, 0, -1); // select all text
            return FALSE;
        }
    }

    UpdateData(TRUE);

    if (m_fKRAUpdate || m_fCountUpdate)
    {
        hr = m_pCA->m_pParentMachine->GetAdmin2(&pAdmin);
        _JumpIfError(hr, error, "GetAdmin");

        // update reg hash list
        hr = SaveKRAList(pAdmin);
        _JumpIfError(hr, error, "SaveKRAList");

        m_pControlPage->NeedServiceRestart(SERVERSETTINGS_PROPPAGE_KRA);
        m_pControlPage->TryServiceRestart(SERVERSETTINGS_PROPPAGE_KRA);

        LoadKRADispositions();

        m_fKRAUpdate = FALSE;
        m_fCountUpdate = FALSE;
    }
	
error:
    if(pAdmin)
        pAdmin->Release();

    if (hr != S_OK)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}

BOOL CSvrSettingsKRAPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pnmh;
    switch(idCtrl)
    {
        //handle double click on list items
        case IDC_LIST_KRA:
            switch(pnmh->code)
            {
                case NM_DBLCLK:
                    OnViewKRA();
                break;
                case LVN_ITEMCHANGED:
                    EnableKRARemoveViewListButtons(pnmlv->uNewState & LVIS_SELECTED);
                break;
            }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\genpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       genpage.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "genpage.h"
#include "progress.h"

#include "certsrv.h"
#include "csdisp.h"
//#include "misc.h"

#include "certca.h"
#include <cryptui.h>

#include "csmmchlp.h"
#include "cslistvw.h"
#include "certmsg.h"
#include "urls.h"
#include "certsrvd.h"
#include "certsd.h"
#include "setupids.h"

#include <objsel.h>

#define __dwFILE__	__dwFILE_CERTMMC_GENPAGE_CPP__


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CString CSvrSettingsCertManagersPage::m_strButtonAllow;
CString CSvrSettingsCertManagersPage::m_strButtonDeny;
CString CSvrSettingsCertManagersPage::m_strTextAllow;
CString CSvrSettingsCertManagersPage::m_strTextDeny;


UINT g_aidFont[] =
{
    IDS_LARGEFONTNAME,
    IDS_LARGEFONTSIZE,
    IDS_SMALLFONTNAME,
    IDS_SMALLFONTSIZE,
};


// forwards
BOOL
BrowseForDirectory(
    HWND hwndParent,
    LPCTSTR pszInitialDir,
    LPTSTR pszBuf,
    int cchBuf,
    LPCTSTR pszDialogTitle);

HRESULT GetPolicyManageDispatch(
    LPCWSTR pcwszProgID,
    REFCLSID clsidModule, 
    DISPATCHINTERFACE* pdi);

HRESULT GetExitManageDispatch(
    LPCWSTR pcwszProgID,
    REFCLSID clsidModule, 
    DISPATCHINTERFACE* pdi);


HRESULT ThunkServerCallbacks(CertSvrCA* pCA);

INT_PTR CALLBACK dlgProcChooseModule(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );
INT_PTR CALLBACK dlgProcTimer(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );
INT_PTR CALLBACK dlgProcQuery(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );
INT_PTR CALLBACK dlgProcAddRestriction(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );
INT_PTR CALLBACK dlgProcRenewReuseKeys(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );

// Base/Delta CRL publish chooser
INT_PTR CALLBACK dlgProcRevocationPublishType(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  );

#define CERTMMC_HELPFILENAME L"Certmmc.hlp"

//////////////////////////////
// hand-hewn pages

////
// 1

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsGeneralPage property page
CSvrSettingsGeneralPage::CSvrSettingsGeneralPage(CertSvrCA* pCA, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pCA(pCA)
{
    m_cstrCAName = _T("");
    m_cstrDescription = _T("");
    m_cstrProvName = _T("");
    m_cstrHashAlg = _T("");

    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
    m_fRestartServer = FALSE;
    m_wRestart = 0;

	m_fWin2kCA = FALSE;

    CSASSERT(m_pCA);
    if (NULL == m_pCA)
        return;

    // add reference to m_pParentMachine
	// At one time, MMC didn't protect us from
	// going away while proppages were open
    m_pCA->m_pParentMachine->AddRef();

    m_pReleaseMe = NULL;

    m_cstrCAName = m_pCA->m_strCommonName;
    m_cstrDescription = m_pCA->m_strComment;

    m_pAdmin = NULL;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE1);
}

CSvrSettingsGeneralPage::~CSvrSettingsGeneralPage()
{
    if(m_pAdmin)
    {
        m_pAdmin->Release();
        m_pAdmin = NULL;
    }

    if(m_pCA->m_pParentMachine)
    {
        // remove refcount from m_pParentMachine
        m_pCA->m_pParentMachine->Release();
    }

    if (m_pReleaseMe)
    {
        m_pReleaseMe->Release();
        m_pReleaseMe = NULL;
    }
}

// replacement for DoDataExchange
BOOL CSvrSettingsGeneralPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrCAName.FromWindow(GetDlgItem(m_hWnd, IDC_CANAME));
	    m_cstrDescription.FromWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
        m_cstrProvName.FromWindow(GetDlgItem(m_hWnd, IDC_CSP_NAME));
	    m_cstrHashAlg.FromWindow(GetDlgItem(m_hWnd, IDC_HASHALG));
    }
    else
    {
        m_cstrCAName.ToWindow(GetDlgItem(m_hWnd, IDC_CANAME));
	    m_cstrDescription.ToWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
        m_cstrProvName.ToWindow(GetDlgItem(m_hWnd, IDC_CSP_NAME));
	    m_cstrHashAlg.ToWindow(GetDlgItem(m_hWnd, IDC_HASHALG));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CSvrSettingsGeneralPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_VIEW_CERT:
        if (BN_CLICKED == HIWORD(wParam))
            OnViewCert((HWND)lParam);
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsGeneralPage message handlers
BOOL CSvrSettingsGeneralPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    DWORD dwProvType, dwHashAlg;
    DWORD dwRet;
    BOOL  fShowErrPopup = TRUE;

    HWND hwndListCert;
    HWND hwndViewCert;
    DWORD cCertCount, dwCertIndex;
    VARIANT varPropertyValue;
    VariantInit(&varPropertyValue);

    variant_t var;

    //disable view button
    hwndViewCert = GetDlgItem(m_hWnd, IDC_VIEW_CERT);
    ::EnableWindow(hwndViewCert, FALSE);

    hwndListCert = GetDlgItem(m_hWnd, IDC_LIST_CERTS);

    dwRet = m_pCA->m_pParentMachine->GetAdmin2(&m_pAdmin);
    if (RPC_S_NOT_LISTENING == dwRet ||
        RPC_S_SERVER_UNAVAILABLE == dwRet)
    {
        //certsrv service is not running
        CString cstrMsg, cstrTitle;
        cstrMsg.LoadString(IDS_VIEW_CERT_NOT_RUNNING);
        cstrTitle.LoadString(IDS_MSG_TITLE);
        MessageBoxW(m_hWnd, cstrMsg, cstrTitle, MB_ICONEXCLAMATION);
        fShowErrPopup = FALSE;
    }
    _PrintIfError(dwRet, "GetAdmin");


    dwRet = m_pCA->GetConfigEntry(
                wszREGKEYCSP,
                wszREGPROVIDER,
                &var);
    _JumpIfError(dwRet, Ret, "GetConfigEntry");
    m_cstrProvName = V_BSTR(&var);
    var.Clear();

    dwRet = m_pCA->GetConfigEntry(
                wszREGKEYCSP,
                wszREGPROVIDERTYPE,
                &var);
    _JumpIfError(dwRet, Ret, "GetConfigEntry");
    dwProvType = V_I4(&var);
    var.Clear();

    dwRet = m_pCA->GetConfigEntry(
                wszREGKEYCSP,
                wszHASHALGORITHM,
                &var);
    _JumpIfError(dwRet, Ret, "GetConfigEntry");
    dwHashAlg = V_I4(&var);
    var.Clear();

    VERIFY (ERROR_SUCCESS ==
        CryptAlgToStr(&m_cstrHashAlg, m_cstrProvName, dwProvType, dwHashAlg) );

    if(m_pAdmin)
    {
	    // load certs here
	    dwRet = m_pAdmin->GetCAProperty(
		    m_pCA->m_bstrConfig,
		    CR_PROP_CASIGCERTCOUNT,
		    0, // (unused)
		    PROPTYPE_LONG, // PropType
		    CR_OUT_BINARY, // Flags
		    &varPropertyValue);
	    if (dwRet == RPC_E_VERSION_MISMATCH)
	    {
		    // if we're talking to a downlevel, keep same functionality as before: remove list
		    m_fWin2kCA = TRUE;
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_LIST_CERTS), FALSE);
		    dwRet = ERROR_SUCCESS;
		    goto Ret;
	    }
	    _JumpIfError(dwRet, Ret, "GetCAProperty");

	    // varPropertyValue.vt will be VT_I4
	    // varPropertyValue.lVal will be the CA signature cert count
	    if (VT_I4 != varPropertyValue.vt)
	    {
		dwRet = (DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		_JumpError(dwRet, Ret, "GetCAProperty");
	    }

	    cCertCount = varPropertyValue.lVal;

	    // now we have a max count; begin looping
	    for (dwCertIndex=0; dwCertIndex<cCertCount; dwCertIndex++)
	    {
		int iItemIndex;
		CString cstrItemName, cstrItemFmt;

		VariantClear(&varPropertyValue);

		// get each key's cert state
		dwRet = m_pAdmin->GetCAProperty(
			m_pCA->m_bstrConfig,
			CR_PROP_CACERTSTATE, //PropId
			dwCertIndex, //PropIndex
			PROPTYPE_LONG, // PropType
			CR_OUT_BINARY, // Flags
			&varPropertyValue);
		_JumpIfError(dwRet, Ret, "GetCAProperty");

		// varPropertyValue.vt will be VT_I4
		// varPropertyValue.lVal will be the cert state
		if (VT_I4 != varPropertyValue.vt)
		{
		    dwRet = (DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		    _JumpError(dwRet, Ret, "GetCAProperty");
		}

		// put identifying information into dialog depending on cert state
		switch(varPropertyValue.lVal)
		{
		    case CA_DISP_REVOKED:    // This Cert has been revoked.
			cstrItemFmt.LoadString(IDS_CA_CERT_LISTBOX_REVOKED);
			break;

		    case CA_DISP_VALID:      // This Cert is still valid
			cstrItemFmt.LoadString(IDS_CA_CERT_LISTBOX);
			break;

		    case CA_DISP_INVALID:    // This Cert has expired.
			cstrItemFmt.LoadString(IDS_CA_CERT_LISTBOX_EXPIRED);
			break;

		    case CA_DISP_ERROR:
		    // CA_DISP_ERROR means the Cert for that index is missing.
		    default:
			continue;
		}

		// sprintf the cert # into the string
		cstrItemName.Format(cstrItemFmt, dwCertIndex);

		iItemIndex = (INT)::SendMessage(hwndListCert, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)cstrItemName);
		// add cert # as item data
		::SendMessage(hwndListCert, LB_SETITEMDATA, iItemIndex, (LPARAM)dwCertIndex);

		// in future, maybe we should load Certs here, suck out extra info to display,

		iItemIndex++;
	    }

        if (0 < dwCertIndex)
        {
            int c = (int) ::SendMessage(hwndListCert, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

            //select last one
            if (LB_ERR != c)
                ::SendMessage(hwndListCert, LB_SETCURSEL, (WPARAM)(c-1), (LPARAM)0);

            //enable view button
            ::EnableWindow(hwndViewCert, TRUE);
        }
    }
    else
    {
        CString strDataUnavailable;
        strDataUnavailable.LoadString(IDS_DATA_UNAVAILABLE);
        SendMessage(hwndListCert, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)strDataUnavailable);
    }

    UpdateData(FALSE);
Ret:
    var.Clear();
    VariantClear(&varPropertyValue);

    if (fShowErrPopup && ERROR_SUCCESS != dwRet)
		DisplayGenericCertSrvError(m_hWnd, dwRet);

    return TRUE;
}

void CSvrSettingsGeneralPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}

void CSvrSettingsGeneralPage::OnViewCert(HWND hwndCtrl)
{
    CRYPTUI_VIEWCERTIFICATE_STRUCTW sViewCert;
    ZeroMemory(&sViewCert, sizeof(sViewCert));
    HCERTSTORE rghStores[2];    // don't bother closing these stores
	BSTR bstrCert; ZeroMemory(&bstrCert, sizeof(BSTR));
    PBYTE pbCert = NULL;
    DWORD cbCert;
    BOOL  fShowErrPopup = TRUE;

	DWORD dw = ERROR_SUCCESS;
	ICertRequest* pIRequest = NULL;

	if (m_fWin2kCA)
	{
		dw = CoCreateInstance(
				CLSID_CCertRequest,
				NULL,		// pUnkOuter
				CLSCTX_INPROC_SERVER,
				IID_ICertRequest,
				(VOID **) &pIRequest);

		// get this cert
		dw = pIRequest->GetCACertificate(FALSE, _bstr_t(m_pCA->m_strConfig), CR_IN_BINARY, &bstrCert);
        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == (HRESULT)dw)
        {
            //possible certsrv service is not running but access deny
            //is very confusing error code, so use our own display text
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_VIEW_CERT_DENY_ERROR);
            cstrTitle.LoadString(IDS_MSG_TITLE);
            MessageBoxW(hwndCtrl, cstrMsg, cstrTitle, MB_OK);
            fShowErrPopup = FALSE;
        }
		_JumpIfError(dw, Ret, "GetCACertificate");

		cbCert = SysStringByteLen(bstrCert);
		pbCert = (PBYTE)bstrCert;

		sViewCert.pCertContext = CertCreateCertificateContext(
			CRYPT_ASN_ENCODING,
			pbCert,
			cbCert);
		if (sViewCert.pCertContext == NULL)
		{
			dw = GetLastError();
			_JumpError(dw, Ret, "CertCreateCertificateContext");
		}
	}
	else
	{
		VARIANT varPropertyValue;
		VariantInit(&varPropertyValue);
		int iCertIndex = 0;

		// get cert # from item data
		HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_CERTS);
		DWORD dwSel = (DWORD)::SendMessage(hwndList, LB_GETCURSEL, 0, 0);
		if (LB_ERR == dwSel)
			goto Ret;

		iCertIndex = (int)::SendMessage(hwndList, LB_GETITEMDATA, (WPARAM)dwSel, 0);

		// get the Cert
		dw = m_pCA->GetCACertByKeyIndex(&(sViewCert.pCertContext), iCertIndex);
        if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == (HRESULT)dw)
        {
            //possible certsrv service is not running but access deny
            //is very confusing error code, so use our own display text
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_VIEW_CERT_DENY_ERROR);
            cstrTitle.LoadString(IDS_MSG_TITLE);
            MessageBoxW(hwndCtrl, cstrMsg, cstrTitle, MB_OK);
            fShowErrPopup = FALSE;
        }
        else if (RPC_S_NOT_LISTENING == dw ||
                 RPC_S_SERVER_UNAVAILABLE == dw)
        {
            //certsrv service is not running
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_VIEW_CERT_NOT_RUNNING);
            cstrTitle.LoadString(IDS_MSG_TITLE);
            MessageBoxW(hwndCtrl, cstrMsg, cstrTitle, MB_OK);
            fShowErrPopup = FALSE;
        }
		_JumpIfError(dw, Ret, "GetCACertByKeyIndex");
	}

    sViewCert.hwndParent = m_hWnd;
    sViewCert.dwSize = sizeof(sViewCert);
    sViewCert.dwFlags = CRYPTUI_ENABLE_REVOCATION_CHECKING | CRYPTUI_DISABLE_ADDTOSTORE;   // this is not the place to allow installs (kelviny discussion 12/11/98)

    // if we're opening remotely, don't open local stores
    if (! m_pCA->m_pParentMachine->IsLocalMachine())
    {
        // get remote stores
        dw = m_pCA->GetRootCertStore(&rghStores[0]);
        _PrintIfError(dw, "GetRootCertStore");

        if (S_OK == dw)
        {
            dw = m_pCA->GetCACertStore(&rghStores[1]);
            _PrintIfError(dw, "GetCACertStore");
        } 

        if (S_OK == dw)
        {
            // rely only on remote machine's stores
            sViewCert.cStores = 2;
            sViewCert.rghStores = rghStores;
            sViewCert.dwFlags |= CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
        }
        else
        {
            // tell user we're only doing this locally
            sViewCert.dwFlags |= CRYPTUI_WARN_REMOTE_TRUST;
        }
    }

    if (!CryptUIDlgViewCertificateW(&sViewCert, NULL))
    {
        dw = GetLastError();
		if (dw != ERROR_CANCELLED)
	        _JumpError(dw, Ret, "CryptUIDlgViewCertificateW");
    }

    dw = ERROR_SUCCESS;

Ret:
    VERIFY(CertFreeCertificateContext(sViewCert.pCertContext));

    if (bstrCert)
        SysFreeString(bstrCert);

    if (pIRequest)
        pIRequest->Release();

    if ((dw != ERROR_SUCCESS) && (dw != ERROR_CANCELLED) && fShowErrPopup)
        DisplayGenericCertSrvError(m_hWnd, dw);

}


BOOL CSvrSettingsGeneralPage::OnApply()
{
    return CAutoDeletePropPage::OnApply();
}

BOOL CSvrSettingsGeneralPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
        //handle double click on list items
        case IDC_LIST_CERTS:
            if (pnmh->code == NM_DBLCLK)
                OnViewCert(pnmh->hwndFrom);
            break;
    }
    return FALSE;
}

void CSvrSettingsGeneralPage::TryServiceRestart(WORD wPage)
{
    m_wRestart &= ~wPage; // whack off the page requesting this
    if (m_fRestartServer && (m_wRestart == 0))  // if we got a request to restart and all pages have agreed
    {

        if (RestartService(m_hWnd, m_pCA->m_pParentMachine))
        {
            MMCPropertyChangeNotify(m_hConsoleHandle, CERTMMC_PROPERTY_CHANGE_REFRESHVIEWS);
            m_fRestartServer = FALSE;
        }
    }
}


////
// 2
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsPolicyPage property page


RoleAccessToControl CSvrSettingsPolicyPage::sm_ControlToRoleMap[] = 
{
    { IDC_ACTIVE_MODULE,    CA_ACCESS_ADMIN },
};


CSvrSettingsPolicyPage::CSvrSettingsPolicyPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    :   CAutoDeletePropPage(uIDD),
        CRolesSupportInPropPage(
            pControlPage->m_pCA,
            sm_ControlToRoleMap,
            ARRAYSIZE(sm_ControlToRoleMap)),
        m_pControlPage(pControlPage)
{
    m_cstrModuleName = _T("");
    m_cstrModuleDescr = _T("");
    m_cstrModuleVersion = _T("");
    m_cstrModuleCopyright = _T("");

    m_bUpdate = FALSE;

    m_fLoadedActiveModule = FALSE;
    m_pszprogidPolicyModule = NULL;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE2);
}

CSvrSettingsPolicyPage::~CSvrSettingsPolicyPage()
{
    if (NULL != m_pszprogidPolicyModule)
    {
        CoTaskMemFree(m_pszprogidPolicyModule);
        m_pszprogidPolicyModule = NULL;
    }
}

// replacement for DoDataExchange
BOOL CSvrSettingsPolicyPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
	    m_cstrModuleDescr.FromWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
	    m_cstrModuleVersion.FromWindow(GetDlgItem(m_hWnd, IDC_VERSION));
	    m_cstrModuleCopyright.FromWindow(GetDlgItem(m_hWnd, IDC_COPYRIGHT));
    }
    else
    {
        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
	    m_cstrModuleDescr.ToWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
	    m_cstrModuleVersion.ToWindow(GetDlgItem(m_hWnd, IDC_VERSION));
	    m_cstrModuleCopyright.ToWindow(GetDlgItem(m_hWnd, IDC_COPYRIGHT));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL
CSvrSettingsPolicyPage::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    switch(LOWORD(wParam))
    {
    case IDC_ACTIVE_MODULE:
        if (BN_CLICKED == HIWORD(wParam))
            OnSetActiveModule();
        break;
    case IDC_CONFIGURE:
        if (BN_CLICKED == HIWORD(wParam))
            OnConfigureModule();
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


HRESULT CSvrSettingsPolicyPage::GetCurrentModuleProperties()
{
    HRESULT hr;
    CString cstrStoragePath;
    BOOL fGotName = FALSE;
    DISPATCHINTERFACE di;
    BOOL fMustRelease = FALSE;
    BSTR bstrTmp=NULL, bstrProperty=NULL, bstrStorageLoc = NULL;

    hr = GetPolicyManageDispatch(
        m_pszprogidPolicyModule,
        m_clsidPolicyModule,
        &di);
    _JumpIfError(hr, Ret, "GetPolicyManageDispatch");

    fMustRelease = TRUE;

    cstrStoragePath = wszREGKEYCONFIGPATH_BS;
    cstrStoragePath += m_pControlPage->m_pCA->m_strSanitizedName;
    cstrStoragePath += TEXT("\\");
    cstrStoragePath += wszREGKEYPOLICYMODULES;
    cstrStoragePath += TEXT("\\");
    cstrStoragePath += m_pszprogidPolicyModule;

    bstrStorageLoc = SysAllocString(cstrStoragePath);
    if(!bstrStorageLoc)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, Ret, "SysAllocString");
    }

    bstrProperty = SysAllocString(wszCMM_PROP_NAME);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    ////////////////////
    // NAME
    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleName = bstrTmp;
        fGotName = TRUE;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }
    else
    {
        // have a backup name to display: CLSID of interface?
        m_cstrModuleName = m_pszprogidPolicyModule;
        fGotName = TRUE;

        // now bail
        _JumpError(hr, Ret, "ManageModule_GetProperty");
    }

    ////////////////////
    // DESCRIPTION
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_DESCRIPTION);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleDescr = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }

    ////////////////////
    // COPYRIGHT
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_COPYRIGHT);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleCopyright = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }

    ////////////////////
    // FILEVER
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_FILEVER);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleVersion = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }
Ret:
    if (!fGotName)
    {
        if (CO_E_CLASSSTRING == hr)
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_POLICYMODULE_NOT_REGISTERED);
        }
        else
        {
            WCHAR const *pwsz = myGetErrorMessageText(hr, TRUE);

            m_cstrModuleName = pwsz;
	    if (NULL != pwsz)
	    {
		LocalFree(const_cast<WCHAR *>(pwsz));
	    }
        }
    }
    if (fMustRelease)
        ManageModule_Release(&di);

    if (bstrProperty)
        SysFreeString(bstrProperty);

    if (bstrStorageLoc)
        SysFreeString(bstrStorageLoc);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsPolicyPage message handlers
BOOL CSvrSettingsPolicyPage::OnInitDialog()
{
    HRESULT hr;
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    // thse should be emptied
    m_cstrModuleName.Empty();
    m_cstrModuleDescr.Empty();
    m_cstrModuleVersion.Empty();
    m_cstrModuleCopyright.Empty();

    hr = myGetActiveModule(
        m_pControlPage->m_pCA,
        TRUE,
        0,
        &m_pszprogidPolicyModule,  // CoTaskMem*
        &m_clsidPolicyModule);
    _JumpIfError(hr, Ret, "myGetActiveModule");

    hr = GetCurrentModuleProperties();
    _JumpIfError(hr, Ret, "GetCurrentModuleProperties");

Ret:
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_CONFIGURE), (hr == S_OK) );
    EnableControl(m_hWnd, IDC_ACTIVE_MODULE, TRUE );

    UpdateData(FALSE);
    return TRUE;
}

void CSvrSettingsPolicyPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
//    if (m_hConsoleHandle)
//        MMCFreeNotifyHandle(m_hConsoleHandle);
//    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}



void CSvrSettingsPolicyPage::OnConfigureModule()
{
    DWORD dw;
    DISPATCHINTERFACE di;
    ZeroMemory(&di, sizeof(DISPATCHINTERFACE));

    BOOL fMustRelease = FALSE;
    BSTR bstrStorageLoc = NULL;
    BSTR bstrVal = NULL;
    DWORD dwConfigFlags = (CA_ACCESS_ADMIN&m_pCA->GetMyRoles())?0:CMM_READONLY;

    do {

        dw = GetPolicyManageDispatch(
            m_pszprogidPolicyModule,
            m_clsidPolicyModule,
            &di);
        _PrintIfError(dw, "GetPolicyManageDispatch");
        if (ERROR_SUCCESS != dw)
            break;

        fMustRelease = TRUE;

        CString cstrStoragePath;
        cstrStoragePath = wszREGKEYCONFIGPATH_BS;
        cstrStoragePath += m_pControlPage->m_pCA->m_strSanitizedName;
        cstrStoragePath += TEXT("\\");
        cstrStoragePath += wszREGKEYPOLICYMODULES;
        cstrStoragePath += TEXT("\\");
        cstrStoragePath += m_pszprogidPolicyModule;

        bstrStorageLoc = SysAllocString(cstrStoragePath);
	if (NULL == bstrStorageLoc)
	{
	    dw = (DWORD) E_OUTOFMEMORY;
	    _JumpError(dw, Ret, "SysAllocString");
	}

        // Callbacks must be initialized whenever ManageModule_Configure is called
        dw = ThunkServerCallbacks(m_pControlPage->m_pCA);
        _JumpIfError(dw, Ret, "ThunkServerCallbacks");

        // pass an hwnd to the policy module -- this is an optional value
        bstrVal = SysAllocStringByteLen(NULL, sizeof(HWND));
	if (NULL == bstrVal)
	{
	    dw = (DWORD) E_OUTOFMEMORY;
	    _JumpError(dw, Ret, "SysAllocStringByteLen");
	}

        *(HWND*)(bstrVal) = m_hWnd;

        dw = ManageModule_SetProperty(
                &di,
                m_pControlPage->m_pCA->m_bstrConfig,
                bstrStorageLoc,
                const_cast<WCHAR*>(wszCMM_PROP_DISPLAY_HWND),
                0,
                PROPTYPE_BINARY,
                bstrVal);
        _PrintIfError(dw, "ManageModule_SetProperty(HWND)");

        dw = ManageModule_Configure(
                &di,
                m_pControlPage->m_pCA->m_bstrConfig,
                bstrStorageLoc,
                dwConfigFlags);
        _PrintIfError(dw, "ManageModule_Configure");

    } while(0);

    if (S_OK != dw)
        DisplayGenericCertSrvError(m_hWnd, dw);

Ret:
    if (fMustRelease)
        ManageModule_Release(&di);

    if (bstrStorageLoc)
        ::SysFreeString(bstrStorageLoc);

    if (bstrVal)
        ::SysFreeString(bstrVal);
}

typedef struct _PRIVATE_DLGPROC_MODULESELECT_LPARAM
{
    BOOL        fIsPolicyModuleSelection;
    CertSvrCA*  pCA;

    LPOLESTR*   ppszProgIDModule;
    CLSID*      pclsidModule;

} PRIVATE_DLGPROC_MODULESELECT_LPARAM, *PPRIVATE_DLGPROC_MODULESELECT_LPARAM;

void CSvrSettingsPolicyPage::OnSetActiveModule()
{
    DWORD dwErr;

    // get currently active module
    PRIVATE_DLGPROC_MODULESELECT_LPARAM    sParam;
    ZeroMemory(&sParam, sizeof(sParam));

    sParam.fIsPolicyModuleSelection = TRUE;
    sParam.pCA = m_pControlPage->m_pCA;

    sParam.ppszProgIDModule = &m_pszprogidPolicyModule;
    sParam.pclsidModule = &m_clsidPolicyModule;

    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_CHOOSE_MODULE),
            m_hWnd,
            dlgProcChooseModule,
            (LPARAM)&sParam);

    // translate ok/cancel into error codes
    if (IDOK == dwErr)
    {
        // dirty bit
        m_pControlPage->NeedServiceRestart(SERVERSETTINGS_PROPPAGE_POLICY);
        SetModified(TRUE);
        m_bUpdate = TRUE;
        GetCurrentModuleProperties();
        UpdateData(FALSE);
    }

    if ((dwErr != IDOK) && (dwErr != IDCANCEL))
    {
        _PrintIfError(dwErr, "dlgProcChooseModule");
        DisplayGenericCertSrvError(m_hWnd, dwErr);
    }

    return;
}

BOOL CSvrSettingsPolicyPage::OnApply()
{
    if (m_bUpdate)
    {
        if (NULL != m_pszprogidPolicyModule)
        {
            HRESULT hr;
            variant_t var;

            var = m_pszprogidPolicyModule;
            // now we have the chosen uuid -- set as default in registry
            hr = m_pControlPage->m_pCA->SetConfigEntry(
                wszREGKEYPOLICYMODULES,
                wszREGACTIVE,
                &var);

            if (hr != S_OK)
            {
                DisplayGenericCertSrvError(m_hWnd, hr);
                return FALSE;
            }
        }

        m_bUpdate = FALSE;
        m_pControlPage->TryServiceRestart(SERVERSETTINGS_PROPPAGE_POLICY);
    }


    return CAutoDeletePropPage::OnApply();
}



void ClearModuleDefn(PCOM_CERTSRV_MODULEDEFN pMod)
{
    if (pMod)
    {
        if (pMod->szModuleProgID)
            CoTaskMemFree(pMod->szModuleProgID);
        ZeroMemory(pMod, sizeof(COM_CERTSRV_MODULEDEFN));
    }
}

////
// 3
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsExitPage property page

RoleAccessToControl CSvrSettingsExitPage::sm_ControlToRoleMap[] = 
{
    { IDC_ADD_MODULE,       CA_ACCESS_ADMIN },
    { IDC_REMOVE_MODULE,    CA_ACCESS_ADMIN },
};

CSvrSettingsExitPage::CSvrSettingsExitPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    :   CAutoDeletePropPage(uIDD), 
        CRolesSupportInPropPage(
            pControlPage->m_pCA,
            sm_ControlToRoleMap,
            ARRAYSIZE(sm_ControlToRoleMap)),
        m_pControlPage(pControlPage)
{
    m_cstrModuleName = _T("");
    m_cstrModuleDescr = _T("");
    m_cstrModuleVersion = _T("");
    m_cstrModuleCopyright = _T("");

    m_bUpdate = FALSE;

    m_fLoadedActiveModule = FALSE;
    m_iSelected = -1;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE3);
}

CSvrSettingsExitPage::~CSvrSettingsExitPage()
{
    int i;
    for(i=0; i<m_arrExitModules.GetSize(); i++)
    {
#pragma warning(push)		// BUGBUG: nonstandard extension used : class rvalue used as lvalue
#pragma warning(disable: 4238)	// BUGBUG: nonstandard extension used : class rvalue used as lvalue
        ClearModuleDefn(&m_arrExitModules[i]);
#pragma warning(pop)	// BUGBUG: nonstandard extension used : class rvalue used as lvalue
    }
}

// replacement for DoDataExchange
BOOL CSvrSettingsExitPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
        m_cstrModuleDescr.FromWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
        m_cstrModuleVersion.FromWindow(GetDlgItem(m_hWnd, IDC_VERSION));
        m_cstrModuleCopyright.FromWindow(GetDlgItem(m_hWnd, IDC_COPYRIGHT));
    }
    else
    {
        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
        m_cstrModuleDescr.ToWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION));
        m_cstrModuleVersion.ToWindow(GetDlgItem(m_hWnd, IDC_VERSION));
        m_cstrModuleCopyright.ToWindow(GetDlgItem(m_hWnd, IDC_COPYRIGHT));

        // if 0 modules, disable REMOVE button
        EnableControl(m_hWnd, IDC_REMOVE_MODULE, (0 != m_arrExitModules.GetSize()));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CSvrSettingsExitPage::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    switch(LOWORD(wParam))
    {
    case IDC_ADD_MODULE:
    case IDC_ACTIVE_MODULE:
        if (BN_CLICKED == HIWORD(wParam))
            OnAddActiveModule();
        break;
    case IDC_CONFIGURE:
        if (BN_CLICKED == HIWORD(wParam))
            OnConfigureModule();
        break;
    case IDC_REMOVE_MODULE:
        if (BN_CLICKED == HIWORD(wParam))
            OnRemoveActiveModule();
        break;
    case IDC_EXIT_LIST:
        if (LBN_SELCHANGE == HIWORD(wParam))
        {
            m_iSelected = (int)SendMessage(GetDlgItem(m_hWnd, IDC_EXIT_LIST), LB_GETCURSEL, 0, 0);
            UpdateSelectedModule();
            break;
        }
    default:
        return FALSE;
        break;
    }
    return TRUE;
}

BOOL CSvrSettingsExitPage::UpdateSelectedModule()
{
    HRESULT hr;
    BOOL fGotName = FALSE;
    DISPATCHINTERFACE di;
    BOOL fMustRelease = FALSE;
    CString cstrStoragePath;

    // empty any strings
    m_cstrModuleName.Empty();
    m_cstrModuleDescr.Empty();
    m_cstrModuleVersion.Empty();
    m_cstrModuleCopyright.Empty();

    BSTR bstrTmp=NULL, bstrProperty=NULL, bstrStorageLoc = NULL;
    // no exit module
    if (0 == m_arrExitModules.GetSize())
    {
        hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
        _JumpError(hr, Ret, "m_pszprogidExitManage");
    }
    CSASSERT(m_iSelected != -1);

    CSASSERT(m_iSelected <= m_arrExitModules.GetUpperBound());
    if (m_iSelected > m_arrExitModules.GetUpperBound())
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, Ret, "m_iSelected > m_arrExitModules.GetUpperBound()");
    }

    cstrStoragePath = wszREGKEYCONFIGPATH_BS;
    cstrStoragePath += m_pControlPage->m_pCA->m_strSanitizedName;
    cstrStoragePath += TEXT("\\");
    cstrStoragePath += wszREGKEYEXITMODULES;
    cstrStoragePath += TEXT("\\");
    cstrStoragePath += m_arrExitModules[m_iSelected].szModuleProgID; //m_pszprogidExitModule;

    bstrStorageLoc = SysAllocString(cstrStoragePath);
    _JumpIfOutOfMemory(hr, Ret, bstrStorageLoc);

    hr = GetExitManageDispatch(
            m_arrExitModules[m_iSelected].szModuleProgID,
            m_arrExitModules[m_iSelected].clsidModule, 
            &di);
    _JumpIfErrorStr(hr, Ret, "GetExitManageDispatch", m_arrExitModules[m_iSelected].szModuleProgID);
    
    fMustRelease = TRUE;

    bstrProperty = SysAllocString(wszCMM_PROP_NAME);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    ////////////////////
    // NAME
    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleName = bstrTmp;
        fGotName = TRUE;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }
    else
    {
        // have a backup name to display: CLSID of interface?
        m_cstrModuleName = m_arrExitModules[m_iSelected].szModuleProgID;
        fGotName = TRUE;

        // bail
        _JumpError(hr, Ret, "ManageModule_GetProperty");
    }

    ////////////////////
    // DESCRIPTION
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_DESCRIPTION);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleDescr = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }

    ////////////////////
    // COPYRIGHT
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_COPYRIGHT);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleCopyright = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }


    ////////////////////
    // FILEVER
    SysFreeString(bstrProperty);
    bstrProperty = SysAllocString(wszCMM_PROP_FILEVER);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    hr = ManageModule_GetProperty(
            &di,
            m_pControlPage->m_pCA->m_bstrConfig,
            bstrStorageLoc,
            bstrProperty,
            0,
            PROPTYPE_STRING,
            &bstrTmp);
    if ((S_OK == hr) && (NULL != bstrTmp))
    {
        myRegisterMemAlloc(bstrTmp, -1, CSM_SYSALLOC);
        m_cstrModuleVersion = bstrTmp;
        SysFreeString(bstrTmp);
        bstrTmp = NULL;
    }


Ret:
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_CONFIGURE), (hr == S_OK) );
    EnableControl(m_hWnd, IDC_ADD_MODULE, TRUE);

    if (!fGotName)
    {
        if (HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND) == hr)
        {
            m_cstrModuleName.LoadString(IDS_NO_EXIT_MODULE);
        }
        else if (CO_E_CLASSSTRING == hr)
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_EXITMODULE_NOT_REGISTERED);
        }
        else
        {
            WCHAR const *pwsz = myGetErrorMessageText(hr, TRUE);

            m_cstrModuleName = pwsz;
	    if (NULL != pwsz)
	    {
		LocalFree(const_cast<WCHAR *>(pwsz));
	    }
        }
    }

    if (fMustRelease)
        ManageModule_Release(&di);

    if (bstrProperty)
        SysFreeString(bstrProperty);

    if (bstrStorageLoc)
        SysFreeString(bstrStorageLoc);


    UpdateData(FALSE);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsExitPage message handlers
BOOL CSvrSettingsExitPage::OnInitDialog()
{
    HRESULT hr;

    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    if (!m_fLoadedActiveModule)
    {
        m_fLoadedActiveModule = TRUE;

        // load all of the modules
        for (int i=0; ; i++)
        {
            COM_CERTSRV_MODULEDEFN sModule;
            ZeroMemory(&sModule, sizeof(sModule));

            hr = myGetActiveModule(
                m_pControlPage->m_pCA,
                FALSE,
                i,
                &sModule.szModuleProgID,  // CoTaskMem*
                &sModule.clsidModule);
            _PrintIfError(hr, "myGetActiveModule");
            if (hr != S_OK)
                break;

            m_arrExitModules.Add(sModule);
        }

        m_iSelected = 0;    // select 1st element
    }

    InitializeExitLB();

    UpdateSelectedModule();

    UpdateData(FALSE);
    return TRUE;
}

void CSvrSettingsExitPage::OnConfigureModule()
{
    DWORD dw;
    DISPATCHINTERFACE di;
    BOOL fMustRelease = FALSE;
    BSTR bstrStorageLoc = NULL;
    BSTR bstrVal = NULL;
    DWORD dwConfigFlags = (CA_ACCESS_ADMIN&m_pCA->GetMyRoles())?0:CMM_READONLY;

    CSASSERT(m_iSelected <= m_arrExitModules.GetUpperBound());
    if (m_iSelected > m_arrExitModules.GetUpperBound())
    {
        dw = (DWORD) E_UNEXPECTED;
        _JumpError(dw, Ret, "m_iSelected > m_arrExitModules.GetUpperBound()");
    }

    if (NULL == m_arrExitModules[m_iSelected].szModuleProgID)
    {
        dw = ERROR_MOD_NOT_FOUND;
        _JumpError(dw, Ret, "m_pszprogidExitManage");
    }

    do {    // not a loop
        dw = GetExitManageDispatch(
                m_arrExitModules[m_iSelected].szModuleProgID,
                m_arrExitModules[m_iSelected].clsidModule, 
                &di);
        _PrintIfErrorStr(dw, "GetExitManageDispatch", m_arrExitModules[m_iSelected].szModuleProgID);
        if (ERROR_SUCCESS != dw)
            break;
        fMustRelease = TRUE;

        CString cstrStoragePath;
        cstrStoragePath = wszREGKEYCONFIGPATH_BS;
        cstrStoragePath += m_pControlPage->m_pCA->m_strSanitizedName;
        cstrStoragePath += TEXT("\\");
        cstrStoragePath += wszREGKEYEXITMODULES;
        cstrStoragePath += TEXT("\\");
        cstrStoragePath += m_arrExitModules[m_iSelected].szModuleProgID;//m_pszprogidExitModule;

        bstrStorageLoc = SysAllocString(cstrStoragePath);
	if (NULL == bstrStorageLoc)
	{
	    dw = (DWORD) E_OUTOFMEMORY;
	    _JumpError(dw, Ret, "SysAllocString");
	}

        // Callbacks must be initialized whenever ManageModule_Configure is called
        dw = ThunkServerCallbacks(m_pControlPage->m_pCA);
        _JumpIfError(dw, Ret, "ThunkServerCallbacks");

        // pass an hwnd to the exit module -- this is an optional value
        bstrVal = SysAllocStringByteLen(NULL, sizeof(HWND));
	if (NULL == bstrVal)
	{
	    dw = (DWORD) E_OUTOFMEMORY;
	    _JumpError(dw, Ret, "SysAllocStringByteLen");
	}

        *(HWND*)(bstrVal) = m_hWnd;

        dw = ManageModule_SetProperty(
                &di,
                m_pControlPage->m_pCA->m_bstrConfig,
                bstrStorageLoc,
                const_cast<WCHAR*>(wszCMM_PROP_DISPLAY_HWND),
                0,
                PROPTYPE_BINARY,
                bstrVal);
        _PrintIfError(dw, "ManageModule_SetProperty(HWND)");

        dw = ManageModule_Configure(
                &di,
                m_pControlPage->m_pCA->m_bstrConfig,
                bstrStorageLoc,
                dwConfigFlags);
        _PrintIfError(dw, "ManageModule_Configure");

    } while(0);

    if (S_OK != dw)
        DisplayGenericCertSrvError(m_hWnd, dw);

Ret:
    if (fMustRelease)
        ManageModule_Release(&di);

    if (bstrStorageLoc)
        ::SysFreeString(bstrStorageLoc);

    if (bstrVal)
        ::SysFreeString(bstrVal);
}

void CSvrSettingsExitPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
//    if (m_hConsoleHandle)
//        MMCFreeNotifyHandle(m_hConsoleHandle);
//    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}

HRESULT CSvrSettingsExitPage::InitializeExitLB()
{
    HRESULT hr=S_OK;
    SendMessage(GetDlgItem(m_hWnd, IDC_EXIT_LIST), LB_RESETCONTENT, 0, 0);

    int i;

    BSTR bstrProperty = SysAllocString(wszCMM_PROP_NAME);
    _JumpIfOutOfMemory(hr, Ret, bstrProperty);

    for (i=0; i< m_arrExitModules.GetSize(); i++)
    {
	LPWSTR pszDisplayString = m_arrExitModules[i].szModuleProgID; // by default, display progid

        BSTR bstrName = NULL;
        DISPATCHINTERFACE di;

        // attempt to create object (locally)
        hr = GetExitManageDispatch(
                m_arrExitModules[i].szModuleProgID,
                m_arrExitModules[i].clsidModule, 
                &di);
        _PrintIfErrorStr(hr, "GetExitManageDispatch", m_arrExitModules[i].szModuleProgID);

        if (hr == S_OK)
        {
            // get name property
            hr = ManageModule_GetProperty(&di, m_pControlPage->m_pCA->m_bstrConfig, L"", bstrProperty, 0, PROPTYPE_STRING, &bstrName);
            _PrintIfError(hr, "ManageModule_GetProperty");

            // output successful display string
            if (hr == S_OK && bstrName != NULL)
            {
                myRegisterMemAlloc(bstrName, -1, CSM_SYSALLOC);
                pszDisplayString = bstrName;
            }

            ManageModule_Release(&di);
        }

        SendMessage(GetDlgItem(m_hWnd, IDC_EXIT_LIST), LB_ADDSTRING, 0, (LPARAM)pszDisplayString);
        if (bstrName)
            SysFreeString(bstrName);
    }

Ret:

    if (m_iSelected >= 0)
        SendMessage(GetDlgItem(m_hWnd, IDC_EXIT_LIST), LB_SETCURSEL, m_iSelected, 0);


    if (bstrProperty)
        SysFreeString(bstrProperty);

    return hr;
}

void CSvrSettingsExitPage::OnAddActiveModule()
{
    DWORD dwErr;
    COM_CERTSRV_MODULEDEFN sModule;
    ZeroMemory(&sModule, sizeof(sModule));

    // get currently active module
    PRIVATE_DLGPROC_MODULESELECT_LPARAM    sParam;
    ZeroMemory(&sParam, sizeof(sParam));

    sParam.fIsPolicyModuleSelection = FALSE;
    sParam.pCA = m_pControlPage->m_pCA;

    // don't support hilighting the active modules (there may be multiple)
    sParam.ppszProgIDModule = &sModule.szModuleProgID;
    sParam.pclsidModule = &sModule.clsidModule;

    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_CHOOSE_MODULE),
            m_hWnd,
            dlgProcChooseModule,
            (LPARAM)&sParam);

    // translate ok/cancel into error codes
    if (IDOK == dwErr)
    {
        // add to array...IFF not duplicate
        for (int i=0; i<m_arrExitModules.GetSize(); i++)
        {
#pragma warning(push)		// BUGBUG: nonstandard extension used : class rvalue used as lvalue
#pragma warning(disable: 4238)	// BUGBUG: nonstandard extension used : class rvalue used as lvalue
            if (0 == memcmp(&sModule.clsidModule, &m_arrExitModules[i].clsidModule, sizeof(CLSID)) )
#pragma warning(pop)	// BUGBUG: nonstandard extension used : class rvalue used as lvalue
                break;
        }
        if (m_arrExitModules.GetSize() == i)
        {
            m_iSelected = m_arrExitModules.Add(sModule);

            OnInitDialog();
            SetModified(TRUE);
            m_bUpdate = TRUE;
            m_pControlPage->NeedServiceRestart(SERVERSETTINGS_PROPPAGE_EXIT);
        }
    }

    if ((dwErr != IDOK) && (dwErr != IDCANCEL))
    {
        _PrintIfError(dwErr, "dlgProcChooseModule");
        DisplayGenericCertSrvError(m_hWnd, dwErr);
    }

    return;
}

void CSvrSettingsExitPage::OnRemoveActiveModule()
{
    if (m_iSelected != -1)
    {
#pragma warning(push)		// BUGBUG: nonstandard extension used : class rvalue used as lvalue
#pragma warning(disable: 4238)	// BUGBUG: nonstandard extension used : class rvalue used as lvalue
        ClearModuleDefn(&m_arrExitModules[m_iSelected]);
#pragma warning(pop)	// BUGBUG: nonstandard extension used : class rvalue used as lvalue
        m_arrExitModules.RemoveAt(m_iSelected);

        m_iSelected--;  // will either go to previous in list or -1 (NONE)
        if ((m_iSelected == -1) && (m_arrExitModules.GetSize() != 0))   // if NONE and there are still modules
            m_iSelected = 0;    // select the first one

        OnInitDialog();
        SetModified(TRUE);
        m_bUpdate = TRUE;
        m_pControlPage->NeedServiceRestart(SERVERSETTINGS_PROPPAGE_EXIT);
    }

    return;
}

BOOL CSvrSettingsExitPage::OnApply()
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sab;
    SAFEARRAY* psa = NULL; // no cleanup, will be deleted by ~variant_t
    BSTR bstr = NULL;
    variant_t var;
    LONG i;

    if (m_bUpdate)
    {

        sab.cElements = m_arrExitModules.GetSize();
        sab.lLbound = 0;

        psa = SafeArrayCreate(
                            VT_BSTR,
                            1,
                            &sab);
        if(!psa)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "SafeArrayCreate");
        }

        for (i=0; i<m_arrExitModules.GetSize(); i++)
        {
            if(!ConvertWszToBstr(
                    &bstr,
                    m_arrExitModules[i].szModuleProgID,
                    -1))
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "ConvertWszToBstr");
            }

            hr = SafeArrayPutElement(psa, (LONG*)&i, bstr);
            _JumpIfError(hr, error, "SafeArrayPutElement");

            SysFreeString(bstr);
            bstr = NULL;
        }

       V_VT(&var) = VT_ARRAY|VT_BSTR;
       V_ARRAY(&var) = psa;
       psa = NULL;

        // NOTE: could be NULL (no exit module)
        hr = m_pControlPage->m_pCA->SetConfigEntry(
            wszREGKEYEXITMODULES,
            wszREGACTIVE,
            &var);
        _PrintIfError(hr, "SetConfigEntry");

        m_bUpdate = FALSE;

        m_pControlPage->TryServiceRestart(SERVERSETTINGS_PROPPAGE_EXIT);

        OnInitDialog();
    }

error:
    if(psa)
        SafeArrayDestroy(psa);
    if(bstr)
        SysFreeString(bstr);

    if(S_OK!=hr)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}


////
// 4
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsExtensionPage property page

HRESULT
AddURLNode(
    IN CSURLTEMPLATENODE **ppURLList,
    IN CSURLTEMPLATENODE *pURLNode)
{
    HRESULT  hr = S_OK;
    CSASSERT(NULL != ppURLList);
    CSASSERT(NULL == pURLNode->pNext);

    if (NULL == *ppURLList)
    {
        //empty list currently
        *ppURLList = pURLNode;
    }
    else
    {
        CSURLTEMPLATENODE *pURLList = *ppURLList;
        //find the end
        while (NULL != pURLList->pNext)
        {
            pURLList = pURLList->pNext;
        }
        //add to the end
        pURLList->pNext = pURLNode;
    }

    return hr;
}

ENUM_URL_TYPE rgAllPOSSIBLE_URL_PREFIXES[] =
{
    URL_TYPE_HTTP,
    URL_TYPE_FILE,
    URL_TYPE_LDAP,
    URL_TYPE_FTP,
};

HRESULT
BuildURLListFromStrings(
    IN VARIANT &varURLs,
    OUT CSURLTEMPLATENODE **ppURLList)
{
    HRESULT  hr;
    CSURLTEMPLATENODE *pURLList = NULL;
    CSURLTEMPLATENODE *pURLNode = NULL;
    WCHAR *pwsz; // no free
    WCHAR const *pwszURL;
    DWORD  dwFlags;
    ENUM_URL_TYPE  UrlType;

    CSASSERT(V_VT(&varURLs)==(VT_ARRAY|VT_BSTR));
    CSASSERT(NULL != ppURLList);

    // init
    *ppURLList = NULL;

    SafeArrayEnum<BSTR> saenum(V_ARRAY(&varURLs));

    while(S_OK==saenum.Next(pwsz))
    {
        dwFlags = _wtoi(pwsz);
        pwszURL = pwsz;
        while (pwszURL && iswdigit(*pwszURL))
        {
            pwszURL++;
        }
        if (pwszURL > pwsz && L':' == *pwszURL)
        {
            // ok, one url, create a new node
            pURLNode = (CSURLTEMPLATENODE*)LocalAlloc(
                                LMEM_FIXED | LMEM_ZEROINIT,
                                sizeof(CSURLTEMPLATENODE));
            if (NULL == pURLNode)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }
            // skip :
            ++pwszURL;

            // translate %1 -> <CAName> etc.
            hr = ExpandDisplayString(pwszURL, &pURLNode->URLTemplate.pwszURL);
            _JumpIfError(hr, error, "ExpandDisplayString");

/*
            pURLNode->URLTemplate.pwszURL = (WCHAR*)LocalAlloc(
                                LMEM_FIXED,
                                (wcslen(pwszURL) + 1) * sizeof(WCHAR));
            if (NULL == pURLNode->URLTemplate.pwszURL)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }
            wcscpy(pURLNode->URLTemplate.pwszURL, pwszURL);
*/
            pURLNode->URLTemplate.Flags = dwFlags;

            //determine url type and assign enable mask
            UrlType = DetermineURLType(
                        rgAllPOSSIBLE_URL_PREFIXES,
                        ARRAYSIZE(rgAllPOSSIBLE_URL_PREFIXES),
                        pURLNode->URLTemplate.pwszURL);
            pURLNode->EnableMask = DetermineURLEnableMask(UrlType);

            hr = AddURLNode(&pURLList, pURLNode);
            _JumpIfError(hr , error, "AddURLNode");
        }
    }

    //out
    *ppURLList = pURLList;

    hr = S_OK;
error:
    return hr;
}

HRESULT
BuildURLStringFromList(
    IN CSURLTEMPLATENODE *pURLList,
    OUT VARIANT          *pvarURLs)
{
    HRESULT hr = S_OK;
    WCHAR wszFlags[10];
    LPWSTR pwszURL = NULL;
    CSURLTEMPLATENODE *pURLNode = pURLList;
    DWORD dwMaxSize = 0;
    DWORD cURLs = 0;
    SAFEARRAYBOUND rgsabound[1];
    SAFEARRAY * psa = NULL;
    long i;

    CSASSERT(NULL != pvarURLs);
    // init

    VariantInit(pvarURLs);

    while (NULL != pURLNode)
    {
        DWORD dwSize;
        wsprintf(wszFlags, L"%d", pURLNode->URLTemplate.Flags);
        dwSize = wcslen(wszFlags) +1;

        // ASSUMPTION
        // %1..%14 will always be = or smaller than shortest <CAName> token
        dwSize += wcslen(pURLNode->URLTemplate.pwszURL) +1;

        // otherwise, run code below
/*
        pszThrowAway = NULL;
        hr = ContractDisplayString(pURLNode->URLTemplate.pwszURL, &pszSizeComputation);
        _JumpIfError(hr, error, "ContractDisplayString");

        dwSize += wcslen(pszSizeComputation) + 1;
        if (NULL != pszSizeComputation)
            LocalFree(pszSizeComputation);
*/
        if(dwSize>dwMaxSize)
            dwMaxSize = dwSize;
        pURLNode = pURLNode->pNext;
        cURLs++;
    }

    pwszURL = (WCHAR*)LocalAlloc(LMEM_FIXED, dwMaxSize * sizeof(WCHAR));
    if (NULL == pwszURL)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cURLs;

    psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
    if(!psa)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "SafeArrayCreate");
    }

    pURLNode = pURLList;
    i=0;
    while (NULL != pURLNode)
    {
        variant_t vtURL;

        //  translate <CAName> ... to %1
        LPWSTR szContracted = NULL;
        hr = ContractDisplayString(pURLNode->URLTemplate.pwszURL, &szContracted);
        _JumpIfError(hr, error, "ContractDisplayString");

        ASSERT(wcslen(szContracted) <= wcslen(pURLNode->URLTemplate.pwszURL)); // otherwise our assumption above doesn't hold

        wsprintf(pwszURL, L"%d:%ws",
            pURLNode->URLTemplate.Flags,
            szContracted);

        // free the tmp
        if (NULL != szContracted)
            LocalFree(szContracted);

        vtURL = pwszURL;

        hr = SafeArrayPutElement(psa, &i, V_BSTR(&vtURL));
        _JumpIfError(hr, error, "LocalAlloc");

        pURLNode = pURLNode->pNext;
        i++;
    }

    V_VT(pvarURLs) = VT_ARRAY|VT_BSTR;
    V_ARRAY(pvarURLs) = psa;

//done:
    hr = S_OK;
error:

    if(S_OK!=hr && psa)
    {
        SafeArrayDestroy(psa);
    }
    LOCAL_FREE(pwszURL);
    return hr;
}

void
FreeURLNode(
    IN CSURLTEMPLATENODE *pURLNode)
{
    CSASSERT(NULL != pURLNode);

    if (NULL != pURLNode->URLTemplate.pwszURL)
    {
        LocalFree(pURLNode->URLTemplate.pwszURL);
    }
}

void
FreeURLList(
    IN CSURLTEMPLATENODE *pURLList)
{
    CSASSERT(NULL != pURLList);

    // assume pURLList is always the 1st node
    CSURLTEMPLATENODE *pURLNode = pURLList;

    while (NULL != pURLNode)
    {
        FreeURLNode(pURLNode);
        pURLNode = pURLNode->pNext;
    }

    LocalFree(pURLList);
}

HRESULT
RemoveURLNode(
    IN OUT CSURLTEMPLATENODE **ppURLList,
    IN CSURLTEMPLATENODE *pURLNode)
{
    HRESULT hr;
    // assume pURLList is always the 1st node
    CSURLTEMPLATENODE *pURLList = *ppURLList;
    BOOL fFound = FALSE;

    if (pURLList == pURLNode)
    {
        //happen want to remove 1st one
        //update the list head
        *ppURLList = pURLList->pNext;
        fFound = TRUE;
    }
    else
    {
        while (pURLList->pNext != NULL)
        {
            if (pURLList->pNext == pURLNode)
            {
                // found it
                fFound = TRUE;
                if (NULL == pURLNode->pNext)
                {
                    // happen removed node is the last
                    // fix the end
                    pURLList->pNext = NULL;
                }
                else
                {
                    // remove the node
                    pURLList->pNext = pURLList->pNext->pNext;
                }
                // out of while loop
                break;
            }
            // go next
            pURLList = pURLList->pNext;
        }
    }

    if (!fFound)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "orphan node");
    }
    // remove the node
    FreeURLNode(pURLNode);

    hr = S_OK;
error:
    return hr;
}

BOOL
IsURLInURLList(
    IN CSURLTEMPLATENODE *pURLList,
    IN WCHAR const *pwszURL)
{
    BOOL fRet = FALSE;

    // assume pURLList is always the 1st node

    while (NULL != pURLList)
    {
        if (0 == mylstrcmpiL(pwszURL, pURLList->URLTemplate.pwszURL))
        {
            fRet = TRUE;
            break;
        }
        pURLList = pURLList->pNext;
    }

    return fRet;
}

EXTENSIONWIZ_DATA g_ExtensionList[] =
{
    {IDS_EXT_CDP,
     IDS_EXT_CDP_EXPLAIN,
     IDS_CDP_INCLUDE_INSTRUCTIONS,
     IDS_PUBLISH_DELTAS_HERE,
     wszREGCRLPUBLICATIONURLS,
     CSURL_SERVERPUBLISH |
         CSURL_ADDTOCERTCDP |
         CSURL_ADDTOFRESHESTCRL |
         CSURL_ADDTOCRLCDP |
         CSURL_SERVERPUBLISHDELTA,
     NULL},
    {IDS_EXT_AIA,
     IDS_EXT_AIA_EXPLAIN,
     IDS_AIA_INCLUDE_INSTRUCTIONS,
     IDS_INCLUDE_IN_OSCP_EXTENSION,
     wszREGCACERTPUBLICATIONURLS,
     CSURL_ADDTOCERTCDP |
     CSURL_ADDTOCERTOCSP,
     NULL},
    {0, 0, 0, NULL, 0x0, NULL},
};


HRESULT
cuCopyToClipboard(
    IN HWND hwndActive,
    IN WCHAR const *pwszIn)
{
    HRESULT hr;
    HANDLE hData = NULL;
    DWORD cwc;
    WCHAR *pwszT;
    BOOL fOpened = FALSE;

    if (!OpenClipboard(hwndActive))
    {
	hr = myHLastError();
	_JumpError(hr, error, "OpenClipboard");
    }
    fOpened = TRUE;
    EmptyClipboard();

    cwc = wcslen(pwszIn);
    hData = GlobalAlloc(GMEM_MOVEABLE, (cwc + 1) * sizeof(WCHAR));
    if (NULL == hData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "GlobalAlloc");
    }
    pwszT = (WCHAR *) GlobalLock(hData);
    if (NULL == pwszT)
    {
	hr = myHLastError();
	_JumpError(hr, error, "GlobalLock");
    }
    wcscpy(pwszT, pwszIn);
    GlobalUnlock(hData);

    if (NULL == SetClipboardData(CF_UNICODETEXT, hData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SetClipboardData");
    }
    hData = NULL;	// now owned by clipboard
    hr = S_OK;

error:
    if (fOpened)
    {
	CloseClipboard();
    }
    if (NULL != hData)
    {
	GlobalFree(hData);
    }
    return(hr);
}


RoleAccessToControl CSvrSettingsExtensionPage::sm_ControlToRoleMap[] = 
    {
        { IDC_URL_ADD,          CA_ACCESS_ADMIN },
        { IDC_URL_REMOVE,       CA_ACCESS_ADMIN },
        { IDC_ADDTOCERTCDP,     CA_ACCESS_ADMIN },        
        { IDC_ADDTOCERTOCSP,    CA_ACCESS_ADMIN },
        { IDC_ADDTOFRESHESTCRL, CA_ACCESS_ADMIN },
        { IDC_ADDTOCRLCDP,      CA_ACCESS_ADMIN },
        { IDC_SERVERPUBLISH,    CA_ACCESS_ADMIN },
    };


CSvrSettingsExtensionPage::CSvrSettingsExtensionPage(
    CertSvrCA               *pCertCA,
    CSvrSettingsGeneralPage *pControlPage,
    UINT                     uIDD) :
        CAutoDeletePropPage(uIDD), 
        CRolesSupportInPropPage(
            pCertCA,
            sm_ControlToRoleMap,
            ARRAYSIZE(sm_ControlToRoleMap)),
        m_pControlPage(pControlPage)
{
    m_bUpdate = FALSE;
    m_nIndexReset = MAXDWORD;
    m_pExtData = g_ExtensionList;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE4_CDP);
}

CSvrSettingsExtensionPage::~CSvrSettingsExtensionPage()
{
    EXTENSIONWIZ_DATA *pExt = m_pExtData;

    while (NULL != pExt->wszRegName)
    {
        if (NULL != pExt->pURLList)
        {
            FreeURLList(pExt->pURLList);
            pExt->pURLList = NULL;
        }
        ++pExt;
    }
}

// get current extension pointer
EXTENSIONWIZ_DATA* CSvrSettingsExtensionPage::GetCurrentExtension()
{
    HWND hwndCtrl;
    LRESULT nIndex;
    EXTENSIONWIZ_DATA *pExt;

    // get extension data
    hwndCtrl = GetDlgItem(m_hWnd, IDC_EXT_SELECT);
    nIndex = SendMessage(hwndCtrl, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
    CSASSERT(CB_ERR != nIndex);
    pExt = (EXTENSIONWIZ_DATA*)SendMessage(
                                   hwndCtrl,
                                   CB_GETITEMDATA,
                                   (WPARAM)nIndex,
                                   (LPARAM)0);
    CSASSERT(NULL != pExt);
    return pExt;
}

// get current url pointer
CSURLTEMPLATENODE* CSvrSettingsExtensionPage::GetCurrentURL(
    OUT OPTIONAL LRESULT *pnIndex)
{
    HWND hwndCtrl;
    LRESULT nIndex;
    CSURLTEMPLATENODE *pURLNode;

    //get current url
    hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);
    //get current url selection
    nIndex = SendMessage(hwndCtrl, LB_GETCURSEL, (WPARAM)0, (LPARAM)0);
    CSASSERT(LB_ERR != nIndex);
    // get url data
    pURLNode = (CSURLTEMPLATENODE*)SendMessage(hwndCtrl,
                   LB_GETITEMDATA,
                   (WPARAM)nIndex,
                   (LPARAM)0);
    CSASSERT(NULL != pURLNode);

    if (NULL != pnIndex)
    {
        *pnIndex = nIndex;
    }
    return pURLNode;
}

void CSvrSettingsExtensionPage::UpdateURLFlagControl(
    IN int                idCtrl,
    IN DWORD              dwFlag,
    IN OPTIONAL EXTENSIONWIZ_DATA *pExt,
    IN OPTIONAL CSURLTEMPLATENODE *pURLNode)
{
    HWND hwndCtrl = GetDlgItem(m_hWnd, idCtrl);

    // check extension type, hide/show accordingly
    if (NULL == pExt || 0x0 == (dwFlag & pExt->dwFlagsMask) || NULL == pURLNode)
    {
        //no URLs link to the extension or
        //the flag not making sense for the extension, disable it
        ShowWindow(hwndCtrl, SW_HIDE);
        SendMessage(hwndCtrl, BM_SETCHECK, (WPARAM)BST_UNCHECKED, (LPARAM)0);
    }
    else
    {
        //show the control first
        ShowWindow(hwndCtrl, SW_SHOW);

        if (0x0 == (dwFlag & pURLNode->EnableMask))
        {
            //this url type is not allowed, disbale it and unset it
            SendMessage(hwndCtrl, BM_SETCHECK, BST_UNCHECKED, (LPARAM)0);
            EnableControl(m_hWnd, idCtrl, FALSE);
        }
        else
        {
            //enable it
            EnableControl(m_hWnd, idCtrl, TRUE);

            WPARAM fCheck = (0x0 != (dwFlag & pURLNode->URLTemplate.Flags)) ?
                            BST_CHECKED : BST_UNCHECKED;
            SendMessage(hwndCtrl, BM_SETCHECK, fCheck, (LPARAM)0);
        }

        // For ldap url, server name (ldap://server/DN...) is not supported, so disable
        // the publish check boxes

        LPCWSTR pcwszLDAP = L"ldap:";
        LPCWSTR pcwszFwdSlashes = L"///";

        if(IDS_EXT_CDP == pExt->idExtensionName &&
           (IDC_SERVERPUBLISH == idCtrl ||
            IDC_ADDTOCERTOCSP == idCtrl) &&
           pURLNode &&
           0 == _wcsnicmp(
                    pURLNode->URLTemplate.pwszURL, 
                    pcwszLDAP, 
                    wcslen(pcwszLDAP)) &&
           NULL == wcsstr(
                    pURLNode->URLTemplate.pwszURL,
                    pcwszFwdSlashes))
        {
            SendMessage(hwndCtrl, BM_SETCHECK, BST_UNCHECKED, (LPARAM)0);
            EnableControl(m_hWnd, idCtrl, FALSE);            
        }
    }
}

//update check controls from the flag
void
CSvrSettingsExtensionPage::UpdateURLFlags(
    IN EXTENSIONWIZ_DATA *pExt,
    IN OPTIONAL CSURLTEMPLATENODE *pURLNode)
{
    if (NULL != pExt && NULL == pURLNode)
    {
        // use 1st one
        pURLNode = pExt->pURLList;
    }

    UpdateURLFlagControl(IDC_SERVERPUBLISH,
                         CSURL_SERVERPUBLISH,
                         pExt,
                         pURLNode);
    UpdateURLFlagControl(IDC_ADDTOCERTCDP,
                         CSURL_ADDTOCERTCDP,
                         pExt,
                         pURLNode);
    UpdateURLFlagControl(IDC_ADDTOFRESHESTCRL,
                         CSURL_ADDTOFRESHESTCRL,
                         pExt,
                         pURLNode);
    UpdateURLFlagControl(IDC_ADDTOCRLCDP,
                         CSURL_ADDTOCRLCDP,
                         pExt,
                         pURLNode);

    // this chkbox is doubled up depending on mode
    if (pExt && pExt->idExtensionName == IDS_EXT_AIA)
    {
    UpdateURLFlagControl(IDC_ADDTOCERTOCSP,
                         CSURL_ADDTOCERTOCSP,
                         pExt,
                         pURLNode);
    } 
    else 
    {
    UpdateURLFlagControl(IDC_ADDTOCERTOCSP,
                         CSURL_SERVERPUBLISHDELTA,
                         pExt,
                         pURLNode);
    }

}

//handle url selection change
void CSvrSettingsExtensionPage::OnURLChange()
{
    // update check controls
    if (MAXDWORD != m_nIndexReset)
    {
        SendMessage(
		GetDlgItem(m_hWnd, IDC_URL_LIST),
		LB_SETCURSEL,
		(WPARAM) m_nIndexReset,
		(LPARAM) 0);
	m_nIndexReset = MAXDWORD;
    }
    UpdateURLFlags(GetCurrentExtension(), GetCurrentURL(NULL));
}

void CSvrSettingsExtensionPage::OnURLCopy()
{
    HWND hwndCtrl;
    LRESULT nIndex;

    hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);
    nIndex = SendMessage(hwndCtrl, LB_GETCURSEL, (WPARAM) 0, (LPARAM) 0);
    if (LB_ERR != nIndex)
    {
	HRESULT hr;
	CSURLTEMPLATENODE *pURL = GetCurrentURL(&nIndex);

	if (NULL != pURL && NULL != pURL->URLTemplate.pwszURL)
	{
	    hr = cuCopyToClipboard(m_hWnd, pURL->URLTemplate.pwszURL);
	    _PrintIfError(hr, "cuCopyToClipboard");

	    m_nIndexReset = nIndex;
	}
    }
}

void AdjustListHScrollWidth(HWND hwndList)
{
    HDC  hdc = GetDC(hwndList);
    int  cItem;
    int  maxWidth = 0;
    int  i;
    SIZE sz;

    WCHAR  *pwszString = NULL;
    if (LB_ERR == (cItem = (int)SendMessage(hwndList, LB_GETCOUNT, (WPARAM)0, (LPARAM)0)))
        goto error;

    //loop through all strings in list and find the largest length
    for (i = 0; i < cItem; i++)
    {
        if (NULL != pwszString)
        {
            LocalFree(pwszString);
            pwszString = NULL;
        }

        //get string length
        int len = (int)SendMessage(hwndList, LB_GETTEXTLEN, (WPARAM)i, (LPARAM)0);
        if (LB_ERR == len)
        {
            //ignore error, skip to next
            continue;
        }
        pwszString = (WCHAR*)LocalAlloc(LMEM_FIXED, (len+1) * sizeof(WCHAR));
        if (NULL == pwszString)
        {
            _JumpError(E_OUTOFMEMORY, error, "Out of memory");
        }
        //get string text
        if (LB_ERR == SendMessage(hwndList, LB_GETTEXT, (WPARAM)i, (LPARAM)pwszString))
        {
            //skip error
            continue;
        }
        //calculate string width
        if (!GetTextExtentPoint32(hdc, pwszString, len, &sz))
        {
            //skip error
            continue;
        }
        if (sz.cx > maxWidth)
        {
            maxWidth = sz.cx;
        }
    }

    if (0 < maxWidth)
    {
        // now set horizontal scroll width
        SendMessage(hwndList,
                    LB_SETHORIZONTALEXTENT,
                    (WPARAM)maxWidth,
                    (LPARAM)0);
    }

error:
        if (NULL != pwszString)
        {
            LocalFree(pwszString);
            pwszString = NULL;
        }

}

// handle extension selection change in the combo box
void CSvrSettingsExtensionPage::OnExtensionChange()
{
    EXTENSIONWIZ_DATA *pExt;
    LRESULT nIndex;
    LRESULT nIndex0=0;
    CString strExplain;
    HWND    hwndCtrl;
    CSURLTEMPLATENODE *pURLNode;
    BOOL fEnable = TRUE;

    // get extension data
    pExt = GetCurrentExtension();

    // update extension explaination
    strExplain.LoadString(pExt->idExtensionExplain);
    SetWindowText(GetDlgItem(m_hWnd, IDC_EXT_EXPLAIN), strExplain);

    // update default checkbox text with 'better' text
    strExplain.LoadString(pExt->idCheckboxText);
    SetWindowText(GetDlgItem(m_hWnd, IDC_ADDTOCERTCDP), strExplain);

    // change meaning of OCSP/publish Delta CRL here text
    strExplain.LoadString(pExt->idCheckboxText2);
    SetWindowText(GetDlgItem(m_hWnd, IDC_ADDTOCERTOCSP), strExplain);

    // remove the current URLs in the list
    hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);
    while (0 < SendMessage(hwndCtrl, LB_GETCOUNT, (WPARAM)0, (LPARAM)0))
    {
        SendMessage(hwndCtrl, LB_DELETESTRING, (WPARAM)0, (LPARAM)0);
    }

    // list URLs of the current extension
    pURLNode = pExt->pURLList;
    while (NULL != pURLNode)
    {
        nIndex = SendMessage(hwndCtrl,
                    LB_ADDSTRING,
                    (WPARAM)0,
                    (LPARAM)pURLNode->URLTemplate.pwszURL);
        CSASSERT(CB_ERR != nIndex);
        if (pURLNode == pExt->pURLList)
        {
            //remember the 1st
            nIndex0 = nIndex;
        }
        //set list item data
        SendMessage(hwndCtrl, LB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pURLNode);
        pURLNode = pURLNode->pNext;
    }

    //adjust horizontal scroll width
    AdjustListHScrollWidth(hwndCtrl);

    if (NULL != pExt->pURLList)
    {
        // select the first one
        SendMessage(hwndCtrl, LB_SETCURSEL, (WPARAM)nIndex0, (LPARAM)0);
    }
    else
    {
        //empty url list
        fEnable = FALSE;
    }
    EnableControl(m_hWnd, IDC_URL_REMOVE, fEnable);
    UpdateURLFlags(pExt, NULL);
}

// handle check control change
void CSvrSettingsExtensionPage::OnFlagChange(DWORD dwFlag)
{
    //get current url
    CSURLTEMPLATENODE *pURLNode = GetCurrentURL(NULL);

    // update flag
    if (0x0 != (pURLNode->URLTemplate.Flags & dwFlag))
    {
        // means the current bit is on, trun it off
        pURLNode->URLTemplate.Flags &= ~dwFlag;
    }
    else
    {
        // means the current bit is off, trun it on
        pURLNode->URLTemplate.Flags |= dwFlag;
    }

    m_bUpdate = TRUE;
    SetModified(m_bUpdate);
}

// handle remove url
BOOL CSvrSettingsExtensionPage::OnURLRemove()
{
    LRESULT nIndex;
    LRESULT nCount = 0;
    HRESULT hr;
    HWND hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);

    // get extension data
    EXTENSIONWIZ_DATA *pExt = GetCurrentExtension();
    //get current url
    CSURLTEMPLATENODE *pURLNode = GetCurrentURL(&nIndex);

    // confirm this action
    CString cstrMsg, cstrTitle;
    cstrMsg.LoadString(IDS_CONFIRM_REMOVE_URL);
    cstrTitle.LoadString(IDS_CONFIRM_REMOVE_TITLE);
    if (IDYES != MessageBox(m_hWnd, cstrMsg, cstrTitle, MB_YESNO))
        goto bailout;

    // remove it from the list
    hr = RemoveURLNode(&pExt->pURLList, pURLNode);
    if (S_OK == hr)
    {
        // ok, remove it from UI
        nCount = SendMessage(hwndCtrl,
                    LB_DELETESTRING,
                    (WPARAM)nIndex,
                    (LPARAM)0);
        m_bUpdate = TRUE;
        SetModified(m_bUpdate);
        // select a previous one, if 1st one, still 1st one
        if (0 < nIndex)
        {
            --nIndex;
        }
        if (0 < nCount)
        {
            SendMessage(hwndCtrl, LB_SETCURSEL, (WPARAM)nIndex, (LPARAM)0);
            pURLNode = GetCurrentURL(&nIndex);
            UpdateURLFlags(pExt, pURLNode);
        }
    }
    else
    {
        _PrintError(hr, "RemoveURLNode");
        return FALSE;
    }

    if (0 >= nCount)
    {
        //now is empty list, disable remove button
        EnableControl(m_hWnd, IDC_URL_REMOVE, FALSE);
        //disable all check controls
        UpdateURLFlags(NULL, NULL);
    }

bailout:
    return TRUE;
}


HRESULT
gpVerifyIA5URL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;
    CERT_NAME_VALUE cnv;
    BYTE *pb = NULL;
    DWORD cb;

    hr = myInternetCanonicalizeUrl(pwszURL, &pwsz);
    _JumpIfError(hr, error, "myInternetCanonicalizeUrl");

    // encode the string as an IA5 string

    cnv.dwValueType = CERT_RDN_IA5_STRING;
    cnv.Value.pbData = (BYTE *) pwsz;
    cnv.Value.cbData = 0;	// Use L'\0' termination for the length

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_NAME_VALUE,
		    &cnv,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pb,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
	LocalFree(pwsz);
    }
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


INT_PTR CALLBACK dlgAddURL(
  HWND hwnd,
  UINT uMsg,
  WPARAM  wParam,
  LPARAM  lParam)
{
    HRESULT hr;
    BOOL fReturn = FALSE;

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            ::SetWindowLong(
                hwnd,
                GWL_EXSTYLE,
                ::GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // stash the ADDURL_DIALOGARGS pointer
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lParam);

            // dump knowledge of tokens into dropdown, item data is description
            HWND hCombo = GetDlgItem(hwnd, IDC_COMBO_VARIABLE);
            for (int i=0; i<DISPLAYSTRINGS_TOKEN_COUNT; i++)
            {
                // skip invalid tokens
                if (0 == wcscmp(L"", g_displayStrings[i].szContractedToken))
                    continue;

                INT nItemIndex = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) (LPCWSTR) (*g_displayStrings[i].pcstrExpansionString));
                if (CB_ERR == nItemIndex)
                    continue;
                SendMessage(hCombo, CB_SETITEMDATA, (WPARAM)nItemIndex, (LPARAM) (LPCWSTR) (*g_displayStrings[i].pcstrExpansionStringDescr));
            }

            // set start value
            SendMessage(hCombo, CB_SETCURSEL, 0, 0);
            SetDlgItemText(hwnd, IDC_EDIT_VARIABLEDESCRIPTION, (LPCWSTR) (*g_displayStrings[0].pcstrExpansionStringDescr));

            break;
        }
        case WM_HELP:
        {
            OnDialogHelp((LPHELPINFO)lParam,
                         CERTMMC_HELPFILENAME,
                         g_aHelpIDs_IDD_ADDURL);
            break;
        }
        case WM_CONTEXTMENU:
        {
            OnDialogContextHelp((HWND)wParam,
                         CERTMMC_HELPFILENAME,
                         g_aHelpIDs_IDD_ADDURL);
            break;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_COMBO_VARIABLE:
                {
                    if (HIWORD(wParam) == LBN_SELCHANGE)
                    {
                        // On selection change, ask for the selection idx
                        int nItemIndex = (INT)SendMessage((HWND)lParam,
                            CB_GETCURSEL,
                            0,
                            0);

                        LPCWSTR sz;
                        sz = (LPCWSTR) SendMessage(
                                (HWND)lParam,
                                CB_GETITEMDATA,
                                (WPARAM)nItemIndex,
                                0);
                        if (CB_ERR == (DWORD_PTR)sz)
                            break;  // get out of here

                            // otherwise, we just got descr... set it!
                            SetDlgItemText(hwnd, IDC_EDIT_VARIABLEDESCRIPTION, sz);
                        }
                }
                break;
                case IDC_BUTTON_INSERTVAR:
                {
                    WCHAR sz[64]; // ASSUME: no token is > 64 char
                    if (0 != GetDlgItemText(hwnd, IDC_COMBO_VARIABLE, sz, ARRAYLEN(sz)))
                    {
                        // insert <token> at cursor
                        SendMessage(GetDlgItem(hwnd, IDC_EDITURL), EM_REPLACESEL, TRUE, (LPARAM)sz);
                    }
                }
                break;

                case IDOK:
                {
                    // snatch the ADDURL_DIALOGARGS* we were given
                    ADDURL_DIALOGARGS* pArgs = (ADDURL_DIALOGARGS*)
                                GetWindowLongPtr(hwnd, GWLP_USERDATA);
                    if (pArgs == NULL)
                    {
                        hr = E_UNEXPECTED;
                        _PrintError(hr, "unexpected null data");
                        break;
                    }

                    hr = myUIGetWindowText(GetDlgItem(hwnd, IDC_EDITURL),
                                           pArgs->ppszNewURL);
                    if (S_OK != hr)
                    {
                        _PrintError(hr, "myUIGetWindowText");
                        break;
                    }

                    if (NULL == *pArgs->ppszNewURL)
                    {
                        CertWarningMessageBox(
                                g_hInstance,
                                FALSE,
                                hwnd,
                                IDS_EMPTY_URL,
                                0,
                                NULL);
                        HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                        SetFocus(hwndCtrl);
                        break;
                    }

                    if (URL_TYPE_UNKNOWN == DetermineURLType(
                                                pArgs->rgAllowedURLs,
                                                pArgs->cAllowedURLs,
                                                *pArgs->ppszNewURL))
                    {
                        // not found; bail with message
                        CertWarningMessageBox(
                                g_hInstance,
                                FALSE,
                                hwnd,
                                IDS_INVALID_PREFIX,
                                0,
                                NULL);
                        SetFocus(GetDlgItem(hwnd, IDC_EDITURL));
                        break;
                    }

                    DWORD chBadBegin, chBadEnd;
                    if (S_OK != ValidateTokens(
                            *pArgs->ppszNewURL,
                            &chBadBegin,
                            &chBadEnd))
                    {
                        // not found; bail with message
                        CertWarningMessageBox(
                                g_hInstance,
                                FALSE,
                                hwnd,
                                IDS_INVALID_TOKEN,
                                0,
                                NULL);
                        HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                        // set selection starting from where validation failed
                        SetFocus(hwndCtrl);
                        SendMessage(hwndCtrl, EM_SETSEL, chBadBegin, chBadEnd);
                        break;
                    }

                    if (IsURLInURLList(pArgs->pURLList, *pArgs->ppszNewURL))
                    {
                        CString cstrMsg, cstrTemplate;
                        cstrTemplate.LoadString(IDS_SAME_URL_EXIST);
                        cstrMsg.Format(cstrTemplate, *pArgs->ppszNewURL);

                        if (IDYES != MessageBox(hwnd, cstrMsg, (LPCWSTR)g_pResources->m_DescrStr_CA, MB_YESNO))
                        { 
                            HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                            // set selection starting from where validation failed 
                            SetFocus(hwndCtrl);
                            SendMessage(hwndCtrl, EM_SETSEL, 0, -1);
                            break;
                        }

// mattt, 1/15/01
// we want to warn but allow multiples so people can work around
// not being able to sort entries -- now they can create
// multiples of the same place but place them differently in the list
/*
                        // the same url is defined already
                        CertWarningMessageBox(
                                g_hInstance,
                                FALSE,
                                hwnd,
                                IDS_SAME_URL_EXIST,
                                0,
                                *pArgs->ppszNewURL);

                        HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                        // set selection starting from where validation failed
                        SetFocus(hwndCtrl);
                        SendMessage(hwndCtrl, EM_SETSEL, 0, -1);
                        break;
*/
                    }

                    // attempt IA5 encoding
                    hr = gpVerifyIA5URL(*pArgs->ppszNewURL);
                    if (S_OK != hr)
                    {
                        _PrintError(hr, "gpVerifyIA5URL");

                        // encoding error; bail with message
                        WCHAR szMsg[MAX_PATH*2];
                        HWND hwndCtrl = GetDlgItem(hwnd, IDC_EDITURL);
                        LoadString(g_hInstance, IDS_INVALID_ENCODING, szMsg, ARRAYLEN(szMsg));
                        MessageBox(hwnd, szMsg, NULL, MB_OK);

                        // set selection starting from where validation failed
                        SetFocus(hwndCtrl);
                        SendMessage(GetDlgItem(hwnd, IDC_EDITURL), EM_SETSEL, MAXDWORD, -1);
                        break;
                    }
                }
                // fall through for cleanup
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    fReturn = TRUE;
                break;
                default:
                break;
            }
        default:
        break;  //WM_COMMAND
    }
    return fReturn;
}

ENUM_URL_TYPE rgPOSSIBLE_CRL_URLs[] =
{
    URL_TYPE_HTTP,
    URL_TYPE_FILE,
    URL_TYPE_LDAP,
    URL_TYPE_FTP,
    URL_TYPE_LOCAL,
    URL_TYPE_UNC,
};

ENUM_URL_TYPE rgPOSSIBLE_AIA_URLs[] =
{
    URL_TYPE_HTTP,
    URL_TYPE_FILE,
    URL_TYPE_LDAP,
    URL_TYPE_FTP,
    URL_TYPE_UNC,
};

// handle add url
BOOL CSvrSettingsExtensionPage::OnURLAdd()
{
    HRESULT hr;
    WCHAR *pwszURL = NULL;
    CSURLTEMPLATENODE *pURLNode;
    HWND  hwndCtrl;
    LRESULT nIndex;
    // get current extension
    EXTENSIONWIZ_DATA *pExt = GetCurrentExtension();
    BOOL fCDP = (IDS_EXT_CDP == pExt->idExtensionName) ? TRUE : FALSE;

    ADDURL_DIALOGARGS dlgArgs = {
        fCDP ? rgPOSSIBLE_CRL_URLs : rgPOSSIBLE_AIA_URLs,
        (DWORD)(fCDP ? ARRAYLEN(rgPOSSIBLE_CRL_URLs) : ARRAYLEN(rgPOSSIBLE_AIA_URLs)),
        &pwszURL,
        pExt->pURLList};

    if (IDOK != DialogBoxParam(
                    g_hInstance,
                    MAKEINTRESOURCE(IDD_ADDURL),
                    m_hWnd,
                    dlgAddURL,
                    (LPARAM)&dlgArgs))
    {
        //cancel
        return TRUE;
    }

    if (NULL != pwszURL && L'\0' != *pwszURL)
    {
        // a new url, add into the list
        pURLNode = (CSURLTEMPLATENODE*)LocalAlloc(
                                LMEM_FIXED | LMEM_ZEROINIT,
                                sizeof(CSURLTEMPLATENODE));
        if (NULL == pURLNode)
        {
            hr = E_OUTOFMEMORY;
            _PrintError(hr, "LocalAlloc");
            return FALSE;
        }
        pURLNode->URLTemplate.pwszURL = pwszURL;
        pURLNode->EnableMask = DetermineURLEnableMask(
                    DetermineURLType(
                        rgAllPOSSIBLE_URL_PREFIXES,
                        ARRAYSIZE(rgAllPOSSIBLE_URL_PREFIXES),
                        pURLNode->URLTemplate.pwszURL));
        //add to the data structure
        hr = AddURLNode(&pExt->pURLList, pURLNode);
        if (S_OK != hr)
        {
            _PrintError(hr, "AddURLNode");
            return FALSE;
        }
        hwndCtrl = GetDlgItem(m_hWnd, IDC_URL_LIST);
        nIndex = SendMessage(hwndCtrl,
                             LB_ADDSTRING,
                             (WPARAM)0,
                             (LPARAM)pURLNode->URLTemplate.pwszURL);
        CSASSERT(LB_ERR != nIndex);
        //set item data
        SendMessage(hwndCtrl, LB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pURLNode);
        //set it as current selection
        SendMessage(hwndCtrl, LB_SETCURSEL, (WPARAM)nIndex, (LPARAM)0);
        //update flag controls
        UpdateURLFlags(pExt, pURLNode);
        m_bUpdate = TRUE;
        SetModified(m_bUpdate);
        //alway enable remove button
        EnableControl(m_hWnd, IDC_URL_REMOVE, TRUE);

        //adjust list control width accordingly
        AdjustListHScrollWidth(hwndCtrl);
    }
    return TRUE;
}


void CSvrSettingsExtensionPage::OnHelp(LPHELPINFO lpHelp)
{
   // override help for _ADDCERTOCSP if chkbox is reused for _SERVERPUBLISHDELTA

   if (lpHelp == NULL)
       return;

   if ((lpHelp->iContextType == HELPINFO_WINDOW) && 
       (lpHelp->iCtrlId == IDC_ADDTOCERTOCSP))
   {
       EXTENSIONWIZ_DATA *pExt = GetCurrentExtension();
       BOOL fCDP = (IDS_EXT_CDP == pExt->idExtensionName) ? TRUE : FALSE;

       OnDialogHelp(lpHelp,
            CERTMMC_HELPFILENAME,
            (fCDP?
             g_aHelpIDs_IDD_CERTSRV_PROPPAGE4_CDP:
             g_aHelpIDs_IDD_CERTSRV_PROPPAGE4_AIA));
   }
   else
      CAutoDeletePropPage::OnHelp(lpHelp);
}

void CSvrSettingsExtensionPage::OnContextHelp(HWND hwnd)
{
    EXTENSIONWIZ_DATA *pExt = GetCurrentExtension();
    BOOL fCDP = (IDS_EXT_CDP == pExt->idExtensionName) ? TRUE : FALSE;

    if(hwnd == GetDlgItem(m_hWnd, IDC_ADDTOCERTOCSP))
    {
        ::WinHelp(
            hwnd, 
            m_strHelpFile, 
            HELP_CONTEXTMENU, 
            (ULONG_PTR)(LPVOID)
            (fCDP?m_prgzHelpIDs:g_aHelpIDs_IDD_CERTSRV_PROPPAGE4_AIA));
    }
    else
        CAutoDeletePropPage::OnContextHelp(hwnd);
    return;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CSvrSettingsExtensionPage::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    switch(LOWORD(wParam))
    {
        case IDC_EXT_SELECT:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                    // extension selection is changed
                    OnExtensionChange();
                break;
            }
        break;
        case IDC_URL_LIST:
            switch (HIWORD(wParam))
            {
                case LBN_SELCHANGE:
                    // url selection is changed
                    OnURLChange();
                break;
            }
        break;
        case IDC_URL_ADD:
            return OnURLAdd();
        break;
        case IDC_URL_REMOVE:
            OnURLRemove();
        break;
        case IDC_SERVERPUBLISH:
            OnFlagChange(CSURL_SERVERPUBLISH);
        break;
        case IDC_ADDTOCERTCDP:
            OnFlagChange(CSURL_ADDTOCERTCDP);
        break;
        case IDC_ADDTOFRESHESTCRL:
            OnFlagChange(CSURL_ADDTOFRESHESTCRL);
        break;
        case IDC_ADDTOCRLCDP:
            OnFlagChange(CSURL_ADDTOCRLCDP);
        break;
        case IDC_ADDTOCERTOCSP:
        {
          EXTENSIONWIZ_DATA *pExt = GetCurrentExtension();
          ASSERT(pExt);
          if (IDS_EXT_AIA == pExt->idExtensionName) // showing OCSP text
            OnFlagChange(CSURL_ADDTOCERTOCSP);
          else   // delta text
            OnFlagChange(CSURL_SERVERPUBLISHDELTA);
        }
        break;
        default:
        return FALSE;
    }
    return TRUE;
}


BOOL
CSvrSettingsExtensionPage::OnNotify(
    IN UINT /* idCtrl */ ,
    IN NMHDR *pnmh)
{
    BOOL fHandled = FALSE;
    
    switch (pnmh->code)
    {
	case PSN_TRANSLATEACCELERATOR:
	{
	    MSG *pmsg = (MSG *) ((PSHNOTIFY *) pnmh)->lParam;

	    if (WM_CHAR == pmsg->message && 'C' - 0x40 == pmsg->wParam)
	    {
		OnURLCopy();
		fHandled = TRUE;
	    }
	    break;
	}
    }
    return(fHandled);
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsExtensionPage message handlers
BOOL CSvrSettingsExtensionPage::OnInitDialog()
{
    CSASSERT(NULL != m_pExtData);

    EXTENSIONWIZ_DATA *pExt = m_pExtData;
    DWORD              dwRet;
    HWND               hwndCtrl;
    CString            strName;
    LRESULT            nIndex;
    LRESULT            nIndex0 = 0;
    HRESULT            hr;
    VARIANT            var;

    // does parent init
    CAutoDeletePropPage::OnInitDialog();

    // initially disabled
    UpdateURLFlags(NULL, NULL);

    //go through each extension and init data from reg
    while (NULL != pExt->wszRegName)
    {
        dwRet = m_pControlPage->m_pCA->GetConfigEntry(
                    NULL,
                    pExt->wszRegName,
                    &var);
        if(dwRet != S_OK)
            return FALSE;
        CSASSERT(V_VT(&var)==(VT_ARRAY|VT_BSTR));

        hr = BuildURLListFromStrings(var, &pExt->pURLList);
        _PrintIfError(hr, "BuildURLListFromStrings");
        ++pExt;

        VariantClear(&var);
    }

    // add extensions into UI combo list
    pExt = m_pExtData;
    hwndCtrl = GetDlgItem(m_hWnd, IDC_EXT_SELECT);
    while (NULL != pExt->wszRegName)
    {
        // load current extension display name into the list
        strName.LoadString(pExt->idExtensionName);
        nIndex = (INT)SendMessage(hwndCtrl,
                                  CB_ADDSTRING,
                                  (WPARAM)0,
                                  (LPARAM)(LPCWSTR)strName);
        CSASSERT(CB_ERR != nIndex);

        //remember index of the first extension
        if (pExt == m_pExtData)
        {
            nIndex0 = nIndex;
        }
        //link current extension to the item
        nIndex = SendMessage(hwndCtrl,
                                  CB_SETITEMDATA,
                                  (WPARAM)nIndex,
                                  (LPARAM)pExt);
        CSASSERT(CB_ERR != nIndex);
        ++pExt;
    }

    // select the 1st one as default
    nIndex = SendMessage(hwndCtrl,
                         CB_SETCURSEL,
                         (WPARAM)nIndex0,
                         (LPARAM)0);
    CSASSERT(CB_ERR != nIndex);

    EnableControl(m_hWnd, IDC_URL_ADD, TRUE);
    OnExtensionChange();
    return TRUE;
}


void CSvrSettingsExtensionPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
//    if (m_hConsoleHandle)
//        MMCFreeNotifyHandle(m_hConsoleHandle);
//    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}

BOOL CSvrSettingsExtensionPage::OnApply()
{
    DWORD dwRet = ERROR_SUCCESS;
    EXTENSIONWIZ_DATA *pExt = m_pExtData;
    WCHAR *pwszzURLs;
    HRESULT hr;
    variant_t varURLs;

	if (m_bUpdate == TRUE)
    {
        //go through each extension and init data from reg
        while (NULL != pExt->wszRegName)
        {
            pwszzURLs = NULL;
            hr = BuildURLStringFromList(
                        pExt->pURLList,
                        &varURLs);
            if (S_OK != hr)
            {
                _PrintError(hr, "BuildURLStringFromList");
                return FALSE;
            }
            dwRet = m_pControlPage->m_pCA->SetConfigEntry(
                        NULL,
                        pExt->wszRegName,
                        &varURLs);
            if (dwRet != ERROR_SUCCESS)
            {
                DisplayGenericCertSrvError(m_hWnd, dwRet);
                _PrintError(dwRet, "SetConfigEntry");
                return FALSE;
            }
            ++pExt;
            varURLs.Clear();
        }

        //check to see if service is running
        if (m_pCA->m_pParentMachine->IsCertSvrServiceRunning())
        {
            //throw a confirmation
            CString cstrMsg;
            cstrMsg.LoadString(IDS_CONFIRM_SERVICE_RESTART);

            if (IDYES == ::MessageBox(m_hWnd, (LPCWSTR)cstrMsg, (LPCWSTR)g_pResources->m_DescrStr_CA, MB_YESNO | MB_ICONWARNING ))
            {
                //stop first
                hr = m_pCA->m_pParentMachine->CertSvrStartStopService(m_hWnd, FALSE);
                _PrintIfError(hr, "CertSvrStartStopService");
                //should check status?
                //start again
                hr = m_pCA->m_pParentMachine->CertSvrStartStopService(m_hWnd, TRUE);
                _PrintIfError(hr, "CertSvrStartStopService");
            }
        }

        m_bUpdate = FALSE;
    }
	
    return CAutoDeletePropPage::OnApply();
}


////
// 5
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsStoragePage property page
CSvrSettingsStoragePage::CSvrSettingsStoragePage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage)
{
    m_cstrDatabasePath = _T("");
    m_cstrLogPath = _T("");
    m_cstrSharedFolder = _T("");

    m_bUpdate = FALSE;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE5);
}

CSvrSettingsStoragePage::~CSvrSettingsStoragePage()
{
}

// replacement for DoDataExchange
BOOL CSvrSettingsStoragePage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrDatabasePath.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_DATABASE_LOC));
        m_cstrLogPath.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOG_LOC));
        m_cstrSharedFolder.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_SHAREDFOLDER));
    }
    else
    {
        m_cstrDatabasePath.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_DATABASE_LOC));
        m_cstrLogPath.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOG_LOC));
        m_cstrSharedFolder.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_SHAREDFOLDER));
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsStoragePage message handlers
BOOL CSvrSettingsStoragePage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    // DS or shared folder?
    BOOL fUsesDS = m_pControlPage->m_pCA->FIsUsingDS();
    ::SendDlgItemMessage(m_hWnd, IDC_CHECK1, BM_SETCHECK, (WPARAM) fUsesDS, 0);

    HRESULT hr = S_OK;
    variant_t var;
    CertSvrMachine *pMachine = m_pControlPage->m_pCA->m_pParentMachine;

    hr = pMachine->GetRootConfigEntry(
                wszREGDIRECTORY,
                &var);
    // shared folder might not be configured, ignore
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)!=hr)
    {
        _JumpIfError(hr, Ret, "GetRootConfigEntry wszREGDIRECTORY");

        m_cstrSharedFolder = V_BSTR(&var);

        var.Clear();
    }

    hr = pMachine->GetRootConfigEntry(
                wszREGDBDIRECTORY,
                &var);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)!=hr)
    {
        _JumpIfError(hr, Ret, "GetRootConfigEntry wszREGDBDIRECTORY");

        m_cstrDatabasePath = V_BSTR(&var);

        var.Clear();
    }

    hr = pMachine->GetRootConfigEntry(
                wszREGDBLOGDIRECTORY,
                &var);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)!=hr)
    {
        _JumpIfError(hr, Ret, "GetRootConfigEntry wszREGDBLOGDIRECTORY");

        m_cstrLogPath = V_BSTR(&var);
    }

    UpdateData(FALSE);

    hr = S_OK;

Ret:
    if (S_OK != hr)
        return FALSE;

    return TRUE;
}


///////////////////////////////////////////
// CCRLPropPage
/////////////////////////////////////////////////////////////////////////////
// CCRLPropPage property page

RoleAccessToControl CCRLPropPage::sm_ControlToRoleMap[] = 
{
    { IDC_EDIT_CRLPERIODCOUNT,          CA_ACCESS_ADMIN},
    { IDC_COMBO_CRLPERIODSTRING,        CA_ACCESS_ADMIN},
    { IDC_ENABLE_DELTAPUBLISH,          CA_ACCESS_ADMIN},
    { IDC_EDIT_DELTACRLPERIODCOUNT,     CA_ACCESS_ADMIN},
    { IDC_COMBO_DELTACRLPERIODSTRING,   CA_ACCESS_ADMIN},
};


CCRLPropPage::CCRLPropPage(CertSvrCA* pCA, UINT uIDD)
    :   CAutoDeletePropPage(uIDD),
        CRolesSupportInPropPage(
            pCA,
            sm_ControlToRoleMap,
            ARRAYSIZE(sm_ControlToRoleMap))
{
    m_cstrPublishPeriodCount = "1";
    m_cstrLastCRLPublish = _T("");
//    m_iNoAutoPublish = BST_UNCHECKED;

    m_cstrDeltaPublishPeriodCount = "1";
    m_cstrDeltaLastCRLPublish = _T("");
    m_iDeltaPublish = BST_CHECKED;


    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;


    CSASSERT(m_pCA);
    if (NULL == m_pCA)
        return;

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CRL_PROPPAGE);
}

CCRLPropPage::~CCRLPropPage()
{
}

// replacement for DoDataExchange
BOOL CCRLPropPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrPublishPeriodCount.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT));

        m_cstrDeltaPublishPeriodCount.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT));
        m_iDeltaPublish = (INT)SendDlgItemMessage(IDC_ENABLE_DELTAPUBLISH, BM_GETCHECK, 0, 0);
    }
    else
    {
        m_cstrPublishPeriodCount.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT));
        m_cstrLastCRLPublish.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_LASTUPDATE));

        m_cstrDeltaPublishPeriodCount.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT));
        m_cstrDeltaLastCRLPublish.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE));
        SendDlgItemMessage(IDC_ENABLE_DELTAPUBLISH, BM_SETCHECK, (WPARAM)m_iDeltaPublish, 0);
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL
CCRLPropPage::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    CString strCount;

    switch(LOWORD(wParam))
    {
    case IDC_EDIT_CRLPERIODCOUNT:
    case IDC_EDIT_DELTACRLPERIODCOUNT:
        strCount.FromWindow(GetDlgItem(m_hWnd, LOWORD(wParam)));
        if (EN_CHANGE == HIWORD(wParam) &&
            m_cstrPublishPeriodCount != strCount)
        {
            OnEditChange();
        }
        break;
    case IDC_COMBO_CRLPERIODSTRING:
    case IDC_COMBO_DELTACRLPERIODSTRING:
        if (CBN_SELCHANGE == HIWORD(wParam))
            OnEditChange();
        break;
    case IDC_DISABLE_PUBLISH:
    case IDC_DISABLE_DELTAPUBLISH:
        if (BN_CLICKED == HIWORD(wParam))
            OnCheckBoxChange(LOWORD(wParam) == IDC_DISABLE_PUBLISH);
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CCRLPropPage message handlers

void CCRLPropPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}



BOOL CCRLPropPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    m_cboxPublishPeriodString.Init(GetDlgItem(m_hWnd, IDC_COMBO_CRLPERIODSTRING));
    m_cboxDeltaPublishPeriodString.Init(GetDlgItem(m_hWnd, IDC_COMBO_DELTACRLPERIODSTRING));

    int iPublishPeriodCount = 0, iDeltaPublishPeriodCount = 0;
    CString cstr;
    HRESULT hr = S_OK;
    variant_t var;
    FILETIME ftBase, ftDelta;
	ZeroMemory(&ftBase, sizeof(ftBase));
	ZeroMemory(&ftDelta, sizeof(ftDelta));

    // add strings to dropdown
    m_cboxPublishPeriodString.ResetContent();
    m_cboxDeltaPublishPeriodString.ResetContent();

    int iEnum;

    // y
    iEnum = m_cboxPublishPeriodString.AddString(g_pResources->m_szPeriod_Years);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_YEARS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_pResources->m_szPeriod_Years);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_YEARS);

    // m
    iEnum = m_cboxPublishPeriodString.AddString(g_pResources->m_szPeriod_Months);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_MONTHS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_pResources->m_szPeriod_Months);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_MONTHS);

    // w
    iEnum = m_cboxPublishPeriodString.AddString(g_pResources->m_szPeriod_Weeks);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_WEEKS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_pResources->m_szPeriod_Weeks);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_WEEKS);

    // d
    iEnum = m_cboxPublishPeriodString.AddString(g_pResources->m_szPeriod_Days);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_DAYS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_pResources->m_szPeriod_Days);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_DAYS);

    // h
    iEnum = m_cboxPublishPeriodString.AddString(g_pResources->m_szPeriod_Hours);
    if (iEnum >= 0)
        m_cboxPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_HOURS);
    iEnum = m_cboxDeltaPublishPeriodString.AddString(g_pResources->m_szPeriod_Hours);
    if (iEnum >= 0)
        m_cboxDeltaPublishPeriodString.SetItemData(iEnum, ENUM_PERIOD_HOURS);

    // base period count
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLPERIODCOUNT,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)==VT_I4);
    iPublishPeriodCount = V_I4(&var);

    var.Clear();

    // Base CRL Period
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLPERIODSTRING,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)== VT_BSTR);

    // match validity internally, select combo
    if (StringFromDurationEnum( DurationEnumFromNonLocalizedString(V_BSTR(&var)), &cstr, TRUE))
    {
        m_cboxPublishPeriodString.SelectString(
            -1,
            cstr);
    }

    // create comparison value for later
    myMakeExprDateTime(
        &ftBase,
        iPublishPeriodCount,
        DurationEnumFromNonLocalizedString(V_BSTR(&var)));

    var.Clear();

    // DELTA period count
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLDELTAPERIODCOUNT,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)==VT_I4);
    iDeltaPublishPeriodCount = V_I4(&var);

    var.Clear();

    // delta CRL Period
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLDELTAPERIODSTRING,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)== VT_BSTR);

    // create comparison value for later
    myMakeExprDateTime(
        &ftDelta,
        iDeltaPublishPeriodCount,
        DurationEnumFromNonLocalizedString(V_BSTR(&var)));

    // match validity internally, select combo
    // clamp delta <= Base

    BOOL fSetDeltaString = TRUE;
    if (0 >= CompareFileTime(&ftDelta, &ftBase))
    {
	fSetDeltaString = StringFromDurationEnum(
			    DurationEnumFromNonLocalizedString(V_BSTR(&var)),
			    &cstr,
			    TRUE);
    }
    else
    {
        if (0 != iDeltaPublishPeriodCount)
	{
	    iDeltaPublishPeriodCount = iPublishPeriodCount;
	}
    }
    if (fSetDeltaString)
    {
        m_cboxDeltaPublishPeriodString.SelectString(
            -1,
            cstr);
    }
    var.Clear();

    // base Next publish
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLNEXTPUBLISH,
            &var);
    _PrintIfError(hr, "GetConfigEntry");

    // optional value: might have never been published
    if (hr == S_OK)
    {
        CSASSERT(V_VT(&var)==(VT_ARRAY|VT_UI1));

        DWORD dwType, dwSize;
        BYTE *pbTmp = NULL;
        hr = myVariantToRegValue(
                &var,
                &dwType,
                &dwSize,
                &pbTmp);
        _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");
        CSASSERT(dwType == REG_BINARY);

        // push result into FileTime
        CSASSERT(dwSize == sizeof(FILETIME));
        FILETIME ftGMT;
        CopyMemory(&ftGMT, pbTmp, sizeof(FILETIME));
        LOCAL_FREE(pbTmp);

        // Convert to localized time localized string
        hr = myGMTFileTimeToWszLocalTime(&ftGMT, FALSE, (LPWSTR*) &pbTmp);
        _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
        if (S_OK == hr)
        {
            m_cstrLastCRLPublish = (LPWSTR)pbTmp;
            LOCAL_FREE(pbTmp);
        }
    }

    var.Clear();

    GetDeltaNextPublish();

    // base autopublish
    // don't allow 0 : use chkbox
//    m_iNoAutoPublish = (iPublishPeriodCount == 0) ? BST_CHECKED : BST_UNCHECKED;
    if (iPublishPeriodCount <= 0)
        iPublishPeriodCount = 1;

    m_cstrPublishPeriodCount.Format(L"%i", iPublishPeriodCount);
//    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_COMBO_CRLPERIODSTRING), (m_iNoAutoPublish == BST_UNCHECKED));
//    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT), (m_iNoAutoPublish == BST_UNCHECKED));
//    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_LASTUPDATE), (m_iNoAutoPublish == BST_UNCHECKED));

    // DELTA autopublish
    // don't allow 0 : use chkbox
    m_iDeltaPublish = iDeltaPublishPeriodCount == 0?	// if disabled
		    BST_UNCHECKED : BST_CHECKED;
    if (iDeltaPublishPeriodCount <= 0)
        iDeltaPublishPeriodCount = 1;

    m_cstrDeltaPublishPeriodCount.Format(L"%i", iDeltaPublishPeriodCount);

    EnableControl(m_hWnd, IDC_EDIT_CRLPERIODCOUNT, TRUE);
    EnableControl(m_hWnd, IDC_COMBO_CRLPERIODSTRING, TRUE);
    EnableControl(m_hWnd, IDC_ENABLE_DELTAPUBLISH, TRUE);
    EnableControl(m_hWnd, IDC_COMBO_DELTACRLPERIODSTRING, (m_iDeltaPublish == BST_CHECKED));
    EnableControl(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT, (m_iDeltaPublish == BST_CHECKED));

    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE), (m_iDeltaPublish == BST_CHECKED));


    UpdateData(FALSE);
    return TRUE;

error:
    DisplayGenericCertSrvError(m_hWnd, hr);
    return TRUE;
}

void CCRLPropPage::GetDeltaNextPublish()
{
    HRESULT hr = S_OK;
    variant_t var;

    DWORD dwType, dwSize;
    BYTE* pbTmp = NULL;

    // DELTA Next publish
    hr = m_pCA->GetConfigEntry(
            NULL,
            wszREGCRLDELTANEXTPUBLISH,
            &var);
    _JumpIfError(hr, error, "GetConfigEntry");

    CSASSERT(V_VT(&var)==(VT_ARRAY|VT_UI1));

    hr = myVariantToRegValue(
            &var,
            &dwType,
            &dwSize,
            &pbTmp);
    _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");

    CSASSERT(dwType == REG_BINARY);

    // push result into FileTime
    CSASSERT(dwSize == sizeof(FILETIME));
    FILETIME ftGMT;
    CopyMemory(&ftGMT, pbTmp, sizeof(FILETIME));

    LOCAL_FREE(pbTmp);
    pbTmp=NULL;

    // Convert to localized time localized string
    hr = myGMTFileTimeToWszLocalTime(&ftGMT, FALSE, (LPWSTR*) &pbTmp);
    _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");

    m_cstrDeltaLastCRLPublish = (LPWSTR)pbTmp;

error:
    LOCAL_FREE(pbTmp);
    return; // ignore errors
}


void
CCRLPropPage::OnCheckBoxChange(
    BOOL) // fDisableBaseCRL
{
    UpdateData(TRUE);

    if(m_iDeltaPublish == BST_UNCHECKED)
    {
        m_cstrDeltaLastCRLPublish = L"";
        m_cstrDeltaLastCRLPublish.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE));
    }

    // pull in new selection
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_COMBO_DELTACRLPERIODSTRING), (m_iDeltaPublish == BST_CHECKED));
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT), (m_iDeltaPublish == BST_CHECKED));
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DELTALASTUPDATE), (m_iDeltaPublish == BST_CHECKED));

    // call normal edit change to whack modified bit
    OnEditChange();
}

void CCRLPropPage::OnEditChange()
{
    // Page is dirty, mark it.
    SetModified();	
    m_bUpdate = TRUE;
}


BOOL CCRLPropPage::OnApply()
{
    HRESULT hr = S_OK;
    BOOL fValidDigitString;
    variant_t var;
    FILETIME ftBase, ftDelta;
	ZeroMemory(&ftBase, sizeof(ftBase));
	ZeroMemory(&ftDelta, sizeof(ftDelta));


    if (m_bUpdate == TRUE)
    {
        int iPublishPeriodCount, iDeltaPublishPeriodCount;

        // check for invalid data in IDC_EDIT_CRLPERIODCOUNT if not autopublishing
        iPublishPeriodCount = myWtoI(m_cstrPublishPeriodCount, &fValidDigitString);
//        if (!m_iNoAutoPublish)
        {
            // invalid data is zero, negative, or not reproducible
            if (!fValidDigitString || 0 == iPublishPeriodCount)
            {
                DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_POSITIVE_NUMBER);
                ::SetFocus(::GetDlgItem(m_hWnd, IDC_EDIT_CRLPERIODCOUNT));
                return FALSE;
            }

        }

        // check for invalid data in IDC_EDIT_DELTACRLPERIODCOUNT if not autopublishing
        iDeltaPublishPeriodCount = myWtoI(m_cstrDeltaPublishPeriodCount, &fValidDigitString);
        if (m_iDeltaPublish)
        {
            if (!fValidDigitString || 0 == iDeltaPublishPeriodCount)
            {
                DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_POSITIVE_NUMBER);
                ::SetFocus(::GetDlgItem(m_hWnd, IDC_EDIT_DELTACRLPERIODCOUNT));
                return FALSE;
            }
        }

        CString cstrTmp;
        ENUM_PERIOD iEnum = (ENUM_PERIOD) m_cboxPublishPeriodString.GetItemData(m_cboxPublishPeriodString.GetCurSel());
        if (StringFromDurationEnum(iEnum, &cstrTmp, FALSE))
        {
//            DWORD dwPublishPeriodCount = (m_iNoAutoPublish == BST_CHECKED) ? 0 : iPublishPeriodCount;
            DWORD dwPublishPeriodCount = iPublishPeriodCount;
            var = cstrTmp;

            // create comparison value for later
            myMakeExprDateTime(
                &ftBase,
                dwPublishPeriodCount,
                iEnum);

            hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGCRLPERIODSTRING,
                &var);
            _JumpIfError(hr, Ret, "SetConfigEntry");

            var.Clear();
            V_VT(&var) = VT_I4;
            V_I4(&var) = dwPublishPeriodCount;

            // use chkbox
            hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGCRLPERIODCOUNT,
                &var);
            _JumpIfError(hr, Ret, "SetConfigEntry");
        }

        iEnum = (ENUM_PERIOD)m_cboxDeltaPublishPeriodString.GetItemData(m_cboxDeltaPublishPeriodString.GetCurSel());
        if (StringFromDurationEnum(iEnum, &cstrTmp, FALSE))
        {
            DWORD dwDeltaPublishPeriodCount = (m_iDeltaPublish == BST_UNCHECKED) ? 0 : iDeltaPublishPeriodCount;
            var = cstrTmp;

            // create comparison value for later
            myMakeExprDateTime(
                &ftDelta,
                dwDeltaPublishPeriodCount,
                iEnum);

            if (-1 != CompareFileTime(&ftDelta,&ftBase))	// if delta not less
            {
                 dwDeltaPublishPeriodCount = 0; // disable
                 m_iDeltaPublish = BST_UNCHECKED;
            }
//            else
//                 m_iDeltaPublish = BST_CHECKED;

            hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGCRLDELTAPERIODSTRING,
                &var);
            _JumpIfError(hr, Ret, "SetConfigEntry");

            var.Clear();
            V_VT(&var) = VT_I4;
            V_I4(&var) = dwDeltaPublishPeriodCount;

            // use chkbox
            hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGCRLDELTAPERIODCOUNT,
                &var);
            _JumpIfError(hr, Ret, "SetConfigEntry");

            if(!m_iDeltaPublish)
            {
                var.Clear();
                V_VT(&var) = VT_EMPTY; // delete entry
                hr = m_pCA->SetConfigEntry(
                    NULL,
                    wszREGCRLDELTANEXTPUBLISH,
                    &var);
                if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    hr = S_OK; // if already deleted, don't care.
                _JumpIfError(hr, Ret, "SetConfigEntry");
            }
        }
    m_bUpdate = FALSE;
    }
Ret:
    if (hr != S_OK)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}


///////////////////////////////////////////
// CCRLViewPage
/////////////////////////////////////////////////////////////////////////////
// CCRLViewPage property page
CCRLViewPage::CCRLViewPage(CCRLPropPage* pControlPage, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pControlPage(pControlPage)
{
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CRL_VIEWPAGE);
}

CCRLViewPage::~CCRLViewPage()
{
}

// replacement for DoDataExchange
BOOL CCRLViewPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL
CCRLViewPage::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    BOOL  fBaseCRL = TRUE;
    switch(LOWORD(wParam))
    {
        case IDC_CRL_VIEW_BTN_VIEWDELTA:
            fBaseCRL = FALSE;
            //fall through
        case IDC_CRL_VIEW_BTN_VIEWCRL:
        if (BN_CLICKED == HIWORD(wParam))
            OnViewCRL(fBaseCRL);
        break;
        default:
        //return FALSE;
	return TRUE;
        break;
    }
    return TRUE;
}

BOOL CCRLViewPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    BOOL fBaseCRL = TRUE;

    switch(idCtrl)
    {
        //handle double click on list items
        case IDC_CRL_VIEW_LIST_DELTA:
            fBaseCRL = FALSE;
            //fall through
        case IDC_CRL_VIEW_LIST_CRL:
            switch (pnmh->code)
            {
            case NM_DBLCLK:
                OnViewCRL(fBaseCRL);
                break;
            case LVN_ITEMCHANGED:
                OnSelectCRL(fBaseCRL);
                break;
    
            }
            break;
    }
    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCRLViewPage message handlers

/*

To get the CA signature cert count, use ICertAdmin::GetCAProperty(
strConfig,
PropId == CR_PROP_CASIGCERTCOUNT,
PropIndex == 0 (unused),
PropType == PROPTYPE_LONG,
Flags == CR_OUT_BINARY,
&varPropertyValue);
varPropertyValue.vt will be VT_I4
varPropertyValue.lVal will be the CA signature cert count

then step key index from 0 to 1 less than the count of signature certs to determine which key indices have valid CRLs:
To get each key's CRL state, call ICertAdmin2::GetCAProperty(
strConfig,
PropId == CR_PROP_CRLSTATE,
PropIndex == key index (MAXDWORD for current key),
PropType == PROPTYPE_LONG,
Flags == CR_OUT_BINARY,
&varPropertyValue);
varPropertyValue.vt will be VT_I4
varPropertyValue.lVal will be the CRL state, CA_DISP_VALID means you can fetch the CRL for that index.

To get each key's CRL, call ICertAdmin2::GetCAProperty(
strConfig,
PropId == CR_PROP_BASECRL or CR_PROP_DELTACRL,
PropIndex == key index (MAXDWORD for current key),
PropType == PROPTYPE_BINARY,
Flags == CR_OUT_BINARY,
&varPropertyValue);
varPropertyValue.vt will be VT_BSTR
varPropertyValue.bstrVal can be cast to BYTE *pbCRL
SysStringByteLen(varPropertyValue.bstrVal) will be cbCRL

If the server is down level, all GetCAProperty method calls will return RPC_E_VERSION_MISMATCH.  Then you have two choices:
use ICertAdmin::GetCRL, which will only retrieve the current key's base CRL
to fetch a CAINFO structure to get the CA signature cert count, use ICertRequest::GetCACertificate(
fExchangeCertificate == GETCERT_CAINFO,
strConfig,
Flags == CR_OUT_BINARY,
&strOut);
strCACertificate will be a Unicode BSTR, something like: L"3,1".  The first number is the CA Type, and the second is the count of CA signature certs.

then step key index from 0 to 1 less than the count of signature certs to determine which key indices have valid CRLs:
To get each key's CRL state, call ICertRequest::GetCACertificate(
fExchangeCertificate == GETCERT_CRLSTATEBYINDEX | key index),
strConfig,
Flags == CR_OUT_BINARY,
&strOut);
strCACertificate will be a Unicode BSTR, something like: L"3".  After converting to a DWORD, CA_DISP_VALID means you can fetch the CRL for that index.

To get each key's CRL, call ICertRequest::GetCACertificate(	// can retrieve only base CRLs for all server keys
fExchangeCertificate == GETCERT_CRLBYINDEX | key index (MAXDWORD not supported here),
strConfig,
Flags == CR_OUT_BINARY,
&strOut);
strOut can be cast to BYTE *pbCRL
SysStringByteLen(strOut) will be cbCRL

*/

void MapCRLPublishStatusToString(DWORD dwStatus, CString& strStatus)
{
    strStatus.LoadString(
        dwStatus?
        ((dwStatus&CPF_COMPLETE)?
          IDS_CRLPUBLISHSTATUS_OK:
          IDS_CRLPUBLISHSTATUS_FAILED):
        IDS_CRLPUBLISHSTATUS_UNKNOWN);
}

void
ListView_AddCRLItem(
    IN HWND hwndList,
    IN int iItem,
    IN DWORD dwIndex,
    IN PCCRL_CONTEXT pCRLContext,
    IN DWORD dwCRLPublishStatus)
{
    CString cstrItemName;
    CString cstrCRLPublishStatus;

    MapCRLPublishStatusToString(dwCRLPublishStatus, cstrCRLPublishStatus);

    // add column data for crl
    // renew index
    cstrItemName.Format(L"%d", dwIndex);
    ListView_NewItem(hwndList, iItem, cstrItemName, (LPARAM)pCRLContext);

    if (pCRLContext)	// on error, don't add these
{
    // crl effective date
    ListView_SetItemFiletime(hwndList, iItem, 1, &pCRLContext->pCrlInfo->ThisUpdate);
    // crl expiration date
    ListView_SetItemFiletime(hwndList, iItem, 2, &pCRLContext->pCrlInfo->NextUpdate);
}
    // crl publish status
    ListView_SetItemText(hwndList, iItem, 3, cstrCRLPublishStatus.GetBuffer());
}

void
ListView_AddFailedCRLItem(
    IN HWND hwndList,
    IN int iItem,
    IN DWORD dwIndex,
    LPCWSTR pcwszMessage
)
{
    CString cstrItemName;

    // add column data for crl
    // renew index
    cstrItemName.Format(L"%d", dwIndex);
    ListView_NewItem(hwndList, iItem, cstrItemName, NULL);

    ListView_SetItemText(hwndList, iItem, 1, const_cast<LPWSTR>(pcwszMessage));
}

void
ListView_AddFailedCRLItem2(
    IN HWND hwndList,
    IN int iItem,
    IN DWORD dwIndex,
    HRESULT hr
)
{
    CString strMsg;
    CString strFormat;
    LPCWSTR pcwszError;

    pcwszError = myGetErrorMessageText(hr, TRUE);
    strFormat.LoadString(IDS_CRLERROR_FORMAT);
    
    strMsg.Format(strFormat, pcwszError?pcwszError:L"");

    ListView_AddFailedCRLItem(
        hwndList,
        iItem,
        dwIndex,
        strMsg); 
    
    LOCAL_FREE(const_cast<LPWSTR>(pcwszError));
}

BOOL CCRLViewPage::OnInitDialog()
{
	HRESULT hr;
	ICertAdmin2* pAdmin = NULL;
	VARIANT varPropertyValue, varCRLStatus;
	VariantInit(&varPropertyValue);
    VariantInit(&varCRLStatus);

	DWORD cCertCount, dwCertIndex;
	CString cstrItemName;
	int  iItem = 0, iDeltaItem = 0;
    HWND hwndListCRL, hwndListDeltaCRL;
    PCCRL_CONTEXT pCRLContext = NULL;
    PCCRL_CONTEXT pDeltaCRLContext = NULL;
    CWaitCursor WaitCursor;
    CString strMessage;

    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

	// init listview
	hwndListCRL = GetDlgItem(m_hWnd, IDC_CRL_VIEW_LIST_CRL);
	hwndListDeltaCRL = GetDlgItem(m_hWnd, IDC_CRL_VIEW_LIST_DELTA);

    //make listviews whole row selection
    ListView_SetExtendedListViewStyle(hwndListCRL, LVS_EX_FULLROWSELECT);
    ListView_SetExtendedListViewStyle(hwndListDeltaCRL, LVS_EX_FULLROWSELECT);

    //add multiple columns
    //column 0
    cstrItemName.LoadString(IDS_CRL_LISTCOL_INDEX);
    ListView_NewColumn(hwndListCRL, 0, 60, (LPWSTR)(LPCWSTR)cstrItemName);
    ListView_NewColumn(hwndListDeltaCRL, 0, 60, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 1
    cstrItemName.LoadString(IDS_LISTCOL_EFFECTIVE_DATE);
    ListView_NewColumn(hwndListCRL, 1, 105, (LPWSTR)(LPCWSTR)cstrItemName);
    ListView_NewColumn(hwndListDeltaCRL, 1, 105, (LPWSTR)(LPCWSTR)cstrItemName);
    //column 2
    cstrItemName.LoadString(IDS_LISTCOL_EXPIRATION_DATE);
    ListView_NewColumn(hwndListCRL, 2, 105, (LPWSTR)(LPCWSTR)cstrItemName);
    ListView_NewColumn(hwndListDeltaCRL, 2, 105, (LPWSTR)(LPCWSTR)cstrItemName);

    //column 3
    cstrItemName.LoadString(IDS_LISTCOL_PUBLISH_STATUS);
    ListView_NewColumn(hwndListCRL, 3, 83, (LPWSTR)(LPCWSTR)cstrItemName);
    ListView_NewColumn(hwndListDeltaCRL, 3, 83, (LPWSTR)(LPCWSTR)cstrItemName);

    hr = m_pControlPage->m_pCA->m_pParentMachine->GetAdmin2(&pAdmin);
    _JumpIfError(hr, Ret, "GetAdmin");

	// load crls here
	hr = pAdmin->GetCAProperty(
		m_pControlPage->m_pCA->m_bstrConfig,
		CR_PROP_CASIGCERTCOUNT,
		0, // (unused)
		PROPTYPE_LONG, // PropType
		CR_OUT_BINARY, // Flags
		&varPropertyValue);
	_JumpIfErrorStr(hr, Ret, "GetCAProperty", L"CR_PROP_CASIGCERTCOUNT");

    CSASSERT(VT_I4 == V_VT(&varPropertyValue));

	cCertCount = varPropertyValue.lVal;

    iItem = 0;
    iDeltaItem = 0;

    for (dwCertIndex=0; dwCertIndex<cCertCount; dwCertIndex++)
    {
        VariantClear(&varPropertyValue);
        VariantClear(&varCRLStatus);
        bool fFetchBaseCRL = false;
        bool fFetchDeltaCRL = false;
        CERT_EXTENSION *pExt = NULL;

        // get each key's CRL state
        hr = pAdmin->GetCAProperty(
            m_pControlPage->m_pCA->m_bstrConfig,
            CR_PROP_CRLSTATE, //PropId
            dwCertIndex, //PropIndex
            PROPTYPE_LONG, // PropType
            CR_OUT_BINARY, // Flags
            &varPropertyValue);
        _PrintIfErrorStr(hr, "GetCAProperty", L"CR_PROP_CRLSTATE");

        if(S_OK == hr)
        {
            CSASSERT(VT_I4 == V_VT(&varPropertyValue));

            switch(V_I4(&varPropertyValue))
            {
            case CA_DISP_ERROR:
                continue;
            case CA_DISP_REVOKED:
                strMessage.LoadString(IDS_CRLSTATE_REVOKED);
                break;
            case CA_DISP_INVALID:
            case CA_DISP_VALID:
                fFetchBaseCRL = true;
                break;
            }

            if(fFetchBaseCRL)
            {
                hr = m_pControlPage->m_pCA->GetCRLByKeyIndex(&pCRLContext, TRUE, dwCertIndex);
		if (S_OK != hr)
		{
		    _PrintError(hr, "GetCRLByKeyIndex (base)");
		    if (CA_DISP_INVALID == V_I4(&varPropertyValue))
		    {
			continue;
		    }
		}
                else
                {
                    // zero means Unknown error
                    V_VT(&varCRLStatus) = VT_I4;
                    V_I4(&varCRLStatus) = 0;

                    hr = pAdmin->GetCAProperty(
                        m_pControlPage->m_pCA->m_bstrConfig,
                        CR_PROP_BASECRLPUBLISHSTATUS,
                        dwCertIndex,
                        PROPTYPE_LONG,
                        CR_OUT_BINARY,
                        &varCRLStatus);
                    _PrintIfErrorStr(hr, "GetCAProperty (base)", 
                        L"CR_PROP_BASECRLPUBLISHSTATUS"); // in case of error, will show "Unknown"

                    ListView_AddCRLItem(
                        hwndListCRL,
                        iItem,
                        dwCertIndex,
                        pCRLContext,
                        V_I4(&varCRLStatus));

                    pExt = CertFindExtension(
                        szOID_FRESHEST_CRL,
                        pCRLContext->pCrlInfo->cExtension,
                        pCRLContext->pCrlInfo->rgExtension);

                    fFetchDeltaCRL = (NULL != pExt);

                    pCRLContext = NULL;
                    hr = S_OK;
                }
            }
            else
            {
                ListView_AddFailedCRLItem(
                    hwndListCRL,
                    iItem,
                    dwCertIndex,
                    strMessage);

                hr = S_OK;
            }
        }

        if(S_OK != hr)
        {
            ListView_AddFailedCRLItem2(
                hwndListCRL,
                iItem,
                dwCertIndex,
                hr);
        }

        iItem++;

        if(fFetchDeltaCRL)
        {
            if(fFetchBaseCRL)
            {
                // Delta
                VariantClear(&varCRLStatus);

                hr = m_pControlPage->m_pCA->GetCRLByKeyIndex(&pDeltaCRLContext, FALSE, dwCertIndex);
                _PrintIfError(hr, "GetCRLByKeyIndex (delta)");

                if(S_OK == hr)
                {
                    // zero is status Unknown
                    V_VT(&varCRLStatus) = VT_I4;
                    V_I4(&varCRLStatus) = 0;

                    hr = pAdmin->GetCAProperty(
                            m_pControlPage->m_pCA->m_bstrConfig,
                            CR_PROP_DELTACRLPUBLISHSTATUS,
                            dwCertIndex,
                            PROPTYPE_LONG,
                            CR_OUT_BINARY,
                            &varCRLStatus);
                    _PrintIfErrorStr(hr, "GetCAProperty (delta)", 
                        L"CR_PROP_DELTACRLPUBLISHSTATUS"); // in case of error will show "Unknown"

                    ListView_AddCRLItem(
                        hwndListDeltaCRL,
                        iDeltaItem,
                        dwCertIndex,
                        pDeltaCRLContext,
                        V_I4(&varCRLStatus));

                    //don't free, they are used as item data, will free in OnDestroy
                    pDeltaCRLContext = NULL;
                }
                else
                {
                    ListView_AddFailedCRLItem2(
                        hwndListDeltaCRL,
                        iDeltaItem,
                        dwCertIndex,
                        hr);
                }
            }
            else
            {
                ListView_AddFailedCRLItem(
                    hwndListDeltaCRL,
                    iDeltaItem,
                    dwCertIndex,
                    strMessage);
            }
            iDeltaItem++;
        }

        hr = S_OK;
    }

    if (0 < iItem)
    {
        //select most recent item
        ListView_SetItemState(
            hwndListCRL, 
            iItem-1,
            LVIS_SELECTED|LVIS_FOCUSED, 
            LVIS_SELECTED|LVIS_FOCUSED);
        
        // make sure it's visible
        ListView_EnsureVisible(
            hwndListCRL, 
            iItem-1,
            FALSE); // fPartialOK
    }

    if(0 < iDeltaItem)
    {
        ListView_SetItemState(
            hwndListDeltaCRL, 
            iDeltaItem-1,
            LVIS_SELECTED|LVIS_FOCUSED, 
            LVIS_SELECTED|LVIS_FOCUSED);

        // make sure it's visible
        ListView_EnsureVisible(
            hwndListDeltaCRL, 
            iDeltaItem-1,
            FALSE); // fPartialOK

    }

    UpdateData(FALSE);
    hr = S_OK;

Ret:
    if (NULL != pCRLContext)
    {
        CertFreeCRLContext(pCRLContext);
    }
    if (NULL != pDeltaCRLContext)
    {
        CertFreeCRLContext(pDeltaCRLContext);
    }
	if (pAdmin)
		pAdmin->Release();
	
	VariantClear(&varPropertyValue);
	
	if (hr != S_OK)
    {
        HideControls();
        EnableWindow(GetDlgItem(IDC_UNAVAILABLE), TRUE);
        ShowWindow(GetDlgItem(IDC_UNAVAILABLE), SW_SHOW);
    }

    return TRUE;
}

DWORD CertAdminViewCRL(CertSvrCA* pCertCA, HWND hwnd, PCCRL_CONTEXT pCRLContext)
{
    DWORD dwErr;

    HCERTSTORE      rghStores[2];

    CRYPTUI_VIEWCRL_STRUCT sViewCRL;
    ZeroMemory(&sViewCRL, sizeof(sViewCRL));

    if (pCRLContext == NULL)
    {
       _PrintError(E_POINTER, "pCRLContext");
       dwErr = S_OK;
       goto Ret;
    }

    sViewCRL.dwSize = sizeof(sViewCRL);
    sViewCRL.hwndParent = hwnd;
    sViewCRL.pCRLContext = pCRLContext;
    sViewCRL.dwFlags = CRYPTUI_ENABLE_REVOCATION_CHECKING |
                        CRYPTUI_DISABLE_ADDTOSTORE;

    // if we're opening remotely, don't open local stores
    if (! pCertCA->m_pParentMachine->IsLocalMachine())
    {
        DWORD dw; 

        // get remote stores
        dw = pCertCA->GetRootCertStore(&rghStores[0]);
        _PrintIfError(dw, "GetRootCertStore");

        if (S_OK == dw)
        {
            dw = pCertCA->GetCACertStore(&rghStores[1]);
            _PrintIfError(dw, "GetCACertStore");
        } 

        if (S_OK == dw)
        {
            // rely only on remote machine's stores
            sViewCRL.cStores = 2;
            sViewCRL.rghStores = rghStores;
            sViewCRL.dwFlags |= CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
        }
        else
        {
            // tell user we're only doing this locally
            sViewCRL.dwFlags |= CRYPTUI_WARN_REMOTE_TRUST;
        }
    }

    if (!CryptUIDlgViewCRL(&sViewCRL))
    {
        dwErr = GetLastError();
		if (dwErr != ERROR_CANCELLED)
			_JumpError(dwErr, Ret, "CryptUIDlgViewCRL");
    }

    dwErr = ERROR_SUCCESS;
Ret:
    return dwErr;
}

void CCRLViewPage::OnSelectCRL(BOOL fBaseCRL)
{
    PCCRL_CONTEXT pCRLContext;
    BOOL fEnable = FALSE;
    HWND hwndList = GetDlgItem(m_hWnd, (fBaseCRL ?
                      IDC_CRL_VIEW_LIST_CRL : IDC_CRL_VIEW_LIST_DELTA));

    // get cert # from item data
    int iSel = ListView_GetCurSel(hwndList);
    if (-1 != iSel)

    {
        // get item data
        pCRLContext = (PCCRL_CONTEXT)ListView_GetItemData(hwndList, iSel);
        if (NULL != pCRLContext)
            fEnable = TRUE;
    }

    ::EnableWindow(
        GetDlgItem(m_hWnd, 
        fBaseCRL?
        IDC_CRL_VIEW_BTN_VIEWCRL:
        IDC_CRL_VIEW_BTN_VIEWDELTA),
        fEnable);
}

void CCRLViewPage::OnViewCRL(BOOL fViewBaseCRL)
{
	DWORD dw;
    PCCRL_CONTEXT pCRLContext;
    HWND hwndList = GetDlgItem(m_hWnd, (fViewBaseCRL ?
                      IDC_CRL_VIEW_LIST_CRL : IDC_CRL_VIEW_LIST_DELTA));

    // get cert # from item data
    int iSel = ListView_GetCurSel(hwndList);
    if (-1 == iSel)
        return;

    // get item data
    pCRLContext = (PCCRL_CONTEXT)ListView_GetItemData(hwndList, iSel);
    if (NULL == pCRLContext)
        return;
	
    dw = CertAdminViewCRL(m_pControlPage->m_pCA, m_hWnd, pCRLContext);
    _PrintIfError(dw, "CertAdminViewCRL");
	
    if ((dw != ERROR_SUCCESS) && (dw != ERROR_CANCELLED))
        DisplayGenericCertSrvError(m_hWnd, dw);

}

void
FreeListViewCRL(HWND hwndList, int iItem)
{
    PCCRL_CONTEXT pCRLContext;

    pCRLContext = (PCCRL_CONTEXT)ListView_GetItemData(hwndList, iItem);
    if (pCRLContext != NULL)	
        CertFreeCRLContext(pCRLContext);
}

void CCRLViewPage::OnDestroy()
{
    int i;
	HWND hwndListCRL = GetDlgItem(m_hWnd, IDC_CRL_VIEW_LIST_CRL);
	HWND hwndListDeltaCRL = GetDlgItem(m_hWnd, IDC_CRL_VIEW_LIST_DELTA);
    int iCRLCount = ListView_GetItemCount(hwndListCRL);
    int iDeltaCRLCount = ListView_GetItemCount(hwndListDeltaCRL);

    //free all crl context
    for (i = 0; i < iCRLCount; ++i)
    {
        FreeListViewCRL(hwndListCRL, i);
    }

    for (i = 0; i < iDeltaCRLCount; ++i)
    {
        FreeListViewCRL(hwndListDeltaCRL, i);
    }

    CAutoDeletePropPage::OnDestroy();
}


///////////////////////////////////////////
// CBackupWizPage1
/////////////////////////////////////////////////////////////////////////////
// CBackupWizPage1 property page

CBackupWizPage1::CBackupWizPage1(
    BACKUPWIZ_STATE* pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    InitWizard97 (TRUE);	// firstlast page

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

CBackupWizPage1::~CBackupWizPage1()
{
}

// replacement for DoDataExchange
BOOL CBackupWizPage1::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CBackupWizPage1::OnCommand(
    WPARAM, // wParam
    LPARAM) // lParam
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}


BOOL CBackupWizPage1::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    // firstlast page
    //(GetDlgItem(IDC_TEXT_BIGBOLD))->SetFont(&(GetBigBoldFont()), TRUE);
    SendMessage(GetDlgItem(IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));

    return TRUE;
}

BOOL CBackupWizPage1::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);

	return TRUE;
}

///////////////////////////////////////////
// CBackupWizPage2
/////////////////////////////////////////////////////////////////////////////
// CBackupWizPage2 property page

CBackupWizPage2::CBackupWizPage2(
    PBACKUPWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    m_szHeaderTitle.LoadString(IDS_WIZ97TITLE_BACKUPWIZPG2);
    m_szHeaderSubTitle.LoadString(IDS_WIZ97SUBTITLE_BACKUPWIZPG2);
	InitWizard97 (FALSE);
    m_cstrLogsPath = L"";
    m_iKeyCertCheck = BST_UNCHECKED;
    m_iLogsCheck = BST_UNCHECKED;
    m_iIncrementalCheck = BST_UNCHECKED;

    DWORD dwRet;
    m_fIncrementalAllowed = FALSE;

    variant_t var;
    dwRet = m_pState->pCA->m_pParentMachine->GetRootConfigEntry(
                wszREGDBLASTFULLBACKUP,
                &var);
    if(S_OK==dwRet)
    {
        m_fIncrementalAllowed = TRUE;
    }

//    SetHelp(CERTMMC_HELPFILENAME , g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CBackupWizPage2::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrLogsPath.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOGS));

        m_iKeyCertCheck = (INT)SendDlgItemMessage(IDC_CHECK_KEYCERT, BM_GETCHECK, 0, 0);
        m_iLogsCheck = (INT)SendDlgItemMessage(IDC_CHECK_LOGS, BM_GETCHECK, 0, 0);
        m_iIncrementalCheck = (INT)SendDlgItemMessage(IDC_CHECK_INCREMENTAL, BM_GETCHECK, 0, 0);
    }
    else
    {
        m_cstrLogsPath.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOGS));

        SendDlgItemMessage(IDC_CHECK_KEYCERT, BM_SETCHECK, (WPARAM)m_iKeyCertCheck, 0);
        SendDlgItemMessage(IDC_CHECK_LOGS, BM_SETCHECK, (WPARAM)m_iLogsCheck, 0);
        SendDlgItemMessage(IDC_CHECK_INCREMENTAL, BM_SETCHECK, (WPARAM)m_iIncrementalCheck, 0);

        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_INCREMENTAL), m_fIncrementalAllowed && (m_iLogsCheck == BST_CHECKED) );
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CBackupWizPage2::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    switch(LOWORD(wParam))
    {
    case IDC_BROWSE_LOGS:
        if (BN_CLICKED == HIWORD(wParam))
            OnBrowse();
        break;
    case IDC_CHECK_LOGS:
        if (BN_CLICKED == HIWORD(wParam))
        {
            m_iLogsCheck = (INT)SendDlgItemMessage(IDC_CHECK_LOGS, BM_GETCHECK, 0, 0);
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_INCREMENTAL), m_fIncrementalAllowed && (m_iLogsCheck == BST_CHECKED) );
        }
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


BOOL CBackupWizPage2::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    return TRUE;
}

BOOL CBackupWizPage2::OnSetActive()
{
    PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_NEXT));

    // don't allow PFX across machines
    if (! m_pState->pCA->m_pParentMachine->IsLocalMachine())
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_KEYCERT), FALSE);

    // get from state
    m_iKeyCertCheck = (m_pState->fBackupKeyCert) ? BST_CHECKED : BST_UNCHECKED;
    m_iLogsCheck = (m_pState->fBackupLogs) ? BST_CHECKED : BST_UNCHECKED;
    m_iIncrementalCheck = (m_pState->fIncremental) ? BST_CHECKED : BST_UNCHECKED;
    if (m_pState->szLogsPath)
        m_cstrLogsPath = m_pState->szLogsPath;

	return TRUE;
}



void CBackupWizPage2::OnBrowse()
{
    UpdateData(TRUE);

    LPCWSTR pszInitialDir;
    WCHAR  szCurDir[MAX_PATH];

    if (m_cstrLogsPath.IsEmpty())
    {
        if (0 == GetCurrentDirectory(MAX_PATH, szCurDir) )
            pszInitialDir = L"C:\\";
        else
            pszInitialDir = szCurDir;
    }
    else
        pszInitialDir = m_cstrLogsPath;

    WCHAR szFileBuf[MAX_PATH+1]; szFileBuf[0] = L'\0';
    if (!BrowseForDirectory(
            m_hWnd,
            pszInitialDir,
            szFileBuf,
            MAX_PATH,
            NULL))
        return;

    m_cstrLogsPath = szFileBuf;

    UpdateData(FALSE);
    return;
}


HRESULT CBackupWizPage2::ConvertLogsPathToFullPath()
{
    LPWSTR pwszFullPath = NULL;
    DWORD cFullPath = 0;
    HRESULT hr;

    cFullPath = GetFullPathName(
                    m_cstrLogsPath,
                    0,
                    NULL,
                    NULL);
    if(!cFullPath)
        return(myHLastError());

    pwszFullPath = (LPWSTR)LocalAlloc(LMEM_FIXED, cFullPath*sizeof(WCHAR));
    if(!pwszFullPath)
        return E_OUTOFMEMORY;
    cFullPath = GetFullPathName(
                    m_cstrLogsPath,
                    cFullPath,
                    pwszFullPath,
                    NULL);
    if(cFullPath == 0)
    {
        hr = myHLastError();
        goto Ret;
    }


    m_cstrLogsPath = pwszFullPath;
    hr = S_OK;
Ret:
    if(pwszFullPath)
        LocalFree(pwszFullPath);
    return hr;
}

LRESULT CBackupWizPage2::OnWizardNext()
{
    HRESULT hr;
    UpdateData(TRUE);

    // persist to state structure
    m_pState->fBackupKeyCert = (m_iKeyCertCheck == BST_CHECKED);
    m_pState->fBackupLogs = (m_iLogsCheck == BST_CHECKED);
    m_pState->fIncremental = (m_iIncrementalCheck == BST_CHECKED);

    if (!
        (m_pState->fBackupKeyCert ||
        m_pState->fBackupLogs) )
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_REQUIRE_ONE_SELECTION);
        return -1;
    }



    // empty?
    if ( m_cstrLogsPath.IsEmpty() )
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_NEED_FILEPATH);
        return -1;
    }

    hr = ConvertLogsPathToFullPath();
    if(S_OK != hr)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        return -1;
    }

    // make sure we're a valid directory
    if (!myIsDirectory(m_cstrLogsPath))
    {
        CString cstrTitle, cstrFmt, cstrMsg;
        cstrTitle.FromWindow(m_hWnd);  // use same title as parent has
        cstrFmt.LoadString(IDS_DIR_CREATE);
        cstrMsg.Format(cstrFmt, m_cstrLogsPath);

        if (IDOK != MessageBox(m_hWnd, cstrMsg, cstrTitle, MB_OKCANCEL))
           return -1;

        hr = myCreateNestedDirectories(m_cstrLogsPath);
        _PrintIfError(hr, "myCreateNestedDirectories");
        if (hr != S_OK)
        {
            DisplayGenericCertSrvError(m_hWnd, hr);
            return -1;
        }
    }

    hr = myIsDirWriteable(
        m_cstrLogsPath,
        FALSE);
    _PrintIfError(hr, "myIsDirWriteable");
    if (hr != S_OK)
    {
        DisplayCertSrvErrorWithContext(m_hWnd, hr, IDS_DIR_NOT_WRITEABLE);
        return -1;
    }

    // if backing up db, make sure there's no \DataBase folder here
    if (m_pState->fBackupLogs)
    {
        DWORD dwFlags = CDBBACKUP_VERIFYONLY;
        dwFlags |= m_pState->fIncremental ? CDBBACKUP_INCREMENTAL : 0;
        hr = myBackupDB(
            (LPCWSTR)m_pState->pCA->m_strConfig,
            dwFlags,
            m_cstrLogsPath,
    	    NULL);
        _PrintIfError(hr, "myBackupDB");
        if (hr != S_OK)
        {
            DisplayCertSrvErrorWithContext(m_hWnd, hr, IDS_CANT_ACCESS_BACKUP_DIR);
            return -1;
        }
    }


    if (m_pState->fBackupKeyCert ||
        m_pState->fBackupLogs)
    {
        // free if exists
        if (m_pState->szLogsPath)
            LocalFree(m_pState->szLogsPath);

        // alloc anew
        m_pState->szLogsPath = (LPWSTR)LocalAlloc(LMEM_FIXED, WSZ_BYTECOUNT((LPCWSTR)m_cstrLogsPath));

        // copy
        if (m_pState->szLogsPath)
            wcscpy(m_pState->szLogsPath, (LPCWSTR)m_cstrLogsPath);
    }


    // skip "get password"?
    if (!m_pState->fBackupKeyCert)
        return IDD_BACKUPWIZ_COMPLETION;

    return 0;
}


///////////////////////////////////////////
// CBackupWizPage3
/////////////////////////////////////////////////////////////////////////////
// CBackupWizPage3 property page

CBackupWizPage3::CBackupWizPage3(
    PBACKUPWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    m_szHeaderTitle.LoadString(IDS_WIZ97TITLE_BACKUPWIZPG3);
    m_szHeaderSubTitle.LoadString(IDS_WIZ97SUBTITLE_BACKUPWIZPG3);
	InitWizard97 (FALSE);
    m_cstrPwd = L"";
    m_cstrPwdVerify = L"";

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CBackupWizPage3::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrPwd.FromWindow(GetDlgItem(m_hWnd, IDC_NEW_PASSWORD));
        m_cstrPwdVerify.FromWindow(GetDlgItem(m_hWnd, IDC_CONFIRM_PASSWORD));
    }
    else
    {
        m_cstrPwd.ToWindow(GetDlgItem(m_hWnd, IDC_NEW_PASSWORD));
        m_cstrPwdVerify.ToWindow(GetDlgItem(m_hWnd, IDC_CONFIRM_PASSWORD));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CBackupWizPage3::OnCommand(
    WPARAM, // wParam
    LPARAM) // lParam
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}


BOOL CBackupWizPage3::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    return TRUE;
}

BOOL CBackupWizPage3::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_NEXT));

	return TRUE;
}

LRESULT CBackupWizPage3::OnWizardNext()
{
    UpdateData(TRUE);
    if (! m_cstrPwd.IsEqual(m_cstrPwdVerify))
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_PASSWORD_NOMATCH);

        m_cstrPwd.Empty();
        m_cstrPwdVerify.Empty();
        UpdateData(FALSE);

        return -1;  // stay here
    }


    // free if exists
    if (m_pState->szPassword)
    {
        SecureZeroMemory(m_pState->szPassword, wcslen(m_pState->szPassword)*sizeof(WCHAR));
        LocalFree(m_pState->szPassword);
    }

    // alloc anew
    m_pState->szPassword = (LPWSTR)LocalAlloc(LMEM_FIXED, WSZ_BYTECOUNT((LPCWSTR)m_cstrPwd));

    // copy
    if (m_pState->szPassword)
        wcscpy(m_pState->szPassword, (LPCWSTR)m_cstrPwd);

    return 0;   // advance
}


///////////////////////////////////////////
// CBackupWizPage5
/////////////////////////////////////////////////////////////////////////////
// CBackupWizPage5 property page

CBackupWizPage5::CBackupWizPage5(
    PBACKUPWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    InitWizard97 (TRUE);	// firstlast page

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CBackupWizPage5::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CBackupWizPage5::OnCommand(
    WPARAM, // wParam
    LPARAM) // lParam
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}



BOOL CBackupWizPage5::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    // firstlast page
    SendMessage(GetDlgItem(IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));


    HWND hList = ::GetDlgItem(m_hWnd, IDC_COMPLETION_LIST);
    LV_COLUMN lvC = { (LVCF_FMT|LVCF_WIDTH), LVCFMT_LEFT, 0, NULL, 0, 0};

    lvC.cx = 675;
    ListView_InsertColumn(hList, 0, &lvC);

    return TRUE;
}

BOOL CBackupWizPage5::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_FINISH));


    CString cstrDialogMsg;
    HWND hList = ::GetDlgItem(m_hWnd, IDC_COMPLETION_LIST);
    LV_ITEM sItem; ZeroMemory(&sItem, sizeof(sItem));

    ListView_DeleteAllItems(hList);

    if (m_pState->fBackupKeyCert)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_KEYANDCERT);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }
    if (m_pState->fBackupLogs)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_CALOGS);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }
    if (m_pState->fIncremental)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_INCREMENTAL_BACKUP);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }

	return TRUE;
}


LRESULT CBackupWizPage5::OnWizardBack()
{
    if (!m_pState->fBackupKeyCert)
        return IDD_BACKUPWIZ_SELECT_DATA;

    return 0;
}



///////////////////////////////////////////
// CRestoreWizPage1
/////////////////////////////////////////////////////////////////////////////
// CRestoreWizPage1 property page
CRestoreWizPage1::CRestoreWizPage1(
    PRESTOREWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    InitWizard97 (TRUE);	// firstlast page

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

CRestoreWizPage1::~CRestoreWizPage1()
{
}

// replacement for DoDataExchange
BOOL CRestoreWizPage1::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CRestoreWizPage1::OnCommand(
    WPARAM, // wParam
    LPARAM) // lParam
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}


BOOL CRestoreWizPage1::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    // firstlast page
    SendMessage(GetDlgItem(IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));


    return TRUE;
}


BOOL CRestoreWizPage1::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);

	return TRUE;
}

///////////////////////////////////////////
// CRestoreWizPage2
/////////////////////////////////////////////////////////////////////////////
// CRestoreWizPage2 property page
CRestoreWizPage2::CRestoreWizPage2(
    PRESTOREWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    m_szHeaderTitle.LoadString(IDS_WIZ97TITLE_RESTOREWIZPG2);
    m_szHeaderSubTitle.LoadString(IDS_WIZ97SUBTITLE_RESTOREWIZPG2);
	InitWizard97 (FALSE);
    m_cstrLogsPath = L"";
    m_iKeyCertCheck = BST_UNCHECKED;
    m_iLogsCheck = BST_UNCHECKED;

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CRestoreWizPage2::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrLogsPath.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOGS));

        m_iKeyCertCheck = (INT)SendDlgItemMessage(IDC_CHECK_KEYCERT, BM_GETCHECK, 0, 0);
        m_iLogsCheck = (INT)SendDlgItemMessage(IDC_CHECK_LOGS, BM_GETCHECK, 0, 0);
    }
    else
    {
        m_cstrLogsPath.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_LOGS));

        SendDlgItemMessage(IDC_CHECK_KEYCERT, BM_SETCHECK, (WPARAM)m_iKeyCertCheck, 0);
        SendDlgItemMessage(IDC_CHECK_LOGS, BM_SETCHECK, (WPARAM)m_iLogsCheck, 0);
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CRestoreWizPage2::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    switch(LOWORD(wParam))
    {
    case IDC_BROWSE_LOGS:
        if (BN_CLICKED == HIWORD(wParam))
            OnBrowse();
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}



BOOL CRestoreWizPage2::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    return TRUE;
}

BOOL CRestoreWizPage2::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_NEXT));

    // get from state
    m_iKeyCertCheck = (m_pState->fRestoreKeyCert) ? BST_CHECKED : BST_UNCHECKED;
    m_iLogsCheck = (m_pState->fRestoreLogs) ? BST_CHECKED : BST_UNCHECKED;
    if (m_pState->szLogsPath)
        m_cstrLogsPath = m_pState->szLogsPath;


	return TRUE;
}

void CRestoreWizPage2::OnBrowse()
{
    UpdateData(TRUE);

    LPCWSTR pszInitialDir;
    WCHAR  szCurDir[MAX_PATH];

    if (m_cstrLogsPath.IsEmpty())
    {
        if (0 == GetCurrentDirectory(MAX_PATH, szCurDir) )
            pszInitialDir = L"C:\\";
        else
            pszInitialDir = szCurDir;
    }
    else
        pszInitialDir = (LPCWSTR)m_cstrLogsPath;

    WCHAR szFileBuf[MAX_PATH+1]; szFileBuf[0] = L'\0';
    if (!BrowseForDirectory(
            m_hWnd,
            pszInitialDir,
            szFileBuf,
            MAX_PATH,
            NULL))
        return;

    m_cstrLogsPath = szFileBuf;

    UpdateData(FALSE);
    return;
}




LRESULT CRestoreWizPage2::OnWizardNext()
{
    HRESULT hr;
    UpdateData(TRUE);

    // persist to state structure
    m_pState->fRestoreKeyCert = (m_iKeyCertCheck == BST_CHECKED);
    m_pState->fRestoreLogs = (m_iLogsCheck == BST_CHECKED);

    if (!
        (m_pState->fRestoreKeyCert ||
        m_pState->fRestoreLogs) )
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_REQUIRE_ONE_SELECTION);
        return -1;
    }


    if ( m_cstrLogsPath.IsEmpty() )
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_NEED_FILEPATH);
        return -1;
    }

    if (!myIsDirectory(m_cstrLogsPath))
    {
        DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_INVALID_DIRECTORY);
        return -1;
    }

    // validate pfx blob
    if (m_pState->fRestoreKeyCert)
    {
        // if pfx not here -- FAIL
        if (myIsDirEmpty(m_cstrLogsPath))
        {
            DisplayCertSrvErrorWithContext(m_hWnd, S_OK, IDS_DIRECTORY_CONTENTS_UNEXPECTED);
            return -1;
        }
    }

    // validate logs path
    if (m_pState->fRestoreLogs)
    {
        // If CDBBACKUP_VERIFYONLY, only verify the passed directory contains valid files
        // and detect INCREMENTAL
        hr = myRestoreDB(
            (LPCWSTR)m_pState->pCA->m_strConfig,
            CDBBACKUP_VERIFYONLY,
            (LPCWSTR)m_cstrLogsPath,
            NULL,
            NULL,
            NULL,
            NULL);
        _PrintIfError(hr, "myRestoreDB Full Restore");
        if (hr != S_OK)
        {
            hr = myRestoreDB(
                (LPCWSTR)m_pState->pCA->m_strConfig,
                CDBBACKUP_VERIFYONLY | CDBBACKUP_INCREMENTAL,
                (LPCWSTR)m_cstrLogsPath,
                NULL,
                NULL,
                NULL,
                NULL);
            _PrintIfError(hr, "myRestoreDB Incremental Restore");
            if (hr != S_OK)
            {
                DisplayCertSrvErrorWithContext(m_hWnd, hr, IDS_DIRECTORY_CONTENTS_UNEXPECTED);
                return -1;
            }

            // if incremental, set struct bool
            m_pState->fIncremental = TRUE;
        }
    }


    if (m_pState->fRestoreKeyCert ||
        m_pState->fRestoreLogs)
    {
        // free if exists
        if (m_pState->szLogsPath)
            LocalFree(m_pState->szLogsPath);

        // alloc anew
        m_pState->szLogsPath = (LPWSTR)LocalAlloc(LMEM_FIXED, WSZ_BYTECOUNT((LPCWSTR)m_cstrLogsPath));

        // copy
        if (m_pState->szLogsPath)
            wcscpy(m_pState->szLogsPath, (LPCWSTR)m_cstrLogsPath);
    }


    // skip get password?
    if (!m_pState->fRestoreKeyCert)
        return IDD_RESTOREWIZ_COMPLETION;

    return 0;
}


///////////////////////////////////////////
// CRestoreWizPage3
/////////////////////////////////////////////////////////////////////////////
// CRestoreWizPage3 property page
CRestoreWizPage3::CRestoreWizPage3(
    PRESTOREWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg,
    UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    m_szHeaderTitle.LoadString(IDS_WIZ97TITLE_RESTOREWIZPG3);
    m_szHeaderSubTitle.LoadString(IDS_WIZ97SUBTITLE_RESTOREWIZPG3);
	InitWizard97 (FALSE);
    m_cstrPwd = L"";

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CRestoreWizPage3::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
        m_cstrPwd.FromWindow(GetDlgItem(m_hWnd, IDC_EDIT_PASSWORD));
    }
    else
    {
        m_cstrPwd.ToWindow(GetDlgItem(m_hWnd, IDC_EDIT_PASSWORD));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CRestoreWizPage3::OnCommand(
    WPARAM, // wParam
    LPARAM) // lParam
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}



BOOL CRestoreWizPage3::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    return TRUE;
}

BOOL CRestoreWizPage3::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_NEXT));

	return TRUE;
}

LRESULT CRestoreWizPage3::OnWizardNext()
{
    UpdateData(TRUE);

    // free if exists
    if (m_pState->szPassword)
    {
        SecureZeroMemory(m_pState->szPassword, wcslen(m_pState->szPassword)*sizeof(WCHAR));
        LocalFree(m_pState->szPassword);
    }

    // alloc anew
    m_pState->szPassword = (LPWSTR)LocalAlloc(LMEM_FIXED, WSZ_BYTECOUNT((LPCWSTR)m_cstrPwd));

    // copy
    if (m_pState->szPassword)
        wcscpy(m_pState->szPassword, (LPCWSTR)m_cstrPwd);

    return 0;   // advance
}


///////////////////////////////////////////
// CRestoreWizPage5
/////////////////////////////////////////////////////////////////////////////
// CRestoreWizPage5 property page
CRestoreWizPage5::CRestoreWizPage5(
    PRESTOREWIZ_STATE pState,
    CWizard97PropertySheet *pcDlg, UINT uIDD) :
    CWizard97PropertyPage(g_hInstance, uIDD, g_aidFont),
    m_pState(pState),
    m_pParentSheet(pcDlg)
{
    InitWizard97 (TRUE);	// firstlast page

//    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

// replacement for DoDataExchange
BOOL CRestoreWizPage5::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL
CRestoreWizPage5::OnCommand(
    WPARAM, // wParam
    LPARAM) // lParam
{
//    switch(LOWORD(wParam))
    {
//    default:
        return FALSE;
//        break;
    }
//    return TRUE;
}



BOOL CRestoreWizPage5::OnInitDialog()
{
    // does parent init and UpdateData call
    CWizard97PropertyPage::OnInitDialog();

    // firstlast page
    SendMessage(GetDlgItem(IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));


    HWND hList = ::GetDlgItem(m_hWnd, IDC_COMPLETION_LIST);
    LV_COLUMN lvC = { (LVCF_FMT|LVCF_WIDTH), LVCFMT_LEFT, 0, NULL, 0, 0};

    lvC.cx = 675;
    ListView_InsertColumn(hList, 0, &lvC);

    return TRUE;
}

BOOL CRestoreWizPage5::OnSetActive()
{
	PropertyPage::OnSetActive();

    PropSheet_SetWizButtons(GetParent(), (PSWIZB_BACK | PSWIZB_FINISH));


    CString cstrDialogMsg;
    HWND hList = ::GetDlgItem(m_hWnd, IDC_COMPLETION_LIST);
    LV_ITEM sItem; ZeroMemory(&sItem, sizeof(sItem));

    ListView_DeleteAllItems(hList);

    if (m_pState->fRestoreKeyCert)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_KEYANDCERT);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }
    if (m_pState->fRestoreLogs)
    {
        sItem.iItem = ListView_InsertItem(hList, &sItem);

        cstrDialogMsg.LoadString(IDS_CALOGS);
        ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)(LPCWSTR)cstrDialogMsg);
        sItem.iItem++;
    }

	return TRUE;
}


LRESULT CRestoreWizPage5::OnWizardBack()
{
    if (!m_pState->fRestoreKeyCert)
        return IDD_RESTOREWIZ_SELECT_DATA;

    return 0;
}





////////////////////////////////////////////////////////////////////
// misc UI throwing routines
DWORD CABackupWizard(CertSvrCA* pCertCA, HWND hwnd)
{
    HRESULT             hr;
    BACKUPWIZ_STATE     sBackupState; ZeroMemory(&sBackupState, sizeof(sBackupState));
    sBackupState.pCA = pCertCA;

    InitCommonControls();

    CWizard97PropertySheet cDlg(
			    g_hInstance,
			    IDS_BACKUP_WIZARD,
			    IDB_WIZ,
			    IDB_WIZ_HEAD,
			    TRUE);
    CBackupWizPage1    sPg1(&sBackupState, &cDlg);
    CBackupWizPage2    sPg2(&sBackupState, &cDlg);
    CBackupWizPage3    sPg3(&sBackupState, &cDlg);
    CBackupWizPage5    sPg5(&sBackupState, &cDlg);
    cDlg.AddPage(&sPg1);
    cDlg.AddPage(&sPg2);
    cDlg.AddPage(&sPg3);
    cDlg.AddPage(&sPg5);

    // if not started, start service
    if (!pCertCA->m_pParentMachine->IsCertSvrServiceRunning())
    {
        CString cstrMsg, cstrTitle;
        cstrTitle.LoadString(IDS_BACKUP_WIZARD);
        cstrMsg.LoadString(IDS_START_SERVER_WARNING);
        if (IDOK != MessageBox(hwnd, (LPCWSTR)cstrMsg, (LPCWSTR)cstrTitle, MB_OKCANCEL))
            return ERROR_CANCELLED;

        hr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, TRUE);
        _JumpIfError(hr, Ret, "CertSvrStartStopService");
    }

    // should return value >0 on success
    if (0 >= cDlg.DoWizard(hwnd))
        return ERROR_CANCELLED;

    if (sBackupState.fBackupKeyCert)
    {
        hr = myCertServerExportPFX(
            (LPCWSTR)pCertCA->m_strCommonName,
            sBackupState.szLogsPath,
            sBackupState.szPassword,
	    TRUE,	// fEnhancedStrength
	    TRUE,	// fForceOverWrite
	    TRUE,	// fMustExportPrivateKeys
	    0,		// dwmsTimeout (use default)
            NULL);	// ppwszPFXFile
        if (hr != S_OK)
        {
            CString cstrMsg, cstrTitle;
            cstrTitle.LoadString(IDS_BACKUP_WIZARD);
            cstrMsg.LoadString(IDS_PFX_EXPORT_PRIVKEY_WARNING);
            if (IDOK != MessageBox(hwnd, (LPCWSTR)cstrMsg, (LPCWSTR)cstrTitle, MB_ICONWARNING|MB_OKCANCEL))
            {
                hr = ERROR_CANCELLED;
                _JumpError(hr, Ret, "myCertServerExportPFX user cancel");
            }

            hr = myCertServerExportPFX(
                (LPCWSTR)pCertCA->m_strCommonName,
                sBackupState.szLogsPath,
                sBackupState.szPassword,
		TRUE,	// fEnhancedStrength
		TRUE,	// fForceOverWrite
                FALSE,	// fMustExportPrivateKeys (don't require private keys)
		0,	// dwmsTimeout (use default)
		NULL);	// ppwszPFXFile
            _JumpIfError(hr, Ret, "myCertServerExportPFX");
        }

    }   // sBackupState.fBackupKeyCert


    if (sBackupState.fBackupLogs)
    {
	    DBBACKUPPROGRESS dbp;
	    ZeroMemory(&dbp, sizeof(dbp));

        DWORD dwBackupFlags;
        dwBackupFlags = sBackupState.fIncremental ? CDBBACKUP_INCREMENTAL : 0;

        HANDLE hProgressThread = NULL;
        hProgressThread = StartPercentCompleteDlg(g_hInstance, hwnd, IDS_BACKUP_PROGRESS, &dbp);
        if (hProgressThread == NULL)
        {
            hr = GetLastError();
            _JumpError(hr, Ret, "StartPercentCompleteDlg");
        }

        hr = myBackupDB(
            (LPCWSTR)pCertCA->m_strConfig,
            dwBackupFlags,
            sBackupState.szLogsPath,
    	    &dbp);

        CSASSERT( (S_OK != hr) || (
                                (dbp.dwDBPercentComplete == 100) &&
                                (dbp.dwLogPercentComplete == 100) &&
                                (dbp.dwTruncateLogPercentComplete == 100) )
            );

        if (S_OK != hr)
        {
            dbp.dwDBPercentComplete = 100;
            dbp.dwLogPercentComplete = 100;
            dbp.dwTruncateLogPercentComplete = 100;
        }

        // pause for progress dlg to finish
        EndPercentCompleteDlg(hProgressThread);

        _JumpIfError(hr, Ret, "myBackupDB");
    }

    hr = S_OK;
Ret:
    if (sBackupState.szLogsPath)
        LocalFree(sBackupState.szLogsPath);

    if (sBackupState.szPassword)
    {
        SecureZeroMemory(sBackupState.szPassword, wcslen(sBackupState.szPassword)*sizeof(WCHAR));
        LocalFree(sBackupState.szPassword);
    }

    return hr;
}

DWORD CARestoreWizard(CertSvrCA* pCertCA, HWND hwnd)
{
    HRESULT             hr;
    RESTOREWIZ_STATE    sRestoreState; ZeroMemory(&sRestoreState, sizeof(sRestoreState));
    sRestoreState.pCA = pCertCA;

    InitCommonControls();

    CWizard97PropertySheet cDlg(
			    g_hInstance,
			    IDS_RESTORE_WIZARD,
			    IDB_WIZ,
			    IDB_WIZ_HEAD,
			    TRUE);
    CRestoreWizPage1    sPg1(&sRestoreState, &cDlg);
    CRestoreWizPage2    sPg2(&sRestoreState, &cDlg);
    CRestoreWizPage3    sPg3(&sRestoreState, &cDlg);
    CRestoreWizPage5    sPg5(&sRestoreState, &cDlg);
    cDlg.AddPage(&sPg1);
    cDlg.AddPage(&sPg2);
    cDlg.AddPage(&sPg3);
    cDlg.AddPage(&sPg5);

    // if not halted, stop service
    if (pCertCA->m_pParentMachine->IsCertSvrServiceRunning())
    {
        CString cstrMsg, cstrTitle;
        cstrTitle.LoadString(IDS_RESTORE_WIZARD);
        cstrMsg.LoadString(IDS_STOP_SERVER_WARNING);
        if (IDOK != MessageBox(hwnd, (LPCWSTR)cstrMsg, (LPCWSTR)cstrTitle, MB_OKCANCEL))
            return ERROR_CANCELLED;

        hr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, FALSE);
        _JumpIfError(hr, Ret, "CertSvrStartStopService");
    }


    // should return value >0 on success
    if (0 >= cDlg.DoWizard(hwnd))
        return ERROR_CANCELLED;

    if (sRestoreState.fRestoreKeyCert)
    {
        hr = myCertServerImportPFX(
            sRestoreState.szLogsPath,
            sRestoreState.szPassword,
            TRUE,
            NULL,
            NULL,
            NULL);
        _JumpIfError(hr, Ret, "myCertServerImportPFX");

        if (!sRestoreState.fRestoreLogs)
        {
             // if we're not restoring db, restart svc now
             hr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, TRUE);
             _JumpIfError(hr, Ret, "CertSvrStartStopService");
        }
    }

    if (sRestoreState.fRestoreLogs)
    {
        DBBACKUPPROGRESS dbp;
        ZeroMemory(&dbp, sizeof(dbp));

        DWORD dwFlags = CDBBACKUP_OVERWRITE;
        dwFlags |= sRestoreState.fIncremental ? CDBBACKUP_INCREMENTAL : 0;


        HANDLE hProgressThread = NULL;
        hProgressThread = StartPercentCompleteDlg(g_hInstance, hwnd, IDS_RESTORE_PROGRESS, &dbp);
        if (hProgressThread == NULL)
        {
            hr = GetLastError();
            _JumpError(hr, Ret, "StartPercentCompleteDlg");
        }

        hr = myRestoreDB(
            (LPCWSTR)pCertCA->m_strConfig,
            dwFlags,
            sRestoreState.szLogsPath,
            NULL,
            NULL,
            NULL,
            &dbp);

        CSASSERT( (S_OK != hr) || (
                                (dbp.dwDBPercentComplete == 100) &&
                                (dbp.dwLogPercentComplete == 100) &&
                                (dbp.dwTruncateLogPercentComplete == 100) )
            );

        if (S_OK != hr)
        {
            dbp.dwDBPercentComplete = 100;
            dbp.dwLogPercentComplete = 100;
            dbp.dwTruncateLogPercentComplete = 100;
        }

        // pause for progress dlg to finish
        EndPercentCompleteDlg(hProgressThread);

        _JumpIfError(hr, Ret, "myRestoreDB");

        {
            CString cstrMsg, cstrTitle;
            cstrTitle.LoadString(IDS_RESTORE_WIZARD);
            cstrMsg.LoadString(IDS_INCRRESTORE_RESTART_SERVER_WARNING);
            if (IDYES == MessageBox(hwnd, (LPCWSTR)cstrMsg, (LPCWSTR)cstrTitle, MB_ICONWARNING|MB_YESNO))
            {
                // start svc to complete db restore
                hr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, TRUE);
                _PrintIfError(hr, "CertSvrStartStopService Restore");

                if (hr != S_OK)
                {
                    // remove "restore pending" mark
                    myRestoreDB(
                        pCertCA->m_strConfig,
                        0,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);

                    goto Ret;
                }
            }
        }

    }

    hr = S_OK;
Ret:
    if (sRestoreState.szLogsPath)
        LocalFree(sRestoreState.szLogsPath);

    if (sRestoreState.szPassword)
    {
        SecureZeroMemory(sRestoreState.szPassword, wcslen(sRestoreState.szPassword)*sizeof(WCHAR));
        LocalFree(sRestoreState.szPassword);
    }

    return hr;
}


DWORD CARequestInstallHierarchyWizard(CertSvrCA* pCertCA, HWND hwnd, BOOL fRenewal, BOOL fAttemptRestart)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwFlags = CSRF_INSTALLCACERT;
    BOOL fServiceWasRunning = FALSE;

    // stop/start msg
    if (pCertCA->m_pParentMachine->IsCertSvrServiceRunning())
    {
        fServiceWasRunning = TRUE;
        // service must be stopped to complete hierarchy
        CString cstrMsg, cstrTitle;
        cstrMsg.LoadString(IDS_STOP_SERVER_WARNING);
        cstrTitle.LoadString(IDS_INSTALL_HIERARCHY_TITLE);
        if (IDYES != MessageBox(hwnd, cstrMsg, cstrTitle, MB_YESNO))
            return ERROR_CANCELLED;

        // stop
        dwErr = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, FALSE);
        _JumpIfError(dwErr, Ret, "CertSvrStartStopService");
    }

    LogOpen(TRUE);

    if (fRenewal)
    {
        BOOL fReuseKeys = FALSE;
        dwErr = (DWORD)DialogBoxParam(
                g_hInstance,
                MAKEINTRESOURCE(IDD_RENEW_REUSEKEYS),
                hwnd,
                dlgProcRenewReuseKeys,
                (LPARAM)&fReuseKeys);

        // translate ok/cancel into error codes
        if (dwErr == IDOK)
            dwErr = ERROR_SUCCESS;
        else if (dwErr == IDCANCEL)
            dwErr = ERROR_CANCELLED;

        _JumpIfError(dwErr, Ret, "dlgProcRenewalReuseKeys");

	dwFlags = CSRF_RENEWCACERT | CSRF_OVERWRITE;
        if (!fReuseKeys)
	    dwFlags |= CSRF_NEWKEYS;
    }

    // do actual install
    dwErr = CertServerRequestCACertificateAndComplete(
                g_hInstance,			// hInstance
                hwnd,				// hwnd
                dwFlags,	                // Flags
                pCertCA->m_strCommonName,	// pwszCAName
                NULL,				// pwszParentMachine
                NULL,				// pwszParentCA
		NULL,				// pwszCAChainFile
                NULL);				// pwszRequestFile
    _JumpIfError(dwErr, Ret, "CertServerRequestCACertificateAndComplete");

Ret:
    // start svc
    if ((fAttemptRestart) && fServiceWasRunning)
    {
        DWORD dwErr2;
        dwErr2 = pCertCA->m_pParentMachine->CertSvrStartStopService(hwnd, TRUE);
        if (dwErr == S_OK)
        {
           dwErr = dwErr2;
           _PrintIfError(dwErr2, "CertSvrStartStopService");
        }
    }

    return dwErr;
}


typedef struct _PRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM
{
    BOOL fCurrentCRLValid; // IN
    BOOL fDeltaCRLEnabled; // IN
    BOOL fPublishBaseCRL;  // OUT
} PRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM, *PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM;


DWORD PublishCRLWizard(CertSvrCA* pCertCA, HWND hwnd)
{
    DWORD dwErr = ERROR_SUCCESS;
    ICertAdmin2* pAdmin = NULL;  // free this
    PCCRL_CONTEXT   pCRLCtxt = NULL;    // free this

    DATE dateGMT = 0.0;
    DWORD dwCRLFlags;
    variant_t var;

    // UNDONE: might need to check validity of DELTA crl as well as base
    PRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM sParam = {FALSE, FALSE, FALSE};

    // grab DELTA period count to see if deltas are enabled
    dwErr = pCertCA->GetConfigEntry(
            NULL,
            wszREGCRLDELTAPERIODCOUNT,
            &var);
    _JumpIfError(dwErr, Ret, "GetConfigEntry");

    CSASSERT(V_VT(&var)==VT_I4);
    sParam.fDeltaCRLEnabled = ( -1 != (V_I4(&var)) ) && (0 != (V_I4(&var))); //0, -1 mean disabled

    // now check validity and determine whether to display warning
    // UNDONE: check validity of delta crls?
    dwErr = pCertCA->GetCurrentCRL(&pCRLCtxt, TRUE);
    _PrintIfError(dwErr, "GetCurrentCRL");

    if ((dwErr == S_OK) && (NULL != pCRLCtxt))
    {
        // check validity of outstanding CRL
        dwErr = CertVerifyCRLTimeValidity(
            NULL,
            pCRLCtxt->pCrlInfo);
        // 0 -> current CRL already exists
        if (dwErr == 0)
            sParam.fCurrentCRLValid = TRUE;
    }
    else
    {
        // assume this is funky overwrite case
        sParam.fCurrentCRLValid = TRUE;
    }

    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_CHOOSE_PUBLISHCRL),
            hwnd,
            dlgProcRevocationPublishType,
            (LPARAM)&sParam);

    // translate ok/cancel into error codes
    if (dwErr == IDOK)
        dwErr = ERROR_SUCCESS;
    else if (dwErr == IDCANCEL)
        dwErr = ERROR_CANCELLED;
    _JumpIfError(dwErr, Ret, "dlgProcRevocationPublishType");


    // publish Delta CRLs if ( !sParam.fPublishBaseCRL )
    dwErr = pCertCA->m_pParentMachine->GetAdmin2(&pAdmin);
    _JumpIfError(dwErr, Ret, "GetAdmin");

    // now publish CRL valid for normal period (dateGMT=0.0 defaults to regular period length)
    dwCRLFlags = 0;
    if (sParam.fDeltaCRLEnabled)
        dwCRLFlags |= CA_CRL_DELTA;
    if (sParam.fPublishBaseCRL)
        dwCRLFlags |= CA_CRL_BASE;

    {
        CWaitCursor hourglass;

        dwErr = pAdmin->PublishCRLs(pCertCA->m_bstrConfig, dateGMT, dwCRLFlags);
        _JumpIfError(dwErr, Ret, "PublishCRLs");
    }

Ret:
    if (pAdmin)
        pAdmin->Release();

    if (pCRLCtxt)
        CertFreeCRLContext(pCRLCtxt);

    return dwErr;
}


DWORD
CertAdminRevokeCert(
    CertSvrCA *pCertCA,
    ICertAdmin *pAdmin,
    LONG lReasonCode,
    LPWSTR szCertSerNum)
{
    DWORD dwErr;
    BSTR bstrSerNum = NULL;
    DATE dateNow = 0.0;     // now

    if (pAdmin == NULL)
        return ERROR_INVALID_PARAMETER;

    bstrSerNum = SysAllocString(szCertSerNum);
    if (NULL == bstrSerNum)
    {
	dwErr = (DWORD) E_OUTOFMEMORY;
	_JumpError(dwErr, Ret, "SysAllocString");
    }

    dwErr = pAdmin->RevokeCertificate(
            pCertCA->m_bstrConfig,
            bstrSerNum,
            lReasonCode,
            dateNow);
    _JumpIfError(dwErr, Ret, "RevokeCertificate");

Ret:
    if (bstrSerNum)
        SysFreeString(bstrSerNum);

    return dwErr;
}


DWORD CertAdminResubmitRequest(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lRequestID)
{
    DWORD dwErr;
    LONG lDisposition;

    dwErr = pAdmin->ResubmitRequest(
            pCertCA->m_bstrConfig,
            lRequestID,
            &lDisposition);
    _JumpIfError(dwErr, Ret, "ResubmitRequest");

Ret:
    return dwErr;
}

DWORD CertAdminDenyRequest(CertSvrCA* pCertCA, ICertAdmin* pAdmin, LONG lRequestID)
{
    DWORD dwErr;

    dwErr = pAdmin->DenyRequest(
            pCertCA->m_bstrConfig,
            lRequestID);
    _JumpIfError(dwErr, Ret, "DenyRequest");

Ret:
    return dwErr;
}


typedef struct _QUERY_COLUMN_HEADINGS
{
    UINT    iRscID;
    DWORD   cbColWidth;
} QUERY_COLUMN_HEADINGS;

QUERY_COLUMN_HEADINGS g_colHeadings[] =
{
    {   IDS_COLUMNCHOOSER_FIELDNAME,  90        },
    {   IDS_COLUMNCHOOSER_OPERATOR,   55        },
    {   IDS_COLUMNCHOOSER_VALUE,      150       },
};


void RefreshListView(HWND hwndList, QUERY_RESTRICTION* pRestrict)
{
    HRESULT hr;
    ListView_DeleteAllItems(hwndList);		

    LVITEM sNewItem;
    ZeroMemory(&sNewItem, sizeof(sNewItem));

    int iSubItem;

    // while there are restrictions
    while(pRestrict)
    {
        iSubItem = 0;
        ListView_InsertItem(hwndList, &sNewItem);

        LPCWSTR szLocalizedCol;
        hr = myGetColumnDisplayName(
                pRestrict->szField,
                &szLocalizedCol);
        _PrintIfError(hr, "myGetColumnDisplayName");
        if (S_OK == hr)
		{

			ListView_SetItemText(hwndList, sNewItem.iItem, iSubItem++, (LPWSTR)szLocalizedCol);
			ListView_SetItemText(hwndList, sNewItem.iItem, iSubItem++, (LPWSTR)OperationToStr(pRestrict->iOperation));

			VARIANT vtString;
			VariantInit(&vtString);

			if (MakeDisplayStrFromDBVariant(&pRestrict->varValue, &vtString))
			{
				ListView_SetItemText(hwndList, sNewItem.iItem, iSubItem++, vtString.bstrVal);
				VariantClear(&vtString);
			}

	        sNewItem.iItem++;
		}

        // fwd to next elt
        pRestrict = pRestrict->pNext;
    }

    return;
}


#define     MAX_FIELD_SIZE  128

typedef struct _PRIVATE_DLGPROC_QUERY_LPARAM
{
    // this is the restriction, modify in-place
    PQUERY_RESTRICTION*         ppRestrict;

    // CFolder for read-only data
//    CFolder*                    pFolder;
    CComponentDataImpl*         pCompData;

} PRIVATE_DLGPROC_QUERY_LPARAM, *PPRIVATE_DLGPROC_QUERY_LPARAM;

//////////////////////////////////////////////////////////////////
// New Query Dialog
INT_PTR CALLBACK
dlgProcQuery(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PQUERY_RESTRICTION* ppRestrict = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember PRIVATE_DLGPROC_QUERY_LPARAM
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
            ppRestrict = ((PRIVATE_DLGPROC_QUERY_LPARAM*)lParam)->ppRestrict;

            HWND hwndList = GetDlgItem(hwndDlg, IDC_QUERY_LIST);

            // insert possible operators
            for (int i=0; i<ARRAYLEN(g_colHeadings); i++)
            {
                CString cstrTmp;
                cstrTmp.LoadString(g_colHeadings[i].iRscID);
                ListView_NewColumn(hwndList, i, g_colHeadings[i].cbColWidth, (LPWSTR)(LPCWSTR)cstrTmp);
            }

            // don't show deletion buttons if no items to delete
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_RESET_BUTTON), (*ppRestrict!=NULL));
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_RESTRICTION), (*ppRestrict!=NULL));

            ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

            RefreshListView(hwndList, *ppRestrict);

            return 1;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_DEFINE_QUERY);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_DEFINE_QUERY);
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_DELETE_RESTRICTION:
            {
                ppRestrict = (PQUERY_RESTRICTION*) ((PRIVATE_DLGPROC_QUERY_LPARAM*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))->ppRestrict;
                PQUERY_RESTRICTION pPrevRestriction = NULL, pRestriction = ppRestrict[0];
                LRESULT iSel;

                HWND hwndList = GetDlgItem(hwndDlg, IDC_QUERY_LIST);
                int iItems = ListView_GetItemCount(hwndList);

                // find selected item
                for(iSel=0; iSel<(LRESULT)iItems; iSel++)
                {
                    UINT ui = ListView_GetItemState(hwndList, iSel, LVIS_SELECTED);
                    if (ui == LVIS_SELECTED)
                        break;
                }

                // no selected item
                if (iSel == iItems)
                    break;

                // walk to it in the list
                for(LRESULT lr=0; lr<iSel; lr++)
                {
                    // walked off end of list
                    if (NULL == pRestriction)
                        break;

                    // step fwd in list
                    pPrevRestriction = pRestriction;
                    pRestriction = pRestriction->pNext;
                }

                // if item exists, remove from list & free it
                if (pRestriction)
                {
                    if (pPrevRestriction)
                    {
                        // ppRestrict is still valid, this wasn't the head elt
                        pPrevRestriction->pNext = pRestriction->pNext;
                    }
                    else
                    {
                        // reset NEXT as the head elt
                        *ppRestrict = pRestriction->pNext;
                    }
                    FreeQueryRestriction(pRestriction);

                    // don't show deletion buttons if no items to delete
                    ::EnableWindow(GetDlgItem(hwndDlg, IDC_RESET_BUTTON), (*ppRestrict!=NULL));
                    ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_RESTRICTION), (*ppRestrict!=NULL));

                    RefreshListView(hwndList, *ppRestrict);

                    if(*ppRestrict!=NULL)
                    {
                        int c = ListView_GetItemCount(hwndList);
                        ListView_SetItemState(hwndList, c-1, LVIS_SELECTED|LVIS_FOCUSED , LVIS_SELECTED|LVIS_FOCUSED);
                        SetFocus(hwndList);
                    }
                }

            }
            break;
        case IDC_RESET_BUTTON:
            {
                ppRestrict = (PQUERY_RESTRICTION*) ((PRIVATE_DLGPROC_QUERY_LPARAM*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))->ppRestrict;
                FreeQueryRestrictionList(*ppRestrict);
                *ppRestrict = NULL;

                ::EnableWindow(GetDlgItem(hwndDlg, IDC_RESET_BUTTON), FALSE);
                ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_RESTRICTION), FALSE);

                HWND hwndList = GetDlgItem(hwndDlg, IDC_QUERY_LIST);
                RefreshListView(hwndList, *ppRestrict);
            }
            break;
        case IDC_ADD_RESTRICTION:
            {
                LPARAM mylParam = GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
	            ppRestrict = (PQUERY_RESTRICTION*) ((PRIVATE_DLGPROC_QUERY_LPARAM*)mylParam)->ppRestrict;

				if (IDOK == DialogBoxParam(
						g_hInstance,
						MAKEINTRESOURCE(IDD_NEW_RESTRICTION),
						hwndDlg,
						dlgProcAddRestriction,
						mylParam))
				{
					// show deletion buttons if items to delete
					::EnableWindow(GetDlgItem(hwndDlg, IDC_RESET_BUTTON), (*ppRestrict!=NULL));
					::EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_RESTRICTION), (*ppRestrict!=NULL));

					HWND hwndList = GetDlgItem(hwndDlg, IDC_QUERY_LIST);
					RefreshListView(hwndList, *ppRestrict);

					int c = ListView_GetItemCount(hwndList);
					ListView_SetItemState(hwndList, c-1, LVIS_SELECTED|LVIS_FOCUSED , LVIS_SELECTED|LVIS_FOCUSED);
					SetFocus(hwndList);
				}
            }
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}


HRESULT SetTimePickerNoSeconds(HWND hwndPicker)
{
    HRESULT hr = S_OK;

    //
    // Setup the time picker controls to use a short time format with no seconds.
    //
    WCHAR   szTimeFormat[MAX_PATH]  = {0};
    LPTSTR  pszTimeFormat           = szTimeFormat;

    WCHAR   szTimeSep[MAX_PATH]     = {0};
    int     cchTimeSep;

    WCHAR   szShortTimeFormat[MAX_PATH];
    LPWSTR  pszShortTimeFormat = szShortTimeFormat;

    if(0 == GetLocaleInfo( LOCALE_USER_DEFAULT,
                       LOCALE_STIMEFORMAT,
                       szTimeFormat,
                       ARRAYLEN(szTimeFormat)))
    {
        hr = GetLastError();
        _JumpError(hr, Ret, "GetLocaleInfo");
    }

    cchTimeSep = GetLocaleInfo( LOCALE_USER_DEFAULT,
                   LOCALE_STIME,
                   szTimeSep,
                   ARRAYLEN(szTimeSep));
    if (0 == cchTimeSep)
    {
        hr = GetLastError();
        _JumpError(hr, Ret, "GetLocaleInfo");
    }
    cchTimeSep--; // number of chars not including NULL

    //
    // Remove the seconds format string and preceeding separator.
    //
    while (*pszTimeFormat)
    {
        if ((*pszTimeFormat != L's') && (*pszTimeFormat != L'S'))
        {
            *pszShortTimeFormat++ = *pszTimeFormat;
        }
        else
        {
            // NULL terminate here so we can strcmp
            *pszShortTimeFormat = L'\0';

            LPWSTR p = pszShortTimeFormat;

            // trim preceeding off

            // rewind one char
            p--;
            if (p >= szShortTimeFormat)  // we didn't rewind too far
            {
                if (*p == L' ')
                    pszShortTimeFormat = p;   // skip space
                else
                {
                    p -= (cchTimeSep-1);        // p already backstepped one char
                    if (0 == lstrcmp(p, szTimeSep))
                        pszShortTimeFormat = p;    // skip szTimeSep
                }
            }
        }

        pszTimeFormat++;
    }

    // zero-terminate
    *pszShortTimeFormat = L'\0';

    //
    // If we have retrived a valid time format string then use it,
    // else use the default format string implemented by common control.
    //
    DateTime_SetFormat(hwndPicker, szShortTimeFormat);

Ret:
    return hr;
}

INT_PTR CALLBACK dlgProcAddRestriction(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    typedef struct _DROPDOWN_FIELD_PARAM
    {
        DWORD dwPropType;
        DWORD dwIndexed;
        LPWSTR szUnlocalized;
    } DROPDOWN_FIELD_PARAM, *PDROPDOWN_FIELD_PARAM;

    HRESULT hr;
    PQUERY_RESTRICTION* ppRestrict = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember PQUERY_RESTRICTION
            ppRestrict = ((PRIVATE_DLGPROC_QUERY_LPARAM*)lParam)->ppRestrict;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)ppRestrict);

            // Not a huge failure,  worst case:
            // we don't call DateTime_SetFormat and the user gets a seconds picker
            SetTimePickerNoSeconds(GetDlgItem(hwndDlg, IDC_TIMEPICKER_NEWQUERY));

            {
                // insert all column names
                CComponentDataImpl* pCompData = ((PRIVATE_DLGPROC_QUERY_LPARAM*)lParam)->pCompData;
                HWND hFieldDropdown = GetDlgItem(hwndDlg, IDC_EDIT_NEWQUERY_FIELD);
                for(DWORD i=0; i<pCompData->GetSchemaEntries(); i++)
                {
                    LPCWSTR pszLocal;
                    LPCWSTR szColName=NULL;
                    LONG lType, lIndexed;
                    if (S_OK == pCompData->GetDBSchemaEntry(i, &szColName, &lType, (BOOL*)&lIndexed))
                    {
                        // skip filter types we can't parse
                        if (PROPTYPE_BINARY == lType)
                            continue;

                        hr = myGetColumnDisplayName(
                            szColName,
                            &pszLocal);
                        _PrintIfError(hr, "myGetColumnDisplayName");
                        if (S_OK != hr)
                            continue;

                        INT nItemIndex = (INT)SendMessage(hFieldDropdown, CB_ADDSTRING, 0, (LPARAM)pszLocal);

                        // prepare the data parameter
                        PDROPDOWN_FIELD_PARAM pField = (PDROPDOWN_FIELD_PARAM)new BYTE[sizeof(DROPDOWN_FIELD_PARAM) + WSZ_BYTECOUNT(szColName)];
                        if (pField != NULL)
                        {
                            pField->dwPropType = lType;
                            pField->dwIndexed = lIndexed;
                            pField->szUnlocalized = (LPWSTR)((BYTE*)pField + sizeof(DROPDOWN_FIELD_PARAM));
                            wcscpy(pField->szUnlocalized, szColName);

                            SendMessage(hFieldDropdown, CB_SETITEMDATA, (WPARAM)nItemIndex, (LPARAM) pField);
                        }
                    }
                }

                // set a default selection
                SendMessage(hFieldDropdown, CB_SETCURSEL, 0, 0);
                SendMessage(hwndDlg, WM_COMMAND, MAKEWPARAM(IDC_EDIT_NEWQUERY_FIELD, LBN_SELCHANGE), (LPARAM)hFieldDropdown);

                HWND hOperationDropdown = GetDlgItem(hwndDlg, IDC_EDIT_NEWQUERY_OPERATION);
                SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L"<");
                SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L"<=");
                SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L">=");
                SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L">");

                INT iDefSel = (INT)SendMessage(hOperationDropdown, CB_ADDSTRING, 0, (LPARAM)L"=");
                SendMessage(hOperationDropdown, CB_SETCURSEL, iDefSel, 0);
            }

            return 1;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_NEW_RESTRICTION);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_NEW_RESTRICTION);
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_EDIT_NEWQUERY_FIELD:
            {
                if (HIWORD(wParam) == LBN_SELCHANGE)
                {
                    // On selection change, ask for the right format
                    int nItemIndex;
                    nItemIndex = (INT)SendMessage((HWND)lParam,
                        CB_GETCURSEL,
                        0,
                        0);

                    DROPDOWN_FIELD_PARAM* pField = NULL;
                    pField = (PDROPDOWN_FIELD_PARAM) SendMessage(
                            (HWND)lParam,
                            CB_GETITEMDATA,
                            (WPARAM)nItemIndex,
                            0);
                    if (CB_ERR == (DWORD_PTR)pField)
                        break;  // get out of here

                    BOOL fShowPickers = (pField->dwPropType == PROPTYPE_DATE);

                    // swap entry mode to/from datetime pickers
                    ShowWindow(GetDlgItem(hwndDlg, IDC_EDIT_NEWQUERY_VALUE), fShowPickers ? SW_HIDE : SW_SHOW);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DATEPICKER_NEWQUERY), fShowPickers ? SW_SHOW : SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_TIMEPICKER_NEWQUERY), fShowPickers ? SW_SHOW : SW_HIDE);
                }
            }
            break;
        case IDOK:
            {
                ppRestrict = (PQUERY_RESTRICTION*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);


                WCHAR szFieldName[MAX_FIELD_SIZE+1];
                WCHAR szValue[MAX_FIELD_SIZE+1];
                WCHAR szOp[10];

                GetDlgItemText(hwndDlg, IDC_EDIT_NEWQUERY_VALUE, szValue, MAX_FIELD_SIZE);
                GetDlgItemText(hwndDlg, IDC_EDIT_NEWQUERY_OPERATION, szOp, ARRAYLEN(szOp)-1);
                GetDlgItemText(hwndDlg, IDC_EDIT_NEWQUERY_FIELD, szFieldName, MAX_FIELD_SIZE);


                DROPDOWN_FIELD_PARAM* pField = NULL;

                VARIANT vt;
                VariantInit(&vt);

                // parsing code
                {
                    HWND hFieldDropdown = GetDlgItem(hwndDlg, IDC_EDIT_NEWQUERY_FIELD);
		    BOOL fValidDigitString;

                    INT nItemIndex = (INT)SendMessage(hFieldDropdown,
                        CB_GETCURSEL,
                        0,
                        0);

                    pField = (PDROPDOWN_FIELD_PARAM)SendMessage(
                        hFieldDropdown,
                        CB_GETITEMDATA,
                        (WPARAM)nItemIndex,
                        0);

                    if ((NULL == pField) || (CB_ERR == (DWORD_PTR)pField))
                        break;

                    switch(pField->dwPropType)
                    {
                    case PROPTYPE_LONG:
                        vt.vt = VT_I4;
                        vt.lVal = myWtoI(szValue, &fValidDigitString);
                        break;
                    case PROPTYPE_STRING:
                        vt.vt = VT_BSTR;
                        vt.bstrVal = _wcslwr(szValue);
                        break;
                    case PROPTYPE_DATE:
                        {
                            SYSTEMTIME stDate, stTime;
                            hr = DateTime_GetSystemtime(GetDlgItem(hwndDlg, IDC_DATEPICKER_NEWQUERY), &stDate);
                            _PrintIfError(hr, "DateTime_GetSystemtime");
                            if (hr != S_OK)
                                break;

                            hr = DateTime_GetSystemtime(GetDlgItem(hwndDlg, IDC_TIMEPICKER_NEWQUERY), &stTime);
                            _PrintIfError(hr, "DateTime_GetSystemtime");
                            if (hr != S_OK)
                                break;

                            // merge the two structures
                            stTime.wYear = stDate.wYear;
                            stTime.wMonth = stDate.wMonth;
                            stTime.wDayOfWeek = stDate.wDayOfWeek;
                            stTime.wDay = stDate.wDay;

                            // convert to GMT
                            hr = mySystemTimeToGMTSystemTime(&stTime);
                            _PrintIfError(hr, "mySystemTimeToGMTSystemTime");
                            if (hr != S_OK)
                                break;

                            stTime.wSecond = 0;
                            stTime.wMilliseconds = 0;

                            // inject into variant
                            if (!SystemTimeToVariantTime(&stTime, &vt.date))
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                                _PrintError(hr, "SystemTimeToVariantTime");
                                break;
                            }
                            vt.vt = VT_DATE;
                        }
                        break;
                    case PROPTYPE_BINARY:
                        {
                            CString cstrMsg, cstrTitle;
                            cstrMsg.LoadString(IDS_FILTER_NOT_SUPPORTED);
                            cstrTitle.LoadString(IDS_MSG_TITLE);
                            MessageBoxW(hwndDlg, cstrMsg, cstrTitle, MB_OK);
                        }
                        break;
                    default:
                        break;
                    }
                }

                // if we didn't get column
                if (VT_EMPTY == vt.vt)
                    break;


                // copy into new struct
                QUERY_RESTRICTION* pNewRestrict = NewQueryRestriction(
                        pField->szUnlocalized, // UnlocalizeColName(szFieldName),
                        StrToOperation(szOp),
                        &vt);

                if (pNewRestrict)
                {
                    // add restriction only if not already present
                    if(!QueryRestrictionFound(pNewRestrict, *ppRestrict))
                    {
                        // don't call VarClear -- it'll try to SysFree the non-bstr!
                        VariantInit(&vt);

                        // insert into list
                        ListInsertAtEnd((void**)ppRestrict, pNewRestrict);

                        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)ppRestrict);
                    }
                    else
                    {
                        FreeQueryRestriction(pNewRestrict);
                    }
                }
            }
        case IDCANCEL:
            // cleanup
            {
                INT cItems = (INT)::SendDlgItemMessage(hwndDlg, IDC_EDIT_NEWQUERY_FIELD, CB_GETCOUNT, 0, 0);
                while(cItems--)
                {
                    PBYTE pb = (PBYTE)::SendDlgItemMessage(hwndDlg, IDC_EDIT_NEWQUERY_FIELD, CB_GETITEMDATA, (WPARAM)cItems, 0);
                    delete [] pb;
                }
            }

            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}


typedef struct _CHOOSEMODULE_MODULEDEF
{
    LPOLESTR pszprogidModule;
    CLSID clsidModule;
} CHOOSEMODULE_MODULEDEF, *PCHOOSEMODULE_MODULEDEF;


void FreeChooseModuleDef(PCHOOSEMODULE_MODULEDEF psModuleDef)
{
    if (psModuleDef)
    {
        if (psModuleDef->pszprogidModule)
        {
            CoTaskMemFree(psModuleDef->pszprogidModule);
        }

        LocalFree(psModuleDef);
    }
}


INT_PTR CALLBACK dlgProcChooseModule(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    BOOL fReturn = FALSE;
    HRESULT hr;
    PPRIVATE_DLGPROC_MODULESELECT_LPARAM pParam = NULL;

    HKEY hRemoteMachine = NULL;


    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            pParam = (PRIVATE_DLGPROC_MODULESELECT_LPARAM*)lParam;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)pParam);

            ::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_RESETCONTENT, 0, 0);

            CString cstrTitle;
            if (pParam->fIsPolicyModuleSelection)
                cstrTitle.LoadString(IDS_CHOOSEMODULE_POLICY_TITLE);
            else
                cstrTitle.LoadString(IDS_CHOOSEMODULE_EXIT_TITLE);
            ::SetWindowText(hwndDlg, (LPCWSTR)cstrTitle);

            // grab current default, watch for it to float by during enum
            DWORD   dwCurrentSelection = 0;

            LPWSTR pszKeyName = NULL;
            DISPATCHINTERFACE di;
            BOOL fMustRelease = FALSE;
            PCHOOSEMODULE_MODULEDEF psModuleDef = NULL;

            if (! pParam->pCA->m_pParentMachine->IsLocalMachine())
            {
                hr = RegConnectRegistry(
                    pParam->pCA->m_pParentMachine->m_strMachineName,
                    HKEY_CLASSES_ROOT,
                    &hRemoteMachine);
                _PrintIfError(hr, "RegConnectRegistry");
                if (S_OK != hr)
                    break;
            }


            for (DWORD dwIndex=0; ; /*dwIndex++*/)
            {
                if (NULL != pszKeyName)
                {
                    LocalFree(pszKeyName);
                    pszKeyName = NULL;
                }

                if (fMustRelease)
                {
                    ManageModule_Release(&di);
                    fMustRelease = FALSE;
                }

                FreeChooseModuleDef(psModuleDef);

                psModuleDef = (PCHOOSEMODULE_MODULEDEF)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(CHOOSEMODULE_MODULEDEF));
                if (NULL == psModuleDef)
                {
                    hr = E_OUTOFMEMORY;
                    _PrintError(hr, "LocalAlloc");
                    break;
                }

                pszKeyName = RegEnumKeyContaining(
                    (hRemoteMachine != NULL) ? hRemoteMachine : HKEY_CLASSES_ROOT,
                    pParam->fIsPolicyModuleSelection? wszCERTPOLICYMODULE_POSTFIX : wszCERTEXITMODULE_POSTFIX,
                    &dwIndex);
                if (NULL == pszKeyName)
                {
                    break;
                }

                // make sure it _ends_ with the specified string
                DWORD chSubStrShouldStartAt = (wcslen(pszKeyName) -
                    wcslen(pParam->fIsPolicyModuleSelection ? wszCERTPOLICYMODULE_POSTFIX : wszCERTEXITMODULE_POSTFIX) );

                if (0 != wcscmp(
                    &pszKeyName[chSubStrShouldStartAt],
                    pParam->fIsPolicyModuleSelection?
                        wszCERTPOLICYMODULE_POSTFIX : wszCERTEXITMODULE_POSTFIX))
                    continue;

                psModuleDef->pszprogidModule = (LPOLESTR)CoTaskMemAlloc(WSZ_BYTECOUNT(pszKeyName));
                if (NULL == psModuleDef->pszprogidModule)
                {
                    hr = E_OUTOFMEMORY;
                    _PrintError(hr, "CoTaskMemAlloc");
                    break;
                }
                wcscpy(psModuleDef->pszprogidModule, pszKeyName);

                hr = CLSIDFromProgID(psModuleDef->pszprogidModule, &psModuleDef->clsidModule);
                _PrintIfError(hr, "CLSIDFromProgID");
                if (S_OK != hr)
                    continue;   // module clsid not found? ouch!
                
                if(pParam->fIsPolicyModuleSelection)
                {
                    hr = GetPolicyManageDispatch(
                        psModuleDef->pszprogidModule,
                        psModuleDef->clsidModule,
                        &di);
                    _PrintIfErrorStr(hr, "GetPolicyManageDispatch", psModuleDef->pszprogidModule);
                }
                else
                {
                    hr = GetExitManageDispatch(
                        psModuleDef->pszprogidModule,
                        psModuleDef->clsidModule,
                        &di);
                    _PrintIfErrorStr(hr, "GetExitManageDispatch", psModuleDef->pszprogidModule);
                }
                if (hr != S_OK)
                    continue;

                fMustRelease = TRUE;

                BSTR bstrName = NULL;
                BSTR bstrStorageLoc = NULL;

//                ASSERT( pParam->pCA->m_pParentMachine->IsLocalMachine());

                // get the storage path
                CString cstrStoragePath;

                cstrStoragePath = wszREGKEYCONFIGPATH_BS;
                cstrStoragePath += pParam->pCA->m_strSanitizedName;
                cstrStoragePath += TEXT("\\");
                cstrStoragePath += pParam->fIsPolicyModuleSelection?
                                    wszREGKEYPOLICYMODULES:
                                    wszREGKEYEXITMODULES;
                cstrStoragePath += TEXT("\\");
                cstrStoragePath += psModuleDef->pszprogidModule;

                bstrStorageLoc = SysAllocString(cstrStoragePath);
                if (bstrStorageLoc == NULL)
                {
                    _PrintError(E_OUTOFMEMORY, "SysAllocString");
                    continue;
                }

                BSTR bstrPropertyName = SysAllocString(wszCMM_PROP_NAME);
                if (bstrPropertyName == NULL)
                {
                    _PrintError(E_OUTOFMEMORY, "SysAllocString");
                    continue;
                }

                // get name property
                hr = ManageModule_GetProperty(&di, pParam->pCA->m_bstrConfig, bstrStorageLoc, bstrPropertyName, 0, PROPTYPE_STRING, &bstrName);
                _PrintIfError(hr, "ManageModule_GetProperty");
                if(S_OK==hr)
                {
                    myRegisterMemAlloc(bstrName, -1, CSM_SYSALLOC);
                }

                if (bstrStorageLoc)
                {
                    SysFreeString(bstrStorageLoc);
                    bstrStorageLoc = NULL;
                }
                if (bstrPropertyName)
                {
                    SysFreeString(bstrPropertyName);
                    bstrPropertyName = NULL;
                }

                if (hr != S_OK)
                {
                    // Bug #236267: module instantiated but GetProperty returns error
                    // notify user and continue
                    CString cstrMsg, cstrFmt;
                    cstrFmt.LoadString(IDS_ICMM_GETNAMEPROPERTY_FAILED);
                    cstrMsg.Format(cstrFmt, psModuleDef->pszprogidModule);

                    DisplayCertSrvErrorWithContext(hwndDlg, hr, (LPCWSTR)cstrMsg);

                    if (bstrName)
                        SysFreeString(bstrName);

                    continue;
                }

                // No error (but no name)
                if (bstrName == NULL)
                    continue;

                // add to listbox
                INT idxInsertion;
                idxInsertion = (INT)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_ADDSTRING, 0, (LPARAM)bstrName);

                SysFreeString(bstrName);
                bstrName = NULL;

                // add module defn as item data
                ::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_SETITEMDATA, idxInsertion, (LPARAM)psModuleDef);

                if (0 == memcmp(&psModuleDef->clsidModule, pParam->pclsidModule, sizeof(CLSID)))
                    dwCurrentSelection = idxInsertion;

                psModuleDef = NULL; // dlg owns memory
            }

            FreeChooseModuleDef(psModuleDef);

            if (NULL != pszKeyName)
                LocalFree(pszKeyName);

            if (fMustRelease)
            {
                ManageModule_Release(&di);
            }

            ::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_SETCURSEL, (WPARAM)dwCurrentSelection, 0);

            // no other work to be done
            fReturn = TRUE;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CHOOSE_MODULE);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CHOOSE_MODULE);
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            {
                pParam = (PPRIVATE_DLGPROC_MODULESELECT_LPARAM)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

                // detect selection, chg registry settings
                DWORD dwSel = (DWORD)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_GETCURSEL, 0, 0);
                if (LB_ERR != dwSel)
                {
                    PCHOOSEMODULE_MODULEDEF psModuleDef = NULL;
                    psModuleDef = (PCHOOSEMODULE_MODULEDEF)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_GETITEMDATA, (WPARAM)dwSel, 0);

                    // we own memory now, delete this guy
                    ::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_DELETESTRING, (WPARAM)dwSel, 0);

                    // if (moduledef) OR (exit module "no exit module" selection)
                    if ((psModuleDef) || (!pParam->fIsPolicyModuleSelection))
                    {
                        // free what was passed in
                        if (*pParam->ppszProgIDModule)
                        {
                            CoTaskMemFree(*pParam->ppszProgIDModule);
                        }

                        if (psModuleDef)
                        {
                            *pParam->ppszProgIDModule = psModuleDef->pszprogidModule;
                            CopyMemory(pParam->pclsidModule, &psModuleDef->clsidModule, sizeof(CLSID));

                            // all other memory is owned by pParam
                            LocalFree(psModuleDef);
                        }
                        else
                        {
                            *pParam->ppszProgIDModule = NULL;
                            ZeroMemory(pParam->pclsidModule, sizeof(CLSID));
                        }
                    } // no moduledef found; error!
                }
            }
            // fall through for cleanup
        case IDCANCEL:
            {
                PCHOOSEMODULE_MODULEDEF psModuleDef = NULL;

                // listbox cleanup
                INT cItems = (INT)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_GETCOUNT, 0, 0);
                while(cItems--)
                {
                    psModuleDef = (PCHOOSEMODULE_MODULEDEF)::SendDlgItemMessage(hwndDlg, IDC_MODULE_LIST, LB_GETITEMDATA, (WPARAM)cItems, 0);
                    FreeChooseModuleDef(psModuleDef);
                }
            }

            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }

    if (NULL != hRemoteMachine)
        RegCloseKey(hRemoteMachine);

    return fReturn;
}


DWORD
ModifyQueryFilter(
    HWND hwnd,
    CertViewRowEnum *pRowEnum,
    CComponentDataImpl *pCompData,
    int i)
{
    // copy m_pRestrictions to pRestrictionHead
    DWORD dwErr = ERROR_SUCCESS;

    PRIVATE_DLGPROC_QUERY_LPARAM    sParam;

    PQUERY_RESTRICTION pRestrictionHead = NULL, pTmpRestriction, pCurRestriction;
    PQUERY_RESTRICTION pFolderRestrictions = pRowEnum->GetQueryRestrictions(i);

    pCurRestriction = NULL;
    if (pFolderRestrictions)
    {
        pRestrictionHead = NewQueryRestriction(
                pFolderRestrictions->szField,
                pFolderRestrictions->iOperation,
                &pFolderRestrictions->varValue);
	if (NULL == pRestrictionHead)
	{
	    dwErr = (DWORD) E_OUTOFMEMORY;
	    _JumpError(dwErr, Ret, "NewQueryRestriction");
	}

        pCurRestriction = pRestrictionHead;
        pFolderRestrictions = pFolderRestrictions->pNext;
    }
    while(pFolderRestrictions)
    {
        pTmpRestriction = NewQueryRestriction(
                pFolderRestrictions->szField,
                pFolderRestrictions->iOperation,
                &pFolderRestrictions->varValue);
	if (NULL == pTmpRestriction)
	{
	    dwErr = (DWORD) E_OUTOFMEMORY;
	    _JumpError(dwErr, Ret, "NewQueryRestriction");
	}

        pCurRestriction->pNext = pTmpRestriction;
        pCurRestriction = pCurRestriction->pNext;
        pFolderRestrictions = pFolderRestrictions->pNext;
    }

    InitCommonControls();   // dialog uses comctl32

    sParam.ppRestrict = &pRestrictionHead;
    sParam.pCompData = pCompData;


    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_DEFINE_QUERY),
            hwnd,
            dlgProcQuery,
            (LPARAM)&sParam);
    if (dwErr == IDOK)
    {
        // copy pRestrictionHead back to GetCA()->m_pRestrictions on OK
        pRowEnum->SetQueryRestrictions(pRestrictionHead, i);

        // trigger active flag
        pRowEnum->SetQueryRestrictionsActive(pRestrictionHead != NULL, i);
    }
    else
    {
        FreeQueryRestrictionList(pRestrictionHead);
    }
    // translate ok/cancel into error codes
    if (dwErr == IDOK)
        dwErr = ERROR_SUCCESS;
    else if (dwErr == IDCANCEL)
        dwErr = ERROR_CANCELLED;

    _PrintIfError(dwErr, "dlgProcQuery");

Ret:
    return dwErr;
}


BOOL
SwapSelectedListboxItem(
    HWND hFrom,
    HWND hTo,
    LPWSTR szItem,
    DWORD DBGCODE(chItem))
{
    // find selected item in from list
    INT nIndex = (INT)SendMessage(hFrom, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return FALSE;

    // dblchk text buf long enough
#if DBG
    INT nChars = (INT)SendMessage(hFrom, LB_GETTEXTLEN, (WPARAM)nIndex, 0);
    if (nChars == LB_ERR)
        return FALSE;
    CSASSERT( (nChars +1) <= (int)chItem);
#endif

    // retrieve text
    if(LB_ERR == SendMessage(hFrom, LB_GETTEXT, (WPARAM)nIndex, (LPARAM)szItem))
        goto Ret;

    // add to target
    if(LB_ERR == SendMessage(hTo, LB_ADDSTRING, 0, (LPARAM)szItem))
        goto Ret;

    // remove from old
    if(LB_ERR == SendMessage(hFrom, LB_DELETESTRING, (WPARAM)nIndex, 0))
        goto Ret;

Ret:

    return TRUE;
}

//////////////////////////////////////////////////////////////////
// Base/Delta CRL publish chooser
INT_PTR CALLBACK dlgProcRevocationPublishType(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
// no help here, it's self-explanitory (per mikedan)
//            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember param
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);

            // only show warning if current CRL still valid
            PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM psParam = (PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM)lParam;
            ShowWindow(GetDlgItem(hwndDlg, IDC_VALID_LASTPUBLISHED), psParam->fCurrentCRLValid ? SW_SHOW : SW_HIDE);

            // select the 1st element
            HWND hRadioBase = GetDlgItem(hwndDlg, IDC_RADIO_NEWBASE);
            SendMessage(hRadioBase, BM_SETCHECK, TRUE, 0); // Yes by default

            if (!psParam->fDeltaCRLEnabled)
{
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_RADIO_NEWDELTA), FALSE);
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_DELTA_EXPLANATION), FALSE);
}

            return 1;
        }
        break;
    case WM_HELP:
    {
        // UNDONE
        //OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_REVOCATION_DIALOG);
        break;
    }
    case WM_CONTEXTMENU:
    {
        // UNDONE
        //OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_REVOCATION_DIALOG);
        break;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            {
                PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM psParam = (PPRIVATE_DLGPROC_CHOOSECRLPUBLISHTYPE_LPARAM)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

                HWND hRadioBase = GetDlgItem(hwndDlg, IDC_RADIO_NEWBASE);
                psParam->fPublishBaseCRL = (BOOL)SendMessage(hRadioBase, BM_GETCHECK, 0, 0);

            // fall through
            }
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}

//////////////////////////////////////////////////////////////////
// Revocation Reason Chooser
INT_PTR CALLBACK dlgProcRevocationReason(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember param
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);

	        HWND hCombo = GetDlgItem(hwndDlg, IDC_COMBO_REASON);

// from WINCRYPT.H
//          CRL_REASON_UNSPECIFIED              0
//          CRL_REASON_KEY_COMPROMISE           1
//          CRL_REASON_CA_COMPROMISE            2
//          CRL_REASON_AFFILIATION_CHANGED      3
//          CRL_REASON_SUPERSEDED               4
//          CRL_REASON_CESSATION_OF_OPERATION   5
//          CRL_REASON_CERTIFICATE_HOLD         6

            INT itemidx;
            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_pResources->m_szRevokeReason_Unspecified);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_UNSPECIFIED);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_pResources->m_szRevokeReason_KeyCompromise);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_KEY_COMPROMISE);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_pResources->m_szRevokeReason_CaCompromise);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_CA_COMPROMISE);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_pResources->m_szRevokeReason_Affiliation);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_AFFILIATION_CHANGED);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_pResources->m_szRevokeReason_Superseded);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_SUPERSEDED);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_pResources->m_szRevokeReason_Cessatation);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_CESSATION_OF_OPERATION);

            itemidx = (INT)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPCWSTR)g_pResources->m_szRevokeReason_CertHold);
            SendMessage(hCombo, CB_SETITEMDATA, itemidx, CRL_REASON_CERTIFICATE_HOLD);


            // select the 1st element
            SendMessage(hCombo, CB_SETCURSEL, 0, 0);

            return 1;
        }
        break;
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_REVOCATION_DIALOG);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_REVOCATION_DIALOG);
        break;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            {
                LONG* plRevocationReason = (LONG*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

	            HWND hCombo = GetDlgItem(hwndDlg, IDC_COMBO_REASON);
                *plRevocationReason = (LONG)SendMessage(hCombo, CB_GETCURSEL, 0, 0);

                if (*plRevocationReason == CB_ERR)
                    *plRevocationReason = CRL_REASON_UNSPECIFIED;

            // fall through
            }
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}


DWORD GetUserConfirmRevocationReason(LONG* plReasonCode, HWND hwnd)
{
    DWORD dwErr;
    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_REVOCATION_DIALOG),
            hwnd,
            dlgProcRevocationReason,
            (LPARAM)plReasonCode);

    // translate ok/cancel into error codes
    if (dwErr == IDOK)
        dwErr = ERROR_SUCCESS;
    else if (dwErr == IDCANCEL)
        dwErr = ERROR_CANCELLED;

    _PrintIfError(dwErr, "dlgProcRevocationReason");

//Ret:
    return dwErr;
}


//////////////////////////////////////////////////////////////////
// Renewal: Reuse Keys Chooser
INT_PTR CALLBACK dlgProcRenewReuseKeys(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
// self-explanitory page, no help needed
//            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember param
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);

            HWND hNew = GetDlgItem(hwndDlg, IDC_RADIO_NEWKEY);
            SendMessage(hNew, BM_SETCHECK, BST_CHECKED, 0); // Default: New key

            return 1;
        }
        break;
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_RENEW_REUSEKEYS);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_RENEW_REUSEKEYS);
        break;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            {
                BOOL* pfReuseKeys = (BOOL*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

                HWND hReuse = GetDlgItem(hwndDlg, IDC_RADIO_REUSEKEY);
                *pfReuseKeys = (BOOL)SendMessage(hReuse, BM_GETCHECK, 0, 0);

            // fall through
            }
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}


typedef struct _CERTMMC_BINARYCOLCHOOSER{
    CComponentDataImpl* pComp;
    LPCWSTR wszCol;
    BOOL fSaveOnly;
} CERTMMC_BINARYCOLCHOOSER, *PCERTMMC_BINARYCOLCHOOSER;

//////////////////////////////////////////////////////////////////
// Binary Dump: Column Chooser
INT_PTR CALLBACK dlgProcBinaryColChooser(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam  )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
// self-explanitory page, no help needed
//            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            // remember param
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam); // PCERTMMC_BINARYCOLCHOOSER

    PCERTMMC_BINARYCOLCHOOSER pData = (PCERTMMC_BINARYCOLCHOOSER)lParam;
    HWND hColumnCombo = GetDlgItem(hwndDlg, IDC_COMBO_BINARY_COLUMN_CHOICE);
    BOOL fInsertedOne = FALSE;   // must insert one or bail

    // insert all known binary columns in this view
    for(int i=0; ;i++)
    {
        LRESULT lr;
        HRESULT hr;
        LPCWSTR szCol, szLocalizedCol;
        LONG lType;

        hr = pData->pComp->GetDBSchemaEntry(i,&szCol, &lType, NULL);
        if (hr != S_OK)
           break;

        if (lType != PROPTYPE_BINARY)
            continue;

        // bug 462781: don't show archived key column since you can't really
        // fetch the archived key this way, just a bool
        if(wcsstr(szCol, wszPROPREQUESTRAWARCHIVEDKEY))
            continue;

        // Q: see if this is included in the current view?

        // convert to localized name
        hr = myGetColumnDisplayName(szCol, &szLocalizedCol);
        if (hr != S_OK)
            continue;

        // add loc name to combobox with szCol as data ptr
        lr = SendMessage(hColumnCombo, CB_ADDSTRING, 0, (LPARAM)szLocalizedCol);
        if ((lr != CB_ERR) && (lr != CB_ERRSPACE))
        {
             SendMessage(hColumnCombo, CB_SETITEMDATA, lr, (LPARAM)szCol);
             fInsertedOne = TRUE;
        }
    }

            if (!fInsertedOne)
                EndDialog(hwndDlg, IDOK); // bail here
            else
                SendMessage(hColumnCombo, CB_SETCURSEL, 0, 0);

			// by default: view
			SendDlgItemMessage(hwndDlg, IDC_RADIO_BINARY_VIEW, BM_SETCHECK, BST_CHECKED, 0);

            return 1;
        }
        break;
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_RENEW_REUSEKEYS);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_RENEW_REUSEKEYS);
        break;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            {
                PCERTMMC_BINARYCOLCHOOSER pData = (PCERTMMC_BINARYCOLCHOOSER)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                HWND hColumnCombo = GetDlgItem(hwndDlg, IDC_COMBO_BINARY_COLUMN_CHOICE);
                LRESULT lr;


                lr = SendMessage(hColumnCombo, CB_GETCURSEL, 0, 0);
                if (lr != CB_ERR)
                {
                    pData->wszCol = (LPCWSTR)SendMessage(hColumnCombo, CB_GETITEMDATA, lr, 0);
                    if (pData->wszCol == (LPCWSTR)CB_ERR)
                         pData->wszCol = NULL;

					// if view unchecked, save only
					pData->fSaveOnly = (BST_UNCHECKED == SendDlgItemMessage(hwndDlg, IDC_RADIO_BINARY_VIEW, BM_GETCHECK, 0, 0));

                    //pData->fSaveOnly = (BOOL)SendMessage(GetDlgItem(hwndDlg, IDC_CHECK_BINARY_SAVETOFILE), BM_GETCHECK, 0, 0);
                }

            // fall through
            }
        case IDCANCEL:
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
            break;
        }
    default:
        break;
    }
    return 0;
}



/////////////////////////////////////////////////////////////////////////////////////
// View Attributes and extensions associated with a request

DWORD
ViewRowAttributesExtensions(
    HWND hwnd,
    IEnumCERTVIEWATTRIBUTE *pAttr,
    IEnumCERTVIEWEXTENSION *pExtn,
    LPCWSTR szReqID)
{
    DWORD dwErr = S_OK;
    HPROPSHEETPAGE hPages[2];
    CString cstrCaption, cstrCaptionTemplate;
    CViewAttrib *psPg1;
    CViewExtn *psPg2;
    InitCommonControls();

    // page 1 initialization
    psPg1 = new CViewAttrib();   // autodeleted
    if (psPg1 == NULL)
    {
        dwErr = (DWORD) E_OUTOFMEMORY;
        goto error;
    }
    psPg1->m_pAttr = pAttr;

    hPages[0] = CreatePropertySheetPage(&psPg1->m_psp);
    if (hPages[0] == NULL)
    {
        dwErr = GetLastError();
        goto error;
    }

    // page 2 initialization
    psPg2 = new CViewExtn();     // autodeleted
    if (psPg2 == NULL)
    {
        dwErr = (DWORD) E_OUTOFMEMORY;
        goto error;
    }
    psPg2->m_pExtn = pExtn;

    hPages[1] = CreatePropertySheetPage(&psPg2->m_psp);
    if (hPages[1] == NULL)
    {
        dwErr = GetLastError();
        goto error;
    }

    cstrCaptionTemplate.LoadString(IDS_CERT_PROP_CAPTION);
    cstrCaption.Format(cstrCaptionTemplate, szReqID);

    PROPSHEETHEADER sPsh;
    ZeroMemory(&sPsh, sizeof(sPsh));
    sPsh.dwSize = sizeof(sPsh);
    sPsh.dwFlags = PSH_DEFAULT | PSH_PROPTITLE | PSH_NOAPPLYNOW ;
    sPsh.hwndParent = hwnd;
    sPsh.hInstance = g_hInstance;
    sPsh.nPages = ARRAYLEN(hPages);
    sPsh.phpage = hPages;
    sPsh.pszCaption = (LPCWSTR)cstrCaption;

    dwErr = (DWORD)PropertySheet(&sPsh);
    if (dwErr == -1)
    {
        // error
        dwErr = GetLastError();
        goto error;
    }
    if (dwErr == 0)
    {
        // cancel
        dwErr = (DWORD)ERROR_CANCELLED;
        goto error;
    }
    dwErr = S_OK;

error:
    return dwErr;
}


DWORD
ChooseBinaryColumnToDump(
    IN HWND hwnd,
    IN CComponentDataImpl *pComp,
    OUT LPCWSTR *pcwszColumn,
    OUT BOOL *pfSaveToFileOnly)
{
    DWORD dwErr;

    if ((NULL == pcwszColumn) || (NULL == pfSaveToFileOnly))
        return((DWORD) E_POINTER);

    CERTMMC_BINARYCOLCHOOSER sParam = {0};
    sParam.pComp = pComp;

    dwErr = (DWORD)DialogBoxParam(
            g_hInstance,
            MAKEINTRESOURCE(IDD_CHOOSE_BINARY_COLUMN),
            hwnd,
            dlgProcBinaryColChooser,
            (LPARAM)&sParam);

        // translate ok/cancel into error codes
        if (dwErr == IDOK)
            dwErr = ERROR_SUCCESS;
        else if (dwErr == IDCANCEL)
            dwErr = ERROR_CANCELLED;

        _JumpIfError(dwErr, Ret, "dlgProcBinaryColChooser");


    // copy out params, even if null
    *pcwszColumn = sParam.wszCol;
    *pfSaveToFileOnly = sParam.fSaveOnly;

Ret:
    return dwErr;
}


DWORD ViewRowRequestASN(HWND hwnd, LPCWSTR szTempFileName, PBYTE pbRequest, DWORD cbRequest, IN BOOL fSaveToFileOnly)
{
#define P_WAIT 0
#define P_NOWAIT 1

    DWORD dwErr = S_OK;
    WCHAR szTmpPath[MAX_PATH], szReqFile[MAX_PATH], szTmpFile[MAX_PATH];
    WCHAR szCmdLine[MAX_PATH], szSysDir[MAX_PATH];
    LPWSTR pszReqFile = szReqFile;

    STARTUPINFO sStartup;
    ZeroMemory(&sStartup, sizeof(sStartup));
    PROCESS_INFORMATION sProcess;
    ZeroMemory(&sProcess, sizeof(sProcess));
    sStartup.cb = sizeof(sStartup);

    HANDLE hFile = NULL;

    SECURITY_ATTRIBUTES sa;

    // Set up the security attributes struct.
    sa.nLength= sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    if (fSaveToFileOnly)
    {
	// Put up a file dialog to prompt the user for Cert file
	// 0 == hr means dialog was cancelled, we cheat because S_OK == 0

        dwErr = myGetSaveFileName(
                 hwnd,
				 g_hInstance,				// hInstance
                 IDS_BINARYFILE_OUTPUT_TITLE,
                 IDS_BINARYFILE_OUTPUT_FILTER,
                 0,				//no def ext
                 OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
				 szTempFileName,				// default file
                 &pszReqFile);
        _JumpIfError(dwErr, error, "myGetSaveFileName");

        if (NULL == pszReqFile)
        {
            // cancelled:
	    // see public\sdk\inc\cderr.h for real CommDlgExtendedError errors

	    dwErr = CommDlgExtendedError();
	    _JumpError(dwErr, error, "myGetSaveFileName");
        }
    }
    else
    {
		if (0 == GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)))
		{
			dwErr = GetLastError();
			goto error;
		}

		if (0 == GetTempPath(ARRAYSIZE(szTmpPath), szTmpPath))
		{
			dwErr = GetLastError();
			goto error;
		}

		// gen one unique filename
		if (0 == GetTempFileName(
			  szTmpPath,
			  L"TMP",
			  0,
			  szReqFile))	// binary goo
		{
			dwErr = GetLastError();
			goto error;
		}

		// c:\temp\foo.tmp
		wcscpy(szTmpFile, szTmpPath);
		wcscat(szTmpFile, szTempFileName);

                // this file should never exist
	        DeleteFile(szTmpFile);
    }

dwErr = EncodeToFileW(
pszReqFile,
pbRequest,
cbRequest,
CRYPT_STRING_BINARY|DECF_FORCEOVERWRITE);
_JumpIfError(dwErr, error, "EncodeToFile");

    if (fSaveToFileOnly)
    {
       // done saving, bail!
       dwErr = S_OK;
       goto error;
    }


    // open up the output file
    hFile = CreateFile(
         szTmpFile,
         GENERIC_ALL,
         FILE_SHARE_WRITE|FILE_SHARE_READ,
         &sa, // must make inheritable for other process to write to
         OPEN_ALWAYS,
         FILE_ATTRIBUTE_TEMPORARY,
         NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        goto error;
    }

    // set as output
    sStartup.dwFlags = STARTF_USESTDHANDLES;
    sStartup.hStdInput = GetStdHandle(STD_INPUT_HANDLE); 
    sStartup.hStdError = GetStdHandle(STD_ERROR_HANDLE); 
    sStartup.hStdOutput = hFile;


    // exec "certutil -dump szReqFile szTempFile"
    wsprintf(szCmdLine, L"%ws\\certutil.exe -dump \"%ws\"", szSysDir, szReqFile);
    wcscat(szSysDir, L"\\certutil.exe");

    if (!CreateProcess(
      szSysDir, // exe
      szCmdLine, // full cmd line
      NULL,
      NULL,
      TRUE, // use hStdOut
      CREATE_NO_WINDOW,
      NULL,
      NULL,
      &sStartup,
      &sProcess))
    {
        dwErr = GetLastError();
        _JumpError(dwErr, error, "EncodeToFile");
    }

    // wait up to 2 sec for certutil to finish
    if (WAIT_OBJECT_0 != WaitForSingleObject(sProcess.hProcess, INFINITE))
    {
        dwErr = ERROR_TIMEOUT;
        _JumpError(dwErr, error, "EncodeToFile");
    }

    CloseHandle(sProcess.hProcess);
    CloseHandle(hFile);
    hFile=NULL;

    // exec "notepad tmpfil2"
    if (-1 == _wspawnlp(P_NOWAIT, L"notepad.exe", L"notepad.exe", szTmpFile, NULL))
        dwErr = errno;

    // give notepad 2 sec to open before we delete his szTmpFile out from under him
    // use waitforinputidle?
    Sleep(2000);

    // delete the binary file
    DeleteFile(szReqFile);

    // delete the tmp file
    DeleteFile(szTmpFile);

    dwErr = S_OK;
error:
    if (hFile != NULL)
        CloseHandle(hFile);

    // originally points to []
    if ((pszReqFile != NULL) && (pszReqFile != szReqFile))
        LocalFree(pszReqFile);

    return dwErr;
}


///////////////////////////////////////////
// CViewAttrib
/////////////////////////////////////////////////////////////////////////////
// CViewAttrib property page
CViewAttrib::CViewAttrib(UINT uIDD)
    : CAutoDeletePropPage(uIDD)
{
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_ATTR_PROPPAGE);
}

// replacement for DoDataExchange
BOOL CViewAttrib::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CViewAttrib::OnCommand(
    WPARAM, // wParam
    LPARAM) // lParam
{
//    switch(LOWORD(wParam))
    {
//    default:
//        return FALSE;
//        break;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CViewAttrib message handlers
BOOL CViewAttrib::OnInitDialog()
{
    HRESULT hr;
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();


    IEnumCERTVIEWATTRIBUTE* pAttr = m_pAttr;
    BSTR bstrName = NULL, bstrValue = NULL;
    LPWSTR pszName = NULL;

    HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_ATTR);
    CString cstrTmp;

    int iItem =0, iSubItem;

    cstrTmp.LoadString(IDS_LISTCOL_TAG);
    ListView_NewColumn(hwndList, 0, 150, (LPWSTR)(LPCWSTR)cstrTmp);

    cstrTmp.LoadString(IDS_LISTCOL_VALUE);
    ListView_NewColumn(hwndList, 1, 250, (LPWSTR)(LPCWSTR)cstrTmp);

    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

    while(TRUE)
    {
        LONG lIndex = 0;

        // set up for next loop
        hr = pAttr->Next(&lIndex);
        if (hr == S_FALSE)
            break;
        _JumpIfError(hr, initerror, "pAttr->Next");

        hr = pAttr->GetName(&bstrName);
        _JumpIfError(hr, initerror, "pAttr->GetName");

        hr = pAttr->GetValue(&bstrValue);
        _JumpIfError(hr, initerror, "pAttr->GetValue");

        // have all info, populate row
        ListView_NewItem(hwndList, iItem, (LPWSTR)bstrName);
        iSubItem = 1;
        ListView_SetItemText(hwndList, iItem++, iSubItem, (LPWSTR)bstrValue);

        // not necessary to free in the loop
    }

    hr = S_OK;

initerror:

    if (pszName)
        LocalFree(pszName);

    if (bstrName)
        SysFreeString(bstrName);

    if (bstrValue)
        SysFreeString(bstrValue);

    if (hr != S_OK)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        DestroyWindow(m_hWnd);
    }

    return TRUE;
}


///////////////////////////////////////////
// CViewExtn
/////////////////////////////////////////////////////////////////////////////
// CViewExtn property page
CViewExtn::CViewExtn(UINT uIDD)
    : CAutoDeletePropPage(uIDD)
{
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_EXTN_PROPPAGE);

    if (NULL == g_hmodRichEdit)
    {
        g_hmodRichEdit = LoadLibrary(L"RichEd32.dll");
	if (NULL == g_hmodRichEdit)
	{
            HRESULT hr = myHLastError();
            _PrintErrorStr(hr, "LoadLibrary", L"RichEd32.dll");
	}
    }
    INITCOMMONCONTROLSEX initcomm = {
        sizeof(initcomm),
	ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES
    };
    InitCommonControlsEx(&initcomm);
}


CViewExtn::~CViewExtn()
{
    int i;
    for (i=0; i<m_carrExtnValues.GetUpperBound(); i++)
        delete m_carrExtnValues.GetAt(i);
    m_carrExtnValues.Init();
}

// replacement for DoDataExchange
BOOL CViewExtn::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
    }
    else
    {
    }
    return TRUE;
}

BOOL CViewExtn::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
    case IDC_LIST_EXTN:
        if (pnmh->code == LVN_ITEMCHANGED)
            OnReselectItem();
        break;
    }
    return FALSE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CViewExtn::OnCommand(
    WPARAM, // wParam
    LPARAM) // lParam
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

void CViewExtn::OnReselectItem()
{
    HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_EXTN);

    int iSel, iItems = ListView_GetItemCount(hwndList);

    // find selected item
    for(iSel=0; iSel<(LRESULT)iItems; iSel++)
    {
        UINT ui = ListView_GetItemState(hwndList, iSel, LVIS_SELECTED);
        if (ui == LVIS_SELECTED)
            break;
    }

    // selected item
    if (iSel != iItems)
    {
        CSASSERT(m_carrExtnValues.GetUpperBound() >= iSel);
        if (m_carrExtnValues.GetUpperBound() >= iSel)
        {
            CString* pcstr = m_carrExtnValues.GetAt(iSel);
            CSASSERT(pcstr);
            if (pcstr != NULL)
                SetDlgItemText(m_hWnd, IDC_EDIT_EXTN, *pcstr);
        }
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
// CViewExtn message handlers
BOOL CViewExtn::OnInitDialog()
{
    HRESULT hr = S_OK;
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();


    IEnumCERTVIEWEXTENSION* pExtn = m_pExtn;
    BSTR bstrName = NULL, bstrValue = NULL;
    LPWSTR pszName = NULL;
    LPWSTR pszFormattedExtn = NULL;
    VARIANT varExtn;
    VariantInit(&varExtn);

    HWND hwndList = GetDlgItem(m_hWnd, IDC_LIST_EXTN);

    CString cstrTmp;

    int iItem = 0;

    cstrTmp.LoadString(IDS_LISTCOL_TAG);
    ListView_NewColumn(hwndList, 0, 150, (LPWSTR)(LPCWSTR)cstrTmp);

    cstrTmp.LoadString(IDS_LISTCOL_ORGIN);
    ListView_NewColumn(hwndList, 1, 70, (LPWSTR)(LPCWSTR)cstrTmp);

    cstrTmp.LoadString(IDS_LISTCOL_CRITICAL);
    ListView_NewColumn(hwndList, 2, 70, (LPWSTR)(LPCWSTR)cstrTmp);

    cstrTmp.LoadString(IDS_LISTCOL_ENABLED);
    ListView_NewColumn(hwndList, 3, 70, (LPWSTR)(LPCWSTR)cstrTmp);

    //set whole row selection
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

    while(TRUE)
    {
        CString cstrOrigin;
        CString cstrCritical;
        CString cstrEnabled;
        CString* pcstr;
        LONG lIndex = 0, lExtFlags;

        // set up for next loop
        hr = pExtn->Next(&lIndex);
        if (hr == S_FALSE)
            break;
        _JumpIfError(hr, initerror, "pExtn->Next");

        hr = pExtn->GetName(&bstrName);
        _JumpIfError(hr, initerror, "pExtn->GetName");

        if (pszName)
            LocalFree(pszName);
        pszName = NULL;
        hr = myOIDToName(bstrName, &pszName);
        _PrintIfError(hr, "myOIDToName");

        hr = pExtn->GetFlags(&lExtFlags);
        _JumpIfError(hr, initerror, "pExtn->GetFlags");

        switch ( lExtFlags & EXTENSION_ORIGIN_MASK )
        {
            case EXTENSION_ORIGIN_REQUEST:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_REQUEST);
                break;
            case EXTENSION_ORIGIN_POLICY:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_POLICY);
                break;
            case EXTENSION_ORIGIN_ADMIN:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_ADMIN);
                break;
            case EXTENSION_ORIGIN_SERVER:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_SERVER);
                break;
            case EXTENSION_ORIGIN_RENEWALCERT:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_RENEWAL);
                break;
            case EXTENSION_ORIGIN_IMPORTEDCERT:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_IMPORTED_CERT);
                break;
            case EXTENSION_ORIGIN_PKCS7:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_PKCS7);
                break;
            case EXTENSION_ORIGIN_CMC:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_CMC);
                break;
            case EXTENSION_ORIGIN_CACERT:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_CACERT);
                break;
            default:
                cstrOrigin.LoadString(IDS_EXT_ORIGIN_UNKNOWN);
                DBGPRINT((DBG_SS_CERTMMC, "Unknown extension orgin: 0x%x\n", (lExtFlags & EXTENSION_ORIGIN_MASK)));
                break;
        }

        // possible to be both crit & disabled
        if ( (lExtFlags & EXTENSION_CRITICAL_FLAG) != 0)
            cstrCritical.LoadString(IDS_YES);
        else
            cstrCritical.LoadString(IDS_NO);

        if ( (lExtFlags & EXTENSION_DISABLE_FLAG) != 0)
            cstrEnabled.LoadString(IDS_NO);
        else
            cstrEnabled.LoadString(IDS_YES);

        hr = pExtn->GetValue(
            PROPTYPE_BINARY,
            CV_OUT_BINARY,
            &varExtn);
        _JumpIfError(hr, initerror, "pExtn->GetValue");

        if (varExtn.vt == VT_BSTR)
        {
            if (pszFormattedExtn)
                LocalFree(pszFormattedExtn);
            pszFormattedExtn = NULL;
            hr = myDumpFormattedObject(
                bstrName,
                (PBYTE)varExtn.bstrVal,
                SysStringByteLen(varExtn.bstrVal),
                &pszFormattedExtn);
            _PrintIfError(hr, "myDumpFormattedObject");
        }

        // have all info, populate row

        // tag name (subitem 0)
        ListView_NewItem(hwndList, iItem, (pszName!=NULL) ? pszName : (LPWSTR)bstrName);
        // origin (subitem 1)
        ListView_SetItemText(hwndList, iItem, 1, (LPWSTR)(LPCWSTR)cstrOrigin);
        // critical flag (subitem 2)
        ListView_SetItemText(hwndList, iItem, 2, (LPWSTR)(LPCWSTR)cstrCritical);
        // enabled flag (subitem 3)
        ListView_SetItemText(hwndList, iItem, 3, (LPWSTR)(LPCWSTR)cstrEnabled);

        // value
        pcstr = new CString;
        if (pcstr != NULL)
        {
           *pcstr = pszFormattedExtn;
           m_carrExtnValues.Add(pcstr);    // arr owns pcstr memory
           pcstr = NULL;
        }
        else
        {
           hr = E_OUTOFMEMORY;
           _JumpError(hr, initerror, "new CString");
        }

        iItem++;

        // not necessary to free in the loop
    }

    hr = S_OK;

initerror:
    VariantClear(&varExtn);

    if (pszName)
        LocalFree(pszName);

    if (bstrName)
        SysFreeString(bstrName);

    if (pszFormattedExtn)
        LocalFree(pszFormattedExtn);

    if (bstrValue)
        SysFreeString(bstrValue);

    if (hr != S_OK)
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
        DestroyWindow(m_hWnd);
    }

    return TRUE;
}


///////////////////////////////////////////
// CViewCertManagers
/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsGeneralPage property page

RoleAccessToControl CSvrSettingsCertManagersPage::sm_ControlToRoleMap[] = 
{
    { IDC_RADIO_DISABLEOFFICERS,    CA_ACCESS_ADMIN },
    { IDC_RADIO_ENABLEOFFICERS,     CA_ACCESS_ADMIN },
    { IDC_ALLOWDENY,                CA_ACCESS_ADMIN },
    { IDC_ADDSUBJECT,               CA_ACCESS_ADMIN },
    { IDC_REMOVESUBJECT,            CA_ACCESS_ADMIN },
};


CSvrSettingsCertManagersPage::CSvrSettingsCertManagersPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    :   CAutoDeletePropPage(uIDD), 
        CRolesSupportInPropPage(
            pControlPage->m_pCA,
            sm_ControlToRoleMap,
            ARRAYSIZE(sm_ControlToRoleMap)),
        m_pControlPage(pControlPage), 
        m_fEnabled(FALSE), 
        m_fDirty(FALSE)
{

    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE6);

    if(m_strButtonAllow.IsEmpty())
        m_strButtonAllow.LoadString(IDS_BUTTONTEXT_ALLOW);
    if(m_strButtonDeny.IsEmpty())
        m_strButtonDeny.LoadString(IDS_BUTTONTEXT_DENY);
    if(m_strTextAllow.IsEmpty())
        m_strTextAllow.LoadString(IDS_TEXT_ALLOW);
    if(m_strTextDeny.IsEmpty())
        m_strTextDeny.LoadString(IDS_TEXT_DENY);
}

CSvrSettingsCertManagersPage::~CSvrSettingsCertManagersPage()
{
}


// replacement for BEGIN_MESSAGE_MAP
BOOL
CSvrSettingsCertManagersPage::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    switch(LOWORD(wParam))
    {
    case IDC_ADDSUBJECT:
        OnAddSubject();
        break;
    case IDC_REMOVESUBJECT:
        OnRemoveSubject();
        break;
    case IDC_ALLOWDENY:
        OnAllowDeny();
        break;
    case IDC_RADIO_ENABLEOFFICERS:
        OnEnableOfficers(true);
        break;
    case IDC_RADIO_DISABLEOFFICERS:
        OnEnableOfficers(false);
        break;
    case IDC_LIST_CERTMANAGERS:
        switch (HIWORD(wParam))
        {
            case CBN_SELCHANGE:
                // extension selection is changed
                OnOfficerChange();
            break;
        }
        break;
    default:
        return FALSE;
        break;
    }
    return TRUE;
}

void CSvrSettingsCertManagersPage::OnOfficerChange()
{
    DWORD dwOfficerIndex = GetCurrentOfficerIndex();
    if(-1!=dwOfficerIndex)
    {
        FillClientList(GetCurrentOfficerIndex());
    }
    SetAllowDeny();
}

BOOL CSvrSettingsCertManagersPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
   LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pnmh;

    switch(idCtrl)
    {
    case IDC_LIST_SUBJECTS:
        if (pnmh->code == LVN_ITEMCHANGED)
        {
            if(pnmlv->uChanged & LVIF_STATE)
            {
                if ((pnmlv->uNewState & LVIS_SELECTED) &&
                    !(pnmlv->uOldState & LVIS_SELECTED))
                {
                    SetAllowDeny();
                }
            }
        }
        break;
    default:
        return CAutoDeletePropPage::OnNotify(idCtrl, pnmh);
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsCertManagersPage message handlers
BOOL CSvrSettingsCertManagersPage::OnInitDialog()
{
    HWND hwndClients  = GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS);
    RECT rc;
    LV_COLUMN col;
    GetClientRect(hwndClients, &rc);
    CString strHeader;
    CString strAccess;

    strHeader.LoadString(IDS_LIST_NAME);
    strAccess.LoadString(IDS_LIST_ACCESS);

    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.pszText = strHeader.GetBuffer();
    col.iSubItem = 0;
    col.cx = rc.right*3/4;
    ListView_InsertColumn(hwndClients, 0, &col);

    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.pszText = strAccess.GetBuffer();
    col.iSubItem = 0;
    col.cx = rc.right*1/4;
    ListView_InsertColumn(hwndClients, 1, &col);

    ListView_SetExtendedListViewStyle(hwndClients, LVS_EX_FULLROWSELECT);

    UpdateData(FALSE);
    return TRUE;
}


BOOL CSvrSettingsCertManagersPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (!fSuckFromDlg)
    {
        HRESULT hr = GetOfficerRights();
        _PrintIfError(hr, "GetOfficerRights");
        if(S_OK!=hr)
        {
            // hide all controls and show error text

            HideControls();

            EnableWindow(GetDlgItem(IDC_UNAVAILABLE), TRUE);
            ShowWindow(GetDlgItem(IDC_UNAVAILABLE), SW_SHOW);
            }
        else
        {
            EnableControls();
        }
    }
    return TRUE;
}

void CSvrSettingsCertManagersPage::OnDestroy()
{
    CAutoDeletePropPage::OnDestroy();
}


BOOL CSvrSettingsCertManagersPage::OnApply()
{
    if(IsDirty())
    {
        HRESULT hr = SetOfficerRights();
        if (hr != S_OK)
        {
            DisplayGenericCertSrvError(m_hWnd, hr);
            return FALSE;
        }
    }

    UpdateData(FALSE);
    return CAutoDeletePropPage::OnApply();
}

void CSvrSettingsCertManagersPage::OnAddSubject()
{
    PSID pSid = NULL;
    HRESULT hr;
    DWORD dwIndex;
    CertSrv::COfficerRights* pOfficer;
    hr = BrowseForSubject(m_hWnd, pSid);
    _JumpIfError(hr, err, "BrowseForSubject");

    if(S_OK==hr)
    {
        HWND hwnd = GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS);

        pOfficer = m_OfficerRightsList.GetAt(GetCurrentOfficerIndex());

        dwIndex = pOfficer->Find(pSid);
        if(DWORD_MAX==dwIndex)
        {
            dwIndex = pOfficer->GetCount();
            pOfficer->Add(pSid, TRUE);

            ListView_NewItem(hwnd, dwIndex,
                pOfficer->GetAt(dwIndex)->GetName());
            ListView_SetItemText(hwnd, dwIndex, 1,
                pOfficer->GetAt(dwIndex)->GetPermission()?
                m_strTextAllow.GetBuffer():
                m_strTextDeny.GetBuffer());
            SetAllowDeny();
            SetDirty();
        }

        ::EnableWindow(GetDlgItem(m_hWnd, IDC_REMOVESUBJECT), TRUE);
        ::EnableWindow(GetDlgItem(m_hWnd, IDC_ALLOWDENY),   TRUE);

        ListView_SetItemState(hwnd, dwIndex,
            LVIS_SELECTED|LVIS_FOCUSED , LVIS_SELECTED|LVIS_FOCUSED);
        SetFocus(hwnd);
    }
    else
    {
        DisplayGenericCertSrvError(m_hWnd, hr);
    }

err:
    if(pSid)
        LocalFree(pSid);
}

void CSvrSettingsCertManagersPage::OnRemoveSubject()
{
    DWORD dwClientIndex = GetCurrentClientIndex();
    DWORD dwOfficerIndex = GetCurrentOfficerIndex();
    HWND hwndListClients = GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS);


    m_OfficerRightsList.GetAt(dwOfficerIndex)->
        RemoveAt(dwClientIndex);

    ListView_DeleteItem(hwndListClients, dwClientIndex);

    if(0==m_OfficerRightsList.GetAt(dwOfficerIndex)->GetCount())
    {
        EnableControl(m_hWnd, IDC_REMOVESUBJECT, FALSE);
        EnableControl(m_hWnd, IDC_ALLOWDENY, FALSE);
        SetFocus(GetDlgItem(m_hWnd, IDC_ADDSUBJECT));
    }
    else
    {
        if(dwClientIndex==
            m_OfficerRightsList.GetAt(dwOfficerIndex)->GetCount())
            dwClientIndex--;
        ListView_SetItemState(hwndListClients, dwClientIndex,
            LVIS_SELECTED|LVIS_FOCUSED , LVIS_SELECTED|LVIS_FOCUSED);
        SetFocus(hwndListClients);
    }

    SetDirty();
}

void CSvrSettingsCertManagersPage::OnAllowDeny()
{
    DWORD dwCrtClient  = GetCurrentClientIndex();
    DWORD dwCrtOfficer = GetCurrentOfficerIndex();
    CertSrv::CClientPermission *pClient =
        m_OfficerRightsList.GetAt(dwCrtOfficer)->GetAt(dwCrtClient);

    m_OfficerRightsList.GetAt(dwCrtOfficer)->
        SetAt(dwCrtClient, !pClient->GetPermission());

    SetAllowDeny();

    ListView_SetItemText(
        GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS),
        dwCrtClient,
        1,
        pClient->GetPermission()?
        m_strTextAllow.GetBuffer():
        m_strTextDeny.GetBuffer());

    SetDirty();

}

void CSvrSettingsCertManagersPage::OnEnableOfficers(bool fEnable)
{
    // only if switching enable -> disable or the other way
    if(m_fEnabled && !fEnable ||
       !m_fEnabled && fEnable)
    {
        if(fEnable)
        {
            HRESULT hr = BuildVirtualOfficerRights();
            if(S_OK!=hr)
            {
                DisplayGenericCertSrvError(m_hWnd, hr);
                return;
            }
        }
        m_fEnabled = fEnable;
        EnableControls();
        SetDirty();
    }
}


void CSvrSettingsCertManagersPage::EnableControls()
{
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_LIST_CERTMANAGERS), m_fEnabled);
    ::EnableWindow(GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS),     m_fEnabled);
    EnableControl(m_hWnd, IDC_ADDSUBJECT, m_fEnabled);
    EnableControl(m_hWnd, IDC_REMOVESUBJECT, m_fEnabled);
    EnableControl(m_hWnd, IDC_ALLOWDENY, m_fEnabled);
    EnableControl(m_hWnd, IDC_RADIO_DISABLEOFFICERS, TRUE);
    EnableControl(m_hWnd, IDC_RADIO_ENABLEOFFICERS, TRUE);


    SendMessage(
        GetDlgItem(m_hWnd, IDC_RADIO_ENABLEOFFICERS),
        BM_SETCHECK,
        m_fEnabled?TRUE:FALSE, 0);

    SendMessage(
        GetDlgItem(m_hWnd, IDC_RADIO_DISABLEOFFICERS),
        BM_SETCHECK,
        m_fEnabled?FALSE:TRUE, 0);

    FillOfficerList();
    FillClientList(0);
    SetAllowDeny();
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsCertManagersPage utilities

HRESULT CSvrSettingsCertManagersPage::BrowseForSubject(HWND hwnd, PSID &rpSid)
{
    HRESULT hr;
    CComPtr<IDsObjectPicker> pObjPicker;
    CComPtr<IDataObject> pdo;
    BOOL fCurrentMachine = m_pControlPage->m_pCA->m_pParentMachine->IsLocalMachine();
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    BOOL bAllocatedStgMedium = FALSE;
    PDS_SELECTION_LIST      pDsSelList = NULL;
    static PCWSTR pwszObjSID = L"ObjectSid";
    SAFEARRAY *saSid = NULL;
    void HUGEP *pArray = NULL;
    const int MAX_SCOPE_INIT_COUNT = 10;
    ULONG scopesDomain[] =
    {
        DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_TYPE_TARGET_COMPUTER,
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
        DSOP_SCOPE_TYPE_WORKGROUP,
    };

    ULONG scopesStandalone[] =
    {
        DSOP_SCOPE_TYPE_TARGET_COMPUTER,
    };
    bool fStandalone = (S_OK != myDoesDSExist(FALSE));

    ULONG *pScopes = fStandalone?scopesStandalone:scopesDomain;
    int nScopes = (int)(fStandalone?ARRAYSIZE(scopesStandalone):ARRAYSIZE(scopesDomain));

    hr = CoCreateInstance (CLSID_DsObjectPicker,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IDsObjectPicker,
                           (void **) &pObjPicker);
    _JumpIfError(hr, err, "CoCreateInstance(IID_IDsObjectPicker");

    DSOP_SCOPE_INIT_INFO aScopeInit[MAX_SCOPE_INIT_COUNT];
    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * MAX_SCOPE_INIT_COUNT);

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flScope =
            DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
            DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS |
            DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;
    aScopeInit[0].flType = pScopes[0];
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_USERS|
        DSOP_FILTER_COMPUTERS|
        DSOP_FILTER_BUILTIN_GROUPS|
        DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE|
        DSOP_FILTER_GLOBAL_GROUPS_SE|
        DSOP_FILTER_UNIVERSAL_GROUPS_SE|
        DSOP_FILTER_WELL_KNOWN_PRINCIPALS;

    aScopeInit[0].FilterFlags.flDownlevel =
        DSOP_DOWNLEVEL_FILTER_USERS |
        DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS |
        DSOP_DOWNLEVEL_FILTER_COMPUTERS |
        DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS |
        DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

    for(int c=1;c<nScopes;c++)
    {
        aScopeInit[c] = aScopeInit[0];
        aScopeInit[c].flType = pScopes[c];
    }
    aScopeInit[0].flScope |= DSOP_SCOPE_FLAG_STARTING_SCOPE;

    DSOP_INIT_INFO  initInfo;
    ZeroMemory(&initInfo, sizeof(initInfo));
    initInfo.cbSize = sizeof(initInfo);
    initInfo.pwzTargetComputer = fCurrentMachine ?
        NULL : (LPCWSTR)m_pControlPage->m_pCA->m_strServer,
    initInfo.cDsScopeInfos = nScopes;
    initInfo.aDsScopeInfos = aScopeInit;
    initInfo.cAttributesToFetch = 1;
    initInfo.apwzAttributeNames = &pwszObjSID;

    hr = pObjPicker->Initialize(&initInfo);
    _JumpIfError(hr, err, "IDsObjectPicker::Initialize");

    hr = pObjPicker->InvokeDialog(hwnd, &pdo);
    _JumpIfError(hr, err, "IDsObjectPicker::InvokeDialog");

    if(S_OK==hr)
    {
        UINT                    cf = 0;
        FORMATETC               formatetc = {
                                            (CLIPFORMAT)cf,
                                            NULL,
                                            DVASPECT_CONTENT,
                                            -1,
                                            TYMED_HGLOBAL
                                            };
        PDS_SELECTION           pDsSelection = NULL;

        cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);
        if (0 == cf)
        {
            hr = myHLastError();
            _JumpIfError(hr, err, "RegisterClipboardFormat");
        }

        //set the clipformat for the formatetc structure
        formatetc.cfFormat = (CLIPFORMAT)cf;

        hr = pdo->GetData (&formatetc, &stgmedium);
        _JumpIfError(hr, err, "IDataObject::GetData");

        bAllocatedStgMedium = TRUE;
        pDsSelList = (PDS_SELECTION_LIST) GlobalLock (stgmedium.hGlobal);

        if (NULL == pDsSelList)
        {
            hr = myHLastError();
            _JumpIfError(hr, err, "GlobalLock");
        }


        if (!pDsSelList->cItems)    //some item must have been selected
        {
            hr = E_UNEXPECTED;
            _JumpIfError(hr, err, "no items selected in object picker");
        }

        pDsSelection = &(pDsSelList->aDsSelection[0]);

        saSid = V_ARRAY(pDsSelection->pvarFetchedAttributes);
        hr = SafeArrayAccessData(saSid, &pArray);
        _JumpIfError(hr, err, "SafeArrayAccessData");

        CSASSERT(IsValidSid((PSID)pArray));
        rpSid = LocalAlloc(LMEM_FIXED, GetLengthSid((PSID)pArray));
        if(!CopySid(GetLengthSid((PSID)pArray),
            rpSid,
            pArray))
        {
            hr = myHLastError();
            _JumpIfError(hr, err, "GlobalLock");
        }
    }

err:
    if(pArray)
        SafeArrayUnaccessData(saSid);
    if(pDsSelList)
        GlobalUnlock(stgmedium.hGlobal);
    if (bAllocatedStgMedium)
        ReleaseStgMedium (&stgmedium);

    return hr;
}

HRESULT CSvrSettingsCertManagersPage::GetOfficerRights()
{
    HRESULT hr = S_OK;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 2;	// 0 required by myOpenAdminDComConnection
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbSD;
	ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

	if (2 > dwServerVersion)
	{
	    hr = RPC_E_VERSION_MISMATCH;
	    _JumpError(hr, error, "old server");
	}

    __try
    {
        hr = pICertAdminD->GetOfficerRights(
                 pwszAuthority,
                 &m_fEnabled,
                 &ctbSD);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->GetOfficerRights");

    myRegisterMemAlloc(ctbSD.pb, ctbSD.cb, CSM_COTASKALLOC);

    m_OfficerRightsList.Cleanup();

    if(m_fEnabled)
    {
        hr = m_OfficerRightsList.Load(ctbSD.pb);
        _JumpIfError(hr, error, "COfficerRightsList::Init");
    }

error:
    if(pICertAdminD)
    {
        myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);
    }
    if (NULL != ctbSD.pb)
    {
        CoTaskMemFree(ctbSD.pb);
    }

    return hr;
}

HRESULT CSvrSettingsCertManagersPage::SetOfficerRights()
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 2;	// 0 required by myOpenAdminDComConnection
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbSD;
	ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    if(m_fEnabled)
    {
        hr = m_OfficerRightsList.Save(pSD);
        _JumpIfError(hr, error, "COfficerRightsList::Save");

        ctbSD.cb = GetSecurityDescriptorLength(pSD);
        ctbSD.pb = (BYTE*)pSD;
    }
    else
    {
        ZeroMemory(&ctbSD, sizeof(ctbSD));
    }

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, error, "old server");
    }

    __try
    {
        hr = pICertAdminD->SetOfficerRights(
                 pwszAuthority,
                 m_fEnabled,
                 &ctbSD);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->GetOfficerRights");

error:
    myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);

    if(pSD)
    {
        LocalFree(pSD);
    }

    return hr;
}

#pragma warning(push)
#pragma warning(disable: 4509) // nonstandard extension used: uses SEH and has destructor
HRESULT
CSvrSettingsCertManagersPage::BuildVirtualOfficerRights()
{
    HRESULT hr = S_OK;
    CertSrv::COfficerRightsSD VirtOfficerRightsSD;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion = 2;	// 0 required by myOpenAdminDComConnection
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbSD;
	ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));
    PSECURITY_DESCRIPTOR pVirtOfficerRights;

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, error, "old server");
    }

    __try
    {
        hr = pICertAdminD->GetCASecurity(
                 pwszAuthority,
                 &ctbSD);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "pICertAdminD->GetOfficerRights");

    // BuildVirtualOfficerRights should be called only when transitioning
    // from not enabled to enabled, before enabling on the server side
    CSASSERT(!m_fEnabled);

    myRegisterMemAlloc(ctbSD.pb, ctbSD.cb, CSM_COTASKALLOC);

    m_OfficerRightsList.Cleanup();

    hr = VirtOfficerRightsSD.InitializeEmpty();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Initialize");

    hr = VirtOfficerRightsSD.Adjust(ctbSD.pb);
    _JumpIfError(hr, error, "COfficerRightsSD::Adjust");

    pVirtOfficerRights = VirtOfficerRightsSD.Get();
    CSASSERT(pVirtOfficerRights);

    hr = m_OfficerRightsList.Load(pVirtOfficerRights);
    _JumpIfError(hr, error, "COfficerRightsList::Load");

error:
    myCloseDComConnection((IUnknown **) &pICertAdminD, NULL);
    if (NULL != ctbSD.pb)
    {
        CoTaskMemFree(ctbSD.pb);
    }
    return hr;
}
#pragma warning(pop)


void CSvrSettingsCertManagersPage::FillOfficerList()
{
    HWND hwnd= GetDlgItem(m_hWnd, IDC_LIST_CERTMANAGERS);

    SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    if(m_fEnabled)
    {
        for(DWORD cManagers=0;
            cManagers<m_OfficerRightsList.GetCount();
            cManagers++)
        {
            CSASSERT(m_OfficerRightsList.GetAt(cManagers));

            DBGCODE(LRESULT nIndex =) SendMessage(hwnd, CB_ADDSTRING, 0,
                (LPARAM)m_OfficerRightsList.GetAt(cManagers)->GetName());
            CSASSERT(nIndex != CB_ERR);
        }

        SendMessage(hwnd, CB_SETCURSEL, 0, 0);
    }
}

void CSvrSettingsCertManagersPage::FillClientList(DWORD dwOfficerIndex)
{
    HWND hwnd= GetDlgItem(m_hWnd, IDC_LIST_SUBJECTS);
    CertSrv::COfficerRights *pOfficer = NULL;
    DWORD dwClientCount, cClients;

    ListView_DeleteAllItems(hwnd);

    if(m_fEnabled)
    {
        if(dwOfficerIndex<m_OfficerRightsList.GetCount())
        {
            pOfficer = m_OfficerRightsList.GetAt(dwOfficerIndex);
            CSASSERT(pOfficer);
            dwClientCount = pOfficer->GetCount();
            for(cClients=0;cClients<dwClientCount;cClients++)
            {
                ListView_NewItem(hwnd, cClients,
                    pOfficer->GetAt(cClients)->GetName());

                ListView_SetItemText(hwnd, cClients, 1,
                    pOfficer->GetAt(cClients)->GetPermission()?
                    m_strTextAllow.GetBuffer():
                    m_strTextDeny.GetBuffer());
            }

            ListView_SetItemState(hwnd, 0,
                LVIS_SELECTED|LVIS_FOCUSED , LVIS_SELECTED|LVIS_FOCUSED);
        }
    }
}

void CSvrSettingsCertManagersPage::SetAllowDeny()
{
    if(m_fEnabled && 0!=m_OfficerRightsList.GetCount())
    {
        DWORD dwIndex = GetCurrentOfficerIndex();
        if(0!=m_OfficerRightsList.GetAt(dwIndex)->GetCount())
        {
            BOOL fPermission = m_OfficerRightsList.GetAt(dwIndex)->
                GetAt(GetCurrentClientIndex())->GetPermission();

            EnableControl(m_hWnd, IDC_ALLOWDENY, TRUE);

            SetDlgItemText(
                m_hWnd,
                IDC_ALLOWDENY,
                fPermission?m_strButtonDeny:m_strButtonAllow);
            return;
        }
    }

    EnableControl(m_hWnd, IDC_ALLOWDENY, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CSvrSettingsAuditFilterPage property page

RoleAccessToControl CSvrSettingsAuditFilterPage::sm_ControlToRoleMap[] = 
{
    { IDC_AUDIT_BACKUPRESTORE,  CA_ACCESS_AUDITOR},
    { IDC_AUDIT_CACONFIG,       CA_ACCESS_AUDITOR},
    { IDC_AUDIT_CASEC,          CA_ACCESS_AUDITOR},
    { IDC_AUDIT_CERTIFICATE,    CA_ACCESS_AUDITOR},
    { IDC_AUDIT_CRL,            CA_ACCESS_AUDITOR},
    { IDC_AUDIT_KEYARCHIVAL,    CA_ACCESS_AUDITOR},
    { IDC_AUDIT_STARTSTOP,      CA_ACCESS_AUDITOR},
};

CSvrSettingsAuditFilterPage::CSvrSettingsAuditFilterPage(CSvrSettingsGeneralPage* pControlPage, UINT uIDD)
    :   CAutoDeletePropPage(uIDD),
        CRolesSupportInPropPage(
            pControlPage->m_pCA,
            sm_ControlToRoleMap,
            ARRAYSIZE(sm_ControlToRoleMap)),
        m_pControlPage(pControlPage), 
        m_fDirty(FALSE), 
        m_dwFilter(0)
{
    SetHelp(CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_CERTSRV_PROPPAGE7);
}

CSvrSettingsAuditFilterPage::~CSvrSettingsAuditFilterPage()
{
}

int CSvrSettingsAuditFilterPage::m_iCheckboxID[] =
{
    // ID order must match bit order in audit flag DWORD, see
    // AUDIT_FILTER_* in include\audit.h
    IDC_AUDIT_STARTSTOP,
    IDC_AUDIT_BACKUPRESTORE,
    IDC_AUDIT_CERTIFICATE,
    IDC_AUDIT_CRL,
    IDC_AUDIT_CASEC,
    IDC_AUDIT_KEYARCHIVAL,
    IDC_AUDIT_CACONFIG
};

BOOL CSvrSettingsAuditFilterPage::OnInitDialog()
{
    GetAuditFilter();
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();
    for(int i=0; i<ARRAYLEN(m_iCheckboxID); i++)
        EnableControl(m_hWnd, m_iCheckboxID[i], TRUE); 
    UpdateData(FALSE);
    return TRUE;
}

HRESULT CSvrSettingsAuditFilterPage::GetAuditFilterDCOM()
{
    HRESULT hr = S_OK;
    ICertAdminD2* pAdminD = NULL;
    WCHAR const *pwszAuthority;
    DWORD dwServerVersion = 2;
    LPCWSTR pcwszPriv = SE_SECURITY_NAME;
    HANDLE hToken = EnablePrivileges(&pcwszPriv, 1);

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pAdminD);
    _JumpIfError(hr, Ret, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, Ret, "old server");
    }

	// load certs here
	hr = pAdminD->GetAuditFilter(
		pwszAuthority,
		&m_dwFilter);
	_JumpIfError(hr, Ret, "ICertAdminD2::GetAuditFilter");

Ret:
	if (pAdminD)
    {
		pAdminD->Release();
    }

    ReleasePrivileges(hToken);

    return hr;
}

HRESULT CSvrSettingsAuditFilterPage::GetAuditFilterRegistry()
{
    HRESULT hr = S_OK;
    variant_t var;

    hr = m_pCA->GetConfigEntry(
                NULL,
                wszREGAUDITFILTER,
                &var);
    _JumpIfError(hr, Ret, "GetConfigEntry");

    m_dwFilter = (DWORD)V_I4(&var);

Ret:
    return hr;
}

HRESULT CSvrSettingsAuditFilterPage::GetAuditFilter()
{
    HRESULT hr = S_OK;

    hr = GetAuditFilterDCOM();
    _PrintIfError(hr, "GetAuditFilterDCOM");

    if(S_OK!=hr)
    {
        hr = GetAuditFilterRegistry();
        _PrintIfError(hr, "GetAuditFilterRegistry");
    }

    return hr;
}

HRESULT CSvrSettingsAuditFilterPage::SetAuditFilterDCOM()
{
    HRESULT hr = S_OK;
    ICertAdminD2* pAdminD = NULL;
    WCHAR const *pwszAuthority;
    DWORD dwServerVersion = 2;
    LPCWSTR pcwszPriv = SE_SECURITY_NAME;
    HANDLE hToken = INVALID_HANDLE_VALUE;

    hToken = EnablePrivileges(&pcwszPriv, 1);

    hr = myOpenAdminDComConnection(
                    m_pControlPage->m_pCA->m_bstrConfig,
                    &pwszAuthority,
                    NULL,
                    &dwServerVersion,
                    &pAdminD);
    _JumpIfError(hr, Ret, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, Ret, "old server");
    }

	// load certs here
	hr = pAdminD->SetAuditFilter(
		pwszAuthority,
		m_dwFilter);
	_JumpIfError(hr, Ret, "ICertAdminD2::SetAuditFilter");

Ret:
    if (pAdminD)
    {
		pAdminD->Release();
    }

    ReleasePrivileges(hToken);

    return hr;
}

HRESULT CSvrSettingsAuditFilterPage::SetAuditFilterRegistry()
{
    HRESULT hr = S_OK;
    variant_t var;

    V_VT(&var) = VT_I4;
    V_I4(&var) = m_dwFilter;

    hr = m_pCA->SetConfigEntry(
                NULL,
                wszREGAUDITFILTER,
                &var);
    _JumpIfError(hr, Ret, "SetConfigEntry");

Ret:
    return hr;
}

HRESULT CSvrSettingsAuditFilterPage::SetAuditFilter()
{
    HRESULT hr = S_OK;

    hr = SetAuditFilterDCOM();
    _PrintIfError(hr, "SetAuditFilterDCOM");

    if(S_OK!=hr)
    {
        hr = SetAuditFilterRegistry();
        _PrintIfError(hr, "SetAuditFilterRegistry");
    }

    return hr;
}

BOOL CSvrSettingsAuditFilterPage::OnApply()
{
    HRESULT hr = S_OK;

    if (TRUE==m_fDirty)
    {
        UpdateData(TRUE);

        hr = SetAuditFilter();
        _JumpIfError(hr, Ret, "SetAuditFilter");

        m_fDirty = FALSE;
    }

Ret:
    if (S_OK != hr)
    {
	DisplayGenericCertSrvError(m_hWnd, hr);
        return FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}


BOOL CSvrSettingsAuditFilterPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    int c;
    DWORD dwBit;

    if (fSuckFromDlg)
    {
        m_dwFilter = 0;
        for(c=0, dwBit=1; c<ARRAYLEN(m_iCheckboxID); c++, dwBit<<=1)
        {
            // set corresponding bit in filter DWORD
            m_dwFilter = m_dwFilter |
                ((INT)SendDlgItemMessage(m_iCheckboxID[c], BM_GETCHECK, 0, 0)?dwBit:0);
        }
    }
    else
    {
        for(c=0, dwBit=1; c<ARRAYLEN(m_iCheckboxID); c++, dwBit<<=1)
        {
            // set checkbox corresponding to bit in filter DWORD
            SendDlgItemMessage(m_iCheckboxID[c], BM_SETCHECK,
                (m_dwFilter&dwBit)?BST_CHECKED:BST_UNCHECKED, 0);
        }
    }
    return TRUE;
}


BOOL
CSvrSettingsAuditFilterPage::OnCommand(
    WPARAM wParam,
    LPARAM) // lParam
{
    int c;
    static s_fAlreadyWarnedStartStopPerf = false;

    if (BN_CLICKED == HIWORD(wParam))
    {
    // walk the checkbox list and set dirty flag
    for(c=0; c<ARRAYLEN(m_iCheckboxID); c++)
    {
        // if audit start/stop is checked the first time, warn the user 
        // that auditing start/stop can be expensive due to lengthy database hash 
        // computation
        if(!s_fAlreadyWarnedStartStopPerf &&
           LOWORD(wParam)==IDC_AUDIT_STARTSTOP &&
           BST_CHECKED==SendDlgItemMessage(IDC_AUDIT_STARTSTOP, BM_GETCHECK, 0, 0))
        {
            CString cstrMsg, cstrTitle;
            cstrMsg.LoadString(IDS_WARN_START_STOP_PERFORMANCE);
            cstrTitle.LoadString(IDS_MSG_TITLE);
            MessageBoxW(GetParent(), cstrMsg, cstrTitle, MB_ICONWARNING|MB_OK);
            s_fAlreadyWarnedStartStopPerf = true;

        }

        if(LOWORD(wParam)==m_iCheckboxID[c])
        {
            m_fDirty = TRUE;
            SendMessage (GetParent(), PSM_CHANGED, (WPARAM) m_hWnd, 0);
            return TRUE;
        }
    }
    }

    return FALSE;
}


HRESULT GetPolicyManageDispatch(
    LPCWSTR pcwszProgID,
    REFCLSID clsidModule, 
    DISPATCHINTERFACE* pdi)
{
    HRESULT hr;
    DISPATCHINTERFACE di;
    bool fRelease = false;
    CString pszprogidPolicyManage;
    CLSID  clsidPolicyManage;

    hr = Policy_Init(
        DISPSETUP_COMFIRST,
        pcwszProgID,
        &clsidModule,
        &di);
    _JumpIfErrorStr(hr, Ret, "Policy_Init", pcwszProgID);

    fRelease = true;

    hr = Policy2_GetManageModule(
        &di,
        pdi);
    
    // For backward compatibility, try the old way 
    if(S_OK != hr)
    {
        // build manage progid from policy/exit progid + "Manage"

        pszprogidPolicyManage = pcwszProgID;
        pszprogidPolicyManage += wszCERTMANAGE_SUFFIX;

        hr = CLSIDFromProgID(pszprogidPolicyManage, &clsidPolicyManage);
        _PrintIfError(hr, "CLSIDFromProgID");
        
        hr = ManageModule_Init(
            DISPSETUP_COMFIRST,
            pszprogidPolicyManage,
            &clsidPolicyManage,
            pdi);
        _JumpIfError(hr, Ret, "ManageModule_Init");        
    }

Ret:
    if(fRelease)
        Policy_Release(&di);
    return hr;
}

HRESULT GetExitManageDispatch(
    LPCWSTR pcwszProgID,
    REFCLSID clsidModule, 
    DISPATCHINTERFACE* pdi)
{
    HRESULT hr;
    DISPATCHINTERFACE di;
    bool fRelease = false;
    CString pszprogidExitManage;
    CLSID  clsidExitManage;

    hr = Exit_Init(
        DISPSETUP_COMFIRST,
        pcwszProgID,
        &clsidModule,
        &di);
    _JumpIfErrorStr(hr, Ret, "Policy_Init", pcwszProgID);

    fRelease = true;

    hr = Exit2_GetManageModule(
        &di,
        pdi);

    // For backward compatibility, try the old way 
    if(S_OK != hr)
    {
        // build manage progid from policy/exit progid + "Manage"

        pszprogidExitManage = pcwszProgID;
        pszprogidExitManage += wszCERTMANAGE_SUFFIX;

        hr = CLSIDFromProgID(pszprogidExitManage, &clsidExitManage);
        _PrintIfError(hr, "CLSIDFromProgID");
        
        hr = ManageModule_Init(
            DISPSETUP_COMFIRST,
            pszprogidExitManage,
            &clsidExitManage,
            pdi);
        _JumpIfError(hr, Ret, "ManageModule_Init");        
    }

Ret:
    if(fRelease)
        Exit_Release(&di);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\officer.h ===
//+--------------------------------------------------------------------------
// File:        officer.h
// Contents:    officer rights classes
//---------------------------------------------------------------------------
#include "sid.h"
#include "tptrlist.h"

namespace CertSrv
{

class CClientPermission
{
public:
    CClientPermission(BOOL fAllow, PSID pSid);
    ~CClientPermission() {}

    static BOOL IsInitialized(CClientPermission* pObj) 
    { 
        return  NULL != pObj &&
                NULL != ((PSID)pObj->m_Sid);
    }
    void SetPermission(BOOL fAllow) { m_fAllow = fAllow;}
    BOOL GetPermission() { return m_fAllow; }
    LPCWSTR GetName() { return m_Sid.GetName(); }
    PSID GetSid() { return m_Sid.GetSid(); }
    friend class COfficerRights;
    BOOL operator==(const CClientPermission& rhs)
    {
        return EqualSid(GetSid(), 
            (const_cast<CClientPermission&>(rhs)).GetSid());
    }

protected:
    BOOL m_fAllow;
    CSid m_Sid;
};

class COfficerRights
{
public:
    COfficerRights() : m_pSid(NULL), m_List() {}
   ~COfficerRights() { delete m_pSid; }

    HRESULT Init(PACCESS_ALLOWED_CALLBACK_ACE pAce);
    HRESULT Add(PSID pSID, BOOL fAllow);
    HRESULT RemoveAt(DWORD dwIndex)
    { 
        return m_List.RemoveAt(dwIndex)?S_OK:E_INVALIDARG; 
    }
    HRESULT SetAt(DWORD dwIndex, BOOL fAllow)
    { 
        CClientPermission *pClient = m_List.GetAt(dwIndex);
        if(!pClient)
            return E_INVALIDARG;
        pClient->SetPermission(fAllow);
        return S_OK;
    }
    CClientPermission* GetAt(DWORD dwIndex) 
    {
        return m_List.GetAt(dwIndex);
    }

    DWORD Find(PSID pSid);
    DWORD GetCount() { return m_List.GetCount(); }
    LPCWSTR GetName() { return m_pSid->GetName(); };
    PSID GetSid() { return m_pSid->GetSid(); }

    friend class COfficerRightsList;
    
protected:

    DWORD GetAceSize(BOOL fAllow);
    HRESULT AddAce(PACL pAcl, BOOL fAllow);
    HRESULT AddSidList(PACCESS_ALLOWED_CALLBACK_ACE pAce);

    void Cleanup() 
    {
        if (m_pSid)
        {
           delete m_pSid; 
           m_pSid=NULL; 
        }
        m_List.Cleanup();
    }
    // following bools are used to decide if this COfficerRights has to
    // be represented as one or two aces (allow/deny) in the ACL
    CSid* m_pSid; // use pointer instead of member object because
                  // we don't know the sid at construct time
    TPtrList<CClientPermission> m_List;
};

class COfficerRightsList
{
public:
    COfficerRightsList() : m_List(NULL), m_dwCountList(0) {}
   ~COfficerRightsList();

    HRESULT Load(PSECURITY_DESCRIPTOR pSD);
    HRESULT Save(PSECURITY_DESCRIPTOR &rpSD);
    COfficerRights* GetAt(DWORD dwIndex) 
    {
        if(dwIndex>=m_dwCountList)
            return NULL;
        return m_List[dwIndex];
    }

    DWORD GetCount() { return m_dwCountList;}

    void Dump();
    void Cleanup()
    {
        if (m_List != NULL)
        {
            for(DWORD dwCount=0;dwCount<m_dwCountList;dwCount++)
            {
                if (m_List[dwCount] != NULL) 
                    delete m_List[dwCount];
            }

            LocalFree(m_List); 
            m_List = NULL;
        }
        m_dwCountList = 0;
    }

protected:

    HRESULT BuildAcl(PACL &rpAcl);
    COfficerRights **m_List;
    DWORD m_dwCountList;
};

}; // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\roles.cpp ===
#include "stdafx.h"
#include "roles.h"
#include "csdisp.h" // certsrv picker

#define __dwFILE__	__dwFILE_CERTMMC_ROLES_CPP__


#ifdef _DEBUG
#undef THIS_FILE
#define THIS_FILE __FILE__
#endif

bool CRolesSupportInPropPage::RoleCanUseThisControl(int nID)
{
    DWORD dwCrtUserRoles = m_pCA->GetMyRoles();

    for(int i=0; i<m_nRoleMapEntries; i++)
    {
        if(nID==m_pRoleMap[i].nIDDlgItem)
            return (dwCrtUserRoles & m_pRoleMap[i].dwRoles)?true:false;
    }

    CSASSERT(0 && "Found a control with no matching role access defined");
    return false;
}

BOOL CRolesSupportInPropPage::EnableControl(HWND hwnd, int nID, BOOL bEnable)
{
    // If current user's roles don't allow it to use the control, disable it

    if(RoleCanUseThisControl(nID))
        return ::EnableWindow(GetDlgItem(hwnd, nID), bEnable);
    else
        return ::EnableWindow(GetDlgItem(hwnd, nID), FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snapin.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_COLUMN_NAME                 2
#define IDS_SIZE                        3
#define IDS_COLUMN_SIZE                 3
#define IDOK2                           3
#define IDS_TYPE                        4
#define IDS_COLUMN_TYPE                 4
#define IDS_NODENAME                    5
#define IDS_SNAPIN_DESC2                5
#define IDS_STRING6                     6
#define IDS_DESCRIPTION                 6
#define IDS_COMPANY			8
#define IDS_SCOPE_MYCOMPUTER            9
#define IDS_SCOPE_MYCOMPUTER_OVERRIDE   10
#define IDS_LOCALMACHINE                11
#define IDS_NODENAME_PREFIX             12
#define IDS_NODENAME_FORMAT             12
#define IDS_COLUMN_OTHER                13
#define IDS_COLUMN_DESCRIPTION          14
#define IDS_DESCR_CA                    15
#define IDS_DESCR_UNKNOWN               16
#define IDS_CERTS_REVOKED               17
#define IDS_CERTS_ISSUED                18
#define IDS_CERTS_PENDING               19
#define IDS_STATUSBAR_FILTER_APPLIED    20
#define IDS_STOPPED_SERVER_MSG          21
#define IDS_COLUMN_INCLUSION_ERROR      22
#define IDC_DUMP_ASN                    23
#define IDS_CONFIRM_CRL_PUBLISH         24
#define IDS_CRL_TITLE                   25
#define IDS_CONFIRM_REVOKE_CERT         26
#define IDS_REVOKE_CERT_TITLE           27
#define IDS_FILTER_NOT_SUPPORTED        28
#define IDS_FILTER_NOT_SUPPORTED2       29
#define IDS_CONFIRM_SERVICE_RESTART     29
#define IDS_COLUMNCHOOSER_FIELDNAME     30
#define IDS_COLUMNCHOOSER_OPERATOR      31
#define IDS_COLUMNCHOOSER_VALUE         32
#define IDS_COLUMNCHOOSER_ANDOR         33
#define IDS_AND                         34
#define IDS_CERTS_FAILED                35
#define IDS_CONFIRM_DENY_REQUEST        36
#define IDS_DENY_REQUEST_TITLE          37
#define IDS_PASSWORD_NOMATCH            38
#define IDS_PASSWORD_DIALOG             39
#define IDS_WARN_FILE_EXISTS            40
#define IDS_INSTALL_HIERARCHY_TITLE     40
#define IDS_SAVE_DIALOG_TITLE           41
#define IDS_COMPLETE_HIERARCHY_INSTALL_MSG 42
#define IDS_MODULE_INSTALL_TITLE        43
#define IDS_FILEDLG_DLL_FILTER          44
#define IDS_CHOOSEMODULE_POLICY_TITLE   45
#define IDS_CHOOSEMODULE_EXIT_TITLE     46
#define IDS_CANT_ACCESS_BACKUP_DIR      47
#define IDS_STATUSBAR_SORTEDBY_ASCEND   48
#define IDS_STATUSBAR_SORTEDBY_DESCEND  49
#define IDS_CA_REDISCOVER               50
#define IDS_STARTING_SVC                51
#define IDS_STOPPING_SVC                52
#define IDS_BACKUP_PROGRESS             53
#define IDS_INCREMENTAL_BACKUP          54
#define IDS_WIZ97TITLE_BACKUPWIZPG1     55
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG1  56
#define IDS_WIZ97TITLE_BACKUPWIZPG2     57
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG2  58
#define IDS_WIZ97TITLE_BACKUPWIZPG3     59
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG3  60
#define IDS_WIZ97TITLE_BACKUPWIZPG4     61
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG4  62
#define IDS_BACKUP_WIZARD               63
#define IDS_WIZ97TITLE_BACKUPWIZPG5     64
#define IDS_WIZ97SUBTITLE_BACKUPWIZPG5  65
#define IDS_TASKMENU_UNREVOKECERT       66
#define IDS_FILEDLG_PKCS12_FILTER       67
#define IDS_INCRRESTORE_RESTART_SERVER_WARNING 68
#define IDS_FILEDLG_PKCS12_DEFAULTEXTENSION 69
#define IDS_RESTORE_WIZARD              70
#define IDS_REQUIRE_ONE_SELECTION       71
#define IDS_MSG_DIRECTORY_TITLE         72
#define IDS_INVALID_DIRECTORY           73
#define IDS_WIZ97TITLE_RESTOREWIZPG1    74
#define IDS_WIZ97SUBTITLE_RESTOREWIZPG1 75
#define IDS_WIZ97TITLE_RESTOREWIZPG2    76
#define IDS_WIZ97SUBTITLE_RESTOREWIZPG2 77
#define IDS_WIZ97TITLE_RESTOREWIZPG3    78
#define IDS_WIZ97SUBTITLE_RESTOREWIZPG3 79
#define IDS_WIZ97TITLE_RESTOREWIZPG4    80
#define IDS_WIZ97SUBTITLE_RESTOREWIZPG4 81
#define IDS_ERR_RESTORE_OUT_OF_ORDER    82
#define IDS_DIR_CREATE                  83
#define IDS_SERVER_UNAVAILABLE          84
#define IDS_RESTORE_PROGRESS            85
#define IDS_POLICYMODULE_NOT_REGISTERED 86
#define IDS_EXITMODULE_NOT_REGISTERED   87
#define IDS_RETARGET_SNAPIN             88
#define IDS_STATUSBAR_RETARGET_SNAPIN   89
#define IDS_TASKMENU_STATUSBAR_UNREVOKECERT 90
#define IDS_STATUSBAR_ERRORTEMPLATE     91
#define IDS_ROLLOVER_REUSEKEYS          92
#define IDS_PFX_EXPORT_PRIVKEY_WARNING  93
#define IDS_RENEWAL_PROGRESS            94
#define IDS_CONFIRM_REMOVE_URL          95
#define IDS_CONFIRM_REMOVE_TITLE        96
#define IDD_RESTOREWIZ_COMPLETION       101
#define IDI_APPICON                     102
#define IDD_RENEW_REUSEKEYS             105
#define IDD_RESTOREWIZ_WELCOME          107
#define IDD_RESTOREWIZ_SELECT_DATA      108
#define IDD_RESTOREWIZ_SELECT_PASSWORD  109
#define IDS_CERTMMC_SNAPINNAME          110
#define IDS_CERTMMC_SNAPINNAMESTRING    111
#define IDS_UNREVOKE_FAILED             112
#define IDS_TOKEN_SERVERDNSNAME         130
#define IDS_TOKEN_SERVERSHORTNAME       131
#define IDS_TOKEN_SANITIZEDCANAME       132
#define IDS_TOKEN_CERTFILENAMESUFFIX    133
#define IDS_TOKEN_CONFIGDN              135
#define IDS_TOKEN_SANITIZEDCANAMEHASH   136
#define IDS_TOKEN_CRLFILENAMESUFFIX     137
#define IDS_TOKEN_CRLDELTAFILENAMESUFFIX 138
#define IDS_TOKEN_DSCRLATTRIBUTE        139
#define IDS_TOKEN_DSCACERTATTRIBUTE     140
#define IDS_CRL_REASON_UNSPECIFIED      150
#define IDS_CRL_REASON_KEY_COMPROMISE   151
#define IDS_CRL_REASON_CA_COMPROMISE    152
#define IDS_CRL_REASON_AFFILIATION_CHANGED 153
#define IDS_CRL_REASON_SUPERSEDED       154
#define IDS_CRL_REASON_CESSATION_OF_OPERATION 155
#define IDS_CRL_REASON_CERTIFICATE_HOLD 156
#define IDS_POSSIBLEERROR_NO_POLICY_MODULE 157
#define IDS_KEYANDCERT                  158
#define IDS_CALOGS                      160
#define IDS_STOP_SERVER_WARNING         161
#define IDS_START_SERVER_WARNING        162
#define IDS_TASKMENU_ROLLOVER           163
#define IDS_TASKMENU_STATUSBAR_ROLLOVER 164
#define IDS_CRL_REASON_REMOVE_FROM_CRL  165
#define IDS_TASKMENU_DUMPASN            166
#define IDS_TASKMENU_STATUSBAR_DUMPASN  167
#define IDS_TOKENDESC_SERVERDNSNAME     180
#define IDS_TOKENDESC_SERVERSHORTNAME   181
#define IDS_TOKENDESC_SANITIZEDCANAME   182
#define IDS_TOKENDESC_CERTFILENAMESUFFIX 183
#define IDS_TOKENDESC_CONFIGDN          185
#define IDS_TOKENDESC_SANITIZEDCANAMEHASH 186
#define IDS_TOKENDESC_CRLFILENAMESUFFIX 187
#define IDS_TOKENDESC_CRLDELTAFILENAMESUFFIX 188
#define IDS_TOKENDESC_DSCRLATTRIBUTE    189
#define IDS_TOKENDESC_DSCACERTATTRIBUTE 190
#define IDS_CA_CERT_LISTBOX_EXPIRED     191
#define IDS_CA_CERT_LISTBOX_REVOKED     192
#define IDS_INCLUDE_IN_OSCP_EXTENSION   193
#define IDS_PUBLISH_DELTAS_HERE         194
#define IDI_PRIVKEY                     232
#define IDD_VIEW_ATTREXT                234
#define IDD_CRL_VIEWPAGE                237
#define IDC_DISABLE_PUBLISH             267
#define IDC_DISABLE_DELTAPUBLISH        268
#define IDC_ENABLE_DELTAPUBLISH         268
#define IDC_CHECK_INCREMENTAL           269
#define IDC_DATEPICKER_NEWQUERY         270
#define IDC_TIMEPICKER_NEWQUERY         271
#define IDC_CHOOSER_MACHINE_OVERRIDE    271
#define IDC_EXIT_LIST                   272
#define IDC_LIST_EXTN                   273
#define IDC_LIST_ATTR                   274
#define IDC_RADIO_NEWBASE               275
#define IDC_RADIO_NEWDELTA              276
#define IDC_VALID_LASTPUBLISHED         277
#define IDC_CRL_VIEW_LIST_CRL           278
#define IDC_LIST_CERTS                  279
#define IDC_EXT_EXPLAIN                 280
#define IDC_LIST_KRA                    280
#define IDC_SERVERPUBLISH               281
#define IDC_KRA_ENABLE                  281
#define IDC_ADDTOCERTOCSP               282
#define IDC_KRA_ALL                     282
#define IDC_AUDIT_STARTSTOP             282
#define IDC_AUDIT_BACKUPRESTORE         283
#define IDC_KRA_DISABLE                 283
#define IDC_CHECK_BINARY_SAVETOFILE     283
#define IDC_DUMMY_SERVERPUBLISHDELTA    283
#define IDC_AUDIT_CERTIFICATE           284
#define IDC_RADIO_BINARY_VIEW           284
#define IDC_AUDIT_CRL                   285
#define IDC_RADIO_BINARY_SAVE           285
#define IDC_DELTA_EXPLANATION           285
#define IDC_AUDIT_CACERT                286
#define IDC_AUDIT_CASEC                 287
#define IDC_SPIN2                       287
#define IDC_AUDIT_KEYARCHIVAL           288
#define IDC_COMBO2                      288
#define IDC_AUDIT_CACONFIG              289
#define IDC_BUTTON_INSERTVAR            290
#define IDB_WIZ_HEAD                    321
#define IDB_WIZ                         322
#define IDB_CHECKLIST                   325
#define IDD_REVOCATION_DIALOG           326
#define IDD_NEW_RESTRICTION             328
#define IDD_BROWSEDIRECTORY             330
#define IDC_ACTIVE_MODULE               352
#define IDC_VERSION                     353
#define IDC_COPYRIGHT                   354
#define IDC_MODULENAME                  355
#define IDC_MODULE_LIST                 356
#define IDC_CHECK_SAVE_KEY              357
#define IDC_TEXT_BIGBOLD                358
#define IDC_BACKUP_KEYFILE              360
#define IDC_BACKUP_DBFILE               361
#define IDC_CONFIGURE                   362
#define IDC_BUTTON_UP                   363
#define IDC_COMBO_REASON                364
#define IDC_START_SERVICE_WARNING       365
#define IDS_PERIOD_YEARS                600
#define IDS_PERIOD_MONTHS               601
#define IDD_CRLWIZ_WELCOME              601
#define IDS_PERIOD_WEEKS                602
#define IDD_CRLWIZ_PUBLICATION_LOCATION 602
#define IDS_PERIOD_DAYS                 603
#define IDS_PERIOD_HOURS                604
#define IDS_PERIOD_MINUTES              605
#define IDS_PERIOD_SECONDS              606
#define IDD_GENERAL                     607
#define IDD_CRLWIZ_COMPLETION           607
#define IDD_EXTENSION_PAGE              608
#define IDD_CRLWIZ_VALIDITY_LENGTH      608
#define IDD_CERTSRV_PROPPAGE1           609
#define IDD_CERTSRV_PROPPAGE            610
#define IDD_CERTSRV_PROPPAGE2           610
#define IDS_POSITIVE_NUMBER             611
#define IDD_CERTSRV_PROPPAGE4           612
#define IDS_NO_EXIT_MODULE              612
#define IDD_CERTSRV_PROPPAGE5           613
#define IDD_CERTSRV_PROPPAGE3           614
#define IDD_CRL_PROPPAGE                615
#define IDC_CHOOSER_STATIC              616
#define IDD_ADDURL                      617
#define IDC_EDITURL                     618
#define IDS_VIEWMENU_ALL_RECORDS        650
#define IDS_VIEWMENU_STATUSBAR_ALL_RECORDS 651
#define IDS_VIEWMENU_FILTER             652
#define IDS_VIEWMENU_STATUSBAR_FILTER   653
#define IDS_EMPTY                       654
#define IDS_VIEWMENU_COLUMNS            655
#define IDS_VIEWMENU_STATUSBAR_COLUMNS  656
#define IDS_TASKMENU_STARTSERVICE       657
#define IDS_TASKMENU_STATUSBAR_STARTSERVICE 658
#define IDS_TASKMENU_STOPSERVICE        659
#define IDS_TASKMENU_STATUSBAR_STOPSERVICE 660
#define IDS_TASKMENU_PUBLISHCRL         661
#define IDS_TASKMENU_STATUSBAR_PUBLISHCRL 662
#define IDS_TASKMENU_VIEWCRL            663
#define IDS_TASKMENU_STATUSBAR_VIEWCRL  664
#define IDS_TASKMENU_REVOKECERT         665
#define IDS_TASKMENU_STATUSBAR_REVOKECERT 666
#define IDS_TASKMENU_RESUBMIT           667
#define IDS_TASKMENU_STATUSBAR_RESUBMIT 668
#define IDS_TASKMENU_DENYREQUEST        669
#define IDS_TASKMENU_STATUSBAR_DENYREQUEST 670
#define IDS_TASKMENU_BACKUP             671
#define IDS_TASKMENU_STATUSBAR_BACKUP   672
#define IDS_NEED_FILEPATH               673
#define IDS_BACKUPWIZ_TITLE             674
#define IDS_TOPMENU_OPEN                674
#define IDS_TASKMENU_RESTORE            675
#define IDS_TASKMENU_STATUSBAR_RESTORE  676
#define IDS_TASKMENU_INSTALL_CA         677
#define IDS_TASKMENU_STATUSBAR_INSTALL_CA 678
#define IDS_TOPMENU_STATUSBAR_OPEN      679
#define IDS_ERR_RESTORE_OVER_EXISTING_DATABASE 680
#define IDS_DIR_NOT_WRITEABLE           681
#define IDS_DIRECTORY_CONTENTS_UNEXPECTED 682
#define IDS_MUST_CHOOSE_MACHINE         683
#define IDC_NEW_FOLDER                  701
#define IDB_16x16                       702
#define IDC_EXT_STATIC                  702
#define IDC_ORGANIZATION                702
#define IDB_32x32                       703
#define IDC_EXT_TEXT                    703
#define IDC_ORGUNIT                     703
#define IDI_COMPUTER                    704
#define IDC_LOCALITY                    704
#define IDI_FOLDER                      705
#define IDC_CERTSRV_PROPPAGE_TAB1       705
#define IDC_STATE                       705
#define IDC_COUNTRY                     706
#define IDB_TOOLBAR1                    707
#define IDC_DESCRIPTION                 707
#define IDB_TOOLBAR2                    708
#define IDC_CANAME                      708
#define IDI_CERT                        709
#define IDC_COUNTRY2                    709
#define IDB_SMALLBMP                    710
#define IDC_COUNTRY3                    710
#define IDB_LARGE                       711
#define IDC_COUNTRY4                    711
#define IDC_CA_HIERARCHY                711
#define IDC_BUTTON_INSTALLCERT          712
#define FILEEX_MENU                     713
#define IDC_BUTTON_VIEWCERT             713
#define IDC_BUTTON_BACKUP               713
#define FOLDEREX_MENU                   714
#define IDC_RADIO_REUSEKEY              714
#define IDC_RADIO_NEWKEY                715
#define IDC_EDIT1                       716
#define IDC_EDIT_SHAREDFOLDER           716
#define IDC_EDIT_NEWQUERY_VALUE         716
#define IDC_RADIO_QUEUEVIEW             716
#define IDC_EDIT_EXTN                   716
#define IDC_EDIT_DELTACRLPERIODCOUNT    716
#define IDC_KRA_EDITCOUNT               716
#define IDC_EDIT_VARIABLEDESCRIPTION    716
#define IDC_BUTTON1                     717
#define IDC_ADD_MODULE                  717
#define IDC_RADIO_MANUALVIEW            717
#define IDC_ADD_RESTRICTION             717
#define IDC_URL_ADD                     717
#define IDC_CRL_VIEW_BTN_VIEWCRL        717
#define IDC_BUTTON4                     718
#define IDB_COMPUTER_LARGE              718
#define IDC_REMOVE_MODULE               718
#define IDI_NOICON                      718
#define IDC_INSTALL_MODULE              718
#define IDC_BUTTON_DN                   718
#define IDC_DELETE_RESTRICTION          718
#define IDC_EDIT_DELTASIZE              718
#define IDC_URL_REMOVE                  718
#define IDB_COMPUTER_SMALL              719
#define IDC_EDIT_CRLPERIODCOUNT         719
#define IDD_DEFINE_QUERY                719
#define IDC_BACKUP_CONFIGFILE           719
#define IDB_TOOLBAR_SVRMGR1             720
#define IDC_CRL_VIEW_BTN_VIEWDELTA      720
#define IDD_CERTSRV_PROPPAGE6           721
#define IDD_BACKUPWIZ_WELCOME           722
#define IDC_EDIT_UNITS                  723
#define IDD_BACKUPWIZ_SELECT_PASSWORD   723
#define IDC_CHECK1                      724
#define IDD_BACKUPWIZ_PUBLICATION_LOCATION 724
#define IDC_COMBO1                      725
#define IDD_BACKUPWIZ_COMPLETION        725
#define IDC_CHECK_SAVE_CONFIG           725
#define IDC_DELTA_COMBO                 725
#define IDC_EXT_SELECT                  725
#define IDC_COMBO_BINARY_COLUMN_CHOICE  725
#define IDC_COMBO_VARIABLE              725
#define IDC_CHECK2                      726
#define IDC_EDIT_NEWQUERY_OPERATION     726
#define IDD_CHOOSE_MODULE               726
#define IDC_CHECK_SAVE_DB               726
#define IDC_ADDTOCERTCDP                726
#define IDC_EDIT_NEWQUERY_ANDOR         727
#define IDD_BACKUPWIZ_SELECT_DATA       727
#define IDC_ADDTOFRESHESTCRL            727
#define IDC_COMBO_CRLPERIODSTRING       728
#define IDD_CHOOSE_COLUMNS_NEW          728
#define IDC_ADDTOCRLCDP                 728
#define IDC_CHECK3                      729
#define IDC_COMBO_DELTACRLPERIODSTRING  729
#define IDC_EDIT_LASTUPDATE             730
#define IDC_CSP_NAME                    731
#define IDC_EDIT_DELTALASTUPDATE        731
#define IDC_HASHALG                     732
#define IDC_EDIT_DATABASE_LOC           733
#define IDC_EDIT_LOG_LOC                734
#define IDC_QUERY_LIST                  737
#define IDC_EDIT_NEWQUERY_FIELD         739
#define IDC_RESET_BUTTON                740
#define IDC_LIST_AVAILABLE              742
#define IDC_LIST_SELECTED               743
#define IDC_KRA_ADD                     744
#define IDC_KRA_REMOVE                  745
#define IDC_KRA_VIEW                    746
#define IDC_RADIO_LOGVIEW               746
#define IDC_EDIT_KRAUSEDCOUNT           747
#define IDC_RADIO_FAILEDLOGVIEW         747
#define IDC_LIST_AVAILABLE_LABEL        748
#define IDC_LIST_SELECTED_LABEL         749
#define IDC_VIEW_CRL                    750
#define IDC_VIEW_CERT                   751
#define IDC_VIEW_DELTACRL               751
#define IDC_EDIT_BACKUP_PATH            752
#define IDC_NEW_PASSWORD                753
#define IDC_VIEW_CERT2                  753
#define IDC_CONFIRM_PASSWORD            754
#define IDC_BROWSE                      755
#define IDS_TASKMENU_REQUEST_CA         756
#define IDS_TASKMENU_STATUSBAR_REQUEST_CA 757
#define IDS_ICMM_GETNAMEPROPERTY_FAILED 758
#define IDD_CHOOSER_CHOOSE_MACHINE      759
#define IDC_CHOOSER_GROUP_TARGET_MACHINE 761
#define IDD_ATTR_PROPPAGE               761
#define IDC_CHOOSER_RADIO_LOCAL_MACHINE 762
#define IDD_EXTN_PROPPAGE               762
#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE 763
#define IDD_CHOOSE_PUBLISHCRL           763
#define IDC_CHOOSER_EDIT_MACHINE_NAME   764
#define IDD_CERTSRV_PROPPAGE_CHOOSE_KRA 764
#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES 765
#define IDD_CERTSRV_PROPPAGE7           765
#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME 766
#define IDD_CHOOSE_BINARY_COLUMN        766
#define IDS_CHOOSER_INVALID_COMPUTERNAME 767
#define IDS_EXT_CDP                     768
#define IDS_EXT_AIA                     769
#define IDS_EXT_CDP_EXPLAIN             770
#define IDS_EXT_AIA_EXPLAIN             771
#define IDS_INVALID_PREFIX              772
#define IDS_INVALID_TOKEN               773
#define IDS_INVALID_ENCODING            774
#define IDS_EMPTY_URL                   775
#define IDD_CERTMANAGERS_PROPPAGE       776
#define IDC_ADDSUBJECT                  777
#define IDC_REMOVESUBJECT               778
#define IDS_SAME_URL_EXIST              779
#define IDC_LIST_SUBJECTS               781
#define IDC_LIST_CERTMANAGERS           782
#define IDS_VIEW_CERT_DENY_ERROR        783
#define IDS_VIEW_CERT_NOT_RUNNING       784
#define IDS_KRA_ADD_TITLE               785
#define IDS_KRA_ADD_SUBTITLE            786
#define IDC_ALLOWDENY                   787
#define IDS_TASKMENU_SUBMITREQUEST      791
#define IDS_TASKMENU_STATUSBAR_SUBMITREQUEST 792
#define IDC_RADIO_ENABLEOFFICERS        793
#define IDC_RADIO_DISABLEOFFICERS       794
#define IDC_CHECK_KEYCERT               1005
#define IDC_EDIT_KEYCERT                1006
#define IDC_EDIT_PASSWORD               1006
#define IDC_BROWSE_KEYCERT              1007
#define IDC_LIST2                       1009
#define IDC_COMPLETION_LIST             1009
#define IDC_CRL_VIEW_LIST_DELTA         1009
#define IDC_EDIT_CONFIG                 1012
#define IDC_BROWSE_CONFIG               1013
#define IDC_CHECK_LOGS                  1014
#define IDC_EDIT_LOGS                   1015
#define IDC_BROWSE_LOGS                 1016
#define IDC_URL_LIST                    1017
#define IDS_INH_ALL                     1250
#define IDS_INH_CONTAINER               1251
#define IDS_INH_OBJECT                  1252
#define IDS_INH_NONE                    1253
#define IDS_LARGEFONTNAME               2000
#define IDS_SMALLFONTNAME               2001
#define IDS_SMALLFONTSIZE               2002
#define IDS_FONTSIZE                    2003
#define IDS_LARGEFONTSIZE               2004
#define IDS_STARTMENU_CERTMMC_LINKNAME  2005
#define IDS_STARTMENU_CERTMMC_DESCRIPTION 2006
#define IDS_LISTCOL_TAG                 2007
#define IDS_LISTCOL_VALUE               2008
#define IDS_TASKMENU_VIEWATTREXT        2009
#define IDS_TASKMENU_STATUSBAR_VIEWATTREXT 2010
#define IDS_LISTCOL_FLAGS               2011
#define IDS_LISTCOL_ORGIN               2011
#define IDS_UNKNOWN_EXTENSION           2012
#define IDS_CERT_PROP_CAPTION           2013
#define IDS_LISTCOL_CRITICAL            2014
#define IDS_LISTCOL_ENABLED             2015
#define IDS_CRL_LISTCOL_INDEX           2016
#define IDS_LISTCOL_EFFECTIVE_DATE      2017
#define IDS_LISTCOL_EXPIRATION_DATE     2018
#define IDS_LISTCOL_PUBLISH_STATUS      2019
#define IDS_YES                         2020
#define IDS_NO                          2021
#define IDS_EXT_ORIGIN_REQUEST          2022
#define IDS_EXT_ORIGIN_POLICY           2023
#define IDS_EXT_ORIGIN_ADMIN            2024
#define IDS_EXT_ORIGIN_SERVER           2025
#define IDS_EXT_ORIGIN_RENEWAL          2026
#define IDS_EXT_ORIGIN_IMPORTED_CERT    2027
#define IDS_EXT_ORIGIN_PKCS7            2028
#define IDS_EXT_ORIGIN_UNKNOWN          2029
#define IDS_LISTCOL_SUBJECT             2030
#define IDS_LISTCOL_ISSUER              2031
#define IDS_CA_CERT_LISTBOX             2032
#define IDS_LIST_NAME                   2033
#define IDS_BINARYFILE_OUTPUT_TITLE     2034
#define IDS_BINARYFILE_OUTPUT_FILTER    2035
#define IDS_KRA_COUNT_TOO_BIG           2036
#define IDS_KRA_NOKRADEFINED            2037
#define IDS_BUTTONTEXT_ALLOW            2038
#define IDS_BUTTONTEXT_DENY             2039
#define IDS_LIST_ACCESS                 2040
#define IDS_TEXT_ALLOW                  2041
#define IDS_TEXT_DENY                   2042
#define IDS_LISTCOL_STATUS              2043
#define IDS_DISPOSITION_EXPIRED         2044
#define IDS_DISPOSITION_NOTFOUND        2045
#define IDS_DISPOSITION_REVOKED         2046
#define IDS_DISPOSITION_VALID           2047
#define IDS_DISPOSITION_INVALID         2048
#define IDS_DISPOSITION_UNTRUSTED       2049
#define IDS_DISPOSITION_NOTLOADED       2050
#define IDS_CRLPUBLISHSTATUS_OK         2051
#define IDS_CRLPUBLISHSTATUS_FAILED     2052
#define IDS_CRLPUBLISHSTATUS_UNKNOWN    2053
#define IDS_KRA_CANNOT_OPEN_STORE       2054
#define IDS_OLD_CA                      2055
#define IDS_CERTS_IMPORTED              2056
#define IDS_W2K_UPGRADE_DETECTED_TITLE  2057
#define IDS_CONFIRM_W2K_SECURITY_UPGRADE 2058
#define IDS_BLOCK_W2K_SECURITY_UPGRADE  2059
#define IDS_W2K_SECURITY_UPGRADE_DESCR  2060
#define IDS_CDP_INCLUDE_INSTRUCTIONS    2061
#define IDS_AIA_INCLUDE_INSTRUCTIONS    2062
#define IDS_WARN_START_STOP_PERFORMANCE 2063
#define IDS_CANNOT_OPEN_CERT_SERVICES   2064
#define IDS_DATA_UNAVAILABLE            2065
#define IDC_UNAVAILABLE                 2066
#define IDC_MGR_STATIC                  2067
#define IDC_LIST_STATIC                 2068
#define IDC_DO_STATIC                   2069
#define IDC_NUM_STATIC                  2070
#define IDS_CANNOT_UPDATE_SECURITY_ON_CA 2071
#define IDS_WARN_INVALID_KRAS           2072
#define IDS_CRLSTATE_REVOKED            2073
#define IDS_CRLERROR_FORMAT             2074
#define IDS_EXT_ORIGIN_CMC              2075
#define IDS_EXT_ORIGIN_CACERT           2076

#define IDC_TEXT_BOLD                   65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        240
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         290
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\officer.cpp ===
//+--------------------------------------------------------------------------
// File:        officer.cpp
// Contents:    officer rights implementation
//---------------------------------------------------------------------------
#include <stdafx.h>
#include "officer.h"
#include "certsd.h"

#define __dwFILE__	__dwFILE_CERTMMC_OFFICER_CPP__


using namespace CertSrv;

static const DEFAULT_USERNAME_SIZE = 256;

CClientPermission::CClientPermission(BOOL fAllow, PSID pSid) :
    m_fAllow(fAllow),
    m_Sid(pSid)
{}

HRESULT COfficerRights::Add(PSID pSid, BOOL fAllow)
{
    HRESULT hr = S_OK;
    CClientPermission* pClient = new CClientPermission(fAllow, pSid);

    if(!CClientPermission::IsInitialized(pClient) ||
       !m_List.AddTail(pClient))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "");
    }

error:
    if(S_OK!=hr)
        delete pClient;
    return hr;
}

HRESULT COfficerRights::Init(PACCESS_ALLOWED_CALLBACK_ACE pAce)
{
    HRESULT hr = S_OK;
    
    // no object reuse
    CSASSERT(!m_pSid);
    CSASSERT(m_List.IsEmpty());

    CSASSERT(IsValidSid((PSID)(&pAce->SidStart)));
    m_pSid = new CSid((PSID)(&pAce->SidStart));
    if(!m_pSid)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "new CSid");
    }

    hr = AddSidList(pAce);
    _JumpIfError(hr, error, "COfficerRights::AddSidList");

error:
    if(S_OK!=hr)
    {
        Cleanup();
    }
    return hr;
}

HRESULT COfficerRights::AddSidList(PACCESS_ALLOWED_CALLBACK_ACE pAce)
{
    HRESULT hr = S_OK;
    PSID pSid;
    DWORD cSids;
    PSID_LIST pSidList = (PSID_LIST) (((BYTE*)&pAce->SidStart)+
                    GetLengthSid(&pAce->SidStart));

    CSASSERT(EqualSid((PSID)&pAce->SidStart, GetSid()));
    
    for(pSid=(PSID)&pSidList->SidListStart, cSids=0; 
        cSids<pSidList->dwSidCount;
        cSids++, pSid = (PSID)(((BYTE*)pSid)+GetLengthSid(pSid)))
    {
        hr = Add(pSid, ACCESS_ALLOWED_CALLBACK_ACE_TYPE==pAce->Header.AceType);
        _JumpIfError(hr, error, "COfficerRights::Add");
    }

error:
    return hr;
}

COfficerRightsList::~COfficerRightsList()
{ 
    Cleanup();
}


HRESULT COfficerRightsList::Load(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    PACL pAcl; // no free
    ACL_SIZE_INFORMATION AclInfo;
    PACCESS_ALLOWED_CALLBACK_ACE pAce;
    DWORD cAce;
    COfficerRights *pOfficerRights = NULL;
    DWORD cList;
    COfficerRights* pExistingOfficer;
        
    CSASSERT(IsValidSecurityDescriptor(pSD));

    hr = myGetSecurityDescriptorDacl(pSD, &pAcl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    if(!GetAclInformation(pAcl,
                          &AclInfo,
                          sizeof(AclInfo),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    m_dwCountList = 0;

    m_List = (COfficerRights **)LocalAlloc(LMEM_FIXED, 
                sizeof(COfficerRights*)*AclInfo.AceCount);
    if(!m_List)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    ZeroMemory(m_List, sizeof(COfficerRights*)*AclInfo.AceCount);

    for(cAce=0; cAce<AclInfo.AceCount; cAce++)
    {
        pExistingOfficer = NULL;

        if(!GetAce(pAcl, cAce, (PVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        CSASSERT(
            ACCESS_ALLOWED_CALLBACK_ACE_TYPE == pAce->Header.AceType ||
            ACCESS_DENIED_CALLBACK_ACE_TYPE  == pAce->Header.AceType);

        // Detect if another object already exists for this officer; if so, we
        // will add the client list to it instead of creating a new object
        // Assuming denied aces always come before allow aces, we can limit
        // the search to allow type
        if(ACCESS_ALLOWED_CALLBACK_ACE_TYPE==pAce->Header.AceType)
        {
            for(cList=0; cList<m_dwCountList; cList++)
            {
                if(EqualSid(m_List[cList]->GetSid(), 
                            (PSID)&pAce->SidStart))
                {
                    pExistingOfficer = m_List[cList];
                    break;
                }
            }
        }

        if(pExistingOfficer)
        {
            // add SID list stored in this ace to existing officer object
            hr = pExistingOfficer->AddSidList(pAce);
            _JumpIfError(hr, error, "COfficerRights::AddSidList");
        }
        else
        {
            // create new officer object
            pOfficerRights = new COfficerRights;
            if(!pOfficerRights)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "new COfficerRights");
            }

            hr = pOfficerRights->Init(pAce);
            _JumpIfError(hr, error, "COfficerRights::Init");

            m_List[m_dwCountList] = pOfficerRights;
            pOfficerRights = NULL;
            m_dwCountList++;
        }
    }

error:
    if(S_OK!=hr && m_List)
    {
        if(m_List)
        {
            LocalFree(m_List);
            m_List = NULL;
        }
        if(pOfficerRights)
        {
            delete pOfficerRights;
        }
    }
    return hr;
}

HRESULT COfficerRightsList::Save(PSECURITY_DESCRIPTOR &rpSD)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSD = NULL, pSDSelfRelative = NULL;
    DWORD dwSelfRelativeSize = 0;
    PSID pSidBuiltinAdministrators = NULL;
    PACL pAcl = NULL;

    rpSD = NULL;
    
    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED,
                                      SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (!pSD)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
#ifdef _DEBUG
    ZeroMemory(pSD, SECURITY_DESCRIPTOR_MIN_LENGTH);
#endif 

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    hr = GetBuiltinAdministratorsSID(&pSidBuiltinAdministrators);
    _JumpIfError(hr, error, "GetBuiltinAdministratorsSID");
    
    if(!SetSecurityDescriptorOwner(
        pSD,
        pSidBuiltinAdministrators,
        FALSE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    hr = BuildAcl(pAcl);
    _JumpIfError(hr, error, "BuildAcl");

    if(!SetSecurityDescriptorDacl(
        pSD,
        TRUE, // DACL present
        pAcl,
        FALSE)) // DACL defaulted
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    CSASSERT(IsValidSecurityDescriptor(pSD));

    MakeSelfRelativeSD(pSD, NULL, &dwSelfRelativeSize);
    if(ERROR_INSUFFICIENT_BUFFER!=GetLastError())
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    pSDSelfRelative = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSelfRelativeSize);
    if(!pSDSelfRelative)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSelfRelativeSize))
    {
        hr = myHLastError();
        _JumpError(hr, error, "MakeSelfRelativeSD");
    }

    rpSD = pSDSelfRelative;

error:
    if(pAcl)
    {
        LocalFree(pAcl);
    }
    if(pSD)
    {
        LocalFree(pSD);
    }
    if(pSidBuiltinAdministrators)
    {
        LocalFree(pSidBuiltinAdministrators);
    }
    return hr;
}

HRESULT COfficerRightsList::BuildAcl(PACL &rpAcl)
{
    HRESULT hr = S_OK;
    DWORD dwAclSize = sizeof(ACL);
    DWORD cRights;
    PACL pAcl = NULL;

    rpAcl = NULL;

    // calculate total acl size by adding the space required
    // for the ACEs resulting from each COfficerRights
    for(cRights=0;cRights<m_dwCountList;cRights++)
    {
        dwAclSize += m_List[cRights]->GetAceSize(FALSE);
        dwAclSize += m_List[cRights]->GetAceSize(TRUE);
    }

    pAcl = (PACL)LocalAlloc(LMEM_FIXED, dwAclSize);
    if(!pAcl)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
#ifdef _DEBUG
    ZeroMemory(pAcl, dwAclSize);
#endif

    if(!InitializeAcl(pAcl, dwAclSize, ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    // add deny aces first
    for(cRights=0;cRights<m_dwCountList;cRights++)
    {
        hr = m_List[cRights]->AddAce(pAcl, FALSE);
        _JumpIfError(hr, error, "COfficerRights::AddAce");
    }

    // then add allow aces
    for(cRights=0;cRights<m_dwCountList;cRights++)
    {
        hr = m_List[cRights]->AddAce(pAcl, TRUE);
        _JumpIfError(hr, error, "COfficerRights::AddAce");
    }
    
    CSASSERT(IsValidAcl(pAcl));

    rpAcl = pAcl;

error:

    if(S_OK!=hr)
    {
        if(pAcl)
        {
            LocalFree(pAcl);
        }
    }
    return hr;
}

DWORD COfficerRights::GetAceSize(BOOL fAllow)
{
    DWORD dwAceSize = sizeof(ACCESS_ALLOWED_CALLBACK_ACE);
    dwAceSize += GetLengthSid(m_pSid->GetSid());
    BOOL fFound = FALSE;

    TPtrListEnum<CClientPermission> CPEnum(m_List);
    CClientPermission *pCP;

    for(pCP=CPEnum.Next();pCP;pCP=CPEnum.Next())
    {
        if(pCP->GetPermission()==fAllow)
        {
            dwAceSize += GetLengthSid(pCP->GetSid());
            fFound = TRUE;
        }
    }

    return fFound?dwAceSize:0;
}

HRESULT COfficerRights::AddAce(PACL pAcl, BOOL fAllow)
{
    HRESULT hr = S_OK;
    PACCESS_ALLOWED_CALLBACK_ACE pAce = NULL;
    DWORD dwAceSize = GetAceSize(fAllow);
    DWORD dwSidSize = GetLengthSid(m_pSid->GetSid());
    DWORD dwClientSidSize;
    PSID_LIST pSidList;
    PSID pClientSid;
    TPtrListEnum<CClientPermission> CPEnum(m_List);
    CClientPermission *pCP;
    BOOL fFound = FALSE;
    DWORD dwSidCount = 0;

    if(dwAceSize)
    {
        pAce = (PACCESS_ALLOWED_CALLBACK_ACE) LocalAlloc(LMEM_FIXED, dwAceSize);
        if(!pAce)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

    #ifdef _DEBUG
            ZeroMemory(pAce, dwAceSize);
    #endif 

        pAce->Header.AceType = (BYTE) (fAllow?
			    ACCESS_ALLOWED_CALLBACK_ACE_TYPE:
			    ACCESS_DENIED_CALLBACK_ACE_TYPE);
        pAce->Header.AceFlags= 0;
        pAce->Header.AceSize = (USHORT)dwAceSize;
        pAce->Mask = DELETE;

        CopySid(dwSidSize,
            (PSID)&pAce->SidStart,
            m_pSid->GetSid());
        pSidList = (PSID_LIST)(((BYTE*)&pAce->SidStart)+dwSidSize);
        pSidList->dwSidCount = m_List.GetCount();
        pClientSid = (PSID)&pSidList->SidListStart;
        for(pCP=CPEnum.Next(); pCP; pCP=CPEnum.Next())
        {
            if(pCP->GetPermission()==fAllow)
            {
                dwClientSidSize = GetLengthSid(pCP->GetSid());
                CopySid(dwClientSidSize,
                    pClientSid,
                    pCP->GetSid());
                pClientSid = (((BYTE*)pClientSid)+dwClientSidSize);
                fFound = TRUE;
                dwSidCount++;
            }
        }
        pSidList->dwSidCount = dwSidCount;
        
        CSASSERT(pClientSid==((BYTE*)pAce)+dwAceSize);

        if(fFound)
        {
            if(!::AddAce(
                pAcl,
                ACL_REVISION,
                MAXDWORD,
                pAce,
                dwAceSize))
            {
                hr = myHLastError();
                _JumpError(hr, error, "AddAce");
            }
        }
    }

error:
    if(pAce)
    {
        LocalFree(pAce);
    }
    return hr;
}

void COfficerRightsList::Dump()
{
    DBGPRINT((DBG_SS_INFO, "Officers: %d\n", m_dwCountList));
    wprintf(L"Officers: %d\n", m_dwCountList);
    for(DWORD dwCount=0;dwCount<m_dwCountList;dwCount++)
    {
        COfficerRights *pOR = GetAt(dwCount);
        wprintf(L"Officer %ws, %d clients\n", pOR->GetName(), pOR->GetCount());
        for(DWORD c=0;c<pOR->GetCount();c++)
        {
            CClientPermission *pCli = pOR->GetAt(c);
            wprintf(L"\tClient %ws, %ws\n", pCli->GetName(), pCli->GetPermission()?L"allow":L"deny");
        }
    }
}

// Searches the list for an object with this SID; if found returns
// object index, if not found, returns DWORD_MAX
DWORD COfficerRights::Find(PSID pSid)
{
    CClientPermission perm(TRUE, pSid);
    return m_List.FindIndex(perm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\roles.h ===
#ifndef __ROLES_H_INCLUDED__
#define __ROLES_H_INCLUDED__

using namespace CertSrv;

typedef struct tagRoleAccessToControls
{
    int nIDDlgItem; // control ID
    DWORD dwRoles; // roles allowed to use this control

} RoleAccessToControl;

class CRolesSupportInPropPage
{
public:
    CRolesSupportInPropPage(
        CertSvrCA *pCA,
        RoleAccessToControl *pRoleMap,
        int nRoleMap) : 
      m_pCA(pCA),
      m_pRoleMap(pRoleMap), 
      m_nRoleMapEntries(nRoleMap) {}
    ~CRolesSupportInPropPage() {}
        
    bool RoleCanUseThisControl(int nID);
    BOOL EnableControl(HWND hwnd, int nID, BOOL bEnable);

    CertSvrCA* m_pCA;

private:

    RoleAccessToControl *m_pRoleMap;
    int m_nRoleMapEntries;

}; // CRolesSupportInPropPage

#endif // __ROLES_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_SNAPIN_DESC),
    RESSTR(IDS_NAME),
    RESSTR(IDS_COLUMN_NAME),
    RESSTR(IDS_SIZE),
    RESSTR(IDS_COLUMN_SIZE),
    RESSTR(IDS_TYPE),
    RESSTR(IDS_COLUMN_TYPE),
    RESSTR(IDS_NODENAME),
    RESSTR(IDS_SNAPIN_DESC2),
    RESSTR(IDS_STRING6),
    RESSTR(IDS_DESCRIPTION),
    RESSTR(IDS_COMPANY),
    RESSTR(IDS_SCOPE_MYCOMPUTER),
    RESSTR(IDS_SCOPE_MYCOMPUTER_OVERRIDE),
    RESSTR(IDS_LOCALMACHINE),
    RESSTR(IDS_NODENAME_PREFIX),
    RESSTR(IDS_NODENAME_FORMAT),
    RESSTR(IDS_COLUMN_OTHER),
    RESSTR(IDS_COLUMN_DESCRIPTION),
    RESSTR(IDS_DESCR_CA),
    RESSTR(IDS_DESCR_UNKNOWN),
    RESSTR(IDS_CERTS_REVOKED),
    RESSTR(IDS_CERTS_ISSUED),
    RESSTR(IDS_CERTS_PENDING),
    RESSTR(IDS_STATUSBAR_FILTER_APPLIED),
    RESSTR(IDS_STOPPED_SERVER_MSG),
    RESSTR(IDS_COLUMN_INCLUSION_ERROR),
    RESSTR(IDS_CONFIRM_CRL_PUBLISH),
    RESSTR(IDS_CRL_TITLE),
    RESSTR(IDS_CONFIRM_REVOKE_CERT),
    RESSTR(IDS_REVOKE_CERT_TITLE),
    RESSTR(IDS_FILTER_NOT_SUPPORTED),
    RESSTR(IDS_FILTER_NOT_SUPPORTED2),
    RESSTR(IDS_CONFIRM_SERVICE_RESTART),
    RESSTR(IDS_COLUMNCHOOSER_FIELDNAME),
    RESSTR(IDS_COLUMNCHOOSER_OPERATOR),
    RESSTR(IDS_COLUMNCHOOSER_VALUE),
    RESSTR(IDS_COLUMNCHOOSER_ANDOR),
    RESSTR(IDS_AND),
    RESSTR(IDS_CERTS_FAILED),
    RESSTR(IDS_CONFIRM_DENY_REQUEST),
    RESSTR(IDS_DENY_REQUEST_TITLE),
    RESSTR(IDS_PASSWORD_NOMATCH),
    RESSTR(IDS_PASSWORD_DIALOG),
    RESSTR(IDS_WARN_FILE_EXISTS),
    RESSTR(IDS_INSTALL_HIERARCHY_TITLE),
    RESSTR(IDS_SAVE_DIALOG_TITLE),
    RESSTR(IDS_COMPLETE_HIERARCHY_INSTALL_MSG),
    RESSTR(IDS_MODULE_INSTALL_TITLE),
    RESSTR(IDS_FILEDLG_DLL_FILTER),
    RESSTR(IDS_CHOOSEMODULE_POLICY_TITLE),
    RESSTR(IDS_CHOOSEMODULE_EXIT_TITLE),
    RESSTR(IDS_CANT_ACCESS_BACKUP_DIR),
    RESSTR(IDS_STATUSBAR_SORTEDBY_ASCEND),
    RESSTR(IDS_STATUSBAR_SORTEDBY_DESCEND),
    RESSTR(IDS_CA_REDISCOVER),
    RESSTR(IDS_STARTING_SVC),
    RESSTR(IDS_STOPPING_SVC),
    RESSTR(IDS_BACKUP_PROGRESS),
    RESSTR(IDS_INCREMENTAL_BACKUP),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG1),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG1),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG2),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG2),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG3),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG3),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG4),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG4),
    RESSTR(IDS_BACKUP_WIZARD),
    RESSTR(IDS_WIZ97TITLE_BACKUPWIZPG5),
    RESSTR(IDS_WIZ97SUBTITLE_BACKUPWIZPG5),
    RESSTR(IDS_TASKMENU_UNREVOKECERT),
    RESSTR(IDS_FILEDLG_PKCS12_FILTER),
    RESSTR(IDS_INCRRESTORE_RESTART_SERVER_WARNING),
    RESSTR(IDS_FILEDLG_PKCS12_DEFAULTEXTENSION),
    RESSTR(IDS_RESTORE_WIZARD),
    RESSTR(IDS_REQUIRE_ONE_SELECTION),
    RESSTR(IDS_MSG_DIRECTORY_TITLE),
    RESSTR(IDS_INVALID_DIRECTORY),
    RESSTR(IDS_WIZ97TITLE_RESTOREWIZPG1),
    RESSTR(IDS_WIZ97SUBTITLE_RESTOREWIZPG1),
    RESSTR(IDS_WIZ97TITLE_RESTOREWIZPG2),
    RESSTR(IDS_WIZ97SUBTITLE_RESTOREWIZPG2),
    RESSTR(IDS_WIZ97TITLE_RESTOREWIZPG3),
    RESSTR(IDS_WIZ97SUBTITLE_RESTOREWIZPG3),
    RESSTR(IDS_WIZ97TITLE_RESTOREWIZPG4),
    RESSTR(IDS_WIZ97SUBTITLE_RESTOREWIZPG4),
    RESSTR(IDS_ERR_RESTORE_OUT_OF_ORDER),
    RESSTR(IDS_DIR_CREATE),
    RESSTR(IDS_SERVER_UNAVAILABLE),
    RESSTR(IDS_RESTORE_PROGRESS),
    RESSTR(IDS_POLICYMODULE_NOT_REGISTERED),
    RESSTR(IDS_EXITMODULE_NOT_REGISTERED),
    RESSTR(IDS_RETARGET_SNAPIN),
    RESSTR(IDS_STATUSBAR_RETARGET_SNAPIN),
    RESSTR(IDS_TASKMENU_STATUSBAR_UNREVOKECERT),
    RESSTR(IDS_STATUSBAR_ERRORTEMPLATE),
    RESSTR(IDS_ROLLOVER_REUSEKEYS),
    RESSTR(IDS_PFX_EXPORT_PRIVKEY_WARNING),
    RESSTR(IDS_RENEWAL_PROGRESS),
    RESSTR(IDS_CONFIRM_REMOVE_URL),
    RESSTR(IDS_CONFIRM_REMOVE_TITLE),
    RESSTR(IDS_CERTMMC_SNAPINNAME),
    RESSTR(IDS_CERTMMC_SNAPINNAMESTRING),
    RESSTR(IDS_UNREVOKE_FAILED),
    RESSTR(IDS_TOKEN_SERVERDNSNAME),
    RESSTR(IDS_TOKEN_SERVERSHORTNAME),
    RESSTR(IDS_TOKEN_SANITIZEDCANAME),
    RESSTR(IDS_TOKEN_CERTFILENAMESUFFIX),
    RESSTR(IDS_TOKEN_CONFIGDN),
    RESSTR(IDS_TOKEN_SANITIZEDCANAMEHASH),
    RESSTR(IDS_TOKEN_CRLFILENAMESUFFIX),
    RESSTR(IDS_TOKEN_CRLDELTAFILENAMESUFFIX),
    RESSTR(IDS_TOKEN_DSCRLATTRIBUTE),
    RESSTR(IDS_TOKEN_DSCACERTATTRIBUTE),
    RESSTR(IDS_CRL_REASON_UNSPECIFIED),
    RESSTR(IDS_CRL_REASON_KEY_COMPROMISE),
    RESSTR(IDS_CRL_REASON_CA_COMPROMISE),
    RESSTR(IDS_CRL_REASON_AFFILIATION_CHANGED),
    RESSTR(IDS_CRL_REASON_SUPERSEDED),
    RESSTR(IDS_CRL_REASON_CESSATION_OF_OPERATION),
    RESSTR(IDS_CRL_REASON_CERTIFICATE_HOLD),
    RESSTR(IDS_POSSIBLEERROR_NO_POLICY_MODULE),
    RESSTR(IDS_KEYANDCERT),
    RESSTR(IDS_CALOGS),
    RESSTR(IDS_STOP_SERVER_WARNING),
    RESSTR(IDS_START_SERVER_WARNING),
    RESSTR(IDS_TASKMENU_ROLLOVER),
    RESSTR(IDS_TASKMENU_STATUSBAR_ROLLOVER),
    RESSTR(IDS_CRL_REASON_REMOVE_FROM_CRL),
    RESSTR(IDS_TASKMENU_DUMPASN),
    RESSTR(IDS_TASKMENU_STATUSBAR_DUMPASN),
    RESSTR(IDS_TOKENDESC_SERVERDNSNAME),
    RESSTR(IDS_TOKENDESC_SERVERSHORTNAME),
    RESSTR(IDS_TOKENDESC_SANITIZEDCANAME),
    RESSTR(IDS_TOKENDESC_CERTFILENAMESUFFIX),
    RESSTR(IDS_TOKENDESC_CONFIGDN),
    RESSTR(IDS_TOKENDESC_SANITIZEDCANAMEHASH),
    RESSTR(IDS_TOKENDESC_CRLFILENAMESUFFIX),
    RESSTR(IDS_TOKENDESC_CRLDELTAFILENAMESUFFIX),
    RESSTR(IDS_TOKENDESC_DSCRLATTRIBUTE),
    RESSTR(IDS_TOKENDESC_DSCACERTATTRIBUTE),
    RESSTR(IDS_CA_CERT_LISTBOX_EXPIRED),
    RESSTR(IDS_CA_CERT_LISTBOX_REVOKED),
    RESSTR(IDS_INCLUDE_IN_OSCP_EXTENSION),
    RESSTR(IDS_PUBLISH_DELTAS_HERE),
    RESSTR(IDS_PERIOD_YEARS),
    RESSTR(IDS_PERIOD_MONTHS),
    RESSTR(IDS_PERIOD_WEEKS),
    RESSTR(IDS_PERIOD_DAYS),
    RESSTR(IDS_PERIOD_HOURS),
    RESSTR(IDS_PERIOD_MINUTES),
    RESSTR(IDS_PERIOD_SECONDS),
    RESSTR(IDS_POSITIVE_NUMBER),
    RESSTR(IDS_NO_EXIT_MODULE),
    RESSTR(IDS_VIEWMENU_ALL_RECORDS),
    RESSTR(IDS_VIEWMENU_STATUSBAR_ALL_RECORDS),
    RESSTR(IDS_VIEWMENU_FILTER),
    RESSTR(IDS_VIEWMENU_STATUSBAR_FILTER),
    RESSTR(IDS_EMPTY),
    RESSTR(IDS_VIEWMENU_COLUMNS),
    RESSTR(IDS_VIEWMENU_STATUSBAR_COLUMNS),
    RESSTR(IDS_TASKMENU_STARTSERVICE),
    RESSTR(IDS_TASKMENU_STATUSBAR_STARTSERVICE),
    RESSTR(IDS_TASKMENU_STOPSERVICE),
    RESSTR(IDS_TASKMENU_STATUSBAR_STOPSERVICE),
    RESSTR(IDS_TASKMENU_PUBLISHCRL),
    RESSTR(IDS_TASKMENU_STATUSBAR_PUBLISHCRL),
    RESSTR(IDS_TASKMENU_VIEWCRL),
    RESSTR(IDS_TASKMENU_STATUSBAR_VIEWCRL),
    RESSTR(IDS_TASKMENU_REVOKECERT),
    RESSTR(IDS_TASKMENU_STATUSBAR_REVOKECERT),
    RESSTR(IDS_TASKMENU_RESUBMIT),
    RESSTR(IDS_TASKMENU_STATUSBAR_RESUBMIT),
    RESSTR(IDS_TASKMENU_DENYREQUEST),
    RESSTR(IDS_TASKMENU_STATUSBAR_DENYREQUEST),
    RESSTR(IDS_TASKMENU_BACKUP),
    RESSTR(IDS_TASKMENU_STATUSBAR_BACKUP),
    RESSTR(IDS_NEED_FILEPATH),
    RESSTR(IDS_BACKUPWIZ_TITLE),
    RESSTR(IDS_TOPMENU_OPEN),
    RESSTR(IDS_TASKMENU_RESTORE),
    RESSTR(IDS_TASKMENU_STATUSBAR_RESTORE),
    RESSTR(IDS_TASKMENU_INSTALL_CA),
    RESSTR(IDS_TASKMENU_STATUSBAR_INSTALL_CA),
    RESSTR(IDS_TOPMENU_STATUSBAR_OPEN),
    RESSTR(IDS_ERR_RESTORE_OVER_EXISTING_DATABASE),
    RESSTR(IDS_DIR_NOT_WRITEABLE),
    RESSTR(IDS_DIRECTORY_CONTENTS_UNEXPECTED),
    RESSTR(IDS_MUST_CHOOSE_MACHINE),
    RESSTR(IDS_TASKMENU_REQUEST_CA),
    RESSTR(IDS_TASKMENU_STATUSBAR_REQUEST_CA),
    RESSTR(IDS_ICMM_GETNAMEPROPERTY_FAILED),
    RESSTR(IDS_CHOOSER_INVALID_COMPUTERNAME),
    RESSTR(IDS_EXT_CDP),
    RESSTR(IDS_EXT_AIA),
    RESSTR(IDS_EXT_CDP_EXPLAIN),
    RESSTR(IDS_EXT_AIA_EXPLAIN),
    RESSTR(IDS_INVALID_PREFIX),
    RESSTR(IDS_INVALID_TOKEN),
    RESSTR(IDS_INVALID_ENCODING),
    RESSTR(IDS_EMPTY_URL),
    RESSTR(IDS_SAME_URL_EXIST),
    RESSTR(IDS_VIEW_CERT_DENY_ERROR),
    RESSTR(IDS_VIEW_CERT_NOT_RUNNING),
    RESSTR(IDS_KRA_ADD_TITLE),
    RESSTR(IDS_KRA_ADD_SUBTITLE),
    RESSTR(IDS_TASKMENU_SUBMITREQUEST),
    RESSTR(IDS_TASKMENU_STATUSBAR_SUBMITREQUEST),
    RESSTR(IDS_INH_ALL),
    RESSTR(IDS_INH_CONTAINER),
    RESSTR(IDS_INH_OBJECT),
    RESSTR(IDS_INH_NONE),
    RESSTR(IDS_LARGEFONTNAME),
    RESSTR(IDS_SMALLFONTNAME),
    RESSTR(IDS_SMALLFONTSIZE),
    RESSTR(IDS_FONTSIZE),
    RESSTR(IDS_LARGEFONTSIZE),
    RESSTR(IDS_STARTMENU_CERTMMC_LINKNAME),
    RESSTR(IDS_STARTMENU_CERTMMC_DESCRIPTION),
    RESSTR(IDS_LISTCOL_TAG),
    RESSTR(IDS_LISTCOL_VALUE),
    RESSTR(IDS_TASKMENU_VIEWATTREXT),
    RESSTR(IDS_TASKMENU_STATUSBAR_VIEWATTREXT),
    RESSTR(IDS_LISTCOL_FLAGS),
    RESSTR(IDS_LISTCOL_ORGIN),
    RESSTR(IDS_UNKNOWN_EXTENSION),
    RESSTR(IDS_CERT_PROP_CAPTION),
    RESSTR(IDS_LISTCOL_CRITICAL),
    RESSTR(IDS_LISTCOL_ENABLED),
    RESSTR(IDS_CRL_LISTCOL_INDEX),
    RESSTR(IDS_LISTCOL_EFFECTIVE_DATE),
    RESSTR(IDS_LISTCOL_EXPIRATION_DATE),
    RESSTR(IDS_LISTCOL_PUBLISH_STATUS),
    RESSTR(IDS_YES),
    RESSTR(IDS_NO),
    RESSTR(IDS_EXT_ORIGIN_REQUEST),
    RESSTR(IDS_EXT_ORIGIN_POLICY),
    RESSTR(IDS_EXT_ORIGIN_ADMIN),
    RESSTR(IDS_EXT_ORIGIN_SERVER),
    RESSTR(IDS_EXT_ORIGIN_RENEWAL),
    RESSTR(IDS_EXT_ORIGIN_IMPORTED_CERT),
    RESSTR(IDS_EXT_ORIGIN_PKCS7),
    RESSTR(IDS_EXT_ORIGIN_UNKNOWN),
    RESSTR(IDS_LISTCOL_SUBJECT),
    RESSTR(IDS_LISTCOL_ISSUER),
    RESSTR(IDS_CA_CERT_LISTBOX),
    RESSTR(IDS_LIST_NAME),
    RESSTR(IDS_BINARYFILE_OUTPUT_TITLE),
    RESSTR(IDS_BINARYFILE_OUTPUT_FILTER),
    RESSTR(IDS_KRA_COUNT_TOO_BIG),
    RESSTR(IDS_KRA_NOKRADEFINED),
    RESSTR(IDS_BUTTONTEXT_ALLOW),
    RESSTR(IDS_BUTTONTEXT_DENY),
    RESSTR(IDS_LIST_ACCESS),
    RESSTR(IDS_TEXT_ALLOW),
    RESSTR(IDS_TEXT_DENY),
    RESSTR(IDS_LISTCOL_STATUS),
    RESSTR(IDS_DISPOSITION_EXPIRED),
    RESSTR(IDS_DISPOSITION_NOTFOUND),
    RESSTR(IDS_DISPOSITION_REVOKED),
    RESSTR(IDS_DISPOSITION_VALID),
    RESSTR(IDS_DISPOSITION_INVALID),
    RESSTR(IDS_DISPOSITION_UNTRUSTED),
    RESSTR(IDS_DISPOSITION_NOTLOADED),
    RESSTR(IDS_CRLPUBLISHSTATUS_OK),
    RESSTR(IDS_CRLPUBLISHSTATUS_FAILED),
    RESSTR(IDS_CRLPUBLISHSTATUS_UNKNOWN),
    RESSTR(IDS_KRA_CANNOT_OPEN_STORE),
    RESSTR(IDS_OLD_CA),
    RESSTR(IDS_CERTS_IMPORTED),
    RESSTR(IDS_W2K_UPGRADE_DETECTED_TITLE),
    RESSTR(IDS_CONFIRM_W2K_SECURITY_UPGRADE),
    RESSTR(IDS_BLOCK_W2K_SECURITY_UPGRADE),
    RESSTR(IDS_W2K_SECURITY_UPGRADE_DESCR),
    RESSTR(IDS_CDP_INCLUDE_INSTRUCTIONS),
    RESSTR(IDS_AIA_INCLUDE_INSTRUCTIONS),
    RESSTR(IDS_WARN_START_STOP_PERFORMANCE),
    RESSTR(IDS_CANNOT_OPEN_CERT_SERVICES),
    RESSTR(IDS_DATA_UNAVAILABLE),
    RESSTR(IDS_CANNOT_UPDATE_SECURITY_ON_CA),
    RESSTR(IDS_WARN_INVALID_KRAS),
    RESSTR(IDS_CRLSTATE_REVOKED),
    RESSTR(IDS_CRLERROR_FORMAT),
    RESSTR(IDS_EXT_ORIGIN_CMC),
    RESSTR(IDS_EXT_ORIGIN_CACERT),
    RESSTR(IDS_CAHIER_CERTFILE_FILTER),
    RESSTR(IDS_CAHIER_INSTALL_TITLE),
    RESSTR(IDS_ILOG_MISSING_PROVIDER),
    RESSTR(IDS_ERR_INCOMPLETECHAIN),
    RESSTR(IDS_ERR_INVALIDCHAIN),
    RESSTR(IDS_ERR_RETRIEVE_PENDING),
    RESSTR(IDS_ILOG_GETCANAME),
    RESSTR(IDS_ILOG_SELECTCA),
    RESSTR(IDS_ILOG_SAVECERTANDKEYS),
    RESSTR(IDS_ILOG_RETRIEVECERT),
    RESSTR(IDS_ILOG_FINISHSUSPENDEDSETUP),
    RESSTR(IDS_ERR_NOTCACERT),
    RESSTR(IDS_ILOG_SETUPCOMPLETE),
    RESSTR(IDS_ILOG_RETRIEVEPENDING),
    RESSTR(IDS_ILOG_KEYINDEX),
    RESSTR(IDS_ILOG_LOADOLDCERT),
    RESSTR(IDS_ILOG_CLONECERT),
    RESSTR(IDS_ILOG_BUILDREQUEST),
    RESSTR(IDS_ILOG_RENEWOLDKEY),
    RESSTR(IDS_ILOG_INSTALLCERT),
    RESSTR(IDS_ILOG_RENEWNEWKEY),
    RESSTR(IDS_ILOG_BUILDCERT),
    RESSTR(IDS_ILOG_SAVECHAINANDKEYS),
    RESSTR(IDS_REQUEST_HELPTEXT),
    RESSTR(IDS_ILOG_CREATECDP),
    RESSTR(IDS_ILOG_CREATENTAUTHTRUST),
    RESSTR(IDS_ILOG_CREATEROOTTRUST),
    RESSTR(IDS_ILOG_PUBLISHCA),
    RESSTR(IDS_ILOG_SUBMITREQUEST),
    RESSTR(IDS_ERR_BADCSP),
    RESSTR(IDS_ERR_BAD_CA_CERT_7F),
    RESSTR(IDS_ERR_RENEWEDCERTCAVERSION),
    RESSTR(IDS_ERR_UNTRUSTEDROOT),
    RESSTR(IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE),
    RESSTR(IDS_ERR_CERTCREATECERTIFICATECONTEXT),
    RESSTR(IDS_ILOG_UNREFERENCEDINFSECTIONS),
    RESSTR(IDS_ILOG_SETSECURITY),
    RESSTR(IDS_ERR_CREATEFILE),
    RESSTR(IDS_ERR_DELETEKEY),
    RESSTR(IDS_ERR_ENCODEKEYATTR),
    RESSTR(IDS_ERR_ENCODETOBESIGNED),
    RESSTR(IDS_ERR_ENV_NOT_SET),
    RESSTR(IDS_ERR_FULL_TOKEN),
    RESSTR(IDS_ERR_GENKEYFAIL),
    RESSTR(IDS_ERR_GETCOMPUTERNAME),
    RESSTR(IDS_ERR_KEYSECURITY),
    RESSTR(IDS_ERR_MYDECODENAME),
    RESSTR(IDS_ERR_NOT_ENTERPRISE_USER),
    RESSTR(IDS_ERR_NOT_MATCH_COMMONNAME),
    RESSTR(IDS_ILOG_GENERATEKEYS),
    RESSTR(IDS_ERR_REPEATWIZPREFIX),
    RESSTR(IDS_ERR_REQUEST_DENIED),
    RESSTR(IDS_ERR_REQUEST_ERROR),
    RESSTR(IDS_ERR_REQUEST_INCOMPLETE),
    RESSTR(IDS_ERR_REQUEST_OUTOFBAND),
    RESSTR(IDS_ERR_REQUEST_PENDING),
    RESSTR(IDS_ERR_REQUEST_REVOKED),
    RESSTR(IDS_ERR_SETKEYPROVIDER),
    RESSTR(IDS_ERR_SUBMIT_REQUEST),
    RESSTR(IDS_ERR_SUBMIT_REQUEST_FAIL),
    RESSTR(IDS_ERR_NOT_MATCH_BINARYNAME),
    RESSTR(IDS_ERR_NOT_MATCH_KEY),
    RESSTR(IDS_CAHIER_INSTALL_MISIINGCERT_TITLE),
    RESSTR(IDS_ERR_WRITEDERTOFILE),
    RESSTR(IDS_ERR_WRITEFILE),
    RESSTR(IDS_ILOG_INFERROR),
    RESSTR(IDS_ILOG_SETKEYSECURITY),
    RESSTR(IDS_MSG_PARENTCA_CONFIG),
    RESSTR(IDS_MSG_REQUEST_ID),
    RESSTR(IDS_MSG_TITLE),
    RESSTR(IDS_ILOG_SETADMINONLYFOLDERSECURITY),
    RESSTR(IDS_ERR_NO_KEY_ACCESS),
    RESSTR(IDS_CA_PICKER_TITLE),
    RESSTR(IDS_CA_PICKER_PROMPT),
    RESSTR(IDS_CERTTYPE_USER),
    RESSTR(IDS_CERTTYPE_USER_AS),
    RESSTR(IDS_CERTTYPE_USER_SMARTCARD_LOGON),
    RESSTR(IDS_CERTTYPE_EFS),
    RESSTR(IDS_CERTTYPE_ADMIN),
    RESSTR(IDS_CERTTYPE_EFS_RECOVERY),
    RESSTR(IDS_CERTTYPE_CODE_SIGNING),
    RESSTR(IDS_CERTTYPE_CTL_SIGNING),
    RESSTR(IDS_CERTTYPE_MACHINE),
    RESSTR(IDS_CERTTYPE_DC),
    RESSTR(IDS_CERTTYPE_WEBSERVER),
    RESSTR(IDS_CERTTYPE_KDC),
    RESSTR(IDS_CERTTYPE_ROOT_CA),
    RESSTR(IDS_CERTTYPE_SUBORDINATE_CA),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT),
    RESSTR(IDS_CERTTYPE_SMARTCARD_USER),
    RESSTR(IDS_CERTTYPE_USER_SIGNATURE),
    RESSTR(IDS_ILOG_BAD_NUMERICFIELD),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_COUNT),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING),
    RESSTR(IDS_CERTTYPE_ROUTER_OFFLINE),
    RESSTR(IDS_REQUEST_FILE_DEFEXT),
    RESSTR(IDS_REQUEST_OPEN_TITLE),
    RESSTR(IDS_REQUEST_FILE_FILTER),
    RESSTR(IDS_WRN_COMPUTERNAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_NOT_MATCH),
    RESSTR(IDS_WRN_PINGCA_FAIL),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE),
    RESSTR(IDS_WRN_CALIST_EMPTY),
    RESSTR(IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT),
    RESSTR(IDS_REQUEST_SAVE_TITLE),
    RESSTR(IDS_CERTTYPE_CEP_ENCRYPTION),
    RESSTR(IDS_ILOG_CAPOLICY_BUILD),
    RESSTR(IDS_ILOG_CAPOLICY_ELEMENT),
    RESSTR(IDS_ILOG_CAPOLICY_EXTENSION),
    RESSTR(IDS_ILOG_CAPOLICY_NOKEY),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN_FAILED),
    RESSTR(IDS_ILOG_BEGIN),
    RESSTR(IDS_ILOG_END),
    RESSTR(IDS_ACTRL_CAADMIN),
    RESSTR(IDS_ACTRL_OFFICER),
    RESSTR(IDS_ACTRL_AUDITOR),
    RESSTR(IDS_ACTRL_OPERATOR),
    RESSTR(IDS_ACTRL_CAREAD),
    RESSTR(IDS_ACTRL_ENROLL),
    RESSTR(IDS_ILOG_CAPOLICY_CLOSE),
    RESSTR(IDS_ILOG_MESSAGEBOX),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND),
    RESSTR(IDS_CERTTYPE_KEY_RECOVERY_AGENT),
    RESSTR(IDS_CERTTYPE_CA_EXCHANGE),
    RESSTR(IDS_EMPTY_FRIENDLY_NAME),
    RESSTR(IDS_CERTTYPE_CROSS_CA),
    RESSTR(IDS_CERTTYPE_DC_AUTH),
    RESSTR(IDS_CERTTYPE_DS_EMAIL_REPLICATION),
    RESSTR(IDS_WARN_ENTERPRISE_REQUIREMENTS),
    RESSTR(IDS_WRN_OLD_CA),
    RESSTR(IDS_ILOG_BAD_BOOLEAN),
    RESSTR(IDS_CERTTYPE_WORKSTATION),
    RESSTR(IDS_CERTTYPE_RASIASSERVER),
    RESSTR(IDS_LOW_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_MEDIUM_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_HIGH_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_KRA_DESCRIPTION),
    RESSTR(IDS_EMAIL_REPLICATION_DESCRIPTION),
    RESSTR(IDS_CROSS_CA_DESCRIPTION),
    RESSTR(IDS_CA_DESCRIPTION),
    RESSTR(IDS_MACHINE_DESCRIPTION),
    RESSTR(IDS_END_USER_DESCRIPTION),
    RESSTR(IDS_UNKNOWN_DESCRIPTION),
    RESSTR(IDS_STORENAME_DS_KRA),
    RESSTR(IDS_STORENAME_DS_AIA),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\stdafx.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#undef _MSC_EXTENSIONS

#define __DIR__		"certmmc"

#include <windows.h>
#include <objbase.h>
#include <coguid.h>
#include <aclui.h>

#include <wincrypt.h>

#include <setupapi.h>
#include "ocmanage.h"

#include <atlbase.h>

//using namespace ATL;

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const CLSID CLSID_Extension; // In-Proc server GUID
extern const CLSID CLSID_About; 

extern HINSTANCE g_hInstance;
extern HMODULE g_hmodRichEdit;

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))



#include <atlcom.h>

#pragma comment(lib, "mmc")
#include <mmc.h>

// include debug allocator tracking, etc
#include "certlib.h"

// must be after certlib to track memory
#include <comdef.h>

// Thomlinson Foundation Classes
#include "tfc.h"

#include <certsrv.h>
#include <certdb.h>
#include <initcert.h>

// most common private includes
#include "uuids.h"
#include "misc.h"
#include "folders.h"
#include "certwrap.h"
#include "compdata.h"
#include "CSnapin.h"
#include "DataObj.h"

inline void __stdcall _com_issue_error(long) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\snapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "misc.h"

#include <shlguid.h>
#include <shlobj.h>

#define __dwFILE__	__dwFILE_CERTMMC_SNAPIN_CPP__

#define WSZCERTMMC_DLL "certmmc.dll"

CComModule _Module;
HINSTANCE g_hInstance = NULL;
HMODULE g_hmodRichEdit = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Snapin, CComponentDataPrimaryImpl)
    OBJECT_ENTRY(CLSID_About, CSnapinAboutImpl)
END_OBJECT_MAP()

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


void CreateRegEntries();
void RemoveRegEntries();

void CreateProgramGroupLink();
void RemoveProgramGroupLink();


// #define CERTMMC_DEBUG_REGSVR

BOOL WINAPI
DllMain(  
    HINSTANCE hinstDLL,  // handle to DLL module
    DWORD dwReason,     // reason for calling function
    LPVOID /* lpvReserved */ )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        g_hInstance = hinstDLL;
        _Module.Init(ObjectMap, hinstDLL);

        DisableThreadLibraryCalls(hinstDLL);
	LogOpen(FALSE);
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        // last call process should do this

        if (NULL != g_hmodRichEdit)
	{
            FreeLibrary(g_hmodRichEdit);
        }
        myFreeColumnDisplayNames();   
	myFreeResourceStrings("certmmc.dll");
	delete g_pResources;
        _Module.Term();
	myRegisterMemDump();
        LogClose();

        DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
        DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);
        break;
    }

    default:
        break;
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    CreateRegEntries();
    CreateProgramGroupLink();

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

    RemoveRegEntries();
    RemoveProgramGroupLink();

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Register/UnRegister nodetypes, etc

typedef struct _REGVALUE
{
    DWORD        dwFlags;
    WCHAR const *pwszKeyName;     // NULL implies place value under CA name key
    WCHAR const *pwszValueName;
    WCHAR const *pwszValueString; // NULL implies use REG_DWORD value (dwValue)
    DWORD        dwValue;
} REGVALUE;

// Flags
#define CERTMMC_REG_DELKEY 1    // delete this key on removal

// Values Under "HKLM" from base to leaves
REGVALUE g_arvCA[] =
{
  // main snapin uuid
#define IREG_SNAPINNAME		0
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1, NULL, NULL, 0},
#define IREG_SNAPINNAMESTRING	1
  { 0,                  wszREGKEYMGMTSNAPINUUID1, wszSNAPINNAMESTRING, NULL, 0},
#define IREG_SNAPINNAMESTRINGINDIRECT	2
  { 0,                  wszREGKEYMGMTSNAPINUUID1, wszSNAPINNAMESTRINGINDIRECT, NULL, 0},

  { 0,                  wszREGKEYMGMTSNAPINUUID1, wszSNAPINABOUT, wszSNAPINNODETYPE_ABOUT, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_STANDALONE, NULL, NULL, 0}
  ,
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_1, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_2, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_3, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_4, NULL, NULL, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPINUUID1_NODETYPES_5, NULL, NULL, 0},

  // register each snapin nodetype
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_1, NULL, wszREGCERTSNAPIN_NODETYPES_1, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_2, NULL, wszREGCERTSNAPIN_NODETYPES_2, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_3, NULL, wszREGCERTSNAPIN_NODETYPES_3, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_4, NULL, wszREGCERTSNAPIN_NODETYPES_4, 0},
  { CERTMMC_REG_DELKEY, wszREGKEYMGMTSNAPIN_NODETYPES_5, NULL, wszREGCERTSNAPIN_NODETYPES_5, 0},

  { 0,                  NULL, NULL, NULL, 0 }
};


HRESULT
InitRegEntries(
    OPTIONAL IN OUT CString *pcstrName,
    OPTIONAL IN OUT CString *pcstrNameString,
    OPTIONAL IN OUT CString *pcstrNameStringIndirect)
{
    HRESULT hr = S_OK;
    WCHAR const *pwsz;

    pwsz = NULL;
    if (NULL != pcstrName)
    {
	pcstrName->LoadString(IDS_CERTMMC_SNAPINNAME);
	if (pcstrName->IsEmpty())
	{
	    hr = myHLastError();
	    _PrintError(hr, "LoadString");
	}
	else
	{
	    pwsz = (LPCWSTR) *pcstrName;
	}
    }
    g_arvCA[IREG_SNAPINNAME].pwszValueString = pwsz;

    pwsz = NULL;
    if (NULL != pcstrNameString)
    {
	pcstrNameString->LoadString(IDS_CERTMMC_SNAPINNAMESTRING);
	if (pcstrNameString->IsEmpty())
	{
	    hr = myHLastError();
	    _PrintError(hr, "LoadString");
	}
	else
	{
	    pwsz = (LPCWSTR) *pcstrNameString;
	}
    }
    g_arvCA[IREG_SNAPINNAMESTRING].pwszValueString = pwsz;


    pwsz = NULL;
    if (NULL != pcstrNameStringIndirect)
    {
	pcstrNameStringIndirect->Format(wszSNAPINNAMESTRINGINDIRECT_TEMPLATE, L"CertMMC.dll", IDS_CERTMMC_SNAPINNAMESTRING);
	if (pcstrNameStringIndirect->IsEmpty())
	{
	    hr = myHLastError();
	    _PrintError(hr, "LoadString");
	}
	else
	{
	    pwsz = (LPCWSTR) *pcstrNameStringIndirect;
	}
    }
    g_arvCA[IREG_SNAPINNAMESTRINGINDIRECT].pwszValueString = pwsz;


//error:
    return(hr);
}


void CreateRegEntries()
{
    DWORD err;
    HKEY hKeyThisValue = NULL;
    REGVALUE const *prv;
    CString cstrName;
    CString cstrNameString;
    CString cstrNameStringIndirect;

    InitRegEntries(&cstrName, &cstrNameString, &cstrNameStringIndirect);

    // run until not creating key or value
    for (   prv=g_arvCA; 
            !(NULL == prv->pwszValueName && NULL == prv->pwszKeyName);
            prv++ )
    {
        DWORD dwDisposition;
        ASSERT(NULL != prv->pwszKeyName);
        if (NULL == prv->pwszKeyName)
             continue;

#ifdef CERTMMC_DEBUG_REGSVR
            CString cstr;
            cstr.Format(L"RegCreateKeyEx: %ws\n", prv->pwszKeyName);
            OutputDebugString((LPCWSTR)cstr);
#endif

        err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
             prv->pwszKeyName,
             0,
             NULL,
             REG_OPTION_NON_VOLATILE,
             KEY_ALL_ACCESS,
             NULL,
             &hKeyThisValue,
             &dwDisposition);
        if (err != ERROR_SUCCESS)
            goto error;
        

        // for now, don't set any value if unnamed, unvalued string
        // UNDONE: can't set unnamed dword!

        if (NULL != prv->pwszValueName || NULL != prv->pwszValueString)
        {
            if (NULL != prv->pwszValueString)
            {
#ifdef CERTMMC_DEBUG_REGSVR
            CString cstr;
            cstr.Format(L"RegSetValueEx: %ws : %ws\n", prv->pwszValueName, prv->pwszValueString);
            OutputDebugString((LPCWSTR)cstr);
#endif
                err = RegSetValueEx(
                        hKeyThisValue,
                        prv->pwszValueName,
                        0,
                        REG_SZ,
                        (const BYTE *) prv->pwszValueString,
                        WSZ_BYTECOUNT(prv->pwszValueString));
            }
            else
            {
#ifdef CERTMMC_DEBUG_REGSVR
            CString cstr;
            cstr.Format(L"RegSetValueEx: %ws : %ul\n", prv->pwszValueName, prv->dwValue);
            OutputDebugString((LPCWSTR)cstr);
#endif
                err = RegSetValueEx(
                        hKeyThisValue,
                        prv->pwszValueName,
                        0,
                        REG_DWORD,
                        (const BYTE *) &prv->dwValue,
                        sizeof(prv->dwValue));

            }
            if (err != ERROR_SUCCESS)
                goto error;
        }

        if (NULL != hKeyThisValue)
        {
            RegCloseKey(hKeyThisValue);
            hKeyThisValue = NULL;
        }
    }

error:            
    if (hKeyThisValue)
        RegCloseKey(hKeyThisValue);

    InitRegEntries(NULL, NULL, NULL);
    return;
}

void RemoveRegEntries()
{
    REGVALUE const *prv;

    // walk backwards through array until hit array start
    for (   prv= (&g_arvCA[ARRAYLEN(g_arvCA)]) - 2;     // goto zero-based end AND skip {NULL}
            prv >= g_arvCA;                             // until we walk past beginning
            prv-- )                                     // walk backwards
    {
        if (prv->dwFlags & CERTMMC_REG_DELKEY) 
        {
            ASSERT(prv->pwszKeyName != NULL);
#ifdef CERTMMC_DEBUG_REGSVR
            CString cstr;
            cstr.Format(L"RegDeleteKey: %ws\n", prv->pwszKeyName);
            OutputDebugString((LPCWSTR)cstr);
#endif

            RegDeleteKey(
                HKEY_LOCAL_MACHINE,
                prv->pwszKeyName);
        }
    }

//error:            

    return;
}

#include <shlobj.h>         // CSIDL_ #defines
#include <userenv.h>
#include <userenvp.h>   // CreateLinkFile API

typedef struct _PROGRAMENTRY
{
    UINT        uiLinkName;
    UINT        uiDescription;
    DWORD       csidl;          // special folder index
    WCHAR const *pwszExeName;
    WCHAR const *pwszArgs;
} PROGRAMENTRY;

PROGRAMENTRY const g_aProgramEntry[] = {
    {
        IDS_STARTMENU_CERTMMC_LINKNAME,         // uiLinkName
        IDS_STARTMENU_CERTMMC_DESCRIPTION,      // uiDescription
        CSIDL_COMMON_ADMINTOOLS,                // "All Users\Start Menu\Programs\Administrative Tools"
        L"certsrv.msc",                         // pwszExeName
        L"",                                    // pwszArgs
    },
};

#define CPROGRAMENTRY   ARRAYSIZE(g_aProgramEntry)


BOOL FFileExists(LPCWSTR szFile)
{
    WIN32_FILE_ATTRIBUTE_DATA data;

    return(
    GetFileAttributesEx(szFile, GetFileExInfoStandard, &data) &&
    !(FILE_ATTRIBUTE_DIRECTORY & data.dwFileAttributes) 
          );
}

HRESULT
DeleteMatchingLinks(
    IN WCHAR const *pwszLinkDir,	// C:\Documents...Administrative Tools
    IN WCHAR const *pwszLinkPath,	// C:\ " \Certification Authority.lnk
    IN WCHAR const *pwszTargetPath,	// C:\WINDOWS\system32\certsrv.msc
    IN WCHAR const *pwszArgs,
    IN WCHAR const *pwszDLLPath)	// C:\WINDOWS\system32\certmmc.dll
{
    HRESULT hr;
    WCHAR *pwszPattern = NULL;
    WCHAR *pwszFile = NULL;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA wfd;
    IShellLink *psl = NULL; 
    IPersistFile *ppf = NULL; 
    int i;
    
    hr = myBuildPathAndExt(pwszLinkDir, L"*.lnk", NULL, &pwszPattern);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hf = FindFirstFile(pwszPattern, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpErrorStr2(hr, error, "no *.lnk files", pwszPattern, hr);
    }

    hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
    do {
        WCHAR wszPath[MAX_PATH];

	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}

        if (NULL != psl)
	{
	    psl->Release(); 
	    psl = NULL;
	}
        if (NULL != ppf)
	{
	    ppf->Release(); 
	    ppf = NULL;
	}
	if (NULL != pwszFile)
	{
	    LocalFree(pwszFile);
	    pwszFile = NULL;
	}
	hr = myBuildPathAndExt(pwszLinkDir, wfd.cFileName, NULL, &pwszFile);
	_JumpIfError(hr, error, "myBuildPathAndExt");

	if (0 == mylstrcmpiL(pwszLinkPath, pwszFile))
	{
	    continue;	// skip exact match
	}

        // Get a pointer to the IShellLink interface. 
        hr = CoCreateInstance(CLSID_ShellLink, NULL, 
            CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *) &psl); 
	if (S_OK != hr)
	    psl = NULL;
        _JumpIfError(hr, error, "CoCreateInstance");

        // Query IShellLink for the IPersistFile interface for saving the 
        // shortcut in persistent storage. 
        hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf); 
	if (S_OK != hr)
	    ppf = NULL;
        _JumpIfError(hr, error, "QI");
        
        // Load the link by calling IPersistFile::Load. 
        hr = ppf->Load(pwszFile, STGM_READ); 
        _JumpIfError(hr, error, "Load");

        hr = psl->GetPath(wszPath, ARRAYSIZE(wszPath), &wfd, SLGP_UNCPRIORITY);
        _JumpIfError(hr, error, "GetPath");

	if (0 != mylstrcmpiL(pwszTargetPath, wszPath))
	{
	    continue;	// different path: skip
	}

        hr = psl->GetArguments(wszPath, ARRAYSIZE(wszPath));
        _JumpIfError(hr, error, "GetArguments");

	if (0 != mylstrcmpiL(pwszArgs, wszPath))
	{
	    continue;	// different arguments: skip
	}

	hr = psl->GetIconLocation(wszPath, ARRAYSIZE(wszPath), &i);
        _JumpIfError(hr, error, "GetIconLocation");

	if (0 != mylstrcmpiL(pwszDLLPath, wszPath))
	{
	    continue;	// different icon DLL: skip
	}
	psl->Release(); 
	psl = NULL;
	ppf->Release(); 
	ppf = NULL;
	DeleteFile(pwszFile);

    } while (FindNextFile(hf, &wfd));
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hf)
    {
	FindClose(hf);
    }
    if (NULL != pwszFile)
    {
	LocalFree(pwszFile);
    }
    if (NULL != pwszPattern)
    {
	LocalFree(pwszPattern);
    }
    if (NULL != ppf)
    {
        ppf->Release(); 
    }
    if (NULL != psl)
    {
        psl->Release(); 
    }
    return(hr);
}


void CreateProgramGroupLink()
{
    HRESULT hr;
    PROGRAMENTRY const *ppe;
    IShellLink *psl = NULL; 
    IPersistFile *ppf = NULL; 

    for (ppe = g_aProgramEntry; ppe < &g_aProgramEntry[CPROGRAMENTRY]; ppe++)
    {
        WCHAR wszPath[MAX_PATH];
        CString strDLLPath, strPath, strDescr, strLinkName, strLinkPath;
        LPWSTR pszTmp;

        if (NULL == (pszTmp = strPath.GetBuffer(MAX_PATH)))
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "GetBuffer");
        }
        
        GetSystemDirectory(pszTmp, MAX_PATH);

        strPath += L"\\";

        strDLLPath = strPath;
        strDLLPath += WSZCERTMMC_DLL;

        strPath += ppe->pwszExeName;

        // don't create link for file that doesn't exist
        if (!FFileExists(strPath))
            continue;

        strDescr.Format(L"@%s,-%d", strDLLPath.GetBuffer(), ppe->uiDescription);
        
        hr = SHGetFolderPath(
            NULL,
            ppe->csidl,
            NULL,
            SHGFP_TYPE_CURRENT,
            wszPath);
        _JumpIfError(hr, error, "SHGetFolderPath(Administrative Tools)");

        strLinkName.LoadString(ppe->uiLinkName);
        strLinkPath.Format(L"%s\\%s.lnk", wszPath, strLinkName);
	DeleteMatchingLinks(
			wszPath,
			strLinkPath,
			strPath,
			ppe->pwszArgs,
			strDLLPath);

        // Get a pointer to the IShellLink interface. 
        hr = CoCreateInstance(CLSID_ShellLink, NULL, 
            CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *) &psl); 
	if (S_OK != hr)
	    psl = NULL;
        _JumpIfError(hr, error, "CoCreateInstance");

        strPath += ppe->pwszArgs;
        hr = psl->SetPath(strPath);
        _JumpIfError(hr, error, "SetPath");

        hr = psl->SetIconLocation(strDLLPath, 0);
        _JumpIfError(hr, error, "SetIconLocation");

        hr = psl->SetDescription(strDescr);
        _JumpIfError(hr, error, "SetDescription");

        // Query IShellLink for the IPersistFile interface for saving the 
        // shortcut in persistent storage. 
        hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf); 
	if (S_OK != hr)
	    ppf = NULL;
        _JumpIfError(hr, error, "QI");
        
        // Save the link by calling IPersistFile::Save. 
        hr = ppf->Save(strLinkPath.GetBuffer(), TRUE); 
        _JumpIfError(hr, error, "Save");

        hr = SHSetLocalizedName(
            strLinkPath.GetBuffer(),
            strDLLPath,
            ppe->uiLinkName);
        _JumpIfError(hr, error, "SHSetLocalizedName");

        ppf->Release(); 
	ppf = NULL;
        psl->Release(); 
	psl = NULL;
    }

    hr = S_OK;

error:
    if (NULL != ppf)
        ppf->Release(); 
    if (NULL != psl)
        psl->Release(); 
    return;
}

void RemoveProgramGroupLink()
{
    HRESULT hr = S_OK;
    PROGRAMENTRY const *ppe;

    for (ppe = g_aProgramEntry; ppe < &g_aProgramEntry[CPROGRAMENTRY]; ppe++)
    {
        CString cstrLinkName;
        cstrLinkName.LoadString(ppe->uiLinkName);
        if (cstrLinkName.IsEmpty())
        {
            hr = myHLastError();
            _PrintError(hr, "LoadString");
            continue;
        }

        if (!DeleteLinkFile(
            ppe->csidl,     // CSIDL_*
            NULL,               // IN LPCSTR lpSubDirectory
            (LPCWSTR)cstrLinkName,      // IN LPCSTR lpFileName
            FALSE))         // IN BOOL fDeleteSubDirectory
        {
            hr = myHLastError();
            _PrintError2(hr, "DeleteLinkFile", hr);
        }
    }

//error:
    _PrintIfError2(hr, "RemoveProgramGroupLink", hr);    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\uuids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       uuids.cpp
//
//--------------------------------------------------------------------------

#include <stdafx.h>

const CLSID CLSID_Snapin = /*de751566-4cc6-11d1-8ca0-00c04fc297eb*/ \
{0xde751566,0x4cc6,0x11d1,{0x8c,0xa0,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};

const CLSID CLSID_About = /*4653e860-4cc7-11d1-8ca0-00c04fc297eb*/ \
{0x4653e860,0x4cc7,0x11d1,{0x8c,0xa0,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};

///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// NodeType GUID in numeric & string formats.

// nodetype for each machine instance
const GUID cNodeTypeMachineInstance = 
{0x89b31b94,0x4cc7,0x11d1,{0x8c, 0xa0, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}};
const WCHAR*  cszNodeTypeMachineInstance = L"{89b31b94-4cc7-11d1-8ca0-00c04fc297eb}";

// nodetype for each server instance
const GUID cNodeTypeServerInstance = 
{0x5d972ee4,0x7576,0x11d1,{0x8c, 0xbe, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}};
const WCHAR*  cszNodeTypeServerInstance = L"{5d972ee4-7576-11d1-8cbe-00c04fc297eb}";

// nodetype for CRL Publication
const GUID cNodeTypeCRLPublication = 
{0x5946e36c,0x757c,0x11d1,{0x8c,0xbe,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszNodeTypeCRLPublication = L"{5946E36C-757C-11d1-8CBE-00C04FC297EB}";

// nodetype for Issued Certs
const GUID cNodeTypeIssuedCerts = 
{0x783e4e5f,0x757c,0x11d1,{0x8c,0xbe,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszNodeTypeIssuedCerts = L"{783E4E5F-757C-11d1-8CBE-00C04FC297EB}";

// nodetype for Pending Certs
const GUID cNodeTypePendingCerts = 
{0x783e4e63,0x757c,0x11d1,{0x8c,0xbe,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszNodeTypePendingCerts = L"{783E4E63-757C-11d1-8CBE-00C04FC297EB}";

// nodetype for Failed Certs
const GUID cNodeTypeFailedCerts =
{0x1edac98a,0xaf06,0x11d1,{0x8c,0xd4,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszNodeTypeFailedCerts = L"{1EDAC98A-AF06-11D1-8CD4-00C04FC297EB}";

// nodetype for Alien Certs
const GUID cNodeTypeAlienCerts =
{0x0A0DAF12,0xD9B8,0x42F3,{0xAF, 0x1C, 0x61, 0xD1, 0x6E, 0x0A, 0x89, 0x27}};
const WCHAR* cszNodeTypeAlienCerts = L"{0A0DAF12-D9B8-42F3-AF1C-61D16E0A8927}";

// nodetype for Issued CRLs
const GUID cNodeTypeIssuedCRLs = 
{0x3307d57d,0x6201,0x4c3a,{0x89,0xc8,0xe3,0x56,0xab,0x14,0xa4,027}};
const WCHAR* cszNodeTypeIssuedCRLs = L"{3307D57D-6201-4C3A-89C8-E356AB14A427}";

// Dynamicaly created objects.
extern const GUID cNodeTypeDynamic = 
{0x0ac69b7a,0xafce,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
extern const WCHAR*  cszNodeTypeDynamic = L"{0ac69b7a-afce-11d0-a79b-00c04fd8d565}";



//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem = 
{0x00c86e52,0xaf90,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
extern const WCHAR*  cszObjectTypeResultItem = L"{00c86e52-af90-11d0-a79b-00c04fd8d565}";



//
//
//////////////////////////////////////////////////////////////////////////////

const WCHAR* SNAPIN_INTERNAL = L"SNAPIN_INTERNAL";

// Published formats
const WCHAR* SNAPIN_CA_INSTALL_TYPE = L"SNAPIN_CA_INSTALL_TYPE";
const WCHAR* SNAPIN_CA_COMMON_NAME = L"SNAPIN_CA_COMMON_NAME";
const WCHAR* SNAPIN_CA_MACHINE_NAME = L"SNAPIN_CA_MACHINE_NAME";
const WCHAR* SNAPIN_CA_SANITIZED_NAME = L"SNAPIN_CA_SANITIZED_NAME";
const WCHAR* SNAPIN_CA_ROLES = L"SNAPIN_CA_ROLES";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certprxy\csprxy.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csprxy.h
//
// Contents:    CertPrxy includes
//
//---------------------------------------------------------------------------

extern "C"
BOOL WINAPI
CertPrxyDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

STDAPI
CertPrxyDllCanUnloadNow(void);

STDAPI
CertPrxyDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

STDAPI
CertPrxyDllRegisterServer(void);

STDAPI
CertPrxyDllUnregisterServer(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\urls.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       urls.h
//
//--------------------------------------------------------------------------
#ifndef __CERTMMC_URLS_H__
#define __CERTMMC_URLS_H__


typedef struct _DISPLAYSTRING_EXPANSION
{
   LPCWSTR szContractedToken;
   UINT uTokenID;
   UINT uTokenDescrID;
   CString* pcstrExpansionString;
   CString* pcstrExpansionStringDescr;
} DISPLAYSTRING_EXPANSION, *PDISPLAYSTRING_EXPANSION;

extern DISPLAYSTRING_EXPANSION g_displayStrings[11];
#define DISPLAYSTRINGS_TOKEN_COUNT   ARRAYSIZE(g_displayStrings)

typedef enum
{
    URL_TYPE_UNKNOWN = 0,
    URL_TYPE_HTTP,
    URL_TYPE_FILE,
    URL_TYPE_LDAP,
    URL_TYPE_FTP,
    URL_TYPE_LOCAL,
    URL_TYPE_UNC,
} ENUM_URL_TYPE;

typedef struct _CSURLTEMPLATENODE
{
    CSURLTEMPLATE              URLTemplate;
    DWORD                      EnableMask;
    struct _CSURLTEMPLATENODE *pNext;
} CSURLTEMPLATENODE;

typedef struct _ADDURL_DIALOGARGS
{
    ENUM_URL_TYPE       *rgAllowedURLs;
    DWORD                cAllowedURLs;
    LPWSTR              *ppszNewURL;
    CSURLTEMPLATENODE   *pURLList;
} ADDURL_DIALOGARGS, *PADDURL_DIALOGARGS;

ENUM_URL_TYPE
DetermineURLType(
    ENUM_URL_TYPE *pAllowedUrls,
    DWORD          cAllowedUrls,
    WCHAR         *pwszURL);

HRESULT ValidateTokens(
                    IN WCHAR const *pwszURL,
                    OUT DWORD* pchBadBegin,
                    OUT DWORD* pchBadEnd);

DWORD
DetermineURLEnableMask(
    IN ENUM_URL_TYPE   UrlType);


HRESULT 
ExpandDisplayString(
     IN LPCWSTR szContractedString,
     OUT LPWSTR* ppszDisplayString);

HRESULT
ContractDisplayString(
     IN LPCWSTR szDisplayString,
     OUT LPWSTR* ppContractedString);


#endif //__CERTMMC_URLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\urls.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       urls.cpp
//
//--------------------------------------------------------------------------
#include <stdafx.h>

#include "urls.h"



BOOL
IsValidToken(
    IN WCHAR const *pwszToken,
    OUT DWORD      *pdwTokenLen)
{
    BOOL fRet = FALSE;
    DWORD i;
    DWORD len;

    CSASSERT(NULL != pwszToken &&
             L'%' == pwszToken[0] &&
             NULL != pdwTokenLen);

    //init
    *pdwTokenLen = 0;

    //find out how long the token is
    len = wcslen(pwszToken);
    *pdwTokenLen = 1; //skip % escape
    while (iswdigit(pwszToken[*pdwTokenLen]) && *pdwTokenLen < len)
    {
        ++(*pdwTokenLen);
    }

    for (i = 0; i < DISPLAYSTRINGS_TOKEN_COUNT; ++i)
    {
        if (*pdwTokenLen == wcslen(g_displayStrings[i].szContractedToken) &&
            0 == wcsncmp(pwszToken,
                         g_displayStrings[i].szContractedToken, 
                         *pdwTokenLen))
        {
            //found match
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

HRESULT ValidateTokens(
    IN WCHAR const *pwszURL,
    OUT DWORD* pchBadBegin,
    OUT DWORD* pchBadEnd)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszFound = pwszURL;
    DWORD  dwTokenLen;

    *pchBadBegin = MAXDWORD;
    *pchBadEnd = MAXDWORD;

    // look for escape token open marker
    while(NULL != (pwszFound = wcschr(pwszFound, L'%')))
    {
        if (!IsValidToken(pwszFound, &dwTokenLen))
        {
            *pchBadBegin =
                SAFE_SUBTRACT_POINTERS(pwszFound, pwszURL) + 1; //skip %
            *pchBadEnd = *pchBadBegin + dwTokenLen - 1;
            hr = S_FALSE;
            break;
        }
        pwszFound += dwTokenLen;
    }
    
    return hr;
}


typedef struct _URL_TYPE_FORMATS
{
    ENUM_URL_TYPE      UrlType;
    WCHAR const       *pwszFormat;
} URL_TYPE_FORMATS;

URL_TYPE_FORMATS const g_URLFormatTable[] =
{
    { URL_TYPE_HTTP,     L"http:"},
    { URL_TYPE_FILE,     L"file:"},
    { URL_TYPE_LDAP,     L"ldap:"},
    { URL_TYPE_FTP,      L"ftp:"},
    { URL_TYPE_UNKNOWN,  NULL},
};

URL_TYPE_FORMATS const *GetURLFormatTableEntry(
    ENUM_URL_TYPE  UrlType)
{
    URL_TYPE_FORMATS const *pFormatEntry = g_URLFormatTable;

    while (NULL != pFormatEntry->pwszFormat)
    {
        if (UrlType == pFormatEntry->UrlType)
        {
            return pFormatEntry;
        }
        ++pFormatEntry;
    }
    return NULL;
}

ENUM_URL_TYPE
DetermineURLType(
    ENUM_URL_TYPE *pAllowedUrls,
    DWORD          cAllowedUrls,
    WCHAR         *pwszURL)
{
    DWORD i;
    DWORD dwFlag;
    URL_TYPE_FORMATS const *pFormatEntry = NULL;

    for (i = 0; i < cAllowedUrls; ++i)
    {
        pFormatEntry = GetURLFormatTableEntry(pAllowedUrls[i]);
        if (NULL != pFormatEntry)
        {
            //compare if match format
            if (0 == _wcsnicmp(pwszURL, pFormatEntry->pwszFormat,
                               wcslen(pFormatEntry->pwszFormat)))
            {
                //match, done
                return pAllowedUrls[i];
            }
        }
    }

    //got here, no format match, try local path
    if (myIsFullPath(pwszURL, &dwFlag))
    {
        //it is a valid path
        if (UNC_PATH == dwFlag)
        {
            return URL_TYPE_UNC;
        }
        else
        {
            CSASSERT(LOCAL_PATH == dwFlag);
            return URL_TYPE_LOCAL;
        }
    }

    return URL_TYPE_UNKNOWN;
}

typedef struct _URL_ENABLE_MASK
{
    ENUM_URL_TYPE   UrlType;
    DWORD           dwEnableMask;
} URL_ENABLE_MASK;


URL_ENABLE_MASK g_UrlEnableMaskTable[] =
{
    {URL_TYPE_HTTP,                        CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCERTOCSP},
    {URL_TYPE_FILE,    CSURL_SERVERPUBLISH|CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCERTOCSP|CSURL_SERVERPUBLISHDELTA},
    {URL_TYPE_LDAP,    CSURL_SERVERPUBLISH|CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCRLCDP|CSURL_ADDTOCERTOCSP|CSURL_SERVERPUBLISHDELTA},
    {URL_TYPE_FTP,     CSURL_SERVERPUBLISH|CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCERTOCSP|CSURL_SERVERPUBLISHDELTA},
    {URL_TYPE_LOCAL,   CSURL_SERVERPUBLISH                                                              |CSURL_SERVERPUBLISHDELTA},
    {URL_TYPE_UNC,     CSURL_SERVERPUBLISH|CSURL_ADDTOCERTCDP|CSURL_ADDTOFRESHESTCRL|CSURL_ADDTOCERTOCSP|CSURL_SERVERPUBLISHDELTA},
};

DWORD
DetermineURLEnableMask(
    IN ENUM_URL_TYPE   UrlType)
{
    DWORD  i;
    DWORD  dwMask = 0x0;

    for (i = 0; i < ARRAYSIZE(g_UrlEnableMaskTable); ++i)
    {
        if (UrlType == g_UrlEnableMaskTable[i].UrlType)
        {
            dwMask = g_UrlEnableMaskTable[i].dwEnableMask;
            break;
        }
    }
    return dwMask;
}



HRESULT 
ExpandDisplayString(
     IN LPCWSTR szContractedString,
     OUT LPWSTR* ppszDisplayString)
{
    HRESULT hr;
    DWORD dwChars;
    int i;
    
    LPCWSTR args[ARRAYSIZE(g_displayStrings)];
    for (i=0; i<ARRAYSIZE(g_displayStrings); i++)
    {
        args[i] = *g_displayStrings[i].pcstrExpansionString;
    }

    dwChars = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING,
        szContractedString,
        0, //msgid
        0, //langid
        (LPWSTR)ppszDisplayString,
        1,  // minimum chars to alloc
        (va_list *)args);

    if (dwChars == 0)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto Ret;
    }

    hr = S_OK;
Ret:

    return hr;
}

HRESULT
ContractDisplayString(
     IN LPCWSTR szDisplayString,
     OUT LPWSTR* ppContractedString)
{
    HRESULT hr;
    int i;

    *ppContractedString = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(szDisplayString)+1) * sizeof(WCHAR));
    if (*ppContractedString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }

    wcscpy(*ppContractedString, szDisplayString);

    for (i=0; i<ARRAYSIZE(g_displayStrings); i++)
    {
        DWORD chContractedToken, chExpansionString;

        LPWSTR pszFound = wcsstr(*ppContractedString, *g_displayStrings[i].pcstrExpansionString);
        while(pszFound)
        {
            // calc commonly used values
            chContractedToken = wcslen(g_displayStrings[i].szContractedToken);
            chExpansionString = wcslen(*g_displayStrings[i].pcstrExpansionString);

            // replace with token
            CopyMemory(pszFound, g_displayStrings[i].szContractedToken, chContractedToken*sizeof(WCHAR));

            // slide rest of string left
            MoveMemory(
                &pszFound[chContractedToken],         // destination
                &pszFound[chExpansionString],         // source
                (wcslen(&pszFound[chExpansionString])+1) *sizeof(WCHAR) );

            // step Found over insertion
            pszFound += chContractedToken;

            // find any other ocurrences after this one
            pszFound = wcsstr(pszFound, *g_displayStrings[i].pcstrExpansionString);
        }
    }

    hr = S_OK;
Ret:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\uuids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       uuids.h
//
//--------------------------------------------------------------------------

const LONG UNINITIALIZED = -1;


enum SCOPE_TYPES
{
    UNINITIALIZED_ITEM  = 0,

    SCOPE_LEVEL_ITEM    = 111,
    RESULT_ITEM         = 222,
    CA_LEVEL_ITEM       = 333,
};

// Sample folder types
enum FOLDER_TYPES
{
    // certsvr machine node
    MACHINE_INSTANCE = 0x8000,

    // certsvr root node
    SERVER_INSTANCE = 0x8007,
    
    // server instance sub-folders
    SERVERFUNC_CRL_PUBLICATION = 0x8100,
    SERVERFUNC_ISSUED_CERTIFICATES = 0x8101,
    SERVERFUNC_PENDING_CERTIFICATES = 0x8102,
    SERVERFUNC_FAILED_CERTIFICATES = 0x8103,
    SERVERFUNC_ALIEN_CERTIFICATES = 0x8104,
    SERVERFUNC_ISSUED_CRLS = 0x8105,
    SERVERFUNC_ALL_FOLDERS = 0x81ff,

    NONE = 0xFFFF
};

#if DBG
#define _DEBUGUUIDS
#endif

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
#ifdef _DEBUGUUIDS
        OutputDebugString(L"CERTMMC: Release called on NULL interface ptr\n"); 
#endif
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const CLSID CLSID_About; 

///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// Static NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeMachineInstance;
extern const WCHAR*  cszNodeTypeMachineInstance;

extern const GUID cNodeTypeServerInstance;
extern const WCHAR* cszNodeTypeServerInstance;

extern const GUID cNodeTypeCRLPublication;
extern const WCHAR* cszNodeTypeCRLPublication;

// nodetype for Issued Certs
extern const GUID cNodeTypeIssuedCerts;
extern const WCHAR* cszNodeTypeIssuedCerts;

// nodetype for Pending Certs
extern const GUID cNodeTypePendingCerts;
extern const WCHAR* cszNodeTypePendingCerts;

// nodetype for Failed Certs
extern const GUID cNodeTypeFailedCerts;
extern const WCHAR* cszNodeTypeFailedCerts;

// nodetype for Alien Certs
extern const GUID cNodeTypeAlienCerts;
extern const WCHAR* cszNodeTypeAlienCerts;

// nodetype for Issued CRLs
extern const GUID cNodeTypeIssuedCRLs;
extern const WCHAR* cszNodeTypeIssuedCRLs;
extern BOOL g_fCertViewOnly;


// Dynamically created objects.
extern const GUID cNodeTypeDynamic;
extern const wchar_t*  cszNodeTypeDynamic;


//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem;
extern const wchar_t*  cszObjectTypeResultItem;


//
//
//////////////////////////////////////////////////////////////////////////////


extern const WCHAR* SNAPIN_INTERNAL;

// Published context information for extensions to extend
extern const WCHAR* SNAPIN_CA_INSTALL_TYPE;
extern const WCHAR* SNAPIN_CA_COMMON_NAME;
extern const WCHAR* SNAPIN_CA_MACHINE_NAME;
extern const WCHAR* SNAPIN_CA_SANITIZED_NAME;
extern const WCHAR* SNAPIN_CA_ROLES;

struct INTERNAL 
{
    INTERNAL() 
    {
        m_type = CCT_UNINITIALIZED; 
        m_cookie = -1;
        ZeroMemory(&m_clsid, sizeof(CLSID));
    };

    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;         // What context is the data object.
    MMC_COOKIE          m_cookie;       // What object the cookie represents
    CString             m_string;       // 
    CLSID               m_clsid;       // Class ID of who created this data object

    INTERNAL & operator=(const INTERNAL& rhs) 
    { 
        if (&rhs == this)
            return *this;

        // Deep copy the information
        m_type = rhs.m_type; 
        m_cookie = rhs.m_cookie; 
        m_string = rhs.m_string;
        memcpy(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

        return *this;
    } 

    BOOL operator==(const INTERNAL& rhs) 
    {
        return rhs.m_string == m_string;
    }
};

// Debug instance counter
#ifdef _DEBUGUUIDS
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%hs has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "CertMMC: Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certreq\certreq.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certreq.cpp
//
//  Contents:   Cert Store API Tests: Create and Add a chain of certificates
//              and CRLs to the store.
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    07-Mar-96   philh   created
//		10-Oct-96   jerryk  modified
//
//--------------------------------------------------------------------------

#define __DIR__		"certreq"

#define CMSG_SIGNER_ENCODE_INFO_HAS_CMS_FIELDS
#define CMSG_SIGNED_ENCODE_INFO_HAS_CMS_FIELDS
#include <windows.h>
#include <stdlib.h>
#include <locale.h>
#include <io.h>
#include <fcntl.h>
#include <tchar.h>
#include <assert.h>
#include <wincrypt.h>
#include "certlib.h"
#include <certsrv.h>
#include <certca.h>
#include <commdlg.h>
#include <xenroll.h>
#include <common.ver>
#include "resource.h"
#include "csdisp.h"
#include "cscsp.h"
#include "csprop.h"
#include "clibres.h"
#include "csresstr.h"


#define __dwFILE__	__dwFILE_CERTREQ_CERTREQ_CPP__


#define CR_IN_CERT	CR_IN_FORMATMASK

#define wprintf	myConsolePrintf

#define WM_DOCERTREQDIALOGS		WM_USER+0

HINSTANCE g_hInstance;

typedef struct _IDSUSAGE {
    DWORD idsVerb;
    DWORD idsOptions;
    WCHAR const *pwszVerb;
} IDSUSAGE;

#define cmdNONE			MAXDWORD

IDSUSAGE g_aidsUsage[] = {
#define cmdSUBMITREQUEST	0
    { IDS_USAGE_VERB_DEFAULT, IDS_USAGE_OPTIONS_DEFAULT, L"Submit" },

#define cmdRETRIEVEPENDING	1
    { IDS_USAGE_VERB_RETRIEVE, IDS_USAGE_OPTIONS_RETRIEVE, L"Retrieve" },

#define cmdNEWREQUEST		2
    { IDS_USAGE_VERB_NEW, IDS_USAGE_OPTIONS_NEW, L"New" },

#define cmdACCEPTRESPONSE	3
    { IDS_USAGE_VERB_ACCEPT, IDS_USAGE_OPTIONS_ACCEPT, L"Accept" },

#define cmdQUALIFIEDREQUEST	4
    { IDS_USAGE_VERB_POLICY, IDS_USAGE_OPTIONS_POLICY, L"Policy" },

#define cmdSIGNREQUEST		5
    { IDS_USAGE_VERB_SIGN, IDS_USAGE_OPTIONS_SIGN, L"Sign" },
};


WCHAR *g_apwszOptionStrings[] = {
    L"any",		// %1
    L"attrib",		// %2
    L"binary",		// %3
    L"cert",		// %4
    L"config",		// %5
    L"crl",		// %6
    L"f",		// %7
    L"q",		// %8
    L"rpc",		// %9
    L"v",		// %10
    L"?",		// %11
    L"v1",		// %12
    L"idispatch",	// %13
};



DWORD g_dwCommand = cmdNONE;

BOOL g_fAny = FALSE;
BOOL g_fRPC = FALSE;
BOOL g_fIDispatch = FALSE;
BOOL g_fForce = FALSE;
BOOL g_fQuiet = FALSE;
BOOL g_fV1Interface = FALSE;
BOOL g_fFullUsage = FALSE;
BOOL g_fVerbose = FALSE;
BOOL g_idError = 0;
LONG g_dwOutFormat = CV_OUT_BASE64REQUESTHEADER;
DWORD g_dwUIFlag = CC_UIPICKCONFIG;
DWORD g_dwCRLIn = 0;
DWORD g_dwCRLOut = 0;

WCHAR *g_pwszInfErrorString = NULL;
WCHAR *g_pwszErrorString = NULL;
WCHAR *g_pwszUnreferencedSectionNames = NULL;

WCHAR *g_pwszConfig = NULL;
WCHAR *g_pwszCertCN = NULL;
WCHAR const g_wszNewLine[] = L"\n";
CHAR const *g_pszObjIdHash = szOID_OIWSEC_sha1;


#define wszINFSECTION_NEWREQUEST	L"NewRequest"
#define wszINFKEY_SUBJECT		L"Subject"
#define wszINFKEY_PRIVATEKEYARCHIVE	L"PrivateKeyArchive"
#define wszINFKEY_KEYSPEC		L"KeySpec"
#define wszINFKEY_KEYLENGTH		L"KeyLength"
#define wszINFKEY_RENEWALCERT		L"RenewalCert"
#define wszINFKEY_SMIME			L"SMIME"
#define wszINFKEY_EXPORTABLE		L"Exportable"
#define wszINFKEY_USERPROTECTED		L"UserProtected"
#define wszINFKEY_KEYCONTAINER		L"KeyContainer"
#define wszINFKEY_HASHALGID		L"HashAlgId"
#define wszINFKEY_HASHALGORITHM		L"HashAlgorithm"
#define wszINFKEY_MACHINEKEYSET		L"MachineKeySet"
#define wszINFKEY_SILENT		L"Silent"
#define wszINFKEY_PROVIDERNAME		L"ProviderName"
#define wszINFKEY_PROVIDERTYPE		L"ProviderType"
#define wszINFKEY_USEEXISTINGKEYSET	L"UseExistingKeySet"
#define wszINFKEY_REQUESTERNAME		wszPROPREQUESTERNAME
#define wszINFKEY_REQUESTTYPE		L"RequestType"
#define wszINFKEY_KEYUSAGE		L"KeyUsage"
#define wszINFKEY_ENCIPHERONLY		L"EncipherOnly"

#define wszINFVALUE_REQUESTTYPE_PKCS101	L"PKCS10-"
#define wszINFVALUE_REQUESTTYPE_PKCS10	L"PKCS10"
#define wszINFVALUE_REQUESTTYPE_PKCS7	L"PKCS7"
#define wszINFVALUE_REQUESTTYPE_CMC	L"CMC"


typedef struct _INFUSAGE
{
    WCHAR const *pwszKey;
} INFUSAGE;

WCHAR const *g_apwszInfKeyNewRequest[] = {
    wszINFKEY_SUBJECT		L" = \"CN=..,OU=...,DC=...\"",
    wszINFKEY_PRIVATEKEYARCHIVE	L" = TRUE",
    wszINFKEY_KEYSPEC		L" = 1",
    wszINFKEY_KEYLENGTH		L" = 1024",
    wszINFKEY_RENEWALCERT	L" = CertId",
    wszINFKEY_SMIME		L" = TRUE",
    wszINFKEY_EXPORTABLE	L" = TRUE",
    wszINFKEY_USERPROTECTED	L" = TRUE",
    wszINFKEY_KEYCONTAINER	L" = \"...\"",
#if 0
    wszINFKEY_HASHALGID		L" = ???",
    wszINFKEY_HASHALGORITHM	L" = ???",
#endif
    wszINFKEY_MACHINEKEYSET	L" = TRUE",
    wszINFKEY_SILENT		L" = TRUE",
    wszINFKEY_PROVIDERNAME	L" = \"" MS_ENHANCED_PROV_W  L"\"",
    wszINFKEY_PROVIDERTYPE	L" = 1",
    wszINFKEY_USEEXISTINGKEYSET	L" = TRUE",
    wszINFKEY_REQUESTERNAME	L" = DOMAIN\\User",
    wszINFKEY_REQUESTTYPE	L" = " wszINFVALUE_REQUESTTYPE_PKCS10
				L" | " wszINFVALUE_REQUESTTYPE_PKCS101
				L" | " wszINFVALUE_REQUESTTYPE_PKCS7
				L" | " wszINFVALUE_REQUESTTYPE_CMC,
    wszINFKEY_KEYUSAGE		L" = 0x80",
    wszINFKEY_ENCIPHERONLY	L" = TRUE",
};

HRESULT
GetCMCTemplateName(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OUT BOOL *pfCA,
    OUT WCHAR **ppwszTemplateName);


//  Save eror string: "foo.inf" or "foo.inf(key = "value", "value")"

HRESULT
SetErrorStringInf(
    IN WCHAR const *pwszString,
    OPTIONAL IN INFVALUES *pInfValues)
{
    HRESULT hr;
    
    if (NULL == g_pwszErrorString && NULL != pwszString)
    {
	DWORD cwc = wcslen(pwszString);
	DWORD i;
	
	if (NULL != pInfValues && NULL != pInfValues->pwszKey)
	{
	    cwc += 1 + wcslen(pInfValues->pwszKey) + 2 + 1;

	    for (i = 0; i < pInfValues->cValues; i++)
	    {
		if (NULL == pInfValues->rgpwszValues[i])
		{
		    break;
		}
		if (0 != i)
		{
		    cwc++;
		}
		cwc += 2 + wcslen(pInfValues->rgpwszValues[i]) + 1;
	    }
	}
	g_pwszErrorString = (WCHAR *) LocalAlloc(
					    LMEM_FIXED,
					    (cwc + 1) * sizeof(WCHAR));
	if (NULL == g_pwszErrorString)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(g_pwszErrorString, pwszString);

	if (NULL != pInfValues && NULL != pInfValues->pwszKey)
	{
	    wcscat(g_pwszErrorString, wszLPAREN);
	    wcscat(g_pwszErrorString, pInfValues->pwszKey);
	    wcscat(g_pwszErrorString, L" =");

	    for (i = 0; i < pInfValues->cValues; i++)
	    {
		if (NULL == pInfValues->rgpwszValues[i])
		{
		    break;
		}
		if (0 != i)
		{
		    wcscat(g_pwszErrorString, L",");
		}
		wcscat(g_pwszErrorString, L" \"");
		wcscat(g_pwszErrorString, pInfValues->rgpwszValues[i]);
		wcscat(g_pwszErrorString, L"\"");
	    }
	    wcscat(g_pwszErrorString, wszRPAREN);
	}
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
SetErrorString(
    IN WCHAR const *pwszString)
{
    SetErrorStringInf(pwszString, NULL);
}


HRESULT
DisplayResourceString(
    IN DWORD idsMsg,
    OPTIONAL IN WCHAR const * const *papwszString,
    OPTIONAL OUT WCHAR **ppwszFormatted)
{
    HRESULT hr;
    WCHAR *pwszRaw = NULL;
    WCHAR *pwszFormatted = NULL;

    if (NULL != ppwszFormatted)
    {
	*ppwszFormatted = NULL;
    }
    hr = myLoadRCString(g_hInstance, idsMsg, &pwszRaw);
    _JumpIfError(hr, error, "myLoadRCString");

    if (0 == FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_STRING |
			FORMAT_MESSAGE_ARGUMENT_ARRAY,
		    (VOID *) pwszRaw,
		    0,              // dwMessageID
		    0,              // dwLanguageID
		    (LPWSTR) &pwszFormatted,
		    0,
		    (va_list *) papwszString))
    {
	hr = myHLastError();
	wprintf(pwszRaw);
	_JumpError(hr, error, "FormatMessage");
    }
    if (NULL != ppwszFormatted)
    {
	*ppwszFormatted = pwszFormatted;
	pwszFormatted = NULL;
    }
    else
    {
	wprintf(pwszFormatted);
    }

error:
    if (NULL != pwszRaw)
    {
	LocalFree(pwszRaw);
    }
    if (NULL != pwszFormatted)
    {
	LocalFree(pwszFormatted);
    }
    return(hr);
}


DWORD g_aidsOptions[] =
{
    IDS_USAGE_OPTION_ANY,
    IDS_USAGE_OPTION_ATTRIB,
    IDS_USAGE_OPTION_BINARY,
    IDS_USAGE_OPTION_CERT,
    IDS_USAGE_OPTION_CONFIG,
    IDS_USAGE_OPTION_CRL,
    IDS_USAGE_OPTION_F,
    IDS_USAGE_OPTION_Q,
    IDS_USAGE_OPTION_RPC,
    IDS_USAGE_OPTION_VERBOSE,
    IDS_USAGE_OPTION_QUESTION,
};


DWORD g_aidsOptionsFull[] =
{
    IDS_USAGE_OPTION_V1,
    IDS_USAGE_OPTION_IDISPATCH,
};


// Option description formatting:
// Resource string contains "%2 <Arg>\nDescription\nMore description\n"
// To format:
//     insert "  -" in front of the first line and skip the newline,
//     insert space to pad out to N-2 columns and "- " before the second line,
//     insert space to pad out to N columns before all additional lines.

#define cwcINDENT 28   // ----+
                       //     |
/*                            v
    -Optiom <Arg>           - Description\n
                              More description\n
*/


VOID
DisplayOptionList(
    IN DWORD cOpt,
    IN DWORD *aidsOpt)
{
    DWORD i;

    for (i = 0; i < cOpt; i++)
    {
	WCHAR *pwszFormatted = NULL;
	WCHAR const *pwszPrefix;
	WCHAR *pwsz;
	DWORD j;
	DWORD iLine;
	DWORD cwc0;

	DisplayResourceString(aidsOpt[i], g_apwszOptionStrings, &pwszFormatted);
	if (NULL == pwszFormatted)
	{
	    continue;
	}

	pwsz = pwszFormatted;
	iLine = 0;
	cwc0 = 0;
	while (L'\0' != *pwsz)
	{
	    WCHAR const *pwszNewLine = L"\n";
	    DWORD cwcPad;

	    j = wcscspn(pwsz, L"\r\n");

	    switch (iLine)
	    {
		WCHAR wc;

		case 0:
		    cwcPad = 2;
		    pwszPrefix = L"-";
		    wc = pwsz[j];
		    pwsz[j] = L'\0';
		    cwc0 = cwcPad +
				wcslen(pwszPrefix) +
				myGetDisplayLength(pwsz);
		    pwsz[j] = wc;
		    pwszNewLine = L"";
		    break;

		case 1:
		    cwcPad = 1;
		    if (cwcINDENT > 2 + cwc0)
		    {
			cwcPad = cwcINDENT - (2 + cwc0);
		    }
		    pwszPrefix = L"- ";
		    break;

		default:
		    cwcPad = cwcINDENT;
		    pwszPrefix = L"";
		    break;
	    }
	    wprintf(
		L"%*ws%ws%.*ws%ws",
		cwcPad,
		L"",
		pwszPrefix,
		j,
		pwsz,
		pwszNewLine);

	    pwsz += j;
	    if (L'\r' == *pwsz)
	    {
		pwsz++;
	    }
	    if (L'\n' == *pwsz)
	    {
		pwsz++;
	    }
	    iLine++;
	}
	LocalFree(pwszFormatted);
    }
}


VOID
Usage(
    IN BOOL fError)
{
    IDSUSAGE *pidsUsage;
    IDSUSAGE *pidsUsageEnd;
    BOOL fShowOptions;

    DisplayResourceString(IDS_USAGE_GENERAL, NULL, NULL);
    wprintf(L"\n");
    switch (g_dwCommand)
    {
	case cmdSUBMITREQUEST:
	case cmdRETRIEVEPENDING:
	case cmdNEWREQUEST:
	case cmdACCEPTRESPONSE:
	case cmdQUALIFIEDREQUEST:
	case cmdSIGNREQUEST:
	    pidsUsage = &g_aidsUsage[g_dwCommand];
	    pidsUsageEnd = &pidsUsage[1];
	    fShowOptions = TRUE;
	    break;

	case cmdNONE:
	default:
	    pidsUsage = g_aidsUsage;
	    pidsUsageEnd = &g_aidsUsage[ARRAYSIZE(g_aidsUsage)];
	    fShowOptions = g_fVerbose;
	    break;
    }
    if (fError)
    {
	fShowOptions = FALSE;
    }
    for ( ; pidsUsage < pidsUsageEnd; pidsUsage++)
    {
	DisplayResourceString(pidsUsage->idsVerb, &pidsUsage->pwszVerb, NULL);
	if (fShowOptions)
	{
	    DisplayResourceString(pidsUsage->idsOptions, g_apwszOptionStrings, NULL);
	}
	wprintf(L"\n");
    }
    if (fShowOptions)
    {
	DisplayResourceString(IDS_USAGE_OPTIONS_DESCRIPTION, NULL, NULL);
	DisplayOptionList(ARRAYSIZE(g_aidsOptions), g_aidsOptions);
	if (g_fFullUsage)
	{
	    DisplayOptionList(ARRAYSIZE(g_aidsOptionsFull), g_aidsOptionsFull);
	}
	wprintf(L"\n");
	DisplayResourceString(IDS_USAGE_DESCRIPTION, g_apwszOptionStrings, NULL);
    }
    if (!fError)
    {
	if ((cmdNEWREQUEST == g_dwCommand ||
	    (cmdNONE == g_dwCommand && g_fVerbose)))
	{
	    DWORD i;
	    
	    wprintf(L"[%ws]\n", wszINFSECTION_NEWREQUEST);
	    for (i = 0; i < ARRAYSIZE(g_apwszInfKeyNewRequest); i++)
	    {
		wprintf(L"    %ws\n", g_apwszInfKeyNewRequest[i]);
	    }
	}
    }
    exit(0);
}


VOID
AppendAttributeString(
    IN OUT WCHAR *pwszOut,
    IN WCHAR const *pwszIn)
{
    pwszOut += wcslen(pwszOut);
    while (L'\0' != *pwszIn)
    {
	switch (*pwszIn)
	{
	    case L';':
		*pwszOut = L'\n';
		break;

	    case L'\\':
		if (L'n' == pwszIn[1])
		{
		    *pwszOut = L'\n';
		    pwszIn++;
		    break;
		}
		if (L'r' == pwszIn[1])
		{
		    *pwszOut = L'\r';
		    pwszIn++;
		    break;
		}
		// else FALLTHROUGH

	    default:
		*pwszOut = *pwszIn;
		break;
	}
	pwszOut++;
	pwszIn++;
    }
    *pwszOut = L'\0';
}


HRESULT
crCombineAttributes(
    IN WCHAR const *pwszAttributesAdd,
    IN OUT WCHAR **ppwszAttributesExisting)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszAttributesExisting = *ppwszAttributesExisting;
    WCHAR *pwsz;
    
    cwc = wcslen(pwszAttributesAdd) + 1;
    if (NULL != pwszAttributesExisting)
    {
	cwc += wcslen(pwszAttributesExisting) + 1;
    }
    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    
    pwsz[0] = L'\0';
    if (NULL != pwszAttributesExisting)
    {
	AppendAttributeString(pwsz, pwszAttributesExisting);
	AppendAttributeString(pwsz, L"\\n");
	LocalFree(pwszAttributesExisting);
    }
    AppendAttributeString(pwsz, pwszAttributesAdd);
    *ppwszAttributesExisting = pwsz;
    hr = S_OK;

error:
    return(hr);
}


VOID
crMissingFileArg()
{
    HRESULT hr;
    WCHAR *pwszMsg = NULL;

    hr = myLoadRCString(g_hInstance, IDS_ERROR_NO_FILENAME, &pwszMsg);
    _JumpIfError(hr, error, "myLoadRCString");

    CSASSERT(NULL != pwszMsg);
    wprintf(pwszMsg);
    wprintf(g_wszNewLine);

error:
    if (NULL != pwszMsg)
    {
	LocalFree(pwszMsg);
    }
}


HRESULT
crGetOpenFileName(
    IN HWND hWndOwner,
    IN UINT idsOpenTitle,
    IN UINT idsFileFilter,
    IN UINT idsFileDefExt,
    OUT WCHAR **ppwszOFN)
{
    HRESULT hr;
    
    if (g_fQuiet)
    {
	crMissingFileArg();
	Usage(TRUE);
    }

    // Put up a file dialog to prompt the user for Inf File
    // 0 == hr means dialog was cancelled, we cheat because S_OK == 0

    hr = myGetOpenFileName(
		hWndOwner,
		NULL,				// hInstance
		idsOpenTitle,
		idsFileFilter,
		idsFileDefExt,
		OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
		NULL,				// no default file
		ppwszOFN);
    _JumpIfError(hr, error, "myGetOpenFileName");

    if (NULL == *ppwszOFN)
    {
	// cancelled:
	// see public\sdk\inc\cderr.h for real CommDlgExtendedError errors

	hr = myHError(CommDlgExtendedError());
	if (S_OK == hr)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	}
	_JumpError(hr, error, "myGetOpenFileName");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
crOverwriteFileAllowed(
    IN HWND hWndOwner,
    IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    int rc = IDCANCEL;
    WCHAR *pwszTitle = NULL;
    WCHAR *pwszMessage = NULL;
    WCHAR *pwsz = NULL;

    if (!g_fForce && myDoesFileExist(pwszfnOut))
    {
	if (!g_fQuiet)
	{
	    DWORD cwc;

	    hr = myLoadRCString(g_hInstance, IDS_CERTREQ_TITLE, &pwszTitle);
	    _JumpIfError(hr, error, "myLoadRCString");

	    hr = myLoadRCString(g_hInstance, IDS_OVERWRITE_FILE, &pwszMessage);
	    _JumpIfError(hr, error, "myLoadRCString");

	    cwc = wcslen(pwszMessage) + 2 + wcslen(pwszfnOut);
	    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (1 + cwc) * sizeof(WCHAR));
	    if (NULL == pwsz)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    wcscpy(pwsz, pwszMessage);
	    wcscat(pwsz, L"\r\n");
	    wcscat(pwsz, pwszfnOut);

	    rc = MessageBox(
		    hWndOwner,
		    pwsz,
		    pwszTitle,
		    MB_OKCANCEL |
			MB_DEFBUTTON2 |
			MB_ICONWARNING |
			MB_SETFOREGROUND);
	}
	if (IDOK != rc)
	{
	    SetErrorString(pwszfnOut);
	    hr = g_fQuiet?
		    HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) :
		    HRESULT_FROM_WIN32(ERROR_CANCELLED);
	    _JumpErrorStr(hr, error, "File Exists", pwszfnOut);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    if (NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if (NULL != pwszMessage)
    {
        LocalFree(pwszMessage);
    }
    return(hr);
}


HRESULT
WriteCertificateOrRequest(
    IN HWND hWndOwner,
    OPTIONAL IN DISPATCHINTERFACE *pdiRequest,
    OPTIONAL IN BYTE const *pbOut,
    IN DWORD cbOut,
    IN DWORD Flags,
    IN DWORD idsTitle,
    IN DWORD idsFilter,
    IN DWORD idsDefExt,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    WCHAR *pwszOFN = NULL;
    BSTR strCert = NULL;
    CHAR *pszCert = NULL;
    DWORD decFlags = CRYPT_STRING_BINARY;
    BOOL fCheckFileOverwriteOK = TRUE; // careful not to overwrite without prompting user

    if (NULL == pwszfnOut)
    {
	if (g_fQuiet)
	{
	    crMissingFileArg();
	    Usage(TRUE);
	}

	// Put up a file dialog to prompt the user for Cert file
	// 0 == hr means dialog was cancelled, we cheat because S_OK == 0

        hr = myGetSaveFileName(
		    hWndOwner,
		    NULL,			// hInstance
		    idsTitle,
		    idsFilter,
		    idsDefExt,
		    OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
		    NULL,			// no default file
		    &pwszOFN);
	_JumpIfError(hr, error, "myGetSaveFileName");

        fCheckFileOverwriteOK = FALSE; // OFN_OVERWRITEPROMPT should have prompted if necessary

        if (NULL == pwszOFN)
        {
            // cancelled:
	    // see public\sdk\inc\cderr.h for real CommDlgExtendedError errors

	    hr = myHError(CommDlgExtendedError());
	    _JumpError(hr, error, "myGetSaveFileName");
        }
	pwszfnOut = pwszOFN;

	hr = myIsDirWriteable(pwszfnOut, TRUE);
	if (S_OK != hr)
	{
	    SetErrorString(pwszfnOut);
	    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnOut);
	}
    }

    if (NULL == pbOut)
    {
	hr = Request_GetCertificate(pdiRequest, Flags, &strCert);
	_JumpIfError(hr, error, "Request_GetCertificate");

	if (CR_OUT_BINARY == (CR_OUT_ENCODEMASK & Flags))
	{
	    cbOut = SysStringByteLen(strCert);
	    pbOut = (BYTE const *) strCert;
	}
	else
	{
	    if (!ConvertWszToSz(&pszCert, strCert, -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "ConvertWszToSz(cert)");
	    }
	    cbOut = strlen(pszCert);
	    pbOut = (BYTE const *) pszCert;
	}
    }
    else
    {
	decFlags = CR_OUT_ENCODEMASK & Flags;
	CSASSERT(CSExpr(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER));
	CSASSERT(CSExpr(CR_OUT_BINARY == CRYPT_STRING_BINARY));
    }

    if (fCheckFileOverwriteOK)
    {
        hr = crOverwriteFileAllowed(hWndOwner, pwszfnOut);
        _JumpIfError(hr, error, "crOverwriteFileAllowed");
    }

    hr = EncodeToFileW(
		pwszfnOut,
		pbOut,
		cbOut,
		DECF_FORCEOVERWRITE | decFlags);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnOut);
	_JumpErrorStr(hr, error, "EncodeToFileW", pwszfnOut);
    }

error:
    if (NULL != strCert)
    {
	SysFreeString(strCert);
    }
    if (NULL != pszCert)
    {
	LocalFree(pszCert);
    }
    if (NULL != pwszOFN)
    {
	LocalFree(pwszOFN);
    }
    return(hr);
}


HRESULT
GetLong(
    WCHAR const *pwszIn,
    LONG *pLong)
{
    HRESULT hr = E_INVALIDARG;
    WCHAR const *pwsz;
    LONG l;

    pwsz = pwszIn;
    if (NULL == pwsz)
    {
	_JumpError(hr, error, "NULL parm");
    }
    if (L'\0' == *pwsz)
    {
	_JumpError(hr, error, "empty string");
    }
    if (L'0' == *pwsz && (L'x' == pwsz[1] || L'X' == pwsz[1]))
    {
	l = 0;
	pwsz += 2;
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    if (!iswxdigit(*pwsz))
	    {
		_JumpErrorStr(hr, error, "Non-hex digit", pwszIn);
	    }
	    if (0xf0000000 & l)
	    {
		_JumpErrorStr(hr, error, "overflow", pwszIn);
	    }
	    l <<= 4;
	    if (iswdigit(*pwsz))
	    {
		l |= *pwsz - L'0';
	    }
	    else if (L'A' <= *pwsz && L'F' >= *pwsz)
	    {
		l |= *pwsz - L'A' + 10;
	    }
	    else
	    {
		l |= *pwsz - L'a' + 10;
	    }
	}
	*pLong = l;
    }
    else
    {
	LARGE_INTEGER li;
	
	li.QuadPart = 0;
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    if (!iswdigit(*pwsz))
	    {
		_JumpErrorStr2(hr, error, "Non-decimal digit", pwszIn, hr);
	    }
	    li.QuadPart *= 10;
	    li.QuadPart += *pwsz - L'0';
	    if (0 != li.HighPart || 0 > (LONG) li.LowPart)
	    {
		_JumpErrorStr2(hr, error, "overflow", pwszIn, hr);
	    }
	}
	*pLong = li.LowPart;
    }
    hr = S_OK;
    //wprintf(L"GetLong(%ws) --> %x (%d)\n", pwszIn, *pLong, *pLong);

error:
    return(hr);
}


HRESULT
IsSubjectTypeCA(
    IN CERT_EXTENSION const *pExt,
    OUT BOOL *pfCA)
{
    HRESULT hr;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    DWORD cb;
    
    *pfCA = FALSE;
    cb = sizeof(Constraints);
    if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_BASIC_CONSTRAINTS2,
			pExt->Value.pbData,
			pExt->Value.cbData,
			0,
			&Constraints,
			&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }
    if (Constraints.fCA)
    {
	*pfCA = TRUE;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
GetExtensionsTemplateName(
    IN CERT_EXTENSION const *rgExtension,
    IN DWORD cExtension,
    IN OUT BOOL *pfCA,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    CERT_EXTENSION const *pExt;
    CERT_EXTENSION const *pExtEnd;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    CERT_NAME_VALUE *pName = NULL;
    DWORD cb;

    pExtEnd = &rgExtension[cExtension];
    for (pExt = rgExtension; pExt < pExtEnd; pExt++)
    {
	if (NULL == *ppwszTemplateName)
	{
	    if (0 == strcmp(pExt->pszObjId, szOID_CERTIFICATE_TEMPLATE))
	    {
		// V2 template info extension

		if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_CERTIFICATE_TEMPLATE,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pTemplate,
			    &cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "Policy:myDecodeObject");
		}
		if (!myConvertSzToWsz(ppwszTemplateName, pTemplate->pszObjId, -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "Policy:myConvertSzToBstr");
		}
	    }
	    else
	    if (0 == strcmp(pExt->pszObjId, szOID_ENROLL_CERTTYPE_EXTENSION))
	    {
		// V1 template name extension

		if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pName,
			    &cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		hr = myDupString(
			    (WCHAR const *) pName->Value.pbData,
			    ppwszTemplateName);
		_JumpIfError(hr, error, "myDupString");
	    }
	}
	if (!*pfCA)
	{
	    if (0 == strcmp(pExt->pszObjId, szOID_BASIC_CONSTRAINTS2))
	    {
		hr = IsSubjectTypeCA(pExt, pfCA);
		_JumpIfError(hr, error, "IsSubjectTypeCA");
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pTemplate)
    {
	LocalFree(pTemplate);
    }
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    return(hr);
}


HRESULT
GetAttributesTemplateName(
    IN CRYPT_ATTRIBUTE const *rgAttrib,
    IN DWORD cAttrib,
    IN OUT BOOL *pfCA,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    CRYPT_ATTRIBUTE const *pAttrib;
    CRYPT_ATTRIBUTE const *pAttribEnd;
    CRYPT_ATTR_BLOB *pAttrBlob;
    CERT_EXTENSIONS *pCertExtensions = NULL;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pInfo = NULL;
    DWORD cb;
    DWORD i;

    pAttribEnd = &rgAttrib[cAttrib];
    for (pAttrib = rgAttrib; pAttrib < pAttribEnd; pAttrib++)
    {
	if (0 == strcmp(pAttrib->pszObjId, szOID_CERT_EXTENSIONS) ||
	    0 == strcmp(pAttrib->pszObjId, szOID_RSA_certExtensions))
        {
            if (1 != pAttrib->cValue)
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    if (NULL != pCertExtensions)
	    {
		LocalFree(pCertExtensions);
		pCertExtensions = NULL;
	    }

	    pAttrBlob = pAttrib->rgValue;
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_EXTENSIONS,
			    pAttrBlob->pbData,
			    pAttrBlob->cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pCertExtensions,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    hr = GetExtensionsTemplateName(
				pCertExtensions->rgExtension,
				pCertExtensions->cExtension,
				pfCA,
				ppwszTemplateName);
	    _JumpIfError(hr, error, "GetExtensionsTemplateName");
	}
	else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ENROLLMENT_NAME_VALUE_PAIR))
	{
	    for (i = 0; i < pAttrib->cValue; i++)
	    {
		if (NULL != pInfo)
		{
		    LocalFree(pInfo);
		    pInfo = NULL;
		}
		pAttrBlob = &pAttrib->rgValue[i];
		if (!myDecodeNameValuePair(
					X509_ASN_ENCODING,
					pAttrBlob->pbData,
					pAttrBlob->cbData,
					CERTLIB_USE_LOCALALLOC,
					&pInfo,
					&cb))
		{
		    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    _JumpError(hr, error, "myDecodeNameValuePair");

		    // if the attribute name & value are both non-empty ...
		}
		if (0 == LSTRCMPIS(pInfo->pwszName, wszPROPCERTTEMPLATE))
		{
		    if (NULL == *ppwszTemplateName)
		    {
			hr = myDupString(pInfo->pwszValue, ppwszTemplateName);
			_JumpIfError(hr, error, "myDupString");
		    }
		}
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pCertExtensions)
    {
	LocalFree(pCertExtensions);
    }
    if (NULL != pInfo)
    {
	LocalFree(pInfo);
    }
    return(hr);
}


HRESULT
GetPKCS10TemplateName(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OUT BOOL *pfCA,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    CERT_REQUEST_INFO *pRequestInfo = NULL;
    DWORD cb;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pRequestInfo,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = GetAttributesTemplateName(
		    pRequestInfo->rgAttribute,
		    pRequestInfo->cAttribute,
		    pfCA,
		    ppwszTemplateName);
    _JumpIfError(hr, error, "GetAttributesTemplateName");

error:
    if (NULL != pRequestInfo)
    {
	LocalFree(pRequestInfo);
    }
    return(hr);
}


HRESULT
GetCMCRequestTemplateName(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OUT BOOL *pfCA,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    BYTE *pbContents = NULL;
    DWORD cbContents;
    char *pszInnerContentObjId = NULL;

    hr = myDecodePKCS7(
		    pbIn,
		    cbIn,
		    &pbContents,
		    &cbContents,
		    NULL,		// pdwMsgType
		    &pszInnerContentObjId,
		    NULL,		// pcSigner
		    NULL,		// pcRecipient
		    NULL,		// phStore
		    NULL);		// phMsg
    _JumpIfError(hr, error, "myDecodePKCS7");

    if (NULL != pszInnerContentObjId &&
	0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA))
    {
	hr = GetCMCTemplateName(
			pbContents,
			cbContents,
			pfCA,
			ppwszTemplateName);
	_JumpIfError(hr, error, "GetCMCTemplateName");
    }
    hr = S_OK;
    
error:
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != pbContents)
    {
        LocalFree(pbContents);
    }
    return(hr);
}


HRESULT
GetCMCExtensionsTemplateName(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OUT BOOL *pfCA,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    CMC_ADD_EXTENSIONS_INFO *pcmcExt = NULL;
    DWORD cb;

    *ppwszTemplateName = NULL;

    // Decode CMC_ADD_EXTENSIONS_INFO from Attribute Blob

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_EXTENSIONS,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcExt,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = GetExtensionsTemplateName(
			pcmcExt->rgExtension,
			pcmcExt->cExtension,
			pfCA,
			ppwszTemplateName);
    _JumpIfError(hr, error, "GetExtensionsTemplateName");

error:
    if (NULL != pcmcExt)
    {
	LocalFree(pcmcExt);
    }
    return(hr);
}


HRESULT
GetCMCAttributesTemplateName(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OUT BOOL *pfCA,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    CMC_ADD_ATTRIBUTES_INFO *pcmcAttrib = NULL;
    DWORD cb;

    // Decode CMC_ADD_ATTRIBUTES_INFO from Attribute Blob

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_ATTRIBUTES,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcAttrib,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = GetAttributesTemplateName(
		    pcmcAttrib->rgAttribute,
		    pcmcAttrib->cAttribute,
		    pfCA,
		    ppwszTemplateName);
    _JumpIfError(hr, error, "GetAttributesTemplateName");

error:
    if (NULL != pcmcAttrib)
    {
	LocalFree(pcmcAttrib);
    }
    return(hr);
}


HRESULT
GetRequestAttributesTemplateName(
    IN WCHAR const *pwszAttributes,
    IN BOOL fRegInfo,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszBuf;
    WCHAR const *pwszName;
    WCHAR const *pwszValue;
    WCHAR *pwszNameAlloc = NULL;
    WCHAR *pwszValueAlloc = NULL;

    if (NULL == pwszAttributes)
    {
	hr = S_OK;
        goto error;		// silently ignore empty string
    }

    hr = myDupString(pwszAttributes, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszBuf = pwszDup;

    for (;;)
    {
	hr = myParseNextAttribute(&pwszBuf, fRegInfo, &pwszName, &pwszValue);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "myParseNextAttribute");

	if (fRegInfo)
	{
	    if (NULL != pwszNameAlloc)
	    {
		LocalFree(pwszNameAlloc);
		pwszNameAlloc = NULL;
	    }
	    if (NULL != pwszValueAlloc)
	    {
		LocalFree(pwszValueAlloc);
		pwszValueAlloc = NULL;
	    }
	    hr = myUncanonicalizeURLParm(pwszName, &pwszNameAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    hr = myUncanonicalizeURLParm(pwszValue, &pwszValueAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    pwszName = pwszNameAlloc;
	    pwszValue = pwszValueAlloc;
	}
	if (0 == LSTRCMPIS(pwszName, wszPROPCERTTEMPLATE))
	{
	    if (NULL == *ppwszTemplateName)
	    {
		hr = myDupString(pwszValue, ppwszTemplateName);
		_JumpIfError(hr, error, "myDupString");
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszNameAlloc)
    {
	LocalFree(pwszNameAlloc);
    }
    if (NULL != pwszValueAlloc)
    {
	LocalFree(pwszValueAlloc);
    }
    if (NULL != pwszDup)
    {
        LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
GetCMCRegInfoTemplateName(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    WCHAR *pwszRA = NULL;

    hr = myDecodeCMCRegInfo(pbIn, cbIn, &pwszRA);
    _JumpIfError(hr, error, "myDecodeCMCRegInfo");

    hr = GetRequestAttributesTemplateName(pwszRA, TRUE, ppwszTemplateName);
    _JumpIfError(hr, error, "GetRequestAttributesTemplateName");

error:
    if (NULL != pwszRA)
    {
	LocalFree(pwszRA);
    }
    return(hr);
}


HRESULT
GetTaggedAttributeTemplateName(
    IN CMC_TAGGED_ATTRIBUTE const *pTaggedAttribute,
    IN OUT BOOL *pfCA,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    DWORD i;
    CRYPT_ATTRIBUTE const *pAttribute = &pTaggedAttribute->Attribute;

    for (i = 0; i < pAttribute->cValue; i++)
    {
	if (0 == strcmp(szOID_CMC_ADD_EXTENSIONS, pAttribute->pszObjId))
	{
	    hr = GetCMCExtensionsTemplateName(
				pAttribute->rgValue[i].pbData,
				pAttribute->rgValue[i].cbData,
				pfCA,
				ppwszTemplateName);
	    _JumpIfError(hr, error, "GetCMCExtensionsTemplateName");
	}
	else
	if (0 == strcmp(szOID_CMC_ADD_ATTRIBUTES, pAttribute->pszObjId))
	{
	    hr = GetCMCAttributesTemplateName(
				pAttribute->rgValue[i].pbData,
				pAttribute->rgValue[i].cbData,
				pfCA,
				ppwszTemplateName);
	    _JumpIfError(hr, error, "GetCMCAttributesTemplateName");
	}
	else
	if (0 == strcmp(szOID_CMC_REG_INFO, pAttribute->pszObjId))
	{
	    hr = GetCMCRegInfoTemplateName(
				pAttribute->rgValue[i].pbData,
				pAttribute->rgValue[i].cbData,
				ppwszTemplateName);
	    _JumpIfError(hr, error, "GetCMCRegInfoTemplateName");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


// Just find the first template indicator available, and return it.

HRESULT
GetCMCTemplateName(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OUT BOOL *pfCA,
    IN OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    DWORD cb;
    CMC_DATA_INFO *pcmcData = NULL;
    DWORD i;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_DATA,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcData,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    // Process extensions and attributes

    for (i = 0; i < pcmcData->cTaggedAttribute; i++)
    {
	hr = GetTaggedAttributeTemplateName(
				&pcmcData->rgTaggedAttribute[i],
				pfCA,
				ppwszTemplateName);
	_JumpIfError(hr, error, "pkcsSetTaggedAttributes");
    }

    // Process nested CMC messages

    if (0 != pcmcData->cTaggedContentInfo)
    {
	CMC_TAGGED_CONTENT_INFO const *pTaggedContentInfo;

	// Recurse on the nested CMC message
	// Only handle one request at a time for now.

	pTaggedContentInfo = &pcmcData->rgTaggedContentInfo[0];

	hr = GetCMCRequestTemplateName(
			pTaggedContentInfo->EncodedContentInfo.pbData,
			pTaggedContentInfo->EncodedContentInfo.cbData,
			pfCA,
			ppwszTemplateName);
	_JumpIfError(hr, error, "GetCMCRequestTemplateName");
    }

    // Process nested PKCS10 requests

    if (0 != pcmcData->cTaggedRequest)
    {
	CMC_TAGGED_REQUEST const *pTaggedRequest;
	CMC_TAGGED_CERT_REQUEST const *pTaggedCertRequest;

	// Only handle one request at a time for now.

	pTaggedRequest = &pcmcData->rgTaggedRequest[0];

	// The request must be a PKCS10 request

	if (CMC_TAGGED_CERT_REQUEST_CHOICE ==
	    pTaggedRequest->dwTaggedRequestChoice)
	{
	    pTaggedCertRequest = pTaggedRequest->pTaggedCertRequest;

	    hr = GetPKCS10TemplateName(
			    pTaggedCertRequest->SignedCertRequest.pbData,
			    pTaggedCertRequest->SignedCertRequest.cbData,
			    pfCA,
			    ppwszTemplateName);
	    _JumpIfError(hr, error, "GetPKCS10TemplateName");
	}
    }
    hr = S_OK;

error:
    if (NULL != pcmcData)
    {
	LocalFree(pcmcData);
    }
    return(hr);
}


HRESULT
CheckRequestType(
    IN WCHAR const *pwszfnReq,
    OUT BYTE **ppbReq,
    OUT DWORD *pcbReq,
    OUT LONG *pFlags,
    OUT BOOL *pfSigned,
    OPTIONAL OUT BOOL *pfCA,
    OPTIONAL OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    BYTE *pbContents = NULL;
    DWORD cbContents;
    DWORD cb;
    LONG EncodingType;
    LONG RequestType;
    BYTE *pbDecoded = NULL;
    char *pszInnerContentObjId = NULL;
    CERT_CONTEXT const *pcc = NULL;
    CERT_SIGNED_CONTENT_INFO *pcsci = NULL;
    DWORD cbcsci;
    DWORD cSigner;
    DWORD cRecipient;
    BOOL fCAT;
    WCHAR *pwszTemplateNameT = NULL;

    *ppbReq = NULL;
    *pcbReq = NULL;
    *pFlags = 0;
    *pfSigned = FALSE;
    if (NULL == pfCA)
    {
	pfCA = &fCAT;
    }
    *pfCA = FALSE;
    if (NULL == ppwszTemplateName)
    {
	ppwszTemplateName = &pwszTemplateNameT;
    }
    *ppwszTemplateName = NULL;

    EncodingType = CR_IN_BASE64HEADER;
    hr = DecodeFileW(pwszfnReq, &pbReq, &cbReq, CRYPT_STRING_BASE64HEADER);
    if (S_OK != hr)
    {
	//_PrintError(hr, "DecodeFileW(CRYPT_STRING_BASE64HEADER)");
	CSASSERT(NULL == pbReq);

	EncodingType = CR_IN_BASE64;
	hr = DecodeFileW(pwszfnReq, &pbReq, &cbReq, CRYPT_STRING_BASE64);
	if (S_OK != hr)
	{
	    //_PrintError(hr, "DecodeFileW(CRYPT_STRING_BASE64)");
	    CSASSERT(NULL == pbReq);

	    EncodingType = CR_IN_BINARY;
	    hr = DecodeFileW(pwszfnReq, &pbReq, &cbReq, CRYPT_STRING_BINARY);
	    if (S_OK != hr)
	    {
		SetErrorString(pwszfnReq);
		_JumpErrorStr(hr, error, "DecodeFileW", pwszfnReq);
	    }
	}
    }
    CSASSERT(NULL != pbReq);

    RequestType = CR_IN_PKCS10;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pbReq,
		    cbReq,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbDecoded,
		    &cb))
    {
	//_PrintError(myHLastError(), "myDecodeObject(PKCS10)");
	CSASSERT(NULL == pbDecoded);

	RequestType = CR_IN_CERT;
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERT_TO_BE_SIGNED,
			pbReq,
			cbReq,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbDecoded,
			&cb))
	{
	    //_PrintError(myHLastError(), "myDecodeObject(Cert)");
	    CSASSERT(NULL == pbDecoded);

	    RequestType = CR_IN_KEYGEN;
	    if (!myDecodeKeyGenRequest(
				pbReq,
				cbReq,
				CERTLIB_USE_LOCALALLOC,
				(CERT_KEYGEN_REQUEST_INFO **) &pbDecoded,
				&cb))
	    {
		//_PrintError(myHLastError(), "myDecodeKeyGenRequest");
		CSASSERT(NULL == pbDecoded);

		RequestType = CR_IN_PKCS7; // PKCS 7 renewal request?
		hr = myDecodePKCS7(
				pbReq,
				cbReq,
				&pbContents,
				&cbContents,
				NULL,		// pdwMsgType
				&pszInnerContentObjId,
				&cSigner,
				&cRecipient,
				NULL,		// phStore
				NULL);		// phMsg
		_JumpIfError(hr, error, "myDecodePKCS7");

		if (NULL != pszInnerContentObjId &&
		    0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA))
		{
		    RequestType = CR_IN_CMC;
		    hr = GetCMCTemplateName(
				    pbContents,
				    cbContents,
				    pfCA,
				    ppwszTemplateName);
		    _JumpIfError(hr, error, "GetCMCTemplateName");

		    DBGPRINT((
			DBG_SS_CERTREQ, 
			"TemplateName = %ws\n",
			*ppwszTemplateName));
		}
		if (0 < cSigner)
		{
		    *pfSigned = TRUE;
		}
	    }
	}
    }
    if (CR_IN_CERT == RequestType ||
	CR_IN_PKCS10 == RequestType ||
	CR_IN_KEYGEN == RequestType)
    {
	if (CR_IN_CERT == RequestType)
	{
	    pcc = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pbReq,
					cbReq);
	    if (NULL == pcc)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertCreateCertificateContext");
	    }
	    hr = GetExtensionsTemplateName(
				pcc->pCertInfo->rgExtension,
				pcc->pCertInfo->cExtension,
				pfCA,
				ppwszTemplateName);
	    _JumpIfError(hr, error, "GetExtensionsTemplateName");
	}
	else if (CR_IN_PKCS10 == RequestType)
	{
	    hr = GetPKCS10TemplateName(pbReq, cbReq, pfCA, ppwszTemplateName);
	    _JumpIfError(hr, error, "GetPKCS10TemplateName");
	}
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERT,
			pbReq,
			cbReq,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pcsci,
			&cbcsci))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "myDecodeObject", CRYPT_E_ASN1_BADTAG);
	}
	else
	{
	    *pfSigned = TRUE;		// has a signature
	}
    }
    *ppbReq = pbReq;
    pbReq = NULL;
    *pcbReq = cbReq;
    *pFlags = EncodingType | RequestType;
    hr = S_OK;
    
error:
    if (NULL != pwszTemplateNameT)
    {
	LocalFree(pwszTemplateNameT);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pcsci)
    {
	LocalFree(pcsci);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    if (NULL != pbContents)
    {
        LocalFree(pbContents);
    }
    if (NULL != pbReq)
    {
        LocalFree(pbReq);
    }
    return(hr);
}


WCHAR *
wszDisposition(
    DWORD disposition)
{
    HRESULT hr;
    UINT iRsc = 0;
    WCHAR *pwszDisposition = NULL;

    switch (disposition)
    {
	case CR_DISP_INCOMPLETE:	 
	    iRsc = IDS_DISPOSITION_INCOMPLETE; 
	    break;

	case CR_DISP_ERROR:		 
	    iRsc = IDS_DISPOSITION_ERROR;
	    break;

	case CR_DISP_DENIED:
	    iRsc = IDS_DISPOSITION_DENIED;
	    break;

	case CR_DISP_ISSUED:
	    iRsc = IDS_DISPOSITION_ISSUED;
	    break;

	case CR_DISP_ISSUED_OUT_OF_BAND:
	    iRsc = IDS_DISPOSITION_ISSUED_OOB;
	    break;

	case CR_DISP_UNDER_SUBMISSION:
	    iRsc = IDS_DISPOSITION_UNDER_SUBMISSION;
	    break;

	case CR_DISP_REVOKED:
	    iRsc = IDS_DISPOSITION_REVOKED;
	    break;

	default:
	    iRsc = IDS_DISPOSITION_UNKNOWN;
	    break;
    }

    hr = myLoadRCString(g_hInstance, iRsc, &pwszDisposition);
    _PrintIfError(hr, "myLoadRCString");

    return(pwszDisposition);
}


VOID
DumpProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG PropId,
    IN WCHAR const *pwszPropId,
    IN LONG PropIndex,
    IN LONG PropType,
    OPTIONAL OUT LONG *pCount)
{
    HRESULT hr;
    LONG Flags;
    VOID *pvOut;
    BSTR str = NULL;
    LONG val;
    DATE date;
    WCHAR wszInfo[128];

    if (NULL != pCount)
    {
	*pCount = 0;
    }
    Flags = CV_OUT_BINARY;
    val = 0;
    date = 0.0;
    pvOut = NULL;
    switch (PropType)
    {
	case PROPTYPE_BINARY:
	    Flags = CV_OUT_BASE64HEADER;
	    pvOut = &str;
	    break;

	case PROPTYPE_STRING:
	    pvOut = &str;
	    break;

	case PROPTYPE_DATE:
	    pvOut = &date;
	    break;

	case PROPTYPE_LONG:
	    pvOut = &val;
	    break;
    }
    wsprintf(wszInfo, L"%ws[%u] %u", pwszPropId, PropIndex, PropType);
    hr = Request2_GetFullResponseProperty(
				pdiRequest,
				PropId,
				PropIndex,
				PropType,
				Flags,
				pvOut);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	wprintf(L"%ws: CERTSRV_E_PROPERTY_EMPTY\n", wszInfo);
    }
    _JumpIfErrorStr2(
		hr,
		error,
		"Request2_GetFullResponseProperty",
		wszInfo,
		CERTSRV_E_PROPERTY_EMPTY);

    wprintf(L"%ws:", wszInfo);

    switch (PropType)
    {
	case PROPTYPE_BINARY:
	    wprintf(L"\n%ws\n", str);
	    break;

	case PROPTYPE_STRING:
	    wprintf(L" \"%ws\"\n", str);
	    break;

	case PROPTYPE_DATE:
	    wprintf(L" %f\n", date);
	    break;

	case PROPTYPE_LONG:
	    wprintf(L" 0x%x(%u)\n", val, val);
	    if (NULL != pCount)
	    {
		*pCount = val;
	    }
	    break;
    }

error:
    if (NULL != str)
    {
	SysFreeString(str);
    }
}


VOID
DumpIndexedProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG PropId,
    IN WCHAR const *pwszPropId,
    IN LONG PropType,
    LONG Count)
{
    LONG PropIndex;

    for (PropIndex = 0; PropIndex < Count; PropIndex++)
    {
	DumpProperty(pdiRequest, PropId, pwszPropId, PropIndex, PropType, NULL);
    }
}


typedef struct _FRPROP
{
    LONG PropId;
    WCHAR *pwszPropId;
    LONG PropType;
} FRPROP;


#define _PROPARG(pt)		(pt), L#pt

FRPROP s_afrp[] =
{
    { _PROPARG(FR_PROP_BODYPARTSTRING),         PROPTYPE_STRING },
    { _PROPARG(FR_PROP_STATUS),                 PROPTYPE_LONG },
    { _PROPARG(FR_PROP_STATUSSTRING),           PROPTYPE_STRING },
    { _PROPARG(FR_PROP_OTHERINFOCHOICE),        PROPTYPE_LONG },
    { _PROPARG(FR_PROP_FAILINFO),               PROPTYPE_LONG },
    { _PROPARG(FR_PROP_PENDINFOTOKEN),          PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_PENDINFOTIME),           PROPTYPE_DATE },
    { _PROPARG(FR_PROP_ISSUEDCERTIFICATEHASH),  PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ENCRYPTEDKEYHASH),       PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ISSUEDCERTIFICATE),      PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ISSUEDCERTIFICATECHAIN), PROPTYPE_BINARY },
    { _PROPARG(FR_PROP_ISSUEDCERTIFICATECRLCHAIN), PROPTYPE_BINARY },
};


VOID
DumpFullResponseProperties(
    IN DISPATCHINTERFACE *pdiRequest)
{
    LONG cResponse = 0;
    DWORD i;
    
    DumpProperty(
	    pdiRequest,
	    _PROPARG(FR_PROP_FULLRESPONSE),
	    0,
	    PROPTYPE_BINARY,
	    NULL);

    DumpProperty(
	    pdiRequest,
	    _PROPARG(FR_PROP_FULLRESPONSENOPKCS7),
	    0,
	    PROPTYPE_BINARY,
	    NULL);

    DumpProperty(
	    pdiRequest,
	    _PROPARG(FR_PROP_STATUSINFOCOUNT),
	    0,
	    PROPTYPE_LONG,
	    &cResponse);

    for (i = 0; i < ARRAYSIZE(s_afrp); i++)
    {
	DumpIndexedProperty(
		    pdiRequest,
		    s_afrp[i].PropId,
		    s_afrp[i].pwszPropId,
		    s_afrp[i].PropType,
		    cResponse);
    }
}


HRESULT
SaveFullResponse(
    IN HWND hWndOwner,
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszfnFullResponse)
{
    HRESULT hr;
    BSTR strFullResponse = NULL;

    hr = Request2_GetFullResponseProperty(
				pdiRequest,
				FR_PROP_FULLRESPONSENOPKCS7,
				0,		// PropIndex
				PROPTYPE_BINARY,
				CV_OUT_BINARY,
				&strFullResponse);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfError(hr, error, "Request2_GetFullResponseProperty");
    }
    if (S_OK == hr)
    {
        hr = WriteCertificateOrRequest(
			    hWndOwner,
			    pdiRequest,
			    (BYTE const *) strFullResponse,
			    SysStringByteLen(strFullResponse),
			    g_dwOutFormat,
			    IDS_RESPONSE_OUTFILE_TITLE,
			    IDS_RESPONSE_FILE_FILTER,
			    IDS_RESPONSE_FILE_DEFEXT,
			    pwszfnFullResponse);
        _JumpIfError(hr, error, "WriteCertificateOrRequest");
    }
    hr = S_OK;
    goto error;

error:
    if (NULL != strFullResponse)
    {
	SysFreeString(strFullResponse);
    }
    return(hr);
}


HRESULT
CallServerAndStoreCert(
    IN HWND hWndOwner,
    IN WCHAR const *pwszConfig,
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN WCHAR const *pwszfnReq,
    OPTIONAL IN WCHAR const *pwszfnCert,
    OPTIONAL IN WCHAR const *pwszfnCertChain,
    OPTIONAL IN WCHAR const *pwszfnFullResponse)
{
    HRESULT hr;
    HRESULT hr2;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    LONG dwFlags;
    BOOL fSigned;
    BSTR strRequest = NULL;
    DISPATCHINTERFACE diRequest;
    BOOL fMustRelease = FALSE;
    BSTR strMessage = NULL;
    WCHAR const *pwszMessage;
    CERTSERVERENROLL csEnroll;
    CERTSERVERENROLL *pcsEnroll = NULL;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszAuthority = NULL;
    WCHAR awchr[cwcHRESULTSTRING];
    char const *pszMethod;
    WCHAR *pwszMsg = NULL;
    WCHAR *pwszDispMsg = NULL;
    WCHAR *pwszConfigPlusSerial = NULL;
    BOOL fV1 = g_fV1Interface;

    // If submitting a new request:


    cbReq = 0;
    if (NULL != pwszfnReq)
    {
	// Read the request from a file, convert it to binary, and return
	// dwFlags to indicate the orignal encoding and the detected format.

	hr = CheckRequestType(
			pwszfnReq,
			&pbReq,
			&cbReq,
			&dwFlags,
			&fSigned,
			NULL,		// pfCA
			NULL);		// ppwszTemplateName
	_JumpIfError(hr, error, "CheckRequestType");

	if (!fSigned || CR_IN_CERT == (CR_IN_FORMATMASK & dwFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    SetErrorString(pwszfnReq);
	    _JumpError(hr, error, "not a signed request");
	}
    }

    pszMethod = "";
    if (1 < g_fRPC)
    {
	hr = mySplitConfigString(pwszConfig, &pwszServer, &pwszAuthority);
	_JumpIfError(hr, error, "mySplitConfigString");

	if (NULL != pwszfnReq)
	{
	    // Since CertServerSubmitRequest can only handle binary requests,
	    // pass the request in binary form, and set dwFlags to so indicate.

	    dwFlags = CR_IN_BINARY | (~CR_IN_ENCODEMASK & dwFlags);

	    pszMethod = "CertServerSubmitRequest";
	    hr = CertServerSubmitRequest(
				    dwFlags | g_dwCRLIn,
				    pbReq,
				    cbReq,
				    pwszAttributes,
				    pwszServer,
				    pwszAuthority,
				    &pcsEnroll);
	    _JumpIfError(hr, error, "CertServerSubmitRequest");
	}
	else
	{
	    pszMethod = "CertServerRetrievePending";
	    hr = CertServerRetrievePending(
				    RequestId,
				    pwszSerialNumber,
				    pwszServer,
				    pwszAuthority,
				    &pcsEnroll);
	    _JumpIfError(hr, error, "CertServerRetrievePending");
	}
	CSASSERT(NULL != pcsEnroll);
	pwszMessage = pcsEnroll->pwszDispositionMessage;
    }
    else
    {
	ZeroMemory(&csEnroll, sizeof(csEnroll));
    
	hr = Request_Init(g_fIDispatch, &diRequest);
	if (S_OK != hr)
	{
	    _PrintError(hr, "Request_Init");
	    if (E_ACCESSDENIED == hr)	// try for a clearer error message
	    {
		hr = CO_E_REMOTE_COMMUNICATION_FAILURE;
	    }
	    _JumpError(hr, error, "Request_Init");
	}
	fMustRelease = TRUE;

	if (NULL != pwszfnReq)
	{
	    assert(NULL != pbReq && 0 != cbReq);

	    // We could always pass the binary ASN.1 encoded request, since
	    // we've already decoded it above, but in the interest of fully
	    // exercising the ICertRequest interface, we choose to submit the
	    // request in its original form.

	    if (CR_IN_BINARY == (CR_IN_ENCODEMASK & dwFlags))
	    {
		// Convert the binary ASN.1 blob into a BSTR blob.

		if (!ConvertWszToBstr(&strRequest, (WCHAR const *) pbReq, cbReq))
		{
		    if (S_OK == myLoadRCString(
					g_hInstance,
					IDS_ERROR_STRCONVERSION,
					&pwszMsg))
		    {
			CSASSERT(NULL != pwszMsg);
			wprintf(pwszMsg);
			wprintf(g_wszNewLine);
		    }
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
		}
	    }
	    else // !CR_IN_BINARY
	    {
		// Since ICertRequest::Submit can handle any encoding type,
		// re-read the ansi base64 request from the file without
		// decoding it to binary, then convert the ansi base64 text
		// into a Unicode base64 text BSTR.
		// Free the request's binary image first.

		LocalFree(pbReq);
		pbReq = NULL;

		hr = DecodeFileW(pwszfnReq, &pbReq, &cbReq, CRYPT_STRING_BINARY);
		if (S_OK != hr)
		{
		    if (S_OK == myLoadRCString(
					g_hInstance,
					IDS_FORMATSTR_DECODE_ERR,
					&pwszMsg))
		    {
			CSASSERT(NULL != pwszMsg);
			wprintf(pwszMsg, myHResultToString(awchr, hr));
			wprintf(g_wszNewLine);
		    }
		    goto error;
		}
		if (!ConvertSzToBstr(&strRequest, (CHAR const *) pbReq, cbReq))
		{
		    if (S_OK == myLoadRCString(
					g_hInstance,
					IDS_ERROR_STRCONVERSION,
					&pwszMsg))
		    {
			CSASSERT(NULL != pwszMsg);
			wprintf(pwszMsg);
		    }
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertSzToBstr");
		}
	    }
	    pszMethod = "ICertRequest::Submit";
	    if (g_fRPC)
	    {
		pszMethod = "ICertRequest::Submit+RPC";
		dwFlags |= CR_IN_RPC;
	    }
	    if (g_fAny)
	    {
		dwFlags = CR_IN_ENCODEANY | 
			  CR_IN_FORMATANY |
			  (~(CR_IN_ENCODEMASK | CR_IN_FORMATMASK) & dwFlags);
	    }
	    hr = Request_Submit(
			    &diRequest,
			    dwFlags | g_dwCRLIn,
			    strRequest,
			    SysStringByteLen(strRequest),
			    pwszAttributes,
			    pwszConfig,
			    (LONG *) &csEnroll.Disposition);
	}
	else
	{
	    if (!fV1)
	    {
		pszMethod = "ICertRequest2::GetIssuedCertificate";
		hr = Request2_GetIssuedCertificate(
					&diRequest,
					pwszConfig,
					RequestId,
					pwszSerialNumber,
					(LONG *) &csEnroll.Disposition);
		if (E_NOTIMPL == hr)
		{
		    fV1 = TRUE;
		}
	    }
	    if (fV1)
	    {
		if (NULL != pwszSerialNumber)
		{
		    CSASSERT(0 == RequestId);
		    pwszConfigPlusSerial = (WCHAR *) LocalAlloc(
						LMEM_FIXED,
						(wcslen(pwszConfig) +
						    1 +
						    wcslen(pwszSerialNumber) +
						    1) * sizeof(WCHAR));
		    if (NULL == pwszConfigPlusSerial)
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		    }
		    wcscpy(pwszConfigPlusSerial, pwszConfig);
		    wcscat(pwszConfigPlusSerial, L"\\");
		    wcscat(pwszConfigPlusSerial, pwszSerialNumber);
		    pwszConfig = pwszConfigPlusSerial;
		}
		pszMethod = "ICertRequest::RetrievePending";
		hr = Request_RetrievePending(
					&diRequest,
					RequestId,
					pwszConfig,
					(LONG *) &csEnroll.Disposition);
	    }
	}

	hr2 = Request_GetLastStatus(&diRequest, &csEnroll.hrLastStatus);
	if (S_OK != hr2)
	{
	    _PrintError(hr2, "Request_GetLastStatus");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	    _JumpError(hr, error, "Request_GetLastStatus");
	}
	
	if (S_OK != hr)
	{
	    _PrintError(hr, pszMethod);
	    if (E_ACCESSDENIED == hr)	// try for a clearer error message
	    {
		hr = CO_E_REMOTE_COMMUNICATION_FAILURE;
	    }
	    _JumpError(hr, error, pszMethod);
	}

	if (fMustRelease && !fV1)
	{
	    if (g_fVerbose)
	    {
		DumpFullResponseProperties(&diRequest);
	    }
	    if (NULL != pwszfnFullResponse)
	    {
		hr = SaveFullResponse(
				hWndOwner,
				&diRequest,
				pwszfnFullResponse);
		_JumpIfError(hr, error, "SaveFullResponse");
	    }
	}
	
	hr = Request_GetDispositionMessage(&diRequest, &strMessage);
	_JumpIfError(hr, error, "Request_GetDispositionMessage");

	hr = Request_GetRequestId(&diRequest, (LONG *) &csEnroll.RequestId);
	_JumpIfError(hr, error, "Request_GetRequestId");

	pcsEnroll = &csEnroll;
	pwszMessage = strMessage;
    }

    CSASSERT(NULL != pcsEnroll);
    if (NULL == pwszMessage)
    {
	pwszMessage = L"";
    }
    if (0 != pcsEnroll->RequestId)
    {
        if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_REQUESTID,
			    &pwszMsg))
        {
            CSASSERT(NULL != pwszMsg);
            wprintf(pwszMsg, pcsEnroll->RequestId);
            wprintf(g_wszNewLine);
	    LocalFree(pwszMsg);
	    pwszMsg = NULL;
        }
    }
    
    if (CR_DISP_UNDER_SUBMISSION == pcsEnroll->Disposition)
    {
        if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_CERTPENDING,
			    &pwszMsg))
        {
            CSASSERT(NULL != pwszMsg);
            wprintf(
                pwszMsg,
	        pwszMessage,
                pcsEnroll->hrLastStatus);
            wprintf(g_wszNewLine);
        }
    }
    else if (CR_DISP_ISSUED == pcsEnroll->Disposition ||
	     CR_DISP_REVOKED == pcsEnroll->Disposition)
    {
        pwszDispMsg = wszDisposition(pcsEnroll->Disposition);

	DBGPRINT((
	    DBG_SS_CERTREQ, 
            "%hs(%ws) --> %ws\n",
	    pszMethod,
            NULL != pwszDispMsg ? pwszDispMsg : L"",
            pwszMessage));

        if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_CERTRETRIEVED,
			    &pwszMsg))
        {
            wprintf(
                pwszMsg,
                NULL != pwszDispMsg ? pwszDispMsg : L"",
	        pwszMessage);
            wprintf(g_wszNewLine);
        }
        
        hr = WriteCertificateOrRequest(
			    hWndOwner,
			    &diRequest,
			    pcsEnroll->pbCert,
			    pcsEnroll->cbCert,
			    g_dwOutFormat,
			    IDS_CERT_OUTFILE_TITLE,
			    IDS_CERT_FILE_FILTER,
			    IDS_CERT_FILE_DEFEXT,
			    pwszfnCert);
        _JumpIfError(hr, error, "WriteCertificateOrRequest");
        
        if (NULL != pwszfnCertChain)
        {
            hr = WriteCertificateOrRequest(
			    hWndOwner,
			    &diRequest,
			    pcsEnroll->pbCertChain,
			    pcsEnroll->cbCertChain,
			    CR_OUT_CHAIN | g_dwCRLOut | g_dwOutFormat,
			    0,
			    0,
			    0,
			    pwszfnCertChain);
            _JumpIfError(hr, error, "WriteCertificateOrRequest(chain)");
        }
    }
    else
    {
	WCHAR const *pwszError = NULL;
	
	if (S_OK != pcsEnroll->hrLastStatus)
	{
	    pwszError = myGetErrorMessageText(pcsEnroll->hrLastStatus, TRUE);
	}
	SetErrorString(pwszMessage);

        if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_CERTNOTISSUED,
			    &pwszMsg))
        {
            pwszDispMsg = wszDisposition(pcsEnroll->Disposition);

            wprintf(
                pwszMsg,
                NULL != pwszDispMsg ? pwszDispMsg : L"",
	        pwszMessage);
	    if (NULL != pwszError && NULL == wcsstr(pwszMessage, pwszError))
	    {
                wprintf(L" %ws", pwszError);
	    }
            wprintf(g_wszNewLine);
        }
	if (NULL != pwszError)
	{
	    LocalFree(const_cast<WCHAR *>(pwszError));
	}

	hr = pcsEnroll->hrLastStatus;
        _PrintIfError(hr, "Denied(LastStatus)");
        goto error;
    }

error:
    if (NULL != pwszMsg)
    {
	LocalFree(pwszMsg);
    }
    if (NULL != pwszDispMsg)
    {
	LocalFree(pwszDispMsg);
    }
    if (NULL != pwszConfigPlusSerial)
    {
	LocalFree(pwszConfigPlusSerial);
    }
    if (NULL != pwszServer)
    {
	LocalFree(pwszServer);
    }
    if (NULL != pwszAuthority)
    {
	LocalFree(pwszAuthority);
    }
    if (NULL != pcsEnroll && &csEnroll != pcsEnroll)
    {
	CertServerFreeMemory(pcsEnroll);
    }
    if (NULL != strMessage)
    {
    	SysFreeString(strMessage);
    }
    if (fMustRelease)
    {
    	Request_Release(&diRequest);
    }
    if (NULL != strRequest)
    {
    	SysFreeString(strRequest);
    }
    if (NULL != pbReq)
    {
	LocalFree(pbReq);
    }
    return(hr);
}


HRESULT
crGetConfig(
    IN OUT BSTR *pstrConfig)
{
    HRESULT hr;
    WCHAR awchr[cwcHRESULTSTRING];
    
    hr = ConfigGetConfig(g_fIDispatch, g_dwUIFlag, pstrConfig);
    if (S_OK != hr)
    {
	WCHAR *pwszMsg = NULL;

	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
	    g_idError = IDS_NOMORE_CAS;
	}
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
	{
	    if (S_OK == myLoadRCString(
				g_hInstance,
				IDS_FORMATSTR_ERRCONFIG,
				&pwszMsg))
	    {
		CSASSERT(NULL != pwszMsg);
		wprintf(
		    pwszMsg,
		    myHResultToString(awchr, hr));
		wprintf(g_wszNewLine);
		LocalFree(pwszMsg);
	    }
	}
	goto error;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
SubmitRequest(
    IN HWND hWndOwner,
    IN LONG RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszfnReq,
    OPTIONAL IN WCHAR const *pwszfnCert,
    OPTIONAL IN WCHAR const *pwszfnCertChain,
    OPTIONAL IN WCHAR const *pwszfnFullResponse)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    WCHAR *pwszConfig;
    BSTR strConfig = NULL;
    
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    pwszConfig = g_pwszConfig;
    if (NULL == pwszConfig)
    {
	hr = crGetConfig(&strConfig);
        _JumpIfError(hr, error, "crGetConfig");

	pwszConfig = strConfig;
    }

    // If submitting a new request:

    hr = CallServerAndStoreCert(
			hWndOwner,
			pwszConfig,
			RequestId,
			pwszSerialNumber,
			pwszAttributes,
			pwszfnReq,
			pwszfnCert,
			pwszfnCertChain,
			pwszfnFullResponse);
    _JumpIfError(hr, error, "CallServerAndStoreCert");
    
error:
    if (NULL != strConfig)
    {
    	SysFreeString(strConfig);
    }
    if (fCoInit)
    {
    	CoUninitialize();
    }
    return(hr);
}


FNMYINFGETEXTENSION *g_apfnGetExtension[] = {
    myInfGetPolicyConstraintsExtension,
    myInfGetPolicyMappingExtension,
    myInfGetPolicyStatementExtension,
    myInfGetApplicationPolicyConstraintsExtension,
    myInfGetApplicationPolicyMappingExtension,
    myInfGetApplicationPolicyStatementExtension,
    myInfGetNameConstraintsExtension,
    myInfGetEnhancedKeyUsageExtension,
    myInfGetBasicConstraints2CAExtension,
    myInfGetCrossCertDistributionPointsExtension,
};
#define CINFEXT	ARRAYSIZE(g_apfnGetExtension)


HRESULT
DumpRequestAttributeBlobs(
    IN DWORD cAttribute,
    IN CRYPT_ATTR_BLOB const *paAttribute)
{
    HRESULT hr;
    DWORD i;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pNamePair = NULL;
    DWORD cb;
    
    if (g_fVerbose)
    {
	for (i = 0; i < cAttribute; i++)
	{
	    if (NULL != paAttribute[i].pbData)
	    {
		if (NULL != pNamePair)
		{
		    LocalFree(pNamePair);
		    pNamePair = NULL;
		}
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				//X509_ENROLLMENT_NAME_VALUE_PAIR,
				szOID_ENROLLMENT_NAME_VALUE_PAIR,
				paAttribute[i].pbData,
				paAttribute[i].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pNamePair,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		wprintf(
		    L"%u: %ws = %ws\n",
		    i,
		    pNamePair->pwszName,
		    pNamePair->pwszValue);
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pNamePair)
    {
	LocalFree(pNamePair);
    }
    return(hr);
}


VOID
FreeExtensions(
    IN BOOL fFreeObjIds,
    IN DWORD cExt,
    IN OUT CERT_EXTENSION *rgExt)
{
    IN DWORD i;
    
    if (NULL != rgExt)
    {
	for (i = 0; i < cExt; i++)
	{
	    if (fFreeObjIds && NULL != rgExt[i].pszObjId)
	    {
		LocalFree(rgExt[i].pszObjId);
	    }
	    if (NULL != rgExt[i].Value.pbData)
	    {
		LocalFree(rgExt[i].Value.pbData);
	    }
	}
	LocalFree(rgExt);
    }
}


VOID
FreeAttributes(
    IN DWORD cAttributes,
    IN OUT CRYPT_ATTRIBUTES *rgAttributes)
{
    DWORD i;
    DWORD j;
    
    if (NULL != rgAttributes)
    {
	for (i = 0; i < cAttributes; i++)
	{
	    CRYPT_ATTRIBUTE *pAttribute = rgAttributes[i].rgAttr;

	    if (NULL != pAttribute)
	    {
		if (NULL != pAttribute->rgValue)
		{
		    for (j = 0; j < pAttribute->cValue; j++)
		    {
			CRYPT_ATTR_BLOB *pValue = &pAttribute->rgValue[j];

			if (NULL != pValue->pbData)
			{
			    LocalFree(pValue->pbData);
			}
		    }
		    LocalFree(pAttribute->rgValue);
		}
		LocalFree(pAttribute);
	    }
	}
	LocalFree(rgAttributes);
    }
}


HRESULT
ParseInfFile(
    IN WCHAR const *pwszfnPolicy,
    OPTIONAL OUT INFVALUES **prgInfValues,
    OPTIONAL OUT DWORD *pcInfValues,
    OUT CRYPT_ATTR_BLOB **ppaAttribute,
    OUT DWORD *pcAttribute,
    OUT CERT_EXTENSION **ppExt,
    OUT DWORD *pcExt,
    OUT WCHAR **ppwszTemplateNameInf)
{
    HRESULT hr;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    DWORD i;
    INFVALUES *rgInfValues = NULL;
    DWORD cInfValues;
    DWORD cExt = 0;
    DWORD cAttribute = 0;
    CRYPT_ATTR_BLOB *paAttribute = NULL;
    CERT_EXTENSION aext[CINFEXT];
    FNMYINFGETEXTENSION **ppfnGetExtension;
    CERT_EXTENSION *rgExt = NULL;
    DWORD cExtInf = 0;
    CERT_EXTENSION *rgExtInf = NULL;
    WCHAR *pwszInfError = NULL;
    WCHAR *pwszzSectionNames;

    if (NULL != prgInfValues)
    {
	*prgInfValues = NULL;
    }
    if (NULL != pcInfValues)
    {
	*pcInfValues = 0;
    }
    *ppaAttribute = NULL;
    *pcAttribute = 0;
    *ppExt = NULL;
    *pcExt = 0;
    *ppwszTemplateNameInf = NULL;
    cInfValues = 0;

    ZeroMemory(aext, sizeof(aext));

    hr = myInfOpenFile(pwszfnPolicy, &hInf, &ErrorLine);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnPolicy);
	_JumpError(hr, error, "myInfOpenFile");
    }

    if (NULL != prgInfValues && NULL != pcInfValues)
    {
	hr = myInfGetSectionValues(
			hInf,
			wszINFSECTION_NEWREQUEST,
			&cInfValues,
			&rgInfValues);
	if (S_OK != hr)
	{
	    SetErrorString(pwszfnPolicy);
	    _JumpError(hr, error, "myInfGetSectionValues");
	}
    }
    for (ppfnGetExtension = g_apfnGetExtension;
	 ppfnGetExtension < &g_apfnGetExtension[CINFEXT];
	 ppfnGetExtension++)
    {
	hr = (**ppfnGetExtension)(hInf, &aext[cExt]);
	CSASSERT((NULL == aext[cExt].Value.pbData) ^ (S_OK == hr));
	if (S_OK != hr)
	{
	    char achIndex[64];

	    if (NULL != pwszInfError)
	    {
		LocalFree(pwszInfError);
		pwszInfError = NULL;
	    }
	    sprintf(
		achIndex,
		"*ppfnGetExtension[%u]",
		SAFE_SUBTRACT_POINTERS(ppfnGetExtension, g_apfnGetExtension));
	
	    pwszInfError = myInfGetError();
	    if (S_FALSE == hr || (HRESULT) ERROR_LINE_NOT_FOUND == hr)
	    {
		//_PrintErrorStr2(hr, achIndex, pwszInfError, S_FALSE);
		continue;
	    }
	    _JumpIfErrorStr(hr, error, achIndex, pwszInfError);
	}
	cExt++;
    }

    hr = myInfGetExtensions(hInf, &cExtInf, &rgExtInf);
    if ((HRESULT) ERROR_LINE_NOT_FOUND != hr && S_FALSE != hr)
    {
	_JumpIfError(hr, error, "myInfGetExtensions");
    }

    hr = myInfGetRequestAttributes(
			hInf,
			&cAttribute,
			&paAttribute,
			ppwszTemplateNameInf);
    if ((HRESULT) ERROR_LINE_NOT_FOUND != hr && S_FALSE != hr)
    {
	_JumpIfError(hr, error, "myInfGetRequestAttributes");
    }

    DumpRequestAttributeBlobs(cAttribute, paAttribute);

    hr = myInfGetUnreferencedSectionNames(&pwszzSectionNames);
    _JumpIfError(hr, error, "myInfGetUnreferencedSectionNames");

    if (NULL != pwszzSectionNames)
    {
	WCHAR *pwsz;

	pwsz = pwszzSectionNames;
	while (L'\0' != *pwsz)
	{
	    pwsz += wcslen(pwsz);
	    *pwsz++ = L'\n';
	}
	g_pwszUnreferencedSectionNames = pwszzSectionNames;
    }

    if (0 != cExt + cExtInf)
    {
	rgExt = (CERT_EXTENSION *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					(cExt + cExtInf) * sizeof(**ppExt));
	if (NULL == rgExt)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	if (0 != cExt)
	{
	    CopyMemory(&rgExt[0], &aext[0], cExt * sizeof(rgExt[0]));
	    for (i = 0; i < cExt; i++)
	    {
		rgExt[i].pszObjId = NULL;
	    }
	    for (i = 0; i < cExt; i++)
	    {
		hr = myDupStringA(aext[i].pszObjId, &rgExt[i].pszObjId);
		_JumpIfError(hr, error, "myDupStringA");
	    }
	}
	if (0 != cExtInf)
	{
	    CopyMemory(&rgExt[cExt], rgExtInf, cExtInf * sizeof(rgExtInf[0]));
	    ZeroMemory(rgExtInf, cExtInf * sizeof(rgExtInf[0]));
	}
	if (g_fVerbose)
	{
	    for (i = 0; i < cExt + cExtInf; i++)
	    {
		WCHAR *pwszCritMsg = NULL;
		
		myLoadRCString(
			g_hInstance,
			rgExt[i].fCritical? IDS_CRITICAL : IDS_NON_CRITICAL,
			&pwszCritMsg);
		wprintf(
		    L"%u: %hs(%ws) %ws cb=%x\n",
		    i,
		    rgExt[i].pszObjId,
		    myGetOIDNameA(rgExt[i].pszObjId),
		    pwszCritMsg,
		    rgExt[i].Value.cbData);
		if (NULL != pwszCritMsg)
		{
		    LocalFree(pwszCritMsg);
		}
	    }
	}
	*pcExt = cExt + cExtInf;
	*ppExt = rgExt;
	rgExt = NULL;
    }
    if (NULL != prgInfValues && NULL != pcInfValues)
    {
	*prgInfValues = rgInfValues;
	rgInfValues = NULL;
	*pcInfValues = cInfValues;
    }
    *ppaAttribute = paAttribute;
    *pcAttribute = cAttribute;
    paAttribute = NULL;
    hr = S_OK;

error:
    if (NULL != rgInfValues)
    {
	myInfFreeSectionValues(cInfValues, rgInfValues);
    }
    if (NULL != pwszInfError)
    {
	LocalFree(pwszInfError);
    }
    if (S_OK != hr)
    {
	for (i = 0; i < ARRAYSIZE(aext); i++)
	{
	    if (NULL != aext[i].Value.pbData)
	    {
		LocalFree(aext[i].Value.pbData);
	    }
	}
	if (NULL != *ppwszTemplateNameInf)
	{
	    LocalFree(*ppwszTemplateNameInf);
	    *ppwszTemplateNameInf = NULL;
	}
	if (NULL != rgExt)
	{
	    FreeExtensions(TRUE, cExt, rgExt);
	}
    }
    myInfFreeExtensions(cExtInf, rgExtInf);
    if (NULL != paAttribute)
    {
	myInfFreeRequestAttributes(cAttribute, paAttribute);
    }
    if (INVALID_HANDLE_VALUE != hInf)
    {
	g_pwszInfErrorString = myInfGetError();
	myInfCloseFile(hInf);
    }
    return(hr);
}


HRESULT
DeleteMsgCerts(
    IN HCRYPTMSG hMsg)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    BYTE *pbCert = NULL;

    CSASSERT(NULL == pCert);
    for (;;)
    {
	BOOL fFirst = FALSE;
	DWORD cCert;
	DWORD cb;
	DWORD i;
	
	cb = sizeof(cCert);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_CERT_COUNT_PARAM,
			0,
			&cCert,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgGetParam(Cert count)");
	}
	for (i = 0; i < cCert; i++)
	{
	    CSASSERT(NULL == pbCert);
	    hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_CERT_PARAM,
			    i,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pbCert,
			    &cb);
	    _JumpIfError(hr, error, "myCryptMsgGetParam");

	    CSASSERT(NULL == pCert);
	    pCert = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pbCert,
					cb);
	    if (NULL == pCert)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertCreateCertificateContext");
	    }

	    hr = myIsFirstSigner(&pCert->pCertInfo->Subject, &fFirst);
	    _JumpIfError(hr, error, "myIsFirstSigner");

	    LocalFree(pbCert);
	    pbCert = NULL;
	    
	    CertFreeCertificateContext(pCert);
	    pCert = NULL;

	    if (!fFirst)
	    {
		DWORD j = i;

		if (!CryptMsgControl(
				hMsg,
				0,			// dwFlags
				CMSG_CTRL_DEL_CERT,
				&j))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgControl(delCert)");
		}
		break;
	    }
	}
	if (i == cCert)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
DeleteMsgCRLs(
    IN HCRYPTMSG hMsg)
{
    HRESULT hr;
    DWORD cCRLPrev;

    for (cCRLPrev = MAXDWORD; ; )
    {
	DWORD cCRL;
	DWORD cb;
	DWORD i;

	cb = sizeof(cCRL);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_CRL_COUNT_PARAM,
			0,
			&cCRL,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgGetParam(CRL count)");
	}
	if (0 == cCRL)
	{
	    break;		// we're done
	}
	i = 0;			// delete the first CRL
	if (!CryptMsgControl(
			hMsg,
			0,	// dwFlags
			CMSG_CTRL_DEL_CRL,
			&i))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgControl(delCRL)");
	}
	if (cCRL >= cCRLPrev)
	{
	    break;		// give up after one retry
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
AddMsgCert(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStore,
    IN CERT_CONTEXT const *pCertAdd)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;

    for (;;)
    {
	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}
	if (pCertAdd->cbCertEncoded == pCert->cbCertEncoded &&
	    0 == memcmp(
		    pCertAdd->pbCertEncoded,
		    pCert->pbCertEncoded,
		    pCert->cbCertEncoded))
	{
	    break;
	}
    }
    if (NULL == pCert)
    {
	CERT_BLOB Blob;

	Blob.pbData = pCertAdd->pbCertEncoded;
	Blob.cbData = pCertAdd->cbCertEncoded;
	
	if (!CryptMsgControl(
			hMsg,
			0,			// dwFlags
			CMSG_CTRL_ADD_CERT,
			&Blob))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgControl(addCert)");
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
AddMsgCRL(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStore,
    IN CRL_CONTEXT const *pCRLAdd)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRL = NULL;

    for (;;)
    {
	pCRL = CertEnumCRLsInStore(hStore, pCRL);
	if (NULL == pCRL)
	{
	    break;
	}
	if (pCRLAdd->cbCrlEncoded == pCRL->cbCrlEncoded &&
	    0 == memcmp(
		    pCRLAdd->pbCrlEncoded,
		    pCRL->pbCrlEncoded,
		    pCRL->cbCrlEncoded))
	{
	    break;
	}
    }
    if (NULL == pCRL)
    {
	CERT_BLOB Blob;

	Blob.pbData = pCRLAdd->pbCrlEncoded;
	Blob.cbData = pCRLAdd->cbCrlEncoded;
	
	if (!CryptMsgControl(
			hMsg,
			0,			// dwFlags
			CMSG_CTRL_ADD_CRL,
			&Blob))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgControl(addCRL)");
	}
    }
    hr = S_OK;

error:
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    return(hr);
}


HRESULT
AddMsgCertsAndCRLs(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStore,
    IN CERT_CHAIN_CONTEXT const *pChainContext,
    IN BOOL fIncludeCRLs)
{
    HRESULT hr;
    DWORD cElement;
    CERT_CHAIN_ELEMENT **ppElement;
    DWORD i;

    CSASSERT(NULL != pChainContext);
    if (NULL == pChainContext ||
	0 == pChainContext->cChain ||
	0 == pChainContext->rgpChain[0]->cElement)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "no chain");
    }
    cElement = pChainContext->rgpChain[0]->cElement;
    ppElement = pChainContext->rgpChain[0]->rgpElement;

    for (i = 0; i < cElement; ppElement++, i++)
    {
	hr = AddMsgCert(hMsg, hStore, (*ppElement)->pCertContext);
	_JumpIfError(hr, error, "AddMsgCert");

	if (fIncludeCRLs)
	{
	    CERT_REVOCATION_INFO *pRevocationInfo;
	    
	    pRevocationInfo = (*ppElement)->pRevocationInfo;

	    if (NULL != pRevocationInfo &&
		CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
		    pRevocationInfo->cbSize &&
		NULL != pRevocationInfo->pCrlInfo)
	    {
		CERT_REVOCATION_CRL_INFO *pCrlInfo;

		pCrlInfo = pRevocationInfo->pCrlInfo;
		if (NULL != pCrlInfo)
		{
		    if (NULL != pCrlInfo->pBaseCrlContext)
		    {
			hr = AddMsgCRL(
				    hMsg,
				    hStore,
				    pCrlInfo->pBaseCrlContext);
			_JumpIfError(hr, error, "AddMsgCRL");
		    }
		    if (NULL != pCrlInfo->pDeltaCrlContext)
		    {
			hr = AddMsgCRL(
				    hMsg,
				    hStore,
				    pCrlInfo->pDeltaCrlContext);
			_JumpIfError(hr, error, "AddMsgCRL");
		    }
		}
	    }
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
AddOrDeleteMsgCertsAndCRLs(
    IN BYTE const *pbPKCS7,
    IN DWORD cbPKCS7,
    IN HCRYPTMSG hMsg,
    IN BOOL fDelete,	// else add Certs and CRLs
    OPTIONAL IN CERT_CHAIN_CONTEXT const *pChainContext,
    IN BOOL fIncludeCRLs)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blobPKCS7;
    HCERTSTORE hStore = NULL;

    blobPKCS7.pbData = const_cast<BYTE *>(pbPKCS7);
    blobPKCS7.cbData = cbPKCS7;

    hStore = CertOpenStore(
			CERT_STORE_PROV_PKCS7,
			PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			NULL,			// hCryptProv
			0,			// dwFlags
			&blobPKCS7);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    if (fDelete)
    {
	CSASSERT(NULL == pChainContext);

	hr = DeleteMsgCerts(hMsg);
	_JumpIfError(hr, error, "DeleteMsgCerts");

	hr = DeleteMsgCRLs(hMsg);
	_JumpIfError(hr, error, "DeleteMsgCRLs");
    }
    else
    {
	CSASSERT(NULL != pChainContext);

	hr = AddMsgCertsAndCRLs(hMsg, hStore, pChainContext, fIncludeCRLs);
	_JumpIfError(hr, error, "AddMsgCertsAndCRLs");
    }
    hr = S_OK;

error:
    if (NULL != hStore)
    {
        CertCloseStore(hStore, 0);
    }
    return(hr);
}


HRESULT
SignCMCContent(
    OPTIONAL IN CERT_CONTEXT const *pCertSigner,
    IN char const *pszInnerContentObjId,
    IN BYTE const *pbPKCS7Old,
    IN DWORD cbPKCS7Old,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbPKCS7New,
    OUT DWORD *pcbPKCS7New)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    BOOL fCallerFreeProv;
    DWORD cb;
    HCRYPTMSG hMsg = NULL;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CRYPT_ATTRIBUTE AttributeRequestClient;
    CRYPT_ATTR_BLOB BlobRequestClient;
    CERT_BLOB SignerCertBlob;
    DWORD cSigner;
    DWORD i;
    CERT_CONTEXT const *pCert = NULL;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    DWORD iElement;
    CMSG_CMS_SIGNER_INFO *pcsi = NULL;
    DWORD cFirstSigner;
    BOOL fFirst;
    CERT_REQUEST_INFO *pRequest = NULL;

    BlobRequestClient.pbData = NULL;
    fCallerFreeProv = FALSE;

    // decode existing PKCS 7 wrapper, and add or delete signatures

    hMsg = CryptMsgOpenToDecode(
		    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		    0,					// dwFlags
		    0,					// dwMsgType
		    //CMSG_SIGNED,
		    NULL,				// hCryptProv
		    NULL,				// pRecipientInfo
		    NULL);				// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToDecode");
    }

    // Update the message with the old PKCS 7 signed message

    if (!CryptMsgUpdate(hMsg, pbPKCS7Old, cbPKCS7Old, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    cb = sizeof(cSigner);
    if (!CryptMsgGetParam(
		    hMsg,
		    CMSG_SIGNER_COUNT_PARAM,
		    0,
		    &cSigner,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgGetParam(signer count)");
    }

    cFirstSigner = 0;
    if (NULL != pCertSigner)
    {
	CERT_CHAIN_PARA ChainParams;

	ZeroMemory(&SignerEncodeInfo, sizeof(SignerEncodeInfo));
	SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);

	hr = myEncodeRequestClientAttributeFromClientId(
					    XECI_CERTREQ,
					    &BlobRequestClient.pbData,
					    &BlobRequestClient.cbData);
	_JumpIfError(hr, error, "myEncodeRequestClientAttributeFromClientId");

	AttributeRequestClient.pszObjId = szOID_REQUEST_CLIENT_INFO;
	AttributeRequestClient.cValue = 1;
	AttributeRequestClient.rgValue = &BlobRequestClient;

	// Search for and load the cryptographic provider and private key. 

	hr = myLoadPrivateKey(
			&pCertSigner->pCertInfo->SubjectPublicKeyInfo,
			CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_MYSTORE | CUCS_ARCHIVED,
			&hProv,
			&dwKeySpec,
			&fCallerFreeProv);
	_JumpIfError(hr, error, "myLoadPrivateKey");

	// Get the cert chain

	ZeroMemory(&ChainParams, sizeof(ChainParams));
	ChainParams.cbSize = sizeof(ChainParams);
	ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
	//ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
	//ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

	if (!CertGetCertificateChain(
				NULL,		// hChainEngine
				pCertSigner,	// pCertContext
				NULL,		// pTime
				NULL,		// hAdditionalStore
				&ChainParams,	// pChainPara
				CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
				NULL,		// pvReserved
				&pChainContext))	// ppChainContext
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateChain");
	}

	// Initialize the CMSG_SIGNER_ENCODE_INFO structure.
	// Note: handles only a single signer.

	SignerCertBlob.cbData = pCertSigner->cbCertEncoded;
	SignerCertBlob.pbData = pCertSigner->pbCertEncoded;
	SignerEncodeInfo.pCertInfo = pCertSigner->pCertInfo;

	SignerEncodeInfo.hCryptProv = hProv;
	SignerEncodeInfo.dwKeySpec = dwKeySpec;
	SignerEncodeInfo.HashAlgorithm.pszObjId = const_cast<CHAR *>(g_pszObjIdHash);
	//SignerEncodeInfo.pvHashAuxInfo = NULL;
	SignerEncodeInfo.cAuthAttr = 1;
	SignerEncodeInfo.rgAuthAttr = &AttributeRequestClient;

	// fail if any existing signing cert matches the new signing cert.
	
	for (i = 0; i < cSigner; i++)
	{
	    if (NULL != pcsi)
	    {
		LocalFree(pcsi);
		pcsi = NULL;
	    }
	    hr = myCryptMsgGetParam(
				hMsg,
				CMSG_CMS_SIGNER_INFO_PARAM,
				i,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcsi,
				&cb);
	    _JumpIfError(hr, error, "myCryptMsgGetParam");

	    if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
		(NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
		 0 == strcmp(
			szOID_PKIX_NO_SIGNATURE,
			pcsi->HashEncryptionAlgorithm.pszObjId)))
	    {
		CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA cvse;

		ZeroMemory(&cvse, sizeof(cvse));
		cvse.cbSize = sizeof(cvse);
		cvse.dwSignerIndex = i;

		if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice)
		{
		    if (NULL == pRequest)
		    {
			hr = myGetInnerPKCS10(
					hMsg,
					pszInnerContentObjId,
					&pRequest);
			_JumpIfError(hr, error, "myGetInnerPKCS10");
		    }
		    cvse.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
		    cvse.pvSigner = &pRequest->SubjectPublicKeyInfo;
		}
		else
		{
		    cvse.dwSignerType = CMSG_VERIFY_SIGNER_NULL;
		}

		if (!CryptMsgControl(
				hMsg,
				0,		// dwFlags
				CMSG_CTRL_VERIFY_SIGNATURE_EX,
				&cvse))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgControl(VerifySig)");
		}
		cFirstSigner++;
	    }
	    else
	    {
		iElement = i;

		if (!CryptMsgGetAndVerifySigner(
				    hMsg,
				    0,		// cSignerStore
				    NULL,		// rghSignerStore
				    CMSG_USE_SIGNER_INDEX_FLAG,
				    &pCert,
				    &iElement))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgGetAndVerifySigner");
		}
		if (pCertSigner->cbCertEncoded == pCert->cbCertEncoded &&
		    0 == memcmp(
			    pCertSigner->pbCertEncoded,
			    pCert->pbCertEncoded,
			    pCert->cbCertEncoded))
		{
		    hr = CRYPT_E_EXISTS;
		    _JumpError(hr, error, "duplicate signing cert");
		}
		hr = myIsFirstSigner(&pCert->pCertInfo->Subject, &fFirst);
		_JumpIfError(hr, error, "myIsFirstSigner");

		if (fFirst)
		{
		    cFirstSigner++;
		}
		CertFreeCertificateContext(pCert);
		pCert = NULL;
	    }
	}
	if (!CryptMsgControl(
			hMsg,
			0,			// dwFlags
			CMSG_CTRL_ADD_SIGNER,
			&SignerEncodeInfo))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgControl(addSigner)");
	}
    }
    else
    {
	// delete all existing signers -- except the first signer

	for (;;)
	{
	    BOOL fDeleteSigner = FALSE;
	    
	    for (i = 0; i < cSigner; i++)
	    {
		if (NULL != pcsi)
		{
		    LocalFree(pcsi);
		    pcsi = NULL;
		}
		hr = myCryptMsgGetParam(
				    hMsg,
				    CMSG_CMS_SIGNER_INFO_PARAM,
				    i,
				    CERTLIB_USE_LOCALALLOC,
				    (VOID **) &pcsi,
				    &cb);
		_JumpIfError(hr, error, "myCryptMsgGetParam");

		if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
		    (NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
		     0 == strcmp(
			    szOID_PKIX_NO_SIGNATURE,
			    pcsi->HashEncryptionAlgorithm.pszObjId)))
		{
		    cFirstSigner++;
		    continue;
		}
		iElement = i;

		if (!CryptMsgGetAndVerifySigner(
				    hMsg,
				    0,			// cSignerStore
				    NULL,		// rghSignerStore
				    CMSG_USE_SIGNER_INDEX_FLAG |
					CMSG_SIGNER_ONLY_FLAG,
				    &pCert,
				    &iElement))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgGetAndVerifySigner");
		}

		hr = myIsFirstSigner(&pCert->pCertInfo->Subject, &fFirst);
		_JumpIfError(hr, error, "myIsFirstSigner");

		CertFreeCertificateContext(pCert);
		pCert = NULL;

		if (!fFirst)
		{
		    fDeleteSigner = TRUE;
		    break;
		}
		cFirstSigner++;
	    }
	    if (!fDeleteSigner)
	    {
		break;
	    }
	    if (!CryptMsgControl(
			    hMsg,
			    0,			// dwFlags
			    CMSG_CTRL_DEL_SIGNER,
			    &iElement))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgControl(delSigner)");
	    }
	    cb = sizeof(cSigner);
	    if (!CryptMsgGetParam(
			    hMsg,
			    CMSG_SIGNER_COUNT_PARAM,
			    0,
			    &cSigner,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgGetParam(signer count)");
	    }
	}
    }
    if (1 != cFirstSigner)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "cFirstSigner");
    }

    // Add or delete signing cert chain certs and CRLs in the message.

    hr = AddOrDeleteMsgCertsAndCRLs(
			    pbPKCS7Old,
			    cbPKCS7Old,
			    hMsg,
			    NULL == pChainContext,	// fDelete
			    pChainContext,
			    fIncludeCRLs);
    _JumpIfError(hr, error, "AddOrDeleteMsgCertsAndCRLs");

    // Get the signed message.  Force reencoding with the changed signatures.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_ENCODED_MESSAGE,
		    0,
                    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppbPKCS7New,
		    pcbPKCS7New);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

error:
    if (NULL != pRequest)
    {
	LocalFree(pRequest);
    }
    if (NULL != pcsi)
    {
	LocalFree(pcsi);
    }
    if (NULL != BlobRequestClient.pbData)
    {
	LocalFree(BlobRequestClient.pbData);
    }
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != hProv && fCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


BOOL
IsCATemplate(
    IN WCHAR const *pwszExtensionName)
{
    BOOL fCA;
    DWORD i;
    
    static WCHAR const * const s_apwszCATemplate[] = {
	wszCERTTYPE_CA,
	wszCERTTYPE_SUBORDINATE_CA,
	wszCERTTYPE_CROSS_CA,
    };

    fCA = FALSE;
    for (i = 0; i < ARRAYSIZE(s_apwszCATemplate); i++)
    {
	if (0 == mylstrcmpiL(pwszExtensionName, s_apwszCATemplate[i]))
	{
	    fCA = TRUE;
	    break;
	}
    }
    return(fCA);
}


// AddCAExtensions -- add Basic Constraints & KeyUsage extensions if missing

HRESULT
AddCAExtensions(
    IN OUT CERT_EXTENSION **prgExt,
    IN OUT DWORD *pcExt)
{
    HRESULT hr;
    DWORD cExt;

    BOOL fAddBasicConstraints = TRUE;
    BOOL fAddKeyUsage = TRUE;

    if (NULL != *prgExt)
    {
	cExt = *pcExt;
	if (NULL != CertFindExtension(
				szOID_BASIC_CONSTRAINTS2,
				cExt,
				*prgExt))
	{
	    fAddBasicConstraints = FALSE;
	}
	if (NULL == CertFindExtension(szOID_KEY_USAGE, cExt, *prgExt))
	{
	    fAddKeyUsage = FALSE;
	}
    }
    else
    {
	*pcExt = 0;
	cExt = *pcExt;
    }

    if (fAddBasicConstraints || fAddKeyUsage)
    {
	CERT_EXTENSION *rgExt;
	CERT_EXTENSION *pExt;
	if (fAddBasicConstraints)
	{
	    cExt++;
	}
	if (fAddKeyUsage)
	{
	    cExt++;
	}
	rgExt = (CERT_EXTENSION *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(rgExt[0]) * cExt);
	if (NULL == rgExt)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	if (NULL != *prgExt)
	{
	    CopyMemory(rgExt, *prgExt, *pcExt * sizeof(rgExt[0]));
	    LocalFree(*prgExt);
	}
	*prgExt = rgExt;

	pExt = &rgExt[*pcExt];
	if (fAddBasicConstraints)
	{
	    CERT_BASIC_CONSTRAINTS2_INFO Constraints;

	    Constraints.fCA = TRUE;
	    Constraints.fPathLenConstraint = FALSE;
	    Constraints.dwPathLenConstraint = 0;

	    (*pcExt)++;		// increment now to free memory on error

	    hr = myDupStringA(szOID_BASIC_CONSTRAINTS2, &pExt->pszObjId);
	    _JumpIfError(hr, error, "myDupStringA");

	    pExt->fCritical = TRUE;
	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_BASIC_CONSTRAINTS2,
			    &Constraints,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pExt->Value.pbData,
			    &pExt->Value.cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myEncodeObject");
	    }
	    pExt++;
	}
	if (fAddKeyUsage)
	{
	    CRYPT_BIT_BLOB KeyUsage;
	    BYTE bKeyUsage = myCASIGN_KEY_USAGE;

	    KeyUsage.cbData = sizeof(bKeyUsage);
	    KeyUsage.pbData = &bKeyUsage;
	    KeyUsage.cUnusedBits = 0;

	    (*pcExt)++;		// increment now to free memory on error

	    hr = myDupStringA(szOID_KEY_USAGE, &pExt->pszObjId);
	    _JumpIfError(hr, error, "myDupStringA");

	    pExt->fCritical = FALSE;
	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    &KeyUsage,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pExt->Value.pbData,
			    &pExt->Value.cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Policy:myEncodeObject");
	    }
	    pExt++;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
MergeAndEncodeExtensions(
    IN BOOL fCA,
    OPTIONAL IN CERT_EXTENSION *rgExtInf,
    IN DWORD cExtInf,
    OPTIONAL IN CERT_EXTENSION *rgExtReq,
    IN DWORD cExtReq,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CERT_EXTENSIONS Extensions;
    CERT_EXTENSION *rgExtCA = NULL;
    DWORD cExtCA;
    CERT_EXTENSION *rgrgExt[3];
    DWORD rgcExt[3];
    DWORD cExt;
    DWORD i;

    Extensions.rgExtension = NULL;
    *ppbOut = NULL;
    cExtCA = 0;

    if (fCA)
    {
	hr = AddCAExtensions(&rgExtCA, &cExtCA);
	_JumpIfError(hr, error, "AddCAExtensions");
    }

    ZeroMemory(rgrgExt, sizeof(rgrgExt));
    ZeroMemory(rgcExt, sizeof(rgcExt));
    cExt = 0;
    if (NULL != rgExtInf)	// INF & template extensions take precedence
    {
	rgrgExt[0] = rgExtInf;
	rgcExt[0] = cExtInf;
	cExt += cExtInf;
    }
    if (NULL != rgExtReq)	// Then come Cert & other request extensions
    {
	rgrgExt[1] = rgExtReq;
	rgcExt[1] = cExtReq;
	cExt += cExtReq;
    }
    if (NULL != rgExtCA)	// Added CA extensions are lowest priority
    {
	rgrgExt[2] = rgExtCA;
	rgcExt[2] = cExtCA;
	cExt += cExtCA;
    }
    if (0 == cExt)
    {
	hr = S_FALSE;		// no extensions to encode
	goto error;
    }
    Extensions.cExtension = 0;
    Extensions.rgExtension = (CERT_EXTENSION *) LocalAlloc(
				LMEM_FIXED,
				sizeof(Extensions.rgExtension[0]) * cExt);
    if (NULL == Extensions.rgExtension)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    for (i = 0; i < ARRAYSIZE(rgrgExt); i++)
    {
	CERT_EXTENSION *pExt = rgrgExt[i];
	CERT_EXTENSION *pExtEnd;

	for (pExtEnd = &pExt[rgcExt[i]]; pExt < pExtEnd; pExt++)
	{
	    if (NULL == CertFindExtension(
			    pExt->pszObjId,
			    Extensions.cExtension,
			    Extensions.rgExtension))
	    {
		Extensions.rgExtension[Extensions.cExtension] = *pExt;
		Extensions.cExtension++;
	    }
	}
    }
    CSASSERT(Extensions.cExtension <= cExt);

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_EXTENSIONS,
		&Extensions,
		0,
		CERTLIB_USE_LOCALALLOC,
		ppbOut,
		pcbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != rgExtCA)
    {
	FreeExtensions(TRUE, cExtCA, rgExtCA);
    }
    if (NULL != Extensions.rgExtension)
    {
	LocalFree(Extensions.rgExtension);
    }
    return(hr);
}


HRESULT
ConvertCertToPKCS10Request(
    OPTIONAL IN WCHAR const *pwszExtensionName,
    IN OUT BOOL *pfCA,
    OPTIONAL IN CERT_EXTENSION *rgExtInf,
    IN DWORD cExtInf,
    IN OUT BYTE **ppbReq,
    IN OUT DWORD *pcbReq)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    BYTE *pbReqUnsigned = NULL;
    DWORD cbReqUnsigned;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    CERT_REQUEST_INFO Request;
    CRYPT_ATTR_BLOB ExtBlob;
    CRYPT_ATTR_BLOB VersionBlob;
    CERT_EXTENSIONS Extensions;
    CRYPT_ATTRIBUTE aAttrib[2];
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    BOOL fCallerFreeProv;
    CERT_EXTENSION *pExt;
    CERT_EXTENSION *pExtKeyId;
    CHAR *pszObjId = NULL;
#define CEXT_ADD	4  // SKI, Template Name, Basic Constraints, KeyUsage
    CERT_EXTENSION aExtAdd[CEXT_ADD];
    DWORD i;

    ZeroMemory(aExtAdd, sizeof(aExtAdd));

    // Certificate extensions to strip out of the request:

    static char const * const s_apszObjIdFilter[] = {
	szOID_BASIC_CONSTRAINTS2,	// must be first!
	szOID_CERTSRV_CA_VERSION,
	szOID_AUTHORITY_INFO_ACCESS,
	szOID_CRL_DIST_POINTS,
	szOID_AUTHORITY_KEY_IDENTIFIER2,
	szOID_CERTSRV_PREVIOUS_CERT_HASH,
	szOID_ENROLL_CERTTYPE_EXTENSION,
	szOID_CERTIFICATE_TEMPLATE,
	NULL
    };
    char const * const *apszObjIdFilter = &s_apszObjIdFilter[1];

    ExtBlob.pbData = NULL;
    VersionBlob.pbData = NULL;
    Extensions.rgExtension = NULL;
    fCallerFreeProv = FALSE;

    pCert = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				*ppbReq,
				*pcbReq);
    if (NULL == pCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    if (NULL != pwszExtensionName && IsCATemplate(pwszExtensionName))
    {
	*pfCA = TRUE;
    }
    pExt = CertFindExtension(
		    szOID_BASIC_CONSTRAINTS2,
		    pCert->pCertInfo->cExtension,
		    pCert->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	BOOL fCAT;
	
	hr = IsSubjectTypeCA(pExt, &fCAT);
	_JumpIfError(hr, error, "IsSubjectTypeCA");

	if (fCAT)
	{
	    *pfCA = TRUE;
	}
	else if (*pfCA)
	{
	    // filter out non-CA Basic Constraints -- add a new one below.

	    apszObjIdFilter = s_apszObjIdFilter;
	}
    }
    ZeroMemory(&Request, sizeof(Request));
    Request.dwVersion = CERT_REQUEST_V1;
    Request.Subject = pCert->pCertInfo->Subject;
    Request.SubjectPublicKeyInfo = pCert->pCertInfo->SubjectPublicKeyInfo;

    Extensions.cExtension = 0;
    Extensions.rgExtension = (CERT_EXTENSION *) LocalAlloc(
				LMEM_FIXED,
				sizeof(Extensions.rgExtension[0]) *
				    (CEXT_ADD + pCert->pCertInfo->cExtension));
    if (NULL == Extensions.rgExtension)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pExtKeyId = NULL;
    if (0 < pCert->pCertInfo->cExtension)
    {
	DWORD j;

	pExt = pCert->pCertInfo->rgExtension;
	for (i = 0; i < pCert->pCertInfo->cExtension; i++)
	{
	    if (0 == strcmp(szOID_SUBJECT_KEY_IDENTIFIER, pExt->pszObjId))
	    {
		pExtKeyId = pExt;
	    }
	    for (j = 0; ; j++)
	    {
		if (NULL == apszObjIdFilter[j])
		{
		    Extensions.rgExtension[Extensions.cExtension] =
			pCert->pCertInfo->rgExtension[i];
		    Extensions.cExtension++;
		    break;
		}
		if (0 == strcmp(apszObjIdFilter[j], pExt->pszObjId))
		{
		    break;		// skip this extension
		}
	    }
	    pExt++;
	}
    }
    if (NULL == pExtKeyId)
    {
	BYTE abHash[CBMAX_CRYPT_HASH_LEN];
	CRYPT_DATA_BLOB Blob;

	Blob.pbData = abHash;
	Blob.cbData = sizeof(abHash);
	if (!CryptHashPublicKeyInfo(
			    NULL,		// hCryptProv
			    CALG_SHA1,
			    0,		// dwFlags,
			    X509_ASN_ENCODING,
			    &Request.SubjectPublicKeyInfo,
			    Blob.pbData,
			    &Blob.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashPublicKeyInfo");
	}
	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &Blob,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aExtAdd[0].Value.pbData,
		    &aExtAdd[0].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aExtAdd[0].pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
	pExtKeyId = &Extensions.rgExtension[Extensions.cExtension];
	*pExtKeyId = aExtAdd[0];
	Extensions.cExtension++;
    }

    if (NULL != pwszExtensionName)
    {
	hr = myBuildCertTypeExtension(pwszExtensionName, &aExtAdd[1]);
	_JumpIfError(hr, error, "myBuildCertTypeExtension");

	Extensions.rgExtension[Extensions.cExtension] = aExtAdd[1];
	Extensions.cExtension++;
    }

    // get the OS Version

    hr = myBuildOSVersionAttribute(&VersionBlob.pbData, &VersionBlob.cbData);
    _JumpIfError(hr, error, "myBuildOSVersionAttribute");

    hr = MergeAndEncodeExtensions(
			    *pfCA,
			    rgExtInf,
			    cExtInf,
			    Extensions.rgExtension,
			    Extensions.cExtension,
			    &ExtBlob.pbData,
			    &ExtBlob.cbData);
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "MergeAndEncodeExtensions");
    }

    Request.cAttribute = 0;
    Request.rgAttribute = aAttrib;
    if (NULL != ExtBlob.pbData)
    {
	aAttrib[Request.cAttribute].pszObjId = szOID_RSA_certExtensions;
	aAttrib[Request.cAttribute].cValue = 1;
	aAttrib[Request.cAttribute].rgValue = &ExtBlob;
	Request.cAttribute++;
    }

    aAttrib[Request.cAttribute].pszObjId = szOID_OS_VERSION;
    aAttrib[Request.cAttribute].cValue = 1;
    aAttrib[Request.cAttribute].rgValue = &VersionBlob;
    Request.cAttribute++;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
                    X509_CERT_REQUEST_TO_BE_SIGNED,
		    &Request,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbReqUnsigned,
		    &cbReqUnsigned))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    // Search for and load the cryptographic provider and private key. 

    hr = myLoadPrivateKey(
		    &pCert->pCertInfo->SubjectPublicKeyInfo,
		    CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_MYSTORE | CUCS_ARCHIVED,
		    &hProv,
		    &dwKeySpec,
		    &fCallerFreeProv);
    if (S_OK != hr)
    {
	_PrintError(hr, "myLoadPrivateKey");
	CSASSERT(NULL == hProv);

	// private key is unavailable -- sign the PKCS10 with a NULL signature.

	hr = myDupStringA(g_pszObjIdHash, &pszObjId);
	_JumpIfError(hr, error, "myDupStringA");
    }
    else
    {
	if (AT_SIGNATURE != dwKeySpec)
	{
	    hr = NTE_BAD_KEY_STATE;
	    DBGPRINT((DBG_SS_CERTREQ, "dwKeySpec = %u\n", dwKeySpec));
	    _JumpError(hr, error, "dwKeySpec");
	}

	// The private key is available -- use it to sign the PKCS10.

	hr = myGetSigningOID(hProv, NULL, 0, CALG_SHA1, &pszObjId);
	_JumpIfError(hr, error, "myGetSigningOID");
    }

    // Sign the request and encode the signed info.

    hr = myEncodeSignedContent(
			hProv,
			X509_ASN_ENCODING,
			pszObjId,
			pbReqUnsigned,
			cbReqUnsigned,
			CERTLIB_USE_LOCALALLOC,
			&pbReq,
			&cbReq);
    _JumpIfError(hr, error, "myEncodeSignedContent");

    LocalFree(*ppbReq);
    *ppbReq = pbReq;
    *pcbReq = cbReq;
    pbReq = NULL;
    hr = S_OK;

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    if (NULL != hProv && fCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != Extensions.rgExtension)
    {
        LocalFree(Extensions.rgExtension);
    }
    for (i = 0; i < CEXT_ADD; i++)
    {
	if (NULL != aExtAdd[i].Value.pbData)
	{
	    LocalFree(aExtAdd[i].Value.pbData);
	}
    }
    if (NULL != ExtBlob.pbData)
    {
        LocalFree(ExtBlob.pbData);
    }
    if (NULL != VersionBlob.pbData)
    {
        LocalFree(VersionBlob.pbData);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != pbReq)
    {
	LocalFree(pbReq);
    }
    if (NULL != pbReqUnsigned)
    {
	LocalFree(pbReqUnsigned);
    }
    return(hr);
}


HRESULT
GetPKCS10PrivateKey(
    IN BYTE const *pbReq,
    IN DWORD cbReq,
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv,
    OUT BYTE **ppbKeyId,
    OUT DWORD *pcbKeyId)
{
    HRESULT hr;
    CERT_REQUEST_INFO *pRequest = NULL;
    HCRYPTPROV hProv = NULL;
    CERT_EXTENSIONS *pExtensions = NULL;
    CRYPT_ATTRIBUTE *pAttr;
    BYTE *pbKeyId = NULL;
    DWORD cbKeyId;
    DWORD dwKeySpec;
    DWORD cb;
    DWORD i;

    *phProv = NULL;
    *pdwKeySpec = 0;
    *ppbKeyId = NULL;
    *pcbKeyId = 0;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
                    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pbReq,
		    cbReq,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pRequest,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    // Search for and load the cryptographic provider and private key. 

    hr = myLoadPrivateKey(
		    &pRequest->SubjectPublicKeyInfo,
		    CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_MYSTORE | CUCS_ARCHIVED,
		    &hProv,
		    &dwKeySpec,
		    pfCallerFreeProv);
    _JumpIfError(hr, error, "myLoadPrivateKey");

    if (AT_SIGNATURE != dwKeySpec)
    {
	hr = NTE_BAD_KEY_STATE;
	DBGPRINT((DBG_SS_CERTREQ, "dwKeySpec = %u\n", dwKeySpec));
	_JumpError(hr, error, "dwKeySpec");
    }

    // Fetch or construct the KeyId hash

    cbKeyId = 0;
    pAttr = pRequest->rgAttribute;
    for (i = 0; i < pRequest->cAttribute && NULL != pbKeyId; i++, pAttr++)
    {
	DWORD j;

	if (0 == strcmp(szOID_RSA_certExtensions, pAttr->pszObjId) ||
	    0 == strcmp(szOID_CERT_EXTENSIONS, pAttr->pszObjId))
	{
	    for (j = 0; j < pAttr->cValue; j++)
	    {
		DWORD k;
		CERT_EXTENSION *pExt;

		if (NULL != pExtensions)
		{
		    LocalFree(pExtensions);
		    pExtensions = NULL;
		}
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_EXTENSIONS,
				pAttr->rgValue[j].pbData,
				pAttr->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pExtensions,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}

		pExt = pExtensions->rgExtension;
		for (k = 0; k < pExtensions->cExtension; k++, pExt++)
		{
		    if (0 == strcmp(
				pExt->pszObjId,
				szOID_SUBJECT_KEY_IDENTIFIER))
		    {
			if (!myDecodeObject(
				    X509_ASN_ENCODING,
				    X509_OCTET_STRING,
				    pExt->Value.pbData,
				    pExt->Value.cbData,
				    CERTLIB_USE_LOCALALLOC,
				    (VOID **) &pbKeyId,
				    &cbKeyId))
			{
			    hr = myHLastError();
			    _JumpError(hr, error, "myDecodeObject");
			}
			break;
		    }
		}
	    }
	}
    }
    if (NULL == pbKeyId)
    {
	BYTE abHash[CBMAX_CRYPT_HASH_LEN];

	cbKeyId = sizeof(abHash);
	if (!CryptHashPublicKeyInfo(
			    NULL,		// hCryptProv
			    CALG_SHA1,
			    0,		// dwFlags,
			    X509_ASN_ENCODING,
			    &pRequest->SubjectPublicKeyInfo,
			    abHash,
			    &cbKeyId))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashPublicKeyInfo");
	}
	pbKeyId = (BYTE *) LocalAlloc(LMEM_FIXED, cbKeyId);
	if (NULL == pbKeyId)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pbKeyId, abHash, cbKeyId);
    }
    *phProv = hProv;
    hProv = NULL;
    *ppbKeyId = pbKeyId;
    pbKeyId = NULL;
    *pcbKeyId = cbKeyId;
    *pdwKeySpec = dwKeySpec;
    hr = S_OK;

error:
    if (NULL != hProv && *pfCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pRequest)
    {
        LocalFree(pRequest);
    }
    if (NULL != pExtensions)
    {
        LocalFree(pExtensions);
    }
    if (NULL != pbKeyId)
    {
        LocalFree(pbKeyId);
    }
    return(hr);
}


HRESULT
BuildNameValuePairs(
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN OUT DWORD *pcValue,
    OPTIONAL OUT CRYPT_ATTR_BLOB *pValue,
    OPTIONAL OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    DWORD cValue = 0;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszBuf;
    WCHAR const *pwszName;
    WCHAR const *pwszValue;
    WCHAR *pwszTemplateName = NULL;

    if (NULL != ppwszTemplateName)
    {
	*ppwszTemplateName = NULL;
    }
    if (NULL == pwszAttributes)
    {
	hr = S_OK;
        goto error;		// silently ignore empty string
    }
    hr = myDupString(pwszAttributes, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszBuf = pwszDup;

    for (;;)
    {
	hr = myParseNextAttribute(&pwszBuf, FALSE, &pwszName, &pwszValue);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "myParseNextAttribute");

	DBGPRINT((DBG_SS_CERTREQI, "'%ws' = '%ws'\n", pwszName, pwszValue));
	if (NULL != pValue)
	{
	    CRYPT_ENROLLMENT_NAME_VALUE_PAIR NamePair;

	    CSASSERT(cValue < *pcValue);
	    NamePair.pwszName = const_cast<WCHAR *>(pwszName);
	    NamePair.pwszValue = const_cast<WCHAR *>(pwszValue);

	    if (NULL != ppwszTemplateName &&
		0 == LSTRCMPIS(pwszName, wszPROPCERTTEMPLATE))
	    {
		if (NULL != pwszTemplateName)
		{
		    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    _JumpError(hr, error, "Duplicate cert template");
		}
		hr = myDupString(pwszValue, &pwszTemplateName);
		_JumpIfError(hr, error, "myDupString");
	    }

	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    //X509_ENROLLMENT_NAME_VALUE_PAIR,
			    szOID_ENROLLMENT_NAME_VALUE_PAIR,
			    &NamePair,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pValue[cValue].pbData,
			    &pValue[cValue].cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myEncodeObject");
	    }
	}
	cValue++;
    }
    if (NULL != ppwszTemplateName)
    {
	*ppwszTemplateName = pwszTemplateName;
	pwszTemplateName = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    *pcValue = cValue;
    if (NULL != pwszDup)
    {
        LocalFree(pwszDup);
    }
    return(hr);
}


ConvertPolicesToSz(
    IN DWORD cPolicies,
    IN WCHAR const * const *rgpwszPolicies,
    OUT CHAR ***prgpszPolicies)
{
    HRESULT hr;
    DWORD i;
    DWORD cch = 0;
    CHAR **ppsz;
    CHAR *pch;

    *prgpszPolicies = NULL;
    for (i = 0; i < cPolicies; i++)
    {
	cch += wcslen(rgpwszPolicies[i]) + 1;
    }
    ppsz = (CHAR **) LocalAlloc(
			    LMEM_FIXED,
			    cch + (cPolicies + 1) * sizeof(CHAR *));
    if (NULL == ppsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *prgpszPolicies = ppsz;
    pch = (CHAR *) &ppsz[cPolicies + 1];

    for (i = 0; i < cPolicies; i++)
    {
	WCHAR const *pwc;
	
	*ppsz++ = pch;
	pwc = rgpwszPolicies[i];
	while ('\0' != (*pch++ = (char) *pwc++))
	    ;
    }
    *ppsz = NULL;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
PickCertAndSignRequest(
    IN BYTE const *pbReq,
    IN DWORD cbReq,
    IN BOOL fSkipSignerDeletion,
    OPTIONAL IN WCHAR const *pwszTemplateName,
    OUT BYTE **ppbPKCS7Out,
    OUT DWORD *pcbPKCS7Out)
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;
    CERT_CONTEXT const *pCertSigner = NULL;
    WCHAR **rgpwszPolicies = NULL;
    CHAR **rgpszPolicies = NULL;
    WCHAR **ppwsz;
    DWORD cPolicies = 0;

    if (NULL == g_pwszCertCN || !myIsMinusSignString(g_pwszCertCN))
    {
	if (!g_fQuiet || NULL != g_pwszCertCN)
	{
	    WCHAR const *pwszCommonName;

	    if (NULL != pwszTemplateName)
	    {
		hr = CAFindCertTypeByName(
			    pwszTemplateName,
			    NULL,
			    CT_FIND_LOCAL_SYSTEM |
				CT_ENUM_MACHINE_TYPES |
				CT_ENUM_USER_TYPES,
			    &hCertType);
		if (S_OK != hr)
		{
		    hr = CAFindCertTypeByName(
				pwszTemplateName,
				NULL,
				CT_FIND_LOCAL_SYSTEM |
				    CT_ENUM_MACHINE_TYPES |
				    CT_ENUM_USER_TYPES |
				    CT_FIND_BY_OID,
				&hCertType);
		    _PrintIfErrorStr(hr, "CAFindCertTypeByName", pwszTemplateName);
		}
		if (S_OK == hr)
		{
		    DWORD cSig;

		    hr = CAGetCertTypePropertyEx(
					hCertType,
					CERTTYPE_PROP_RA_SIGNATURE,
					&cSig);
		    if (S_OK != hr)
		    {
			_PrintError(hr, "CAGetCertTypePropertyEx");
			cSig = 0;
		    }
		    if (0 != cSig)
		    {
			hr = CAGetCertTypePropertyEx(
					    hCertType,
					    CERTTYPE_PROP_RA_APPLICATION_POLICY,
					    &rgpwszPolicies);
			if (S_OK != hr)
			{
			    _PrintError(hr, "CAGetCertTypePropertyEx");
			    rgpwszPolicies = NULL;
			}
		    }
		    if (NULL != rgpwszPolicies)
		    {
			for (ppwsz = rgpwszPolicies; NULL != *ppwsz; ppwsz++)
			{
			    cPolicies++;
			}
		    }
		}
	    }
	    pwszCommonName = NULL;
	    if (L'\0' != g_pwszCertCN && 0 != lstrcmp(L"*", g_pwszCertCN))
	    {
		pwszCommonName = g_pwszCertCN;
	    }
	    if (0 != cPolicies)
	    {
		hr = ConvertPolicesToSz(
				cPolicies,
				rgpwszPolicies,
				&rgpszPolicies);
		_JumpIfError(hr, error, "ConvertPolicesToSz");
		
		hr = myGetCertificateFromPicker(
					g_hInstance,
					NULL,		// hwndParent
					IDS_GETERACERT_TITLE,
					IDS_GETERACERT_SUBTITLE,
					CUCS_MYSTORE |
					    CUCS_PRIVATEKEYREQUIRED |
					    CUCS_USAGEREQUIRED |
					    (g_fQuiet? CUCS_SILENT : 0),
					pwszCommonName,
					0,			// cStore
					NULL,			// rghStore
					cPolicies,		// cpszObjId
					rgpszPolicies,		// apszObjId
					&pCertSigner);
		_JumpIfError(hr, error, "myGetCertificateFromPicker");
	    }
	    else
	    {
		hr = myGetERACertificateFromPicker(
					g_hInstance,
					NULL,		// hwndParent
					IDS_GETERACERT_TITLE,
					IDS_GETERACERT_SUBTITLE,
					pwszCommonName,
					g_fQuiet,
					&pCertSigner);
		_JumpIfError(hr, error, "myGetERACertificateFromPicker");
	    }
	}

	// pCertSigner is NULL if the user cancelled out of the cert picker U/I.
	// NULL pCertSigner means delete existing signatures.

	if (NULL == pCertSigner)
	{
	    if (fSkipSignerDeletion)
	    {
		hr = S_FALSE;
		_JumpError2(hr, error, "no signer selected", S_FALSE);
	    }
	    if (g_fQuiet || NULL != g_pwszCertCN)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "no matching signer CN");
	    }
	}
	else
	{
	    DWORD dwCertValidityFlags;

	    // be sure the cert picked isn't already expired - that'd be silly

	    dwCertValidityFlags = CERT_STORE_TIME_VALIDITY_FLAG;
	    if (!CertVerifySubjectCertificateContext(
					    pCertSigner,
					    NULL,
					    &dwCertValidityFlags))
	    {
	       hr = myHLastError();
	       _JumpIfError(hr, error, "CertVerifySubjectCertificateContext");
	    }
	    if (0 != dwCertValidityFlags)
	    {
		hr = HRESULT_FROM_WIN32(CERT_E_EXPIRED);
		_JumpError(hr, error, "CertVerifySubjectCertificateContext");
	    }
	}
    }
    hr = SignCMCContent(
		    pCertSigner,
		    szOID_CT_PKI_DATA,
		    pbReq,
		    cbReq,
		    0 != (CR_OUT_CRLS & g_dwCRLOut),
		    ppbPKCS7Out,
		    pcbPKCS7Out);
    _JumpIfError(hr, error, "SignCMCContent");

error:
    if (NULL != rgpwszPolicies)
    {
        CAFreeCertTypeProperty(hCertType, rgpwszPolicies);
    }
    if (NULL != rgpszPolicies)
    {
        LocalFree(rgpszPolicies);
    }
    if (NULL != hCertType)
    {
        CACloseCertType(hCertType);
    }
    if (NULL != pCertSigner)
    {
	CertFreeCertificateContext(pCertSigner);
    }
    return(hr);
}


HRESULT
SignQualifiedRequest(
    IN HWND hWndOwner,
    IN WCHAR const *pwszfnReq,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    BYTE *pbPKCS7Out = NULL;
    DWORD cbPKCS7Out;
    LONG dwFlags;
    BOOL fSigned;
    WCHAR *pwszTemplateName = NULL;
    
    // Read the request from a file, convert it to binary, and return
    // dwFlags to indicate the orignal encoding and the detected format.

    hr = CheckRequestType(
		    pwszfnReq,
		    &pbReq,
		    &cbReq,
		    &dwFlags,
		    &fSigned,
		    NULL,	// pfCA
		    &pwszTemplateName);
    _JumpIfError(hr, error, "CheckRequestType");

    if (CR_IN_CMC != (CR_IN_FORMATMASK & dwFlags))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	SetErrorString(pwszfnReq);
	_JumpError(hr, error, "not a CMC request");
    }

    hr = PickCertAndSignRequest(
			    pbReq,
			    cbReq,
			    FALSE,
			    pwszTemplateName,
			    &pbPKCS7Out,
			    &cbPKCS7Out);
    _JumpIfError(hr, error, "PickCertAndSignRequest");

    hr = WriteCertificateOrRequest(
			hWndOwner,
    			NULL,		// pdiRequest
			pbPKCS7Out,
			cbPKCS7Out,
			g_dwOutFormat,
			IDS_REQUEST_OUTFILE_TITLE,
			IDS_REQUEST_FILE_FILTER,
			IDS_REQUEST_FILE_DEFEXT,
			pwszfnOut);
    _JumpIfError(hr, error, "WriteCertificateOrRequest");

error:
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    if (NULL != pbReq)
    {
	LocalFree(pbReq);
    }
    if (NULL != pbPKCS7Out)
    {
	LocalFree(pbPKCS7Out);
    }
    return(hr);
}


HRESULT
ParseRequestInfo(
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszfnPolicy,
    OPTIONAL OUT INFVALUES **prgInfValues,
    OPTIONAL OUT DWORD *pcInfValues,
    OUT CRYPT_ATTRIBUTES **prgAttributes,
    OUT DWORD *pcAttributes,
    OUT CERT_EXTENSION **prgExt,
    OUT DWORD *pcExt,
    OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    CERT_EXTENSION *rgExtT;
    CERT_EXTENSION *rgExt = NULL;
    DWORD cExt;
    CRYPT_ATTR_BLOB *argValue[2] = { NULL, NULL };
    DWORD acValue[2];
    DWORD i;
    DWORD j;
    CRYPT_ATTRIBUTES *rgAttributes = NULL;
    DWORD cAttributes = 0;
    WCHAR *pwszTemplateNameInf = NULL;
    WCHAR *pwszTemplateName = NULL;
    HCERTTYPE hCertType = NULL;
    CERT_EXTENSIONS *pExtensions = NULL;
    
    if (NULL != prgInfValues)
    {
	*prgInfValues = NULL;
    }
    if (NULL != pcInfValues)
    {
	*pcInfValues = 0;
    }
    *prgAttributes = NULL;
    *pcAttributes = 0;
    *prgExt = NULL;
    *pcExt = 0;
    *ppwszTemplateName = NULL;

    hr = ParseInfFile(
		pwszfnPolicy,
		prgInfValues,
		pcInfValues,
		&argValue[0],
		&acValue[0],
		&rgExt,
		&cExt,
		&pwszTemplateNameInf);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnPolicy);
	_JumpError(hr, error, "ParseInfFile");
    }
    if (0 != acValue[0])
    {
	cAttributes++;
    }

    // Count the command line request attributes
    
    hr = BuildNameValuePairs(pwszAttributes, &acValue[1], NULL, NULL);
    _JumpIfError(hr, error, "BuildNameValuePairs");

    if (0 != acValue[1])
    {
	cAttributes++;

	argValue[1] = (CRYPT_ATTR_BLOB *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					acValue[1] * sizeof(argValue[1][0]));
	if (NULL == argValue[1])
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	hr = BuildNameValuePairs(
			pwszAttributes,
			&acValue[1],
			argValue[1],
			&pwszTemplateName);
	_JumpIfError(hr, error, "BuildNameValuePairs");
    }

    if (0 != cAttributes)
    {
	rgAttributes  = (CRYPT_ATTRIBUTES *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cAttributes * sizeof(rgAttributes[0]));
	if (NULL == rgAttributes)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	for (i = j = 0; i < cAttributes; i++, j++)
	{
	    CRYPT_ATTRIBUTE *rgAttr;

	    rgAttr = (CRYPT_ATTRIBUTE *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(rgAttributes[i].rgAttr[0]));
	    if (NULL == rgAttr)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    while (0 == acValue[j])
	    {
		j++;
	    }
	    rgAttributes[i].cAttr = 1;
	    rgAttributes[i].rgAttr = rgAttr;
	    
	    rgAttr[0].pszObjId = szOID_ENROLLMENT_NAME_VALUE_PAIR;
	    rgAttr[0].cValue = acValue[j];
	    rgAttr[0].rgValue = argValue[j];
	    argValue[j] = NULL;
	}
    }

    if (NULL != pwszTemplateName || NULL != pwszTemplateNameInf)
    {
	WCHAR const *pwsz;
	
	pwsz = pwszTemplateNameInf;
	if (NULL == pwsz)
	{
	    pwsz = pwszTemplateName;
	    CSASSERT(NULL != pwsz);
	}
	else if (NULL != pwszTemplateName &&
		 0 != mylstrcmpiL(pwszTemplateName, pwszTemplateNameInf))
	{
	    hr = CERTSRV_E_TEMPLATE_CONFLICT;
	    SetErrorString(wszPROPCERTTEMPLATE);
	    _JumpError(hr, error, "Template name conflict");
	}

	// Include the specified cert template's extensions

	hr = CAFindCertTypeByName(
		    pwsz,
		    NULL,
		    CT_FIND_LOCAL_SYSTEM |
			CT_ENUM_MACHINE_TYPES |
			CT_ENUM_USER_TYPES,
		    &hCertType);
	if (S_OK != hr)
	{
	    hr = CAFindCertTypeByName(
			pwsz,
			NULL,
			CT_FIND_LOCAL_SYSTEM |
			    CT_ENUM_MACHINE_TYPES |
			    CT_ENUM_USER_TYPES |
			    CT_FIND_BY_OID,
			&hCertType);
	    _PrintIfErrorStr(hr, "CAFindCertTypeByName", pwsz);
	}
	if (S_OK == hr)
	{
	    hr = CAGetCertTypeExtensions(hCertType, &pExtensions);
	    _PrintIfError(hr, "CAGetCertTypeExtensions");
	}
	if (S_OK == hr && NULL != pExtensions && 0 != pExtensions->cExtension)
	{
	    CERT_EXTENSION *pExtSrc;
	    CERT_EXTENSION *pExtSrcEnd;
	    CERT_EXTENSION *pExtDst;

	    rgExtT = (CERT_EXTENSION *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			(pExtensions->cExtension + cExt) * sizeof(rgExtT[0]));
	    if (NULL == rgExtT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    if (NULL != rgExt)
	    {
		CopyMemory(&rgExtT[0], &rgExt[0], cExt * sizeof(rgExtT[0]));
		LocalFree(rgExt);
	    }
	    rgExt = rgExtT;

	    pExtSrc = pExtensions->rgExtension;
	    pExtSrcEnd = &pExtSrc[pExtensions->cExtension];
	    pExtDst = &rgExt[cExt];
	    for ( ; pExtSrc < pExtSrcEnd; pExtSrc++, pExtDst++)
	    {
		pExtDst->fCritical = pExtSrc->fCritical;
		pExtDst->Value.cbData = pExtSrc->Value.cbData;

		hr = myDupStringA(pExtSrc->pszObjId, &pExtDst->pszObjId);
		_JumpIfError(hr, error, "myDupStringA");

		pExtDst->Value.pbData = (BYTE *) LocalAlloc(
						LMEM_FIXED,
						pExtSrc->Value.cbData);
		if (NULL == pExtDst->Value.pbData)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		CopyMemory(
			pExtDst->Value.pbData,
			pExtSrc->Value.pbData,
			pExtSrc->Value.cbData);
	    }
	    cExt += pExtensions->cExtension;
	}
	else
	{
	    CHAR const *pszObjId;

	    // Grow extension array to make room for the cert type extension

	    rgExtT = (CERT_EXTENSION *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    (cExt + 1) * sizeof(rgExtT[0]));
	    if (NULL == rgExtT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    if (0 != cExt)
	    {
		CSASSERT(NULL != rgExt);
		CopyMemory(&rgExtT[1], rgExt, cExt * sizeof(rgExt[0]));
		LocalFree(rgExt);
	    }
	    rgExt = rgExtT;
	    cExt++;

	    hr = myBuildCertTypeExtension(pwsz, &rgExt[0]);
	    _JumpIfError(hr, error, "myBuildCertTypeExtension");

	    pszObjId = rgExt[0].pszObjId;
	    rgExt[0].pszObjId = NULL;

	    hr = myDupStringA(pszObjId, &rgExt[0].pszObjId);
	    _JumpIfError(hr, error, "myDupStringA");
	}
    }
    myPackExtensionArray(TRUE, &cExt, &rgExt);

    *prgAttributes = rgAttributes;
    rgAttributes = NULL;
    *pcAttributes = cAttributes;

    *prgExt = rgExt;
    rgExt = NULL;
    *pcExt = cExt;

    if (NULL != pwszTemplateNameInf)
    {
	*ppwszTemplateName = pwszTemplateNameInf;
	pwszTemplateNameInf = NULL;
    }
    else
    if (NULL != pwszTemplateName)
    {
	*ppwszTemplateName = pwszTemplateName;
	pwszTemplateName = NULL;
    }
    hr = S_OK;

error:
    if (S_OK != hr && NULL != prgInfValues)
    {
	myInfFreeSectionValues(*pcInfValues, *prgInfValues);
	*prgInfValues = NULL;
	*pcInfValues = 0;
    }
    if (NULL != rgAttributes)
    {
	FreeAttributes(cAttributes, rgAttributes);
    }
    for (i = 0; i < ARRAYSIZE(argValue); i++)
    {
	if (NULL != argValue[i])
	{
	    myInfFreeRequestAttributes(acValue[i], argValue[i]);
	}
    }
    if (NULL != rgExt)
    {
	FreeExtensions(TRUE, cExt, rgExt);
    }
    if (NULL != pwszTemplateNameInf)
    {
	LocalFree(pwszTemplateNameInf);
    }
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    if (NULL != hCertType)
    {
        if (NULL != pExtensions)
        {
            CAFreeCertTypeExtensions(hCertType, pExtensions);
        }
        CACloseCertType(hCertType);
    }
    return(hr);
}


HRESULT
CreateQualifiedRequest(
    IN HWND hWndOwner,
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszfnReq,
    IN WCHAR const *pwszfnPolicy,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszfnPKCS10)
{
    HRESULT hr;
    BYTE *pbReq = NULL;
    DWORD cbReq;
    BYTE *pbKeyId = NULL;
    DWORD cbKeyId = 0;
    BYTE *pbReqCMCFirstSigned = NULL;
    DWORD cbReqCMCFirstSigned;
    BYTE *pbReqCMCOut = NULL;
    DWORD cbReqCMCOut;
    LONG dwFlags;
    BOOL fNestedCMCRequest = FALSE;
    BOOL fSigned;
    CRYPT_ATTRIBUTES *rgAttributes = NULL;
    DWORD cAttributes;
    CERT_EXTENSION *rgExt = NULL;
    DWORD cExt;
    WCHAR *pwszTemplateName = NULL;
    WCHAR *pwszTemplateNameRequest = NULL;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec = 0;
    BOOL fCallerFreeProv;
    BOOL fCA;
    
    cAttributes = 0;
    cExt = 0;
    fCallerFreeProv = FALSE;

    // Read the request from a file, convert it to binary, and return
    // dwFlags to indicate the orignal encoding and the detected format.

    hr = CheckRequestType(
		    pwszfnReq,
		    &pbReq,
		    &cbReq,
		    &dwFlags,
		    &fSigned,
		    &fCA,
		    &pwszTemplateNameRequest);
    _JumpIfError(hr, error, "CheckRequestType");

    hr = ParseRequestInfo(
		pwszAttributes,
		pwszfnPolicy,
		NULL,		// prgInfValues
		NULL,		// pcInfValues
		&rgAttributes,
		&cAttributes,
		&rgExt,
		&cExt,
		&pwszTemplateName);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnPolicy);
	_JumpError(hr, error, "ParseRequestInfo");
    }

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    switch (CR_IN_FORMATMASK & dwFlags)
    {
	case CR_IN_CMC:
	    fNestedCMCRequest = TRUE;
	    break;

	case CR_IN_CERT:
	    hr = ConvertCertToPKCS10Request(
				NULL != pwszTemplateName?
				    pwszTemplateName : pwszTemplateNameRequest,
				&fCA,
				rgExt,
				cExt,
				&pbReq,
				&cbReq);
	    _JumpIfError(hr, error, "ConvertCertToPKCS10Request");

	    if (NULL != rgExt)
	    {
		FreeExtensions(TRUE, cExt, rgExt);
		rgExt = NULL;
		cExt = 0;
	    }
	    dwFlags = CR_IN_PKCS10 | (~CR_IN_FORMATMASK & dwFlags);
	    break;

	case CR_IN_PKCS10:
	    break;

	default:
	    _JumpError(hr, error, "not a CMC or PKCS10 request");
    }
    fCallerFreeProv = FALSE;
    if (CR_IN_PKCS10 == (CR_IN_FORMATMASK & dwFlags))
    {
	if (NULL != pwszfnPKCS10)
	{
	    hr = crOverwriteFileAllowed(hWndOwner, pwszfnPKCS10);
	    _JumpIfError(hr, error, "crOverwriteFileAllowed");

	    hr = EncodeToFileW(
			pwszfnPKCS10,
			pbReq,
			cbReq,
			DECF_FORCEOVERWRITE | g_dwOutFormat);
	    if (S_OK != hr)
	    {
		SetErrorString(pwszfnPKCS10);
		_JumpErrorStr(hr, error, "EncodeToFileW", pwszfnPKCS10);
	    }
	}

	hr = GetPKCS10PrivateKey(
			pbReq,
			cbReq,
			&hProv,
			&dwKeySpec,
			&fCallerFreeProv,
			&pbKeyId,
			&cbKeyId);
	_PrintIfError(hr, "GetPKCS10PrivateKey");
    }

    if (fCA)
    {
	hr = AddCAExtensions(&rgExt, &cExt);
	_JumpIfError(hr, error, "AddCAExtensions");
    }

    hr = BuildCMCRequest(
		    XECI_CERTREQ,
		    fNestedCMCRequest,
		    pbReq,
		    cbReq,
		    rgExt,
		    cExt,
		    rgAttributes,
		    cAttributes,
		    NULL,		// rgAttributeUnauth
		    0,			// cAttributeUnauth
		    pbKeyId,
		    cbKeyId,
		    hProv,
		    dwKeySpec,
		    NULL == hProv? NULL : g_pszObjIdHash,
		    NULL,		// pCertSigner
		    NULL,		// hProvSigner
		    0,			// dwKeySpecSigner
		    NULL,		// pszObjIdHashSigner
		    &pbReqCMCFirstSigned,
		    &cbReqCMCFirstSigned);
    _JumpIfError(hr, error, "BuildCMCRequest");

    hr = PickCertAndSignRequest(
			    pbReqCMCFirstSigned,
			    cbReqCMCFirstSigned,
			    TRUE,
			    NULL != pwszTemplateName?
				pwszTemplateName : pwszTemplateNameRequest,
			    &pbReqCMCOut,
			    &cbReqCMCOut);
    if (S_OK != hr)
    {
	_PrintError2(hr, "PickCertAndSignRequest", S_FALSE);
	if (S_FALSE != hr)
	{
	    goto error;
	}

	// The user cancelled out of the cert picker U/I, so just save the
	// unsigned request.

	pbReqCMCOut = pbReqCMCFirstSigned;
	cbReqCMCOut = cbReqCMCFirstSigned;
    }

    hr = WriteCertificateOrRequest(
			hWndOwner,
    			NULL,		// pdiRequest
			pbReqCMCOut,
			cbReqCMCOut,
			g_dwOutFormat,
			IDS_REQUEST_OUTFILE_TITLE,
			IDS_REQUEST_FILE_FILTER,
			IDS_REQUEST_FILE_DEFEXT,
			pwszfnOut);
    _JumpIfError(hr, error, "WriteCertificateOrRequest");

error:
    if (NULL != hProv && fCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pwszTemplateNameRequest)
    {
	LocalFree(pwszTemplateNameRequest);
    }
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    if (NULL != rgExt)
    {
	FreeExtensions(TRUE, cExt, rgExt);
    }
    if (NULL != rgAttributes)
    {
	FreeAttributes(cAttributes, rgAttributes);
    }
    if (NULL != pbReqCMCOut && pbReqCMCFirstSigned != pbReqCMCOut)
    {
	LocalFree(pbReqCMCOut);
    }
    if (NULL != pbReqCMCFirstSigned)
    {
	LocalFree(pbReqCMCFirstSigned);
    }
    if (NULL != pbKeyId)
    {
	LocalFree(pbKeyId);
    }
    if (NULL != pbReq)
    {
	LocalFree(pbReq);
    }
    return(hr);
}


HRESULT
GetCAXchgCert(
    IN WCHAR const *pwszValue,
    OUT CERT_CONTEXT const **ppccXchg)
{
    HRESULT hr;
    BOOL fEnabled;
    BSTR strConfig = NULL;
    BSTR strCert = NULL;
    WCHAR const *pwszConfig;
    DISPATCHINTERFACE diRequest;
    BOOL fMustRelease = FALSE;

    *ppccXchg = NULL;

    hr = myInfParseBooleanValue(pwszValue, &fEnabled);
    _JumpIfError(hr, error, "myInfParseBooleanValue");

    if (fEnabled)
    {
	pwszConfig = g_pwszConfig;
	if (NULL == pwszConfig)
	{
	    hr = crGetConfig(&strConfig);
	    _JumpIfError(hr, error, "crGetConfig");

	    pwszConfig = strConfig;
	}

	hr = Request_Init(g_fIDispatch, &diRequest);
	if (S_OK != hr)
	{
	    _PrintError(hr, "Request_Init");
	    if (E_ACCESSDENIED == hr)	// try for a clearer error message
	    {
		hr = CO_E_REMOTE_COMMUNICATION_FAILURE;
	    }
	    _JumpError(hr, error, "Request_Init");
	}
	fMustRelease = TRUE;

	hr = Request2_GetCAProperty(
			&diRequest,
			pwszConfig,
			CR_PROP_CAXCHGCERT,
			0,			// Index
			PROPTYPE_BINARY,
			CV_OUT_BINARY,
			(VOID *) &strCert);
	_JumpIfError(hr, error, "Request2_GetCAProperty");

	*ppccXchg = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    (BYTE const *) strCert,
				    SysStringByteLen(strCert));
	if (NULL == *ppccXchg)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}

    }
    hr = S_OK;

error:
    if (NULL != strConfig)
    {
    	SysFreeString(strConfig);
    }
    if (NULL != strCert)
    {
    	SysFreeString(strCert);
    }
    if (fMustRelease)
    {
    	Request_Release(&diRequest);
    }
    return(hr);
}


HRESULT
GetRenewalCert(
    IN WCHAR const *pwszValue,
    OUT CERT_CONTEXT const **ppccRenewal)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strCert = NULL;
    DISPATCHINTERFACE diRequest;
    BOOL fMustRelease = FALSE;

    *ppccRenewal = NULL;

    hr = myGetCertificateFromPicker(
		    g_hInstance,
		    NULL,		// hwndParent
		    IDS_GETRENEWALCERT_TITLE,
		    IDS_GETRENEWALCERT_SUBTITLE,
		    CUCS_MYSTORE |
			CUCS_MACHINESTORE | CUCS_USERSTORE |
			CUCS_DSSTORE |
			CUCS_PRIVATEKEYREQUIRED |
			(g_fVerbose? CUCS_ARCHIVED : 0) |
			(g_fQuiet? CUCS_SILENT : 0),
		    (L'\0' == pwszValue || 0 == lstrcmp(L"*", pwszValue))?
			NULL : pwszValue, // pwszCommonName
		    0,			// cStore
		    NULL,		// rghStore
		    0,			// cpszObjId
		    NULL,		// apszObjId
		    ppccRenewal);
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

    if (NULL == *ppccRenewal)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	_JumpError(hr, error, "myGetCertificateFromPicker");
    }

error:
    if (NULL != strConfig)
    {
    	SysFreeString(strConfig);
    }
    if (NULL != strCert)
    {
    	SysFreeString(strCert);
    }
    if (fMustRelease)
    {
    	Request_Release(&diRequest);
    }
    return(hr);
}


HRESULT
CreateNewRequest(
    IN HWND hWndOwner,
    OPTIONAL IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszfnPolicy,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    IEnroll4 *pEnroll = NULL;
    CRYPT_DATA_BLOB blobRequest;
    WCHAR *pwszObjId = NULL;
    DWORD cInfValues;
    INFVALUES *rgInfValues = NULL;
    CRYPT_ATTRIBUTES *rgAttributes = NULL;
    DWORD cAttributes;
    CERT_EXTENSION *rgExt = NULL;
    WCHAR *pwszTemplateName = NULL;
    CERT_CONTEXT const *pccXchg = NULL;
    CERT_CONTEXT const *pccRenewal = NULL;
    CERT_CONTEXT const *pccSigner = NULL;
    CERT_NAME_BLOB NameBlob;
    WCHAR *pwszDN = NULL;
    DWORD cExt = 0;
    DWORD i;
    DWORD j;
    DWORD k;
    DWORD RequestTypeFlags;
    BOOL fRequestTypeSet;
    BOOL fKeyUsageSet;
    
    blobRequest.pbData = NULL;
    NameBlob.pbData = NULL;
    cAttributes = 0;

    hr = ParseRequestInfo(
		pwszAttributes,
		pwszfnPolicy,
		&rgInfValues,
		&cInfValues,
		&rgAttributes,
		&cAttributes,
		&rgExt,
		&cExt,
		&pwszTemplateName);
    if (S_OK != hr)
    {
	SetErrorString(pwszfnPolicy);
	_JumpError(hr, error, "ParseRequestInfo");
    }

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                       CLSID_CEnroll,
                       NULL,               // pUnkOuter
                       CLSCTX_INPROC_SERVER,
                       IID_IEnroll4,
                       (VOID **) &pEnroll);
    _JumpIfError(hr, error, "CoCreateInstance");

    fKeyUsageSet = FALSE;
    fRequestTypeSet = FALSE;
    RequestTypeFlags = XECR_PKCS10_V2_0;
    for (i = 0; i < cInfValues; i++)
    {
	INFVALUES *pInfValues = &rgInfValues[i];
	WCHAR const *pwszInfValue;
	LONG lFlagsT;
	BOOL fT;
	BOOL fValid;

	if (1 != pInfValues->cValues)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    SetErrorStringInf(pwszfnPolicy, pInfValues);
	    _JumpError(hr, error, "Wrong value count");
	}

	pwszInfValue = pInfValues->rgpwszValues[0];
	if (NULL == pwszDN &&
	    0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_SUBJECT))
	{
	    // Reverse the name for XEnroll!?

	    hr = myCertStrToName(
		    X509_ASN_ENCODING,
		    pwszInfValue,	 // pszX500
		    0,			 // CERT_NAME_STR_REVERSE_FLAG,
		    NULL,		 // pvReserved
		    &NameBlob.pbData,
		    &NameBlob.cbData,
		    NULL);		 // ppszError
	    _JumpIfError(hr, error, "myCertStrToName");

	    hr = myCertNameToStr(
			X509_ASN_ENCODING,
			&NameBlob,
			CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			&pwszDN);
	    _JumpIfError(hr, error, "myCertNameToStr");
	}
	else
	if (NULL == pccXchg &&
	    0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_PRIVATEKEYARCHIVE))
	{
	    hr = GetCAXchgCert(pwszInfValue, &pccXchg);
	    _JumpIfError(hr, error, "GetCAXchgCert");
	}
	else
	if (NULL == pccRenewal &&
	    0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_RENEWALCERT))
	{
	    hr = GetRenewalCert(pwszInfValue, &pccRenewal);
	    _JumpIfError(hr, error, "GetRenewalCert");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_KEYSPEC))
	{
	    DWORD dwKeySpec;
	    
	    dwKeySpec = myWtoI(pwszInfValue, &fValid);
	    if (!fValid ||
		(AT_SIGNATURE != dwKeySpec && AT_KEYEXCHANGE != dwKeySpec))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpError(hr, error, "Bad KeySpec value");
	    }
	    hr = pEnroll->put_KeySpec(dwKeySpec);
	    _JumpIfError(hr, error, "put_KeySpec");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_KEYLENGTH))
	{
	    DWORD dwKeyLength;
	    
	    dwKeyLength = myWtoI(pwszInfValue, &fValid);
	    if (!fValid || 0 == dwKeyLength || 64 * 1024 <= dwKeyLength)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpError(hr, error, "Bad KeyLength value");
	    }
	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~KEY_LENGTH_MASK;
	    lFlagsT |= dwKeyLength << 16;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_EXPORTABLE))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~CRYPT_EXPORTABLE;
	    lFlagsT |= fT? CRYPT_EXPORTABLE : 0;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_USERPROTECTED))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~CRYPT_USER_PROTECTED;
	    lFlagsT |= fT? CRYPT_USER_PROTECTED : 0;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_KEYCONTAINER))
	{
	    hr = pEnroll->put_ContainerNameWStr(
					const_cast<WCHAR *>(pwszInfValue));
	    _JumpIfError(hr, error, "put_ContainerNameWStr");
	}
#if 0
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_HASHALGID))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~CRYPT_EXPORTABLE;
	    lFlagsT |= fT? CRYPT_EXPORTABLE : 0;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_HASHALGORITHM))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_GenKeyFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_GenKeyFlags");

	    lFlagsT &= ~CRYPT_EXPORTABLE;
	    lFlagsT |= fT? CRYPT_EXPORTABLE : 0;

	    hr = pEnroll->put_GenKeyFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_GenKeyFlags");
	}
#endif
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_MACHINEKEYSET))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_ProviderFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_ProviderFlags");

	    lFlagsT &= ~CRYPT_MACHINE_KEYSET;
	    lFlagsT |= fT? CRYPT_MACHINE_KEYSET : 0;

	    hr = pEnroll->put_ProviderFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_ProviderFlags");

	    hr = pEnroll->get_MyStoreFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_MyStoreFlags");

	    lFlagsT &= ~(CERT_SYSTEM_STORE_CURRENT_USER |
			 CERT_SYSTEM_STORE_LOCAL_MACHINE);
	    lFlagsT |= fT? CERT_SYSTEM_STORE_LOCAL_MACHINE :
			   CERT_SYSTEM_STORE_CURRENT_USER;

	    hr = pEnroll->put_MyStoreFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_MyStoreFlags");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_SILENT))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->get_ProviderFlags(&lFlagsT);
	    _JumpIfError(hr, error, "get_ProviderFlags");

	    lFlagsT &= ~CRYPT_SILENT;
	    lFlagsT |= fT? CRYPT_SILENT : 0;

	    hr = pEnroll->put_ProviderFlags(lFlagsT);
	    _JumpIfError(hr, error, "put_ProviderFlags");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_PROVIDERNAME))
	{
	    hr = pEnroll->put_ProviderNameWStr(
					const_cast<WCHAR *>(pwszInfValue));
	    _JumpIfError(hr, error, "put_ProviderNameWStr");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_PROVIDERTYPE))
	{
	    lFlagsT = myWtoI(pwszInfValue, &fValid);
	    if (!fValid)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpError(hr, error, "Bad ProviderType value");
	    }
	    hr = pEnroll->put_ProviderType(lFlagsT);
	    _JumpIfError(hr, error, "put_ProviderType");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_USEEXISTINGKEYSET))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->put_UseExistingKeySet(fT);
	    _JumpIfError(hr, error, "put_UseExistingKeySet");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_SMIME))
	{
	    hr = myInfParseBooleanValue(pwszInfValue, &fT);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->put_EnableSMIMECapabilities(fT);
	    _JumpIfError(hr, error, "put_EnableSMIMECapabilities");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_REQUESTERNAME))
	{
	    hr = pEnroll->AddNameValuePairToSignatureWStr(
					wszINFKEY_REQUESTERNAME,
					const_cast<WCHAR *>(pwszInfValue));
	    _JumpIfError(hr, error, "AddNameValuePairToSignatureWStr");
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_REQUESTTYPE))
	{
	    if (0 == LSTRCMPIS(pwszInfValue, wszINFVALUE_REQUESTTYPE_PKCS101))
	    {
		RequestTypeFlags = XECR_PKCS10_V1_5;
	    }
	    else
	    if (0 == LSTRCMPIS(pwszInfValue, wszINFVALUE_REQUESTTYPE_PKCS10))
	    {
		RequestTypeFlags = XECR_PKCS10_V2_0;
	    }
	    else
	    if (0 == LSTRCMPIS(pwszInfValue, wszINFVALUE_REQUESTTYPE_PKCS7))
	    {
		RequestTypeFlags = XECR_PKCS7;
	    }
	    else
	    if (0 == LSTRCMPIS(pwszInfValue, wszINFVALUE_REQUESTTYPE_CMC))
	    {
		RequestTypeFlags = XECR_CMC;
	    }
	    else
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpErrorStr(hr, error, "Bad RequestType value", pwszInfValue);
	    }
	    fRequestTypeSet = TRUE;
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_KEYUSAGE))
	{
	    CRYPT_BIT_BLOB KeyUsage;
	    CRYPT_DATA_BLOB BlobKeyUsage;

	    lFlagsT = myWtoI(pwszInfValue, &fValid);
	    if (!fValid)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		SetErrorStringInf(pwszfnPolicy, pInfValues);
		_JumpError(hr, error, "Bad KeyUsage value");
	    }
	    KeyUsage.cbData = sizeof(lFlagsT);
	    KeyUsage.pbData = (BYTE *) &lFlagsT;
	    KeyUsage.cUnusedBits = 0;
	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    &KeyUsage,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &BlobKeyUsage.pbData,
			    &BlobKeyUsage.cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Policy:myEncodeObject");
	    }

	    hr = pEnroll->addExtensionToRequestWStr(
					    0,
					    TEXT(szOID_KEY_USAGE),
					    &BlobKeyUsage);
	    LocalFree(BlobKeyUsage.pbData);
	    _JumpIfError(hr, error, "addExtensionToRequestWStr");

	    fKeyUsageSet = TRUE;
	}
	else
	if (0 == LSTRCMPIS(pInfValues->pwszKey, wszINFKEY_ENCIPHERONLY))
	{
	    BOOL fEnciperOnly;
	    
	    hr = myInfParseBooleanValue(pwszInfValue, &fEnciperOnly);
	    _JumpIfError(hr, error, "myInfParseBooleanValue");

	    hr = pEnroll->put_LimitExchangeKeyToEncipherment(fEnciperOnly);
	    _JumpIfError(hr, error, "put_LimitExchangeKeyToEncipherment");
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    SetErrorStringInf(pwszfnPolicy, pInfValues);
	    _JumpErrorStr(hr, error, "bad Inf key", pInfValues->pwszKey);
	}
    }

    for (i = 0; i < cAttributes; i++)
    {
	CRYPT_ATTRIBUTES *pAttributes = &rgAttributes[i];

	for (j = 0; j < pAttributes->cAttr; j++)
	{
	    CRYPT_ATTRIBUTE *pAttr = &pAttributes->rgAttr[j];

	    if (NULL != pwszObjId)
	    {
		LocalFree(pwszObjId);
		pwszObjId = NULL;
	    }
	    if (!ConvertSzToWsz(&pwszObjId, pAttr->pszObjId, -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "ConvertSzToWsz");
	    }
	    for (k = 0; k < pAttr->cValue; k++)
	    {
		hr = pEnroll->addAttributeToRequestWStr(
					    0,		// Flags
					    pwszObjId,
					    &pAttr->rgValue[k]);
		_JumpIfError(hr, error, "addAttributeToRequestWStr");
	    }
	}
    }
    for (i = 0; i < cExt; i++)
    {
	CERT_EXTENSION *pExt = &rgExt[i];

	if (fKeyUsageSet && 0 == strcmp(szOID_KEY_USAGE, pExt->pszObjId))
	{
	    continue;
	}
	if (NULL != pwszObjId)
	{
	    LocalFree(pwszObjId);
	    pwszObjId = NULL;
	}
	if (!ConvertSzToWsz(&pwszObjId, pExt->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz");
	}
	hr = pEnroll->addExtensionToRequestWStr(
					pExt->fCritical,
					pwszObjId,
					&pExt->Value);
	_JumpIfError(hr, error, "addExtensionToRequestWStr");
    }

    if (NULL != g_pwszCertCN)
    {
	if (!g_fQuiet || NULL != g_pwszCertCN)
	{
	    hr = myGetCertificateFromPicker(
		    g_hInstance,
		    NULL,		// hwndParent
		    IDS_GETSIGNINGCERT_TITLE,
		    IDS_GETSIGNINGCERT_SUBTITLE,
		    CUCS_MYSTORE |
			CUCS_PRIVATEKEYREQUIRED |
			(g_fQuiet? CUCS_SILENT : 0),
		    (L'\0' == g_pwszCertCN || 0 == lstrcmp(L"*", g_pwszCertCN))?
			NULL : g_pwszCertCN,	// pwszCommonName
		    0,				// cStore
		    NULL,			// rghStore
		    0,				// cpszObjId
		    NULL,			// apszObjId
		    &pccSigner);
	    _JumpIfError(hr, error, "myGetCertificateFromPicker");
	}

	// pccSigner is NULL if the user cancelled out of the cert picker U/I.

	if (NULL == pccSigner)
	{
	    if (g_fQuiet || NULL != g_pwszCertCN)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "no matching signer CN");
	    }
	}
	hr = pEnroll->SetSignerCertificate(pccSigner);
	_JumpIfError(hr, error, "SetSignerCertificate");
    }
    if (NULL != pccXchg)
    {
	LONG lGenKeyFlags;

	hr = pEnroll->SetPrivateKeyArchiveCertificate(pccXchg);
	_JumpIfError(hr, error, "SetPrivateKeyArchiveCertificate");

        hr = pEnroll->get_GenKeyFlags(&lGenKeyFlags);
	_JumpIfError(hr, error, "getGenKeyFlags");

	if (0 == (CRYPT_EXPORTABLE & lGenKeyFlags))
	{
	    hr = pEnroll->put_GenKeyFlags(CRYPT_EXPORTABLE | lGenKeyFlags);
	    _JumpIfError(hr, error, "putGenKeyFlags");
	}
    }
    if (NULL != pccRenewal)
    {
	hr = pEnroll->put_RenewalCertificate(pccRenewal);
	_JumpIfError(hr, error, "put_RenewalCertificate");
    }
    if (!fRequestTypeSet)
    {
	if (NULL != pccXchg)
	{
	    RequestTypeFlags = XECR_CMC;
	}
	else if (NULL != pccRenewal)
	{
	    RequestTypeFlags = XECR_PKCS7;
	}
    }
    hr = pEnroll->createRequestWStr(
			RequestTypeFlags,
			pwszDN,
			NULL,
			&blobRequest);
    _JumpIfError(hr, error, "createRequestWStr");

    myRegisterMemAlloc(blobRequest.pbData, blobRequest.cbData, CSM_LOCALALLOC);

    hr = WriteCertificateOrRequest(
			hWndOwner,
    			NULL,		// pdiRequest
			blobRequest.pbData,
			blobRequest.cbData,
			g_dwOutFormat,
			IDS_REQUEST_OUTFILE_TITLE,
			IDS_REQUEST_FILE_FILTER,
			IDS_REQUEST_FILE_DEFEXT,
			pwszfnOut);
    _JumpIfError(hr, error, "WriteCertificateOrRequest");

error:
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    if (NULL != NameBlob.pbData)
    {
	LocalFree(NameBlob.pbData);
    }
    if (NULL != pccXchg)
    {
	CertFreeCertificateContext(pccXchg);
    }
    if (NULL != pccRenewal)
    {
	CertFreeCertificateContext(pccRenewal);
    }
    if (NULL != pccSigner)
    {
	CertFreeCertificateContext(pccSigner);
    }
    if (NULL != rgInfValues)
    {
	myInfFreeSectionValues(cInfValues, rgInfValues);
    }
    if (NULL != rgAttributes)
    {
	FreeAttributes(cAttributes, rgAttributes);
    }
    if (NULL != rgExt)
    {
	FreeExtensions(TRUE, cExt, rgExt);
    }
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    if (NULL != blobRequest.pbData)
    {
	LocalFree(blobRequest.pbData);
    }
    if (NULL != pEnroll)
    {
	pEnroll->Release();
    }
    if (fCoInit)
    {
    	CoUninitialize();
    }
    return(hr);
}


HRESULT
MakePKCS7FromCert(
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    OUT BYTE **ppbChain,
    OUT DWORD *pcbChain)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CRYPT_SIGN_MESSAGE_PARA csmp;
    CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithm = { szOID_OIWSEC_sha1, 0, 0 };

    *ppbChain = NULL;
    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    // init csmp for empty signature

    ZeroMemory(&csmp, sizeof(csmp));
    csmp.cbSize = sizeof(csmp);
    csmp.dwMsgEncodingType = PKCS_7_ASN_ENCODING;
    //csmp.pSigningCert = NULL;
    csmp.HashAlgorithm = DigestAlgorithm;
    csmp.cMsgCert = 1;
    csmp.rgpMsgCert = &pcc;
    //csmp.cMsgCrl = 0;
    //csmp.rgpMsgCrl = NULL;

    if (!myCryptSignMessage(
			&csmp,
			pbCert,		// pbToBeSigned
			cbCert,		// cbToBeSigned
			CERTLIB_USE_LOCALALLOC,
			ppbChain,
			pcbChain))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptSignMessage");
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
AcceptResponse(
    IN WCHAR const *pwszfnIn)
{
    HRESULT hr;
    WCHAR *pwszMsg = NULL;
    WCHAR awchr[cwcHRESULTSTRING];
    CRYPT_DATA_BLOB blobIn;
    CRYPT_DATA_BLOB blobCert7;
    char *pszInnerContentObjId = NULL;
    DWORD dwType;
    BYTE *pbDecoded = NULL;
    DWORD cb;
    BOOL fCoInit = FALSE;
    IEnroll4 *pEnroll = NULL;

    blobIn.pbData = NULL;
    blobCert7.pbData = NULL;
    hr = DecodeFileW(
		pwszfnIn,
		&blobIn.pbData,
		&blobIn.cbData,
		CRYPT_STRING_BASE64_ANY);
    if (S_OK != hr)
    {
	if (S_OK == myLoadRCString(
			    g_hInstance,
			    IDS_FORMATSTR_DECODE_ERR,
			    &pwszMsg))
	{
	    CSASSERT(NULL != pwszMsg);
	    wprintf(pwszMsg, myHResultToString(awchr, hr));
	    wprintf(g_wszNewLine);
	}
	goto error;
    }

    dwType = CR_IN_CERT;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    blobIn.pbData,
		    blobIn.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbDecoded,
		    &cb))
    {
	//_PrintError(myHLastError(), "myDecodeObject(Cert)");
	CSASSERT(NULL == pbDecoded);

	dwType = CR_IN_PKCS7; // PKCS 7 renewal request?
	hr = myDecodePKCS7(
			blobIn.pbData,
			blobIn.cbData,
			NULL,		// ppbContents
			NULL,		// pcbContents
			NULL,		// pdwMsgType
			&pszInnerContentObjId,
			NULL,		// pcSigner
			NULL,		// pcRecipient
			NULL,		// phStore
			NULL);		// phMsg
	_JumpIfError(hr, error, "myDecodePKCS7");

	if (NULL != pszInnerContentObjId &&
	    0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_RESPONSE))
	{
	    dwType = CR_IN_CMC;
	}
    }
    if (CR_IN_CERT == dwType)
    {
	hr = MakePKCS7FromCert(
			blobIn.pbData,
			blobIn.cbData,
			&blobCert7.pbData,
			&blobCert7.cbData);
	_JumpIfError(hr, error, "MakePKCS7FromCert");
    }

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                       CLSID_CEnroll,
                       NULL,               // pUnkOuter
                       CLSCTX_INPROC_SERVER,
                       IID_IEnroll4,
                       (VOID **) &pEnroll);
    _JumpIfError(hr, error, "CoCreateInstance");

    if (CR_IN_CMC == dwType)
    {
	hr = pEnroll->acceptResponseBlob(&blobIn);
	_PrintIfError2(hr, "acceptResponseBlob", CRYPT_E_NOT_FOUND);
    }
    else
    {
	hr = pEnroll->acceptPKCS7Blob(
			    NULL != blobCert7.pbData? &blobCert7 : &blobIn);
	_PrintIfError2(hr, "acceptPKCS7Blob", CRYPT_E_NOT_FOUND);
    }
    if (S_OK != hr)
    {
	HRESULT hr2 = hr;
	LONG lFlagsT;
	BOOL fT;

	hr = pEnroll->get_ProviderFlags(&lFlagsT);
	_JumpIfError(hr, error, "get_ProviderFlags");

	fT = 0 == (CRYPT_MACHINE_KEYSET & lFlagsT);
	lFlagsT &= ~CRYPT_MACHINE_KEYSET;
	lFlagsT |= fT? CRYPT_MACHINE_KEYSET : 0;

	hr = pEnroll->put_ProviderFlags(lFlagsT);
	_JumpIfError(hr, error, "put_ProviderFlags");

	hr = pEnroll->get_MyStoreFlags(&lFlagsT);
	_JumpIfError(hr, error, "get_MyStoreFlags");

	lFlagsT &= ~(CERT_SYSTEM_STORE_CURRENT_USER |
		     CERT_SYSTEM_STORE_LOCAL_MACHINE);
	lFlagsT |= fT? CERT_SYSTEM_STORE_LOCAL_MACHINE :
		       CERT_SYSTEM_STORE_CURRENT_USER;

	hr = pEnroll->put_MyStoreFlags(lFlagsT);
	_JumpIfError(hr, error, "put_MyStoreFlags");

	if (CR_IN_CMC == dwType)
	{
	    hr = pEnroll->acceptResponseBlob(&blobIn);
	    _PrintIfError(hr, "acceptResponseBlob");
	}
	else
	{
	    hr = pEnroll->acceptPKCS7Blob(
				NULL != blobCert7.pbData? &blobCert7 : &blobIn);
	    _PrintIfError(hr, "acceptPKCS7Blob");
	}

	// If accepting the response in machine context didn't work, return the
	// first error (the user context error).

	if (S_OK != hr)
	{
	    hr = hr2;
	}
	_JumpIfError(hr, error, "AcceptResponse");
    }

error:
    if (NULL != pwszMsg)
    {
	LocalFree(pwszMsg);
    }
    if (NULL != blobIn.pbData)
    {
	LocalFree(blobIn.pbData);
    }
    if (NULL != blobCert7.pbData)
    {
	LocalFree(blobCert7.pbData);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    if (NULL != pEnroll)
    {
	pEnroll->Release();
    }
    if (fCoInit)
    {
    	CoUninitialize();
    }
    return(hr);
}


HRESULT
ArgvMain(
    int argc,
    WCHAR *argv[],
    HWND hWndOwner)
{
    HRESULT hr;
    WCHAR *pwszOFN = NULL;
    WCHAR *pwszOFN2 = NULL;
    WCHAR const *pwszfnIn;
    WCHAR const *pwszfnOut;
    WCHAR const *pwszfnPKCS10;
    WCHAR const *pwszfnCertChain;
    WCHAR const *pwszfnFullResponse;
    WCHAR const *pwszfnPolicy;
    LONG RequestId;
    WCHAR *pwszAttributes = NULL;
    WCHAR const *pwszSerialNumber = NULL;
    DWORD cCommand = 0;
    int cArgMax = 0;
    WCHAR *rgpwszArg[4];
    UINT idsFileFilter;
    UINT idsFileDefExt;

    myVerifyResourceStrings(g_hInstance);
    while (1 < argc && myIsSwitchChar(argv[1][0]))
    {
	if (0 == LSTRCMPIS(&argv[1][1], L"config"))
	{
	    if (2 >= argc)
	    {
		_PrintError(E_INVALIDARG, "missing -config arg");
		Usage(TRUE);
	    }
	    if (myIsMinusSignString(argv[2]) || 0 == wcscmp(argv[2], L"*"))
	    {
		g_dwUIFlag = CC_LOCALACTIVECONFIG;
	    }
	    else
	    {
		g_pwszConfig = argv[2];
	    }
	    argc--;
	    argv++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"any"))
	{
	    g_fAny = TRUE;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"crl"))
	{
	    g_dwCRLIn = CR_IN_CRLS;
	    g_dwCRLOut = CR_OUT_CRLS;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"rpc"))
	{
	    g_fRPC++;
	    if (0 == lstrcmp(&argv[1][1], L"RPC"))
	    {
		g_fRPC++;
	    }
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"binary"))
	{
	    g_dwOutFormat = CR_OUT_BINARY;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"idispatch"))
	{
	    g_fIDispatch = TRUE;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"submit"))
	{
	    g_dwCommand = cmdSUBMITREQUEST;
	    cArgMax = 4;
	    cCommand++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"retrieve"))
	{
	    g_dwCommand = cmdRETRIEVEPENDING;
	    cArgMax = 4;
	    cCommand++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"policy"))
	{
	    g_dwCommand = cmdQUALIFIEDREQUEST;
	    cArgMax = 4;
	    cCommand++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"new"))
	{
	    g_dwCommand = cmdNEWREQUEST;
	    cArgMax = 2;
	    cCommand++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"accept"))
	{
	    g_dwCommand = cmdACCEPTRESPONSE;
	    cArgMax = 1;
	    cCommand++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"sign"))
	{
	    g_dwCommand = cmdSIGNREQUEST;
	    cArgMax = 2;
	    cCommand++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"v1"))
	{
	    g_fV1Interface = TRUE;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"v"))
	{
	    g_fVerbose = TRUE;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"f"))
	{
	    g_fForce++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"q"))
	{
	    g_fQuiet = TRUE;
	    g_dwUIFlag = CC_LOCALACTIVECONFIG;
	}
	else
	if (0 == lstrcmp(&argv[1][1], L"?") ||
	    0 == LSTRCMPIS(&argv[1][1], L"usage"))
	{
	    g_fFullUsage = 0 == lstrcmp(&argv[1][1], L"uSAGE");
	    Usage(FALSE);
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"attrib"))
	{
	    if (2 >= argc)
	    {
		_PrintError(E_INVALIDARG, "missing -attrib arg");
		Usage(TRUE);
	    }
	    hr = crCombineAttributes(argv[2], &pwszAttributes);
	    _JumpIfError(hr, error, "crCombineAttributes");

	    argc--;
	    argv++;
	}
	else
	if (0 == LSTRCMPIS(&argv[1][1], L"cert"))
	{
	    if (2 >= argc)
	    {
		_PrintError(E_INVALIDARG, "missing -cert arg");
		Usage(TRUE);
	    }
	    g_pwszCertCN = argv[2];
	    argc--;
	    argv++;
	}
	else
	{
	    _PrintError(E_INVALIDARG, "Unknown arg");
	    Usage(TRUE);
	}
	argc--;
	argv++;
    }

    if (1 < cCommand)
    {
	_PrintError(E_INVALIDARG, "multiple commands");
	Usage(TRUE);
    }
    if (cmdNONE == g_dwCommand)
    {
	g_dwCommand = cmdSUBMITREQUEST;
	cArgMax = 4;
    }
    if (NULL != pwszAttributes &&
	cmdSUBMITREQUEST != g_dwCommand &&
	cmdNEWREQUEST != g_dwCommand &&
	cmdQUALIFIEDREQUEST != g_dwCommand)
    {
	_PrintError(E_INVALIDARG, "unexpected -attrib arg");
	Usage(TRUE);
    }
    if (NULL != g_pwszCertCN &&
	cmdSIGNREQUEST != g_dwCommand &&
	cmdQUALIFIEDREQUEST != g_dwCommand &&
	cmdNEWREQUEST != g_dwCommand)
    {
	_PrintError(E_INVALIDARG, "unexpected -cert arg");
	Usage(TRUE);
    }

    if (1 + cArgMax < argc)
    {
	_PrintError(E_INVALIDARG, "Extra args");
	Usage(TRUE);
    }

    CSASSERT(ARRAYSIZE(rgpwszArg) >= cArgMax);
    ZeroMemory(rgpwszArg, sizeof(rgpwszArg));

    if (1 < argc)
    {
	rgpwszArg[0] = argv[1];
	if (2 < argc)
	{
	    rgpwszArg[1] = argv[2];
	    if (3 < argc)
	    {
		rgpwszArg[2] = argv[3];
		if (4 < argc)
		{
		    rgpwszArg[3] = argv[4];
		}
	    }
	}
    }

    // cmdSUBMITREQUEST:
    //	[RequestFile [CertFile [CertChainFile [FullResponseFile]]]]
    //
    // cmdRETRIEVEPENDING:
    //	[RequestId [CertFile [CertChainFile [FullResponseFile]]]]
    //
    // cmdNEWREQUEST
    //	[PolicyFile [RequestFileOut]]
    //
    // cmdACCEPTRESPONSE
    //	[CertFile | CertChainFile | FullResponseFile]
    //
    // cmdQUALIFIEDREQUEST (accept RequestFile and PolicyFile in either order)
    //	[RequestFile [PolicyFile [RequestFileOut [PKCS10FileOut]]]
    //
    // cmdSIGNREQUEST:
    //	[RequestFile [RequestFileOut]]
    //

    pwszfnIn = NULL;
    pwszfnOut = NULL;
    pwszfnPKCS10 = NULL;
    pwszfnCertChain = NULL;
    pwszfnFullResponse = NULL;
    pwszfnPolicy = NULL;

    pwszfnIn = rgpwszArg[0];
    idsFileFilter = IDS_REQUEST_FILE_FILTER;
    idsFileDefExt = IDS_REQUEST_FILE_DEFEXT;

    switch (g_dwCommand)
    {
	case cmdRETRIEVEPENDING:
	    idsFileFilter = 0;	// disable file open dialog
	    // FALLTHROUGH
	case cmdSUBMITREQUEST:
	    pwszfnOut = rgpwszArg[1];
	    pwszfnCertChain = rgpwszArg[2];
	    pwszfnFullResponse = rgpwszArg[3];
	    break;

	case cmdNEWREQUEST:
	    pwszfnIn = NULL;
	    pwszfnPolicy = rgpwszArg[0];
	    pwszfnOut = rgpwszArg[1];
	    CSASSERT(NULL == rgpwszArg[2]);
	    idsFileFilter = 0;	// disable file open dialog
	    break;

	case cmdACCEPTRESPONSE:
	    CSASSERT(NULL == rgpwszArg[1]);
	    idsFileFilter = IDS_RESPONSE_FILE_FILTER;
	    idsFileDefExt = IDS_RESPONSE_FILE_DEFEXT;
	    break;

	case cmdQUALIFIEDREQUEST:
	    pwszfnPolicy = rgpwszArg[1];
	    pwszfnOut = rgpwszArg[2];
	    pwszfnPKCS10 = rgpwszArg[3];
	    idsFileFilter = IDS_REQUEST_FILE_FILTER;
	    break;

	default:
	    CSASSERT(cmdSIGNREQUEST == g_dwCommand);
	    pwszfnOut = rgpwszArg[1];
	    CSASSERT(NULL == rgpwszArg[2]);
	    CSASSERT(NULL == rgpwszArg[3]);
	    break;
    }

    RequestId = 0;
    if (cmdRETRIEVEPENDING == g_dwCommand)
    {
	if (NULL == pwszfnIn)
	{
            WCHAR *pwszMsg = NULL;
            hr = myLoadRCString(
			    g_hInstance,
			    IDS_ERROR_NO_REQUESTID,
			    &pwszMsg);
            if (S_OK == hr)
            {
                CSASSERT(NULL != pwszMsg);
                wprintf(pwszMsg);
                wprintf(g_wszNewLine);
                LocalFree(pwszMsg);
            }
	    _PrintError(E_INVALIDARG, "missing RequestId");
	    Usage(TRUE);
	}
	hr = GetLong(pwszfnIn, &RequestId);
	if (S_OK != hr || 0 == RequestId)
	{
	    RequestId = 0;
	    pwszSerialNumber = pwszfnIn;
	}
	pwszfnIn = NULL;
    }
    else
    if (NULL != pwszfnIn && cmdQUALIFIEDREQUEST == g_dwCommand)
    {
	BYTE *pbReq;
	DWORD cbReq;
	LONG dwFlags;
	BOOL fSigned;

	// accept RequestFile and PolicyFile in either order:
	
	hr = CheckRequestType(
			pwszfnIn,
			&pbReq,
			&cbReq,
			&dwFlags,
			&fSigned,
			NULL,		// pfCA
			NULL);		// ppwszTemplateName
	if (S_OK != hr)
	{
	    WCHAR const *pwsz = pwszfnPolicy;

	    pwszfnPolicy = pwszfnIn;
	    pwszfnIn = pwsz;
	}
	else
	{
	    LocalFree(pbReq);
	}
    }
    if (NULL == pwszfnIn && 0 != idsFileFilter)
    {
	// Put up a file open dialog to get Response, Request or cert file

        hr = crGetOpenFileName(
			hWndOwner,
			IDS_REQUEST_OPEN_TITLE,
			idsFileFilter,
			idsFileDefExt,
			&pwszOFN);
	_JumpIfError(hr, error, "crGetOpenFileName");

	pwszfnIn = pwszOFN;
    }

    if (NULL != pwszfnIn)
    {
	if (!myDoesFileExist(pwszfnIn))
	{
	    SetErrorString(pwszfnIn);
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpErrorStr(hr, error, "myDoesFileExist", pwszfnIn);
	}
    }
    if (NULL != pwszfnOut)
    {
	hr = myIsDirWriteable(pwszfnOut, TRUE);
	if (S_OK != hr)
	{
	    SetErrorString(pwszfnOut);
	    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnOut);
	}
    }

    switch (g_dwCommand)
    {
	case cmdRETRIEVEPENDING:
	case cmdSUBMITREQUEST:
	    if (CV_OUT_BASE64REQUESTHEADER == g_dwOutFormat)
	    {
		g_dwOutFormat = CV_OUT_BASE64HEADER;
	    }
	    if (NULL != pwszfnCertChain)
	    {
		hr = myIsDirWriteable(pwszfnCertChain, TRUE);
		if (S_OK != hr)
		{
		    SetErrorString(pwszfnCertChain);
		    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnCertChain);
		}
	    }
	    if (NULL != pwszfnFullResponse)
	    {
		hr = myIsDirWriteable(pwszfnFullResponse, TRUE);
		if (S_OK != hr)
		{
		    SetErrorString(pwszfnFullResponse);
		    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnFullResponse);
		}
	    }
	    hr = SubmitRequest(
			    hWndOwner,
			    RequestId,
			    pwszSerialNumber,
			    pwszAttributes,
			    pwszfnIn,
			    pwszfnOut,
			    pwszfnCertChain,
			    pwszfnFullResponse);
	    _JumpIfError(hr, error, "SubmitRequest");

	    break;

	case cmdACCEPTRESPONSE:
	    hr = AcceptResponse(pwszfnIn);
	    _JumpIfError(hr, error, "AcceptResponse");

	    break;
	
	case cmdNEWREQUEST:
	case cmdQUALIFIEDREQUEST:
	    if (NULL != pwszfnPKCS10)
	    {
		hr = myIsDirWriteable(pwszfnPKCS10, TRUE);
		if (S_OK != hr)
		{
		    SetErrorString(pwszfnPKCS10);
		    _JumpErrorStr(hr, error, "IsDirWriteable", pwszfnPKCS10);
		}
	    }
	    if (NULL == pwszfnPolicy)
	    {
		// Put up a file dialog to prompt the user for Inf File

		hr = crGetOpenFileName(
				hWndOwner,
				IDS_INF_OPEN_TITLE,
				IDS_INF_FILE_FILTER,
				IDS_INF_FILE_DEFEXT,
				&pwszOFN2);
		_JumpIfError(hr, error, "crGetOpenFileName");

		pwszfnPolicy = pwszOFN2;
	    }
	    CSASSERT(NULL != pwszfnPolicy);
	    if (!myDoesFileExist(pwszfnPolicy))
	    {
		SetErrorString(pwszfnPolicy);
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpErrorStr(hr, error, "myDoesFileExist", pwszfnPolicy);
	    }
	    if (cmdNEWREQUEST == g_dwCommand)
	    {
		hr = CreateNewRequest(
				hWndOwner,
				pwszAttributes,
				pwszfnPolicy,
				pwszfnOut);
		_JumpIfError(hr, error, "CreateNewRequest");
	    }
	    else
	    {
		hr = CreateQualifiedRequest(
					hWndOwner,
					pwszAttributes,
					pwszfnIn,
					pwszfnPolicy,
					pwszfnOut,
					pwszfnPKCS10);
		_JumpIfError(hr, error, "CreateQualifiedRequest");
	    }
	    break;

	default:
	    CSASSERT(cmdSIGNREQUEST == g_dwCommand);
	    if (NULL != pwszfnFullResponse)
	    {
		Usage(TRUE);
	    }
	    hr = SignQualifiedRequest(hWndOwner, pwszfnIn, pwszfnOut);
	    _JumpIfError(hr, error, "SignQualifiedRequest");

	    break;
    }

error:
    if (NULL != pwszAttributes)
    {
        LocalFree(pwszAttributes);
    }
    if (NULL != pwszOFN)
    {
        LocalFree(pwszOFN);
    }
    if (NULL != pwszOFN2)
    {
        LocalFree(pwszOFN2);
    }
    return(hr);
}


//**************************************************************************
//  FUNCTION:	CertReqPreMain
//  NOTES:	Based on vich's MkRootMain function; takes an LPSTR command
//		line and chews it up into argc/argv form so that it can be
//		passed on to a traditional C style main.
//**************************************************************************

#define ISBLANK(wc)	(L' ' == (wc) || L'\t' == (wc))

HRESULT 
CertReqPreMain(
    LPTSTR pszCmdLine,
    HWND hWndOwner)
{
    WCHAR *pbuf;
    LPTSTR apszArg[20];
    int cArg = 0;
    LPTSTR p;
    WCHAR *pchQuote;
    HRESULT hr;

    pbuf = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pszCmdLine) + 1) * sizeof(WCHAR));
    if (NULL == pbuf)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    p = pbuf;

    apszArg[cArg++] = TEXT("CertReq");
    while (*pszCmdLine != TEXT('\0'))
    {
	while (ISBLANK(*pszCmdLine))
	{
	    pszCmdLine++;
	}
	if (*pszCmdLine != TEXT('\0'))
	{
	    apszArg[cArg++] = p;
	    if (sizeof(apszArg)/sizeof(apszArg[0]) <= cArg)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Too many args");
	    }

	    pchQuote = NULL;
	    while (*pszCmdLine != L'\0')
	    {
		if (NULL != pchQuote)
		{
		    if (*pszCmdLine == *pchQuote)
		    {
			pszCmdLine++;
			pchQuote = NULL;
			continue;
		    }
		}
		else
		{
		    if (ISBLANK(*pszCmdLine))
		    {
			break;
		    }
		    if (L'"' == *pszCmdLine)
		    {
			pchQuote = pszCmdLine++;
			continue;
		    }
		}
		*p++ = *pszCmdLine++;
	    }

	    *p++ = TEXT('\0');
	    if (*pszCmdLine != TEXT('\0'))
	    {
		pszCmdLine++;	// skip whitespace or quote character
	    }
	}
    }
    apszArg[cArg] = NULL;

    hr = ArgvMain(cArg, apszArg, hWndOwner);
    _JumpIfError(hr, error, "ArgvMain");

error:
    if (NULL != pbuf)
    {
    	LocalFree(pbuf);
    }
    return(hr);
}


VOID
CertReqErrorDisplay(
    IN HRESULT hr,
    IN HWND hWnd)
{
    WCHAR *pwszTitle = NULL;
    WCHAR *pwszMessage = NULL;
    WCHAR *pwszMessage2 = NULL;
    WCHAR const *pwszError = NULL;
    WCHAR *pwszCombinedError = NULL;
    WCHAR const *pwsz;

    myLoadRCString(g_hInstance, IDS_CERTREQ_TITLE, &pwszTitle);
    if (g_idError)
    {
	myLoadRCString(g_hInstance, g_idError, &pwszMessage);
    }
    pwszError = myGetErrorMessageText(hr, S_OK != hr);
    if (NULL != g_pwszUnreferencedSectionNames)
    {
	myLoadRCString(
		g_hInstance,
		IDS_UNREFERENCED_INF_SECTIONS,
		&pwszMessage2);
    }

    // Eliminate redundant error message text.  If the client and server
    // localized error message text differ, both will still be displayed.

    if (NULL != pwszError && NULL != g_pwszErrorString)
    {
	if (NULL != wcsstr(g_pwszErrorString, pwszError))
	{
	    LocalFree(const_cast<WCHAR *>(pwszError));
	    pwszError = NULL;
	}
    }

    pwsz = NULL;
    if (NULL != pwszMessage ||
	NULL != pwszError ||
	NULL != g_pwszErrorString ||
	NULL != g_pwszInfErrorString ||
	NULL != g_pwszUnreferencedSectionNames)
    {
	DWORD cwc = 1;

	if (NULL != pwszMessage)
	{
	    cwc += wcslen(pwszMessage) + 1;
	}
	if (NULL != pwszError)
	{
	    cwc += wcslen(pwszError) + 1;
	}
	if (NULL != g_pwszErrorString)
	{
	    cwc += wcslen(g_pwszErrorString) + 1;
	}
	if (S_OK != hr && NULL != g_pwszInfErrorString)
	{
	    cwc += wcslen(g_pwszInfErrorString) + 1;
	}
	if (NULL != pwszMessage2)
	{
	    cwc += wcslen(pwszMessage2) + 1;
	}
	if (NULL != g_pwszUnreferencedSectionNames)
	{
	    cwc += wcslen(g_pwszUnreferencedSectionNames) + 1;
	}

	pwszCombinedError = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				cwc * sizeof(WCHAR));
	if (NULL != pwszCombinedError)
	{
	    *pwszCombinedError = L'\0';
	    if (NULL != pwszMessage)
	    {
		wcscat(pwszCombinedError, pwszMessage);
	    }
	    if (NULL != pwszError)
	    {
		if (L'\0' != *pwszCombinedError)
		{
		    wcscat(pwszCombinedError, g_wszNewLine);
		}
		wcscat(pwszCombinedError, pwszError);
	    }
	    if (NULL != g_pwszErrorString)
	    {
		if (L'\0' != *pwszCombinedError)
		{
		    wcscat(pwszCombinedError, g_wszNewLine);
		}
		wcscat(pwszCombinedError, g_pwszErrorString);
	    }
	    if (S_OK != hr && NULL != g_pwszInfErrorString)
	    {
		if (L'\0' != *pwszCombinedError)
		{
		    wcscat(pwszCombinedError, g_wszNewLine);
		}
		wcscat(pwszCombinedError, g_pwszInfErrorString);
	    }
	    if (NULL != pwszMessage2)
	    {
		if (L'\0' != *pwszCombinedError)
		{
		    wcscat(pwszCombinedError, g_wszNewLine);
		}
		wcscat(pwszCombinedError, pwszMessage2);
	    }
	    if (NULL != g_pwszUnreferencedSectionNames)
	    {
		if (L'\0' != *pwszCombinedError)
		{
		    wcscat(pwszCombinedError, g_wszNewLine);
		}
		wcscat(pwszCombinedError, g_pwszUnreferencedSectionNames);
	    }
	    pwsz = pwszCombinedError;
	}
    }
    if (NULL == pwsz)
    {
	pwsz = pwszError;
	if (NULL == pwsz)
	{
	    pwsz = g_pwszErrorString;
	    if (NULL == pwsz)
	    {
		pwsz = L"";
	    }
	}
    }

    if (!g_fQuiet)
    {
	MessageBox(
		hWnd,
		pwsz,
		pwszTitle,
		MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
    }
    wprintf(L"%ws: %ws\n",
	NULL != pwszTitle? pwszTitle : L"",
	NULL != pwsz? pwsz : L"");

    if (NULL != pwszCombinedError)
    {
	LocalFree(pwszCombinedError);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    if (NULL != pwszMessage)
    {
	LocalFree(pwszMessage);
    }
    if (NULL != pwszMessage2)
    {
	LocalFree(pwszMessage2);
    }
    if (NULL != pwszTitle)
    {
	LocalFree(pwszTitle);
    }
}


//**************************************************************************
//  FUNCTION:	MainWndProc(...)
//  ARGUMENTS:
//**************************************************************************

LRESULT APIENTRY
MainWndProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    WCHAR *pwszCmdLine = NULL;
    HRESULT hr;
    LRESULT lr = 0;

    switch(msg)
    {
        case WM_CREATE:
        case WM_SIZE:
	    break;

        case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

        case WM_DOCERTREQDIALOGS:
	    pwszCmdLine = (WCHAR*)lParam;
	    hr = CertReqPreMain(pwszCmdLine, hWnd);
	    if ((S_OK != hr && HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) ||
		NULL != g_pwszUnreferencedSectionNames)
	    {
		CertReqErrorDisplay(hr, hWnd);
	    }
	    PostQuitMessage(hr);
	    break;
	    
	default:
	    lr = DefWindowProc(hWnd, msg, wParam, lParam);
	    break;
    }
    return(lr);
}


static BOOL s_fLogOpened = FALSE;

VOID
LogOpen(
    IN BOOL fForceOpen)
{
    BOOL fOpenLog;

    DbgPrintfInit("+");		// reinitialize debug print mask first
    fOpenLog = DbgIsSSActive(DBG_SS_OPENLOG);

    if (fOpenLog || fForceOpen)
    {
	if (!s_fLogOpened)
	{
	    DbgPrintfInit("+certreq.log");	// open the log file
	    s_fLogOpened = TRUE;
	    DbgLogFileVersion("certreq.exe", szCSVER_STR);
	}
    }
}


VOID
LogClose()
{
    if (s_fLogOpened)
    {
	DbgPrintfInit("-");			// close the log file
	s_fLogOpened = FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Function:	wWinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	--	Instance handle
//		[hPrevInstance] --	Obsolete
//		[pwszCmdLine]	--	App command line
//		[nCmdShow]	--	Starting show state
//
//  History:	12/07/96	JerryK	Added this Comment
//
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE, // hPrevInstance
    LPWSTR pwszCmdLine,
    int /* nCmdShow */ )
{
    HRESULT hr;
    MSG		msg;
    WNDCLASS	wcApp;
    HWND	hWndMain;

    WCHAR *pwszAppName = NULL;
    WCHAR *pwszWindowName = NULL;

    _setmode(_fileno(stdout), _O_TEXT);
    _wsetlocale(LC_ALL, L".OCP");
    mySetThreadUILanguage(0);

    LogOpen(FALSE);

    hr = myLoadRCString(hInstance, IDS_APP_NAME, &pwszAppName);
    _PrintIfError(hr, "myLoadRCString(IDS_APP_NAME)");

    hr = myLoadRCString(hInstance, IDS_WINDOW_NAME, &pwszWindowName);
    _PrintIfError(hr, "myLoadRCString(IDS_WINDOW_NAME)");

    // Save the current instance
    g_hInstance = hInstance;

    // Set up the application's window class
    wcApp.style 	= 0;
    wcApp.lpfnWndProc 	= MainWndProc;
    wcApp.cbClsExtra	= 0;
    wcApp.cbWndExtra	= 0;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL,IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL,IDC_ARROW);
    wcApp.hbrBackground	= (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcApp.lpszMenuName	= NULL;
    wcApp.lpszClassName	= pwszAppName;

    if (!RegisterClass(&wcApp))
    {
	return(FALSE);
    }

    // Create Main Window
    hWndMain = CreateWindow(
			pwszAppName,
			pwszWindowName,
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			NULL,
			NULL,
			hInstance,
			NULL);
    if (NULL == hWndMain)
    {
	return(FALSE);
    }

    // Make window visible
    // ShowWindow(hWndMain,nCmdShow);

    // Update window client area
    UpdateWindow(hWndMain);

    // Send off the message to get things started
    PostMessage(hWndMain,WM_DOCERTREQDIALOGS,0,(LPARAM)pwszCmdLine);

    // Message Loop
    while (GetMessage(&msg,NULL,0,0))
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }
    if (NULL != g_pwszErrorString)
    {
        LocalFree(g_pwszErrorString);
    }
    if (NULL != g_pwszInfErrorString)
    {
	LocalFree(g_pwszInfErrorString);
    }
    if (NULL != g_pwszUnreferencedSectionNames)
    {
	LocalFree(g_pwszUnreferencedSectionNames);
    }
    if (NULL != pwszAppName)
    {
        LocalFree(pwszAppName);
    }
    if (NULL != pwszWindowName)
    {
        LocalFree(pwszWindowName);
    }
    myInfClearError();
    myFreeResourceStrings("certreq.exe");
    myFreeColumnDisplayNames();
    myRegisterMemDump();
    LogClose();
    return((int)msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certreq\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define IDD_ENCODING				101

#define IDI_APP					201

#define IDC_DECODERADIO				303
#define IDC_ENCODERADIO				304
#define IDC_NOBASE64RADIO			305

#define IDS_USAGE_DESCRIPTION			500
#define IDS_CERT_FILE_FILTER			501
#define IDS_FORMATSTR_CERTRETRIEVED		502
#define IDS_REQUEST_OUTFILE_TITLE		503
#define IDS_REQUEST_CERT_ERROR			504
#define IDS_APP_NAME				505
#define IDS_WINDOW_NAME				506
#define IDS_ERROR_NO_REQUESTID			507
#define IDS_USAGE_GENERAL			508
#define IDS_ERROR_STRCONVERSION			509
                                        
#define IDS_DISPOSITION_INCOMPLETE		520
#define IDS_DISPOSITION_ERROR			521
#define IDS_DISPOSITION_DENIED			522
#define IDS_DISPOSITION_ISSUED			523
#define IDS_DISPOSITION_ISSUED_OOB		524
#define IDS_DISPOSITION_UNDER_SUBMISSION	525
#define IDS_DISPOSITION_REVOKED			526
#define IDS_DISPOSITION_UNKNOWN			527
                                        
#define IDS_FORMATSTR_CERTNOTISSUED		540
#define IDS_FORMATSTR_CERTPENDING		541
#define IDS_CERTREQ_TITLE			542
#define IDS_FORMATSTR_DECODE_ERR		543
#define IDS_FORMATSTR_ERRCONFIG			544
#define IDS_USAGE_OPTIONS_DESCRIPTION		545
#define IDS_ERROR_NO_FILENAME			546
//#define IDS_UNUSED				547
#define IDS_NOMORE_CAS				548
#define IDS_GETERACERT_TITLE			549
#define IDS_GETERACERT_SUBTITLE			550

#define IDS_INF_OPEN_TITLE			551
#define IDS_INF_FILE_FILTER			552
#define IDS_INF_FILE_DEFEXT			553
#define IDS_OVERWRITE_FILE			554
#define IDS_RESPONSE_FILE_FILTER		555
#define IDS_RESPONSE_FILE_DEFEXT		556
#define IDS_CERT_OUTFILE_TITLE			557
#define IDS_FORMATSTR_REQUESTID			558
#define IDS_GETRENEWALCERT_TITLE		559
#define IDS_GETRENEWALCERT_SUBTITLE		560
#define IDS_GETSIGNINGCERT_TITLE		561
#define IDS_GETSIGNINGCERT_SUBTITLE		562

#define IDS_USAGE_VERB_DEFAULT			563
#define IDS_USAGE_OPTIONS_DEFAULT		564
#define IDS_USAGE_VERB_RETRIEVE			565
#define IDS_USAGE_OPTIONS_RETRIEVE		566
#define IDS_USAGE_VERB_POLICY			567
#define IDS_USAGE_OPTIONS_POLICY		568
#define IDS_USAGE_VERB_SIGN			569
#define IDS_USAGE_OPTIONS_SIGN			570
#define IDS_USAGE_VERB_NEW			571
#define IDS_USAGE_OPTIONS_NEW			572
#define IDS_USAGE_VERB_ACCEPT			573
#define IDS_USAGE_OPTIONS_ACCEPT		574

#define IDS_USAGE_OPTION_ANY			575
#define IDS_USAGE_OPTION_ATTRIB			576
#define IDS_USAGE_OPTION_BINARY			577
#define IDS_USAGE_OPTION_CERT			578
#define IDS_USAGE_OPTION_CONFIG			579
#define IDS_USAGE_OPTION_CRL			580
#define IDS_USAGE_OPTION_F			581
#define IDS_USAGE_OPTION_Q			582
#define IDS_USAGE_OPTION_RPC			583
#define IDS_USAGE_OPTION_VERBOSE		584
#define IDS_USAGE_OPTION_QUESTION		585

#define IDS_USAGE_OPTION_V1			586
#define IDS_USAGE_OPTION_IDISPATCH		587
#define IDS_CRITICAL				588
#define IDS_NON_CRITICAL			589
#define IDS_RESPONSE_OUTFILE_TITLE		590
#define IDS_CERT_FILE_DEFEXT			591
#define IDS_UNREFERENCED_INF_SECTIONS		592
                                        
#define IDC_STATIC				-1
                                        
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE		547
#define _APS_NEXT_COMMAND_VALUE			40001
#define _APS_NEXT_CONTROL_VALUE			1006
#define _APS_NEXT_SYMED_VALUE			101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\admin.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        admin.cpp
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <accctrl.h>

#include "csdisp.h"
#include "csprop.h"
#include "cscom.h"
#include "certlog.h"
#include "certsrvd.h"
#include "admin.h"
#include "resource.h"
#include "dbtable.h"
#include "elog.h"

#define __dwFILE__	__dwFILE_CERTSRV_ADMIN_CPP__

// Global variables
long g_cAdminComponents = 0;     // Count of active components
long g_cAdminServerLocks = 0;    // Count of locks
DWORD g_dwAdminRegister = 0;
IClassFactory* g_pIAdminFactory = NULL;

extern HWND g_hwndMain;

#ifdef DBG_CERTSRV_DEBUG_PRINT
DWORD s_ssAdmin = DBG_SS_CERTSRVI;
#endif

using namespace CertSrv;

// Admin component
// begin implementing cert admin services

#pragma warning(push)
#pragma warning(disable: 4509) // nonstandard extension used: uses SEH and has destructor

HRESULT
AdminGetIndexedCRL(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD CertIndex,		// -1: current CA cert
    /* [in] */ DWORD Flags,		// CA_CRL_*
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbCRL)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRL = NULL;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD State = 0;

    pctbCRL->pb = NULL;
    pctbCRL->cb = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	switch (Flags)
	{
	    case CA_CRL_BASE:
	    case CA_CRL_DELTA:
		break;

	    default:
		hr = E_INVALIDARG;
		_LeaveError(hr, "Flags");
	}

	// get the requested CRL:

	hr = CRLGetCRL(CertIndex, CA_CRL_DELTA == Flags, &pCRL, NULL);
	_LeaveIfError(hr, "CRLGetCRL");

	pctbCRL->cb = pCRL->cbCrlEncoded;
	pctbCRL->pb = (BYTE *) CoTaskMemAlloc(pCRL->cbCrlEncoded);
	if (NULL == pctbCRL->pb)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CoTaskMemAlloc");
	}
	CopyMemory(pctbCRL->pb, pCRL->pbCrlEncoded, pCRL->cbCrlEncoded);

	myRegisterMemFree(pctbCRL->pb, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pCRL)
    {
        CertFreeCRLContext(pCRL);
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetCRL(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbCRL)
{
    HRESULT hr;

    // Just get current base CRL:

    hr = AdminGetIndexedCRL(pwszAuthority, MAXDWORD, CA_CRL_BASE, pctbCRL);
    _JumpIfError(hr, error, "AdminGetIndexedCRL");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetArchivedKey(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbArchivedKey)
{
    HRESULT hr;
    CAuditEvent audit(SE_AUDITID_CERTSRV_GETARCHIVEDKEY, g_dwAuditFilter);
    DWORD State = 0;

    pctbArchivedKey->pb = NULL;
    pctbArchivedKey->cb = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 request ID
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = PKCSGetArchivedKey(
			    dwRequestId,
			    &pctbArchivedKey->pb,
			    &pctbArchivedKey->cb);
	_LeaveIfError(hr, "PKCSGetArchivedKey");

	myRegisterMemFree(pctbArchivedKey->pb, CSM_COTASKALLOC);

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetCAProperty(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        CAuditEvent audit(0, g_dwAuditFilter);

	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess |
			    audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

        hr = RequestGetCAProperty(
			    PropId,
			    PropIndex,
			    PropType,
			    pctbPropertyValue);
        _LeaveIfError(hr, "RequestGetCAProperty");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::SetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue)
{
    HRESULT hr;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetCAProperty(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = RequestSetCAProperty(
			pwszAuthority,
			PropId,
			PropIndex,
			PropType,
			pctbPropertyValue);
    _JumpIfError(hr, error, "RequestSetCAProperty");

error:
    return(hr);
}

STDMETHODIMP
CCertAdminD::GetCAPropertyInfo(
    IN  wchar_t const *pwszAuthority,
    OUT LONG          *pcProperty,
    OUT CERTTRANSBLOB *pctbPropInfo)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetCAPropertyInfo(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        CAuditEvent audit(0, g_dwAuditFilter);

	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

        hr = RequestGetCAPropertyInfo(
			        pcProperty,
			        pctbPropInfo);
        _LeaveIfError(hr, "RequestGetCAPropertyInfo");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::PublishCRL(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ FILETIME NextUpdate)
{
    HRESULT hr;

    // CA_CRL_BASE implies CA_CRL_DELTA when delta CRLs are enabled.

    hr = PublishCRLs(pwszAuthority, NextUpdate, CA_CRL_BASE);
    _JumpError(hr, error, "PublishCRLs");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::PublishCRLs(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ FILETIME NextUpdate,
    /* [in] */ DWORD Flags)		// CA_CRL_*
{
    HRESULT hr;
    BOOL fRetry = FALSE;
    BOOL fForceRepublishCRL;
    BOOL fShadowDelta = FALSE;
    WCHAR *pwszUserName = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_PUBLISHCRL, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::PublishCRL(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	HRESULT hrPublish;

        hr = audit.AddData(NextUpdate); // %1 next update
        _LeaveIfError(hr, "AddData");

        hr = audit.AddData(
		    (CA_CRL_BASE & Flags)? true : false); // %2 publish base
        _LeaveIfError(hr, "AddData");

        hr = audit.AddData(
		    (CA_CRL_DELTA & Flags)? true : false); // %3 publish delta
        _LeaveIfError(hr, "AddData");

        hr = audit.AccessCheck(
			CA_ACCESS_ADMIN,
			audit.m_gcAuditSuccessOrFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

	switch (~CA_CRL_REPUBLISH & Flags)
	{
	    case CA_CRL_BASE:
		break;

	    case CA_CRL_DELTA:
		if (g_fDeltaCRLPublishDisabled)
		{
		    fShadowDelta = TRUE;
		}
		break;

	    case CA_CRL_BASE | CA_CRL_DELTA:
		if (g_fDeltaCRLPublishDisabled)
		{
		    hr = E_INVALIDARG;
		    _LeaveError(hr, "Delta CRLs disabled");
		}
		break;

	    default:
		hr = E_INVALIDARG;
		_LeaveError(hr, "Flags");
	}

	fForceRepublishCRL = (CA_CRL_REPUBLISH & Flags)? TRUE : FALSE;

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	hr = CRLPublishCRLs(
		!fForceRepublishCRL,	// fRebuildCRL
		fForceRepublishCRL,	// fForceRepublish
		pwszUserName,
		CA_CRL_DELTA == (~CA_CRL_REPUBLISH & Flags),	// fDeltaOnly
		fShadowDelta,
		NextUpdate,
		&fRetry,
		&hrPublish);
	_LeaveIfError(hr, "CRLPublishCRLs");

	hr = hrPublish;
	_LeaveIfError(hr, "CRLPublishCRLs(hrPublish)");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::SetExtension(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszExtensionName,
    /* [in] */ DWORD dwType,
    /* [in] */ DWORD dwFlags,
    /* [ref][in] */ CERTTRANSBLOB __RPC_FAR *pctbValue)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETEXTENSION, g_dwAuditFilter);
    DWORD State = 0;
    BOOL fCommitted = FALSE;
    BYTE *pbOld = NULL;
    DWORD cbOld;
    static WCHAR const s_wszzPendingExtensionList[] =
	TEXT(szOID_ENROLL_CERTTYPE_EXTENSION)
	L"\0"
	TEXT(szOID_CERTIFICATE_TEMPLATE)
	L"\0";

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetExtension(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 Request ID
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(pwszExtensionName); // %2 name
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(dwType); // %3 type
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(dwFlags); // %4 flags
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(pctbValue->pb, pctbValue->cb); // %5 data
	_LeaveIfError(hr, "AddData");

	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, dwRequestId, NULL, &prow);
	_LeaveIfError(hr, "OpenRow");

	hr = CoreValidateRequestId(prow, DB_DISP_PENDING);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "CoreValidateRequestId");
	}

	// Prevent modifying certain extension values for pending requests.
	// Flags can still be changed: critical, disable, etc.

	if (MAXDWORD != CRLIsStringInList(
			    pwszExtensionName,
			    s_wszzPendingExtensionList))
	{
	    DWORD ExtFlags;
	    
	    hr = PropGetExtension(
			prow,
			PROPCALLER_ADMIN | (PROPTYPE_MASK & dwType),
			pwszExtensionName,
			&ExtFlags,		// throw away the flags
			&cbOld,
			&pbOld);
	    _PrintIfError(hr, "PropGetExtension");
	    if (CERTSRV_E_PROPERTY_EMPTY == hr ||
		(S_OK == hr &&
		 (pctbValue->cb != cbOld ||
		    0 != memcmp(pctbValue->pb, pbOld, pctbValue->cb))))
	    {
		hr = E_ACCESSDENIED;
	    }
	    _JumpIfError(hr, error, "restricted extension");
	}

	hr = PropSetExtension(
			    prow,
			    PROPCALLER_ADMIN | (PROPTYPE_MASK & dwType),
			    pwszExtensionName,
			    EXTENSION_ORIGIN_ADMIN |
				(EXTENSION_POLICY_MASK & dwFlags),
			    pctbValue->cb,
			    pctbValue->pb);
	_LeaveIfError(hr, "PropSetExtension");

	hr = prow->CommitTransaction(TRUE);
	_LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pbOld)
    {
	LocalFree(pbOld);
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::SetAttributes(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAttributes)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETATTRIBUTES, g_dwAuditFilter);
    DWORD State = 0;
    BOOL fCommitted = FALSE;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetAttributes(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 request ID
	_LeaveIfError(hr, "AddData");

	hr = audit.AddData(pwszAttributes); // %2 attributes
	_LeaveIfError(hr, "AddData");
	
	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, dwRequestId, NULL, &prow);
	_LeaveIfError(hr, "OpenRow");

	hr = CoreValidateRequestId(prow, DB_DISP_PENDING);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "CoreValidateRequestId");
	}

	if (NULL == pwszAttributes)
	{
	    hr = E_INVALIDARG;
	    _LeaveError(hr, "pwszAttributes NULL");
	}
	hr = PKCSParseAttributes(
			    prow,
			    pwszAttributes,
			    FALSE,
			    TRUE,
			    PROPTABLE_CERTIFICATE,
			    NULL);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "PKCSParseAttributes");
	}
	hr = prow->CommitTransaction(TRUE);
	_LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::DenyRequest(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId)
{
    HRESULT hr;
    DWORD Disposition;
    WCHAR *pwszUserName = NULL;
    CERTSRV_COM_CONTEXT ComContext;
    DWORD dwComContextIndex = MAXDWORD;
    CERTSRV_RESULT_CONTEXT Result;
    CAuditEvent audit(SE_AUDITID_CERTSRV_DENYREQUEST, g_dwAuditFilter);
    DWORD State = 0;

    ZeroMemory(&ComContext, sizeof(ComContext));
    ZeroMemory(&Result, sizeof(Result));

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::DenyRequest(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No Authority Name");

    hr = RegisterComContext(&ComContext, &dwComContextIndex);
    _JumpIfError(hr, error, "RegisterComContext");

    Result.pdwRequestId = &dwRequestId;
    Result.pdwDisposition = &Disposition;

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 request ID
	_LeaveIfError(hr, "AddData");
	
	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	hr = CoreProcessRequest(
			    CR_IN_DENY,		// dwFlags
			    pwszUserName,
			    0,			// cbRequest
			    NULL,		// pbRequest
			    NULL,		// pwszAttributes
			    NULL,		// pwszSerialNumber
			    dwComContextIndex,
			    dwRequestId,
			    &Result);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "CoreProcessRequest");
	}
	if (FAILED(Disposition))
	{
	    hr = (HRESULT) Disposition;
	    _LeaveError(hr, "CoreProcessRequest(Disposition)");
	}
	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    ReleaseResult(&Result);
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (MAXDWORD != dwComContextIndex)
    {
        UnregisterComContext(&ComContext, dwComContextIndex);
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::ResubmitRequest(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [in] */ DWORD dwRequestId,
    /* [out] */ DWORD __RPC_FAR *pdwDisposition)
{
    HRESULT hr;
    WCHAR *pwszUserName = NULL;
    CERTSRV_COM_CONTEXT ComContext;
    DWORD dwComContextIndex = MAXDWORD;
    CERTSRV_RESULT_CONTEXT Result;
    CAuditEvent audit(SE_AUDITID_CERTSRV_RESUBMITREQUEST, g_dwAuditFilter);
    DWORD State = 0;

    ZeroMemory(&ComContext, sizeof(ComContext));
    ZeroMemory(&Result, sizeof(Result));

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::ResubmitRequest(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    hr = RegisterComContext(&ComContext, &dwComContextIndex);
    _JumpIfError(hr, error, "RegisterComContext");

    __try
    {
	hr = audit.AddData(dwRequestId); // %1 request ID
	_LeaveIfError(hr, "AddData");
	
	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = CheckOfficerRights(dwRequestId, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	Result.dwResultFlags |= CRCF_FAILDENIEDREQUEST;

	Result.pdwRequestId = &dwRequestId;
	Result.pdwDisposition = pdwDisposition;
	hr = CoreProcessRequest(
			    CR_IN_RESUBMIT,	// dwFlags
			    pwszUserName,	// pwszUserName
			    0,			// cbRequest
			    NULL,		// pbRequest
			    NULL,		// pwszAttributes
			    NULL,		// pwszSerialNumber
			    dwComContextIndex,
			    dwRequestId,
			    &Result);

	if (S_OK == hr &&
	    FAILED(*Result.pdwDisposition) && 
	    (CRCF_PREVIOUSLYDENIED & Result.dwResultFlags))
	{
	    hr = audit.AccessCheck(
			    CA_ACCESS_ADMIN,
			    audit.m_gcNoAuditSuccess);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");

	    ReleaseResult(&Result);
	    ZeroMemory(&Result, sizeof(Result));
	    Result.pdwRequestId = &dwRequestId;
	    Result.pdwDisposition = pdwDisposition;

	    hr = CoreProcessRequest(
			        CR_IN_RESUBMIT,	// dwFlags
			        pwszUserName,	// pwszUserName
			        0,			// cbRequest
			        NULL,		// pbRequest
			        NULL,		// pwszAttributes
			        NULL,		// pwszSerialNumber
			        dwComContextIndex,
			        dwRequestId,
			        &Result);

	}
	hr = myHError(hr);
	_LeaveIfError(hr, "CoreProcessRequest");

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    ReleaseResult(&Result);
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != ComContext.hAccessToken)
    {
        __try
        {
            CloseHandle(ComContext.hAccessToken);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
            _PrintError(hr, "Exception");
        }
    }
    ReleaseComContext(&ComContext);
    if (MAXDWORD != dwComContextIndex)
    {
	UnregisterComContext(&ComContext, dwComContextIndex);
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::EnumViewColumn(
    /* [ref][in] */ wchar_t const *pwszAuthority,
    /* [in] */  DWORD  iColumn,
    /* [in] */  DWORD  cColumn,
    /* [out] */ DWORD *pcColumn,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbColumnInfo)   // CoTaskMem*
{
    HRESULT hr;

    hr = EnumViewColumnTable(
		    pwszAuthority,
		    CVRC_TABLE_REQCERT,
		    iColumn,
		    cColumn,
		    pcColumn,
		    pctbColumnInfo);   // CoTaskMem*
    _JumpIfError(hr, error, "EnumViewColumnTable");

error:
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::EnumViewColumnTable(
    /* [ref][in] */ wchar_t const *pwszAuthority,
    /* [in] */  DWORD  iTable,
    /* [in] */  DWORD  iColumn,
    /* [in] */  DWORD  cColumn,
    /* [out] */ DWORD *pcColumn,
    /* [ref][out] */ CERTTRANSBLOB __RPC_FAR *pctbColumnInfo)   // CoTaskMem*
{
    HRESULT hr;
    LONG iColumnCurrent;
    CERTDBCOLUMN *rgColumn = NULL;
    CERTDBCOLUMN *pColumn;
    CERTDBCOLUMN *pColumnEnd;
    CERTTRANSDBCOLUMN *rgtColumnOut = NULL;
    CERTTRANSDBCOLUMN *ptColumn;
    DWORD cColumnFetched;
    DWORD cb;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::EnumViewColumnTable(tid=%d, this=%x, icol=%d, ccol=%d)\n",
	GetCurrentThreadId(),
	this,
	iColumn,
	cColumn));

    pctbColumnInfo->cb = 0;
    pctbColumnInfo->pb = NULL;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	if (NULL == m_pEnumCol || iTable != m_iTableEnum)
	{
	    if (NULL != m_pEnumCol)
	    {
		m_pEnumCol->Release();
		m_pEnumCol = NULL;
	    }
	    hr = g_pCertDB->EnumCertDBColumn(iTable, &m_pEnumCol);
	    _LeaveIfError(hr, "EnumCertDBColumn");

	    m_iTableEnum = iTable;
	}

	rgColumn = (CERTDBCOLUMN *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    cColumn * sizeof(rgColumn[0]));
	if (NULL == rgColumn)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "Alloc rgColumn");
	}

	hr = m_pEnumCol->Skip(0, &iColumnCurrent);
	_LeaveIfError(hr, "Skip");


	if (iColumnCurrent != (LONG) iColumn)
	{
	    hr = m_pEnumCol->Skip(
			    (LONG) iColumn - iColumnCurrent,
			    &iColumnCurrent);
	    _LeaveIfError(hr, "Skip");

	    CSASSERT((LONG) iColumn == iColumnCurrent);
	}

	hr = m_pEnumCol->Next(cColumn, rgColumn, &cColumnFetched);
	if (S_FALSE != hr)
	{
	    _LeaveIfError(hr, "Next");
	}

	DBGPRINT((
		s_ssAdmin,
		"EnumViewColumnTable: cColumnFetched=%d\n",
		cColumnFetched));

	cb = cColumnFetched * sizeof(rgtColumnOut[0]);
	pColumnEnd = &rgColumn[cColumnFetched];
	for (pColumn = rgColumn; pColumn < pColumnEnd; pColumn++)
	{
	    cb += DWORDROUND((wcslen(pColumn->pwszName) + 1) * sizeof(WCHAR));
	    cb += DWORDROUND((wcslen(pColumn->pwszDisplayName) + 1) * sizeof(WCHAR));
	}

	rgtColumnOut = (CERTTRANSDBCOLUMN *) CoTaskMemAlloc(cb);
	if (NULL == rgtColumnOut)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CoTaskMemAlloc rgtColumnOut");
	}
	ZeroMemory(rgtColumnOut, cb);
	pctbColumnInfo->cb = cb;

	cb = cColumnFetched * sizeof(rgtColumnOut[0]);
	pColumnEnd = &rgColumn[cColumnFetched];
	ptColumn = rgtColumnOut;
	for (pColumn = rgColumn; pColumn < pColumnEnd; ptColumn++, pColumn++)
	{
	    DWORD cbT;

	    ptColumn->Type = pColumn->Type;
	    ptColumn->Index = pColumn->Index;
	    ptColumn->cbMax = pColumn->cbMax;
	
	    DBGPRINT((
		    s_ssAdmin,
		    "EnumViewColumnTable: ielt=%d idx=%x \"%ws\"\n",
		    iColumn + (ptColumn - rgtColumnOut),
		    ptColumn->Index,
		    pColumn->pwszName));

	    cbT = (wcslen(pColumn->pwszName) + 1) * sizeof(WCHAR);
	    CopyMemory(Add2Ptr(rgtColumnOut, cb), pColumn->pwszName, cbT);
	    ptColumn->obwszName = cb;
	    cb += DWORDROUND(cbT);

	    cbT = (wcslen(pColumn->pwszDisplayName) + 1) * sizeof(WCHAR);
	    CopyMemory(Add2Ptr(rgtColumnOut, cb), pColumn->pwszDisplayName, cbT);
	    ptColumn->obwszDisplayName = cb;
	    cb += DWORDROUND(cbT);
	}
	CSASSERT(cb == pctbColumnInfo->cb);

	pctbColumnInfo->pb = (BYTE *) rgtColumnOut;
	rgtColumnOut = NULL;
	*pcColumn = cColumnFetched;

	myRegisterMemFree(pctbColumnInfo->pb, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != rgColumn)
    {
	pColumnEnd = &rgColumn[cColumn];
	for (pColumn = rgColumn; pColumn < pColumnEnd; pColumn++)
	{
	    if (NULL != pColumn->pwszName)
	    {
		CoTaskMemFree(pColumn->pwszName);
	    }
	    if (NULL != pColumn->pwszDisplayName)
	    {
		CoTaskMemFree(pColumn->pwszDisplayName);
	    }
	}
	LocalFree(rgColumn);
    }
    if (NULL != rgtColumnOut)
    {
	CoTaskMemFree(rgtColumnOut);
    }
    DBGPRINT((
	    s_ssAdmin,
	    "EnumViewColumnTable: icol=%d, ccol=%d, ccolout=%d, hr=%x\n",
	    iColumn,
	    cColumn,
	    *pcColumn,
	    hr));

    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::GetViewDefaultColumnSet(
    IN  wchar_t const *pwszAuthority,
    IN  DWORD          iColumnSetDefault,
    OUT DWORD         *pcColumn,
    OUT CERTTRANSBLOB *ptbColumnInfo)   // CoTaskMem*
{
    HRESULT hr;
    DWORD ccol;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetViewDefaultColumnSet(tid=%d, this=%x, icolset=%d)\n",
	GetCurrentThreadId(),
	this,
	iColumnSetDefault));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	{
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

	hr = g_pCertDB->GetDefaultColumnSet(iColumnSetDefault, 0, &ccol, NULL);
	_LeaveIfError(hr, "GetDefaultColumnSet");

	ptbColumnInfo->cb = ccol * sizeof(DWORD);
	ptbColumnInfo->pb = (BYTE *) CoTaskMemAlloc(ptbColumnInfo->cb);
	if (NULL == ptbColumnInfo->pb)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CoTaskMemAlloc");
	}
	myRegisterMemFree(ptbColumnInfo->pb, CSM_MIDLUSERALLOC);

	hr = g_pCertDB->GetDefaultColumnSet(
					iColumnSetDefault,
					ccol,
					pcColumn,
					(DWORD *) ptbColumnInfo->pb);
	_LeaveIfError(hr, "GetDefaultColumnSet");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    DBGPRINT((
	    S_OK == hr? s_ssAdmin : DBG_SS_CERTSRV,
	    "GetViewDefaultColumnSet: icolset=%d, ccolout=%d, hr=%x\n",
	    iColumnSetDefault,
	    *pcColumn,
	    hr));
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::_EnumAttributes(
    IN ICertDBRow     *prow,
    IN CERTDBNAME     *adbn,
    IN DWORD           celt,
    OUT CERTTRANSBLOB *pctbOut) // CoTaskMem*
{
    HRESULT hr;
    DWORD i;
    DWORD cb;
    DWORD cbT;
    CERTTRANSDBATTRIBUTE *pteltOut;
    BYTE *pbOut;
    BYTE *pbOutEnd;
    DWORD State = 0;

    CSASSERT(NULL == pctbOut->pb);

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    cb = sizeof(*pteltOut) * celt;
    for (i = 0; i < celt; i++)
    {
	cb += (wcslen(adbn[i].pwszName) + 1) * sizeof(WCHAR);
	cb = DWORDROUND(cb);

	cbT = 0;
	hr = prow->GetProperty(
			    adbn[i].pwszName,
			    PROPTYPE_STRING |
				PROPCALLER_ADMIN |
				PROPTABLE_ATTRIBUTE,
			    NULL,
			    &cbT,
			    NULL);
	_JumpIfError(hr, error, "GetProperty(NULL)");

	cb += DWORDROUND(cbT);
    }

    pctbOut->pb = (BYTE *) CoTaskMemAlloc(cb);
    if (NULL == pctbOut->pb)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CoTaskMemAlloc out data");
    }
    pctbOut->cb = cb;

    pteltOut = (CERTTRANSDBATTRIBUTE *) pctbOut->pb;
    pbOut = (BYTE *) &pteltOut[celt];
    pbOutEnd = &pctbOut->pb[pctbOut->cb];

    for (i = 0; i < celt; i++)
    {
	cbT = (wcslen(adbn[i].pwszName) + 1) * sizeof(WCHAR);
	CopyMemory(pbOut, adbn[i].pwszName, cbT);
	pteltOut->obwszName = SAFE_SUBTRACT_POINTERS(pbOut, pctbOut->pb);
	pbOut += DWORDROUND(cbT);

	cbT = SAFE_SUBTRACT_POINTERS(pbOutEnd, pbOut);
	hr = prow->GetProperty(
			    adbn[i].pwszName,
			    PROPTYPE_STRING |
				PROPCALLER_ADMIN |
				PROPTABLE_ATTRIBUTE,
			    NULL,
			    &cbT,
			    pbOut);
	_JumpIfError(hr, error, "GetProperty(pbOut)");

	CSASSERT(wcslen((WCHAR const *) pbOut) * sizeof(WCHAR) == cbT);
	pteltOut->obwszValue = SAFE_SUBTRACT_POINTERS(pbOut, pctbOut->pb);
	pbOut += DWORDROUND(cbT + sizeof(WCHAR));
	pteltOut++;
    }
    CSASSERT(pbOut == pbOutEnd);
    hr = S_OK;

error:
    if (S_OK != hr && NULL != pctbOut->pb)
    {
	CoTaskMemFree(pctbOut->pb);
	pctbOut->pb = NULL;
    }
    CertSrvExitServer(State, hr);
    return(hr);
}


HRESULT
CCertAdminD::_EnumExtensions(
    IN ICertDBRow     *prow,
    IN CERTDBNAME     *adbn,
    IN DWORD           celt,
    OUT CERTTRANSBLOB *pctbOut) // CoTaskMem*
{
    HRESULT hr;
    DWORD i;
    DWORD cb;
    DWORD cbT;
    DWORD ExtFlags;
    CERTTRANSDBEXTENSION *pteltOut;
    BYTE *pbOut;
    BYTE *pbOutEnd;
    DWORD State = 0;

    CSASSERT(NULL == pctbOut->pb);

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    cb = sizeof(*pteltOut) * celt;
    for (i = 0; i < celt; i++)
    {
	cb += (wcslen(adbn[i].pwszName) + 1) * sizeof(WCHAR);
	cb = DWORDROUND(cb);

	cbT = 0;
	hr = prow->GetExtension(
			    adbn[i].pwszName,
			    &ExtFlags,
			    &cbT,
			    NULL);
	_JumpIfError(hr, error, "GetExtension(NULL)");

	cb += DWORDROUND(cbT);
    }

    pctbOut->pb = (BYTE *) CoTaskMemAlloc(cb);
    if (NULL == pctbOut->pb)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CoTaskMemAlloc out data");
    }
    pctbOut->cb = cb;

    pteltOut = (CERTTRANSDBEXTENSION *) pctbOut->pb;
    pbOut = (BYTE *) &pteltOut[celt];
    pbOutEnd = &pctbOut->pb[pctbOut->cb];

    for (i = 0; i < celt; i++)
    {
	cbT = (wcslen(adbn[i].pwszName) + 1) * sizeof(WCHAR);
	CopyMemory(pbOut, adbn[i].pwszName, cbT);
	pteltOut->obwszName = SAFE_SUBTRACT_POINTERS(pbOut, pctbOut->pb);
	pbOut += DWORDROUND(cbT);

	cbT = SAFE_SUBTRACT_POINTERS(pbOutEnd, pbOut);
	hr = prow->GetExtension(
			    adbn[i].pwszName,
			    (DWORD *) &pteltOut->ExtFlags,
			    &cbT,
			    pbOut);
	_JumpIfError(hr, error, "GetExtension(pbOut)");

	pteltOut->cbValue = cbT;
	pteltOut->obValue = SAFE_SUBTRACT_POINTERS(pbOut, pctbOut->pb);
	pbOut += DWORDROUND(cbT);
	pteltOut++;
    }
    CSASSERT(pbOut == pbOutEnd);
    hr = S_OK;

error:
    if (S_OK != hr && NULL != pctbOut->pb)
    {
	CoTaskMemFree(pctbOut->pb);
	pctbOut->pb = NULL;
    }
    CertSrvExitServer(State, hr);
    return(hr);
}


STDMETHODIMP
CCertAdminD::EnumAttributesOrExtensions(
    IN          wchar_t const *pwszAuthority,
    IN          DWORD          RowId,
    IN          DWORD          Flags,
    OPTIONAL IN wchar_t const *pwszLast,
    IN          DWORD          celt,
    OUT         DWORD         *pceltFetched,
    OUT         CERTTRANSBLOB *pctbOut) // CoTaskMem*
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    IEnumCERTDBNAME *penum = NULL;
    DWORD EnumFlags;
    CERTDBNAME *adbn = NULL;
    DWORD celtFetched;
    DWORD i;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::EnumAttributesOrExtensions(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    DBGPRINT((
	s_ssAdmin,
	"EnumAttributesOrExtensions(row=%d, flags=0x%x, last=%ws, celt=%d)\n",
	RowId,
	Flags,
	pwszLast,
	celt));
    __try
    {
	pctbOut->pb = NULL;
	{
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

	if (0 >= RowId)
	{
	    hr = E_INVALIDARG;
	    _LeaveError(hr, "RowId");
	}
	switch (Flags)
	{
	    case CDBENUM_ATTRIBUTES:
		EnumFlags = CIE_TABLE_ATTRIBUTES;
		break;

	    case CDBENUM_EXTENSIONS:
		EnumFlags = CIE_TABLE_EXTENSIONS;
		break;

	    default:
		hr = E_INVALIDARG;
		_LeaveError(hr, "Flags");
	}

	hr = g_pCertDB->OpenRow(
			    PROPOPEN_READONLY | PROPTABLE_REQCERT,
			    RowId,
			    NULL,
			    &prow);
	_LeaveIfError(hr, "OpenRow(RowId)");

	hr = prow->EnumCertDBName(EnumFlags, &penum);
	_LeaveIfError(hr, "EnumCertDBName");

	adbn = (CERTDBNAME *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(adbn[0]) * celt);
	if (NULL == adbn)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "Alloc string pointers");
	}

	// If specified, skip entries up to and including the last key.

	if (NULL != pwszLast)
	{
	    int r;

	    do
	    {
		hr = penum->Next(1, &adbn[0], &celtFetched);
		if (S_FALSE == hr)
		{
		    hr = E_INVALIDARG;
		    _PrintError(hr, "pwszLast missing");
		}
		_LeaveIfError(hr, "Next");

		r = mylstrcmpiL(pwszLast, adbn[0].pwszName);
		LocalFree(adbn[0].pwszName);
		adbn[0].pwszName = NULL;
	    } while (0 != r);
	}

	hr = penum->Next(celt, adbn, &celtFetched);
	if (S_FALSE != hr)
	{
	    _LeaveIfError(hr, "Next");
	}

	if (CIE_TABLE_ATTRIBUTES == EnumFlags)
	{
	    hr = _EnumAttributes(prow, adbn, celtFetched, pctbOut);
	    _LeaveIfError(hr, "_EnumAttributes");
	}
	else
	{
	    hr = _EnumExtensions(prow, adbn, celtFetched, pctbOut);
	    _LeaveIfError(hr, "_EnumExtensions");
	}

	myRegisterMemFree(pctbOut->pb, CSM_MIDLUSERALLOC);

	*pceltFetched = celtFetched;
	hr = S_OK;
	if (celt > celtFetched)
	{
	    hr = S_FALSE;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != adbn)
    {
	for (i = 0; i < celt; i++)
	{
	    if (NULL != adbn[i].pwszName)
	    {
		CoTaskMemFree(adbn[i].pwszName);
	    }
	}
	LocalFree(adbn);
    }
    if (NULL != penum)
    {
	penum->Release();
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    DBGPRINT((
	    s_ssAdmin,
	    "EnumAttributesOrExtensions: celtFetched=%d, hr=%x\n",
	    *pceltFetched,
	    hr));
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


#define COFFICERLISTCACHE	5

typedef struct _REQUESTERELEMENT {
    struct _REQUESTERELEMENT *pNext;
    WCHAR *pwszRequesterName;
} REQUESTERELEMENT;

class CViewComputedColumn : public ICertDBComputedColumn
{
public:
    CViewComputedColumn();
    ~CViewComputedColumn();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    STDMETHOD(GetAlternateColumnId)(
	IN DWORD ComputedColumnId,
	OUT DWORD *pAlternateColumnId,
	OUT DWORD *pPropType);

    STDMETHOD(ComputeColumnValue)(
	IN DWORD ComputedColumnId,
	IN DWORD AlternateColumnId,
	IN DWORD PropType,
	IN DWORD cbProp,
	IN BYTE const *pbProp,
	OUT DWORD *pdwValue);

    HRESULT SaveAuthzCC();

private:
    BOOL _IsInList(
	IN WCHAR const *pwszRequesterName,
	IN REQUESTERELEMENT const *pList);

    HRESULT _AddToList(
	IN WCHAR const *pwszRequesterName,
	IN OUT DWORD *pcList,
	IN OUT REQUESTERELEMENT **ppList);

    VOID _DeleteList(
	IN BOOL fDeleteLastElementOnly,
	IN OUT DWORD *pcList,
	IN OUT REQUESTERELEMENT **ppList);

    VOID _DeleteElement(
	IN REQUESTERELEMENT *pElement);

private:
    AUTHZ_CLIENT_CONTEXT_HANDLE m_hAuthzCC;

    REQUESTERELEMENT *m_pNonOfficerList;
    DWORD	      m_cNonOfficerList;

    REQUESTERELEMENT *m_pOfficerList;
    DWORD	      m_cOfficerList;

    // Reference count
    long        m_cRef;
};


CViewComputedColumn::CViewComputedColumn()
{
    m_hAuthzCC = NULL;
    m_pNonOfficerList = NULL;
    m_cNonOfficerList = 0;
    m_pOfficerList = NULL;
    m_cOfficerList = 0;
    m_cRef = 1;
}


CViewComputedColumn::~CViewComputedColumn()
{
    if (NULL != m_hAuthzCC)
    {
        AuthzFreeContext(m_hAuthzCC);
    }
    _DeleteList(FALSE, &m_cNonOfficerList, &m_pNonOfficerList);
    _DeleteList(FALSE, &m_cOfficerList, &m_pOfficerList);
}


VOID
CViewComputedColumn::_DeleteElement(
    IN REQUESTERELEMENT *pElement)
{
    if (NULL != pElement->pwszRequesterName)
    {
        LocalFree(pElement->pwszRequesterName);
    }
    LocalFree(pElement);
}


VOID
CViewComputedColumn::_DeleteList(
    IN BOOL fDeleteLastElementOnly,
    IN OUT DWORD *pcList,
    IN OUT REQUESTERELEMENT **ppList)
{
    REQUESTERELEMENT *pElement = *ppList;

    if (fDeleteLastElementOnly)
    {
	REQUESTERELEMENT *pElementPrev = NULL;

	while (NULL != pElement)
	{
	    if (NULL == pElement->pNext && NULL != pElementPrev)
	    {
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "deletelast: %ws\n",
		    pElement->pwszRequesterName));

		pElementPrev->pNext = NULL;
		_DeleteElement(pElement);
		(*pcList)--;
		CSASSERT(0 != *pcList);
		break;
	    }
	    pElementPrev = pElement;
	    pElement = pElement->pNext;
	}
    }
    else
    {
	while (NULL != pElement)
	{
	    REQUESTERELEMENT *pElementNext = pElement->pNext;

	    _DeleteElement(pElement);
	    pElement = pElementNext;
	}
	*pcList = 0;
	*ppList = NULL;
    }
}


BOOL
CViewComputedColumn::_IsInList(
    IN WCHAR const *pwszRequesterName,
    IN REQUESTERELEMENT const *pList)
{
    REQUESTERELEMENT const *pElement;
    BOOL fFound = FALSE;

    for (pElement = pList; NULL != pElement; pElement = pElement->pNext)
    {
	if (0 == mylstrcmpiL(pwszRequesterName, pElement->pwszRequesterName))
	{
	    fFound = TRUE;
	    break;
	}
    }
    return(fFound);
}


HRESULT
CViewComputedColumn::_AddToList(
    IN WCHAR const *pwszRequesterName,
    IN OUT DWORD *pcList,
    IN OUT REQUESTERELEMENT **ppList)
{
    HRESULT hr;
    REQUESTERELEMENT *pElementNew = NULL;

    if (!_IsInList(pwszRequesterName, *ppList))
    {
	pElementNew = (REQUESTERELEMENT *) LocalAlloc(
						LMEM_FIXED | LMEM_ZEROINIT,
						sizeof(*pElementNew));
	if (NULL == pElementNew)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	hr = myDupString(pwszRequesterName, &pElementNew->pwszRequesterName);
	_JumpIfError(hr, error, "myDupString");

	pElementNew->pNext = *ppList;
	*ppList = pElementNew;
	pElementNew = NULL;
	DBGPRINT((DBG_SS_CERTSRVI, "added: %ws\n", pwszRequesterName));

	(*pcList)++;
	if (COFFICERLISTCACHE < *pcList)
	{
	    _DeleteList(TRUE, pcList, ppList);
	}
    }
    hr = S_OK;

error:
    if (NULL != pElementNew)
    {
	_DeleteElement(pElementNew);
    }
    return(hr);
}


STDMETHODIMP
CViewComputedColumn::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertDBComputedColumn *>(this);
    }
    else if (iid == IID_ICertDBComputedColumn)
    {
	*ppv = static_cast<ICertDBComputedColumn *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CViewComputedColumn::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CViewComputedColumn::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


STDMETHODIMP
CViewComputedColumn::GetAlternateColumnId(
    IN DWORD ComputedColumnId,
    OUT DWORD *pAlternateColumnId,
    OUT DWORD *pPropType)
{
    HRESULT hr;

    *pAlternateColumnId = 0;
    if ((DTI_REQUESTTABLE | DTR_OFFICER) != ComputedColumnId)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "ComputedColumnId");
    }
    *pAlternateColumnId = DTI_REQUESTTABLE | DTR_REQUESTERNAME;
    *pPropType = PROPTYPE_STRING;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CViewComputedColumn::ComputeColumnValue(
    IN DWORD ComputedColumnId,
    IN DWORD AlternateColumnId,
    IN DWORD PropType,
    IN DWORD cbProp,
    IN BYTE const *pbProp,
    OUT DWORD *pdwValue)
{
    HRESULT hr;
    WCHAR const *pwszRequesterName;

    *pdwValue = 0;
    if ((DTI_REQUESTTABLE | DTR_OFFICER) != ComputedColumnId ||
	(DTI_REQUESTTABLE | DTR_REQUESTERNAME) != AlternateColumnId ||
	PROPTYPE_STRING != PropType ||
	0 == cbProp ||
	((sizeof(WCHAR) - 1) & cbProp))
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "ComputedColumnId");
    }
    pwszRequesterName = (WCHAR const *) pbProp;
    CSASSERT(L'\0' == pwszRequesterName[cbProp / sizeof(WCHAR)]);
    CSASSERT(sizeof(WCHAR) * wcslen(pwszRequesterName) == cbProp);

    if (_IsInList(pwszRequesterName, m_pNonOfficerList))
    {
	hr = CERTSRV_E_RESTRICTEDOFFICER;
    }
    else if (_IsInList(pwszRequesterName, m_pOfficerList))
    {
	hr = S_OK;
    }
    else
    {
	hr = CheckOfficerRightsFromAuthzCC(m_hAuthzCC, pwszRequesterName);
    }
    if (S_OK == hr)
    {
	_AddToList(pwszRequesterName, &m_cOfficerList, &m_pOfficerList);
	*pdwValue = 1;
    }
    else if (CERTSRV_E_RESTRICTEDOFFICER == hr)
    {
	_AddToList(pwszRequesterName, &m_cNonOfficerList, &m_pNonOfficerList);
	hr = S_OK;
    }
    _JumpIfError(hr, error, "CheckOfficerRightsFromAuthzCC");

error:
    DBGPRINT((
	DBG_SS_CERTSRVI,
	"ComputeColumnValue(%ws) = %u  hr=%x\n",
	(WCHAR const *) pbProp,
	*pdwValue,
	hr));
    return(hr);
}


HRESULT
CViewComputedColumn::SaveAuthzCC()
{
    HRESULT hr;

    hr = GetCallerAuthzContext(&m_hAuthzCC);
    _JumpIfError(hr, error, "GetCallerAuthzContext");

error:
    return(hr);
}


STDMETHODIMP
CCertAdminD::OpenView(
    IN wchar_t const             *pwszAuthority,
    IN DWORD                      ccvr,
    IN CERTVIEWRESTRICTION const *acvr,
    IN DWORD                      ccolOut,
    IN DWORD const               *acolOut,
    IN DWORD                      ielt,
    IN DWORD                      celt,
    OUT DWORD                    *pceltFetched,
    OUT CERTTRANSBLOB            *pctbResultRows)   // CoTaskMem*
{
    HRESULT hr;
    DWORD State = 0;
    CAVIEW *pCAView = NULL;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::OpenView(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    DBGPRINT((
	s_ssAdmin,
	"================================================================\n"));
    DBGPRINT((
	    s_ssAdmin,
	    "OpenView(ccvr=%d, ccolOut=%d, celt=%d)\n",
	    ccvr,
	    ccolOut,
	    celt));

    __try
    {
	pctbResultRows->pb = NULL;
	{
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			    CA_ACCESS_ALLREADROLES,
			    audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

	hr = CertSrvDelinkCAView(this, NULL);
	if (S_OK == hr)
	{
	    hr = E_UNEXPECTED;
	    _LeaveError(hr, "Has View");
	}

	pCAView = (CAVIEW *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				sizeof(*pCAView));
	if (NULL == pCAView)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	hr = g_pCertDB->OpenView(
                        ccvr,
                        acvr,
                        ccolOut,
                        acolOut,
                        CDBOPENVIEW_WORKERTHREAD,
                        &pCAView->pView);
	_LeaveIfError(hr, "OpenView");

	hr = _EnumViewNext(
			pCAView->pView,
			ielt,
			celt,
			pceltFetched,
			pctbResultRows);
	if (S_FALSE != hr)
	{
	    _LeaveIfError(hr, "_EnumViewNext");
	}
	{
	    HRESULT hr2;
	    
	    hr2 = CertSrvLinkCAView(TRUE, this, pCAView);
	    if (S_OK != hr2)
	    {
		_PrintError(hr, "CertSrvLinkCAView");
	    }
	    else
	    {
		m_fHasView = TRUE;
		pCAView = NULL;
	    }
	}
	myRegisterMemFree(pctbResultRows->pb, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pCAView)
    {
	if (NULL != pCAView->pView)
	{
	    pCAView->pView->Release();
	}
	LocalFree(pCAView);
    }
    DBGPRINT((
	    s_ssAdmin,
	    "OpenView: celtFetched=%d, hr=%x\n",
	    *pceltFetched,
	    hr));
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::EnumView(
    IN  wchar_t const *pwszAuthority,
    IN  DWORD          ielt,
    IN  DWORD          celt,
    OUT DWORD         *pceltFetched,
    OUT CERTTRANSBLOB *pctbResultRows)  // CoTaskMem*
{
    HRESULT hr;
    DWORD State = 0;
    CAVIEW *pCAView = NULL;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::EnumView(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    DBGPRINT((s_ssAdmin, "EnumView(ielt=%d, celt=%d)\n", ielt, celt));

    __try
    {
	hr = CertSrvDelinkCAView(this, &pCAView);
	_LeaveIfError(hr, "No View");

	hr = _EnumViewNext(
			pCAView->pView,
			ielt,
			celt,
			pceltFetched,
			pctbResultRows);
	if (S_FALSE != hr)
	{
	    _LeaveIfError(hr, "_EnumViewNext");
	}
	{
	    HRESULT hr2;
	    
	    hr2 = CertSrvLinkCAView(FALSE, this, pCAView);
	    if (S_OK != hr2)
	    {
		_PrintError(hr, "CertSrvLinkCAView");
	    }
	    else
	    {
		pCAView = NULL;
	    }
	}
	myRegisterMemFree(pctbResultRows->pb, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pCAView)
    {
	if (NULL != pCAView->pView)
	{
	    pCAView->pView->Release();
	}
	LocalFree(pCAView);
    }
    DBGPRINT((
	    s_ssAdmin,
	    "EnumView: celtFetched=%d, hr=%x\n",
	    *pceltFetched,
	    hr));
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::_EnumViewNext(
    IN  IEnumCERTDBRESULTROW *pview,
    IN  DWORD                 ielt,
    IN  DWORD                 celt,
    OUT DWORD                *pceltFetched,
    OUT CERTTRANSBLOB        *pctbResultRows)   // CoTaskMem
{
    HRESULT hr;
    BOOL fNoMore = FALSE;
    BOOL fFetched = FALSE;
    DWORD cb;
    DWORD cbT;
    DWORD cColTotal;
    CERTDBRESULTROW *aelt = NULL;
    CERTDBRESULTROW *pelt;
    CERTDBRESULTROW *peltEnd;
    CERTDBRESULTCOLUMN *pcol;
    CERTDBRESULTCOLUMN *pcolEnd;
    CERTTRANSDBRESULTROW *pteltOut;
    CERTTRANSDBRESULTCOLUMN *ptcolOut;
    BYTE *pbOut;
    DWORD ieltLast;
    DWORD State = 0;
    DWORD rowidFirst;
    DWORD rowidLast;
    CViewComputedColumn vcc;
    BOOL fOfficerRightsEnabled;

    if (1 < InterlockedIncrement(&m_cNext))
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "Calls from multiple threads on the same view object");
    }

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    DBGPRINT((s_ssAdmin, "_EnumViewNext(ielt=%d celt=%d)\n", ielt, celt));

    fOfficerRightsEnabled = g_OfficerRightsSD.IsEnabled();
    if (fOfficerRightsEnabled)
    {
	hr = vcc.SaveAuthzCC();
	_JumpIfError(hr, error, "SaveAuthzCC");
    }

    aelt = (CERTDBRESULTROW *) LocalAlloc(LMEM_FIXED, celt * sizeof(aelt[0]));
    if (NULL == aelt)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Alloc result rows");
    }

    hr = pview->Skip(0, (LONG *) &ieltLast);
    _JumpIfError(hr, error, "Skip");

    if (ielt != ieltLast + 1)
    {
	DBGPRINT((
	    s_ssAdmin,
	    "_EnumViewNext! ieltLast=%d cskip=%d\n",
	    ieltLast,
	    ielt - (ieltLast + 1)));
	hr = pview->Skip(ielt - (ieltLast + 1), (LONG *) &ieltLast);
	_JumpIfError(hr, error, "Skip");

	DBGPRINT((
	    s_ssAdmin, "_EnumViewNext! ielt after skip=%d\n",
	    ieltLast));
    }

    hr = pview->Next(
		    fOfficerRightsEnabled? &vcc : NULL,
		    celt,
		    aelt,
		    pceltFetched);
    if (S_FALSE == hr)
    {
	fNoMore = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "Next");
    }
    fFetched = TRUE;

    DBGPRINT((
	    s_ssAdmin,
	    "_EnumViewNext! celtFetched=%d\n",
	    *pceltFetched));

    cb = *pceltFetched * sizeof(*pteltOut);
    if (fNoMore)
    {
	cb += sizeof(*pteltOut);
    }
    cColTotal = 0;

    peltEnd = &aelt[*pceltFetched];
    for (pelt = aelt; pelt < peltEnd; pelt++)
    {
	cColTotal += pelt->ccol;
	cb += pelt->ccol * sizeof(*ptcolOut);

	pcolEnd = &pelt->acol[pelt->ccol];
	for (pcol = pelt->acol; pcol < pcolEnd; pcol++)
	{
	    CSASSERT(DWORDROUND(cb) == cb);
	    if (NULL != pcol->pbValue)
	    {
		if ((DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY) ==
		     pcol->Index)
		{
		    cb += sizeof(DWORD);
		}
		else
		{
		    cb += DWORDROUND(pcol->cbValue);
		}
	    }
	}
    }

    pctbResultRows->pb = (BYTE *) CoTaskMemAlloc(cb);
    if (NULL == pctbResultRows->pb)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CoTaskMemAlloc result rows");
    }
    pctbResultRows->cb = cb;
    ZeroMemory(pctbResultRows->pb, pctbResultRows->cb);

    pbOut = pctbResultRows->pb;

    DBGPRINT((
	    s_ssAdmin,
	    "_EnumViewNext! Result Row data cb=0x%x @%x\n",
	    pctbResultRows->cb,
	    pctbResultRows->pb));

    rowidFirst = MAXDWORD;
    rowidLast = MAXDWORD;
    for (pelt = aelt; pelt < peltEnd; pelt++)
    {
	pteltOut = (CERTTRANSDBRESULTROW *) pbOut;
	pbOut += sizeof(*pteltOut);
	ptcolOut = (CERTTRANSDBRESULTCOLUMN *) pbOut;
	pbOut += pelt->ccol * sizeof(*ptcolOut);

	if (MAXDWORD == rowidFirst)
	{
	    rowidFirst = pelt->rowid;
	}
	rowidLast = pelt->rowid;
	pteltOut->rowid = pelt->rowid;
	pteltOut->ccol = pelt->ccol;

	pcolEnd = &pelt->acol[pelt->ccol];
	for (pcol = pelt->acol; pcol < pcolEnd; pcol++, ptcolOut++)
	{
	    ptcolOut->Type = pcol->Type;
	    ptcolOut->Index = pcol->Index;

	    if (NULL != pcol->pbValue)
	    {
		if ((DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY) ==
		     ptcolOut->Index)
		{
		    cbT = sizeof(BYTE);
		    CSASSERT(0 == *(DWORD *) pbOut);
		}
		else
		{
		    cbT = pcol->cbValue;
		    CopyMemory(pbOut, pcol->pbValue, cbT);
		}
		ptcolOut->cbValue = cbT;
		ptcolOut->obValue = SAFE_SUBTRACT_POINTERS(pbOut, (BYTE *) pteltOut);
		pbOut += DWORDROUND(cbT);
	    }
	}
	pteltOut->cbrow = SAFE_SUBTRACT_POINTERS(pbOut, (BYTE *) pteltOut);
    }
    DBGPRINT((
	    s_ssAdmin,
	    "_EnumViewNext! rowidFirst=%d rowidLast=%d\n",
	    rowidFirst,
	    rowidLast));

    // if past the end or at end of rowset, write an extra record containimg
    // the maximum element count.

    if (fNoMore)
    {
	pteltOut = (CERTTRANSDBRESULTROW *) pbOut;
	pbOut += sizeof(*pteltOut);
	pteltOut->rowid = pelt->rowid;
	pteltOut->ccol = pelt->ccol;
	pteltOut->cbrow = SAFE_SUBTRACT_POINTERS(pbOut, (BYTE *) pteltOut);
	CSASSERT(pteltOut->rowid == ~pteltOut->ccol);
	DBGPRINT((
		s_ssAdmin,
		"_EnumViewNext! celtMax=%d\n",
		pteltOut->rowid));
    }

    DBGPRINT((
	    s_ssAdmin,
	    "_EnumViewNext! pbOut=%x/%x\n",
	    pbOut,
	    &pctbResultRows->pb[pctbResultRows->cb]));

    CSASSERT(&pctbResultRows->pb[pctbResultRows->cb] == pbOut);

    if (fNoMore)
    {
	hr = S_FALSE;
    }

error:
    DBGPRINT((
	    s_ssAdmin,
	    "_EnumViewNext: celtFetched=%d, hr=%x\n",
	    *pceltFetched,
	    hr));
    if (fFetched)
    {
	HRESULT hr2;

	hr2 = pview->ReleaseResultRow(*pceltFetched, aelt);
	_PrintIfError(hr2, "ReleaseResultRow");
    }
    if (NULL != aelt)
    {
	LocalFree(aelt);
    }

    CertSrvExitServer(State, hr);
    InterlockedDecrement(&m_cNext);
    return(hr);
}


STDMETHODIMP
CCertAdminD::CloseView(
    IN wchar_t const *pwszAuthority)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::CloseView(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	CAVIEW *pCAView;

	hr = CertSrvDelinkCAView(this, &pCAView);
	_LeaveIfError(hr, "No View");

	if (NULL != pCAView->pView)
	{
	    pCAView->pView->Release();
	}
	LocalFree(pCAView);
	m_fHasView = FALSE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::RevokeCertificate(
    /* [unique][in] */ USHORT const __RPC_FAR *pwszAuthority,
    /* [in, string, unique] */ USHORT const __RPC_FAR *pwszSerialNumber,
    /* [in] */ DWORD Reason,
    /* [in] */ FILETIME FileTime)
{
    HRESULT hr;
    DWORD ReqId;
    DWORD cbProp;
    DWORD Disposition;
    DWORD OldReason;
    ICertDBRow *prow = NULL;
    WCHAR const *pwszDisposition = NULL;
    WCHAR const *pwszDispT = NULL;
    BOOL fUnRevoke = FALSE;
    BOOL fRevokeOnHold = FALSE;
    WCHAR *pwszUserName = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_REVOKECERT, g_dwAuditFilter);
    LPWSTR pwszRequesterName = NULL;
    DWORD State = 0;
    BOOL fCommitted = FALSE;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::RevokeCertificate(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(pwszSerialNumber); // %1 serial no.
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.AddData(Reason); // %2 reason
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.AccessCheck(
			CA_ACCESS_OFFICER,
			audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	switch (Reason)
	{
	    case MAXDWORD:
		fUnRevoke = TRUE;
		break;

	    case CRL_REASON_CERTIFICATE_HOLD:
		fRevokeOnHold = TRUE;
		break;

	    case CRL_REASON_UNSPECIFIED:
	    case CRL_REASON_KEY_COMPROMISE:
	    case CRL_REASON_CA_COMPROMISE:
	    case CRL_REASON_AFFILIATION_CHANGED:
	    case CRL_REASON_SUPERSEDED:
	    case CRL_REASON_CESSATION_OF_OPERATION:
	    case CRL_REASON_REMOVE_FROM_CRL:
		break;

	    default:
		hr = E_INVALIDARG;
		_LeaveError(hr, "Reason parameter");
	}

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, pwszSerialNumber, &prow);
	if (S_OK != hr)
	{
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		hr = E_INVALIDARG;		// Invalid Serial Number
	    }
	    _LeaveErrorStr(hr, "OpenRow", pwszSerialNumber);
	}

	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRequesterName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    (BYTE **) &pwszRequesterName);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _LeaveIfErrorStr(hr, "PKCSGetProperty", g_wszPropRequesterName);
	}

	hr = CheckOfficerRights(pwszRequesterName, audit);
	_LeaveIfError(hr, "CheckOfficerRights");

	cbProp = sizeof(Disposition);
	hr = prow->GetProperty(
			g_wszPropRequestDisposition,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cbProp,
			(BYTE *) &Disposition);
	_LeaveIfError(hr, "GetProperty");

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	switch (Disposition)
	{
	    HRESULT hr2;

	    case DB_DISP_CA_CERT:
		if (!IsRootCA(g_CAType))
		{
		    _LeaveError(hr, "non-root CA");
		}
		// FALLTHROUGH

	    case DB_DISP_ISSUED:
	    case DB_DISP_REVOKED:
		cbProp = sizeof(OldReason);
		hr2 = prow->GetProperty(
			g_wszPropRequestRevokedReason,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cbProp,
			(BYTE *) &OldReason);

		// Converted MDB databases have UNrevoked rows' RevokedReason
		// column set to zero (CRL_REASON_UNSPECIFIED).

		if (S_OK != hr2 ||
		    (DB_DISP_ISSUED == Disposition &&
		     CRL_REASON_UNSPECIFIED == OldReason))
		{
		    OldReason = MAXDWORD;
		}
		if (fRevokeOnHold &&
		    MAXDWORD != OldReason &&
		    CRL_REASON_CERTIFICATE_HOLD != OldReason)
		{
		    _LeaveError(hr, "already revoked: not on hold");
		}
		if (fUnRevoke && CRL_REASON_CERTIFICATE_HOLD != OldReason)
		{
		    _LeaveError(hr, "unrevoke: not on hold");
		}
		break;

	    default:
		_LeaveError(hr, "invalid disposition");
	}

	hr = PropSetRequestTimeProperty(prow, g_wszPropRequestRevokedWhen);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _LeaveError(hr, "PropSetRequestTimeProperty");
	}

	hr = prow->SetProperty(
			g_wszPropRequestRevokedEffectiveWhen,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(FileTime),
			(BYTE const *) &FileTime);
	_LeaveIfError(hr, "SetProperty");

	hr = prow->SetProperty(
			g_wszPropRequestRevokedReason,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(Reason),
			(BYTE const *) &Reason);
	_LeaveIfError(hr, "SetProperty");

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	pwszDispT = fUnRevoke? g_pwszUnrevokedBy : g_pwszRevokedBy;
	pwszDisposition = CoreBuildDispositionString(
					    pwszDispT,
					    pwszUserName,
					    NULL,
					    NULL,
					    NULL,
					    S_OK,
					    FALSE);
	if (NULL == pwszDisposition)
	{
	    pwszDisposition = pwszDispT;
	}

	hr = prow->SetProperty(
			g_wszPropRequestDispositionMessage,
			PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			MAXDWORD,
			(BYTE const *) pwszDisposition);
	_LeaveIfError(hr, "SetProperty");

	if (DB_DISP_CA_CERT != Disposition)
	{
	    Disposition = fUnRevoke? DB_DISP_ISSUED : DB_DISP_REVOKED;
	    hr = prow->SetProperty(
			g_wszPropRequestDisposition,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(Disposition),
			(BYTE const *) &Disposition);
	    _LeaveIfError(hr, "SetProperty");
	}

	hr = prow->CommitTransaction(TRUE);
	_LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

	prow->GetRowId(&ReqId);
	ExitNotify(EXITEVENT_CERTREVOKED, ReqId, NULL, MAXDWORD);
	CoreLogRequestStatus(
			prow,
			MSG_DN_CERT_REVOKED,
			hr,
			pwszDisposition);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != pwszRequesterName)
    {
        LocalFree(pwszRequesterName);
    }
    if (NULL != pwszDisposition && pwszDisposition != pwszDispT)
    {
	LocalFree(const_cast<WCHAR *>(pwszDisposition));
    }
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::IsValidCertificate(
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszAuthority,
    /* [unique][string][in] */ const wchar_t __RPC_FAR *pwszSerialNumber,
    /* [out] */ LONG __RPC_FAR *pRevocationReason,
    /* [out] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::IsValidCertificate(tid=%d, this=%x, serial=%ws)\n",
	GetCurrentThreadId(),
	this,
	pwszSerialNumber));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	CAuditEvent audit(0, g_dwAuditFilter);

	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = PKCSIsRevoked(
		    0,
		    pwszSerialNumber,
		    pRevocationReason,
		    pDisposition);
	_LeaveIfError(hr, "PKCSIsRevoked");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::IsValidCertificate(serial=%ws) --> %x, Reason=%u Disposition=%u\n",
	pwszSerialNumber,
	hr,
	*pRevocationReason,
	*pDisposition));

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::ServerControl(
    IN  wchar_t const *pwszAuthority,
    IN  DWORD          dwControlFlags,
    OUT CERTTRANSBLOB *pctbOut)
{
    HRESULT hr;
    BOOL fBackupAccess = FALSE;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SHUTDOWN, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::ServerControl(tid=%d, this=%x, Flags=0x%x)\n",
	GetCurrentThreadId(),
	this,
	dwControlFlags));

    pctbOut->pb = NULL;
    pctbOut->cb = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); //allow empty name
    _JumpIfError(hr, error, "CheckAuthorityName");

    switch (dwControlFlags)
    {
	case CSCONTROL_SUSPEND:
	case CSCONTROL_RESTART:
	case CSCONTROL_SHUTDOWN:
	    fBackupAccess = TRUE;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad control flags");
    }

    __try
    {
        hr = audit.AccessCheck(
		CA_ACCESS_ADMIN | (fBackupAccess? CA_ACCESS_OPERATOR : 0),
                audit.m_gcAuditSuccessOrFailure);
        _LeaveIfError(
            hr,
            fBackupAccess?
            "CAuditEvent::AccessCheck backup":
            "CAuditEvent::AccessCheck admin");

	switch (dwControlFlags)
	{
	    case CSCONTROL_SHUTDOWN:
		myRegisterMemFree(this, CSM_NEW | CSM_GLOBALDESTRUCTOR);

		hr = CertSrvLockServer(&State);
		_JumpIfError(hr, error, "CertSrvLockServer");

		// have message loop run shutdown code
		SendMessage(g_hwndMain, WM_STOPSERVER, 0, 0);

		// post, don't wait for shutdown
		PostMessage(g_hwndMain, WM_SYNC_CLOSING_THREADS, 0, 0);
		break;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::_Ping(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); //allow empty name
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	CAuditEvent audit(0, g_dwAuditFilter);

	hr = audit.AccessCheck(
		    CA_ACCESS_ADMIN,
		    audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	myRegisterMemDump();
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::Ping(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::Ping(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = _Ping(pwszAuthority);
    _JumpIfError(hr, error, "_Ping");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::Ping2(
    IN WCHAR const *pwszAuthority)
{
    HRESULT hr;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::Ping2(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = _Ping(pwszAuthority);
    _JumpIfError(hr, error, "_Ping");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetServerState(
    IN  WCHAR const *pwszAuthority,
    OUT DWORD       *pdwState)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetServerState(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); //allow empty name
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	*pdwState = 0;
	{
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

    *pdwState = 1;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupPrepare(
    IN WCHAR const  *pwszAuthority,
    IN unsigned long grbitJet,
    IN unsigned long dwBackupFlags,
    IN WCHAR const  *, // pwszBackupAnnotation
    IN DWORD           /* dwClientIdentifier */ )
{
    HRESULT hr;
    CertSrv::CAuditEvent audit(SE_AUDITID_CERTSRV_BACKUPSTART,g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupPrepare(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); //allow empty name
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	hr = audit.AddData(dwBackupFlags); //%1 backup type
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.AccessCheck(
		CA_ACCESS_OPERATOR,
		audit.m_gcAuditSuccessOrFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	if (NULL != m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveError(hr, "Has Backup");
	}
	if ((IF_NOREMOTEICERTADMINBACKUP & g_InterfaceFlags) &&
	    (IF_NOLOCALICERTADMINBACKUP & g_InterfaceFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_RESOURCE_DISABLED);
	    _LeaveError(hr, "disabled");
	}
	hr = g_pCertDB->OpenBackup(grbitJet, &m_pBackup);
	_LeaveIfError(hr, "OpenBackup");

	m_grbitBackup = grbitJet;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupEnd()
{
    HRESULT hr;
    CertSrv::CAuditEvent audit(SE_AUDITID_CERTSRV_BACKUPEND,g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupEnd(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = audit.AccessCheck(
		CA_ACCESS_OPERATOR,
		audit.m_gcAuditSuccessOrFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveError(hr, "No backup");
	}
	m_pBackup->Release();
	m_pBackup = NULL;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertAdminD::_GetDynamicFileList(
    IN OUT DWORD *pcwcList,
    OPTIONAL OUT WCHAR *pwszzList)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    DWORD iCert;
    DWORD iDelta;
    DWORD iDeltaMax;
    DWORD cwc;
    DWORD cwcRemain;
    DWORD cwcTotal;
    WCHAR const * const *papwszSrc;
    WCHAR const * const *ppwsz;
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    cwcRemain = *pcwcList;
    cwcTotal = 0;
    iDeltaMax = g_fDeltaCRLPublishDisabled? 0 : 1;

    for (iCert = 0; iCert < g_cCACerts; iCert++)
    {
	for (iDelta = 0; iDelta <= iDeltaMax; iDelta++)
	{
	    hr2 = PKCSGetCRLList(0 != iDelta, iCert, &papwszSrc);
	    if (S_OK != hr2)
	    {
		_PrintError2(hr2, "PKCSGetCRLList", hr2);
		continue;
	    }
	    for (ppwsz = papwszSrc; NULL != *ppwsz; ppwsz++)
	    {
		WCHAR const *pwsz = *ppwsz;

		// Just return local full path files:

		if (iswalpha(pwsz[0]) && L':' == pwsz[1] && L'\\' == pwsz[2])
		{
		    cwc = wcslen(pwsz) + 1;
		    if (NULL != pwszzList)
		    {
			DWORD cwcT;

			cwcT = min(cwc, cwcRemain);
			CopyMemory(pwszzList, *ppwsz, cwcT * sizeof(WCHAR));
			pwszzList += cwcT;
			if (cwc > cwcT)
			{
			    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
			    pwszzList = NULL;
			}
			cwcRemain -= cwcT;
		    }
		    cwcTotal += cwc;
		}
	    }
	}
    }

    // append an extra trailing L'\0'

    if (NULL != pwszzList)
    {
	if (1 <= cwcRemain)
	{
	    *pwszzList = L'\0';
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	}
    }
    cwcTotal++;

    *pcwcList = cwcTotal;
    _JumpIfError(hr, error, "Buffer Overflow");

error:
    CertSrvExitServer(State, hr);
    return(hr);
}


typedef struct _DBTAG
{
    WCHAR const *pwszPath;
    WCHAR wcFileType;
} DBTAG;


DBTAG g_adbtag[] = {
    { g_wszDatabase,  CSBFT_CERTSERVER_DATABASE },
    { g_wszLogDir,    CSBFT_LOG_DIR },
    { g_wszSystemDir, CSBFT_CHECKPOINT_DIR },
};


CSBFT
BftClassify(
    IN WCHAR const *pwszFileName)
{
    WCHAR *pwszPath = NULL;
    WCHAR const *pwszExt;
    WCHAR *pwsz;
    DWORD i;
    CSBFT bft;

    // Do the easy cases first.

    pwszExt = wcsrchr(pwszFileName, L'.');
    if (NULL != pwszExt)
    {
	if (0 == LSTRCMPIS(pwszExt, L".pat"))
	{
	    bft = CSBFT_PATCH_FILE;
	    goto done;
	}
	if (0 == LSTRCMPIS(pwszExt, L".log"))
	{
	    bft = CSBFT_LOG;
	    goto done;
	}
	if (0 == LSTRCMPIS(pwszExt, L".edb"))
	{
	    // It's a database.  Find out which database it is.

	    for (i = 0; i < ARRAYSIZE(g_adbtag); i++)
	    {
		bft = g_adbtag[i].wcFileType;
		if ((bft & CSBFT_DATABASE_DIRECTORY) &&
		    0 == mylstrcmpiL(g_adbtag[i].pwszPath, pwszFileName))
		{
		    goto done;
		}
	    }
	}
    }

    // Ok, I give up.  We don't know anything about this file at all;
    // try to figure out what we can tell the caller about it.

    pwszPath = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(pwszFileName) + 1) * sizeof(WCHAR));
    if (NULL != pwszPath)
    {
	wcscpy(pwszPath, pwszFileName);
	pwsz = wcsrchr(pwszPath, L'\\');
	if (NULL != pwsz)
	{
	    *pwsz = L'\0';	// truncate to directory path
	}
	for (i = 0; i < ARRAYSIZE(g_adbtag); i++)
	{
	    bft = g_adbtag[i].wcFileType;
	    if (bft & CSBFT_DIRECTORY)
	    {
		// If this file's directory matches the directory we're
		// looking at, we know where it needs to go on the restore.

		if (0 == mylstrcmpiL(g_adbtag[i].pwszPath, pwszPath))
		{
		    goto done;
		}
	    }
	}
    }
    bft = CSBFT_UNKNOWN;

done:
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    return(bft);
}


HRESULT
CCertAdminD::_GetDatabaseLocations(
    IN OUT DWORD *pcwcList,
    OPTIONAL OUT WCHAR *pwszzList)
{
    HRESULT hr = S_OK;
    DWORD cwc;
    DWORD cwcRemain;
    WCHAR *pwcRemain;
    DWORD i;
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    cwcRemain = *pcwcList;
    pwcRemain = pwszzList;

    cwc = 1;
    for (i = 0; i < ARRAYSIZE(g_adbtag); i++)
    {
	DWORD cwcT;

	cwcT = wcslen(g_adbtag[i].pwszPath) + 1;
	cwc += 1 + cwcT;
	if (NULL != pwcRemain && 0 < cwcRemain)
	{
	    *pwcRemain++ = g_adbtag[i].wcFileType;
	    cwcRemain--;
	    if (cwcT > cwcRemain)
	    {
		cwcT = cwcRemain;
	    }
	    CopyMemory(pwcRemain, g_adbtag[i].pwszPath, cwcT * sizeof(WCHAR));
	    pwcRemain += cwcT;
	    cwcRemain -= cwcT;
	}
    }
    if (NULL != pwcRemain)
    {
	if (0 < cwcRemain)
	{
	    *pwcRemain = L'\0';
	}
	if (cwc > *pcwcList)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	}
    }
    *pcwcList = cwc;
    _JumpIfError(hr, error, "Buffer Overflow");

error:
    CertSrvExitServer(State, hr);
    return(hr);
}


STDMETHODIMP
CCertAdminD::RestoreGetDatabaseLocations(
    OUT WCHAR **ppwszDatabaseLocations,
    OUT LONG   *pcwcPaths)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::RestoreGetDatabaseLocations(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = _BackupGetFileList(MAXDWORD, ppwszDatabaseLocations, pcwcPaths);
	_LeaveIfError(hr, "_BackupGetFileList");

	myRegisterMemFree(*ppwszDatabaseLocations, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// Convert UNC path to local full path, as in:
//	\\server\c$\foo... --> c:\foo...
// Note the server name need not match the current server name.

HRESULT
ConvertUNCToLocalPath(
    IN WCHAR const *pwszPath,
    OUT WCHAR **ppwszPathLocal)		// LocalAlloc
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    WCHAR const *pwc;

    *ppwszPathLocal = NULL;

    if (L'\\' != pwszPath[0] || L'\\' != pwszPath[1])
    {
	_JumpError(hr, error, "not a UNC path");
    }
    pwc = wcschr(&pwszPath[2], L'\\');
    if (NULL == pwc || !iswalpha(pwc[1]) || L'$' != pwc[2] || L'\\' != pwc[3])
    {
	_JumpError(hr, error, "bad-UNC path");
    }
    pwc++;

    *ppwszPathLocal = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(wcslen(pwc) + 1) * sizeof(WCHAR));
    if (NULL == *ppwszPathLocal)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszPathLocal, pwc);

    CSASSERT(L'$' == (*ppwszPathLocal)[1]);
    (*ppwszPathLocal)[1] = L':';

    hr = S_OK;

error:
    return(hr);
}


// Convert local possibly annotated full paths to possibly annotated UNC, as:
//	[CSBFT_*]c:\foo... --> [CSBFT_*]\\server\c$\foo...

HRESULT
ConvertLocalPathsToMungedUNC(
    IN WCHAR const *pwszzFiles,
    IN BOOL fAnnotated,			// TRUE if already annotated
    IN WCHAR wcFileType,		// else Annotation WCHAR (if not L'\0')
    OUT DWORD *pcwc,
    OUT WCHAR **ppwszzFilesUNC)		// CoTaskMemAlloc
{
    HRESULT hr;
    DWORD cwc;
    WCHAR const *pwsz;
    WCHAR *pwszDst;
    DWORD cfiles = 0;
    WCHAR *pwszzFilesUNC = NULL;

    *pcwc = 0;
    for (pwsz = pwszzFiles; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	if (fAnnotated)
	{
	    pwsz++;
	}
	if (!iswalpha(pwsz[0]) || L':' != pwsz[1] || L'\\' != pwsz[2])
	{
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "non-local path");
	}
	cfiles++;
    }
    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszzFiles) + 1;
    cwc += cfiles * (2 + wcslen(g_pwszServerName) + 1);
    if (!fAnnotated && 0 != wcFileType)
    {
	cwc += cfiles;			// Add munged CSBFT_* character
    }

    pwszzFilesUNC = (WCHAR *) CoTaskMemAlloc(cwc * sizeof(WCHAR));
    if (NULL == pwszzFilesUNC)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CoTaskMemAlloc pwszzFiles");
    }

    pwszDst = pwszzFilesUNC;
    for (pwsz = pwszzFiles; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	if (fAnnotated)
	{
	    *pwszDst++ = *pwsz++;		// "CSBFT"
	}
	else
	if (0 != wcFileType)
	{
	    *pwszDst++ = BftClassify(pwsz);	// "CSBFT"
	}
	wcscpy(pwszDst, L"\\\\");		// "[CSBFT]\\"
	wcscat(pwszDst, g_pwszServerName);	// "[CSBFT]\\server"
	pwszDst += wcslen(pwszDst);
	*pwszDst++ = L'\\';			// "[CSBFT]\\server\"
	*pwszDst++ = *pwsz++;			// "[CSBFT]\\server\c"
	*pwszDst++ = L'$';			// "[CSBFT]\\server\c$"
	pwsz++;					// skip colon

	wcscpy(pwszDst, pwsz);			// "[CSBFT]\\server\c$\foo..."
	pwszDst += wcslen(pwszDst) + 1;
    }
    *pwszDst = L'\0';
    CSASSERT(SAFE_SUBTRACT_POINTERS(pwszDst, pwszzFilesUNC) + 1 == cwc);

    *pcwc = cwc;
    *ppwszzFilesUNC = pwszzFilesUNC;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertAdminD::_BackupGetFileList(
    IN  DWORD   dwFileType,
    OUT WCHAR **ppwszzFiles,    // CoTaskMem*
    OUT LONG   *pcwcFiles)
{
    HRESULT hr;
    WCHAR *pwszzFiles = NULL;
    WCHAR *pwszzFilesUNC = NULL;
    DWORD cwcFiles = 0;
    DWORD cwc;
    BOOL fAnnotated = FALSE;
    DWORD State = 0;

    *ppwszzFiles = NULL;
    *pcwcFiles = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    if (NULL == m_pBackup && MAXDWORD != dwFileType && 0 != dwFileType)
    {
	hr = E_UNEXPECTED;
	_JumpIfError(hr, error, "No backup");
    }
    for (;;)
    {
	cwc = cwcFiles;
	if (CSBFT_CERTSERVER_DATABASE == dwFileType)
	{
	    hr = m_pBackup->GetDBFileList(&cwc, pwszzFiles);
	    _JumpIfError(hr, error, "GetDBFileList");
	}
	else if (CSBFT_LOG == dwFileType)
	{
	    hr = m_pBackup->GetLogFileList(&cwc, pwszzFiles);
	    _JumpIfError(hr, error, "GetLogFileList");
	}
	else if (MAXDWORD == dwFileType)
	{
	    hr = _GetDatabaseLocations(&cwc, pwszzFiles);
	    _JumpIfError(hr, error, "_GetDatabaseLocations");

	    fAnnotated = TRUE;
	}
	else if (0 == dwFileType)
	{
	    hr = _GetDynamicFileList(&cwc, pwszzFiles);
	    _JumpIfError(hr, error, "_GetDynamicFileList");
	}
	else
	{
	    CSASSERT(CSExpr(!"bad FileListtype"));
	}

	if (NULL != pwszzFiles)
	{
	    break;
	}
	pwszzFiles = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwszzFiles)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc pwszzFiles");
	}
	cwcFiles = cwc;
    }
    hr = ConvertLocalPathsToMungedUNC(
			pwszzFiles,
			fAnnotated,
			(WCHAR) dwFileType,
			&cwc,
			&pwszzFilesUNC);
    _JumpIfError(hr, error, "ConvertLocalPathsToMungedUNC");

    *ppwszzFiles = pwszzFilesUNC;
    *pcwcFiles = cwc;
    pwszzFilesUNC = NULL;

error:
    if (NULL != pwszzFilesUNC)
    {
	CoTaskMemFree(pwszzFilesUNC);
    }
    if (NULL != pwszzFiles)
    {
	LocalFree(pwszzFiles);
    }
    CertSrvExitServer(State, hr);
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupGetAttachmentInformation(
    OUT WCHAR **ppwszzDBFiles,
    OUT LONG   *pcwcDBFiles)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupGetAttachmentInformation(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = _BackupGetFileList(
			    CSBFT_CERTSERVER_DATABASE,
			    ppwszzDBFiles,
			    pcwcDBFiles);
	_LeaveIfError(hr, "_BackupGetFileList");

	myRegisterMemFree(*ppwszzDBFiles, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupGetBackupLogs(
    OUT WCHAR **ppwszzLogFiles,
    OUT LONG   *pcwcLogFiles)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupGetBackupLogs(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = _BackupGetFileList(CSBFT_LOG, ppwszzLogFiles, pcwcLogFiles);
	_LeaveIfError(hr, "_BackupGetFileList");

	myRegisterMemFree(*ppwszzLogFiles, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupGetDynamicFiles(
    OUT WCHAR **ppwszzFiles,
    OUT LONG   *pcwcFiles)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupGetDynamicFiles(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	hr = _BackupGetFileList(0, ppwszzFiles, pcwcFiles);
	_LeaveIfError(hr, "_BackupGetFileList");

	myRegisterMemFree(*ppwszzFiles, CSM_MIDLUSERALLOC);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupOpenFile(
    IN  WCHAR const    *pwszPath,
    OUT unsigned hyper *pliLength)
{
    HRESULT hr;
    WCHAR *pwszPathLocal = NULL;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupOpenFile(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveIfError(hr, "No backup");
	}
	hr = ConvertUNCToLocalPath(pwszPath, &pwszPathLocal);
	_LeaveIfError(hr, "ConvertUNCToLocalPath");

	hr = m_pBackup->OpenFile(pwszPathLocal, (ULARGE_INTEGER *) pliLength);
	_LeaveIfError(hr, "OpenFile");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
    if (NULL != pwszPathLocal)
    {
	LocalFree(pwszPathLocal);
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupReadFile(
    OUT BYTE *pbBuffer,
    IN  LONG  cbBuffer,
    OUT LONG *pcbRead)
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupReadFile(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveIfError(hr, "No backup");
	}
	*pcbRead = cbBuffer;

	hr = m_pBackup->ReadFile((DWORD *) pcbRead, pbBuffer);
	_LeaveIfError(hr, "ReadFile");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupCloseFile()
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupCloseFile(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveIfError(hr, "No backup");
	}
	hr = m_pBackup->CloseFile();
	_LeaveIfError(hr, "CloseFile");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::BackupTruncateLogs()
{
    HRESULT hr;
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::BackupTruncateLogs(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	WCHAR *apwsz[1];

	if (NULL == m_pBackup)
	{
	    hr = E_UNEXPECTED;
	    _LeaveIfError(hr, "No backup");
	}
	hr = m_pBackup->TruncateLog();
	_LeaveIfError(hr, "TruncateLog");

	apwsz[0] = wszREGDBLASTINCREMENTALBACKUP;
	hr = CertSrvSetRegistryFileTimeValue(
				    TRUE,
				    (JET_bitBackupIncremental & m_grbitBackup)?
					wszREGDBLASTINCREMENTALBACKUP :
					wszREGDBLASTFULLBACKUP,
				    (DWORD)((JET_bitBackupIncremental & m_grbitBackup)?
					0 : ARRAYSIZE(apwsz)),
				    apwsz);
	_PrintIfError(hr, "CertSrvSetRegistryFileTimeValue");
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::ImportCertificate(
    IN wchar_t const *pwszAuthority,
    IN CERTTRANSBLOB *pctbCertificate,
    IN LONG Flags,
    OUT LONG *pRequestId)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    CERT_CONTEXT const *pCert = NULL;
    WCHAR *pwszUserName = NULL;
    CACTX *pCAContext;
    CAuditEvent audit(SE_AUDITID_CERTSRV_IMPORTCERT, g_dwAuditFilter);
    DWORD State = 0;
    BOOL fCommitted = FALSE;
    DWORD Disposition;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    BSTR strHash = NULL;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::ImportCertificate(tid=%d, this=%x, cb=%x)\n",
	GetCurrentThreadId(),
	this,
	pctbCertificate->cb));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    if (~(ICF_ALLOWFOREIGN | CR_IN_ENCODEMASK) & Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags");
    }
    if ((ICF_ALLOWFOREIGN & Flags) &&
	0 == (KRAF_ENABLEFOREIGN & g_KRAFlags))
    {
	hr = CERT_E_ISSUERCHAINING;
	_JumpError(hr, error, "Foreign disabled");
    }
    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = audit.AddData(
			pctbCertificate->pb,
			pctbCertificate->cb); // %1 Certificate
        _LeaveIfError(hr, "CAuditEvent::AddData");

        hr = audit.AddData((DWORD)0); // %2 dummy request ID, if access check fails
                                      // and a deny event is generated, we need the
                                      // right number of audit arguments
        _LeaveIfError(hr, "CAuditEvent::AddData");

        hr = audit.AccessCheck(
            CA_ACCESS_OFFICER,
            audit.m_gcNoAuditSuccess);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        pCert = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pctbCertificate->pb,
					pctbCertificate->cb);
        if (NULL == pCert)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _LeaveError(hr, "CertCreateCertificateContext");
        }

        // Be sure we issued this certificate before adding it to the database.

	Disposition = DB_DISP_ISSUED;
        hr = PKCSVerifyIssuedCertificate(pCert, &pCAContext);
	if (S_OK != hr)
	{
	    _PrintError2(hr, "PKCSVerifyIssuedCertificate", NTE_BAD_SIGNATURE);
	    if (0 == (ICF_ALLOWFOREIGN & Flags))
	    {
		hr = CERT_E_ISSUERCHAINING;
		_LeaveError2(hr, "PKCSVerifyIssuedCertificate", hr);
	    }
	    Disposition = DB_DISP_FOREIGN;
	    pCAContext = NULL;
	}

	cbHash = sizeof(abHash);
	if (!CertGetCertificateContextProperty(
					pCert,
					CERT_SHA1_HASH_PROP_ID,
					abHash,
					&cbHash))
	{
	    hr = myHLastError();
	    _LeaveError(hr, "CertGetCertificateContextProperty");
	}

	hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
	_LeaveIfError(hr, "MultiByteIntegerToBstr");

	hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY |
			    PROPOPEN_CERTHASH |
			    PROPTABLE_REQCERT,
			0,		// RequestId
			strHash,
			&prow);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _LeaveIfErrorStr(hr, "OpenRow", strHash);

	    fCommitted = TRUE;	// open for read-only: skip rollback
	    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
	    _LeaveErrorStr2(
			hr,
			"Cert exists",
			strHash,
			HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));
	}

        // okay, we've got valid data. Time to write to the Database.

        hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, &prow);
        _LeaveIfError(hr, "OpenRow");

        // set request id
        hr = prow->GetRowId((DWORD *) pRequestId);
        _LeaveIfError(hr, "GetRowId");

	hr = GetClientUserName(NULL, &pwszUserName, NULL);
	_LeaveIfError(hr, "GetClientUserName");

	hr = prow->SetProperty(
                g_wszPropRequesterName,
                PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
                MAXDWORD,
                (BYTE const *) pwszUserName);
	_LeaveIfError(hr, "SetProperty(requester)");

	hr = prow->SetProperty(
                g_wszPropCallerName,
                PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
                MAXDWORD,
                (BYTE const *) pwszUserName);
	_LeaveIfError(hr, "SetProperty(caller)");

	hr = PKCSParseImportedCertificate(
				    prow,
				    FALSE,	// fCrossCert
				    Disposition,
				    pCAContext,
				    pCert);
	_LeaveIfError(hr, "PKCSParseImportedCertificate");

	hr = prow->CommitTransaction(TRUE);
	_LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

	audit.DeleteLastData(); // remove dummy request ID added above
	hr = audit.AddData((DWORD) *pRequestId); // %2 request ID
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::ImportKey(
    IN wchar_t const *pwszAuthority,
    IN DWORD RequestId,
    IN wchar_t const *pwszCertHash,
    IN DWORD Flags,
    IN CERTTRANSBLOB *pctbKey)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_IMPORTKEY, g_dwAuditFilter);
    DWORD State = 0;
    BOOL fCommitted = FALSE;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    CERT_CONTEXT const *pCert = NULL;
    DWORD dwRowId;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::ImportKey(tid=%d, this=%x, cb=%x)\n",
	GetCurrentThreadId(),
	this,
	pctbKey->cb));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    if (~(IKF_OVERWRITE | CR_IN_ENCODEMASK) & Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags");
    }

    __try
    {
	CRYPT_ATTR_BLOB BlobEncrypted;
	DWORD cb;

        hr = audit.AddData(RequestId); // %1 request ID
        _LeaveIfError(hr, "AddData");

        hr = audit.AccessCheck(
                CA_ACCESS_OFFICER,
                audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	if (MAXDWORD == RequestId)
	{
	    RequestId = 0;
	}
	if (0 == RequestId && NULL == pwszCertHash)
	{
	    hr = E_INVALIDARG;
	    _LeaveError(hr, "pwszCertHash NULL");
	}

	hr = g_pCertDB->OpenRow(
			PROPTABLE_REQCERT |
			    (NULL != pwszCertHash? PROPOPEN_CERTHASH : 0),
			RequestId,
			pwszCertHash,
			&prow);
	_LeaveIfErrorStr(hr, "OpenRow", pwszCertHash);

	BlobEncrypted.cbData = pctbKey->cb;
	BlobEncrypted.pbData = pctbKey->pb;

	hr = prow->GetRowId(&dwRowId);
	_LeaveIfError(hr, "GetRowId");

	// request ID added above could be bogus, add real ID

	audit.DeleteLastData(); 
	hr = audit.AddData(dwRowId); // %1 request ID
	_LeaveIfError(hr, "CAuditEvent::AddData");

	cb = 0;
	hr = prow->GetProperty(
			    g_wszPropRequestRawArchivedKey,
			    PROPTYPE_BINARY |
				PROPCALLER_SERVER |
				PROPTABLE_REQUEST,
			    NULL,
			    &cb,
			    NULL);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _LeaveIfErrorStr(hr, "OpenRow", pwszCertHash);
	}
	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRawCertificate,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbCert,
		    (BYTE **) &pbCert);
	_LeaveIfError(hr, "PKCSGetProperty(cert)");

        pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
        if (NULL == pCert)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _LeaveError(hr, "CertCreateCertificateContext");
        }

	hr = PKCSArchivePrivateKey(
				prow,
				CERT_V1 == pCert->pCertInfo->dwVersion,
				(IKF_OVERWRITE & Flags)? TRUE : FALSE,
				&BlobEncrypted,
				NULL);
	_LeaveIfError2(
		hr,
		"PKCSArchivePrivateKey",
		HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));

        hr = prow->CommitTransaction(TRUE);
        _LeaveIfError(hr, "CommitTransaction");

	fCommitted = TRUE;

        hr = audit.CachedGenerateAudit();
        _LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    CertSrvExitServer(State, hr);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetCASecurity(
    IN WCHAR const    *pwszAuthority,
    OUT CERTTRANSBLOB *pctbSD)   // CoTaskMem*
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD State = 0;

    // init
    pctbSD->pb = NULL;
    pctbSD->cb = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetCASecurity(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	// get current SD:
	hr = g_CASD.LockGet(&pSD); // no free
	_LeaveIfError(hr, "CProtectedSecurityDescriptor::LockGet");

	pctbSD->cb = GetSecurityDescriptorLength(pSD);
	pctbSD->pb = (BYTE *) CoTaskMemAlloc(pctbSD->cb);
	if (NULL == pctbSD->pb)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CoTaskMemAlloc");
	}
	myRegisterMemFree(pctbSD->pb, CSM_MIDLUSERALLOC);
	CopyMemory(pctbSD->pb, pSD, pctbSD->cb);

	hr = g_CASD.Unlock();
	_LeaveIfError(hr, "CProtectedSecurityDescriptor::Unlock");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    return hr;
}


STDMETHODIMP
CCertAdminD::SetCASecurity(
    IN WCHAR const   *pwszAuthority,
    IN CERTTRANSBLOB *pctbSD)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) pctbSD->pb;
    LPWSTR pwszSD = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETSECURITY, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
        s_ssAdmin,
        "CCertAdminD::SetCASecurity(tid=%d, this=%x)\n",
        GetCurrentThreadId(),
        this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
    hr = audit.AddData(pctbSD->pb, pctbSD->cb); // %1 dump permissions as blob, we
                                          // don't want to parse the blob unless
                                          // access check succeeds
    _LeaveIfError(hr, "CAuditEvent::AddData");

    hr = audit.AccessCheck(
        CA_ACCESS_ADMIN,
        audit.m_gcNoAuditSuccess);
    _LeaveIfError(hr, "CAuditEvent::AccessCheck");

    hr = CCertificateAuthoritySD::ConvertToString(pSD, pwszSD);
    _LeaveIfError(hr, "CAuditEvent::ConvertToString");

    audit.DeleteLastData(); // remove permissions blob to add a human friendly SD dump
    hr = audit.AddData(pwszSD);
    _LeaveIfError(hr, "CAuditEvent::AddData");

    hr = audit.CachedGenerateAudit();
    _LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

    if (g_OfficerRightsSD.IsEnabled())
    {
        // adjust officer rights to match new CA SD; persistently save it
        hr = g_OfficerRightsSD.Adjust(pSD);
        _LeaveIfError(hr, "CProtectedSecurityDescriptor::Adjust");

        hr = g_OfficerRightsSD.Save();
        _LeaveIfError(hr, "CProtectedSecurityDescriptor::Save");
    }

    hr = g_CASD.Set(pSD, g_fUseDS?true:false);
    _LeaveIfError(hr, "CProtectedSecurityDescriptor::Set");

    hr = g_CASD.Save();
    _LeaveIfError(hr, "CProtectedSecurityDescriptor::Save");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE) == hr)
    {
        LogEventString(
            EVENTLOG_ERROR_TYPE,
            MSG_E_CANNOT_WRITE_TO_DS,
            g_wszCommonName);
    }
    else
    {
        if(S_OK != hr)
        {
            LogEventHResult(
                EVENTLOG_ERROR_TYPE,
                MSG_E_CANNOT_SET_PERMISSIONS,
                hr);
        }
    }

    LOCAL_FREE(pwszSD);
    CertSrvExitServer(State, hr);
    return hr;
}

// Constructor
CCertAdminD::CCertAdminD() : m_cRef(1), m_cNext(0)
{
    InterlockedIncrement(&g_cAdminComponents);
    m_pEnumCol = NULL;
    m_pBackup = NULL;
    m_fHasView = FALSE;
}


// Destructor
CCertAdminD::~CCertAdminD()
{
    InterlockedDecrement(&g_cAdminComponents);
    if (NULL != m_pEnumCol)
    {
	m_pEnumCol->Release();
	m_pEnumCol = NULL;
    }
    if (NULL != m_pBackup)
    {
	m_pBackup->Release();
	m_pBackup = NULL;
    }
    if (m_fHasView)
    {
	HRESULT hr;
	CAVIEW *pCAView;

	hr = CertSrvDelinkCAView(this, &pCAView);
	if (S_OK == hr)
	{
	    if (NULL != pCAView->pView)
	    {
		pCAView->pView->Release();
	    }
	    LocalFree(pCAView);
	}
    }
}


// IUnknown implementation
STDMETHODIMP
CCertAdminD::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertAdminD *>(this);
    }
    else if (iid == IID_ICertAdminD)
    {
	*ppv = static_cast<ICertAdminD *>(this);
    }
    else if (iid == IID_ICertAdminD2)
    {
	*ppv = static_cast<ICertAdminD2 *>(this);
    }
    else
    {
	*ppv = NULL;
	return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return(S_OK);
}


ULONG STDMETHODCALLTYPE
CCertAdminD::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CCertAdminD::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}



CAdminFactory::~CAdminFactory()
{
    if (m_cRef != 0)
    {
	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CAdminFactory has %d instances left over\n",
	    m_cRef));
    }
}

// Class factory IUnknown implementation
STDMETHODIMP
CAdminFactory::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
	*ppv = static_cast<IClassFactory*>(this);
    }
    else
    {
	*ppv = NULL;
	return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return(S_OK);
}


ULONG STDMETHODCALLTYPE
CAdminFactory::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CAdminFactory::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
	return(0);
    }
    return(cRef);
}


// IClassFactory implementation
STDMETHODIMP
CAdminFactory::CreateInstance(
    IUnknown *pUnknownOuter,
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    CCertAdminD *pA;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
	hr = CLASS_E_NOAGGREGATION;
	_JumpError(hr, error, "pUnknownOuter");
    }

    // Create component.

    pA = new CCertAdminD;
    if (pA == NULL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "out of memory");
    }

    // Get the requested interface.

    hr = pA->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)

    pA->Release();

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// LockServer
STDMETHODIMP
CAdminFactory::LockServer(
    BOOL bLock)
{
    if (bLock)
    {
	InterlockedIncrement(&g_cAdminServerLocks);
    }
    else
    {
	InterlockedDecrement(&g_cAdminServerLocks);
    }
    return(S_OK);
}


STDMETHODIMP
CAdminFactory::CanUnloadNow()
{
    if (g_cAdminComponents || g_cAdminServerLocks)
    {
        return(S_FALSE);
    }
    return(S_OK);
}


STDMETHODIMP
CAdminFactory::StartFactory()
{
    HRESULT hr;

    g_pIAdminFactory = new CAdminFactory();
    if (NULL == g_pIAdminFactory)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "alloc CAdminFactory");
    }

    hr = CoRegisterClassObject(
                      CLSID_CCertAdminD,
                      static_cast<IUnknown *>(g_pIAdminFactory),
                      CLSCTX_LOCAL_SERVER,
                      REGCLS_MULTIPLEUSE,
                      &g_dwAdminRegister);
    _JumpIfError(hr, error, "CoRegisterClassObject");

error:
    if (S_OK != hr)
    {
	CAdminFactory::StopFactory();
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


VOID
CAdminFactory::StopFactory()
{
    HRESULT hr;

    if (0 != g_dwAdminRegister)
    {
        hr = CoRevokeClassObject(g_dwAdminRegister);
	_PrintIfError(hr, "CoRevokeClassObject");
        g_dwAdminRegister = 0;
    }
    if (NULL != g_pIAdminFactory)
    {
        g_pIAdminFactory->Release();
        g_pIAdminFactory = NULL;
    }
}


STDMETHODIMP
CCertAdminD::GetAuditFilter(
    IN wchar_t const *pwszAuthority,
    OUT DWORD        *pdwFilter)
{
    HRESULT hr;
    DWORD State = 0;
    CAuditEvent audit(0, g_dwAuditFilter);

    *pdwFilter = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = audit.AccessCheck(
		        CA_ACCESS_ALLREADROLES,
		        audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        *pdwFilter = g_dwAuditFilter;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    return(hr);
}


STDMETHODIMP
CCertAdminD::SetAuditFilter(
    IN wchar_t const *pwszAuthority,
    IN DWORD          dwFilter)
{
    HRESULT hr;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETAUDITFILTER, g_dwAuditFilter);
    DWORD State = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = audit.AddData(dwFilter); // %1 filter
        _LeaveIfError(hr, "AddParam");

        hr = audit.AccessCheck(
            CA_ACCESS_AUDITOR,
            audit.m_gcAuditSuccessOrFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        // save the audit filter using a dummy audit object
        {
            CAuditEvent dummyaudit(0, dwFilter);

            hr = dummyaudit.SaveFilter(g_wszSanitizedName);
            _LeaveIfError(hr, "CAuditEvent::SaveFilter");
        }
        g_dwAuditFilter = dwFilter;

        // we can't catch service start/stop events generated
        // by SCM, so we need to update the SACL on the service
        
        hr = UpdateServiceSacl(g_dwAuditFilter&AUDIT_FILTER_STARTSTOP);
        _LeaveIfError(hr, "UpdateServiceSacl");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    return(hr);
}


STDMETHODIMP
CCertAdminD::GetOfficerRights(
    IN  wchar_t const *pwszAuthority,
    OUT BOOL *pfEnabled,
    OUT CERTTRANSBLOB *pctbSD)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD State = 0;

    pctbSD->pb = NULL;
    pctbSD->cb = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetOfficerRights(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    if (!g_fAdvancedServer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
	_JumpError(hr, error, "g_fAdvancedServer");
    }

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
        hr = audit.AccessCheck(
		        CA_ACCESS_ALLREADROLES,
		        audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
        _LeaveIfError(hr, "CAuditEvent::AccessCheck");

        *pfEnabled = g_OfficerRightsSD.IsEnabled();

        // return the security descriptor only if the feature is enabled

        if (g_OfficerRightsSD.IsEnabled())
        {
            // get current SD:
            hr = g_OfficerRightsSD.LockGet(&pSD); // no free
            _LeaveIfError(hr, "CProtectedSecurityDescriptor::LockGet");

	    pctbSD->cb = GetSecurityDescriptorLength(pSD);
	    pctbSD->pb = (BYTE *) CoTaskMemAlloc(pctbSD->cb);
	    if (NULL == pctbSD->pb)
	    {
		hr = E_OUTOFMEMORY;
		_LeaveError(hr, "CoTaskMemAlloc");
	    }
	    myRegisterMemFree(pctbSD->pb, CSM_MIDLUSERALLOC);
	    CopyMemory(pctbSD->pb, pSD, pctbSD->cb);

            hr = g_OfficerRightsSD.Unlock();
            _LeaveIfError(hr, "CProtectedSecurityDescriptor::Unlock");
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    return hr;

}


STDMETHODIMP
CCertAdminD::SetOfficerRights(
    IN wchar_t const *pwszAuthority,
    IN BOOL fEnable,
    IN CERTTRANSBLOB *pctbSD)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pNewOfficerSD = (PSECURITY_DESCRIPTOR) pctbSD->pb;
    PSECURITY_DESCRIPTOR pCASD = NULL;
    LPWSTR pwszSD = NULL;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETOFFICERRIGHTS, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetOfficerRights(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    if (!g_fAdvancedServer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
	_JumpError(hr, error, "g_fAdvancedServer");
    }
    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {

    hr = audit.AddData(fEnable?true:false); // %1 Enable restrictions?
    _LeaveIfError(hr, "CAuditEvent::AddData");

    if(fEnable)
    {
        hr = audit.AddData(pctbSD->pb, pctbSD->cb); // %2 new permissions; add as 
                                                    // blob, we don't convert to string
                                                    // unless access check passes
        _LeaveIfError(hr, "CAuditEvent::AddData");
    }
    else
    {
        hr = audit.AddData(L"");    // %2 no permissions if disabling 
                                    // the officer restrictions
        _LeaveIfError(hr, "CAuditEvent::AddData");
    }

    hr = audit.AccessCheck(
            CA_ACCESS_ADMIN,
            audit.m_gcNoAuditSuccess);
    _LeaveIfError(hr, "CAuditEvent::AccessCheck");

	g_OfficerRightsSD.SetEnable(fEnable);

	// ignore new security descriptor if asked to turn officer rights off

	if (fEnable)
	{
	    hr = g_CASD.LockGet(&pCASD); // no free
	    _LeaveIfError(hr, "CProtectedSecurityDescriptor::LockGet");

	    // adjust new officer rights based on the CA SD and set the
	    // officer rights SD to the new SD

	    hr = g_OfficerRightsSD.Merge(pNewOfficerSD, pCASD);
	    _LeaveIfError(hr, "COfficerRightsSD::Merge");

	    hr = g_CASD.Unlock();
	    _LeaveIfError(hr, "CProtectedSecurityDescriptor::Unlock");
	}

	// persistent save to registry

	hr = g_OfficerRightsSD.Save();
	_LeaveIfError(hr, "CProtectedSecurityDescriptor::Save");

    if(fEnable)
    {
        hr = COfficerRightsSD::ConvertToString(pNewOfficerSD, pwszSD);
        _LeaveIfError(hr, "COfficerRightsSD::ConvertToString");
        audit.DeleteLastData(); // remove permissions blob
        hr = audit.AddData(pwszSD); // %2 add human-friend permissions string
        _LeaveIfError(hr, "CAuditEvent::AddData");
    }

    hr = audit.CachedGenerateAudit();
    _LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    LOCAL_FREE(pwszSD);
    CertSrvExitServer(State, hr);
    return hr;
}


STDMETHODIMP
CCertAdminD::GetConfigEntry(
    wchar_t const *pwszAuthority,
    wchar_t const *pwszNodePath,
    wchar_t const *pwszEntry,
    VARIANT *pVariant)
{
    HRESULT hr;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::GetConfigEntry(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); // allow empty/null name
    _JumpIfError(hr, error, "CheckAuthorityName");

    __try
    {
	hr = audit.AccessCheck(
			CA_ACCESS_ALLREADROLES,
			audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = g_ConfigStorage.GetEntry(
			EmptyString(pwszAuthority)?
			    NULL : g_wszSanitizedName, // allow empty/null name
			pwszNodePath,
			pwszEntry,
			pVariant);
	_LeaveIfError2(
		hr,
		"CConfigStorage::GetConfigEntry",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

	myRegisterMemFree(pVariant, CSM_VARIANT);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    return hr;
}


STDMETHODIMP
CCertAdminD::SetConfigEntry(
    wchar_t const *pwszAuthority,
    wchar_t const *pwszNodePath,
    wchar_t const *pwszEntry,
    VARIANT *pVariant)
{
    HRESULT hr;
    CAuditEvent audit(SE_AUDITID_CERTSRV_SETCONFIGENTRY, g_dwAuditFilter);
    DWORD State = 0;

    DBGPRINT((
	s_ssAdmin,
	"CCertAdminD::SetConfigEntry(tid=%d, this=%x)\n",
	GetCurrentThreadId(),
	this));

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority, true); // allow empty/null name
    _JumpIfError(hr, error, "CheckAuthorityName");

    hr = audit.AddData(pwszNodePath); // %1 node
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(pwszEntry); // %2 entry
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(L""); // %3 empty data, we don't process the variant
                             // unless the access check passes
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    __try
    {
	hr = audit.AccessCheck(
		CA_ACCESS_ADMIN,
		audit.m_gcNoAuditSuccess);
	_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	hr = g_ConfigStorage.SetEntry(
		    EmptyString(pwszAuthority)?
			NULL : g_wszSanitizedName, // allow empty/null name
		    pwszNodePath,
		    pwszEntry,
		    pVariant);
	_LeaveIfError(hr, "CConfigStorage::SetConfigEntry");

	// postpone adding the actual data to allow set entry to validate it
	
	audit.DeleteLastData();
	hr = audit.AddData(
		    pVariant, // %3 value
		    true); // true means convert % chars found in strings to %% (bug# 326248)
	_LeaveIfError(hr, "CAuditEvent::AddData");

	hr = audit.CachedGenerateAudit();
	_LeaveIfError(hr, "CAuditEvent::CachedGenerateAudit");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    return hr;
}


STDMETHODIMP
CCertAdminD::GetMyRoles(
    IN wchar_t const *pwszAuthority,
    OUT LONG         *pdwRoles)
{
    HRESULT hr;
    CAuditEvent audit(0, g_dwAuditFilter);
    DWORD dwRoles = 0;
    DWORD State = 0;

    *pdwRoles = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
        hr = audit.GetMyRoles(&dwRoles);
        _LeaveIfError(hr, "CAuditEvent::GetMyRoles");

        *pdwRoles = dwRoles;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    return(hr);
}


HRESULT
adminDeleteRow(
    IN DWORD dwRowId,
    IN DWORD dwPropTable)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    BOOL fCommitted = FALSE;

    hr = g_pCertDB->OpenRow(
			PROPOPEN_DELETE | dwPropTable,
			dwRowId,
			NULL,
			&prow);
    _JumpIfError2(hr, error, "OpenRow", CERTSRV_E_PROPERTY_EMPTY);

    hr = prow->Delete();
    _JumpIfError(hr, error, "Delete");

    hr = prow->CommitTransaction(TRUE);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    return(hr);
}


HRESULT
adminDeleteByRowId(
    IN DWORD dwRowId,
    IN DWORD dwPropTable,
    OUT LONG *pcDeleted)
{
    HRESULT hr;
    LONG cDeleted = 0;
    LONG cDeletedExt = 0;
    LONG cDeletedAttr = 0;

    *pcDeleted = 0;

    if (PROPTABLE_REQCERT == dwPropTable)
    {
	hr = adminDeleteByRowId(dwRowId, PROPTABLE_EXTENSION, &cDeletedExt);
	_JumpIfError(hr, error, "adminDeleteByRowId(ext)");

	DBGPRINT((
	    s_ssAdmin,
	    "adminDeleteByRowId(Rowid=%u) deleted %u extension rows\n",
	    dwRowId,
	    cDeletedExt));

	hr = adminDeleteByRowId(dwRowId, PROPTABLE_ATTRIBUTE, &cDeletedAttr);
	_JumpIfError(hr, error, "adminDeleteByRowId(attrib)");

	DBGPRINT((
	    s_ssAdmin,
	    "adminDeleteByRowId(Rowid=%u) deleted %u attribute rows\n",
	    dwRowId,
	    cDeletedAttr));
    }
    for (;;)
    {
	hr = adminDeleteRow(dwRowId, dwPropTable);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "adminDeleteByRowId");

	cDeleted++;
    }
    if (0 == cDeleted && 0 != (cDeletedExt + cDeletedAttr))
    {
	cDeleted++;
    }
    hr = S_OK;

error:
    *pcDeleted += cDeleted;
    return(hr);
}


#define ICOLDEL_DATE		0
#define ICOLDEL_DISPOSITION	1

HRESULT
adminDeleteRowsFromQuery(
    IN DWORD dwPropTable,
    IN DWORD DateColumn,
    IN DWORD DispositionColumn,
    IN BOOL fRequest,
    IN FILETIME const *pft,
    OUT LONG *pcDeleted)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[1];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD celtFetched;
    DWORD i;
    BOOL fEnd;
    CERTDBRESULTROW aResult[10];
    BOOL fResultActive = FALSE;
    DWORD acol[2];
    DWORD ccol;
    DWORD cDeleted = 0;

    *pcDeleted = 0;

    // Set up restrictions as follows:

    pcvr = acvr;

    // DateColumn < *pft

    pcvr->ColumnIndex = DateColumn;
    pcvr->SeekOperator = CVR_SEEK_LT;
    pcvr->SortOrder = CVR_SORT_ASCEND;
    pcvr->pbValue = (BYTE *) pft;
    pcvr->cbValue = sizeof(*pft);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    ccol = 0;
    acol[ccol++] = DateColumn;
    if (0 != DispositionColumn)
    {
	acol[ccol++] = DispositionColumn;
    }

    celtFetched = 0;
    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			ccol,
			acol,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    fEnd = FALSE;
    while (!fEnd)
    {
	hr = pView->Next(NULL, ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    fEnd = TRUE;
	    if (0 == celtFetched)
	    {
		break;
	    }
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "Next");

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) >= celtFetched);

	for (i = 0; i < celtFetched; i++)
	{
	    BOOL fDelete = TRUE;
	
	    CERTDBRESULTROW *pResult = &aResult[i];

	    CSASSERT(ccol == pResult->ccol);

	    if (0 != DispositionColumn)
	    {
		DWORD Disposition;

		CSASSERT(NULL != pResult->acol[ICOLDEL_DISPOSITION].pbValue);
		CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLDEL_DISPOSITION].Type));
		CSASSERT(sizeof(Disposition) == pResult->acol[ICOLDEL_DISPOSITION].cbValue);
		Disposition = *(DWORD *) pResult->acol[ICOLDEL_DISPOSITION].pbValue;

		if (fRequest)
		{
		    // Delete only pending and failed requests

		    if (DB_DISP_PENDING != Disposition &&
			DB_DISP_LOG_FAILED_MIN > Disposition)
		    {
			fDelete = FALSE;
		    }
		}
		else
		{
		    // Delete only issued and revoked certs

		    if (DB_DISP_LOG_MIN > Disposition ||
			DB_DISP_LOG_FAILED_MIN <= Disposition)
		    {
			fDelete = FALSE;
		    }
		}
	    }

	    CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLDEL_DATE].Type));

	    // If the date column is missing, delete the row.

#ifdef DBG_CERTSRV_DEBUG_PRINT
	    if (NULL != pResult->acol[ICOLDEL_DATE].pbValue &&
		sizeof(FILETIME) == pResult->acol[ICOLDEL_DATE].cbValue)
	    {
		WCHAR *pwszTime = NULL;

		myGMTFileTimeToWszLocalTime(
			    (FILETIME *) pResult->acol[ICOLDEL_DATE].pbValue,
			    TRUE,
			    &pwszTime);

		DBGPRINT((
		    s_ssAdmin,
		    "adminDeleteRowsFromQuery(%ws)\n",
		    pwszTime));
		if (NULL != pwszTime)
		{
		    LocalFree(pwszTime);
		}
	    }
#endif // DBG_CERTSRV_DEBUG_PRINT

	    if (fDelete)
	    {
		LONG cDelT;
		
		hr = adminDeleteByRowId(pResult->rowid, dwPropTable, &cDelT);
		_JumpIfError(hr, error, "adminDeleteByRowId");

		DBGPRINT((
		    s_ssAdmin,
		    "adminDeleteByRowId(Rowid=%u) deleted %u Query rows\n",
		    pResult->rowid,
		    cDelT));

		cDeleted += cDelT;
	    }
	}
	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }
    hr = S_OK;

error:
    *pcDeleted = cDeleted;
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    return(hr);
}
#undef ICOLDEL_DATE
#undef ICOLDEL_DISPOSITION


STDMETHODIMP
CCertAdminD::DeleteRow(
    IN wchar_t const *pwszAuthority,
    IN DWORD          dwFlags,		// CDR_*
    IN FILETIME       FileTime,
    IN DWORD          dwTable,		// CVRC_TABLE_*
    IN DWORD          dwRowId,
    OUT LONG         *pcDeleted)
{
    HRESULT hr;
    DWORD dwPropTable;
    CAuditEvent audit(SE_AUDITID_CERTSRV_DELETEROW, g_dwAuditFilter);
    DWORD DateColumn;
    DWORD DispositionColumn;
    BOOL fRequest;
    DWORD State = 0;

    *pcDeleted = 0;

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    hr = CheckAuthorityName(pwszAuthority);
    _JumpIfError(hr, error, "No authority name");

    __try
    {
	hr = audit.AddData(dwTable); // %1 table ID
	_JumpIfError(hr, error, "CAuditEvent::AddData");

	if (0 == dwRowId)
	{
	    hr = audit.AddData(FileTime); // %2 filter (time)
	    _JumpIfError(hr, error, "CAuditEvent::AddData");
	    
	    hr = audit.AddData((DWORD)0); // %3 rows deleted
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    // bulk deletion -- must be both officer and CA admin, ie
        // can't do on high assurance mode w/ role separation
        // enabled
	    
	    hr = audit.AccessCheck(
		    CA_ACCESS_ADMIN,
		    audit.m_gcNoAuditSuccess);
		_LeaveIfError(hr, "CAuditEvent::AccessCheck");

	    hr = audit.AccessCheck(
	        CA_ACCESS_OFFICER,
	        audit.m_gcNoAuditSuccess);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}
	else
	{
	    hr = audit.AddData(dwRowId); // %2 filter (request ID)
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    hr = audit.AddData((DWORD)0); // %3 rows deleted
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    // individual deletion -- CA admin suffices

	    hr = audit.AccessCheck(
		CA_ACCESS_ADMIN,
		audit.m_gcNoAuditSuccess);
	    _LeaveIfError(hr, "CAuditEvent::AccessCheck");
	}

	hr = E_INVALIDARG;
	if ((0 == FileTime.dwLowDateTime && 0 == FileTime.dwHighDateTime) ^
	    (0 != dwRowId))
	{
	    _LeaveError(hr, "row OR date required");
	}
	DateColumn = 0;
	DispositionColumn = 0;
	fRequest = FALSE;
	switch (dwTable)
	{
	    case CVRC_TABLE_REQCERT:
		dwPropTable = PROPTABLE_REQCERT;
		switch (dwFlags)
		{
		    case CDR_EXPIRED:
			DateColumn = DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE;
			DispositionColumn = DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION;
			break;

		    case CDR_REQUEST_LAST_CHANGED:
			DateColumn = DTI_REQUESTTABLE | DTR_REQUESTRESOLVEDWHEN;
			DispositionColumn = DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION;
			fRequest = TRUE;
			break;

		    case 0:
			break;

		    default:
			_LeaveError(hr, "dwFlags");
			break;
		}
		break;

	    case CVRC_TABLE_EXTENSIONS:
		if (0 == dwRowId)
		{
		    _LeaveError(hr, "no date field in Extension table");
		}
		if (0 != dwFlags)
		{
		    _LeaveError(hr, "dwFlags");
		}
		dwPropTable = PROPTABLE_EXTENSION;
		break;

	    case CVRC_TABLE_ATTRIBUTES:
		if (0 == dwRowId)
		{
		    _LeaveError(hr, "no date field in Request Attribute table");
		}
		if (0 != dwFlags)
		{
		    _LeaveError(hr, "dwFlags");
		}
		dwPropTable = PROPTABLE_ATTRIBUTE;
		break;

	    case CVRC_TABLE_CRL:
		dwPropTable = PROPTABLE_CRL;
		switch (dwFlags)
		{
		    case CDR_EXPIRED:
			DateColumn = DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE;
			break;

		    case 0:
			break;

		    default:
			_LeaveError(hr, "dwFlags");
			break;
		}
		DateColumn = DTI_CRLTABLE | DTL_NEXTUPDATEDATE;
		break;

	    default:
		_LeaveError(hr, "dwTable");
	}
	if (0 != dwRowId)
	{
	    hr = adminDeleteByRowId(dwRowId, dwPropTable, pcDeleted);
	    _LeaveIfError(hr, "adminDeleteByRowId");

	    DBGPRINT((
		s_ssAdmin,
		"adminDeleteByRowId(Rowid=%u) deleted %u rows\n",
		dwRowId,
		*pcDeleted));
	}
	else
	{
	    CSASSERT(0 != DateColumn);

	    hr = adminDeleteRowsFromQuery(
				    dwPropTable,
				    DateColumn,
				    DispositionColumn,
				    fRequest,
				    &FileTime,
				    pcDeleted);
	    _LeaveIfError(hr, "adminDeleteRowsFromQuery");
	}

	audit.DeleteLastData();
	hr = audit.AddData((DWORD)*pcDeleted); // %3 rows deleted
	_JumpIfError(hr, error, "CAuditEvent::AddData");

	hr = audit.CachedGenerateAudit();
	_JumpIfError(hr, error, "CAuditEvent::CachedGenerateAudit");

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    CertSrvExitServer(State, hr);
    return(hr);
}
#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certreq\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_USAGE_DESCRIPTION),
    RESSTR(IDS_CERT_FILE_FILTER),
    RESSTR(IDS_FORMATSTR_CERTRETRIEVED),
    RESSTR(IDS_REQUEST_OUTFILE_TITLE),
    RESSTR(IDS_REQUEST_CERT_ERROR),
    RESSTR(IDS_APP_NAME),
    RESSTR(IDS_WINDOW_NAME),
    RESSTR(IDS_ERROR_NO_REQUESTID),
    RESSTR(IDS_USAGE_GENERAL),
    RESSTR(IDS_ERROR_STRCONVERSION),
    RESSTR(IDS_DISPOSITION_INCOMPLETE),
    RESSTR(IDS_DISPOSITION_ERROR),
    RESSTR(IDS_DISPOSITION_DENIED),
    RESSTR(IDS_DISPOSITION_ISSUED),
    RESSTR(IDS_DISPOSITION_ISSUED_OOB),
    RESSTR(IDS_DISPOSITION_UNDER_SUBMISSION),
    RESSTR(IDS_DISPOSITION_REVOKED),
    RESSTR(IDS_DISPOSITION_UNKNOWN),
    RESSTR(IDS_FORMATSTR_CERTNOTISSUED),
    RESSTR(IDS_FORMATSTR_CERTPENDING),
    RESSTR(IDS_CERTREQ_TITLE),
    RESSTR(IDS_FORMATSTR_DECODE_ERR),
    RESSTR(IDS_FORMATSTR_ERRCONFIG),
    RESSTR(IDS_USAGE_OPTIONS_DESCRIPTION),
    RESSTR(IDS_ERROR_NO_FILENAME),
    RESSTR(IDS_NOMORE_CAS),
    RESSTR(IDS_GETERACERT_TITLE),
    RESSTR(IDS_GETERACERT_SUBTITLE),
    RESSTR(IDS_INF_OPEN_TITLE),
    RESSTR(IDS_INF_FILE_FILTER),
    RESSTR(IDS_INF_FILE_DEFEXT),
    RESSTR(IDS_OVERWRITE_FILE),
    RESSTR(IDS_RESPONSE_FILE_FILTER),
    RESSTR(IDS_RESPONSE_FILE_DEFEXT),
    RESSTR(IDS_CERT_OUTFILE_TITLE),
    RESSTR(IDS_FORMATSTR_REQUESTID),
    RESSTR(IDS_GETRENEWALCERT_TITLE),
    RESSTR(IDS_GETRENEWALCERT_SUBTITLE),
    RESSTR(IDS_GETSIGNINGCERT_TITLE),
    RESSTR(IDS_GETSIGNINGCERT_SUBTITLE),
    RESSTR(IDS_USAGE_VERB_DEFAULT),
    RESSTR(IDS_USAGE_OPTIONS_DEFAULT),
    RESSTR(IDS_USAGE_VERB_RETRIEVE),
    RESSTR(IDS_USAGE_OPTIONS_RETRIEVE),
    RESSTR(IDS_USAGE_VERB_POLICY),
    RESSTR(IDS_USAGE_OPTIONS_POLICY),
    RESSTR(IDS_USAGE_VERB_SIGN),
    RESSTR(IDS_USAGE_OPTIONS_SIGN),
    RESSTR(IDS_USAGE_VERB_NEW),
    RESSTR(IDS_USAGE_OPTIONS_NEW),
    RESSTR(IDS_USAGE_VERB_ACCEPT),
    RESSTR(IDS_USAGE_OPTIONS_ACCEPT),
    RESSTR(IDS_USAGE_OPTION_ANY),
    RESSTR(IDS_USAGE_OPTION_ATTRIB),
    RESSTR(IDS_USAGE_OPTION_BINARY),
    RESSTR(IDS_USAGE_OPTION_CERT),
    RESSTR(IDS_USAGE_OPTION_CONFIG),
    RESSTR(IDS_USAGE_OPTION_CRL),
    RESSTR(IDS_USAGE_OPTION_F),
    RESSTR(IDS_USAGE_OPTION_Q),
    RESSTR(IDS_USAGE_OPTION_RPC),
    RESSTR(IDS_USAGE_OPTION_VERBOSE),
    RESSTR(IDS_USAGE_OPTION_QUESTION),
    RESSTR(IDS_USAGE_OPTION_V1),
    RESSTR(IDS_USAGE_OPTION_IDISPATCH),
    RESSTR(IDS_CRITICAL),
    RESSTR(IDS_NON_CRITICAL),
    RESSTR(IDS_RESPONSE_OUTFILE_TITLE),
    RESSTR(IDS_CERT_FILE_DEFEXT),
    RESSTR(IDS_UNREFERENCED_INF_SECTIONS),
    RESSTR(IDS_CERTTYPE_USER),
    RESSTR(IDS_CERTTYPE_USER_AS),
    RESSTR(IDS_CERTTYPE_USER_SMARTCARD_LOGON),
    RESSTR(IDS_CERTTYPE_EFS),
    RESSTR(IDS_CERTTYPE_ADMIN),
    RESSTR(IDS_CERTTYPE_EFS_RECOVERY),
    RESSTR(IDS_CERTTYPE_CODE_SIGNING),
    RESSTR(IDS_CERTTYPE_CTL_SIGNING),
    RESSTR(IDS_CERTTYPE_MACHINE),
    RESSTR(IDS_CERTTYPE_DC),
    RESSTR(IDS_CERTTYPE_WEBSERVER),
    RESSTR(IDS_CERTTYPE_KDC),
    RESSTR(IDS_CERTTYPE_ROOT_CA),
    RESSTR(IDS_CERTTYPE_SUBORDINATE_CA),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT),
    RESSTR(IDS_CERTTYPE_SMARTCARD_USER),
    RESSTR(IDS_CERTTYPE_USER_SIGNATURE),
    RESSTR(IDS_ILOG_BAD_NUMERICFIELD),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_COUNT),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING),
    RESSTR(IDS_CERTTYPE_ROUTER_OFFLINE),
    RESSTR(IDS_REQUEST_FILE_DEFEXT),
    RESSTR(IDS_REQUEST_OPEN_TITLE),
    RESSTR(IDS_REQUEST_FILE_FILTER),
    RESSTR(IDS_WRN_COMPUTERNAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_NOT_MATCH),
    RESSTR(IDS_WRN_PINGCA_FAIL),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE),
    RESSTR(IDS_WRN_CALIST_EMPTY),
    RESSTR(IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT),
    RESSTR(IDS_REQUEST_SAVE_TITLE),
    RESSTR(IDS_CERTTYPE_CEP_ENCRYPTION),
    RESSTR(IDS_ILOG_CAPOLICY_BUILD),
    RESSTR(IDS_ILOG_CAPOLICY_ELEMENT),
    RESSTR(IDS_ILOG_CAPOLICY_EXTENSION),
    RESSTR(IDS_ILOG_CAPOLICY_NOKEY),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN_FAILED),
    RESSTR(IDS_ILOG_BEGIN),
    RESSTR(IDS_ILOG_END),
    RESSTR(IDS_ACTRL_CAADMIN),
    RESSTR(IDS_ACTRL_OFFICER),
    RESSTR(IDS_ACTRL_AUDITOR),
    RESSTR(IDS_ACTRL_OPERATOR),
    RESSTR(IDS_ACTRL_CAREAD),
    RESSTR(IDS_ACTRL_ENROLL),
    RESSTR(IDS_ILOG_CAPOLICY_CLOSE),
    RESSTR(IDS_ILOG_MESSAGEBOX),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND),
    RESSTR(IDS_CERTTYPE_KEY_RECOVERY_AGENT),
    RESSTR(IDS_CERTTYPE_CA_EXCHANGE),
    RESSTR(IDS_EMPTY_FRIENDLY_NAME),
    RESSTR(IDS_CERTTYPE_CROSS_CA),
    RESSTR(IDS_CERTTYPE_DC_AUTH),
    RESSTR(IDS_CERTTYPE_DS_EMAIL_REPLICATION),
    RESSTR(IDS_WARN_ENTERPRISE_REQUIREMENTS),
    RESSTR(IDS_WRN_OLD_CA),
    RESSTR(IDS_ILOG_BAD_BOOLEAN),
    RESSTR(IDS_CERTTYPE_WORKSTATION),
    RESSTR(IDS_CERTTYPE_RASIASSERVER),
    RESSTR(IDS_LOW_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_MEDIUM_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_HIGH_ASSURANCE_DISPLAY_NAME),
    RESSTR(IDS_KRA_DESCRIPTION),
    RESSTR(IDS_EMAIL_REPLICATION_DESCRIPTION),
    RESSTR(IDS_CROSS_CA_DESCRIPTION),
    RESSTR(IDS_CA_DESCRIPTION),
    RESSTR(IDS_MACHINE_DESCRIPTION),
    RESSTR(IDS_END_USER_DESCRIPTION),
    RESSTR(IDS_UNKNOWN_DESCRIPTION),
    RESSTR(IDS_STORENAME_DS_KRA),
    RESSTR(IDS_STORENAME_DS_AIA),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\cienum.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cienum.cpp
//
// Contents:    Extension and Attribute enumerator
//
// History:     12-Mar-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTSRV_CIENUM_CPP__


HRESULT
CIENUM::EnumSetup(
    IN DWORD RequestId,
    IN LONG Context,
    IN DWORD Flags)
{
    HRESULT hr;

    EnumClose();

    ICertDBRow *prow = NULL;

    hr = g_pCertDB->OpenRow(PROPOPEN_READONLY | PROPTABLE_REQCERT, RequestId, NULL, &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = prow->EnumCertDBName(~CIE_CALLER_MASK & Flags, &m_penum);
    _JumpIfError(hr, error, "EnumCertDBName");

    m_Context = Context;
    m_Flags = Flags;

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


HRESULT
CIENUM::EnumNext(OUT BSTR *pstrPropertyName)
{
    HRESULT hr = E_UNEXPECTED;
    CERTDBNAME cdbn;

    cdbn.pwszName = NULL;

    if (NULL == pstrPropertyName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrPropertyName NULL");
    }
    if (NULL != *pstrPropertyName)
    {
	SysFreeString(*pstrPropertyName);
	*pstrPropertyName = NULL;
    }
    if (NULL != m_penum)
    {
	ULONG celtFetched;

	hr = m_penum->Next(1, &cdbn, &celtFetched);
	_JumpIfError2(hr, error, "Next", S_FALSE);

	CSASSERT(1 == celtFetched);
	CSASSERT(NULL != cdbn.pwszName);

	if (!ConvertWszToBstr(pstrPropertyName, cdbn.pwszName, -1))
	{
	    hr = E_OUTOFMEMORY;
	    goto error;
	}
    }
error:
    if (NULL != cdbn.pwszName)
    {
	CoTaskMemFree(cdbn.pwszName);
    }
    return(hr);
}


HRESULT
CIENUM::EnumClose()
{
    if (NULL != m_penum)
    {
        m_penum->Release();
	m_penum = NULL;
    }
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\certsrv.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certsrv.cpp
//
// Contents:    Cert Server main & debug support
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <locale.h>
#include <io.h>
#include <fcntl.h>
#include <safeboot.h>
#include <authzi.h>
#include <common.ver>

#include "elog.h"
#include "certlog.h"
#include "certsrvd.h"
#include "resource.h"
#include "csresstr.h"

#define __dwFILE__	__dwFILE_CERTSRV_CERTSRV_CPP__

HKEY g_hkeyCABase = 0;


BOOL g_fCreateDB = FALSE;
BOOL g_fStartAsService = TRUE;
BOOL g_fStarted;
BOOL g_fStartInProgress;
DWORD g_ServiceThreadId;
HWND g_hwndMain;
WCHAR g_wszAppName[] = L"CertSrv";
HINSTANCE g_hInstApp;
DWORD g_dwDelay0;
DWORD g_dwDelay1;
DWORD g_dwDelay2;
DWORD g_CryptSilent = 0;

HANDLE g_hServiceThread = NULL;
HANDLE g_hShutdownEvent = NULL;

CRITICAL_SECTION g_ShutdownCriticalSection;
BOOL g_fShutdownCritSec = FALSE;

BOOL g_fRefuseIncoming = FALSE;
LONG g_cCalls = 0;
LONG g_cCallsActive = 0;
LONG g_cCallsActiveMax = 0;
BOOL g_fAdvancedServer = FALSE;

CAVIEW *g_pCAViewList = NULL;
DWORD g_cCAView = 0;
BOOL g_fCAViewForceCleanup = FALSE;

CAutoLPWSTR g_pwszDBFileHash;

SERVICE_TABLE_ENTRY steDispatchTable[] =
{
    { const_cast<WCHAR *>(g_wszCertSrvServiceName), ServiceMain },
    { NULL, NULL }
};


WCHAR const g_wszRegKeyClassesCLSID[] = L"SOFTWARE\\Classes\\CLSID";
WCHAR const g_wszRegKeyInprocServer32[] = L"InprocServer32";
WCHAR const g_wszRegValueThreadingModel[] = L"ThreadingModel";
WCHAR const g_wszRegKeyAppId[] = L"SOFTWARE\\Classes\\AppId";
WCHAR const g_wszRegRunAs[] = L"RunAs";
WCHAR const g_wszRegValueInteractiveUser[] = L"Interactive User";
WCHAR const g_wszRegLocalService[] = L"LocalService";

// do not change the order, add new audit resources at the end
//    g_pwszAllow,
//    g_pwszDeny,
//    g_pwszCAAdmin,
//    g_pwszOfficer,
//    g_pwszRead,
//    g_pwszEnroll,

LPCWSTR g_pwszAuditResources[6];

using namespace CertSrv;


HRESULT
OpenRegistryComKey(
    IN HKEY hKeyParent,
    IN CLSID const *pclsid,
    IN BOOL fWrite,
    OUT HKEY *phKey)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;

    *phKey = NULL;
    hr = StringFromCLSID(*pclsid, &pwsz);
    _JumpIfError(hr, error, "StringFromCLSID");

    hr = RegOpenKeyEx(
		hKeyParent,
		pwsz,
		0,
		fWrite? KEY_ALL_ACCESS : KEY_READ,
		phKey);
    _JumpIfError(hr, error, "RegOpenKeyEx");

error:
    if (NULL != pwsz)
    {
	CoTaskMemFree(pwsz);
    }
    return(hr);
}


BOOL
IsMissingRegistryValue(
    IN HKEY hKey,
    IN WCHAR const *pwszRegValueName)
{
    HRESULT hr;
    DWORD dwLen;
    DWORD dwType;

    hr = RegQueryValueEx(hKey, pwszRegValueName, NULL, &dwType, NULL, &dwLen);
    if (S_OK != hr)
    {
	hr = myHError(hr);
    }
    _JumpIfError2(
	    hr,
	    error,
	    "RegQueryValueEx",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

error:
    return(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
}


BOOL
IsMatchingRegistryValue(
    IN HKEY hKey,
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszRegValueString)
{
    HRESULT hr;
    DWORD dwLen;
    DWORD dwType;
    BOOL fMatch = FALSE;
    WCHAR buf[MAX_PATH];

    dwLen = sizeof(buf);
    hr = RegQueryValueEx(
		    hKey,
		    pwszRegValueName,
		    NULL,
		    &dwType,
		    (BYTE *) buf,
		    &dwLen);
    _JumpIfErrorStr(hr, error, "RegQueryValueEx", pwszRegValueName);

    if (REG_SZ == dwType && 0 == mylstrcmpiL(buf, pwszRegValueString))
    {
	fMatch = TRUE;
    }

error:
    return(fMatch);
}


HRESULT
SetRegistryStringValue(
    IN HKEY hKey,
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszRegValueString)
{
    HRESULT hr;

    hr = RegSetValueEx(
		    hKey,
		    pwszRegValueName,
		    0,
		    REG_SZ,
		    (const BYTE *) pwszRegValueString,
		    (wcslen(pwszRegValueString) + 1) * sizeof(WCHAR));
    return(hr);
}


HRESULT
CertSrvSetRegistryFileTimeValue(
    IN BOOL fConfigLevel,
    IN WCHAR const *pwszRegValueName,
    IN DWORD cpwszDelete,
    OPTIONAL IN WCHAR const * const *papwszRegValueNameDelete)
{
    HRESULT hr;
    HKEY hKey = NULL;
    HKEY hKey1 = NULL;
    FILETIME ftCurrent;
    DWORD i;

    GetSystemTimeAsFileTime(&ftCurrent);

    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    wszREGKEYCONFIGPATH,
		    0,
		    KEY_ALL_ACCESS,
		    &hKey);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    if (!fConfigLevel)
    {
	hKey1 = hKey;
	hKey = NULL;
	hr = RegOpenKeyEx(
			hKey1,
			g_wszSanitizedName,
			0,
			KEY_ALL_ACCESS,
			&hKey);
	_JumpIfError(hr, error, "RegOpenKeyEx");
    }

    hr = RegSetValueEx(
		    hKey,
		    pwszRegValueName,
		    0,
		    REG_BINARY,
		    (BYTE const *) &ftCurrent,
		    sizeof(ftCurrent));
    _JumpIfError(hr, error, "RegSetValueEx");

    for (i = 0; i < cpwszDelete; i++)
    {
	hr = RegDeleteValue(hKey, papwszRegValueNameDelete[i]);
	_PrintIfError2(hr, "RegDeleteValue", ERROR_FILE_NOT_FOUND);
    }
    hr = S_OK;

error:
    if (NULL != hKey1)
    {
	RegCloseKey(hKey1);
    }
    if (NULL != hKey)
    {
	RegCloseKey(hKey);
    }
    return(myHError(hr));
}


HRESULT
SetRegistryDcomConfig(
    IN BOOL fConsoleActive)
{
    HRESULT hr;
    HKEY hKeyAppId = NULL;
    HKEY hKeyRequest = NULL;
    DWORD cChanged = 0;

    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    g_wszRegKeyAppId,
		    0,
		    KEY_ALL_ACCESS,
		    &hKeyAppId);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    hr = OpenRegistryComKey(hKeyAppId, &CLSID_CCertRequestD, TRUE, &hKeyRequest);
    _JumpIfError(hr, error, "OpenRegistryComKey");

    if (fConsoleActive)
    {
	// Running in console mode:
	// Delete both LocalService registry values
	// Create both RunAs = InteractiveUser registry values
	
	if (!IsMissingRegistryValue(hKeyRequest, g_wszRegLocalService))
	{
	    cChanged++;
	    hr = RegDeleteValue(hKeyRequest, g_wszRegLocalService);
	    _JumpIfError(hr, error, "RegDeleteValue");
	}

	if (!IsMatchingRegistryValue(
				hKeyRequest,
				g_wszRegRunAs,
				g_wszRegValueInteractiveUser))
	{
	    cChanged++;
	    hr = SetRegistryStringValue(
			    hKeyRequest,
			    g_wszRegRunAs,
			    g_wszRegValueInteractiveUser);
	    _JumpIfError(hr, error, "SetRegistryStringValue");
	}
	if (0 != cChanged)
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"SetRegistryDcomConfig(%u): setting %ws=%ws\n",
		cChanged,
		g_wszRegRunAs,
		g_wszRegValueInteractiveUser));
	}
    }
    else
    {
	// Running as a service:
	// Delete both RunAs registry values
	// Create both LocalService = CertSvc registry values
	
	if (!IsMissingRegistryValue(hKeyRequest, g_wszRegRunAs))
	{
	    cChanged++;
	    hr = RegDeleteValue(hKeyRequest, g_wszRegRunAs);
	    _JumpIfError(hr, error, "RegDeleteValue");
	}

	if (!IsMatchingRegistryValue(
				hKeyRequest,
				g_wszRegLocalService,
				g_wszCertSrvServiceName))
	{
	    cChanged++;
	    hr = SetRegistryStringValue(
			    hKeyRequest,
			    g_wszRegLocalService,
			    g_wszCertSrvServiceName);
	    _JumpIfError(hr, error, "SetRegistryStringValue");
	}
	if (0 != cChanged)
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"SetRegistryDcomConfig(%u): setting %ws=%ws\n",
		cChanged,
		g_wszRegLocalService,
		g_wszCertSrvServiceName));
	}
    }

error:
    if (NULL != hKeyRequest)
    {
	RegCloseKey(hKeyRequest);
    }
    if (NULL != hKeyAppId)
    {
	RegCloseKey(hKeyAppId);
    }
    return(myHError(hr));
}


DWORD
GetRegistryDwordValue(
    IN WCHAR const *pwszRegValueName)
{
    HRESULT hr;
    HKEY hKeyConfig = NULL;
    DWORD dwVal;
    DWORD dwType;
    DWORD dwLen;

    dwVal = 0;

    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    g_wszRegKeyConfigPath,
		    0,
		    KEY_READ,
		    &hKeyConfig);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    dwLen = sizeof(dwVal);
    hr = RegQueryValueEx(
			hKeyConfig,
			pwszRegValueName,
			NULL,
			&dwType,
			(BYTE *) &dwVal,
			&dwLen);

    if (S_OK != hr || REG_DWORD != dwType || sizeof(dwVal) != dwLen)
    {
	dwVal = 0;
	goto error;
    }

error:
    if (NULL != hKeyConfig)
    {
	RegCloseKey(hKeyConfig);
    }
    return(dwVal);
}

HRESULT 
CertSrvResetRegistryWatch(
    IN OUT HANDLE *phRegistryModified)
{
    HRESULT hr;
    
    CSASSERT(NULL != phRegistryModified);

    //////////////////////////////////////
    // Initialization of registry events

    if (NULL == g_hkeyCABase)
    {
        DWORD dwDisposition;
        LPWSTR pszCAPath;
        
        pszCAPath = (LPWSTR) LocalAlloc(
            LMEM_FIXED,
            (WSZARRAYSIZE(wszREGKEYCONFIGPATH_BS) +
            wcslen(g_wszSanitizedName) +
            1) * sizeof(WCHAR));
	if (NULL == pszCAPath)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
        
        wcscpy(pszCAPath, wszREGKEYCONFIGPATH_BS);
        wcscat(pszCAPath, g_wszSanitizedName);
        
        hr = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            pszCAPath,
            0,                  // reserved
            NULL,               // class
            0,                  // options
            KEY_ALL_ACCESS,     // sec desired
            NULL,               // sec attr
            &g_hkeyCABase,      // phk
            &dwDisposition);
        LocalFree(pszCAPath); pszCAPath = NULL;
        _JumpIfError(hr, error, "RegCreateKeyEx base key");
    }
    if (NULL == *phRegistryModified)
    {
        *phRegistryModified = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == *phRegistryModified)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateEvent registry watch");
        }
    }
    else
    {
        // reset registry event
        ResetEvent( *phRegistryModified ); 
    }

    // register our registry lookout trigger
    hr = RegNotifyChangeKeyValue(
            g_hkeyCABase,
            FALSE,
            REG_NOTIFY_CHANGE_LAST_SET,
            *phRegistryModified,
            TRUE);
    _JumpIfError(hr, error, "RegNotifyChangeKeyValue on base key");

error:
    return(myHError(hr));
}


VOID
CertSrvLogOpen()
{
    BOOL fOpenLog;
    static BOOL s_fLogOpened = FALSE;

    DbgPrintfInit("+");		// reinitialize debug print mask first
    fOpenLog = DbgIsSSActive(DBG_SS_OPENLOG);

    if (fOpenLog)
    {
	if (!s_fLogOpened)
	{
	    DbgPrintfInit("+certsrv.log");	// open the log file
	    s_fLogOpened = TRUE;
	    DbgLogFileVersion("certsrv.exe", szCSVER_STR);
	}
    }
    else
    {
	if (s_fLogOpened)
	{
	    DbgPrintfInit("-");			// close the log file
	    s_fLogOpened = FALSE;
	}
    }
}


HRESULT 
CertSrvRegistryModificationEvent(
    IN FILETIME const *pftWait,
    IN OUT DWORD *pdwTimeOut)
{
    HRESULT hr;
    DWORD dwVal;
    BOOL fDisabledNew;
    FILETIME ftCurrent;
    BOOL fSetEvent = FALSE;
    DWORD dwMSTimeOut;

    CertSrvLogOpen();	// open log if registry changed to enable logging

    // see if Base CRL publish enabled state has changed

    hr = myGetCertRegDWValue(
			g_wszSanitizedName,
			NULL,
			NULL,
			wszREGCRLPERIODCOUNT,
			&dwVal);
    if (S_OK == hr)
    {
	fDisabledNew = 0 == dwVal;      
	if (fDisabledNew != g_fCRLPublishDisabled)
	{
            fSetEvent = TRUE;
	}
    }

    // see if Delta CRL publish enabled state has changed

    hr = myGetCertRegDWValue(
			g_wszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAPERIODCOUNT,
			&dwVal);
    if (S_OK == hr)
    {
	fDisabledNew = 0 == dwVal;      
	if (fDisabledNew != g_fDeltaCRLPublishDisabled)
	{
            fSetEvent = TRUE;
        }
    }

    GetSystemTimeAsFileTime(&ftCurrent);

    CRLComputeTimeOut(pftWait, &ftCurrent, &dwMSTimeOut);
    if (dwMSTimeOut >= *pdwTimeOut)
    {
	dwMSTimeOut = *pdwTimeOut;
	fSetEvent = TRUE;
    }
    *pdwTimeOut -= dwMSTimeOut;

    if (fSetEvent)
    {
	SetEvent(g_hCRLManualPublishEvent);	// pulse to get up-to-date
    }
    return(hr);
}


#if DBG_CERTSRV
WCHAR const *
certsrvGetCurrentTimeWsz()
{
    HRESULT hr;
    FILETIME ft;
    WCHAR *pwszTime = NULL;
    static WCHAR s_wszTime[128];
    
    GetSystemTimeAsFileTime(&ft);
    hr = myGMTFileTimeToWszLocalTime(&ft, TRUE, &pwszTime);
    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
    s_wszTime[0] = L'\0';
    if (NULL != pwszTime)
    {
	wcsncpy(s_wszTime, pwszTime, ARRAYSIZE(s_wszTime));
	s_wszTime[ARRAYSIZE(s_wszTime) - 1] = L'\0';
	LocalFree(pwszTime);
    }
    return(s_wszTime);
}
#endif


HRESULT
CertSrvBlockThreadUntilStop()
{
    HRESULT hr;
    HANDLE hRegistryModified = NULL;
    DWORD dwTimeOut;

    // check CRL publish, get next timeout interval

    hr = CRLPubWakeupEvent(&dwTimeOut);
    _PrintIfError(hr, "CRLPubWakeupEvent");

    hr = CertSrvResetRegistryWatch(&hRegistryModified);
    _PrintIfError(hr, "CertSrvResetRegistryWatch");

    for (;;)
    {
	FILETIME ftWait;
        DWORD dw;
        HANDLE hmultiObjects[] = {
	    hRegistryModified,
	    g_hServiceStoppingEvent,
	    g_hCRLManualPublishEvent
	};

#if DBG_CERTSRV
	{
	    LLFILETIME llft;
	    WCHAR *pwszTimePeriod = NULL;

	    llft.ll = dwTimeOut;
	    llft.ll *= (CVT_BASE / 1000);	// convert msecs to 100ns
	    llft.ll = -llft.ll;
	    
	    hr = myFileTimePeriodToWszTimePeriod(
				    &llft.ft,
				    TRUE,	// fExact
				    &pwszTimePeriod);
	    _PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");

	    DBGPRINT((
		DBG_SS_CERTSRV,
		"WaitForMultipleObjects(%u ms) %ws @%ws\n",
		dwTimeOut,
		pwszTimePeriod,
		certsrvGetCurrentTimeWsz()));
	    if (NULL != pwszTimePeriod)
	    {
		LocalFree(pwszTimePeriod);
	    }
	}
#endif

	GetSystemTimeAsFileTime(&ftWait);
        dw = WaitForMultipleObjects(
			    ARRAYSIZE(hmultiObjects),
			    hmultiObjects,
			    FALSE,      // any object will cause bailout
			    dwTimeOut);

	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "WaitForMultipleObjects(%u ms)->%x, %ws\n",
	    dwTimeOut,
	    dw,
	    certsrvGetCurrentTimeWsz()));

        if (WAIT_FAILED == dw)
        {
            hr = GetLastError();
            _JumpError(hr, error, "WaitForMultipleObjects worker");
        }

        if (dw == WAIT_TIMEOUT)     // CRL
        {
            hr = CRLPubWakeupEvent(&dwTimeOut);
            _PrintIfError(hr, "Error during CRLPubWakeupEvent");

            DBGPRINT((DBG_SS_CERTSRVI, "CRLPub: TimeOut %u ms\n", dwTimeOut));
        }
        else if (dw == WAIT_OBJECT_0)   // Registry modification
        {
            // In either case, determine if CRL needs to be published

            hr = CertSrvRegistryModificationEvent(&ftWait, &dwTimeOut);
            _PrintIfError(hr, "Error during CertSrvRegistryModificationEvent");

            // in registry case, reset registry trigger

            DBGPRINT((
		DBG_SS_CERTSRVI,
		"CRLPub: Registry change trigger, TimeOut=%u ms\n",
		dwTimeOut));

            hr = CertSrvResetRegistryWatch(&hRegistryModified);
            _PrintIfError(hr, "Error during CertSrvResetRegistryWatch");
        }
        else if (dw == WAIT_OBJECT_0 + 1)
        {
            // found "service done" event

            DBGPRINT((DBG_SS_CERTSRV, "Service is pending stop request\n"));
            break;  // exit wait loop
        }
        else if (dw == WAIT_OBJECT_0 + 2)
        {
            // found "g_hCRLManualPublishEvent" event: recalc timeout

            hr = CRLPubWakeupEvent(&dwTimeOut);
            _PrintIfError(hr, "Error during CRLPubWakeupEvent");

            DBGPRINT((
		DBG_SS_CERTSRVI,
		"CRLPub: Manual publish recalc, TimeOut=%u ms\n",
		dwTimeOut));
        }
        else
        {
            CSASSERT(CSExpr(!"unexpected wait return"));
            hr = E_UNEXPECTED;
            _JumpError(hr, error, "WaitForMultipleObjects");
        }
    }
    hr = S_OK;

error:
    CloseHandle(hRegistryModified);
    return hr;
}

HRESULT certsrvGetCACertAndKeyHash(
    OUT WCHAR **ppwszCertHash,
    OUT WCHAR **ppwszPublicKeyHash)
{
    HRESULT hr;
    WCHAR wszCertHash[CBMAX_CRYPT_HASH_LEN * 3];    // 20 bytes @ 3 WCHARs/byte
    DWORD cbCertHashStr;
    WCHAR wszPublicKeyHash[CBMAX_CRYPT_HASH_LEN * 3];
    DWORD cbPublicKeyHashStr;
    BYTE abCertHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbCertHash;
    CAutoPBYTE autopbPublicKeyHash;
    DWORD cbPublicKeyHash;

    *ppwszCertHash = NULL;
    *ppwszPublicKeyHash = NULL;

    cbCertHash = sizeof(abCertHash);
    if (!CertGetCertificateContextProperty(
        g_pCAContextCurrent->pccCA,
        CERT_SHA1_HASH_PROP_ID,
        abCertHash,
        &cbCertHash))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    cbCertHashStr = sizeof(wszCertHash);
    hr = MultiByteIntegerToWszBuf(
        TRUE,   // byte multiple
        cbCertHash,
        abCertHash,
        &cbCertHashStr,
        wszCertHash);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    hr = myGetPublicKeyHash(
        g_pCAContextCurrent->pccCA->pCertInfo,
        &g_pCAContextCurrent->pccCA->pCertInfo->SubjectPublicKeyInfo,
        &autopbPublicKeyHash,
        &cbPublicKeyHash);
    _JumpIfError(hr, error, "myGetPublicKeyHash");

    cbPublicKeyHashStr = sizeof(wszPublicKeyHash);
    hr = MultiByteIntegerToWszBuf(
        TRUE,   // byte multiple
        cbPublicKeyHash,
        autopbPublicKeyHash,
        &cbPublicKeyHashStr,
        wszPublicKeyHash);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    hr = myDupString(wszCertHash, ppwszCertHash);
    _JumpIfError(hr, error, "myDupString");

    hr = myDupString(wszPublicKeyHash, ppwszPublicKeyHash);
    _JumpIfError(hr, error, "myDupString");

error:
    return hr;
}

		
#define CSECSLEEP	2	// time to sleep each time through the loop
#define CSECSLEEPTOTAL	30	// total time to wait before giving up
#define wsz3QM		L"???"	// audit data collection failure placeholder

HRESULT
CertSrvAuditShutdown(
    IN ULARGE_INTEGER *puliKeyUsageCount,
    IN WCHAR const *pwszCertHash,
    IN WCHAR const *pwszPublicKeyHash)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;
    WCHAR const *pwsz;
    CertSrv::CAuditEvent event(
			    SE_AUDITID_CERTSRV_SERVICESTOP, 
			    g_dwAuditFilter);

    hr = S_OK;
    for (i = 0; i < CSECSLEEPTOTAL / CSECSLEEP; i++)
    {
	g_pwszDBFileHash.Cleanup();
	hr = myComputeMAC(g_wszDatabase, &g_pwszDBFileHash);
	if (S_OK == hr || HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) != hr)
	{
	    break;
	}
	_PrintError(hr, "myComputeMAC");
	Sleep(CSECSLEEP * 1000);
    }
    _PrintIfErrorStr(hr, "myComputeMAC", g_wszDatabase);
    hr2 = hr;		// save first error

    // %1 database hash
    pwsz = g_pwszDBFileHash; // avoid CAutoLPWSTR freeing static wsz3QM string!
    hr = event.AddData(pwsz != NULL? pwsz : wsz3QM);
    g_pwszDBFileHash.Cleanup();
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    // %2 key usage count
    hr = event.AddData(puliKeyUsageCount);
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    // %3 CA cert hash
    hr = event.AddData(NULL != pwszCertHash? pwszCertHash : wsz3QM);
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    // %4 CA public key hash
    hr = event.AddData(NULL != pwszPublicKeyHash? pwszPublicKeyHash : wsz3QM);
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = event.Report();
    _JumpIfError(hr, error, "CAuditEvent::Report");

error:
    if (S_OK != hr2)
    {
	hr = hr2;	// return first error
    }
    return(hr);
}


// returns TRUE if we shutdown correctly

BOOL
CertSrvStopServer(
    IN BOOL fConsoleActive)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    BOOL fShutDown = FALSE;
    ULARGE_INTEGER uliKeyUsageCount;
    CAutoLPWSTR autoszCertHash;
    CAutoLPWSTR autoszPublicKeyHash;

    if (!g_fStartInProgress)		// ignore while starting the server
    {
	fShutDown = TRUE;

        DBGPRINT((
            DBG_SS_CERTSRV,
            "CertSrvStopServer(fConsoleActive=%u, tid=%d)\n",
            fConsoleActive,
            GetCurrentThreadId()));

        SetEvent(g_hServiceStoppingEvent);

        if (g_hkeyCABase)
        {
            RegCloseKey(g_hkeyCABase);
            g_hkeyCABase = NULL;
        }

        hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
        if (S_OK != hr && S_FALSE != hr)
        {
            _JumpError(hr, error, "CoInitializeEx");
        }
        fCoInit = TRUE;

        // don't allow new callers in

	if (0 == (IF_NORPCICERTREQUEST & g_InterfaceFlags))
	{
	    hr = RPCTeardown();
	    _PrintIfError(hr, "RPCTeardown");
	}
        CertStopClassFactories();

        // retrieve private key usage count if auditing enabled

        if (AUDIT_FILTER_STARTSTOP & g_dwAuditFilter)
        {
	    BOOL fSupported;
	    BOOL fEnabled;

            uliKeyUsageCount.QuadPart = 0;
	    hr = myGetSigningKeyUsageCount(
				    g_pCAContextCurrent->hProvCA,
				    &fSupported,
				    &fEnabled,
				    &uliKeyUsageCount);
	    _PrintIfError(hr, "myGetSigningKeyUsageCount");

            hr = certsrvGetCACertAndKeyHash(
				    &autoszCertHash,
				    &autoszPublicKeyHash);
            _PrintIfError(hr, "certsrvGetCACertAndKeyHash");
        }

        CoreTerminate();

        if (g_fStarted)
        {
            if (CERTLOG_TERSE <= g_dwLogLevel)
            {
                LogEventString(
                    EVENTLOG_INFORMATION_TYPE,
                    MSG_I_SERVER_STOPPED,
                    g_wszCommonName);
            }
            CONSOLEPRINT0((
                DBG_SS_CERTSRV,
                "Certification Authority Service Stopped\n"));

            // only perform Hash if the auditing is enabled

            if (AUDIT_FILTER_STARTSTOP & g_dwAuditFilter)
            {
                hr = CertSrvAuditShutdown(
				&uliKeyUsageCount,
				autoszCertHash,
				autoszPublicKeyHash);
		_PrintError(hr, "CertSrvAuditShutdown");
            }
        }
        g_fStarted = FALSE;

        AuthzFreeResourceManager(g_AuthzCertSrvRM);
        g_AuthzCertSrvRM = NULL;
        g_CASD.Uninitialize();
        g_OfficerRightsSD.Uninitialize();

        // set "completely stopped" event
        if (!fConsoleActive)
	{
            SetEvent(g_hServiceStoppedEvent);
	}
    }

error:
    if (fCoInit)
    {
	CoUninitialize();
    }
    return(fShutDown);
}


// Control-C handler

BOOL
StopServer(
    IN DWORD /* dwCtrlType */ )
{
    HRESULT hr;

    // if successful shutdown
    if (SendMessage(g_hwndMain, WM_STOPSERVER, 0, 0))
    {
        if (!PostMessage(g_hwndMain, WM_SYNC_CLOSING_THREADS, S_OK, 0))
	{
	    hr = myHLastError();
	    _PrintError(hr, "PostMessage");
	}
    	SetConsoleCtrlHandler(StopServer, FALSE);
    }
    return(TRUE);
}


VOID
ReleaseOldViews()
{
    if (0 < g_cCAView)
    {
	FILETIME ftTooOld;
	FILETIME ftTooIdle;
	CAVIEW *pCAView;
	CAVIEW **ppCAViewLast;

	GetSystemTimeAsFileTime(&ftTooIdle);
	ftTooOld = ftTooIdle;

	myMakeExprDateTime(
			&ftTooOld,
			-(LONG) g_dwViewAgeMinutes,
			ENUM_PERIOD_MINUTES);
	myMakeExprDateTime(
			&ftTooIdle,
			-(LONG) g_dwViewIdleMinutes,
			ENUM_PERIOD_MINUTES);

	ppCAViewLast = &g_pCAViewList;
	pCAView = g_pCAViewList;
	for (;;)
	{
	    if (NULL == pCAView)
	    {
		break;
	    }
	    //CERTSRVDBGPRINTTIME("ftTooOld", &ftTooOld);
	    //CERTSRVDBGPRINTTIME("ftCreate", &pCAView->ftCreate);
	    //CERTSRVDBGPRINTTIME("ftTooIdle", &ftTooIdle);
	    //CERTSRVDBGPRINTTIME("ftLastAccess", &pCAView->ftLastAccess);
	    if (g_fCAViewForceCleanup ||
		g_fRefuseIncoming ||
		0 < CompareFileTime(&ftTooOld, &pCAView->ftCreate) ||
		0 < CompareFileTime(&ftTooIdle, &pCAView->ftLastAccess))
	    {
		CAVIEW *pCAViewFree;
		
		// Release this view, then Delink and free the list element.

		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "ReleaseOldViews(%u: Force=%u Refuse=%u old=%u idle=%u pv=%p View=%p)\n",
		    g_cCAView,
		    g_fCAViewForceCleanup,
		    g_fRefuseIncoming,
		    0 < CompareFileTime(&ftTooOld, &pCAView->ftCreate),
		    0 < CompareFileTime(&ftTooIdle, &pCAView->ftLastAccess),
		    pCAView->pvSearch,
		    pCAView->pView));

		pCAViewFree = pCAView;
		*ppCAViewLast = pCAView->pCAViewNext;
		pCAView = pCAView->pCAViewNext;

		pCAViewFree->pView->Release();
		LocalFree(pCAViewFree);
		g_cCAView--;
	    }
	    else
	    {
		ppCAViewLast = &pCAView->pCAViewNext;
		pCAView = pCAView->pCAViewNext;
	    }
	}
	g_fCAViewForceCleanup = FALSE;
    }
}


HRESULT
CertSrvEnterServer(
    OUT DWORD *pState)
{
    HRESULT hr;
    BOOL fEntered = FALSE;
    
    *pState = 0;	// Caller need not exit server
    if (!g_fShutdownCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
	_JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ShutdownCriticalSection);
    fEntered = TRUE;

    hr = CertSrvTestServerState();
    _JumpIfError(hr, error, "CertSrvTestServerState");

    g_cCalls++;
    g_cCallsActive++;
    if (g_cCallsActiveMax < g_cCallsActive)
    {
	g_cCallsActiveMax = g_cCallsActive;
    }
    *pState = 1;	// Caller must exit server
    hr = S_OK;

error:
    if (fEntered)
    {
        LeaveCriticalSection(&g_ShutdownCriticalSection);
    }
    return(hr);
}


HRESULT
CertSrvTestServerState()
{
    HRESULT hr;
    
    if (g_fRefuseIncoming)
    {
	hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
	_JumpError(hr, error, "g_fRefuseIncoming");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CertSrvLockServer(
    IN OUT DWORD *pState)
{
    HRESULT hr;
    BOOL fEntered = FALSE;

    // Eliminate this thread from the active thread count
    
    CertSrvExitServer(*pState, S_OK);
    *pState = 0;	// Caller no longer needs to exit server

    if (!g_fShutdownCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ShutdownCriticalSection);
    fEntered = TRUE;

    g_fRefuseIncoming = TRUE;
    ReleaseOldViews();
    hr = DBShutDown(TRUE);
    _PrintIfError(hr, "DBShutDown");
    DBGPRINT((DBG_SS_CERTSRV, "LockServer(thread count = %u)\n", g_cCallsActive));
    while (0 < g_cCallsActive)
    {
	LONG cCalls = g_cCallsActive;

	LeaveCriticalSection(&g_ShutdownCriticalSection);

	// Wait 15 seconds plus 2 seconds for each active call.

        hr = WaitForSingleObject(g_hShutdownEvent, (15 + 2 * cCalls) * 1000);
	EnterCriticalSection(&g_ShutdownCriticalSection);

	_PrintIfError(hr, "WaitForSingleObject");
	if ((HRESULT) WAIT_OBJECT_0 == hr)
	{
	    DBGPRINT((DBG_SS_CERTSRV, "LockServer(last thread exit event)\n"));
	}
	else if ((HRESULT) WAIT_TIMEOUT == hr)
	{
	    DBGPRINT((DBG_SS_CERTSRV, "LockServer(timeout)\n"));
	    if (cCalls <= g_cCallsActive)
	    {
		break;	// no reduction in active threads -- abort anyway
	    }
        }
	else if ((HRESULT) WAIT_ABANDONED == hr)
	{
	    DBGPRINT((DBG_SS_CERTSRV, "LockServer(wait abandoned)\n"));
        }
	DBGPRINT((DBG_SS_CERTSRV, "LockServer(thread count = %u)\n", g_cCallsActive));
    }
    DBGPRINT((DBG_SS_CERTSRV, "LockServer(done: thread count = %u)\n", g_cCallsActive));
    hr = S_OK;

error:
    if (fEntered)
    {
        LeaveCriticalSection(&g_ShutdownCriticalSection);
    }
    return(hr);
}


VOID
CertSrvExitServer(
    IN DWORD State,
    IN HRESULT hrExit)
{
    HRESULT hr;
    BOOL fEntered = FALSE;

    if (S_OK != hrExit && g_hrJetVersionStoreOutOfMemory == hrExit)
    {
	g_fCAViewForceCleanup = TRUE;
    }
    if (!g_fShutdownCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ShutdownCriticalSection);
    fEntered = TRUE;

    ReleaseOldViews();
    if (State)
    {
	CSASSERT(0 < g_cCallsActive);
	if (0 == --g_cCallsActive && g_fRefuseIncoming)
	{
	    DBGPRINT((DBG_SS_CERTSRV, "ExitServer(set last thread exit event)\n"));
            SetEvent(g_hShutdownEvent);
	}
    }

error:
    if (fEntered)
    {
        LeaveCriticalSection(&g_ShutdownCriticalSection);
    }
}


HRESULT
CertSrvDelinkCAView(
    IN VOID *pvSearch,
    OPTIONAL OUT CAVIEW **ppCAViewOut)
{
    HRESULT hr;
    BOOL fEntered = FALSE;
    CAVIEW *pCAView;
    CAVIEW **ppCAViewLast;

    if (NULL != ppCAViewOut)
    {
	*ppCAViewOut = NULL;
    }
    if (!g_fShutdownCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ShutdownCriticalSection);
    fEntered = TRUE;

    ppCAViewLast = &g_pCAViewList;
    pCAView = g_pCAViewList;
    for (;;)
    {
	if (NULL == pCAView)
	{
	    hr = E_HANDLE;
	    _JumpError2(hr, error, "pvSearch not in list", hr);
	}
	if (pvSearch == pCAView->pvSearch)
	{
	    break;
	}
	ppCAViewLast = &pCAView->pCAViewNext;
	pCAView = pCAView->pCAViewNext;
    }
    if (NULL != ppCAViewOut)
    {
	*ppCAViewLast = pCAView->pCAViewNext;
	pCAView->pCAViewNext = NULL;
	*ppCAViewOut = pCAView;
	g_cCAView--;
    }
    hr = S_OK;

error:
    if (fEntered)
    {
        LeaveCriticalSection(&g_ShutdownCriticalSection);
    }
    return(hr);
}

HRESULT
CertSrvLinkCAView(
    IN BOOL fNew,
    IN VOID *pvSearch,
    IN CAVIEW *pCAViewIn)
{
    HRESULT hr;
    BOOL fEntered = FALSE;

    GetSystemTimeAsFileTime(&pCAViewIn->ftLastAccess);
    if (fNew)
    {
	pCAViewIn->ftCreate = pCAViewIn->ftLastAccess;
	pCAViewIn->pvSearch = pvSearch;
    }
    else
    {
	CSASSERT(pCAViewIn->pvSearch == pvSearch);
    }
    if (!g_fShutdownCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ShutdownCriticalSection);
    fEntered = TRUE;

    pCAViewIn->pCAViewNext = g_pCAViewList;
    g_pCAViewList = pCAViewIn;
    g_cCAView++;
    hr = S_OK;

error:
    if (fEntered)
    {
        LeaveCriticalSection(&g_ShutdownCriticalSection);
    }
    return(hr);
}


// Test for alignment faults in the C runtimes.
// If the bug hasn't been fixed yet, log an event during cert server startup.

VOID
certsrvLogAlignmentFaultStatus()
{
    HRESULT hr;
    HRESULT hr2;
    ULONG_PTR ExceptionAddress;
    WCHAR awcAddress[2 + 2 * cwcDWORDSPRINTF];
    WCHAR const *apwsz[2];
    WORD cpwsz;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszStringErr = NULL;
    
    ExceptionAddress = 0;
    apwsz[1] = NULL;
    hr = S_OK;
    __try
    {
	fwprintf(stdout, L".");	  // may fault if I/O buffer is odd aligned
	fprintf(stdout, ".");
	fwprintf(stdout, L".\n"); // may fault if I/O buffer is odd aligned
	hr = S_OK;
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "certsrvLogAlignmentFaultStatus: Exception");
    }
    if (S_OK != hr)
    {
	ALIGNIOB(stdout);	// align the stdio buffer
	wprintf(L"STDIO exception: 0x%x\n", hr);

	wsprintf(awcAddress, L"0x%p", (VOID *) ExceptionAddress);
	CSASSERT(wcslen(awcAddress) < ARRAYSIZE(awcAddress));

	apwsz[0] = awcAddress;
	pwszStringErr = myGetErrorMessageText(hr, TRUE);
	apwsz[1] = pwszStringErr;
	if (NULL == pwszStringErr)
	{
	    apwsz[1] = myHResultToString(awchr, hr);
	}
	cpwsz = ARRAYSIZE(apwsz);

	hr2 = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_E_STARTUP_EXCEPTION,
		    cpwsz,
		    apwsz);
	_JumpIfError(hr2, error, "LogEvent");
    }

error:
    if (NULL != pwszStringErr)
    {
	LocalFree(const_cast<WCHAR *>(pwszStringErr));
    }
}


#define MSTOSEC(ms)	(((ms) + 1000 - 1)/1000)
FNLOGEXCEPTION certsrvLogException;

HRESULT
certsrvStartServer(
    IN BOOL fConsoleActive)
{
    HRESULT hr;
    DWORD TimeStart;
    WCHAR awc[ARRAYSIZE(SAFEBOOT_DSREPAIR_STR_W)];
    DWORD cwc;
    DWORD dwEventType = EVENTLOG_ERROR_TYPE;
    DWORD dwIdEvent = 0;
    bool fAuditPrivilegeEnabled = false;
    BOOL fAuditEnabled = FALSE;
    WCHAR const *pwszDC0;

    g_fStartInProgress = TRUE;
    DBGPRINT((
        DBG_SS_CERTSRV,
        "StartServer(tid=%d, fConsoleActive=%u)\n",
        GetCurrentThreadId(),
        fConsoleActive));
    TimeStart = GetTickCount();

    if (fConsoleActive)
    {
        g_fStartAsService = FALSE;
        SetConsoleCtrlHandler(StopServer, TRUE);
    }
    else
    {
	SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
    }

    if (!FIsServer())
    {
        // don't allow startup on non-server SKU

        hr = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
        _JumpError(hr, error, "FIsServer"); 
    }

    cwc = GetEnvironmentVariable(L"SAFEBOOT_OPTION", awc, ARRAYSIZE(awc));
    if (0 != cwc &&
	ARRAYSIZE(awc) > cwc &&
	0 == LSTRCMPIS(awc, SAFEBOOT_DSREPAIR_STR_W))
    {
        // log an error to the event log and stop immediately
	dwEventType = EVENTLOG_INFORMATION_TYPE;
	dwIdEvent = MSG_SAFEBOOT_DETECTED;

	hr = HRESULT_FROM_WIN32(ERROR_RETRY);
	_JumpError(hr, error, "Not starting service: booted in DSRepair mode");
    }
    
    g_fAdvancedServer = FIsAdvancedServer();

    if (fConsoleActive)
    {
        hr = myEnablePrivilege(SE_AUDIT_NAME, TRUE);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myEnablePrivilege(SE_AUDIT_NAME)");
	    if (E_ACCESSDENIED != hr || 2 > g_fAdvancedServer)
	    {
		goto error;
	    }
	}
	else
	{
	    fAuditPrivilegeEnabled = true;
	}
    }

    if (!AuthzInitializeResourceManager(
            0,
            CallbackAccessCheck,
            NULL,
            NULL,
            L"CertSrv",
            &g_AuthzCertSrvRM))
    {
        hr = myHLastError();
        _PrintError(hr, "AuthzInitializeResourceManager");
        if (E_INVALIDARG != hr || (2 > g_fAdvancedServer && IsWhistler()))
        {
	    if (HRESULT_FROM_WIN32(ERROR_PRIVILEGE_NOT_HELD) != hr ||
		!fConsoleActive ||
		fAuditPrivilegeEnabled)
	    {
		goto error;
	    }
        }
    }
    else
    {
	fAuditEnabled = TRUE;
    }

    if (fAuditPrivilegeEnabled)
    {
        hr = myEnablePrivilege(SE_AUDIT_NAME, FALSE);
        _JumpIfError(hr, error, "myDisablePrivilege(SE_AUDIT_NAME)");
        fAuditPrivilegeEnabled = false;
    }

    hr = CoreInit(fAuditEnabled);
    if (S_OK != hr)
    {
	dwIdEvent = MAXDWORD;	// Error event already logged
	_JumpError(hr, error, "CoreInit");
    }
    certsrvLogAlignmentFaultStatus();
    myLogExceptionInit(certsrvLogException);

    if (0 == (IF_NORPCICERTREQUEST & g_InterfaceFlags))
    {
	hr = RPCInit();
	if (S_OK != hr)
	{
	    dwIdEvent = MSG_E_RPC_INIT;
	    _JumpError(hr, error, "RPCInit");
	}
    }

    hr = SetRegistryDcomConfig(fConsoleActive);
    if (S_OK != hr)
    {
	dwIdEvent = MSG_E_REGISTRY_DCOM;
        _JumpError(hr, error, "SetRegistryDcomConfig");
    }

    hr = CertStartClassFactories();
    if (S_OK != hr)
    {
	dwIdEvent = CO_E_WRONG_SERVER_IDENTITY == hr?
		    MSG_E_SERVER_IDENTITY : MSG_E_CLASS_FACTORIES;
        _JumpError(hr, error, "CertStartClassFactories");
    }

    {
        // only perform Hash if the auditing is enabled

        if (AUDIT_FILTER_STARTSTOP & g_dwAuditFilter)
        {
	    BOOL fSupported;
	    BOOL fEnabled;

            CertSrv::CAuditEvent event(
			            SE_AUDITID_CERTSRV_SERVICESTART,
			            g_dwAuditFilter);
            ULARGE_INTEGER uliKeyUsageCount;
            CAutoLPWSTR autoszCertHash;
            CAutoLPWSTR autoszPublicKeyHash;

            hr = event.AddData(g_pwszDBFileHash); // %1 database hash
            _JumpIfError(hr, error, "CAuditEvent::AddData");
    
            // retrieve private key usage count if auditing enabled

            uliKeyUsageCount.QuadPart = 0;
	    hr = myGetSigningKeyUsageCount(
				    g_pCAContextCurrent->hProvCA,
				    &fSupported,
				    &fEnabled,
				    &uliKeyUsageCount);
	    _PrintIfError(hr, "myGetSigningKeyUsageCount");

            hr = event.AddData(&uliKeyUsageCount); // %2 key usage count
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = certsrvGetCACertAndKeyHash(
				    &autoszCertHash,
				    &autoszPublicKeyHash);
            _JumpIfError(hr, error, "certsrvGetCACertAndKeyHash");

            hr = event.AddData((LPCWSTR)autoszCertHash); // %3 CA cert hash
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = event.AddData((LPCWSTR)autoszPublicKeyHash); // %4 CA public key hash
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = event.Report();
            _JumpIfError(hr, error, "CAuditEvent::Report");
        }
    }

    {
        CertSrv::CAuditEvent event(
			        SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE,
			        g_dwAuditFilter);

        hr = event.AddData(CAuditEvent::RoleSeparationIsEnabled()); // %1 is role separation enabled?
        _JumpIfError(hr, error, "CAuditEvent::AddData");
    
        hr = event.Report();
        _JumpIfError(hr, error, "CAuditEvent::Report");
    }


    pwszDC0 = (g_fUseDS || L'\0' != g_wszPolicyDCName[0])? L"  DC=" : L"";
    if (CERTLOG_TERSE <= g_dwLogLevel)
    {
	WCHAR const *apwsz[3];

	apwsz[0] = g_wszCommonName;
	apwsz[1] = pwszDC0;
	apwsz[2] = g_wszPolicyDCName;

	LogEvent(
	    EVENTLOG_INFORMATION_TYPE,
	    MSG_I_SERVER_STARTED,
	    ARRAYSIZE(apwsz),
	    apwsz);
    }
    
    CONSOLEPRINT1((
        DBG_SS_CERTSRV,
        "Certification Authority Service Ready (%us)%ws%ws ...\n",
        MSTOSEC(GetTickCount() - TimeStart),
	pwszDC0,
	g_wszPolicyDCName));
    g_fStarted = TRUE;
    CSASSERT(S_OK == hr);

error:

    g_pwszDBFileHash.Cleanup();
    if (fAuditPrivilegeEnabled)
    {
        myEnablePrivilege(SE_AUDIT_NAME, FALSE);
    }
    if (S_OK != hr)
    {
	if (MAXDWORD != dwIdEvent)
	{
	    if (0 == dwIdEvent)
	    {
		dwIdEvent = MSG_E_GENERIC_STARTUP_FAILURE;
	    }
	    LogEventStringHResult(
			dwEventType,
			dwIdEvent,
			g_wszCommonName,
			EVENTLOG_INFORMATION_TYPE == dwEventType? S_OK : hr);
	}

        CertSrvStopServer(fConsoleActive);
        
        // returning error here results in repost to scm
    }

    g_fStartInProgress = FALSE;
    return(hr);
}


VOID
certsrvLogException(
    IN HRESULT hrEvent,
    IN EXCEPTION_POINTERS const *pep,
    OPTIONAL IN char const *, // pszFileName
    IN DWORD dwFile,
    IN DWORD dwLine)
{
    HRESULT hr;
    WCHAR awcFile[2 + 3 * cwcDWORDSPRINTF];
    WCHAR awcFlags[3 + cwcDWORDSPRINTF];
    WCHAR awcAddress[2 + 2 * cwcDWORDSPRINTF];
    WCHAR const *apwsz[4];
    WORD cpwsz;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszStringErr = NULL;

    wsprintf(awcFile, L"%u.%u.%u", dwFile, dwLine, MSG_E_EXCEPTION);
    CSASSERT(wcslen(awcFile) < ARRAYSIZE(awcFile));

    wsprintf(awcFlags, L"0x%08x", pep->ExceptionRecord->ExceptionFlags);
    CSASSERT(wcslen(awcFlags) < ARRAYSIZE(awcFlags));

    wsprintf(awcAddress, L"0x%p", pep->ExceptionRecord->ExceptionAddress);
    CSASSERT(wcslen(awcAddress) < ARRAYSIZE(awcAddress));

    apwsz[0] = awcFile;
    apwsz[1] = awcAddress;
    apwsz[2] = awcFlags;
    pwszStringErr = myGetErrorMessageText(hrEvent, TRUE);
    apwsz[3] = pwszStringErr;
    if (NULL == pwszStringErr)
    {
	apwsz[3] = myHResultToString(awchr, hrEvent);
    }
    cpwsz = ARRAYSIZE(apwsz);

    hr = LogEvent(EVENTLOG_ERROR_TYPE, MSG_E_EXCEPTION, cpwsz, apwsz);
    _JumpIfError(hr, error, "LogEvent");

error:
    if (NULL != pwszStringErr)
    {
	LocalFree(const_cast<WCHAR *>(pwszStringErr));
    }
}


DWORD
CertSrvStartServerThread(
    IN VOID *pvArg)
{
    HRESULT hr = S_OK;
    DWORD Flags = (DWORD) (ULONG_PTR) pvArg;
    BOOL b;
    ULONG_PTR ulp;

    // Anatomy of startup code
    // if g_fStartAsService, just registers this new thread as the main
    // thread and blocks until the ServiceMain fxn returns.
                        
    // We're in a non-rpc thread; check if we need to create VRoots.  I would
    // have liked to have moved this into CoreInit, but we're limited in where
    // we can do this (can't be calling into RPC during RPC call).
    //
    // If the SetupStatus SETUP_ATTEMPT_VROOT_CREATE registry flag is clear,
    // this call is a nop.  A separate thread is created to access the IIS
    // metabase.  If it hangs, it will be nuked -- after the specified timeout.
    // This call returns immediately, so the only detectable error is likely
    // to be a thread creation problem.

    // if we're doing anything other than starting the service controller,
    // check to see if the vroots need to be created.

    if (0 == (Flags & CSST_STARTSERVICECONTROLLER))
    {
	WCHAR *pwszPath = NULL;
	DWORD cb = sizeof(ENUM_CATYPES);
	DWORD dwType;
	ENUM_CATYPES CAType = ENUM_UNKNOWN_CA;
	HKEY hkey = NULL;

	hr = myRegOpenRelativeKey(
				NULL,
				L"ca",
				RORKF_CREATESUBKEYS,
				&pwszPath,
				NULL,           // ppwszName
				&hkey);
	_PrintIfError(hr, "myRegOpenRelativeKey");
	if (S_OK == hr)
	{
	    DBGPRINT((DBG_SS_CERTLIBI, "%ws\n", pwszPath));
	    cb = sizeof(CAType);
	    hr = RegQueryValueEx(
		 hkey,
		 wszREGCATYPE,
		 NULL,
		 &dwType,
		 (BYTE *) &CAType,
		 &cb);
	    _PrintIfErrorStr(hr, "RegQueryValueEx", wszREGCATYPE);
	}
	if (pwszPath)
	    LocalFree(pwszPath);
	if (hkey)
	   RegCloseKey(hkey);

	hr = myModifyVirtualRootsAndFileShares(
		    VFF_CREATEVROOTS |		// Create VRoots
			VFF_CREATEFILESHARES |	// Create File Shares
			VFF_CHECKREGFLAGFIRST |	// Skip if reg flag clear
			VFF_CLEARREGFLAGFIRST,	// Clear flag before attempt
		    CAType,
		    TRUE,           // asynch call -- don't block
		    VFCSEC_TIMEOUT, // wait this long before giving up
		    NULL,
		    NULL);
	if (S_OK != hr)
	{
	    LogEventHResult(
		    EVENTLOG_INFORMATION_TYPE,
		    MSG_E_IIS_INTEGRATION_ERROR,
		    hr);
	}
    }

    // StartServiceCtrlDispatcher should hang until certsrv terminates

    if ((CSST_STARTSERVICECONTROLLER & Flags) &&
        !StartServiceCtrlDispatcher(steDispatchTable))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT) != hr)
        {
            _JumpError(hr, error, "StartServiceCtrlDispatcher");
        }
        CONSOLEPRINT0((
            DBG_SS_CERTSRV,
            "CertSrv: Failed to connect to service controller -- running in standalone mode\n"));

        Flags &= ~CSST_STARTSERVICECONTROLLER;
        Flags |= CSST_CONSOLE;
    }

   
    if (0 == (CSST_STARTSERVICECONTROLLER & Flags))
    {
        DBGPRINT((
            DBG_SS_CERTSRVI,
            "SendMessageTimeout(tid=%d, hwnd=0x%x, msg=0x%x)\n",
            GetCurrentThreadId(),
            g_hwndMain,
            WM_STARTSERVER));

        b = SendMessageTimeout(
			g_hwndMain,
			WM_STARTSERVER,
			(CSST_CONSOLE & Flags)? TRUE : FALSE, // fConsoleActive
			0,
			SMTO_BLOCK,
			MAXLONG,
			&ulp) != 0;
        if (!b)
        {
            hr = myHLastError();
            _JumpError(hr, error, "SendMessageTimeout");
        }
        else if (ulp != S_OK)
        {
            hr = (HRESULT) ulp;
            _JumpError(hr, error, "SendMessageTimeout");
        }
    }

    if (Flags & CSST_CONSOLE)
    {   
        // we're running as console, and so don't have a CRL publishing thread. 
        // Use this one since no one cares if it returns

        // if svc, we do this in the caller of this function
        CertSrvBlockThreadUntilStop();
    }

error:

    // on return, this thread dies
    return(hr);
}


VOID
DisplayUsage(
    IN DWORD idsMsg)
{
    WCHAR *pwsz = myLoadResourceStringNoCache(g_hInstApp, idsMsg);

    if (NULL != pwsz)
    {
	wprintf(L"%ws", pwsz);
	LocalFree(pwsz);
    }
}


VOID
Usage(
    IN BOOL fUsageInternal)
{
    DisplayUsage(IDS_USAGE);
    if (fUsageInternal)
    {
	DisplayUsage(IDS_USAGE_FULL);
#if DBG_COMTEST
	DisplayUsage(IDS_USAGE_COMTEST);
#endif
    }
}


int
ArgvParseCommandLine(
    IN int argc,
    IN WCHAR *argv[])
{
    HRESULT hr;

    myVerifyResourceStrings(g_hInstApp);

    hr = E_INVALIDARG;
    while (1 < argc && myIsSwitchChar(argv[1][0]))
    {
	WCHAR *pwsz = argv[1];
	BOOL fUsage = FALSE;
	BOOL fUsageInternal = FALSE;

	while (*++pwsz != L'\0')
	{
	    switch (*pwsz)
	    {
#if DBG_COMTEST
		case L'C':
		case L'c':
		    fComTest = TRUE;
		    break;
#endif

		case L'N':
		case L'n':
		    g_fCreateDB = TRUE;
		    break;

		case L'Z':
		case L'z':
		    g_fStartAsService = FALSE;
		    break;

		case L'S':
		case L's':
		    g_CryptSilent = CRYPT_SILENT;
		    break;

		case L'?':
		case L'u':
		    fUsage = TRUE;
		    if (0 == lstrcmp(pwsz, L"uSAGE"))
		    {
			fUsageInternal = TRUE;
		    }
		    // FALLTHROUGH

		default:
		    Usage(fUsageInternal);
		    if (fUsage)
		    {
			goto error;
		    }
		    _JumpError(hr, error, "bad command line option");
	    }
	}
	argc--;
	argv++;
    }
    if (argc != 1)
    {
	Usage(FALSE);
	_JumpError(hr, error, "extra args");
    }
    if (g_fStartAsService)
    {
	BOOL fSilent;
	
	hr = ServiceQueryInteractiveFlag(&fSilent);
	_PrintIfError(hr, "ServiceQueryInteractiveFlag");

	if (S_OK == hr && fSilent)
	{
	    g_CryptSilent = CRYPT_SILENT;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


typedef int (FNARGVMAIN)(
    IN int argc,
    IN WCHAR *argv[]);


//+------------------------------------------------------------------------
// FUNCTION:	CertArgvMainDispatch
//
// NOTES:	Takes a WCHAR * command line and chews it up into argc/argv
//		form so it can be passed on to a traditional C-style main.
//-------------------------------------------------------------------------

HRESULT
CertArgvMainDispatch(
    IN FNARGVMAIN *pfnMain,
    IN WCHAR *pwszAppName,
    IN WCHAR const *pwszCmdLine)
{
    HRESULT hr;
    WCHAR *pwcBuf = NULL;
    WCHAR *apwszArg[20];
    int cArg;
    WCHAR *p;
    WCHAR wcEnd;
    WCHAR const *pwszT;

    pwcBuf = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszCmdLine) + 1) * sizeof(WCHAR));
    if (NULL == pwcBuf)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    p = pwcBuf;
    cArg = 0;
    apwszArg[cArg++] = pwszAppName;
    pwszT = pwszCmdLine;
    while (*pwszT != L'\0')
    {
        while (*pwszT == L' ')
        {
            pwszT++;
        }
        if (*pwszT != L'\0')
        {
            wcEnd = L' ';
            if (*pwszT == L'"')
            {
                wcEnd = *pwszT++;
            }
            apwszArg[cArg++] = p;
	    if (ARRAYSIZE(apwszArg) <= cArg)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Too many args");
	    }
            while (*pwszT != L'\0' && *pwszT != wcEnd)
            {
                *p++ = *pwszT++;
            }
            *p++ = L'\0';
            if (*pwszT != L'\0')
            {
                pwszT++;	// skip blank or quote character
            }
        }
    }
    CSASSERT(
	L'\0' == *pwszCmdLine ||
	wcslen(pwszCmdLine) + 1 >= SAFE_SUBTRACT_POINTERS(p, pwcBuf));
    CSASSERT(ARRAYSIZE(apwszArg) > cArg);
    apwszArg[cArg] = NULL;

    hr = (*pfnMain)(cArg, apwszArg);

error:
    if (NULL != pwcBuf)
    {
	LocalFree(pwcBuf);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// FUNCTION:	MainWndProc(...)
//-------------------------------------------------------------------------

LRESULT APIENTRY
MainWndProc(
    IN HWND hWnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    HRESULT hr;
    LPARAM lRet = 0;
    
    DBGPRINT((
        DBG_SS_CERTSRVI,
        "MainWndProc(tid=%d) msg=0x%x, wp=0x%x, lp=0x%x\n",
        GetCurrentThreadId(),
        msg,
        wParam,
        lParam));
    
    switch (msg)
    {
    case WM_CREATE:
    case WM_SIZE:
        break;
        
    case WM_DESTROY:
        if (!g_fStartAsService)
	{
            PostQuitMessage(S_OK);
	}
        break;
        

    case WM_ENDSESSION:
        // only stop on a real shutdown,
        // never look at this msg if running as svc
        if (g_fStartAsService || (0 == wParam) || (0 != lParam))
        {
            break;
        }
        // fall through

    case WM_STOPSERVER:
        lRet = CertSrvStopServer(!g_fStartAsService);

        break;
        
    case WM_SYNC_CLOSING_THREADS:
        hr = (HRESULT) lParam;
        
        // sync: wait for SCM to return control to exiting CertSrvStartServerThread
        if (WAIT_OBJECT_0 != WaitForSingleObject(g_hServiceThread, 10 * 1000))
        {
            hr = WAIT_TIMEOUT;
        }
        PostQuitMessage(hr);
        break;
        
    case WM_STARTSERVER:
        hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
        if (S_FALSE == hr)
        {
            hr = S_OK;
        }
        if (S_OK != hr)
        {
            LogEventString(
                EVENTLOG_ERROR_TYPE,
                MSG_E_OLE_INIT_FAILED,
                NULL);
            _PrintError(hr, "CoInitializeEx");
        }
        else
        {
            hr = certsrvStartServer((BOOL) wParam);
            _PrintIfError(hr, "certsrvStartServer");
        }

        if (S_OK != hr)
        {
            if ((BOOL) wParam)	// fConsoleActive
	    {
                 PostQuitMessage(hr);
	    }
            lRet = hr;		// set this so caller knows we failed
        }
        break;
        
    case WM_SUSPENDSERVER:
        break;
        
    case WM_RESTARTSERVER:
        break;

    default:
        lRet = DefWindowProc(hWnd, msg, wParam, lParam);
    }
    return(lRet);
}

/*

Complete anatomy of certificate server startup/shutdown

WinMain():
|
|g_hSvcThread = CreateThread(CertSrvStartServerThread(SVC_CONTROLLER))
|                     |
|[MessageLoop         \
| processing           CertSrvStartServerThread(SVC_CONTROLLER):
| until                |StartSvcCtrlDispatcher(ServiceMain)
| WM_QUIT]             ||ServiceMain:
|                      ||RegisterSvcCtrlHandler(ServiceControlHandler())
|                      ||hStartThread = CreateThread(CertSrvStartServerThread(0))
|                      ||                    |
|                      ||                    \ 
|                      ||                     CertSrvStartServerThread(0):
|                      ||                     |SendMessage(WM_STARTSERVER)
|                      ||                     \return   // CertSrvStartServerThread(0)
|                      ||                      (Thread Terminates)
|                      ||WaitForSingleObject(hStartThread), pinging SCM
|                      ||CertSrvBlockThreadUntilStop()
|                      |||WaitForSingleObject(g_hSvcStoppingEvent) ***steady state***
|                      ||\return   // CertSrvBlockThreadUntilStop()
|                      ||WaitForSingleObject(g_hSvcStoppedEvent), pinging SCM
|                      ||PostMessage(WM_SYNC_CLOSING_THREADS)
|                      |\return    // StartSvcCtrlDispatcher(ServiceMain)
|                      \return     // CertSrvStartServerThread(SVC_CONTROLLER)
|                       (Thread Terminates)
| WM_QUIT:
\ return
  (Process Terminates)

ServiceControlHandler special functions:
SERVICE_CONTROL_STOP:
|PostMessage(WM_STOPSERVER)
\break

MessageLoop special functions: 

WM_SYNC_CLOSING_THREADS:
|WaitForSingleObject(g_hSvcThread)
|PostQuitMessage()  // WM_QUIT to msgloop
\break

WM_STOPSERVER:
|CertSrvStopServer():
|| Signal(g_hServiceStoppingEvent)
|| Signal(g_hServiceStoppedEvent)
|\ return // CertSrvStopServer()
\break

*/


//+------------------------------------------------------------------------
//  Function:	wWinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	-- Instance handle
//		[hPrevInstance] -- Obsolete
//		[lpCmdLine]	-- App command line
//		[nCmdShow]	-- Starting show state
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE, // hPrevInstance
    IN LPWSTR lpCmdLine,
    IN int /* nCmdShow */ )
{
    MSG msg;
    WNDCLASSEX wcApp;
    ATOM atomClass;
    HRESULT hr;
    BOOL fCoInit = FALSE;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszMsgAlloc;
    WCHAR const *pwszMsg;

    _setmode(_fileno(stdout), _O_TEXT);
    _wsetlocale(LC_ALL, L".OCP");
    mySetThreadUILanguage(0);

    CertSrvLogOpen();
    DBGPRINT((DBG_SS_CERTSRVI, "Main Thread = %x\n", GetCurrentThreadId()));

    g_dwDelay0 = GetRegistryDwordValue(L"Delay0");
    g_dwDelay1 = GetRegistryDwordValue(L"Delay1");
    g_dwDelay2 = GetRegistryDwordValue(L"Delay2");

    if (0 != g_dwDelay0)
    {
	DBGPRINT((
		DBG_SS_CERTSRV,
		"wWinMain(0): sleeping %u seconds\n",
		g_dwDelay0));
	Sleep(1000 * g_dwDelay0);
    }

    // Save the current instance
    g_hInstApp = hInstance;
    ZeroMemory(&wcApp, sizeof(wcApp));

    // Set up the application's window class
    wcApp.cbSize	= sizeof(wcApp);
    wcApp.lpfnWndProc	= MainWndProc;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL, IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL, IDC_ARROW);
    wcApp.hbrBackground	= NULL; // try to not pull in GDI32

    wcApp.lpszClassName	= g_wszAppName;

    atomClass = RegisterClassEx(&wcApp);
    if (!atomClass)
    {
	hr = myHLastError();
	_JumpError(hr, error, "RegisterClassEx");
    }

    // Create Main Window

    g_hwndMain = CreateWindowEx(
			0,			   // dwExStyle
			(WCHAR const *) atomClass, // lpClassName
			L"Certification Authority",// lpWindowName
			WS_OVERLAPPEDWINDOW,	   // dwStyle
			//0,		           // dwStyle
			CW_USEDEFAULT,		   // x
			CW_USEDEFAULT,		   // y
			CW_USEDEFAULT,		   // nWidth
			CW_USEDEFAULT,		   // nHeight
			NULL,			   // hWndParent
			NULL,			   // hMenu
			hInstance,		   // hInstance
			NULL);			   // lpParam

    if (NULL == g_hwndMain)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateWindowEx");
    }
    DBGPRINT((DBG_SS_CERTSRVI, "Main Window = %x\n", g_hwndMain));

    // Make window visible
    // ShowWindow(g_hwndMain,nCmdShow);

    hr = CertArgvMainDispatch(ArgvParseCommandLine, g_wszAppName, lpCmdLine);
    _JumpIfError2(hr, error, "CertArgvMainDispatch", E_INVALIDARG);

    // Update window client area
    // UpdateWindow(g_hwndMain);

    if (0 != g_dwDelay1)
    {
	DBGPRINT((
		DBG_SS_CERTSRV,
		"wWinMain(1): sleeping %u seconds\n",
		g_dwDelay1));
	Sleep(1000 * g_dwDelay1);
    }

    hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
    if (S_OK != hr && S_FALSE != hr)
    {
	LogEventStringHResult(
			EVENTLOG_ERROR_TYPE,
			MSG_E_CO_INITIALIZE,
			g_wszCommonName,
			hr);
	_JumpError(hr, error, "CoInitializeEx");
    }
    fCoInit = TRUE;

    g_hServiceStoppingEvent = CreateEvent(NULL, TRUE, FALSE, NULL);  
    if (NULL == g_hServiceStoppingEvent)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    g_hServiceStoppedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == g_hServiceStoppedEvent)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    g_hCRLManualPublishEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == g_hCRLManualPublishEvent)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    g_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == g_hShutdownEvent)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    __try
    {
	InitializeCriticalSection(&g_ShutdownCriticalSection);
	g_fShutdownCritSec = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    g_hServiceThread = CreateThread(
			    NULL,	// lpThreadAttributes (Security Attr)
			    0,		// dwStackSize
			    CertSrvStartServerThread,
			    (VOID *) UlongToPtr((g_fStartAsService? CSST_STARTSERVICECONTROLLER : CSST_CONSOLE)), // lpParameter
			    0,		// dwCreationFlags
			    &g_ServiceThreadId);
    if (NULL == g_hServiceThread)
    {
	hr = myHLastError();
	LogEventStringHResult(
			EVENTLOG_ERROR_TYPE,
			MSG_E_SERVICE_THREAD,
			g_wszCommonName,
			hr);
	_JumpError(hr, error, "CreateThread");
    }
    DBGPRINT((DBG_SS_CERTSRVI, "Service Thread = %x\n", g_ServiceThreadId));

    // Message Loop
    for (;;)
    {
	BOOL b;

	b = GetMessage(&msg, NULL, 0, 0);
	if (!b)
	{
	    hr = (HRESULT)msg.wParam;
	    _JumpIfError(hr, error, "WM_QUIT");
	    break;
	}
	if (-1 == (LONG) b)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetMessage");
	}
	DBGPRINT((
		DBG_SS_CERTSRVI,
		"DispatchMessage(tid=%d) msg=0x%x, wp=0x%x, lp=0x%x\n",
		GetCurrentThreadId(),
		msg.message,
		msg.wParam,
		msg.lParam));
	DispatchMessage(&msg);
    }

error:
    if (fCoInit)
    {
	CoUninitialize();
    }
    if (g_fShutdownCritSec)
    {
	DeleteCriticalSection(&g_ShutdownCriticalSection);
	g_fShutdownCritSec = FALSE;
    }
    if (NULL != g_hShutdownEvent)
    {
        CloseHandle(g_hShutdownEvent);
    }
    if (NULL != g_hServiceThread)
    {
        CloseHandle(g_hServiceThread);
    }
    if (NULL != g_hServiceStoppingEvent)
    {
	CloseHandle(g_hServiceStoppingEvent);
    }
    if (NULL != g_hServiceStoppedEvent)
    {
        CloseHandle(g_hServiceStoppedEvent);
    }
    if (NULL != g_hCRLManualPublishEvent)
    {
        CloseHandle(g_hCRLManualPublishEvent);
    }
    CAuditEvent::CleanupAuditEventTypeHandles();

    pwszMsgAlloc = NULL;
    pwszMsg = L"S_OK";
    if (S_OK != hr)
    {
	pwszMsgAlloc = myGetErrorMessageText(hr, TRUE);
	if (NULL != pwszMsgAlloc)
	{
	    pwszMsg = pwszMsgAlloc;
	}
	else
	{
	    pwszMsg = myHResultToString(awchr, hr);
	}
    }
    _PrintError(hr, "Exit Status");
    CONSOLEPRINT1((DBG_SS_CERTSRV, "Exit Status = %ws\n", pwszMsg));
    if (NULL != pwszMsgAlloc)
    {
	LocalFree(const_cast<WCHAR *>(pwszMsgAlloc));
    }
    myFreeResourceStrings("certsrv.exe");
    myFreeColumnDisplayNames();
    myRegisterMemDump();
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\callback.cpp ===
//+--------------------------------------------------------------------------
// File:        callback.cpp
// Contents:    access check callback
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop
#include "csext.h"
#include "certsd.h"
#include <winldap.h>
#include <limits.h>
#include "csprop.h"
#include "sid.h"
#include <authzi.h>

#define __dwFILE__	__dwFILE_CERTSRV_CALLBACK_CPP__


namespace CertSrv
{

HRESULT GetAccountSid(
    IN LPCWSTR pwszName,
    PSID *ppSid)
{
    HRESULT hr = S_OK;
    DWORD cbSid = 0;
    DWORD cbDomainName = 0;
    SID_NAME_USE use;
    LPWSTR pwszDomainName = NULL;
    
    *ppSid = NULL;

    if(!pwszName || L'\0'== pwszName[0])
    {
        hr = GetEveryoneSID(ppSid);
        _JumpIfError(hr, error, "GetEveryoneSID");
    }
    else
    {

        LookupAccountName(
                NULL,
                pwszName,
                NULL,
                &cbSid,
                NULL,
                &cbDomainName,
                &use);
    
        if(ERROR_INSUFFICIENT_BUFFER != GetLastError())
        {
            hr = myHError(GetLastError()); 
            _JumpError(hr, error, "LookupAccountName");
        }

        *ppSid = (PSID)LocalAlloc(LMEM_FIXED, cbSid);
        if(!*ppSid)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        pwszDomainName = (LPWSTR)LocalAlloc(LMEM_FIXED, 
            cbDomainName*sizeof(WCHAR));
        if(!pwszDomainName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if(!LookupAccountName(
                NULL,
                pwszName,
                *ppSid,
                &cbSid,
                pwszDomainName,
                &cbDomainName,
                &use))
        {
            hr = myHError(GetLastError()); 
            _JumpError(hr, error, "LookupAccountName");
        }
    }

    hr = S_OK;

error:
    if(S_OK!=hr)
    {
        if(*ppSid)
        {
            LocalFree(*ppSid);
            *ppSid = NULL;
        }
    }
    if(pwszDomainName)
    {
        LocalFree(pwszDomainName);
    }
    return hr;
}

BOOL
CallbackAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE, // pAuthzClientContext
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable)
{
    HRESULT hr = S_OK;
    LPWSTR pwszSamName = (LPWSTR)pArgs;// requester name is passed in to
                                        // AuthzAccessCheck in NT4 style form
                                        // "DomainNetbiosName\RequesterSAMName"
    PSID pSid = NULL, pClientSid = NULL, pCallerSid = NULL;
    PSID pEveryoneSid = NULL;
    PTOKEN_GROUPS pGroups = NULL;
    ACCESS_ALLOWED_CALLBACK_ACE* pCallbackAce = 
        (ACCESS_ALLOWED_CALLBACK_ACE*)pAce;
    PSID_LIST pSidList = (PSID_LIST) (((BYTE*)&pCallbackAce->SidStart)+
        GetLengthSid(&pCallbackAce->SidStart));
    DWORD cSids, cClientSids;

    CSASSERT(
        ACCESS_ALLOWED_CALLBACK_ACE_TYPE == pAce->AceType ||
        ACCESS_DENIED_CALLBACK_ACE_TYPE  == pAce->AceType);

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));

    SetLastError(ERROR_SUCCESS);

    // get the SID for the requester
    hr = GetAccountSid(pwszSamName, &pCallerSid);

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));

    if(EmptyString(pwszSamName) ||
       HRESULT_FROM_WIN32(ERROR_NONE_MAPPED)==hr)
    {
        // if name cannot be resolved, default to Everyone
        pGroups = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED, sizeof(TOKEN_GROUPS));
        if(!pGroups)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        
        hr = GetEveryoneSID(&pEveryoneSid);
        _JumpIfError(hr, error, "GetEveryoneSID");

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));

        pGroups->GroupCount=1;
        pGroups->Groups[0].Sid = pEveryoneSid;
        pGroups->Groups[0].Attributes = 0;
    }
    else
    {
        _JumpIfError(hr, error, "GetAccountSid");

        // get the list of groups this SID is member of
        hr = GetMembership(g_AuthzCertSrvRM, pCallerSid, &pGroups);
        _JumpIfError(hr, error, "GetMembership");
    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));
    }

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));

    if(pGroups)
    {
        // traverse the SID list stored in the ACE and compare with the
        // client's membership
        for(pSid=(PSID)&pSidList->SidListStart, cSids=0; cSids<pSidList->dwSidCount;
            cSids++, pSid = (PSID)(((BYTE*)pSid)+GetLengthSid(pSid)))
        {
            CSASSERT(IsValidSid(pSid));

            // group membership doesn't include the user itself, so 
            // compare with the user first
            if(pCallerSid && EqualSid(pSid, pCallerSid))
            {
                *pbAceApplicable = TRUE;
                goto error;
            }

            for(cClientSids=0; cClientSids<pGroups->GroupCount; cClientSids++)
            {
                pClientSid = pGroups->Groups[cClientSids].Sid;
                CSASSERT(IsValidSid(pClientSid));
                if(EqualSid(pSid, pClientSid))
                {
                    *pbAceApplicable = TRUE;
                    goto error;
                }
            }
        }
    }

    *pbAceApplicable = FALSE;

error:

    CSASSERT(HeapValidate(GetProcessHeap(),0,NULL));
    
    if(pEveryoneSid)
    {
        LocalFree(pEveryoneSid);
    }
    if(pCallerSid)
    {
        LocalFree(pCallerSid);
    }
    if(pGroups)
    {
        LocalFree(pGroups);
    }
    if(S_OK==hr)
    {
        return TRUE;
    }
    else
    {
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }

}


HRESULT GetMembership(
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzRM,
    IN PSID pSid,
    PTOKEN_GROUPS *ppGroups)
{
    HRESULT hr = S_OK;
    static LUID luid = {0,0};
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzCC = NULL;
    DWORD dwSizeRequired;

    *ppGroups = NULL;

    if(!AuthzInitializeContextFromSid(
            0,
            pSid,
            AuthzRM,
            NULL,
            luid, //ignored
            NULL,
            &AuthzCC))
    {
        hr = myHError(GetLastError()); 
        _JumpError(hr, error, "AuthzInitializeContextFromSid");
    }

    if(!AuthzGetInformationFromContext(
            AuthzCC,
            AuthzContextInfoGroupsSids,
            0,
            &dwSizeRequired,
            NULL))
    {
        if(ERROR_INSUFFICIENT_BUFFER!=GetLastError())
        {
            hr = myHError(GetLastError()); 
            _JumpError(hr, error, "AuthzGetContextInformation");
        }
    }

    *ppGroups = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED, dwSizeRequired);
    if(!*ppGroups)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!AuthzGetInformationFromContext(
            AuthzCC,
            AuthzContextInfoGroupsSids,
            dwSizeRequired,
            &dwSizeRequired,
            *ppGroups))
    {
        hr = myHError(GetLastError()); 
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

error:
    if(AuthzCC)
    {
        AuthzFreeContext(AuthzCC);
    }
    if(S_OK!=hr && *ppGroups)
    {
        LocalFree(*ppGroups);
    }
    return hr;
}

HRESULT GetRequesterName(DWORD dwRequestId, LPWSTR *ppwszName)
{
    HRESULT hr = S_OK;
    ICertDBRow *prow = NULL;

    hr = g_pCertDB->OpenRow(
                        PROPOPEN_READONLY | PROPTABLE_REQCERT,
                        dwRequestId,
                        NULL,
                        &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PKCSGetProperty(
                prow,
                g_wszPropRequesterName,
                PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
                NULL,
                (BYTE **) ppwszName);
    _JumpIfError(hr, error, "PKCSGetProperty");

error:
    if(prow)
    {
        prow->Release();
    }
    return hr;
}

HRESULT CheckOfficerRights(DWORD dwRequestID, CAuditEvent& event)
{
    HRESULT hr = S_OK;
    LPWSTR pwszRequesterName = NULL;

    // officer rights disabled means every officer is allowed to manage requests
    // for everyone, so return ok
    if(!g_OfficerRightsSD.IsEnabled())
        return S_OK;

    hr = GetRequesterName(dwRequestID, &pwszRequesterName);
    if(CERTSRV_E_PROPERTY_EMPTY!=hr &&
       S_OK != hr)
    {
        _JumpError(hr, error, "GetRequesterName");
    }

    hr = CheckOfficerRights(pwszRequesterName, event);

error:
    if(pwszRequesterName)
    {
        LocalFree(pwszRequesterName);
    }
    return hr;
}

// Verify if impersonated user has the rights over the specified request,
// based on the officer rights defined in the global officer SD and the
// requester name stored in the request
// Return S_OK if allowed or if the officer rights feature is disabled
//        E_ACCESSDENIED if not allowed
//        E_* if failed to check the rights

HRESULT
CheckOfficerRights(
    LPCWSTR pwszRequesterName,
    CAuditEvent& event)
{
    HRESULT hr;
    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzCC = NULL;

    // officer rights disabled means every officer is allowed to manage
    // requests for everyone, so return ok

    if (!g_OfficerRightsSD.IsEnabled())
    {
        hr = S_OK;
	goto error;
    }

    hr = GetCallerAuthzContext(&hAuthzCC);
    _JumpIfError(hr, error, "GetCallerAuthzContext");

    hr = CheckOfficerRightsFromAuthzCC(hAuthzCC, pwszRequesterName);
    _JumpIfError(hr, error, "CheckOfficerRightsFromAuthzCC");

error:
    if (NULL != hAuthzCC)
    {
        AuthzFreeContext(hAuthzCC);
    }

    // generate a failure audit event if restricted officer

    if (CERTSRV_E_RESTRICTEDOFFICER == hr)
    {
        HRESULT hr2 = event.AccessCheck(
				    CA_ACCESS_DENIED,
				    event.m_gcNoAuditSuccess);
        if (S_OK != hr2 && E_ACCESSDENIED != hr2)
	{
            hr = hr2;
	}
    }
    return(hr);
}


static LUID s_luid = { 0, 0 };

HRESULT
GetCallerAuthzContext(
    OUT AUTHZ_CLIENT_CONTEXT_HANDLE *phAuthzCC)
{
    HRESULT hr;
    IServerSecurity *pISS = NULL;
    HANDLE hThread = NULL;
    HANDLE hToken = NULL;

    hr = CoGetCallContext(IID_IServerSecurity, (VOID **) &pISS);
    _JumpIfError(hr, error, "CoGetCallContext");

    if (!pISS->IsImpersonating())
    {
	hr = pISS->ImpersonateClient();
        _JumpIfError(hr, error, "ImpersonateClient");
    }
    else
    {
        pISS->Release();
        pISS = NULL;
    }

    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "GetCurrentThread");
    }
    if (!OpenThreadToken(
		    hThread,
                    TOKEN_QUERY,
                    FALSE,  // client impersonation
                    &hToken))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "OpenThreadToken");
    }

    if (!AuthzInitializeContextFromToken(
				0,
				hToken,
				g_AuthzCertSrvRM,
				NULL,
				s_luid,
				NULL,
				phAuthzCC))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzInitializeContextFromToken");
    }
    hr = S_OK;

error:
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    if (NULL != hToken)
    {
        CloseHandle(hToken);
    }
    if (NULL != pISS)
    {
        pISS->RevertToSelf();
        pISS->Release();
    }    
    return(hr);
}


// Verify if impersonated user has the rights over the specified request,
// based on the officer rights defined in the global officer SD and the
// requester name retrieved from the request
//
// Return S_OK if allowed or if the officer rights feature is disabled
//        E_ACCESSDENIED if not allowed
//        E_* if failed to check the rights

HRESULT
CheckOfficerRightsFromAuthzCC(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzCCOfficer,
    IN WCHAR const *pwszRequesterName)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pOfficerSD = NULL;
    AUTHZ_ACCESS_REQUEST AuthzRequest;
    AUTHZ_ACCESS_REPLY AuthzReply;
    ACCESS_MASK GrantedMask;
    DWORD dwError = 0;
    DWORD dwSaclEval = 0;

    AuthzRequest.DesiredAccess = DELETE;
    AuthzRequest.PrincipalSelfSid = NULL;
    AuthzRequest.ObjectTypeList = NULL;
    AuthzRequest.ObjectTypeListLength = 0;
    
    AuthzRequest.OptionalArguments = (VOID *) pwszRequesterName;

    AuthzReply.ResultListLength = 1;
    AuthzReply.GrantedAccessMask  = &GrantedMask;
    AuthzReply.Error = &dwError;
    AuthzReply.SaclEvaluationResults = &dwSaclEval;
    

    hr = g_OfficerRightsSD.LockGet(&pOfficerSD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    CSASSERT(IsValidSecurityDescriptor(pOfficerSD));

    if (!AuthzAccessCheck(
		    0,
		    hAuthzCCOfficer,
		    &AuthzRequest,
		    NULL, //no audit
		    pOfficerSD,
		    NULL,
		    0,
		    &AuthzReply,
		    NULL))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzAccessCheck");
    }

    _PrintIfError(AuthzReply.Error[0], "AuthzAccessCheck");
    hr = AuthzReply.Error[0] == ERROR_SUCCESS?
				    S_OK : CERTSRV_E_RESTRICTEDOFFICER;

error:
    if (NULL != pOfficerSD)
    {
        g_OfficerRightsSD.Unlock();
    }
    return(hr);
}


HRESULT
CheckOfficerRightsFromOfficerName(
    IN WCHAR const *pwszOfficerName,
    IN WCHAR const *pwszRequesterName)
{
    HRESULT hr;
    PSID pSid = NULL;
    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzCCOfficer = NULL;

    // build authz context based on officer name passed in

    hr = GetAccountSid(pwszOfficerName, &pSid);
    _JumpIfErrorStr(hr, error, "GetAccountSid", pwszOfficerName);
    
    if (!AuthzInitializeContextFromSid(
			    0,
			    pSid,
			    g_AuthzCertSrvRM,
			    NULL,
			    s_luid, // ignored
			    NULL,
			    &hAuthzCCOfficer))
    {
	hr = myHError(GetLastError());
	_JumpError(hr, error, "AuthzInitializeContextFromSid");
    }
    hr = CheckOfficerRightsFromAuthzCC(hAuthzCCOfficer, pwszRequesterName);
    _JumpIfError(hr, error, "CheckOfficerRightsFromAuthzCC");

error:
    if (NULL != pSid)
    {
        LocalFree(pSid);
    }
    if (NULL != hAuthzCCOfficer)
    {
        AuthzFreeContext(hAuthzCCOfficer);
    }
    return(hr);
}

} // namespace CertSrv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\certsrvd.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certsrvd.cpp
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define SECURITY_WIN32
#include <security.h>

#include <lmcons.h>
#include <accctrl.h>

#include "certsrvd.h"
#include "admin.h"
#include "request.h"
#include "certacl.h"

//temporary
#include <msaudite.h>

#define __dwFILE__	__dwFILE_CERTSRV_CERTSRVD_CPP__


using namespace CertSrv;

// Global Access List
CCertificateAuthoritySD g_CASD;
AUTHZ_RESOURCE_MANAGER_HANDLE g_AuthzCertSrvRM;
DWORD g_dwAuditFilter;
COfficerRightsSD g_OfficerRightsSD;
CConfigStorage g_ConfigStorage;

GENERIC_MAPPING g_CertGenericMapping = {
    READ_CONTROL | ACTRL_DS_READ_PROP,     
    WRITE_DAC | WRITE_OWNER | ACTRL_DS_WRITE_PROP,     
    0, 
    ACTRL_DS_READ_PROP | 
        ACTRL_DS_WRITE_PROP | 
        READ_CONTROL | 
        WRITE_DAC | 
        WRITE_OWNER 
};


// GetClientUserName() impersonates the client

HRESULT
GetClientUserName(
    IN handle_t hRpc,
    OPTIONAL OUT WCHAR **ppwszUserSamName,
    OPTIONAL OUT WCHAR **ppwszUserDN)
{
    HRESULT hr;
    IServerSecurity *pISS = NULL;
    bool fImpersonating = false;
    WCHAR *pwszUserSamName = NULL;

    if (NULL != ppwszUserSamName)
    {
	*ppwszUserSamName = NULL;
    }
    if (NULL != ppwszUserDN)
    {
	*ppwszUserDN = NULL;
    }
    if (NULL == hRpc)
    {
        // dcom impersonate
        // get client info and impersonate client

        hr = CoGetCallContext(IID_IServerSecurity, (void**)&pISS);
        _JumpIfError(hr, error, "CoGetCallContext");

        hr = pISS->ImpersonateClient();
        _JumpIfError(hr, error, "ImpersonateClient");
    }
    else
    {
        // rpc impersonate

        hr = RpcImpersonateClient((RPC_BINDING_HANDLE) hRpc);
	_JumpIfError(hr, error, "RpcImpersonateClient");
    }
    fImpersonating = true;
    
    if (NULL != ppwszUserSamName)
    {
	hr = myGetUserNameEx(NameSamCompatible, &pwszUserSamName);
	_JumpIfError(hr, error, "myGetUserNameEx");
    }
    if (NULL != ppwszUserDN)
    {
	hr = myGetUserNameEx(NameFullyQualifiedDN, ppwszUserDN);
	_JumpIfError(hr, error, "myGetUserNameEx");
    }
    if (NULL != ppwszUserSamName)
    {
	*ppwszUserSamName = pwszUserSamName;
	pwszUserSamName = NULL;
    }
    hr = S_OK;

error:
    if (fImpersonating)
    {
        if (NULL != hRpc)
        {
            HRESULT hr2 = RpcRevertToSelf();
	    _PrintIfError(hr2, "RpcRevertToSelf");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
        }
        else  // dcom
        {
            pISS->RevertToSelf();
        }
    }
    if (NULL != pISS)
    {
        pISS->Release();
    }
    if (NULL != pwszUserSamName)
    {
	LocalFree(pwszUserSamName);
    }
    return(hr);
}

STDMETHODIMP
CheckCertSrvAccess(
    OPTIONAL IN LPCWSTR pwszAuthority,
    IN handle_t hRpc,
    IN ACCESS_MASK Mask,
    OUT BOOL *pfAccessAllowed,
    OPTIONAL OUT HANDLE *phToken)
{
    HRESULT            hr = S_OK;
    HANDLE             hClientToken = NULL;
    HANDLE             hThread = NULL;
    IServerSecurity   *pISS = NULL;
    PRIVILEGE_SET      ps;
    DWORD              dwPSSize = sizeof(PRIVILEGE_SET);
    DWORD              grantAccess;
    PSECURITY_DESCRIPTOR pCASD = NULL;
    bool fImpersonating = false;

    *pfAccessAllowed = FALSE;

    CSASSERT(hRpc);

    // If, for some reason, a certsrv call is made after we've shut down
    // security, we need to fail.

    if (!g_CASD.IsInitialized())
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
        _JumpError(hr, error, "Security not enabled");
    }

    if (NULL != pwszAuthority)
    {
	if (0 != mylstrcmpiL(pwszAuthority, g_wszCommonName))
        {   
            if (0 != mylstrcmpiL(pwszAuthority, g_wszSanitizedName) &&
   	        0 != mylstrcmpiL(pwszAuthority, g_pwszSanitizedDSName))
	    {
		hr = E_INVALIDARG;
		_PrintErrorStr(
			    hr,
			    "CheckCertSrvAccess: invalid authority name",
			    pwszAuthority);
		_JumpErrorStr(hr, error, "expected CA name", g_wszCommonName);
	    }
#ifdef DBG_CERTSRV_DEBUG_PRINT
	    if (0 == mylstrcmpiL(pwszAuthority, g_wszSanitizedName))
	    {
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "'%ws' called with Sanitized Name: '%ws'\n",
		    g_wszCommonName,
		    pwszAuthority));
	    }
	    else
	    if (0 == mylstrcmpiL(pwszAuthority, g_pwszSanitizedDSName))
	    {
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "'%ws' called with Sanitized DS Name: '%ws'\n",
		    g_wszCommonName,
		    pwszAuthority));
	    }
#endif
        }
    }

    // enforce encryption if enabled
    if(IF_ENFORCEENCRYPTICERTREQUEST & g_InterfaceFlags)
    {
        unsigned long ulAuthLevel;

        hr = RpcBindingInqAuthClient(
                hRpc,
                NULL, NULL,
                &ulAuthLevel,
                NULL, NULL);
        _JumpIfError(hr, error, "RpcBindingInqAuthClient");

        if(RPC_C_AUTHN_LEVEL_PKT_PRIVACY != ulAuthLevel)
        {
            hr = E_ACCESSDENIED;
            _JumpError(hr, error, "call not encrypted");
        }
    }

    // rpc impersonate
    hr = RpcImpersonateClient((RPC_BINDING_HANDLE) hRpc);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "RpcImpersonateClient");
    }

    fImpersonating = true;

    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
	_JumpIfError(hr, error, "GetCurrentThread");
    }

    if (!OpenThreadToken(hThread,
                         TOKEN_QUERY | TOKEN_DUPLICATE,
                         FALSE,  // client impersonation
                         &hClientToken))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "OpenThreadToken");
    }

    hr = g_CASD.LockGet(&pCASD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    
    if (!AccessCheck(
		    pCASD,		// security descriptor
		    hClientToken,	// handle to client access token
		    Mask,		// requested access rights 
		    &g_CertGenericMapping, // map generic to specific rights
		    &ps,		// receives privileges used
		    &dwPSSize,		// size of privilege-set buffer
		    &grantAccess,	// retrieves mask of granted rights
		    pfAccessAllowed))	// retrieves results of access check
    {
        hr = myHLastError();
        _JumpError(hr, error, "AccessCheckByType");
    }
    hr = S_OK;

    if(phToken)
    {
        *phToken = hClientToken;
        hClientToken = NULL;
    }

error:
    if(pCASD)
    {
        HRESULT hr2 = g_CASD.Unlock();
	_PrintIfError(hr2, "g_CASD.Unlock");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }

    if(fImpersonating)
    {
        if (NULL != hRpc) // rpc
        {
        HRESULT hr2 = RpcRevertToSelf();
        _PrintIfError(hr2, "RpcRevertToSelf");
        if (S_OK == hr)
        {
	        hr = hr2;
        }
        }
        else  // dcom
        {
            if (NULL != pISS)
            {
                pISS->RevertToSelf();
                pISS->Release();
            }
        }
    }
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    if (NULL != hClientToken)
    {
        CloseHandle(hClientToken);
    }
    return(hr);
}

HRESULT
CertStartClassFactories()
{
    HRESULT hr;

    if (0 == (IF_NOREMOTEICERTREQUEST & g_InterfaceFlags) ||
	0 == (IF_NOLOCALICERTREQUEST & g_InterfaceFlags))
    {
	hr = CRequestFactory::StartFactory();
	_JumpIfError(hr, error, "CRequestFactory::StartFactory");
    }

    if (0 == (IF_NOREMOTEICERTADMIN & g_InterfaceFlags) ||
	0 == (IF_NOLOCALICERTADMIN & g_InterfaceFlags))
    {
	hr = CAdminFactory::StartFactory();
	_JumpIfError(hr, error, "CAdminFactory::StartFactory");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	CRequestFactory::StopFactory();
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


VOID
CertStopClassFactories()
{
    CRequestFactory::StopFactory();
    CAdminFactory::StopFactory();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\admin.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        admin.h
//
// Contents:    Implementation of DCOM object for RPC services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------

// Admin Interface
class CCertAdminD : public ICertAdminD2
{
public:
    // IUnknown

    virtual STDMETHODIMP QueryInterface(const IID& iid, void**ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // ICertAdminD

    virtual STDMETHODIMP SetExtension(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwRequestId,
	IN wchar_t const *pwszExtensionName,
	IN DWORD          dwType,
	IN DWORD          dwFlags,
	IN CERTTRANSBLOB *ptbValue);

    virtual STDMETHODIMP SetAttributes(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwRequestId,
	IN wchar_t const *pwszAttributes);

    virtual STDMETHODIMP ResubmitRequest(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwRequestId,
	OUT DWORD        *pdwDisposition);

    virtual STDMETHODIMP DenyRequest(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwRequestId);

    virtual STDMETHODIMP IsValidCertificate(
	IN wchar_t const *pwszAuthority,
	IN wchar_t const *pwszSerialNumber,
	OUT LONG         *pRevocationReason,
	OUT LONG         *pDisposition);

    virtual STDMETHODIMP PublishCRL(
	IN wchar_t const *pwszAuthority,
	IN FILETIME       FileTime);

    virtual STDMETHODIMP GetCRL(
	IN  wchar_t const *pwszAuthority,
	OUT CERTTRANSBLOB *ptbCRL);

    virtual STDMETHODIMP RevokeCertificate(
	IN wchar_t const *pwszAuthority,
	IN wchar_t const *pwszSerialNumber,
	IN DWORD          Reason,
	IN FILETIME       FileTime);

    virtual STDMETHODIMP EnumViewColumn(
	IN  wchar_t const *pwszAuthority,
	IN  DWORD          iColumn,
	IN  DWORD          cColumn,
	OUT DWORD         *pcColumn,
	OUT CERTTRANSBLOB *ptbColumnInfo);

    virtual STDMETHODIMP GetViewDefaultColumnSet(
	IN  wchar_t const *pwszAuthority,
	IN  DWORD          iColumnSetDefault,
	OUT DWORD         *pcColumn,
	OUT CERTTRANSBLOB *ptbColumnInfo);

    virtual STDMETHODIMP EnumAttributesOrExtensions(
	IN          wchar_t const *pwszAuthority,
	IN          DWORD          RowId,
	IN          DWORD          Flags,
	OPTIONAL IN wchar_t const *pwszLast,
	IN          DWORD          celt,
	OUT         DWORD         *pceltFetched,
	OUT         CERTTRANSBLOB *pctbOut);

    virtual STDMETHODIMP OpenView(
	IN wchar_t const             *pwszAuthority,
	IN DWORD                      ccvr,
	IN CERTVIEWRESTRICTION const *acvr,
	IN DWORD                      ccolOut,
	IN DWORD const               *acolOut,
	IN DWORD                      ielt,
	IN DWORD                      celt,
	OUT DWORD                    *pceltFetched,
	OUT CERTTRANSBLOB            *pctbResultRows);

    virtual STDMETHODIMP EnumView(
	IN  wchar_t const *pwszAuthority,
	IN  DWORD          ielt,
	IN  DWORD          celt,
	OUT DWORD         *pceltFetched,
	OUT CERTTRANSBLOB *pctbResultRows);

    virtual STDMETHODIMP CloseView(
	IN wchar_t const *pwszAuthority);

    virtual STDMETHODIMP ServerControl(
	IN  wchar_t const *pwszAuthority,
	IN  DWORD          dwControlFlags,
	OUT CERTTRANSBLOB *pctbOut);

    virtual STDMETHODIMP Ping(	// test function
	IN wchar_t const *pwszAuthority);

    virtual STDMETHODIMP GetServerState(
	IN  WCHAR const *pwszAuthority,
	OUT DWORD       *pdwState);

    virtual STDMETHODIMP BackupPrepare(
	IN WCHAR const  *pwszAuthority,
	IN unsigned long grbit,
	IN unsigned long btBackupType,
	IN WCHAR const  *pwszBackupAnnotation,
	IN DWORD         dwClientIdentifier);

    virtual STDMETHODIMP BackupEnd();

    virtual STDMETHODIMP BackupGetAttachmentInformation(
	OUT WCHAR **ppwszzDBFiles,
	OUT LONG   *pcwcDBFiles);

    virtual STDMETHODIMP BackupGetBackupLogs(
	OUT WCHAR **ppwszzLogFiles,
	OUT LONG   *pcwcLogFiles);

    virtual STDMETHODIMP BackupOpenFile(
	IN  WCHAR const    *pwszPath,
	OUT unsigned hyper *pliLength);

    virtual STDMETHODIMP BackupReadFile(
	OUT BYTE *pbBuffer,
	IN  LONG  cbBuffer,
	OUT LONG *pcbRead);

    virtual STDMETHODIMP BackupCloseFile();

    virtual STDMETHODIMP BackupTruncateLogs();

    virtual STDMETHODIMP ImportCertificate( 
        IN wchar_t const *pwszAuthority,
        IN CERTTRANSBLOB *pctbCertificate,
        IN LONG dwFlags,
        OUT LONG *pdwRequestId);

    virtual STDMETHODIMP BackupGetDynamicFiles(
	OUT WCHAR **ppwszzFiles,
	OUT LONG   *pcwcFiles);

    virtual STDMETHODIMP RestoreGetDatabaseLocations(
	OUT WCHAR **ppwszDatabaseLocations,
	OUT LONG   *pcwcPaths);

    // ICertAdminD2

    virtual STDMETHODIMP PublishCRLs(
        IN wchar_t const *pwszAuthority,
	IN FILETIME       FileTime,
	IN DWORD          Flags);		// CA_CRL_*

    virtual STDMETHODIMP GetCAProperty(
	IN  wchar_t const *pwszAuthority,
	IN  LONG           PropId,		// CR_PROP_*
	IN  LONG           PropIndex,
	IN  LONG           PropType,		// PROPTYPE_*
	OUT CERTTRANSBLOB *pctbPropertyValue);

    virtual STDMETHODIMP SetCAProperty(
	IN  wchar_t const *pwszAuthority,
	IN  LONG           PropId,		// CR_PROP_*
	IN  LONG           PropIndex,
	IN  LONG           PropType,		// PROPTYPE_*
	OUT CERTTRANSBLOB *pctbPropertyValue);

    virtual STDMETHODIMP GetCAPropertyInfo(
	IN  wchar_t const *pwszAuthority,
	OUT LONG          *pcProperty,
	OUT CERTTRANSBLOB *pctbPropInfo);

    virtual STDMETHODIMP EnumViewColumnTable(
        IN  wchar_t const *pwszAuthority,
        IN  DWORD          iTable,
        IN  DWORD          iColumn,
        IN  DWORD          cColumn,
        OUT DWORD         *pcColumn,
	OUT CERTTRANSBLOB *pctbColumnInfo);

    virtual STDMETHODIMP GetCASecurity(
        IN  wchar_t const *pwszAuthority,
        OUT CERTTRANSBLOB *pctbSD);

    virtual STDMETHODIMP SetCASecurity(
        IN wchar_t const *pwszAuthority,
        IN CERTTRANSBLOB *pctbSD);

    // this is a test function
    virtual STDMETHODIMP Ping2(
        IN wchar_t const *pwszAuthority);

    virtual STDMETHODIMP GetArchivedKey(
        IN  wchar_t const *pwszAuthority,
	IN  DWORD	   dwRequestId,
	OUT CERTTRANSBLOB *pctbArchivedKey);

    virtual STDMETHODIMP GetAuditFilter(
	IN wchar_t const *pwszAuthority,
	OUT DWORD        *pdwFilter);

    virtual STDMETHODIMP SetAuditFilter(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwFilter);

    virtual STDMETHODIMP GetOfficerRights(
        IN  wchar_t const *pwszAuthority,
        OUT BOOL          *pfEnabled,
        OUT CERTTRANSBLOB *pctbSD);

    virtual STDMETHODIMP SetOfficerRights(
        IN wchar_t const *pwszAuthority,
        IN BOOL           fEnable,
        IN CERTTRANSBLOB *pctbSD);

    virtual STDMETHODIMP GetConfigEntry(
        IN wchar_t const *pwszAuthority,
        IN wchar_t const *pwszNodePath,
        IN wchar_t const *pwszEntry,
        OUT VARIANT      *pVariant);

    virtual STDMETHODIMP SetConfigEntry(
        IN wchar_t const *pwszAuthority,
        IN wchar_t const *pwszNodePath,
        IN wchar_t const *pwszEntry,
        IN VARIANT       *pVariant);

    virtual STDMETHODIMP ImportKey(
	IN wchar_t const *pwszAuthority,
	IN DWORD          RequestId,
	IN wchar_t const *pwszCertHash,
	IN DWORD          Flags,
	IN CERTTRANSBLOB *pctbKey);

    virtual STDMETHODIMP GetMyRoles(
	IN wchar_t const *pwszAuthority,
	OUT LONG         *pdwRoles);

    virtual STDMETHODIMP DeleteRow(
	IN wchar_t const *pwszAuthority,
	IN DWORD          dwFlags,		// CDR_*
	IN FILETIME       FileTime,
	IN DWORD          dwTable,		// CVRC_TABLE_*
	IN DWORD          dwRowId,
	OUT LONG         *pcDeleted);


    // CCertAdminD

    // Constructor
    CCertAdminD();

    // Destructor
    ~CCertAdminD();

private:
    HRESULT _EnumAttributes(
	IN ICertDBRow     *prow,
	IN CERTDBNAME     *adbn,
	IN DWORD           celt,
	OUT CERTTRANSBLOB *pctbOut);

    HRESULT _EnumExtensions(
	IN ICertDBRow     *prow,
	IN CERTDBNAME     *adbn,
	IN DWORD           celt,
	OUT CERTTRANSBLOB *pctbOut);

    HRESULT _EnumViewNext(
	IN  IEnumCERTDBRESULTROW *pview,
	IN  DWORD                 ielt,
	IN  DWORD                 celt,
	OUT DWORD                *pceltFetched,
	OUT CERTTRANSBLOB        *pctbResultRows);

    HRESULT _BackupGetFileList(
	IN  DWORD   dwFileType,
	OUT WCHAR **ppwszzFiles,
	OUT LONG   *pcwcFiles);

    HRESULT _GetDynamicFileList(
	IN OUT DWORD *pcwcList,
	OUT WCHAR    *pwszzList);

    HRESULT _GetDatabaseLocations(
	IN OUT DWORD *pcwcList,
	OUT WCHAR    *pwszzList);

    // this is a test function
    HRESULT _Ping(
        IN wchar_t const *pwszAuthority);

private:
    IEnumCERTDBCOLUMN    *m_pEnumCol;
    DWORD		  m_iTableEnum;

    ICertDBBackup        *m_pBackup;
    JET_GRBIT		  m_grbitBackup;

    BOOL		  m_fHasView;

    // Reference count
    long                  m_cRef;
    long                  m_cNext;
};


// Class of Admin factory
class CAdminFactory : public IClassFactory
{
public:
	// IUnknown
	virtual STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// Interface IClassFactory
	virtual STDMETHODIMP CreateInstance(
					IUnknown *pUnknownOuter,
					const IID& iid,
					void **ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock);

	// Constructor
	CAdminFactory() : m_cRef(1) { }

	// Destructor
	~CAdminFactory();

public:
    static STDMETHODIMP  CanUnloadNow();
    static STDMETHODIMP  StartFactory();
    static void     StopFactory();

private:
    long           m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\com.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        com.cpp
//
// Contents:    Cert Server Policy & Exit module callouts
//
// History:     7-Feb-97       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>

#include "csdisp.h"
#include "elog.h"
#include "certlog.h"
#include "cscom.h"
#include "csprop.h"

#include "com.h"

#define __dwFILE__	__dwFILE_CERTSRV_COM_CPP__


BSTR g_strPolicyDescription = NULL;
BOOL g_fEnablePolicy = FALSE;
MarshalInterface g_miPolicy;

typedef struct _CERTSRV_COM_CONTEXT_ENTRY
{
    USHORT               usFlags;
    CERTSRV_COM_CONTEXT *pComContext;
} CERTSRV_COM_CONTEXT_ENTRY;


// data structure to pass handles between server and policy/exit modules
CERTSRV_COM_CONTEXT_ENTRY *g_pComContextTable = NULL;
DWORD                      g_dwComContextCount = 0;
USHORT                     g_usComContextId = 0; // id increament
CRITICAL_SECTION           g_ComCriticalSection;
BOOL g_fComCritSec = FALSE;
CERTSRV_COM_CONTEXT       *g_pExitComContext = NULL;

// NOTE: GlobalInterfaceTable better to use than CoMarshalInterface


static IGlobalInterfaceTable*   g_pGIT = NULL;

// Clear out any error info
VOID
comClearError(VOID)
{
    IErrorInfo *pErrorInfo = NULL;

    if (S_OK == GetErrorInfo(0, &pErrorInfo))
    {
        if (NULL != pErrorInfo)
        {
            pErrorInfo->Release();
        }
    }
}

HRESULT
MarshalInterface::SetConfig(
    IN LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;
    if (NULL == pwszSanitizedName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "SetConfig");
    }

    m_szConfig = (LPWSTR) LocalAlloc(
				LMEM_FIXED,
				(wcslen(g_pwszServerName) + 1 + wcslen(pwszSanitizedName) + 1) * sizeof(WCHAR));
    if (NULL == m_szConfig)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // config comes to us without server name: add it
    wcscpy((LPWSTR)m_szConfig, g_pwszServerName);
    wcscat((LPWSTR)m_szConfig, L"\\");
    wcscat((LPWSTR)m_szConfig, pwszSanitizedName);

error:
    return hr;
}


HRESULT 
MarshalInterface::Initialize(
    IN WCHAR const *pwszProgID,
    IN CLSID const *pclsid,
    IN DWORD cver,
    IN IID const * const *ppiid,	// cver elements
    IN DWORD const *pcDispatch,		// cver elements
    IN DISPATCHTABLE *adt)
{
    HRESULT hr;

    if (NULL != pwszProgID)
    {
	m_pwszProgID = (LPWSTR) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszProgID) + 1) * sizeof(WCHAR));
        
        if (NULL == m_pwszProgID)
	{
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
       	wcscpy(m_pwszProgID, pwszProgID);
    }
    m_pclsid = pclsid;
    m_cver = cver;
    m_ppiid = ppiid;
    m_pcDispatch = pcDispatch;
    m_adt = adt;
    m_fIDispatch = FALSE;
    m_dwIFCookie = 0;
    m_fInitialized = TRUE;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
MarshalInterface::Setup(
    OUT DISPATCHINTERFACE **ppDispatchInterface)
{
    HRESULT hr;

    CSASSERT(m_fInitialized);
    *ppDispatchInterface = NULL;

    hr = DispatchSetup2(
		DISPSETUP_COMFIRST,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
		m_pwszProgID,
		m_pclsid,
		m_cver,
		m_ppiid,
		m_pcDispatch,
		m_adt,
		&m_DispatchInterface);

    // Don't complain if no class is registered.

    _JumpIfError2(
		hr,
		error,
		"DispatchSetup",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    m_fIDispatch = NULL != m_DispatchInterface.m_adispid;

    CSASSERT(
	0 < m_DispatchInterface.m_dwVersion &&
	m_cver >= m_DispatchInterface.m_dwVersion);
    m_iiid = m_cver - m_DispatchInterface.m_dwVersion;

    // create GIT if it doesn't yet exist
    if (NULL == g_pGIT)
    {
        hr = CoCreateInstance(
			    CLSID_StdGlobalInterfaceTable,
			    NULL,
			    CLSCTX_INPROC_SERVER,
			    IID_IGlobalInterfaceTable,
			    (void **) &g_pGIT);
        _JumpIfError(hr, error, "CoCreateInstance(GIT)");
    }

    hr = Marshal(&m_DispatchInterface);
    _JumpIfError(hr, error, "Marshal");

    *ppDispatchInterface = &m_DispatchInterface;

error:
    if (S_OK != hr)
    {
    	TearDown();
    }
    return(hr);
}


VOID
MarshalInterface::TearDown(VOID)
{
    if (m_fInitialized)
    {
        if (NULL != g_pGIT && 0 != m_dwIFCookie)
	{
	    g_pGIT->RevokeInterfaceFromGlobal(m_dwIFCookie);
	    m_dwIFCookie = 0;
	}
        DispatchRelease(&m_DispatchInterface);
	m_fInitialized = 0;
    }
    if (NULL != m_pwszProgID)
    {
        LocalFree(m_pwszProgID);
        m_pwszProgID = NULL;
    }
    
    if (NULL != m_szConfig)
    {
        LocalFree((LPWSTR)m_szConfig);
        m_szConfig = NULL;
    }
}


HRESULT
MarshalInterface::Marshal(
    IN DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr;

    CSASSERT(g_pGIT);
    if (g_pGIT == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpIfError(hr, error, "GlobalInterfaceTable not initialized");
    }

    hr = g_pGIT->RegisterInterfaceInGlobal(
			m_fIDispatch?
			    pDispatchInterface->pDispatch :
			    pDispatchInterface->pUnknown,
			m_fIDispatch? IID_IDispatch : *m_ppiid[m_iiid],
			&m_dwIFCookie);
    _JumpIfError(hr, error, "RegisterInterfaceInGlobal");

error:
    return(hr);
}


HRESULT
MarshalInterface::Remarshal(
    OUT DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr;

    DBGPRINT((DBG_SS_CERTSRVI, "Remarshal(tid=%d)\n", GetCurrentThreadId()));
    CSASSERT(m_fInitialized);

    pDispatchInterface->pDispatch = NULL;
    pDispatchInterface->pUnknown = NULL;

    CSASSERT(g_pGIT);
    if (g_pGIT == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpIfError(hr, error, "GlobalInterfaceTable not initialized");
    }

    hr = g_pGIT->GetInterfaceFromGlobal(
			m_dwIFCookie,
			m_fIDispatch? IID_IDispatch : *m_ppiid[m_iiid],
			m_fIDispatch?
			    (VOID **) &pDispatchInterface->pDispatch :
			    (VOID **) &pDispatchInterface->pUnknown);

    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "Remarshal(tid=%d) --> 0x%x\n",
	    GetCurrentThreadId(),
	    hr));

    _JumpIfError(hr, error, "GetInterfaceFromGlobal");

    // Copy invariants to the marshaled interface:
    
    pDispatchInterface->SetIID(m_ppiid[m_iiid]);
    pDispatchInterface->pDispatchTable = m_DispatchInterface.pDispatchTable;
    pDispatchInterface->m_cDispatchTable = m_DispatchInterface.m_cDispatchTable;
    pDispatchInterface->m_cdispid = m_DispatchInterface.m_cdispid;
    pDispatchInterface->m_adispid = m_DispatchInterface.m_adispid;

error:
    return(hr);
}


VOID
MarshalInterface::Unmarshal(
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    // Don't free global DISPID table from marshaled interface:

    pDispatchInterface->m_adispid = NULL;
    DispatchRelease(pDispatchInterface);
}


// forwards
VOID PolicyRelease(VOID);
VOID ExitRelease(VOID);


#define COMCONTEXTCOUNTMIN         4
#define COMCONTEXTCOUNTMAX      1024  // must less than 64K
#define COMCONTEXTCOUNTDEFAULT    20

HRESULT
ComInit(VOID)
{
    HRESULT  hr;
    HKEY  hKey = NULL;
    DWORD dwSize;

    CSASSERT(NULL == g_pComContextTable);

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, g_wszRegKeyConfigPath, &hKey);
    _JumpIfError(hr, error, "RegOpenKey(Config)");

    dwSize = sizeof(g_dwComContextCount);
    hr = RegQueryValueEx(
		    hKey,
		    wszREGDBSESSIONCOUNT, // just use db session count
                                          // bug, may not be logic related
		    NULL,
		    NULL,
		    (BYTE *) &g_dwComContextCount,
		    &dwSize);
    if (S_OK != hr)
    {
        _PrintErrorStr(hr, "RegQueryValueEx", wszREGDBSESSIONCOUNT);
        g_dwComContextCount = COMCONTEXTCOUNTDEFAULT;
    }
    if (COMCONTEXTCOUNTMIN > g_dwComContextCount)
    {
        g_dwComContextCount = COMCONTEXTCOUNTMIN;
    }
    if (COMCONTEXTCOUNTMAX < g_dwComContextCount)
    {
        g_dwComContextCount = COMCONTEXTCOUNTMAX;
    }

    g_pComContextTable = (CERTSRV_COM_CONTEXT_ENTRY *) LocalAlloc(
				     LMEM_FIXED | LMEM_ZEROINIT,
				     g_dwComContextCount *
					 sizeof(g_pComContextTable[0]));
    if (NULL == g_pComContextTable)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    __try
    {
	InitializeCriticalSection(&g_ComCriticalSection);
	g_fComCritSec = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return hr;
}


VOID
ComShutDown(VOID)
{
    if (NULL != g_pComContextTable)
    {
	PolicyRelease();
	ExitRelease();
	if (NULL != g_pGIT)
	{
	    g_pGIT->Release();
	    g_pGIT = NULL;
	}
	if (g_fComCritSec)
	{
	    DeleteCriticalSection(&g_ComCriticalSection);
	    g_fComCritSec = FALSE;
	}
        LocalFree(g_pComContextTable);
        g_pComContextTable = NULL;
        g_dwComContextCount = 0;
    }
}


HRESULT
RegisterComContext(
    IN CERTSRV_COM_CONTEXT *pComContext,
    IN OUT DWORD *pdwIndex)
{
    HRESULT  hr = S_OK;
    BOOL     fCS = FALSE;
    DWORD    i;

    CSASSERT(NULL != pComContext);
    CSASSERT(NULL != g_pComContextTable);

    if (NULL == pComContext)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "null com context pointer");
    }
    if (!g_fComCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ComCriticalSection);
    fCS = TRUE;

    for (i = 0; NULL != g_pComContextTable[i].pComContext; ++i)
    {
        if (i + 1 == g_dwComContextCount)
        {
            //hr = HRESULT_FROM_WIN32(ERROR_BUSY);
            hr = HRESULT_FROM_WIN32(RPC_S_SERVER_TOO_BUSY);
            _JumpError(hr, error, "com context table full");
        }
    }
    // pick an id
    if (0 == g_usComContextId)
    {
        // it could make module context to be 0 which is a special flag
        // avoid 0
        ++g_usComContextId;
    }
    g_pComContextTable[i].usFlags = g_usComContextId++;
    // point to com context
    g_pComContextTable[i].pComContext = pComContext;

    *pdwIndex = i;

error:
    if (fCS)
    {
        LeaveCriticalSection(&g_ComCriticalSection);
    }
    return hr;
}


VOID
ReleaseComContext(
    IN CERTSRV_COM_CONTEXT *pComContext)
{
    if (NULL != pComContext->pwszUserDN)
    {
	LocalFree(pComContext->pwszUserDN);
	pComContext->pwszUserDN = NULL;
    }
}


VOID
UnregisterComContext(
    IN CERTSRV_COM_CONTEXT *DBGCODE(pComContext),
    IN DWORD dwIndex)
{
    HRESULT hr = S_OK;
    BOOL fCS = FALSE;

    // if shutdown in progress after wait timeout
    
    if (NULL == g_pComContextTable)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "NULL g_pComContextTable");
    }
    CSASSERT(dwIndex < g_dwComContextCount);

    if (!g_fComCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&g_ComCriticalSection);
    fCS = TRUE;

    if (dwIndex < g_dwComContextCount)
    {
	CSASSERT(0 != g_pComContextTable[dwIndex].usFlags);
	CSASSERT(NULL != g_pComContextTable[dwIndex].pComContext);
	CSASSERT(pComContext == g_pComContextTable[dwIndex].pComContext);

	g_pComContextTable[dwIndex].usFlags = 0;
	g_pComContextTable[dwIndex].pComContext = NULL;
    }
error:
    if (fCS)
    {
        LeaveCriticalSection(&g_ComCriticalSection);
    }
}


CERTSRV_COM_CONTEXT *
GetComContextFromIndex(
    IN DWORD  dwIndex)
{
    CERTSRV_COM_CONTEXT *pComContext = NULL;

    CSASSERT(NULL != g_pComContextTable);
    CSASSERT(dwIndex < g_dwComContextCount);

    if (dwIndex < g_dwComContextCount)
    {
	CSASSERT(0 != g_pComContextTable[dwIndex].usFlags);
	CSASSERT(NULL != g_pComContextTable[dwIndex].pComContext);
	pComContext = g_pComContextTable[dwIndex].pComContext;
    }

    return(pComContext);
}


DWORD
ComContextToModuleContext(
    IN DWORD dwComContextIndex)
{
    CSASSERT(NULL != g_pComContextTable);
    CSASSERT(dwComContextIndex < g_dwComContextCount);
    CSASSERT(0 != g_pComContextTable[dwComContextIndex].usFlags);
    CSASSERT(NULL != g_pComContextTable[dwComContextIndex].pComContext);

    DWORD dwHigh =
        (dwComContextIndex << 16) & 0xFFFF0000; // move index to high 16 bits
    DWORD dwLow =
        ((DWORD)g_pComContextTable[dwComContextIndex].usFlags) & 0x0000FFFF;

    return(dwHigh | dwLow);
}


HRESULT
ModuleContextToComContextIndex(
    IN DWORD dwModuleContext,
    OUT DWORD *pdwIndex)
{
    HRESULT hr = S_OK;
    USHORT  usFlags = (USHORT)(dwModuleContext & 0x0000FFFF);
    DWORD   dwIndex = (dwModuleContext >> 16) & 0x0000FFFF;

    CSASSERT(NULL != pdwIndex);

    *pdwIndex = MAXDWORD;
    if (dwIndex >= g_dwComContextCount ||
	0 == usFlags ||
	g_pComContextTable[dwIndex].usFlags != usFlags)
    {
        // module passed a bogus handle
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid context from policy/exit");
    }
    CSASSERT(NULL != g_pComContextTable[dwIndex].pComContext);
    // for return
    *pdwIndex = dwIndex;

error:
    return hr;
}


HRESULT
ModuleContextToRequestId(
    IN DWORD dwModuleContext,
    OUT DWORD *pdwRequestId)
{
    DWORD   dwIndex;
    HRESULT hr = ModuleContextToComContextIndex(dwModuleContext, &dwIndex);
    _JumpIfError(hr, error, "ModuleContextToComContextIndex");

    // for return
    *pdwRequestId = g_pComContextTable[dwIndex].pComContext->RequestId;
error:
    return hr;
}


HRESULT
ComVerifyRequestContext(
    IN BOOL fAllowZero,
    IN DWORD Flags,
    IN LONG Context,
    OUT DWORD *pRequestId)
{
    HRESULT hr;
    
    *pRequestId = 0;
    if (0 == Context)
    {
	hr = S_OK;
	if (!fAllowZero)
	{
	    hr = E_HANDLE;
	}
    }
    else
    {
	switch (PROPCALLER_MASK & Flags)
	{
	    case PROPCALLER_EXIT:
		hr = ModuleContextToRequestId(Context, pRequestId);
                _JumpIfError(hr, error, "ModuleContextToRequestId");
		break;

	    case PROPCALLER_POLICY:
		hr = ModuleContextToRequestId(Context, pRequestId);
                _JumpIfError(hr, error, "ModuleContextToRequestId");
		break;

            default:
                CSASSERT(CSExpr(FALSE));
                hr = E_HANDLE;
                _JumpError(hr, error, "unexpected policy/exit flags");
                break;
	}
    }

error:
    return(hr);
}


BOOL
ComParseErrorPrefix(
    OPTIONAL IN WCHAR const *pwszIn,
    OUT HRESULT *phrPrefix,
    OUT WCHAR const **ppwszOut)
{
    BOOL fValid = FALSE;

    if (NULL != pwszIn && L'0' == pwszIn[0] && L'x' == pwszIn[1])
    {
	WCHAR const *pwsz = wcschr(pwszIn, L',');

	if (NULL != pwsz)
	{
	    WCHAR awchr[cwcDWORDSPRINTF];
	    DWORD cwc;

	    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszIn);
	    if (ARRAYSIZE(awchr) > cwc)
	    {
		CopyMemory(awchr, pwszIn, sizeof(WCHAR) * cwc);
		awchr[cwc] = L'\0';

		*phrPrefix = myWtoI(awchr, &fValid);
		if (fValid)
		{
		    while (L' ' == *++pwsz)
			;
		    *ppwszOut = pwsz;
		}
	    }
	}
    }
    return(fValid);
}


VOID
PatchFormatSpecifiers(
    IN OUT WCHAR *pwszError)
{
    for (;;)
    {
	WCHAR *pwsz;
	
	pwsz = wcschr(pwszError, L'%');
	if (NULL == pwsz)
	{
	    break;
	}
	if (L'1' <= pwsz[1] && L'9' >= pwsz[1])
	{
	    *pwsz = L'?';
	}
	pwsz += 2;
    }
}


VOID
LogComError(
    OPTIONAL IN WCHAR const *pwszModuleDescription,
    IN WCHAR const *pwszMethod,
    IN HRESULT ErrCode,
    IN BOOL fException,
    IN ULONG_PTR ExceptionAddress,
    IN IID const *piid,
    IN DWORD dwIdEvent)
{
    BSTR bstrErrorMessage = NULL;
    WCHAR const *pwszStringErr = NULL;

    if (CERTLOG_ERROR <= g_dwLogLevel)
    {
        HRESULT hr;
        WCHAR const *apwsz[5];
        WCHAR awchr[cwcHRESULTSTRING];
        WCHAR awcAddress[cwcULONG_INTEGERSPRINTF];

	apwsz[3] = L"";
        if (fException)
        {
	    wsprintf(awcAddress, L"0x%p", (VOID *) ExceptionAddress);
            apwsz[3] = awcAddress;
        }
        else
        {
            IErrorInfo *pErrorInfo = NULL;

            // Get the error info

            hr = GetErrorInfo(0, &pErrorInfo);
            if (S_OK == hr && NULL != pErrorInfo)
	    {
		GUID ErrorGuid;

		hr = pErrorInfo->GetGUID(&ErrorGuid);
		if (S_OK == hr && InlineIsEqualGUID(ErrorGuid, *piid))
		{
		    hr = pErrorInfo->GetDescription(&bstrErrorMessage);
		    if (S_OK == hr && NULL != bstrErrorMessage)
		    {
			WCHAR const *pwszT = NULL;

			myRegisterMemAlloc(bstrErrorMessage, -1, CSM_SYSALLOC);

			if (S_OK != ErrCode ||
			    !ComParseErrorPrefix(
					    bstrErrorMessage,
					    &ErrCode,
					    &pwszT))
			{
			    pwszT = bstrErrorMessage;
			}
			if (NULL != pwszT)
			{
			    apwsz[3] = pwszT;
			}
		    }
		}
		SetErrorInfo(0, pErrorInfo);
		pErrorInfo->Release();
            }
        }

	if (S_OK == ErrCode)
	{
	    if (!fException && NULL == bstrErrorMessage)
	    {
		goto error; // skip if no error, no exception & no com error
	    }

	    // This is the best generic fit for policy module initialization.
	    // Hopefully it's generic enough to not be too confusing.

	    ErrCode = CRYPT_E_NOT_FOUND;
	    _PrintError(ErrCode, "Invented ErrCode");
	}

        apwsz[0] = NULL != pwszModuleDescription? pwszModuleDescription : L"";
        apwsz[1] = pwszMethod;

        // some errors like textual conversions.  no HRESULT pasted on here

	pwszStringErr = myGetErrorMessageText(ErrCode, FALSE);
	PatchFormatSpecifiers(const_cast<WCHAR *>(pwszStringErr));
        apwsz[2] = myHResultToStringRaw(awchr, ErrCode);
	apwsz[4] = pwszStringErr == NULL? L"" : pwszStringErr;

        hr = LogEvent(EVENTLOG_ERROR_TYPE, dwIdEvent, ARRAYSIZE(apwsz), apwsz);
        _PrintIfError(hr, "LogEvent");
    }

error:
    if (NULL != bstrErrorMessage)
    {
	SysFreeString(bstrErrorMessage);
    }
    if (NULL != pwszStringErr)
    {
	LocalFree(const_cast<WCHAR *>(pwszStringErr));
    }
}


VOID
LogPolicyError(
    IN HRESULT ErrCode,
    IN WCHAR const *pwszMethod,
    IN BOOL fException,
    IN ULONG_PTR ExceptionAddress)
{
    LogComError(
	    g_strPolicyDescription,
	    pwszMethod,
	    ErrCode,
	    fException,
	    ExceptionAddress,
	    &IID_ICertPolicy,
	    fException? MSG_E_POLICY_EXCEPTION : MSG_E_POLICY_ERROR);
}


VOID
LogExitError(
    IN HRESULT ErrCode,
    IN WCHAR const *pwszDescription,
    IN WCHAR const *pwszMethod,
    IN BOOL fException,
    IN ULONG_PTR ExceptionAddress)
{
    LogComError(
	    pwszDescription,
	    pwszMethod,
	    ErrCode,
	    fException,
	    ExceptionAddress,
	    &IID_ICertExit,
	    fException? MSG_E_EXIT_EXCEPTION : MSG_E_EXIT_ERROR);
}




HRESULT
PolicyInit(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    DISPATCHINTERFACE *pdiPolicy;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress = NULL;
    WCHAR const *pwszPolicyMethod = L"";

    // support installable modules
    CLSID clsidPolicy;
    LPOLESTR lpszProgID = NULL;

    DBGPRINT((DBG_SS_CERTSRVI, "PolicyInit: tid=%d\n", GetCurrentThreadId()));

    comClearError();
    hr = S_OK;
    __try
    {
	// get active module
	hr = myGetActiveModule(
			NULL,
			pwszSanitizedName,
			TRUE,
			0,
			&lpszProgID,
			&clsidPolicy);
	_LeaveIfError(hr, "myGetActiveModule");
	
	hr = g_miPolicy.Initialize(
		    lpszProgID, 
		    &clsidPolicy, 
		    ARRAYSIZE(s_acPolicyDispatch),
		    s_apPolicyiid,
		    s_acPolicyDispatch,
		    g_adtPolicy);
    _LeaveIfError(hr, "MarshalInterface::Initialize");

	// free olestr
	CoTaskMemFree(lpszProgID);

	hr = g_miPolicy.SetConfig(pwszConfig);
	_LeaveIfError(hr, "SetConfig");

	hr = g_miPolicy.Setup(&pdiPolicy);

	// Don't complain if no class is registered.
	_LeaveIfError2(hr, "Setup", HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

	pwszPolicyMethod = L"GetDescription";
	hr = Policy_GetDescription(pdiPolicy, &g_strPolicyDescription);
	_PrintIfError(hr, "Policy_GetDescription");

	pwszPolicyMethod = L"Initialize";
	hr = Policy_Initialize(pdiPolicy, pwszConfig);
	_LeaveIfError(hr, "Policy_Initialize");

	g_fEnablePolicy = TRUE;	// we have a policy module loaded now

	hr = S_OK;

	CONSOLEPRINT1((
	    DBG_SS_CERTSRV,
	    "Policy Module Enabled (%ws)\n",
	    g_strPolicyDescription));
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Initialize: Exception");
	fException = TRUE;
    }

//error:
    LogPolicyError(hr, pwszPolicyMethod, fException, ExceptionAddress);
    return(hr);
}



VOID
PolicyRelease(VOID)
{
    HRESULT hr = S_OK;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress = NULL;

    DBGPRINT((DBG_SS_CERTSRV, "PolicyRelease: tid=%d\n", GetCurrentThreadId()));

    comClearError();
    __try
    {
        // if we loaded a policy module
        if (g_fEnablePolicy)
        {
            DISPATCHINTERFACE diPolicy;
            
            hr = g_miPolicy.Remarshal(&diPolicy);
            _PrintIfError(hr, "Remarshal");
            
            if (hr == S_OK)
            {
                Policy_ShutDown(&diPolicy);
		g_miPolicy.Unmarshal(&diPolicy);
            }
            g_fEnablePolicy = FALSE;
        }

        if (NULL != g_strPolicyDescription)
        {
            SysFreeString(g_strPolicyDescription);
            g_strPolicyDescription = NULL;
        }
        
        g_miPolicy.TearDown();
        
    } 
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "ShutDown: Exception");
	fException = TRUE;
    }

    LogPolicyError(hr, L"ShutDown", fException, ExceptionAddress);
}


HRESULT
PolicyVerifyRequest(
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN LONG Flags,
    IN BOOL fNewRequest,
    OPTIONAL IN CERTSRV_RESULT_CONTEXT const *pResult,
    IN DWORD dwComContextIndex,
    OUT LPWSTR *ppwszDispositionMessage, // LocalAlloced.
    OUT DWORD *pVerifyStatus) // VR_PENDING || VR_INSTANT_OK || VR_INSTANT_BAD
{
    HRESULT hr;
    ULONG_PTR ExceptionAddress = NULL;
    DWORD rc;
    LONG Result;
    DISPATCHINTERFACE diPolicy;
    BOOL fMustRelease = FALSE;
    BSTR bstrDispositionDetail = NULL;
    CERTSRV_COM_CONTEXT *pComContext;

    comClearError();

    if (!g_fEnablePolicy)
    {
	hr = S_OK;
	rc = VR_INSTANT_OK;
	goto error;
    }
    rc = VR_INSTANT_BAD;

    hr = g_miPolicy.Remarshal(&diPolicy);
    _JumpIfError(hr, error, "Remarshal");

    fMustRelease = TRUE;

    pComContext = GetComContextFromIndex(dwComContextIndex);
    if (NULL == pComContext)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL com context");
    }
    pComContext->RequestId = RequestId;
    if (NULL != pResult)
    {
	pComContext->dwFlags |= CCCF_KEYARCHIVEDSET;
	if (NULL != pResult->pbArchivedKey)
	{
	    pComContext->dwFlags |= CCCF_KEYARCHIVED;
	}
    }
    __try
    {
	hr = Policy_VerifyRequest(
			    &diPolicy,
			    pwszConfig,
			    ComContextToModuleContext(dwComContextIndex),
			    fNewRequest,
			    Flags,
			    &Result);
	_LeaveIfError(hr, "Policy_VerifyRequest");

	switch (Result)
	{
	    default:
		if (SUCCEEDED(Result))
		{
		    hr = E_INVALIDARG;
		    _LeaveError(Result, "Result");
		}
		// FALLTHROUGH

	    case VR_PENDING:
	    case VR_INSTANT_OK:
	    case VR_INSTANT_BAD:
		rc = Result;
		break;
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
        _PrintError(hr, "VerifyRequest: Exception");
	LogPolicyError(hr, L"VerifyRequest", TRUE, ExceptionAddress);
    }
    pComContext->RequestId = 0;

error:

    // Errors will be logged at the coreVerifyRequest level

    if (NULL != ppwszDispositionMessage)
    {
        HRESULT hr2;
	IErrorInfo *pErrorInfo = NULL;

        *ppwszDispositionMessage = NULL;
        hr2 = GetErrorInfo(0, &pErrorInfo);
        if (S_OK == hr2 && NULL != pErrorInfo)
	{
	    GUID ErrorGuid;

	    hr2 = pErrorInfo->GetGUID(&ErrorGuid);
	    if (S_OK == hr2 && InlineIsEqualGUID(ErrorGuid, IID_ICertPolicy))
	    {
		hr2 = pErrorInfo->GetDescription(&bstrDispositionDetail);
		if (S_OK == hr2 && NULL != bstrDispositionDetail)
		{
		    myRegisterMemAlloc(bstrDispositionDetail, -1, CSM_SYSALLOC);
		    *ppwszDispositionMessage = (LPWSTR) LocalAlloc(
			LMEM_FIXED,
			SysStringByteLen(bstrDispositionDetail) + sizeof(WCHAR));

		    if (NULL != *ppwszDispositionMessage)
		    {
			wcscpy(*ppwszDispositionMessage, bstrDispositionDetail);
		    }
		    SysFreeString(bstrDispositionDetail);
		}
	    }
	    SetErrorInfo(0, pErrorInfo);
	    pErrorInfo->Release();
        }
    }

    if (fMustRelease)
    {
	g_miPolicy.Unmarshal(&diPolicy);
    }
    *pVerifyStatus = rc;
    return(hr);
}

typedef struct _EXITMOD
{
    MarshalInterface *pmi;
    BOOL              fEnabled;
    BSTR              strDescription;
    LONG	      EventMask;
} EXITMOD;

BOOL g_fEnableExit = FALSE;
EXITMOD *g_aExitMod = NULL;
DWORD g_cExitMod;
LONG g_ExitEventMask;
TCHAR g_wszRegKeyExitClsid[] = wszCLASS_CERTEXIT TEXT("\\Clsid");

VOID
ExitModRelease(
    OPTIONAL IN OUT EXITMOD *pExitMod)
{
    HRESULT hr;
    
    if (NULL != pExitMod)
    {
	MarshalInterface *pmiExit = pExitMod->pmi;

	if (NULL != pmiExit)
	{
	    hr = S_OK;
	    __try
	    {
		pmiExit->TearDown();
	    }
	    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	    {
		_PrintIfError(hr, "TearDown");
	    }
	    delete pmiExit;
	    pExitMod->pmi = NULL;
	} 
	if (NULL != pExitMod->strDescription)
	{
	    SysFreeString(pExitMod->strDescription);
	    pExitMod->strDescription = NULL;
	}
    }
}

HRESULT
ExitModInit(
    IN WCHAR const *pwszProgId,
    IN CLSID const *pclsid,
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    EXITMOD *pExitMod = NULL;
    DISPATCHINTERFACE *pdiExit;
    MarshalInterface *pmiExit;
    CERTSRV_COM_CONTEXT ComContext;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress = NULL;

    comClearError();
    hr = S_OK;
    __try
    {
	if (0 == g_cExitMod)
	{
	    pExitMod = (EXITMOD *) LocalAlloc(LMEM_FIXED, sizeof(*g_aExitMod));
	}
	else
	{
	    pExitMod = (EXITMOD *) LocalReAlloc(
					g_aExitMod,
					(g_cExitMod + 1) * sizeof(*g_aExitMod),
					LMEM_MOVEABLE);
	}
	if (NULL == pExitMod)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, 0 == g_cExitMod? "LocalAlloc" : "LocalReAlloc");
	}
	g_aExitMod = pExitMod;
	pExitMod += g_cExitMod++;

	// Zero structure here because a previous failed Exit Module load may
	// leave garbage in leftover structure, causing LocalReAlloc to do
	// nothing.

	ZeroMemory(pExitMod, sizeof(*pExitMod));

	pmiExit = new MarshalInterface;
	if (NULL == pmiExit)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "new");
	}
	pExitMod->pmi = pmiExit;

	hr = pmiExit->Initialize(
			pwszProgId, 
			pclsid, 
			ARRAYSIZE(s_acExitDispatch),
			s_apExitiid,
			s_acExitDispatch,
			g_adtExit);
	_JumpIfError(hr, error, "MarshalInterface::Initialize");

	hr = pmiExit->SetConfig(pwszConfig);
	_JumpIfError(hr, error, "SetConfig");

	hr = pmiExit->Setup(&pdiExit);

	// Don't complain if no class is registered.
	_JumpIfError2(hr, error, "Setup", HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

	ComContext.iExitModActive = g_cExitMod - 1;
	g_pExitComContext = &ComContext;

	hr = Exit_GetDescription(pdiExit, &pExitMod->strDescription);
	_PrintIfError(hr, "Exit_GetDescription");

	hr = Exit_Initialize(
			pdiExit,
			pwszConfig,
			&pExitMod->EventMask);
	_JumpIfError(hr, error, "Exit_Initialize");

	pExitMod->fEnabled = TRUE;
	g_fEnableExit = TRUE;	// we have at least one exit module loaded now

	g_ExitEventMask |= pExitMod->EventMask;

	hr = S_OK;

	CONSOLEPRINT3((
	    DBG_SS_CERTSRV,
	    "Exit Module[%d] Enabled: %x (%ws)\n",
	    g_cExitMod,
	    pExitMod->EventMask,
	    pExitMod->strDescription));
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Initialize: Exception");
	fException = TRUE;
    }

error:
    LogExitError(
	    hr,
	    NULL != pExitMod? pExitMod->strDescription : NULL,
	    L"Initialize",
	    fException,
	    ExceptionAddress);

    if (S_OK != hr && NULL != pExitMod)
    {
	ExitModRelease(pExitMod);
	CSASSERT(0 != g_cExitMod);
	g_cExitMod--;
    }
    // reset
    g_pExitComContext = NULL;
    return(hr);
}


HRESULT
ExitModNotify(
    IN EXITMOD *pExitMod,
    IN LONG Event,
    IN LONG RequestId,
    IN DWORD dwComContextIndex)
{
    HRESULT hr;
    DISPATCHINTERFACE diExit;
    BOOL fMustRelease = FALSE;
    CERTSRV_COM_CONTEXT *pComContext;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress = NULL;

    comClearError();
    hr = S_OK;
    __try
    {
	if (!pExitMod->fEnabled || 0 == (Event & pExitMod->EventMask))
	{
	    goto error;
	}
	hr = pExitMod->pmi->Remarshal(&diExit);
	_JumpIfError(hr, error, "Remarshal");

	fMustRelease = TRUE;

	pComContext = GetComContextFromIndex(dwComContextIndex);
	if (NULL == pComContext)
	{
	    hr = E_HANDLE;
	    _JumpError(hr, error, "null com context");
	}
	pComContext->RequestId = RequestId;

	hr = Exit_Notify(
		    &diExit,
		    Event,
		    ComContextToModuleContext(dwComContextIndex));

	pComContext->RequestId = 0;

	if (S_OK != hr)
	{
	    //_PrintError(hr, "Exit_Notify");
	    goto error;
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Notify: Exception");
	fException = TRUE;
    }

error:
    LogExitError(
	    hr,
	    pExitMod->strDescription,
	    L"Notify",
	    fException,
	    ExceptionAddress);

    if (fMustRelease)
    {
	pExitMod->pmi->Unmarshal(&diExit);
    }
    return(hr);
}


HRESULT
ExitInit(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    LPOLESTR pwszProgId = NULL;
    CLSID clsid;
    DWORD i;

    CSASSERT(NULL == g_aExitMod);
    CSASSERT(0 == g_cExitMod);
    CSASSERT(0 == g_ExitEventMask);
    CSASSERT(!g_fEnableExit);

    for (i = 0; ; i++)
    {
	if (NULL != pwszProgId)
	{
	    CoTaskMemFree(pwszProgId);
	    pwszProgId = NULL;
	}

	// get active module
	hr = myGetActiveModule(
                        NULL,
			pwszSanitizedName,
			FALSE,
			i,
			&pwszProgId,
			&clsid);
	_JumpIfError(hr, error, "myGetActiveModule");

	hr = ExitModInit(pwszProgId, &clsid, pwszConfig);
	_PrintIfError(hr, "ExitModInit");
    }
    // NOTREACHED
	
error:
    if (NULL != pwszProgId)
    {
	CoTaskMemFree(pwszProgId);
    }
    return(hr);
}


VOID
ExitRelease(VOID)
{
    ExitNotify(EXITEVENT_SHUTDOWN, 0, NULL, MAXDWORD);
    for ( ; 0 != g_cExitMod; g_cExitMod--)
    {
	ExitModRelease(&g_aExitMod[g_cExitMod - 1]);
    }
    
    if (g_aExitMod)
    {
        LocalFree(g_aExitMod);
        g_aExitMod = NULL;
    }
}


HRESULT
ExitNotify(
    IN LONG Event,
    IN LONG RequestId,
    OPTIONAL IN CERTSRV_RESULT_CONTEXT const *pResult,
    IN DWORD dwComContextIndex)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    CERTSRV_COM_CONTEXT ComContext;
    CERTSRV_COM_CONTEXT *pComContext;
    BOOL fRegComContext = FALSE;

    if (MAXDWORD == dwComContextIndex)
    {
	ZeroMemory(&ComContext, sizeof(ComContext));
	pComContext = &ComContext;
        hr = RegisterComContext(pComContext, &dwComContextIndex);
        _JumpIfError(hr, error, "RegisterComContext");

        fRegComContext = TRUE;
    }
    else
    {
        pComContext = GetComContextFromIndex(dwComContextIndex);
        if (NULL == pComContext)
        {
            hr = E_HANDLE;
            _JumpError(hr, error, "null com context");
        }
    }
    if (NULL != pResult)
    {
	pComContext->dwFlags |= CCCF_KEYARCHIVEDSET;
	if (NULL != pResult->pbArchivedKey)
	{
	    pComContext->dwFlags |= CCCF_KEYARCHIVED;
	}
    }
    CSASSERT(0 == (Event & (Event >> 1)));	// must be a single bit!
    if (!g_fEnableExit || 0 == (Event & g_ExitEventMask))
    {
	goto error;
    }
    for (
	pComContext->iExitModActive = 0;
	pComContext->iExitModActive < g_cExitMod;
	pComContext->iExitModActive++)
    {
	hr2 = ExitModNotify(
			&g_aExitMod[pComContext->iExitModActive],
			Event,
			RequestId,
			dwComContextIndex);
	if (S_OK == hr)
	{
	    hr = hr2;
	}
        _PrintIfError(hr2, "ExitModNotify");
    }

error:
    if (fRegComContext)
    {
        // context is used in local
        UnregisterComContext(&ComContext, dwComContextIndex);
    }
    else if (NULL != pComContext)
    {
        // return index
        pComContext->iExitModActive = 0;
    }
    return(hr);
}


HRESULT
ExitGetActiveModule(
    IN LONG Context,
    OUT MarshalInterface **ppmi)
{
    HRESULT hr;

    // This is for exit module only, it expects Context
    // to be 0. It will use g_pExitComContext instead of table

    // init
    *ppmi = NULL;

#if 0
    DWORD    dwIndex;
    hr = ModuleContextToComContextIndex(Context, &dwIndex);
    _JumpIfError(hr, error, "ModuleContextToComContextIndex");
    // return
    *ppmi = 
    g_aExitMod[g_pComContextTable[dwIndex].pComContext->iExitModActive].pmi;
#endif

    CSASSERT(0 == Context);
    CSASSERT(NULL != g_pExitComContext);
    if (0 != Context || NULL == g_pExitComContext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "unexpected exit context");
    }

    // return
    *ppmi = g_aExitMod[g_pExitComContext->iExitModActive].pmi;
    hr = S_OK;

error:
    return (hr);
}


HRESULT
ComGetClientInfo(
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OUT CERTSRV_COM_CONTEXT **ppComContext)
{
    HRESULT hr;

    *ppComContext = NULL;

    if (MAXDWORD == dwComContextIndex)
    {
	hr = ModuleContextToComContextIndex(Context, &dwComContextIndex);
	_JumpIfError(hr, error, "ModuleContextToComContextIndex");
    }
    *ppComContext = g_pComContextTable[dwComContextIndex].pComContext;
    hr = S_OK;

error:
    return(hr);
}


BSTR
ExitGetDescription(
    IN DWORD iExitMod)
{
    BSTR str = NULL;

    if (iExitMod < g_cExitMod)
    {
	str = g_aExitMod[iExitMod].strDescription;
    }
    return(str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\crl.cpp ===
//+-------------------------------------------------------------------------n-
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crl.cpp
//
// Contents:    Cert Server CRL processing
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <esent.h>

#include "cscom.h"
#include "csprop.h"

#include "dbtable.h"
#include "resource.h"

#include "elog.h"
#include "certlog.h"

#include <winldap.h>
#include "csldap.h"
#include "cainfop.h"

#define __dwFILE__	__dwFILE_CERTSRV_CRL_CPP__

HANDLE g_hCRLManualPublishEvent = NULL;

FILETIME g_ftCRLNextPublish;
FILETIME g_ftDeltaCRLNextPublish;

BOOL g_fCRLPublishDisabled = FALSE;	 // manual publishing always allowed
BOOL g_fDeltaCRLPublishDisabled = FALSE; // controls manual publishing, too

DWORD g_dwCRLFlags = CRLF_DELETE_EXPIRED_CRLS;
LDAP *g_pld = NULL;

typedef struct _CSMEMBLOCK
{
    struct _CSMEMBLOCK *pNext;
    BYTE               *pbFree;
    DWORD               cbFree;
} CSMEMBLOCK;

#define CBMEMBLOCK	4096


typedef struct _CSCRLELEMENT
{
    USHORT   usRevocationReason;
    USHORT   uscbSerialNumber;
    BYTE    *pbSerialNumber;
    FILETIME ftRevocationDate;
} CSCRLELEMENT;


// size the structure just under CBMEMBLOCK to keep it from being just over
// a page size.

#define CCRLELEMENT  ((CBMEMBLOCK - 2 * sizeof(DWORD)) / sizeof(CSCRLELEMENT))

typedef struct _CSCRLBLOCK
{
    struct _CSCRLBLOCK *pNext;
    DWORD	        cCRLElement;
    CSCRLELEMENT        aCRLElement[CCRLELEMENT];
} CSCRLBLOCK;


typedef struct _CSCRLREASON
{
    struct _CSCRLREASON *pNext;
    DWORD                RevocationReason;
    CERT_EXTENSION       ExtReason;
} CSCRLREASON;


typedef struct _CSCRLPERIOD
{
    LONG lCRLPeriodCount;
    ENUM_PERIOD enumCRLPeriod;
    DWORD dwCRLOverlapMinutes;
} CSCRLPERIOD;


#ifdef DBG_CERTSRV_DEBUG_PRINT
# define DPT_DATE	1
# define DPT_DELTA	2
# define DPT_DELTASEC	3
# define DPT_DELTAMS	4

# define DBGPRINTTIME(pfDelta, pszName, Type, ft) \
    DbgPrintTime((pfDelta), (pszName), __LINE__, (Type), (ft))

VOID
DbgPrintTime(
    OPTIONAL IN BOOL const *pfDelta,
    IN char const *pszName,
    IN DWORD Line,
    IN DWORD Type,
    IN FILETIME ft)
{
    HRESULT hr;
    WCHAR *pwszTime = NULL;
    WCHAR awc[1];
    LLFILETIME llft;
    
    llft.ft = ft;
    if (Type == DPT_DATE)
    {
	if (0 != llft.ll)
	{
	    hr = myGMTFileTimeToWszLocalTime(&ft, TRUE, &pwszTime);
	    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
	}
    }
    else
    {
	if (DPT_DELTAMS == Type)
	{
	    llft.ll /= 1000;		// milliseconds to seconds
	    Type = DPT_DELTASEC;
	}
	if (DPT_DELTASEC == Type)
	{
	    llft.ll *= CVT_BASE;	// seconds to FILETIME period
	}
	llft.ll = -llft.ll;		// FILETIME Period must be negative

	if (0 != llft.ll)
	{
	    hr = myFileTimePeriodToWszTimePeriod(
			    &llft.ft,
			    TRUE,	// fExact
			    &pwszTime);
	    _PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");
	}
    }
    if (NULL == pwszTime)
    {
	awc[0] = L'\0';
	pwszTime = awc;
    }

    DBGPRINT((
	DBG_SS_CERTSRVI,
	"%hs(%d):%hs time(%hs): %lx:%08lx %ws\n",
	"crl.cpp",
	Line,
	NULL == pfDelta? "" : (*pfDelta? " Delta CRL" : " Base CRL"),
	pszName,
	ft.dwHighDateTime,
	ft.dwLowDateTime,
	pwszTime));

//error:
    if (NULL != pwszTime && awc != pwszTime)
    {
	LocalFree(pwszTime);
    }
}


VOID
CertSrvDbgPrintTime(
    IN char const *pszDesc,
    IN FILETIME const *pftGMT)
{
    HRESULT hr;
    WCHAR *pwszTime = NULL;
    WCHAR awc[1];

    hr = myGMTFileTimeToWszLocalTime(pftGMT, TRUE, &pwszTime);
    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
    if (S_OK != hr)
    {
	awc[0] = L'\0';
	pwszTime = awc;
    }
    DBGPRINT((DBG_SS_CERTSRV, "%hs: %ws\n", pszDesc, pwszTime));

//error:
    if (NULL != pwszTime && awc != pwszTime)
    {
	LocalFree(pwszTime);
    }
}
#else // DBG_CERTSRV_DEBUG_PRINT
# define DBGPRINTTIME(pfDelta, pszName, Type, ft)
#endif // DBG_CERTSRV_DEBUG_PRINT


HRESULT
crlMemBlockAlloc(
    IN OUT CSMEMBLOCK **ppBlock,
    IN DWORD cb,
    OUT BYTE **ppb)
{
    HRESULT hr;
    CSMEMBLOCK *pBlock = *ppBlock;

    *ppb = NULL;
    cb = POINTERROUND(cb);
    if (NULL == pBlock || cb > pBlock->cbFree)
    {
	pBlock = (CSMEMBLOCK *) LocalAlloc(LMEM_FIXED, CBMEMBLOCK);
        if (NULL == pBlock)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
	pBlock->pNext = *ppBlock;
	pBlock->pbFree = (BYTE *) Add2Ptr(pBlock, sizeof(CSMEMBLOCK));
	pBlock->cbFree = CBMEMBLOCK - sizeof(CSMEMBLOCK);
	*ppBlock = pBlock;
    }
    CSASSERT(cb <= pBlock->cbFree);
    *ppb = pBlock->pbFree;
    pBlock->pbFree += cb;
    pBlock->cbFree -= cb;
    hr = S_OK;

error:
    return(hr);
}


VOID
crlBlockListFree(
    IN OUT CSMEMBLOCK *pBlock)
{
    CSMEMBLOCK *pBlockNext;

    while (NULL != pBlock)
    {
	pBlockNext = pBlock->pNext;
	LocalFree(pBlock);
	pBlock = pBlockNext;
    }
}


HRESULT
crlElementAlloc(
    IN OUT CSCRLBLOCK **ppBlock,
    OUT CSCRLELEMENT **ppCRLElement)
{
    HRESULT hr;
    CSCRLBLOCK *pBlock = *ppBlock;

    *ppCRLElement = NULL;
    if (NULL == pBlock ||
	ARRAYSIZE(pBlock->aCRLElement) <= pBlock->cCRLElement)
    {
	pBlock = (CSCRLBLOCK *) LocalAlloc(LMEM_FIXED, sizeof(*pBlock));
        if (NULL == pBlock)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
	pBlock->pNext = *ppBlock;
	pBlock->cCRLElement = 0;
	*ppBlock = pBlock;
    }
    CSASSERT(ARRAYSIZE(pBlock->aCRLElement) > pBlock->cCRLElement);
    *ppCRLElement = &pBlock->aCRLElement[pBlock->cCRLElement++];
    hr = S_OK;

error:
    return(hr);
}


VOID
crlFreeCRLArray(
    IN OUT VOID *pvBlockSerial,
    IN OUT CRL_ENTRY *paCRL)
{
    crlBlockListFree((CSMEMBLOCK *) pvBlockSerial);
    if (NULL != paCRL)
    {
        LocalFree(paCRL);
    }
}


HRESULT
crlCreateCRLReason(
    IN OUT CSMEMBLOCK **ppBlock,
    IN OUT CSCRLREASON **ppReason,
    IN DWORD RevocationReason,
    OUT DWORD *pcExtension,
    OUT CERT_EXTENSION **ppExtension)
{
    HRESULT hr;
    CSCRLREASON *pReason = *ppReason;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    for (pReason = *ppReason; NULL != pReason; pReason = pReason->pNext)
    {
	if (RevocationReason == pReason->RevocationReason)
	{
	    break;
	}
    }

    if (NULL == pReason)
    {
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_ENUMERATED,
			(const void *) &RevocationReason,
			0,
			CERTLIB_USE_LOCALALLOC,
			&pbEncoded,
			&cbEncoded))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}

	hr = crlMemBlockAlloc(
		    ppBlock,
		    sizeof(CSCRLREASON) + cbEncoded,
		    (BYTE **) &pReason);
	_JumpIfError(hr, error, "crlMemBlockAlloc");

	pReason->pNext = *ppReason;
	pReason->RevocationReason = RevocationReason;
	pReason->ExtReason.pszObjId = szOID_CRL_REASON_CODE;
	pReason->ExtReason.fCritical = FALSE;
	pReason->ExtReason.Value.pbData =
	    (BYTE *) Add2Ptr(pReason, sizeof(*pReason));
	pReason->ExtReason.Value.cbData = cbEncoded;
	CopyMemory(pReason->ExtReason.Value.pbData, pbEncoded, cbEncoded);

	*ppReason = pReason;

	//printf("crlCreateCRLReason: new %x  cb %x\n", RevocationReason, cbEncoded);
    }
    //printf("crlCreateCRLReason: %x\n", RevocationReason);
    CSASSERT(NULL != pReason && RevocationReason == pReason->RevocationReason);

    *pcExtension = 1;
    *ppExtension = &pReason->ExtReason;
    hr = S_OK;

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}


// Convert linked list of CRL blocks to an array.
// If the output array pointer is NULL, just free the list.

HRESULT
ConvertOrFreeCRLList(
    IN OUT CSCRLBLOCK **ppBlockCRL,	// Freed
    IN OUT CSMEMBLOCK **ppBlockReason,	// Used to allocate reason extensions
    IN DWORD cCRL,
    OPTIONAL OUT CRL_ENTRY **paCRL)
{
    HRESULT hr;
    CSCRLREASON *pReasonList = NULL;	// linked list of reason extensions
    CSCRLBLOCK *pBlockCRL = *ppBlockCRL;
    CRL_ENTRY *aCRL = NULL;
    CRL_ENTRY *pCRL;
    DWORD i;

    if (NULL != paCRL)
    {
        aCRL = (CRL_ENTRY *) LocalAlloc(LMEM_FIXED, sizeof(aCRL[0]) * cCRL);
        if (NULL == aCRL)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }

    pCRL = aCRL;
    while (NULL != pBlockCRL)
    {
	CSCRLBLOCK *pBlockCRLNext;

	if (NULL != pCRL)
	{
	    for (i = 0; i < pBlockCRL->cCRLElement; i++)
	    {
		CSCRLELEMENT *pCRLElement = &pBlockCRL->aCRLElement[i];

		pCRL->SerialNumber.pbData = pCRLElement->pbSerialNumber;
		pCRL->SerialNumber.cbData = pCRLElement->uscbSerialNumber;
		pCRL->RevocationDate = pCRLElement->ftRevocationDate;
		pCRL->cExtension = 0;
		pCRL->rgExtension = NULL;

		if (CRL_REASON_UNSPECIFIED != pCRLElement->usRevocationReason)
		{
		    hr = crlCreateCRLReason(
				    ppBlockReason,
				    &pReasonList,
				    pCRLElement->usRevocationReason,
				    &pCRL->cExtension,
				    &pCRL->rgExtension);
		    _JumpIfError(hr, error, "crlCreateCRLReason");
		}
		pCRL++;
	    }
	}
	pBlockCRLNext = pBlockCRL->pNext;
	LocalFree(pBlockCRL);
	pBlockCRL = pBlockCRLNext;
    }

    if (NULL != paCRL)
    {
	CSASSERT(pCRL == &aCRL[cCRL]);
        *paCRL = aCRL;
        aCRL = NULL;
    }
    CSASSERT(NULL == pBlockCRL);
    hr = S_OK;

error:
    *ppBlockCRL = pBlockCRL;
    if (NULL != aCRL)
    {
        LocalFree(aCRL);
    }
    return(hr);
}


HRESULT
AddCRLElement(
    IN OUT CSMEMBLOCK **ppBlockSerial,
    IN OUT CSCRLBLOCK **ppBlockCRL,
    IN WCHAR const *pwszSerialNumber,
    IN FILETIME const *pftRevokedEffectiveWhen,
    IN DWORD RevocationReason)
{
    HRESULT hr;
    CSCRLELEMENT *pCRLElement;
    DWORD cbSerial;
    BYTE *pbSerial = NULL;

    hr = crlElementAlloc(ppBlockCRL, &pCRLElement);
    _JumpIfError(hr, error, "crlElementAlloc");

    hr = WszToMultiByteInteger(
			    FALSE,
			    pwszSerialNumber,
			    &cbSerial,
			    &pbSerial);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

    hr = crlMemBlockAlloc(ppBlockSerial, cbSerial, &pCRLElement->pbSerialNumber);
    _JumpIfError(hr, error, "crlMemBlockAlloc");

    CopyMemory(pCRLElement->pbSerialNumber, pbSerial, cbSerial);

    pCRLElement->ftRevocationDate = *pftRevokedEffectiveWhen;
    pCRLElement->usRevocationReason = (USHORT) RevocationReason;
    pCRLElement->uscbSerialNumber = (USHORT) cbSerial;

    CSASSERT(pCRLElement->usRevocationReason == RevocationReason);
    CSASSERT(pCRLElement->uscbSerialNumber == cbSerial);

error:
    if (NULL != pbSerial)
    {
	LocalFree(pbSerial);
    }
    return(hr);
}


DWORD g_aColCRL[] = {

#define ICOL_DISPOSITION	0
    DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION,

#define ICOL_SERIAL		1
    DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER,

#define ICOL_EFFECTIVEWHEN	2
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN,

#define ICOL_REASON		3
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDREASON,
};


HRESULT
BuildCRLList(
    IN BOOL fDelta,
    IN DWORD iKey,
    OPTIONAL IN FILETIME const *pftQueryMinimum,
    IN FILETIME const *pftThisPublish,
    IN FILETIME const *pftLastPublishBase,
    IN OUT DWORD *pcCRL,
    IN OUT CSCRLBLOCK **ppBlockCRL,
    IN OUT CSMEMBLOCK **ppBlockSerial)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[5];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD celtFetched;
    DWORD NameIdMin;
    DWORD NameIdMax;
    DWORD i;
    BOOL fEnd;
    CERTDBRESULTROW aResult[10];
    BOOL fResultActive = FALSE;
    DWORD cCRL = *pcCRL;
    CSCRLBLOCK *pBlockCRL = *ppBlockCRL;
    CSMEMBLOCK *pBlockSerial = *ppBlockSerial;

    DBGPRINTTIME(NULL, "*pftThisPublish", DPT_DATE, *pftThisPublish);

    // Set up restrictions as follows:

    pcvr = acvr;

    // Request.RevokedEffectiveWhen <= *pftThisPublish (indexed column)

    pcvr->ColumnIndex = DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN;
    pcvr->SeekOperator = CVR_SEEK_LE;
    pcvr->SortOrder = CVR_SORT_DESCEND;
    pcvr->pbValue = (BYTE *) pftThisPublish;
    pcvr->cbValue = sizeof(*pftThisPublish);
    pcvr++;

    // Cert.NotAfter >= *pftLastPublishBase

    if (0 == (CRLF_PUBLISH_EXPIRED_CERT_CRLS & g_dwCRLFlags))
    {
	pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE;
	pcvr->SeekOperator = CVR_SEEK_GE;
	pcvr->SortOrder = CVR_SORT_NONE;
	pcvr->pbValue = (BYTE *) pftLastPublishBase;
	pcvr->cbValue = sizeof(*pftLastPublishBase);
	pcvr++;
    }

    // NameId >= MAKECANAMEID(iCert == 0, iKey)

    NameIdMin = MAKECANAMEID(0, iKey);
    pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID;
    pcvr->SeekOperator = CVR_SEEK_GE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMin;
    pcvr->cbValue = sizeof(NameIdMin);
    pcvr++;

    // NameId <= MAKECANAMEID(iCert == _16BITMASK, iKey)

    NameIdMax = MAKECANAMEID(_16BITMASK, iKey);
    pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID;
    pcvr->SeekOperator = CVR_SEEK_LE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMax;
    pcvr->cbValue = sizeof(NameIdMax);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) > SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    if (NULL != pftQueryMinimum)
    {
	// Request.RevokedWhen >= *pftQueryMinimum

	pcvr->ColumnIndex = DTI_REQUESTTABLE | DTR_REQUESTREVOKEDWHEN;
	pcvr->SeekOperator = CVR_SEEK_GE;
	pcvr->SortOrder = CVR_SORT_NONE;
	pcvr->pbValue = (BYTE *) pftQueryMinimum;
	pcvr->cbValue = sizeof(*pftQueryMinimum);
	pcvr++;

	CSASSERT(ARRAYSIZE(acvr) >= SAFE_SUBTRACT_POINTERS(pcvr, acvr));
    }

    celtFetched = 0;
    hr = g_pCertDB->OpenView(
			SAFE_SUBTRACT_POINTERS(pcvr, acvr),
			acvr,
			ARRAYSIZE(g_aColCRL),
			g_aColCRL,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    fEnd = FALSE;
    while (!fEnd)
    {
	hr = pView->Next(NULL, ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    fEnd = TRUE;
	    if (0 == celtFetched)
	    {
		break;
	    }
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "Next");

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) >= celtFetched);

	for (i = 0; i < celtFetched; i++)
	{
	    DWORD Disposition;
	    DWORD Reason;
	
	    CERTDBRESULTROW *pResult = &aResult[i];

	    CSASSERT(ARRAYSIZE(g_aColCRL) == pResult->ccol);

	    CSASSERT(NULL != pResult->acol[ICOL_DISPOSITION].pbValue);
	    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOL_DISPOSITION].Type));
	    CSASSERT(sizeof(Disposition) == pResult->acol[ICOL_DISPOSITION].cbValue);
	    Disposition = *(DWORD *) pResult->acol[ICOL_DISPOSITION].pbValue;

	    CSASSERT(NULL != pResult->acol[ICOL_SERIAL].pbValue);
	    CSASSERT(PROPTYPE_STRING == (PROPTYPE_MASK & pResult->acol[ICOL_SERIAL].Type));
	    CSASSERT(0 < pResult->acol[ICOL_SERIAL].cbValue);

	    if (NULL == pResult->acol[ICOL_EFFECTIVEWHEN].pbValue)
	    {
		continue;
	    }
	    CSASSERT(sizeof(FILETIME) == pResult->acol[ICOL_EFFECTIVEWHEN].cbValue);
	    CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOL_EFFECTIVEWHEN].Type));

	    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOL_REASON].Type));
	    Reason = CRL_REASON_UNSPECIFIED;
	    if (NULL != pResult->acol[ICOL_REASON].pbValue)
	    {
		CSASSERT(sizeof(Reason) == pResult->acol[ICOL_REASON].cbValue);
		Reason = *(DWORD *) pResult->acol[ICOL_REASON].pbValue;
	    }

	    if (NULL == pResult->acol[ICOL_SERIAL].pbValue ||
		CRL_REASON_REMOVE_FROM_CRL == Reason)
	    {
		continue;
	    }

	    // Add to CRL unless it's:
	    //    not a revoked issued cert &&
	    //    not a root CA cert &&
	    //    not an unrevoked issued cert

	    if (DB_DISP_REVOKED != Disposition &&
		!(DB_DISP_CA_CERT == Disposition && IsRootCA(g_CAType)) &&
		!(DB_DISP_ISSUED == Disposition && MAXDWORD == Reason))
	    {
		continue;
	    }
	    if (MAXDWORD == Reason)
	    {
		if (!fDelta)
		{
		    continue;
		}
		Reason = CRL_REASON_REMOVE_FROM_CRL;
	    }
	    hr = AddCRLElement(
		    &pBlockSerial,
		    &pBlockCRL,
		    (WCHAR const *) pResult->acol[ICOL_SERIAL].pbValue,
		    (FILETIME const *) pResult->acol[ICOL_EFFECTIVEWHEN].pbValue,
		    Reason);
	    _JumpIfError(hr, error, "AddCRLElement");

	    CONSOLEPRINT3((
			DBG_SS_CERTSRV,
			"Cert is %ws: %ws: %d\n",
			CRL_REASON_REMOVE_FROM_CRL == Reason?
			    L"UNREVOKED" : L"Revoked",
			pResult->acol[ICOL_SERIAL].pbValue,
			Reason));
	    cCRL++;
	}
	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }
    *pcCRL = cCRL;
    hr = S_OK;

error:
    *ppBlockSerial = pBlockSerial;
    *ppBlockCRL = pBlockCRL;
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    return(hr);
}
#undef ICOL_DISPOSITION
#undef ICOL_SERIAL
#undef ICOL_EFFECTIVEWHEN
#undef ICOL_REASON


HRESULT
crlBuildCRLArray(
    IN BOOL fDelta,
    OPTIONAL IN FILETIME const *pftQueryMinimum,
    IN FILETIME const *pftThisPublish,
    IN FILETIME const *pftLastPublishBase,
    IN DWORD iKey,
    OUT DWORD *pcCRL,
    OUT CRL_ENTRY **paCRL,
    OUT VOID **ppvBlock)
{
    HRESULT hr;
    BOOL fCoInitialized = FALSE;
    CSCRLBLOCK *pBlockCRL = NULL;
    CSMEMBLOCK *pBlockSerial = NULL;

    *pcCRL = 0;
    *paCRL = NULL;
    *ppvBlock = NULL;

    hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitializeEx");
    }
    fCoInitialized = TRUE;

    hr = BuildCRLList(
		fDelta,
		iKey,
		pftQueryMinimum,
		pftThisPublish,
		pftLastPublishBase,
		pcCRL,
		&pBlockCRL,
		&pBlockSerial);
    _JumpIfError(hr, error, "BuildCRLList");

    hr = ConvertOrFreeCRLList(&pBlockCRL, &pBlockSerial, *pcCRL, paCRL);
    _JumpIfError(hr, error, "ConvertOrFreeCRLList");

    *ppvBlock = pBlockSerial;
    pBlockSerial = NULL;

error:
    if (NULL != pBlockCRL)
    {
	ConvertOrFreeCRLList(&pBlockCRL, NULL, 0, NULL);
    }
    if (NULL != pBlockSerial)
    {
	crlBlockListFree(pBlockSerial);
    }
    if (fCoInitialized)
    {
        CoUninitialize();
    }
    return(hr);
}


HRESULT
crlGetRegCRLNextPublish(
    IN BOOL DBGPARMREFERENCED(fDelta),
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszRegName,
    OUT FILETIME *pftNextPublish)
{
    HRESULT hr;
    BYTE *pbData = NULL;
    DWORD cbData;
    DWORD dwType;

    hr = myGetCertRegValue(
                        NULL,
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegName,
			&pbData,		// free using LocalFree
			&cbData,
			&dwType);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
	goto error;
    }
    _JumpIfErrorStr(hr, error, "myGetCertRegValue", pwszRegName);

    if (REG_BINARY != dwType || sizeof(*pftNextPublish) != cbData)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto error;
    }
    *pftNextPublish = *(FILETIME *) pbData;
    DBGPRINTTIME(&fDelta, "*pftNextPublish", DPT_DATE, *pftNextPublish);
error:
    if (NULL != pbData)
    {
        LocalFree(pbData);
    }
    return(hr);
}


HRESULT
crlSetRegCRLNextPublish(
    IN BOOL DBGPARMREFERENCED(fDelta),
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszRegName,
    IN FILETIME const *pftNextPublish)
{
    HRESULT hr;

    hr = mySetCertRegValue(
                        NULL,
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegName,
			REG_BINARY,
			(BYTE const *) pftNextPublish,
			sizeof(*pftNextPublish),
			FALSE);
    _JumpIfErrorStr(hr, error, "mySetCertRegValue", pwszRegName);

    DBGPRINTTIME(&fDelta, "*pftNextPublish", DPT_DATE, *pftNextPublish);

error:
    return(hr);
}


// called from CoreInit
// inits process-static data: g_ftCRLNextPublish, etc.

HRESULT
CRLInit(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    DWORD dw;

    ZeroMemory(&g_ftCRLNextPublish, sizeof(g_ftCRLNextPublish));
    ZeroMemory(&g_ftDeltaCRLNextPublish, sizeof(g_ftDeltaCRLNextPublish));

    hr = crlGetRegCRLNextPublish(
		    FALSE,
		    pwszSanitizedName,
		    wszREGCRLNEXTPUBLISH,
		    &g_ftCRLNextPublish);
    _JumpIfError(hr, error, "crlGetRegCRLNextPublish");

    hr = crlGetRegCRLNextPublish(
		    TRUE,
		    pwszSanitizedName,
		    wszREGCRLDELTANEXTPUBLISH,
		    &g_ftDeltaCRLNextPublish);
    _JumpIfError(hr, error, "crlGetRegCRLNextPublish");

    hr = myGetCertRegDWValue(
			pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLFLAGS,
			(DWORD *) &dw);
    _PrintIfErrorStr(hr, "myGetCertRegDWValue", wszREGCRLFLAGS);
    if (S_OK == hr)
    {
	g_dwCRLFlags = dw;
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
CRLTerminate()
{
    if (NULL != g_pld)
    {
        ldap_unbind(g_pld);
        g_pld = NULL;
    }
}


HRESULT
crlGetRegPublishParams(
    IN BOOL fDelta,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszRegCRLPeriodCount,
    IN WCHAR const *pwszRegCRLPeriodString,
    IN WCHAR const *pwszRegCRLOverlapPeriodCount,
    IN WCHAR const *pwszRegCRLOverlapPeriodString,
    IN LONG lPeriodCountDefault,
    IN WCHAR const *pwszPeriodStringDefault,
    OPTIONAL OUT CSCRLPERIOD *pccp,
    OUT BOOL *pfCRLPublishDisabled)
{
    HRESULT hr;
    WCHAR *pwszCRLPeriodString = NULL;
    WCHAR *pwszCRLOverlapPeriodString = NULL;
    CSCRLPERIOD ccp;

    if (NULL == pccp)
    {
	pccp = &ccp;
    }
    ZeroMemory(pccp, sizeof(*pccp));

    CSASSERT(NULL != pfCRLPublishDisabled);

    // get if need lCRLPeriodCount OR enumCRLPeriod
    // if any of these fail, skip to error handling below

    hr = myGetCertRegDWValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLPeriodCount,
			(DWORD *) &pccp->lCRLPeriodCount);
    _PrintIfErrorStr(hr, "myGetCertRegDWValue", pwszRegCRLPeriodCount);

    if (hr == S_OK)
    {
        hr = myGetCertRegStrValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLPeriodString,
			&pwszCRLPeriodString);
	_PrintIfErrorStr(hr, "myGetCertRegDWValue", pwszRegCRLPeriodString);
	if (hr == S_OK)
	{
	    hr = myTranslatePeriodUnits(
			    pwszCRLPeriodString,
			    pccp->lCRLPeriodCount,
			    &pccp->enumCRLPeriod,
			    &pccp->lCRLPeriodCount);
	    _PrintIfError(hr, "myTranslatePeriodUnits");
	}
       
        // don't allow base to be disabled anymore: force defaults to be loaded
        if (!fDelta &&
	    (0 == pccp->lCRLPeriodCount || -1 == pccp->lCRLPeriodCount))
	{
            hr = E_INVALIDARG;
	}
    }

    if (hr != S_OK)
    {
        _PrintError(hr, "Error reading CRLPub params. Overwriting with defaults.");

	if (CERTLOG_WARNING <= g_dwLogLevel)
	{
	    hr = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_INVALID_CRL_SETTINGS,
		    0,
		    NULL);
	    _PrintIfError(hr, "LogEvent");
	}

        // slam default publishing to whatever the caller said
	hr = myTranslatePeriodUnits(
			    pwszPeriodStringDefault,
			    lPeriodCountDefault,
			    &pccp->enumCRLPeriod,
			    &pccp->lCRLPeriodCount);
	_JumpIfError(hr, error, "myTranslatePeriodUnits");

        // blindly reset defaults
        mySetCertRegDWValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLPeriodCount,
			pccp->lCRLPeriodCount);

        mySetCertRegStrValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLPeriodString,
			pwszPeriodStringDefault);
    }
    *pfCRLPublishDisabled = 0 == pccp->lCRLPeriodCount;

    if (&ccp != pccp)			// If caller wants the data
    {
        BOOL fRegistryOverlap = FALSE;
        DWORD dwCRLOverlapCount;
        ENUM_PERIOD enumCRLOverlap;
        LLFILETIME llftDeltaPeriod;

        // try and gather overlap values from registry - bail on any failure

	enumCRLOverlap = ENUM_PERIOD_YEARS;
        hr = myGetCertRegDWValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegCRLOverlapPeriodCount,
			&dwCRLOverlapCount);
        if (hr == S_OK && 0 != dwCRLOverlapCount)	// if not disabled
        {
            hr = myGetCertRegStrValue(
			    pwszSanitizedName,
			    NULL,
			    NULL,
			    pwszRegCRLOverlapPeriodString,
			    &pwszCRLOverlapPeriodString);// free w/ LocalFree
            if (hr == S_OK)
            {
                hr = myTranslatePeriodUnits(
				    pwszCRLOverlapPeriodString,
				    dwCRLOverlapCount,
				    &enumCRLOverlap,
				    (LONG *) &dwCRLOverlapCount);

                // we have enough info to override overlap calculation

                if (hr == S_OK)
                {
                    fRegistryOverlap = TRUE;
                    DBGPRINT((
			DBG_SS_CERTSRVI,
                        "Loaded CRL Overlap values. Overriding overlap calculation with specified values.\n"));
                }
            }
        }

        // always possible to revert to calculated value
        if (fRegistryOverlap)
        {
	    LLFILETIME llftOverlap;

            // convert registry-specified CRL overlap to FILETIME

	    llftOverlap.ll = 0;
	    myMakeExprDateTime(
			&llftOverlap.ft,
			dwCRLOverlapCount,
			enumCRLOverlap);
	    DBGPRINTTIME(&fDelta, "ftdelta1", DPT_DELTA, llftOverlap.ft);

	    llftOverlap.ll /= CVT_BASE;  // now in seconds

            // (DELTA sec / 60 secpermin)
            pccp->dwCRLOverlapMinutes = (DWORD) (llftOverlap.ll / CVT_MINUTES);
        }

	// convert CRL period to FILETIME

        llftDeltaPeriod.ll = 0;
	myMakeExprDateTime(
		    &llftDeltaPeriod.ft,
		    pccp->lCRLPeriodCount,
		    pccp->enumCRLPeriod);
	DBGPRINTTIME(&fDelta, "ftdelta2", DPT_DELTA, llftDeltaPeriod.ft);

	llftDeltaPeriod.ll /= CVT_BASE;		// now in seconds
	llftDeltaPeriod.ll /= CVT_MINUTES;	// now in minutes

        if (!fRegistryOverlap)
        {
	    if (fDelta)
	    {
		// default CRLOverlap for delta CRLs: same as period

		pccp->dwCRLOverlapMinutes = llftDeltaPeriod.ft.dwLowDateTime;
	    }
	    else
	    {
		// default CRLOverlap for base CRLs: 10% of period

		pccp->dwCRLOverlapMinutes = (DWORD) (llftDeltaPeriod.ll / 10);
	    }

            // Clamp computed overlap to less than 12 hours

	    if (pccp->dwCRLOverlapMinutes > 12 * 60)
	    {
		pccp->dwCRLOverlapMinutes = 12 * 60;
	    }
        }

        // Always clamp lower bound: (1.5 * skew) < g_dwCRLOverlapMinutes
        // must be at least 1.5x skew

	dwCRLOverlapCount = (3 * g_dwClockSkewMinutes) >> 1;
	if (pccp->dwCRLOverlapMinutes < dwCRLOverlapCount)
	{
	    pccp->dwCRLOverlapMinutes = dwCRLOverlapCount;
	}

        // Always clamp upper bound: must be no more than CRL period

	if (pccp->dwCRLOverlapMinutes > llftDeltaPeriod.ft.dwLowDateTime)
	{
	    pccp->dwCRLOverlapMinutes = llftDeltaPeriod.ft.dwLowDateTime;
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszCRLPeriodString)
    {
        LocalFree(pwszCRLPeriodString);
    }
    if (NULL != pwszCRLOverlapPeriodString)
    {
        LocalFree(pwszCRLOverlapPeriodString);
    }
    return(hr);
}


// Reload publication params during each CRL publication

HRESULT
crlGetRegCRLPublishParams(
    IN WCHAR const *pwszSanitizedName,
    OPTIONAL OUT CSCRLPERIOD *pccpBase,
    OPTIONAL OUT CSCRLPERIOD *pccpDelta)
{
    HRESULT hr;

    hr = crlGetRegPublishParams(
			FALSE,
			pwszSanitizedName,
			wszREGCRLPERIODCOUNT,
			wszREGCRLPERIODSTRING,
			wszREGCRLOVERLAPPERIODCOUNT,
			wszREGCRLOVERLAPPERIODSTRING,
			dwCRLPERIODCOUNTDEFAULT,	// default period
			wszCRLPERIODSTRINGDEFAULT,	// default period
			pccpBase,
			&g_fCRLPublishDisabled);
    _JumpIfError(hr, error, "crlGetRegPublishParams");

    hr = crlGetRegPublishParams(
			TRUE,
			pwszSanitizedName,
			wszREGCRLDELTAPERIODCOUNT,
			wszREGCRLDELTAPERIODSTRING,
			wszREGCRLDELTAOVERLAPPERIODCOUNT,
			wszREGCRLDELTAOVERLAPPERIODSTRING,
			dwCRLDELTAPERIODCOUNTDEFAULT,	// default period
			wszCRLDELTAPERIODSTRINGDEFAULT,	// default period
			pccpDelta,
			&g_fDeltaCRLPublishDisabled);
    _JumpIfError(hr, error, "crlGetRegPublishParams");

error:
    return(hr);
}


#define CERTSRV_CRLPUB_RETRY_COUNT_DEFAULT	10
#define CERTSRV_CRLPUB_RETRY_SECONDS		(10 * CVT_MINUTES)

	    
VOID
crlComputeTimeOutSub(
    OPTIONAL IN BOOL *DBGPARMREFERENCED(pfDelta),
    IN FILETIME const *pftFirst,
    IN FILETIME const *pftLast,
    OUT DWORD *pdwMSTimeOut)
{
    LLFILETIME llft;

    // llft.ll = *pftLast - *pftFirst;

    llft.ll = mySubtractFileTimes(pftLast, pftFirst);
    
    DBGPRINTTIME(pfDelta, "*pftFirst", DPT_DATE, *pftFirst);
    DBGPRINTTIME(pfDelta, "*pftLast", DPT_DATE, *pftLast);

    llft.ll /= (CVT_BASE / 1000);	// convert 100ns to msecs

    DBGPRINTTIME(pfDelta, "llft", DPT_DELTAMS, llft.ft);

    if (0 > llft.ll || MAXLONG < llft.ll)
    {
	// wait as long as we can without going infinite

	llft.ll = MAXLONG;
    }
    *pdwMSTimeOut = llft.ft.dwLowDateTime;
}


VOID
crlComputeTimeOutEx(
    IN BOOL fDelta,
    IN FILETIME const *pftFirst,
    IN FILETIME const *pftLast,
    OUT DWORD *pdwMSTimeOut)
{
    crlComputeTimeOutSub(&fDelta, pftFirst, pftLast, pdwMSTimeOut);
}


VOID
CRLComputeTimeOut(
    IN FILETIME const *pftFirst,
    IN FILETIME const *pftLast,
    OUT DWORD *pdwMSTimeOut)
{
    crlComputeTimeOutSub(NULL, pftFirst, pftLast, pdwMSTimeOut);
}


#ifdef DBG_CERTSRV_DEBUG_PRINT
VOID
DbgPrintRemainTime(
    IN BOOL fDelta,
    IN FILETIME const *pftCurrent,
    IN FILETIME const *pftCRLNextPublish)
{
    HRESULT hr;
    LLFILETIME llftDelta;
    WCHAR *pwszTime = NULL;
    WCHAR awc[1];

    llftDelta.ll = mySubtractFileTimes(pftCRLNextPublish, pftCurrent);

    DBGPRINTTIME(&fDelta, "delta", DPT_DELTA, llftDelta.ft);

    llftDelta.ll = -llftDelta.ll;
    hr = myFileTimePeriodToWszTimePeriod(
			    &llftDelta.ft,
			    TRUE,	// fExact
			    &pwszTime);
    _PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");
    if (S_OK != hr)
    {
	awc[0] = L'\0';
	pwszTime = awc;
    }

    DBGPRINT((
	DBG_SS_CERTSRV,
	"CRLPubWakeupEvent(tid=%d): Next %hs CRL: %ws\n",
	GetCurrentThreadId(),
	fDelta? "Delta" : "Base",
	pwszTime));
    if (NULL != pwszTime && awc != pwszTime)
    {
	LocalFree(pwszTime);
    }
}
#endif // DBG_CERTSRV_DEBUG_PRINT


DWORD g_aColExpiredCRL[] = {

#define ICOLEXP_ROWID		0
    DTI_CRLTABLE | DTL_ROWID,

#define ICOLEXP_MINBASE		1
    DTI_CRLTABLE | DTL_MINBASE,

#define ICOLEXP_CRLNEXTUPDATE	2
    DTI_CRLTABLE | DTL_NEXTUPDATEDATE,
};

HRESULT
crlDeleteExpiredCRLs(
    IN FILETIME const *pftCurrent,
    IN FILETIME const *pftQueryDeltaDelete,
    IN DWORD RowIdBase)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[1];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    BOOL fResultActive = FALSE;
    CERTDBRESULTROW aResult[1];
    CERTDBRESULTROW *pResult;
    DWORD celtFetched;

    celtFetched = 0;
    if (CRLF_DELETE_EXPIRED_CRLS & g_dwCRLFlags)
    {
	DBGPRINTTIME(NULL, "DeleteCRL:*pftCurrent", DPT_DATE, *pftCurrent);
	DBGPRINTTIME(NULL, "DeleteCRL:*pftQueryDeltaDelete", DPT_DATE, *pftQueryDeltaDelete);

	// Set up restrictions as follows:

	pcvr = acvr;

	// CRL Expiration < ftCurrent (indexed column)

	pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NEXTPUBLISHDATE;
	pcvr->SeekOperator = CVR_SEEK_LT;
	pcvr->SortOrder = CVR_SORT_ASCEND;	// Oldest propagated CRL first
	pcvr->pbValue = (BYTE *) pftCurrent;
	pcvr->cbValue = sizeof(*pftCurrent);
	pcvr++;

	CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

	hr = g_pCertDB->OpenView(
			    ARRAYSIZE(acvr),
			    acvr,
			    ARRAYSIZE(g_aColExpiredCRL),
			    g_aColExpiredCRL,
			    0,		// no worker thread
			    &pView);
	_JumpIfError(hr, error, "OpenView");

	for (;;)
	{
	    DWORD RowId;
	    DWORD MinBase;
	    FILETIME ftNextUpdate;
	    BOOL fDelete;
	    
	    hr = pView->Next(NULL, ARRAYSIZE(aResult), aResult, &celtFetched);
	    if (S_FALSE == hr)
	    {
		if (0 == celtFetched)
		{
		    break;
		}
	    }
	    _JumpIfError(hr, error, "Next");

	    fResultActive = TRUE;

	    CSASSERT(ARRAYSIZE(aResult) == celtFetched);

	    pResult = &aResult[0];

	    CSASSERT(ARRAYSIZE(g_aColExpiredCRL) == pResult->ccol);
	    CSASSERT(NULL != pResult->acol[ICOLEXP_ROWID].pbValue);
	    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLEXP_ROWID].Type));
	    CSASSERT(sizeof(RowId) == pResult->acol[ICOLEXP_ROWID].cbValue);
	    RowId = *(DWORD *) pResult->acol[ICOLEXP_ROWID].pbValue;

	    CSASSERT(NULL != pResult->acol[ICOLEXP_MINBASE].pbValue);
	    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLEXP_MINBASE].Type));
	    CSASSERT(sizeof(MinBase) == pResult->acol[ICOLEXP_MINBASE].cbValue);
	    MinBase = *(DWORD *) pResult->acol[ICOLEXP_MINBASE].pbValue;

	    if (NULL != pResult->acol[ICOLEXP_CRLNEXTUPDATE].pbValue)
	    {
		CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLEXP_CRLNEXTUPDATE].Type));
		CSASSERT(sizeof(FILETIME) == pResult->acol[ICOLEXP_CRLNEXTUPDATE].cbValue);
		ftNextUpdate = *(FILETIME *) pResult->acol[ICOLEXP_CRLNEXTUPDATE].pbValue;
	    }
	    else
	    {
		ftNextUpdate.dwLowDateTime = 0;
		ftNextUpdate.dwHighDateTime = 0;
	    }

	    pView->ReleaseResultRow(celtFetched, aResult);
	    fResultActive = FALSE;

	    CSASSERT(0 != RowId);

	    // Delete the CRL row if it is not the current Base CRL and the
	    // row represents a CRL that expired prior to the current Base CRL.

	    fDelete = FALSE;
	    if (0 != ftNextUpdate.dwLowDateTime ||
		0 != ftNextUpdate.dwHighDateTime)
	    {
		if (RowIdBase != RowId &&
		    0 < CompareFileTime(pftQueryDeltaDelete, &ftNextUpdate))
		{
		    fDelete = TRUE;
		}
	    }
	    DBGPRINTTIME(NULL, "DeleteCRL:ftNextUpdate", DPT_DATE, ftNextUpdate);
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"crlDeleteExpiredCRLs(RowId=%x) %ws\n",
		RowId,
		fDelete? L"DELETE" : L"SKIP"));

	    if (fDelete)
	    {
		ICertDBRow *prow;

		hr = g_pCertDB->OpenRow(
				    PROPOPEN_DELETE | PROPTABLE_CRL,
				    RowId,
				    NULL,
				    &prow);
		_JumpIfError(hr, error, "OpenRow");

		hr = prow->Delete();
		_PrintIfError(hr, "Delete");

		if (S_OK == hr)
		{
		    hr = prow->CommitTransaction(TRUE);
		    _PrintIfError(hr, "CommitTransaction");
		}
		if (S_OK != hr)
		{
		    HRESULT hr2 = prow->CommitTransaction(FALSE);
		    _PrintIfError(hr2, "CommitTransaction");
		}
		prow->Release();
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    return(hr);
}
#undef ICOLEXP_ROWID
#undef ICOLEXP_MINBASE
#undef ICOLEXP_CRLNEXTUPDATE


///////////////////////////////////////////////////
// CRLPubWakeupEvent is the handler for wakeup notifications.
//
// This function is called at miscellaneous times and
// determines whether or not it is time to rebuild the
// CRL to be published.
//
// It then calls CRLPublishCRLs and advises it as to whether to
// rebuild or not.
//
// Its final task is to recalculate the next wakeup time, which
// depends on current time, if the exit module needs to be retried,
// or whether CRL publishing is disabled.

HRESULT
CRLPubWakeupEvent(
    OUT DWORD *pdwMSTimeOut)
{
    HRESULT hr;
    HRESULT hrPublish;
    FILETIME ftZero;
    FILETIME ftCurrent;
    BOOL fBaseTrigger = TRUE;
    BOOL fRebuildCRL = FALSE;
    BOOL fForceRepublish = FALSE;
    BOOL fShadowDelta = FALSE;
    BOOL fSetRetryTimer = FALSE;
    DWORD dwMSTimeOut = CERTSRV_CRLPUB_RETRY_SECONDS * 1000;
    DWORD State = 0;
    static BOOL s_fFirstWakeup = TRUE;

    CSASSERT(NULL != pdwMSTimeOut);

    // if anything goes wrong, call us again after a pause

    hr = CertSrvEnterServer(&State);
    _JumpIfError(hr, error, "CertSrvEnterServer");

    __try
    {
	BOOL fCRLPublishDisabledOld = g_fCRLPublishDisabled;
	BOOL fDeltaCRLPublishDisabledOld = g_fDeltaCRLPublishDisabled;

        // Recalc Timeout
        GetSystemTimeAsFileTime(&ftCurrent);

#ifdef DBG_CERTSRV_DEBUG_PRINT
	{
	    WCHAR *pwszNow = NULL;

	    myGMTFileTimeToWszLocalTime(&ftCurrent, TRUE, &pwszNow);

	    DBGPRINT((DBG_SS_CERTSRV, "CRLPubWakeupEvent(%ws)\n", pwszNow));

	    if (NULL != pwszNow)
	    {
		LocalFree(pwszNow);
	    }
	}
#endif // DBG_CERTSRV_DEBUG_PRINT

	// get current publish params

	hr = crlGetRegCRLPublishParams(g_wszSanitizedName, NULL, NULL);
	_LeaveIfError(hr, "crlGetRegCRLPublishParams");

	if (s_fFirstWakeup)
	{
	    s_fFirstWakeup = FALSE;
	    if (g_fDBRecovered)
	    {
		fForceRepublish = TRUE;
	    }
	}
	else
	{
	    if (!g_fCRLPublishDisabled &&
		(fCRLPublishDisabledOld ||
		 g_fDeltaCRLPublishDisabled != fDeltaCRLPublishDisabledOld))
	    {
		fRebuildCRL = TRUE;	// state change: force new CRLs

		// If delta CRLs were just now disabled, make one attempt to
		// publish shadow deltas; force clients to fetch a new base CRL.

		if (!fDeltaCRLPublishDisabledOld && g_fDeltaCRLPublishDisabled)
		{
		    fShadowDelta = TRUE;	// force shadow delta
		}
	    }
	}

        // if "not yet ready"

	if (0 < CompareFileTime(&g_ftCRLNextPublish, &ftCurrent))
	{
	    fBaseTrigger = FALSE;
#ifdef DBG_CERTSRV_DEBUG_PRINT
	    // give next pub status
	    DbgPrintRemainTime(FALSE, &ftCurrent, &g_ftCRLNextPublish);
#endif // DBG_CERTSRV_DEBUG_PRINT
	}

        // if "not yet ready"

	if (!fBaseTrigger &&
	    (g_fDeltaCRLPublishDisabled ||
	     0 < CompareFileTime(&g_ftDeltaCRLNextPublish, &ftCurrent)))
	{
#ifdef DBG_CERTSRV_DEBUG_PRINT
	    // give next pub status
	    if (!g_fDeltaCRLPublishDisabled)
	    {
		DbgPrintRemainTime(TRUE, &ftCurrent, &g_ftDeltaCRLNextPublish);
	    }
#endif // DBG_CERTSRV_DEBUG_PRINT
	}
	else    // "ready to publish" trigger
	{
            if (!g_fCRLPublishDisabled)		// is publishing enabled?
	    {
                fRebuildCRL = TRUE;		// ENABLED, ready to go!
	    }
	    else
            {
                DBGPRINT((
                    DBG_SS_CERTSRV,
                    "CRLPubWakeupEvent(tid=%d): Publishing disabled\n",
                    GetCurrentThreadId() ));
            }
        }

	ftZero.dwLowDateTime = 0;
	ftZero.dwHighDateTime = 0;

	for (;;)
	{
	    hr = CRLPublishCRLs(
		    fRebuildCRL,
		    fForceRepublish,
		    NULL,				// pwszUserName
		    !fForceRepublish &&			// fDeltaOnly
			!fBaseTrigger &&
			!g_fDeltaCRLPublishDisabled &&
			!fDeltaCRLPublishDisabledOld,
		    fShadowDelta,
		    ftZero,
		    &fSetRetryTimer,
		    &hrPublish);
	    if (S_OK == hr)
	    {
		break;
	    }
	    _PrintError(hr, "CRLPublishCRLs");

	    if (!fForceRepublish || fRebuildCRL)
	    {
		_leave;		// give up
	    }

	    // We failed to republish existing CRLs after a database restore
	    // and recovery; generate new base and delta CRLs and publish them.

	    fRebuildCRL = TRUE;
	}
	_PrintIfError(hrPublish, "CRLPublishCRLs(hrPublish)");

        // if we called CRLPublishCRLs, clear the manual event it'll trigger

        ResetEvent(g_hCRLManualPublishEvent);

        // how many ms until next publish?  set dwMSTimeOut

        if (g_fCRLPublishDisabled)
        {
            // if disabled, don't set timeout
            dwMSTimeOut = INFINITE;
            CONSOLEPRINT1((
			DBG_SS_CERTSRV,
			"CRL Publishing Disabled, TimeOut=INFINITE (%d ms)\n",
			dwMSTimeOut));
        }
        else
        {
            DWORD dwMSTimeOutDelta;
	    WCHAR *pwszCRLType = NULL;

	    crlComputeTimeOutEx(
			FALSE,
			&ftCurrent,
			&g_ftCRLNextPublish,
			&dwMSTimeOut);

	    if (g_fDeltaCRLPublishDisabled)
	    {
		pwszCRLType = L"Base";
	    }
	    else
	    {
		crlComputeTimeOutEx(
			    TRUE,
			    &ftCurrent,
			    &g_ftDeltaCRLNextPublish,
			    &dwMSTimeOutDelta);
		if (dwMSTimeOut > dwMSTimeOutDelta)
		{
		    dwMSTimeOut = dwMSTimeOutDelta;
		}
		pwszCRLType = L"Base + Delta";
	    }
	    if (NULL != pwszCRLType)
	    {
		LONGLONG ll;
		WCHAR *pwszTimePeriod = NULL;
		WCHAR awc[1];

		ll = dwMSTimeOut;
		ll *= CVT_BASE / 1000;	// milliseconds to FILETIME Period
		ll = -ll;		// FILETIME Period must be negative

		hr = myFileTimePeriodToWszTimePeriod(
				    (FILETIME const *) &ll,
				    TRUE,	// fExact
				    &pwszTimePeriod);
		_PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");
		if (S_OK != hr)
		{
		    awc[0] = L'\0';
		    pwszTimePeriod = awc;
		}
		CONSOLEPRINT3((
			DBG_SS_CERTSRV,
			"%ws CRL Publishing Enabled, TimeOut=%ds, %ws\n",
			pwszCRLType,
			dwMSTimeOut/1000,
			pwszTimePeriod));
		if (NULL != pwszTimePeriod && awc != pwszTimePeriod)
		{
		    LocalFree(pwszTimePeriod);
		}
	    }
        }

        // if we need to retry, wait no longer than the retry period

        if (fSetRetryTimer)
        {
            if (dwMSTimeOut > CERTSRV_CRLPUB_RETRY_SECONDS * 1000)
            {
                dwMSTimeOut = CERTSRV_CRLPUB_RETRY_SECONDS * 1000;
                CONSOLEPRINT1((
			DBG_SS_CERTSRV,
			"CRL Publishing periodic retry, TimeOut=%ds\n",
			dwMSTimeOut/1000));
            }
        }
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    *pdwMSTimeOut = dwMSTimeOut;
    CertSrvExitServer(State, hr);
    return(hr);
}


HRESULT
CRLWriteToLockedFile(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN BOOL fDelete,
    IN WCHAR const *pwszFile)
{
    HRESULT hr;
    WCHAR *pwszDir = NULL;
    WCHAR *pwszT;
    WCHAR wszTmpPrepFile[MAX_PATH];
    WCHAR wszTmpInUseFile[MAX_PATH];
    BYTE *pbData = NULL;
    DWORD cbData;

    // According to JohnL, the best way to do this is to gen a temp
    // file name, rename the existing file to that, then delete it.
    //
    // Logic:
    // create unique preparation filename
    // write new data to prep file
    // create unique destination filename for old file (possibly locked)
    // move old file to destination filename
    // move prep file to (vacated) file name
    // delete old file from destination filename

    if (!fDelete)
    {
	hr = DecodeFileW(pwszFile, &pbData, &cbData, CRYPT_STRING_BINARY);
	if (S_OK == hr &&
	    cbEncoded == cbData &&
	    0 == memcmp(pbData, pbEncoded, cbData))
	{
	    CSASSERT(S_OK == hr);
	    goto error;		// already written, do nothing
	}
    }

    // create a prep file

    hr = myDupString(pwszFile, &pwszDir);
    _JumpIfError(hr, error, "myDupString");

    pwszT = wcsrchr(pwszDir, L'\\');
    if (NULL != pwszT)
    {
	*pwszT = L'\0';	// for dir path, remove "\filename.ext"
    }

    if (!fDelete)
    {
	if (0 == GetTempFileName(pwszDir, L"pre", 0, wszTmpPrepFile))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetTempFileName");
	}

	// write file to prep area

	hr = EncodeToFileW(
		    wszTmpPrepFile,
		    pbEncoded,
		    cbEncoded,
		    DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
	_JumpIfError(hr, error, "EncodeToFileW");
    }

    if (0 == GetTempFileName(pwszDir, L"crl", 0, wszTmpInUseFile))
    {
        hr = myHLastError();
	_JumpError(hr, error, "GetTempFileName");
    }

    // move old to "in use" file (empty file already exists from
    // GetTempFileName call) may not exist, so don't bother checking status

    MoveFileEx(
	    pwszFile,
	    wszTmpInUseFile,
	    MOVEFILE_WRITE_THROUGH | MOVEFILE_REPLACE_EXISTING);

    // move prepared file to current file

    if (!fDelete)
    {
	if (!MoveFileEx(wszTmpPrepFile, pwszFile, MOVEFILE_WRITE_THROUGH))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "MoveFileEx");
	}
    }

    // The "in use" file may not exist, so don't bother checking status.
    DeleteFile(wszTmpInUseFile);
    hr = S_OK;

error:
    if (NULL != pwszDir)
    {
	LocalFree(pwszDir);
    }
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    return(hr);
}


WCHAR const g_wszPropCRLNumber[] = wszPROPCRLNUMBER;
WCHAR const g_wszPropCRLMinBase[] = wszPROPCRLMINBASE;
WCHAR const g_wszPropCRLNameId[] = wszPROPCRLNAMEID;
WCHAR const g_wszPropCRLCount[] = wszPROPCRLCOUNT;
WCHAR const g_wszPropCRLThisUpdateDate[] = wszPROPCRLTHISUPDATE;
WCHAR const g_wszPropCRLNextUpdateDate[] = wszPROPCRLNEXTUPDATE;
WCHAR const g_wszPropCRLThisPublishDate[] = wszPROPCRLTHISPUBLISH;
WCHAR const g_wszPropCRLNextPublishDate[] = wszPROPCRLNEXTPUBLISH;
WCHAR const g_wszPropCRLEffectiveDate[] = wszPROPCRLEFFECTIVE;
WCHAR const g_wszPropCRLPropagationCompleteDate[] = wszPROPCRLPROPAGATIONCOMPLETE;
WCHAR const g_wszPropCRLLastPublished[] = wszPROPCRLLASTPUBLISHED;
WCHAR const g_wszPropCRLPublishAttempts[] = wszPROPCRLPUBLISHATTEMPTS;
WCHAR const g_wszPropCRLPublishFlags[] = wszPROPCRLPUBLISHFLAGS;
WCHAR const g_wszPropCRLPublishStatusCode[] = wszPROPCRLPUBLISHSTATUSCODE;
WCHAR const g_wszPropCRLPublishError[] = wszPROPCRLPUBLISHERROR;
WCHAR const g_wszPropCRLRawCRL[] = wszPROPCRLRAWCRL;

HRESULT
crlWriteCRLToDB(
    IN DWORD CRLNumber,
    IN DWORD CRLMinBase,		// 0 implies base CRL
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN DWORD CRLNameId,
    IN DWORD CRLCount,
    IN FILETIME const *pftThisUpdate,
    OPTIONAL IN FILETIME const *pftNextUpdate,
    IN FILETIME const *pftThisPublish,
    OPTIONAL IN FILETIME const *pftNextPublish,
    OPTIONAL IN FILETIME const *pftQuery,
    IN FILETIME const *pftPropagationComplete,
    OPTIONAL IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    OUT DWORD *pdwRowId)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    DWORD CRLPublishFlags;
    BOOL fCommitted = FALSE;

    *pdwRowId = 0;

    // Create a new CRL table entry

    hr = g_pCertDB->OpenRow(
			PROPTABLE_CRL,
			0,
			NULL,
			&prow);
    _JumpIfError(hr, error, "OpenRow");

    prow->GetRowId(pdwRowId);

    hr = prow->SetProperty(
		    g_wszPropCRLNumber,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLNumber),
		    (BYTE const *) &CRLNumber);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLMinBase,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLMinBase),
		    (BYTE const *) &CRLMinBase);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLNameId,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLNameId),
		    (BYTE const *) &CRLNameId);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLCount,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLCount),
		    (BYTE const *) &CRLCount);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLThisUpdateDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftThisUpdate),
                    (BYTE const *) pftThisUpdate);
    _JumpIfError(hr, error, "SetProperty");

    if (NULL != pftNextUpdate)
    {
	hr = prow->SetProperty(
			g_wszPropCRLNextUpdateDate,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
			sizeof(*pftNextUpdate),
			(BYTE const *) pftNextUpdate);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = prow->SetProperty(
		    g_wszPropCRLThisPublishDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftThisPublish),
                    (BYTE const *) pftThisPublish);
    _JumpIfError(hr, error, "SetProperty");

    if (NULL != pftNextPublish)
    {
	hr = prow->SetProperty(
			g_wszPropCRLNextPublishDate,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
			sizeof(*pftNextPublish),
			(BYTE const *) pftNextPublish);
	_JumpIfError(hr, error, "SetProperty");
    }
    if (NULL != pftQuery)
    {
	hr = prow->SetProperty(
			g_wszPropCRLEffectiveDate,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
			sizeof(*pftQuery),
			(BYTE const *) pftQuery);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = prow->SetProperty(
		    g_wszPropCRLPropagationCompleteDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftPropagationComplete),
                    (BYTE const *) pftPropagationComplete);
    _JumpIfError(hr, error, "SetProperty");

    CRLPublishFlags = 0 == CRLMinBase? CPF_BASE : CPF_DELTA;
    if (fShadowDelta)
    {
	CRLPublishFlags |= CPF_SHADOW;
    }
    if (NULL != pwszUserName)
    {
	CRLPublishFlags |= CPF_MANUAL;
    }
    hr = prow->SetProperty(
		    g_wszPropCRLPublishFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLPublishFlags),
		    (BYTE const *) &CRLPublishFlags);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCRLRawCRL,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CRL,
		    cbCRL,
		    pbCRL);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->CommitTransaction(TRUE);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    return(hr);
}


// crlSplitStrings -- split newline separated strings into pwszz

HRESULT
crlSplitStrings(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszzOut)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwsz;

    *ppwszzOut = NULL;
    cwc = wcslen(pwszIn) + 1;
    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppwszzOut = pwsz;
    wcscpy(pwsz, pwszIn);
    pwsz[cwc] = L'\0';	// double terminate

    for (;;)
    {
	pwsz = wcschr(pwsz, L'\n');
	if (NULL == pwsz)
	{
	    break;
	}
	*pwsz++ = L'\0';
    }
    hr = S_OK;

error:
    return(hr);
}


// crlUnsplitStrings -- combine pwszz list in-place into newline separated list

VOID
crlUnsplitStrings(
    IN OUT WCHAR *pwszInOut)
{
    WCHAR *pwsz;

    if (NULL != pwszInOut)
    {
	pwsz = pwszInOut;
	while (L'\0' != *pwsz)
	{
	    pwsz += wcslen(pwsz);
	    *pwsz++ = L'\n';
	}
	if (pwsz > pwszInOut && L'\n' == *--pwsz)
	{
	    *pwsz = L'\0';	// no newline terminator!
	}
    }
}


DWORD
CRLIsStringInList(
    IN WCHAR const *pwszSearch,
    OPTIONAL IN WCHAR const *pwszzList)
{
    DWORD iRet = MAXDWORD;

    if (NULL != pwszzList)
    {
	DWORD i = 0;
	WCHAR const *pwsz;

	for (pwsz = pwszzList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    if (0 == mylstrcmpiL(pwsz, pwszSearch))
	    {
		iRet = i;
		break;
	    }
	    i++;
	}
    }
    return(iRet);
}


// crlMergeURLList -- merge two newline separated URL lists into a pwszz list

HRESULT
crlMergeURLList(
    OPTIONAL IN WCHAR const *pwszURLsOld,
    OPTIONAL IN WCHAR const *pwszURLsNew,
    OUT WCHAR **ppwszzURLsMerged)
{
    HRESULT hr;
    WCHAR *pwszzURLsOld = NULL;
    WCHAR *pwszzURLsNew = NULL;
    WCHAR const *pwsz;
    DWORD cwc;
    DWORD cwcT;
    WCHAR *pwszzMerged = NULL;
    WCHAR *pwszNext;

    *ppwszzURLsMerged = NULL;
    cwc = 0;
    if (NULL != pwszURLsOld)
    {
	hr = crlSplitStrings(pwszURLsOld, &pwszzURLsOld);
	_JumpIfError(hr, error, "crlSplitStrings");

	for (pwsz = pwszzURLsOld; L'\0' != *pwsz; pwsz += cwcT)
	{
	    cwcT = wcslen(pwsz) + 1;
	    cwc += cwcT;
	}
    }

    if (NULL != pwszURLsNew)
    {
	hr = crlSplitStrings(pwszURLsNew, &pwszzURLsNew);
	_JumpIfError(hr, error, "crlSplitStrings");

	for (pwsz = pwszzURLsNew; L'\0' != *pwsz; pwsz += cwcT)
	{
	    cwcT = wcslen(pwsz) + 1;
	    if (MAXDWORD == CRLIsStringInList(pwsz, pwszzURLsOld))
	    {
		cwc += cwcT;
	    }
	}
    }
    if (0 == cwc)
    {
	hr = S_OK;
	goto error;
    }

    pwszzMerged = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszzMerged)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszNext = pwszzMerged;
    if (NULL != pwszzURLsOld)
    {
	for (pwsz = pwszzURLsOld; L'\0' != *pwsz; pwsz += cwcT)
	{
	    cwcT = wcslen(pwsz) + 1;
	    wcscpy(pwszNext, pwsz);
	    pwszNext += cwcT;
	}
    }
    if (NULL != pwszzURLsNew)
    {
	for (pwsz = pwszzURLsNew; L'\0' != *pwsz; pwsz += cwcT)
	{
	    cwcT = wcslen(pwsz) + 1;
	    if (MAXDWORD == CRLIsStringInList(pwsz, pwszzURLsOld))
	    {
		wcscpy(pwszNext, pwsz);
		pwszNext += cwcT;
	    }
	}
    }
    *pwszNext = L'\0';
    *ppwszzURLsMerged = pwszzMerged;
    hr = S_OK;

error:
    if (NULL != pwszzURLsOld)
    {
	LocalFree(pwszzURLsOld);
    }
    if (NULL != pwszzURLsNew)
    {
	LocalFree(pwszzURLsNew);
    }
    return(hr);
}


// crlBuildUserURLReferenceList -- construct a new User and URL reference list
//
// "-" means the system published successfully (no failed URLs).
// "Published by User\Domain" means User\Domain published successfully.
// "Published by User\Domain -- 0 3" means User\Domain published CRLs, but
// publishing failed for URLs 0 and 3 in the merged URL list.


HRESULT
crlBuildUserURLReferenceList(
    OPTIONAL IN WCHAR const *pwszUserName,
    OPTIONAL IN WCHAR const *pwszURLsNew,
    OPTIONAL IN WCHAR const *pwszzURLsMerged,
    OUT WCHAR **ppwszUserURLReference)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszzURLsNew = NULL;
    WCHAR const *pwsz;
    WCHAR *pwszT;
    DWORD cURL;
    WCHAR *pwszUserURLReference;

    *ppwszUserURLReference = NULL;

    cwc = 1;
    if (NULL != pwszUserName)
    {
	cwc = wcslen(g_pwszPublishedBy) + wcslen(pwszUserName);
    }
    cURL = 0;
    if (NULL != pwszURLsNew)
    {
	hr = crlSplitStrings(pwszURLsNew, &pwszzURLsNew);
	_JumpIfError(hr, error, "crlSplitStrings");

	for (pwsz = pwszzURLsNew; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    cURL++;
	}
	if (0 != cURL)
	{
	    cwc += 3 + (1 + cwcDWORDSPRINTF) * cURL;
	}
    }

    pwszUserURLReference = (WCHAR *) LocalAlloc(
					    LMEM_FIXED,
					    (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszUserURLReference)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszUserURLReference, L"-");
    if (NULL != pwszUserName)
    {
	swprintf(pwszUserURLReference, g_pwszPublishedBy, pwszUserName);
    }
    if (0 != cURL)
    {
	pwszT = wcschr(pwszUserURLReference, L'\0');
	wcscpy(pwszT, L" --");

	for (pwsz = pwszzURLsNew; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    pwszT += wcslen(pwszT);
	    swprintf(pwszT, L" %u", CRLIsStringInList(pwsz, pwszzURLsMerged));
	}
    }
    CSASSERT(wcslen(pwszUserURLReference) <= cwc);
    *ppwszUserURLReference = pwszUserURLReference;
    hr = S_OK;

error:
    if (NULL != pwszzURLsNew)
    {
	LocalFree(pwszzURLsNew);
    }
    return(hr);
}


// crlCombineCRLError -- merge new and existing CRL error strings
//
// pwszCRLError consists of "Url0\nUrl1..."
//
// pwszCRLErrorNew will consist of "User\n\nUrl0\nUrl1..."
// After second and third attempts, pwszCRLErrorNew will consist of
// "User\nUser\n\nUrl0\nUrl1..." and "User\nUser\nUser\n\nUrl0\nUrl1..."
//
// 
// pwszCRLErrorNew will consist of "User -- 0 1 ...\n\nUrl0\nUrl1..."
// After second and third attempts, pwszCRLErrorNew will consist of
// "User -- 0 1 ...\nUser -- 1\n\nUrl0\nUrl1..." and
// "User -- 0 1 ...\nUser -- 1\nUser -- 1\n\nUrl0\nUrl1..."


HRESULT
crlCombineCRLError(
    IN ICertDBRow *prow,
    OPTIONAL IN WCHAR const *pwszUserName,	// else timer thread
    OPTIONAL IN WCHAR const *pwszURLsNew,	// else no errors
    OUT WCHAR **ppwszCRLErrorNew)
{
    HRESULT hr;
    WCHAR *pwszUserListOld = NULL;
    WCHAR *pwszCRLErrorNew = NULL;
    WCHAR *pwszURLsOld;
    WCHAR *pwszzURLsMerged = NULL;
    WCHAR *pwszUserURLReference = NULL;
    DWORD cwc;

    *ppwszCRLErrorNew = NULL;

    hr = PKCSGetProperty(
		    prow,
		    g_wszPropCRLPublishError,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CRL,
		    NULL,
		    (BYTE **) &pwszUserListOld);
    _PrintIfError2(hr, "PKCSGetProperty", CERTSRV_E_PROPERTY_EMPTY);

    pwszURLsOld = NULL;
    if (NULL != pwszUserListOld)
    {
	pwszURLsOld = wcsstr(pwszUserListOld, L"\n\n");
	if (NULL != pwszURLsOld)
	{
	    // truncate user list and point to the URL List
	    
	    *pwszURLsOld++ = L'\0';
	    pwszURLsOld++;
	    if (L'\0' == *pwszURLsOld)
	    {
		pwszURLsOld = NULL;
	    }
	}
    }
    hr = crlMergeURLList(pwszURLsOld, pwszURLsNew, &pwszzURLsMerged);
    _JumpIfError(hr, error, "crlMergeURLList");

    hr = crlBuildUserURLReferenceList(
				pwszUserName,
				pwszURLsNew,
				pwszzURLsMerged,
				&pwszUserURLReference);
    _JumpIfError(hr, error, "crlBuildUserURLReferenceList");

    // convert pwszz string list into newline separated strings

    crlUnsplitStrings(pwszzURLsMerged);

    cwc = 0;
    if (NULL != pwszUserListOld)
    {
	cwc += wcslen(pwszUserListOld) + 1;	// newline separator
    }
    cwc += wcslen(pwszUserURLReference);
    if (NULL != pwszzURLsMerged)
    {
	cwc += 2 + wcslen(pwszzURLsMerged); // double newline separator
    }

    pwszCRLErrorNew = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszCRLErrorNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    *pwszCRLErrorNew = L'\0';
    if (NULL != pwszUserListOld && L'\0' != *pwszUserListOld)
    {
	wcscat(pwszCRLErrorNew, pwszUserListOld);
	wcscat(pwszCRLErrorNew, L"\n");
    }
    wcscat(pwszCRLErrorNew, pwszUserURLReference);
    if (NULL != pwszzURLsMerged)
    {
	wcscat(pwszCRLErrorNew, L"\n\n");	// double newline separator
	wcscat(pwszCRLErrorNew, pwszzURLsMerged);
    }
    CSASSERT(wcslen(pwszCRLErrorNew) <= cwc);
    *ppwszCRLErrorNew = pwszCRLErrorNew;
    pwszCRLErrorNew = NULL;
    hr = S_OK;

error:
    if (NULL != pwszUserURLReference)
    {
	LocalFree(pwszUserURLReference);
    }
    if (NULL != pwszzURLsMerged)
    {
	LocalFree(pwszzURLsMerged);
    }
    if (NULL != pwszUserListOld)
    {
	LocalFree(pwszUserListOld);
    }
    if (NULL != pwszCRLErrorNew)
    {
	LocalFree(pwszCRLErrorNew);
    }
    return(hr);
}


HRESULT
crlUpdateCRLPublishStateInDB(
    IN DWORD RowId,
    IN FILETIME const *pftCurrent,
    IN HRESULT hrCRLPublish,
    IN DWORD CRLPublishFlags,
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    OPTIONAL IN WCHAR const *pwszCRLError)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    WCHAR *pwszCRLErrorNew = NULL;
    DWORD cb;
    DWORD dw;
    BOOL fCommitted = FALSE;

    hr = g_pCertDB->OpenRow(
			PROPTABLE_CRL,
			RowId,
			NULL,
			&prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = prow->SetProperty(
		    g_wszPropCRLLastPublished,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CRL,
                    sizeof(*pftCurrent),
                    (BYTE const *) pftCurrent);
    _JumpIfError(hr, error, "SetProperty");

    cb = sizeof(dw);
    hr = prow->GetProperty(
		    g_wszPropCRLPublishAttempts,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    NULL,
		    &cb,
		    (BYTE *) &dw);
    if (S_OK != hr)
    {
	dw = 0;
    }
    dw++;

    hr = prow->SetProperty(
		    g_wszPropCRLPublishAttempts,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(dw),
		    (BYTE const *) &dw);
    _JumpIfError(hr, error, "SetProperty");

    cb = sizeof(dw);
    hr = prow->GetProperty(
		    g_wszPropCRLPublishFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    NULL,
		    &cb,
		    (BYTE *) &dw);
    if (S_OK != hr)
    {
	dw = 0;
    }
    CRLPublishFlags |= (CPF_BASE | CPF_DELTA | CPF_SHADOW | CPF_MANUAL) & dw;
    if (S_OK == hrCRLPublish)
    {
	CRLPublishFlags |= CPF_COMPLETE;
    }
    hr = prow->SetProperty(
		    g_wszPropCRLPublishFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(CRLPublishFlags),
		    (BYTE const *) &CRLPublishFlags);
    _JumpIfError(hr, error, "SetProperty");

    // Always set error string property to clear out previous errors.

    hr = prow->SetProperty(
		    g_wszPropCRLPublishStatusCode,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CRL,
		    sizeof(hrCRLPublish),
		    (BYTE const *) &hrCRLPublish);
    _JumpIfError(hr, error, "SetProperty");

    hr = crlCombineCRLError(prow, pwszUserName, pwszCRLError, &pwszCRLErrorNew);
    _JumpIfError(hr, error, "crlCombineCRLError");

    if (NULL != pwszCRLErrorNew)
    {
	hr = prow->SetProperty(
			g_wszPropCRLPublishError,
			PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CRL,
			MAXDWORD,
			(BYTE const *) pwszCRLErrorNew);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = prow->CommitTransaction(TRUE);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pwszCRLErrorNew)
    {
	LocalFree(pwszCRLErrorNew);
    }
    return(hr);
}


HRESULT
WriteCRLToDSAttribute(
    IN WCHAR const *pwszCRLDN,
    IN BOOL fDelta,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD ldaperr;
    BOOL fRebind = FALSE;

    LDAPMod crlmod;
    struct berval crlberval;
    struct berval *crlVals[2];
    LDAPMod *mods[2];

    for (;;)
    {
	if (NULL == g_pld)
	{
	    hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&g_pld,
			NULL);			  // ppwszForestDNSName
	    _JumpIfError(hr, error, "myRobustLdapBindEx");
	}

	mods[0] = &crlmod;
	mods[1] = NULL;

	crlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
	crlmod.mod_type = fDelta? wszDSDELTACRLATTRIBUTE : wszDSBASECRLATTRIBUTE;
	crlmod.mod_bvalues = crlVals;

	crlVals[0] = &crlberval;
	crlVals[1] = NULL;

	crlberval.bv_len = cbCRL;
	crlberval.bv_val = (char *) pbCRL;

	ldaperr = ldap_modify_ext_s(
			    g_pld,
			    const_cast<WCHAR *>(pwszCRLDN),
			    mods,
			    NULL,
			    NULL);
	hr = myHLdapError(g_pld, ldaperr, ppwszError);
	_PrintIfErrorStr(hr, "ldap_modify_ext_s", pwszCRLDN);
	if (fRebind || S_OK == hr)
	{
	    break;
	}
	if (!myLdapRebindRequired(ldaperr, g_pld))
	{
	    _JumpErrorStr(hr, error, "ldap_modify_ext_s", pwszCRLDN);
	}
	fRebind = TRUE;
	if (NULL != g_pld)
	{
	    ldap_unbind(g_pld);
	    g_pld = NULL;
	}
    }

error:
    return(hr);
}


HRESULT
crlParseURLPrefix(
    IN WCHAR const *pwszIn,
    IN DWORD cwcPrefix,
    OUT WCHAR *pwcPrefix,
    OUT WCHAR const **ppwszOut)
{
    HRESULT hr;
    WCHAR const *pwsz;

    CSASSERT(6 <= cwcPrefix);
    wcscpy(pwcPrefix, L"file:");
    *ppwszOut = pwszIn;

    if (L'\\' != pwszIn[0] || L'\\' != pwszIn[1])
    {
	pwsz = wcschr(pwszIn, L':');
	if (NULL != pwsz)
	{
	    DWORD cwc;

	    pwsz++;
	    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszIn);
	    if (2 < cwc && cwc < cwcPrefix)
	    {
		CopyMemory(pwcPrefix, pwszIn, cwc * sizeof(WCHAR));
		pwcPrefix[cwc] = L'\0';
		if (0 == LSTRCMPIS(pwcPrefix, L"file:") &&
		    L'/' == pwsz[0] &&
		    L'/' == pwsz[1])
		{
		    pwsz += 2;
		}
		*ppwszOut = pwsz;
	    }
	}
    }
    hr = S_OK;

//error:
    return(hr);
}


VOID
crlLogError(
    IN BOOL fDelta,
    IN BOOL fLdapURL,
    IN DWORD iKey,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszError,
    IN HRESULT hrPublish)
{
    HRESULT hr;
    WCHAR const *apwsz[6];
    WORD cpwsz;
    WCHAR wszKey[cwcDWORDSPRINTF];
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszMessageText = NULL;
    WCHAR *pwszHostName = NULL;
    DWORD LogMsg;

    if (fLdapURL && NULL != g_pld)
    {
	myLdapGetDSHostName(g_pld, &pwszHostName);
    }

    wsprintf(wszKey, L"%u", iKey);
    pwszMessageText = myGetErrorMessageText(hrPublish, TRUE);
    if (NULL == pwszMessageText)
    {
	pwszMessageText = myHResultToStringRaw(awchr, hrPublish);
    }
    cpwsz = 0;
    apwsz[cpwsz++] = wszKey;
    apwsz[cpwsz++] = pwszURL;
    apwsz[cpwsz++] = pwszMessageText;

    LogMsg = fDelta?
	MSG_E_DELTA_CRL_PUBLICATION : MSG_E_BASE_CRL_PUBLICATION;
    if (NULL != pwszHostName)
    {
	LogMsg = fDelta?
	    MSG_E_DELTA_CRL_PUBLICATION_HOST_NAME :
	    MSG_E_BASE_CRL_PUBLICATION_HOST_NAME;
    }
    else
    {
	pwszHostName = L"";
    }
    apwsz[cpwsz++] = pwszHostName;
    apwsz[cpwsz++] = NULL != pwszError? L"\n" : L"";
    apwsz[cpwsz++] = NULL != pwszError? pwszError : L"";
    CSASSERT(ARRAYSIZE(apwsz) >= cpwsz);

    if (CERTLOG_ERROR <= g_dwLogLevel)
    {
	hr = LogEvent(EVENTLOG_ERROR_TYPE, LogMsg, cpwsz, apwsz);
	_PrintIfError(hr, "LogEvent");
    }

//error:
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
}


HRESULT
crlWriteCRLToURL(
    IN BOOL fDelta,
    IN BOOL iKey,
    IN WCHAR const *pwszURL,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    OUT DWORD *pPublishFlags)
{
    HRESULT hr;
    WCHAR const *pwsz2;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszT;
    WCHAR awcPrefix[6];		// file:/ftp:/http:/ldap: and trailing '\0'
    DWORD ErrorFlags;
    WCHAR *pwszError = NULL;

    *pPublishFlags = 0;

    ErrorFlags = CPF_BADURL_ERROR;
    hr = crlParseURLPrefix(
		    pwszURL,
		    ARRAYSIZE(awcPrefix),
		    awcPrefix,
		    &pwsz2);
    _JumpIfError(hr, error, "crlParseURLPrefix");

    DBGPRINT((
	DBG_SS_CERTSRV,
	"crlWriteCRLToURL: \"%ws\" %ws\n",
	awcPrefix,
	pwsz2));
    if (0 == LSTRCMPIS(awcPrefix, L"file:"))
    {
	ErrorFlags = CPF_FILE_ERROR;

	// tricky

	hr = CRLWriteToLockedFile(pbCRL, cbCRL, FALSE, pwsz2);
	_JumpIfError(hr, error, "CRLWriteToLockedFile");
    }
    else if (0 == LSTRCMPIS(awcPrefix, L"ftp:"))
    {
	ErrorFlags = CPF_FTP_ERROR;
	hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	_JumpError(hr, error, "Publish to ftp:");
    }
    else if (0 == LSTRCMPIS(awcPrefix, L"http:"))
    {
	ErrorFlags = CPF_HTTP_ERROR;
	hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	_JumpError(hr, error, "Publish to http:");
    }
    else if (0 == LSTRCMPIS(awcPrefix, L"ldap:"))
    {
	ErrorFlags = CPF_LDAP_ERROR;
	while (L'/' == *pwsz2)
	{
	    pwsz2++;
	}
	hr = myDupString(pwsz2, &pwszDup);
	_JumpIfError(hr, error, "myDupString");

	pwszT = wcschr(pwszDup, L'?');
	if (NULL != pwszT)
	{
	    *pwszT = L'\0';
	}
	hr = WriteCRLToDSAttribute(pwszDup, fDelta, pbCRL, cbCRL, &pwszError);
	_JumpIfError(hr, error, "WriteCRLToDSAttribute");
    }
    else
    {
	ErrorFlags = CPF_BADURL_ERROR;
	hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	_JumpError(hr, error, "Publish to unknown URL type");
    }
    CSASSERT(S_OK == hr);

error:
    if (S_OK != hr)
    {
	*pPublishFlags = ErrorFlags;
	crlLogError(
		fDelta,
		CPF_LDAP_ERROR == ErrorFlags,
		iKey,
		pwszURL,
		pwszError,
		hr);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
crlWriteCRLToURLList(
    IN BOOL fDelta,
    IN DWORD iKey,
    IN WCHAR const * const *papwszURLs,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    IN OUT DWORD *pCRLPublishFlags,
    OUT WCHAR **ppwszCRLError)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    DWORD PublishFlags;

    *ppwszCRLError = NULL;

    // publish this CRL in multiple places

    if (NULL != papwszURLs)
    {
	WCHAR const * const *ppwsz;

	for (ppwsz = papwszURLs; NULL != *ppwsz; ppwsz++)
	{
	    PublishFlags = 0;

	    hr2 = crlWriteCRLToURL(
			    fDelta,
			    iKey,
			    *ppwsz,
			    pbCRL,
			    cbCRL,
			    &PublishFlags);
	    *pCRLPublishFlags |= PublishFlags;
	    if (S_OK != hr2)
	    {
		if (S_OK == hr)
		{
		    hr = hr2;		// Save first error
		}
		_PrintError(hr2, "crlWriteCRLToURL");

		hr2 = myAppendString(*ppwsz, L"\n", ppwszCRLError);
		_PrintIfError(hr2, "myAppendString");
		if (S_OK == hr)
		{
		    hr = hr2;		// Save first error
		}
	    }
	}
    }

//error:
    return(hr);
}


HRESULT
crlWriteCRLToCAStore(
    IN BOOL fDelta,
    IN DWORD iKey,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    IN CERT_CONTEXT const *pccCA)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CRL_CONTEXT const *pCRLStore = NULL;
    CRL_CONTEXT const *pCRLNew = NULL;
    BOOL fFound = FALSE;

    hStore = CertOpenStore(
                       CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                       X509_ASN_ENCODING,
                       NULL,			// hProv
                       CERT_SYSTEM_STORE_LOCAL_MACHINE,
		       wszCA_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    for (;;)
    {
	DWORD dwCryptFlags;
	BOOL fIsDeltaCRL;
	CRL_CONTEXT const *pCRL;

	dwCryptFlags = CERT_STORE_SIGNATURE_FLAG;
	pCRLStore = CertGetCRLFromStore(
				    hStore,
				    pccCA,
				    pCRLStore,
				    &dwCryptFlags);
	if (NULL == pCRLStore)
	{
	    break;
	}

	// delete this CRL from the store ONLY if the CRL signature matches
	// this CA context's public key

	if (0 != dwCryptFlags)
	{
	    continue;		// no match -- skip
	}

	hr = myIsDeltaCRL(pCRLStore, &fIsDeltaCRL);
	_JumpIfError(hr, error, "myIsDeltaCRL");

	if (fIsDeltaCRL)
	{
	    if (!fDelta)
	    {
		continue;	// no match -- skip Delta CRLs
	    }
	}
	else
	{
	    if (fDelta)
	    {
		continue;	// no match -- skip Base CRLs
	    }
	}

	// See if it has already been published

	if (cbCRL == pCRLStore->cbCrlEncoded &&
	    0 == memcmp(pbCRL, pCRLStore->pbCrlEncoded, cbCRL))
	{
	    fFound = TRUE;
	    continue;		// exact match -- already published
	}

	pCRL = CertDuplicateCRLContext(pCRLStore);
	if (!CertDeleteCRLFromStore(pCRL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDeleteCRLFromStore");
	}
    }

    if (!fFound)
    {
	pCRLNew = CertCreateCRLContext(X509_ASN_ENCODING, pbCRL, cbCRL);
	if (NULL == pCRLNew)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCRLContext");
	}

	if (!CertAddCRLContextToStore(
				  hStore,
				  pCRLNew,
				  CERT_STORE_ADD_ALWAYS,
				  NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCRLContextToStore");
	}
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	crlLogError(fDelta, FALSE, iKey, g_pwszIntermediateCAStore, NULL, hr);
    }
    if (NULL != pCRLNew)
    {
        CertFreeCRLContext(pCRLNew);
    }
    if (NULL != pCRLStore)
    {
        CertFreeCRLContext(pCRLStore);
    }
    if (NULL != hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
crlPublishGeneratedCRL(
    IN DWORD RowId,
    IN FILETIME const *pftCurrent,
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDelta,
    IN DWORD iKey,
    IN BYTE const *pbCRL,
    IN DWORD cbCRL,
    IN CACTX const *pCAContext,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrCRLPublish)
{
    HRESULT hr;
    HRESULT hrCRLPublish;
    DWORD CRLPublishFlags;
    WCHAR *pwszCRLError = NULL;

    *pfRetryNeeded = FALSE;
    hrCRLPublish = S_OK;
    CRLPublishFlags = 0;

    // first verify CRL signature with the CA Cert public key (catch bad CSPs)

    if (!CryptVerifyCertificateSignature(
			NULL,
			X509_ASN_ENCODING,
			pbCRL,
			cbCRL,
			&pCAContext->pccCA->pCertInfo->SubjectPublicKeyInfo))
    {
	hr = myHLastError();
	_PrintError(hr, "CryptVerifyCertificateSignature");
	hrCRLPublish = hr;		// save first error
	CRLPublishFlags |= CPF_SIGNATURE_ERROR;
    }
    else
    {
	hr = crlWriteCRLToCAStore(
			    fDelta,
			    iKey,
			    pbCRL,
			    cbCRL,
			    pCAContext->pccCA);
	if (S_OK != hr)
	{
	    _PrintError(hr, "crlWriteCRLToCAStore");
	    hrCRLPublish = hr;
	    CRLPublishFlags |= CPF_CASTORE_ERROR;
	}

	hr = crlWriteCRLToURLList(
			    fDelta,
			    iKey,
			    fDelta?
				pCAContext->papwszDeltaCRLFiles :
				pCAContext->papwszCRLFiles,
			    pbCRL,
			    cbCRL,
			    &CRLPublishFlags,
			    &pwszCRLError);
	if (S_OK != hr)
	{
	    _PrintError(hr, "crlWriteCRLToURLList");
	    if (S_OK == hrCRLPublish)
	    {
		hrCRLPublish = hr;		// save first error
	    }
	}
    }
    if (S_OK != hrCRLPublish)
    {
	*pfRetryNeeded = TRUE;
    }
    hr = crlUpdateCRLPublishStateInDB(
				RowId,
				pftCurrent,
				hrCRLPublish,
				CRLPublishFlags,
				pwszUserName,
				pwszCRLError);
    _JumpIfError(hr, error, "crlUpdateCRLPublishStateInDB");

error:
    *phrCRLPublish = hrCRLPublish;
    if (NULL != pwszCRLError)
    {
        LocalFree(pwszCRLError);
    }
    return(hr);
}


HRESULT
crlSignAndSaveCRL(
    IN DWORD CRLNumber,
    IN DWORD CRLNumberBaseMin,		// 0 implies Base CRL; else Delta CRL
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN CACTX const *pCAContext,
    IN DWORD cCRL,
    IN CRL_ENTRY *aCRL,
    IN FILETIME const *pftCurrent,
    IN FILETIME const *pftThisUpdate,	// includes skew
    OPTIONAL IN FILETIME const *pftNextUpdate,	// includes skew & overlap
    IN FILETIME const *pftThisPublish,
    OPTIONAL IN FILETIME const *pftNextPublish,
    OPTIONAL IN FILETIME const *pftQuery,
    IN FILETIME const *pftPropagationComplete,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrCRLPublish)
{
    HRESULT hr;
    CRL_INFO CRLInfo;
    DWORD i;
    DWORD cb;
    DWORD cbCRL;
    BYTE *pbCrlEncoded = NULL;
    BYTE *pbCRL = NULL;
#define CCRLEXT	6
    CERT_EXTENSION aext[CCRLEXT];
    BYTE *apbFree[CCRLEXT];
    DWORD cpbFree = 0;
    DWORD RowId;

    *pfRetryNeeded = FALSE;
    *phrCRLPublish = S_OK;

    ZeroMemory(&CRLInfo, sizeof(CRLInfo));
    CRLInfo.dwVersion = CRL_V2;
    CRLInfo.SignatureAlgorithm.pszObjId = pCAContext->pszObjIdSignatureAlgorithm;
    CRLInfo.Issuer.pbData = pCAContext->pccCA->pCertInfo->Subject.pbData;
    CRLInfo.Issuer.cbData = pCAContext->pccCA->pCertInfo->Subject.cbData;
    CRLInfo.ThisUpdate = *pftThisUpdate;
    if (NULL != pftNextUpdate)
    {
	CRLInfo.NextUpdate = *pftNextUpdate;
    }
    CRLInfo.cCRLEntry = cCRL;
    CRLInfo.rgCRLEntry = aCRL;

    CRLInfo.cExtension = 0;
    CRLInfo.rgExtension = aext;
    ZeroMemory(aext, sizeof(aext));

    if (NULL != pCAContext->KeyAuthority2CRL.pbData)
    {
	aext[CRLInfo.cExtension].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER2;
	if (EDITF_ENABLEAKICRITICAL & g_CRLEditFlags)
	{
	    aext[CRLInfo.cExtension].fCritical = TRUE;
	}
	aext[CRLInfo.cExtension].Value = pCAContext->KeyAuthority2CRL;
	CRLInfo.cExtension++;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    &pCAContext->NameId,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aext[CRLInfo.cExtension].Value.pbData,
		    &aext[CRLInfo.cExtension].Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    aext[CRLInfo.cExtension].pszObjId = szOID_CERTSRV_CA_VERSION;
    apbFree[cpbFree++] = aext[CRLInfo.cExtension].Value.pbData,
    CRLInfo.cExtension++;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    &CRLNumber,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aext[CRLInfo.cExtension].Value.pbData,
		    &aext[CRLInfo.cExtension].Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    aext[CRLInfo.cExtension].pszObjId = szOID_CRL_NUMBER;
    apbFree[cpbFree++] = aext[CRLInfo.cExtension].Value.pbData;
    if ((CRLF_CRLNUMBER_CRITICAL & g_dwCRLFlags) && 0 == CRLNumberBaseMin)
    {
	aext[CRLInfo.cExtension].fCritical = TRUE;
    }
    CRLInfo.cExtension++;

    // NextPublish is the earliest the client should look for a newer CRL.

    if (NULL != pftNextPublish)
    {
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_CHOICE_OF_TIME,
			pftNextPublish,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aext[CRLInfo.cExtension].Value.pbData,
			&aext[CRLInfo.cExtension].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aext[CRLInfo.cExtension].pszObjId = szOID_CRL_NEXT_PUBLISH;
	apbFree[cpbFree++] = aext[CRLInfo.cExtension].Value.pbData,
	CRLInfo.cExtension++;
    }

    if (0 != CRLNumberBaseMin)		// if Delta CRL
    {
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			&CRLNumberBaseMin,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aext[CRLInfo.cExtension].Value.pbData,
			&aext[CRLInfo.cExtension].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aext[CRLInfo.cExtension].pszObjId = szOID_DELTA_CRL_INDICATOR;
	aext[CRLInfo.cExtension].fCritical = TRUE;
	apbFree[cpbFree++] = aext[CRLInfo.cExtension].Value.pbData,
	CRLInfo.cExtension++;

	// Add a CDP to base and delta CRLs to make it easier to manually
	// publish an off-line CA's CRLs to the correct DS location.

	if (NULL != pCAContext->CDPCRLDelta.pbData)
	{
	    aext[CRLInfo.cExtension].pszObjId = szOID_CRL_SELF_CDP;
	    aext[CRLInfo.cExtension].Value = pCAContext->CDPCRLDelta;
	    CRLInfo.cExtension++;
	}
    }
    else
    {
	// else if Base CRL (and if delta CRLs are enabled)

	if (!g_fDeltaCRLPublishDisabled &&
	    NULL != pCAContext->CDPCRLFreshest.pbData)
	{
	    aext[CRLInfo.cExtension].pszObjId = szOID_FRESHEST_CRL;
	    aext[CRLInfo.cExtension].Value = pCAContext->CDPCRLFreshest;
	    CRLInfo.cExtension++;
	}

	// Add a CDP to base and delta CRLs to make it easier to manually
	// publish an off-line CA's CRLs to the correct DS location.

	if (NULL != pCAContext->CDPCRLBase.pbData)
	{
	    aext[CRLInfo.cExtension].pszObjId = szOID_CRL_SELF_CDP;
	    aext[CRLInfo.cExtension].Value = pCAContext->CDPCRLBase;
	    CRLInfo.cExtension++;
	}
    }
    CSASSERT(ARRAYSIZE(aext) >= CRLInfo.cExtension);

    if (!myEncodeObject(
                    X509_ASN_ENCODING,
                    X509_CERT_CRL_TO_BE_SIGNED,
                    &CRLInfo,
                    0,
                    CERTLIB_USE_LOCALALLOC,
                    &pbCrlEncoded,               // pbEncoded
                    &cb))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    hr = myEncodeSignedContent(
			pCAContext->hProvCA,
			X509_ASN_ENCODING,
			pCAContext->pszObjIdSignatureAlgorithm,
			pbCrlEncoded,
			cb,
			CERTLIB_USE_LOCALALLOC,
			&pbCRL,
			&cbCRL); // use LocalAlloc*
    _JumpIfError(hr, error, "myEncodeSignedContent");

    hr = crlWriteCRLToDB(
		    CRLNumber,		 // CRLNumber
		    CRLNumberBaseMin,	 // CRLMinBase: 0 implies Base CRL
		    pwszUserName,
		    fShadowDelta,
		    pCAContext->NameId,  // CRLNameId
		    cCRL,		 // CRLCount
		    &CRLInfo.ThisUpdate, // pftThisUpdate
		    pftNextUpdate,
		    pftThisPublish,	 // pftThisPublish
		    pftNextPublish,	 // pftNextPublish
		    pftQuery,
		    pftPropagationComplete,
		    pbCRL,		 // pbCRL
		    cbCRL,		 // cbCRL
		    &RowId);
    _JumpIfError(hr, error, "crlWriteCRLToDB");

    hr = crlPublishGeneratedCRL(
		    RowId,
		    pftCurrent,
		    pwszUserName,
		    0 != CRLNumberBaseMin,	// fDelta
		    pCAContext->iKey,
		    pbCRL,		 	// pbCRL
		    cbCRL,		 	// cbCRL
		    pCAContext,
		    pfRetryNeeded,
		    phrCRLPublish);
    _JumpIfError(hr, error, "crlPublishGeneratedCRL");

error:
    CSASSERT(ARRAYSIZE(aext) >= CRLInfo.cExtension);
    CSASSERT(ARRAYSIZE(apbFree) >= cpbFree);
    for (i = 0; i < cpbFree; i++)
    {
	CSASSERT(NULL != apbFree[i]);
	LocalFree(apbFree[i]);
    }
    if (NULL != pbCrlEncoded)
    {
        LocalFree(pbCrlEncoded);
    }
    if (NULL != pbCRL)
    {
        LocalFree(pbCRL);
    }
    return(myHError(hr));
}


///////////////////////////////////////////////////
// crlPublishCRLFromCAContext is called to build and save one CRL.
//

HRESULT
crlPublishCRLFromCAContext(
    IN DWORD CRLNumber,
    IN DWORD CRLNumberBaseMin,		// 0 implies Base CRL; else Delta CRL
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN CACTX const *pCAContext,
    IN FILETIME const *pftCurrent,
    IN FILETIME ftThisUpdate,		// clamped by CA cert
    IN OUT FILETIME *pftNextUpdate,	// clamped by CA cert
    OPTIONAL OUT BOOL *pfClamped,
    OPTIONAL IN FILETIME const *pftQuery,
    IN FILETIME const *pftThisPublish,
    IN FILETIME const *pftNextPublish,
    IN FILETIME const *pftLastPublishBase,
    IN FILETIME const *pftPropagationComplete,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    DWORD cCRL = 0;
    CRL_ENTRY *aCRL = NULL;
    VOID *pvBlockSerial = NULL;
    CERT_INFO const *pCertInfo = pCAContext->pccCA->pCertInfo;

    *pfRetryNeeded = FALSE;
    *phrPublish = S_OK;
    hr = S_OK;
    __try
    {
	if (!fShadowDelta)
	{
	    hr = crlBuildCRLArray(
			0 != CRLNumberBaseMin,	// fDelta
			pftQuery,
			pftThisPublish,
			pftLastPublishBase,
			pCAContext->iKey,
			&cCRL,
			&aCRL,
			&pvBlockSerial);
	    _JumpIfError(hr, error, "crlBuildCRLArray");
	}

	// Ensure it is not before the CA certificate's start date.

	if (0 > CompareFileTime(&ftThisUpdate, &pCertInfo->NotBefore))
	{
	    // clamp
	    ftThisUpdate = pCertInfo->NotBefore;
	}

	// Ensure it is not after the CA certificate's end date.

        if (NULL != pfClamped)
        {
            //init to FALSE
            *pfClamped = FALSE;
        }

	if (0 == (CRLF_PUBLISH_EXPIRED_CERT_CRLS & g_dwCRLFlags) &&
	    0 < CompareFileTime(pftNextUpdate, &pCertInfo->NotAfter))
	{
	    // clamp
	    *pftNextUpdate = pCertInfo->NotAfter;
            if (NULL != pfClamped)
            {
                *pfClamped = TRUE;
            }
	    if (pCAContext->iKey < g_pCAContextCurrent->iKey)
	    {
		pftNextUpdate = NULL;
		pftNextPublish = NULL;
	    }
	}
#ifdef DBG_CERTSRV_DEBUG_PRINT
	{
	    WCHAR *pwszNow = NULL;
	    WCHAR *pwszQuery = NULL;
	    WCHAR *pwszThisUpdate = NULL;
	    WCHAR *pwszNextUpdate = NULL;
	    WCHAR const *pwszCRLType = 0 == CRLNumberBaseMin? L"Base" : L"Delta";

	    myGMTFileTimeToWszLocalTime(pftThisPublish, TRUE, &pwszNow);
	    if (NULL != pftQuery)
	    {
		myGMTFileTimeToWszLocalTime(pftQuery, TRUE, &pwszQuery);
	    }
	    myGMTFileTimeToWszLocalTime(&ftThisUpdate, TRUE, &pwszThisUpdate);
	    if (NULL != pftNextUpdate)
	    {
		myGMTFileTimeToWszLocalTime(pftNextUpdate, TRUE, &pwszNextUpdate);
	    }

	    DBGPRINT((
		DBG_SS_ERROR | DBG_SS_CERTSRV,
		"crlPublishCRLFromCAContext(tid=%d, CA Version=%u.%u): %ws CRL %u,%hs %u\n"
		    "        %ws CRL Publishing now(%ws)\n"
		    "        %ws CRL Query(%ws)\n"
		    "        %ws CRL ThisUpdate(%ws)\n"
		    "        %ws CRL NextUpdate(%ws)\n",
		GetCurrentThreadId(),
		pCAContext->iCert,
		pCAContext->iKey,
		pwszCRLType,
		CRLNumber,
		0 == CRLNumberBaseMin? "" : " Min Base",
		CRLNumberBaseMin,

		pwszCRLType,
		pwszNow,

		pwszCRLType,
		NULL != pftQuery? pwszQuery : L"None",

		pwszCRLType,
		pwszThisUpdate,

		pwszCRLType,
		pwszNextUpdate));
	    if (NULL != pwszNow)
	    {
		LocalFree(pwszNow);
	    }
	    if (NULL != pwszQuery)
	    {
		LocalFree(pwszQuery);
	    }
	    if (NULL != pwszThisUpdate)
	    {
		LocalFree(pwszThisUpdate);
	    }
	    if (NULL != pwszNextUpdate)
	    {
		LocalFree(pwszNextUpdate);
	    }
	}
#endif //DBG_CERTSRV_DEBUG_PRINT

	hr = CertSrvTestServerState();
	_JumpIfError(hr, error, "CertSrvTestServerState");

	hr = crlSignAndSaveCRL(
		    CRLNumber,
		    CRLNumberBaseMin,
		    pwszUserName,
		    fShadowDelta,
		    pCAContext,
		    cCRL,
		    aCRL,
		    pftCurrent,
		    &ftThisUpdate,
		    pftNextUpdate,
		    pftThisPublish,	// - no skew or overlap
		    pftNextPublish,	// no skew
		    pftQuery,
		    pftPropagationComplete,
		    pfRetryNeeded,
		    phrPublish);
	_JumpIfError(hr, error, "crlSignAndSaveCRL");

	CONSOLEPRINT4((
		DBG_SS_CERTSRV,
		"Published %hs CRL #%u for key %u.%u\n",
		0 == CRLNumberBaseMin? "Base" : "Delta",
		CRLNumber,
		pCAContext->iCert,
		pCAContext->iKey));

	CSASSERT(S_OK == hr);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    crlFreeCRLArray(pvBlockSerial, aCRL);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


DWORD g_aColCRLNumber[] = {

#define ICOL_CRLNUMBER		0
    DTI_CRLTABLE | DTL_NUMBER,
};


HRESULT
crlGetNextCRLNumber(
    OUT DWORD *pdwCRLNumber)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[1];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD Zero = 0;
    CERTDBRESULTROW aResult[1];
    CERTDBRESULTROW *pResult;
    DWORD celtFetched;
    BOOL fResultActive = FALSE;

    *pdwCRLNumber = 1;

    // Set up restrictions as follows:

    pcvr = acvr;

    // CRLNumber > 0 (indexed column)

    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NUMBER;
    pcvr->SeekOperator = CVR_SEEK_GT;
    pcvr->SortOrder = CVR_SORT_DESCEND;		// highest CRL Number first
    pcvr->pbValue = (BYTE *) &Zero;
    pcvr->cbValue = sizeof(Zero);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    celtFetched = 0;
    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			ARRAYSIZE(g_aColCRLNumber),
			g_aColCRLNumber,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    hr = pView->Next(NULL, ARRAYSIZE(aResult), aResult, &celtFetched);
    if (S_FALSE == hr)
    {
	if (0 == celtFetched)
	{
	    hr = S_OK;
	    goto error;
	}
    }
    _JumpIfError(hr, error, "Next");

    fResultActive = TRUE;

    CSASSERT(ARRAYSIZE(aResult) == celtFetched);

    pResult = &aResult[0];

    CSASSERT(ARRAYSIZE(g_aColCRLNumber) == pResult->ccol);
    CSASSERT(NULL != pResult->acol[ICOL_CRLNUMBER].pbValue);
    CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOL_CRLNUMBER].Type));
    CSASSERT(sizeof(*pdwCRLNumber) == pResult->acol[ICOL_CRLNUMBER].cbValue);

    *pdwCRLNumber = 1 + *(DWORD *) pResult->acol[ICOL_CRLNUMBER].pbValue;
    hr = S_OK;

error:
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    DBGPRINT((
	DBG_SS_CERTSRVI,
	"crlGetNextCRLNumber -> %u\n",
	*pdwCRLNumber));
    return(hr);
}
#undef ICOL_CRLNUMBER


//+--------------------------------------------------------------------------
// crlGetBaseCRLInfo -- get database column data for the most recent Base CRL
//
//---------------------------------------------------------------------------

DWORD g_aColBaseCRLInfo[] = {

#define ICOLBI_CRLNUMBER		0
    DTI_CRLTABLE | DTL_NUMBER,

#define ICOLBI_CRLTHISUPDATE		1
    DTI_CRLTABLE | DTL_THISUPDATEDATE,

#define ICOLBI_CRLNEXTUPDATE		2
    DTI_CRLTABLE | DTL_NEXTUPDATEDATE,

#define ICOLBI_CRLNAMEID		3
    DTI_CRLTABLE | DTL_NAMEID,
};

HRESULT
crlGetBaseCRLInfo(
    IN FILETIME const *pftCurrent,
    IN BOOL fOldestUnexpiredBase,	// else newest propagated CRL
    OUT DWORD *pdwRowId,
    OUT DWORD *pdwCRLNumber,
    OUT FILETIME *pftThisUpdate)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[2];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD Zero = 0;
    CERTDBRESULTROW aResult[1];
    CERTDBRESULTROW *pResult;
    DWORD celtFetched;
    BOOL fResultActive = FALSE;
    BOOL fSaveCRLInfo;

    DWORD RowId = 0;
    DWORD CRLNumber;
    FILETIME ftThisUpdate;
    FILETIME ftNextUpdate;
    FILETIME ftNextUpdateT;

    *pdwRowId = 0;
    *pdwCRLNumber = 0;
    CRLNumber = 0;
    pftThisUpdate->dwHighDateTime = 0;
    pftThisUpdate->dwLowDateTime = 0;

    if (CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE & g_dwCRLFlags)
    {
	fOldestUnexpiredBase = TRUE;
    }

    // Set up restrictions as follows:

    pcvr = acvr;
    if (fOldestUnexpiredBase)
    {
	// NextUpdate >= now

	pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NEXTUPDATEDATE;
	pcvr->SeekOperator = CVR_SEEK_GE;
    }
    else	// else newest propagated CRL
    {
	// PropagationComplete < now

	pcvr->ColumnIndex = DTI_CRLTABLE | DTL_PROPAGATIONCOMPLETEDATE;
	pcvr->SeekOperator = CVR_SEEK_LT;
    }
    pcvr->SortOrder = CVR_SORT_DESCEND;		// Newest CRL first
    pcvr->pbValue = (BYTE *) pftCurrent;
    pcvr->cbValue = sizeof(*pftCurrent);
    pcvr++;

    // CRL Minimum Base == 0 (to eliminate delta CRLs)

    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_MINBASE;
    pcvr->SeekOperator = CVR_SEEK_EQ;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &Zero;
    pcvr->cbValue = sizeof(Zero);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    celtFetched = 0;
    ZeroMemory(&ftThisUpdate, sizeof(ftThisUpdate));
    ZeroMemory(&ftNextUpdate, sizeof(ftNextUpdate));
    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			ARRAYSIZE(g_aColBaseCRLInfo),
			g_aColBaseCRLInfo,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    while (0 == RowId || fOldestUnexpiredBase)
    {
	hr = pView->Next(NULL, ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    CSASSERT(0 == celtFetched);
	    if (0 != RowId)
	    {
		break;
	    }
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	_JumpIfError(hr, error, "Next: no matching base CRL");

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) == celtFetched);

	pResult = &aResult[0];

	CSASSERT(ARRAYSIZE(g_aColBaseCRLInfo) == pResult->ccol);

	CSASSERT(NULL != pResult->acol[ICOLBI_CRLNUMBER].pbValue);
	CSASSERT(PROPTYPE_LONG == (PROPTYPE_MASK & pResult->acol[ICOLBI_CRLNUMBER].Type));
	CSASSERT(sizeof(DWORD) == pResult->acol[ICOLBI_CRLNUMBER].cbValue);

	CSASSERT(NULL != pResult->acol[ICOLBI_CRLTHISUPDATE].pbValue);
	CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLBI_CRLTHISUPDATE].Type));
	CSASSERT(sizeof(FILETIME) == pResult->acol[ICOLBI_CRLTHISUPDATE].cbValue);

	if (NULL != pResult->acol[ICOLBI_CRLNEXTUPDATE].pbValue)
	{
	    CSASSERT(PROPTYPE_DATE == (PROPTYPE_MASK & pResult->acol[ICOLBI_CRLNEXTUPDATE].Type));
	    CSASSERT(sizeof(FILETIME) == pResult->acol[ICOLBI_CRLNEXTUPDATE].cbValue);
	    ftNextUpdateT = *(FILETIME *) pResult->acol[ICOLBI_CRLNEXTUPDATE].pbValue;
	}
	else
	{
	    ftNextUpdateT.dwHighDateTime = MAXDWORD;
	    ftNextUpdateT.dwLowDateTime = MAXDWORD;
	}

	DBGPRINT((DBG_SS_CERTSRVI, "Query:RowId: %u\n", pResult->rowid));
	DBGPRINT((DBG_SS_CERTSRVI, "Query:CRLNumber: %u\n", *(DWORD *) pResult->acol[ICOLBI_CRLNUMBER].pbValue));
	DBGPRINT((DBG_SS_CERTSRVI, "Query:NameId: 0x%x\n", *(DWORD *) pResult->acol[ICOLBI_CRLNAMEID].pbValue));
	DBGPRINTTIME(NULL, "Query:ThisUpdate", DPT_DATE, *(FILETIME *) pResult->acol[ICOLBI_CRLTHISUPDATE].pbValue);
	DBGPRINTTIME(NULL, "Query:NextUpdate", DPT_DATE, ftNextUpdateT);

	if (0 == RowId)
	{
	    // save first matching row info
	    
	    fSaveCRLInfo = TRUE;
	}
	else
	{
	    // save row info, if looking for
	    // oldest unexpired base & this CRL expires before the saved CRL
	    //     +1 if first > second -- saved > this
	    
	    CSASSERT(fOldestUnexpiredBase);

	    fSaveCRLInfo = 0 < CompareFileTime(&ftNextUpdate, &ftNextUpdateT);
	}
	if (fSaveCRLInfo)
	{
	    CRLNumber = *(DWORD *) pResult->acol[ICOLBI_CRLNUMBER].pbValue;
	    ftThisUpdate = *(FILETIME *) pResult->acol[ICOLBI_CRLTHISUPDATE].pbValue;
	    ftNextUpdate = ftNextUpdateT;
	    RowId = pResult->rowid;
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"Query: SAVED RowId=%u CRLNumber=%u\n",
		pResult->rowid,
		CRLNumber));
	    DBGPRINTTIME(NULL, "ftThisUpdate", DPT_DATE, ftThisUpdate);
	}
	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }

    *pdwRowId = RowId;
    *pdwCRLNumber = CRLNumber;
    *pftThisUpdate = ftThisUpdate;
    DBGPRINTTIME(NULL, "*pftThisUpdate", DPT_DATE, *pftThisUpdate);
    DBGPRINTTIME(NULL, "ftNextUpdate", DPT_DATE, ftNextUpdate);
    hr = S_OK;

error:
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    DBGPRINT((
	DBG_SS_CERTSRV,
	"crlGetBaseCRLInfo -> RowId=%u, CRL=%u\n",
	*pdwRowId,
	*pdwCRLNumber));
    return(hr);
}
#undef ICOLBI_CRLNUMBER
#undef ICOLBI_CRLTHISUPDATE
#undef ICOLBI_CRLNEXTUPDATE
#undef ICOLBI_CRLNAMEID


DWORD g_aColRepublishCRLInfo[] = {

#define ICOLRI_CRLNUMBER		0
    DTI_CRLTABLE | DTL_NUMBER,

#define ICOLRI_CRLNAMEID		1
    DTI_CRLTABLE | DTL_NAMEID,

#define ICOLRI_CRLPUBLISHFLAGS		2
    DTI_CRLTABLE | DTL_PUBLISHFLAGS,

#define ICOLRI_CRLTHISUPDATE		3
    DTI_CRLTABLE | DTL_THISUPDATEDATE,

#define ICOLRI_CRLNEXTUPDATE		4
    DTI_CRLTABLE | DTL_NEXTUPDATEDATE,

#define ICOLRI_CRLRAWCRL		5
    DTI_CRLTABLE | DTL_RAWCRL,
};

HRESULT
crlGetRowIdAndCRL(
    IN BOOL fDelta,
    IN CACTX *pCAContext,
    OUT DWORD *pdwRowId,
    OUT DWORD *pcbCRL,
    OPTIONAL OUT BYTE **ppbCRL,
    OPTIONAL OUT DWORD *pdwCRLPublishFlags)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[4];
    CERTVIEWRESTRICTION *pcvr;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD Zero = 0;
    DWORD NameIdMin;
    DWORD NameIdMax;
    CERTDBRESULTROW aResult[1];
    CERTDBRESULTROW *pResult;
    DWORD celtFetched;
    BOOL fResultActive = FALSE;
    FILETIME ftCurrent;
    DWORD RowId = 0;
    BYTE *pbCRL = NULL;
    DWORD cbCRL;

    *pdwRowId = 0;
    *pcbCRL = 0;
    if (NULL != ppbCRL)
    {
	*ppbCRL = NULL;
    }

    if (NULL != pdwCRLPublishFlags)
    {
	*pdwCRLPublishFlags = 0;
    }
    GetSystemTimeAsFileTime(&ftCurrent);

    DBGPRINT((
	DBG_SS_CERTSRVI,
	"crlGetRowIdAndCRL(%ws, NameId=%x)\n",
	fDelta? L"Delta" : L"Base",
	pCAContext->NameId));

    // Set up restrictions as follows:

    pcvr = acvr;

    // RowId > 0

    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_ROWID;
    pcvr->SeekOperator = CVR_SEEK_GE;
    pcvr->SortOrder = CVR_SORT_DESCEND;		// Newest CRL first
    pcvr->pbValue = (BYTE *) &Zero;
    pcvr->cbValue = sizeof(Zero);
    pcvr++;

    if (fDelta)
    {
	// CRL Minimum Base > 0 (to eliminate base CRLs)

	pcvr->SeekOperator = CVR_SEEK_GT;
    }
    else
    {
	// CRL Minimum Base == 0 (to eliminate delta CRLs)

	pcvr->SeekOperator = CVR_SEEK_EQ;
    }
    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_MINBASE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &Zero;
    pcvr->cbValue = sizeof(Zero);
    pcvr++;

    // NameId >= MAKECANAMEID(iCert == 0, pCAContext->iKey)

    NameIdMin = MAKECANAMEID(0, pCAContext->iKey);
    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NAMEID;
    pcvr->SeekOperator = CVR_SEEK_GE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMin;
    pcvr->cbValue = sizeof(NameIdMin);
    pcvr++;

    // NameId <= MAKECANAMEID(iCert == _16BITMASK, pCAContext->iKey)

    NameIdMax = MAKECANAMEID(_16BITMASK, pCAContext->iKey);
    pcvr->ColumnIndex = DTI_CRLTABLE | DTL_NAMEID;
    pcvr->SeekOperator = CVR_SEEK_LE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMax;
    pcvr->cbValue = sizeof(NameIdMax);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    celtFetched = 0;
    cbCRL = 0;
    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			((NULL != ppbCRL) ? 
				(DWORD) ARRAYSIZE(g_aColRepublishCRLInfo) : 
				(DWORD) ARRAYSIZE(g_aColRepublishCRLInfo) - 1 ),	// explicitly describe expected return value
			g_aColRepublishCRLInfo,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    while (0 == RowId)
    {
	hr = pView->Next(NULL, ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    CSASSERT(0 == celtFetched);
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	_JumpIfErrorStr2(
		hr,
		error,
		"Next: no matching CRL",
		fDelta? L"delta" : L"base",
		fDelta? hr : S_OK);

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) == celtFetched);

	pResult = &aResult[0];

	CSASSERT(ARRAYSIZE(g_aColRepublishCRLInfo) == pResult->ccol);

	// verify CRLNumber data & schema

	CSASSERT(NULL != pResult->acol[ICOLRI_CRLNUMBER].pbValue);

	CSASSERT(
	    PROPTYPE_LONG ==
	    (PROPTYPE_MASK & pResult->acol[ICOLRI_CRLNUMBER].Type));

	CSASSERT(sizeof(DWORD) == pResult->acol[ICOLRI_CRLNUMBER].cbValue);

	// verify ThisUpdate data & schema

	CSASSERT(NULL != pResult->acol[ICOLRI_CRLTHISUPDATE].pbValue);

	CSASSERT(
	    PROPTYPE_DATE ==
	    (PROPTYPE_MASK & pResult->acol[ICOLRI_CRLTHISUPDATE].Type));

	CSASSERT(
	    sizeof(FILETIME) ==
	    pResult->acol[ICOLRI_CRLTHISUPDATE].cbValue);

	// verify NextUpdate data & schema

	if (NULL != pResult->acol[ICOLRI_CRLNEXTUPDATE].pbValue)
	{
	    CSASSERT(
		PROPTYPE_DATE ==
		(PROPTYPE_MASK & pResult->acol[ICOLRI_CRLNEXTUPDATE].Type));

	    CSASSERT(
		sizeof(FILETIME) ==
		pResult->acol[ICOLRI_CRLNEXTUPDATE].cbValue);
	}

	// verify RawCRL data & schema

	if (NULL != ppbCRL)
	{
	    CSASSERT(NULL != pResult->acol[ICOLRI_CRLRAWCRL].pbValue);
	    CSASSERT(PROPTYPE_BINARY == (PROPTYPE_MASK & pResult->acol[ICOLRI_CRLRAWCRL].Type));
	}

	// DBGPRINT query results

	DBGPRINT((DBG_SS_CERTSRVI, "Query:RowId: %u\n", pResult->rowid));
	DBGPRINT((
		DBG_SS_CERTSRVI,
		"Query:CRLNumber: %u\n",
		*(DWORD *) pResult->acol[ICOLRI_CRLNUMBER].pbValue));

	DBGPRINT((
		DBG_SS_CERTSRVI,
		"Query:NameId: 0x%x\n",
		*(DWORD *) pResult->acol[ICOLRI_CRLNAMEID].pbValue));

	DBGPRINTTIME(
		NULL,
		"Query:ThisUpdate",
		DPT_DATE,
		*(FILETIME *) pResult->acol[ICOLRI_CRLTHISUPDATE].pbValue);

	if (NULL != pResult->acol[ICOLRI_CRLNEXTUPDATE].pbValue)
	{
	    DBGPRINTTIME(
		    NULL,
		    "Query:NextUpdate",
		    DPT_DATE,
		    *(FILETIME *) pResult->acol[ICOLRI_CRLNEXTUPDATE].pbValue);
	}
	if (NULL != ppbCRL)
	{
	    DBGPRINT((
		    DBG_SS_CERTSRVI,
		    "Query:RawCRL: cb=%x\n",
		    pResult->acol[ICOLRI_CRLRAWCRL].cbValue));
	}
	if (NULL != pResult->acol[ICOLRI_CRLPUBLISHFLAGS].pbValue)
	{
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"Query:PublishFlags: f=%x\n",
		*(DWORD *) pResult->acol[ICOLRI_CRLPUBLISHFLAGS].pbValue));
	}
	if (0 < CompareFileTime(
		    (FILETIME *) pResult->acol[ICOLRI_CRLTHISUPDATE].pbValue,
		    &ftCurrent))
	{
	    _PrintError(E_INVALIDARG, "ThisUpdate in future");
	}
	if (NULL != pResult->acol[ICOLRI_CRLNEXTUPDATE].pbValue &&
	    0 > CompareFileTime(
		    (FILETIME *) pResult->acol[ICOLRI_CRLNEXTUPDATE].pbValue,
		    &ftCurrent))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "NextUpdate in past");
	}

	CSASSERT(0 != pResult->rowid);
	CSASSERT(NULL == pbCRL);
	
	RowId = pResult->rowid;
	if (NULL != ppbCRL)
	{
	    cbCRL = pResult->acol[ICOLRI_CRLRAWCRL].cbValue;
	    pbCRL = (BYTE *) LocalAlloc(LMEM_FIXED, cbCRL);
	    if (NULL == pbCRL)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(
		    pbCRL,
		    pResult->acol[ICOLRI_CRLRAWCRL].pbValue,
		    cbCRL);
	}
	if (NULL != pdwCRLPublishFlags &&
	    NULL != pResult->acol[ICOLRI_CRLPUBLISHFLAGS].pbValue)
	{
	    *pdwCRLPublishFlags =
		*(DWORD *) pResult->acol[ICOLRI_CRLPUBLISHFLAGS].pbValue;
	}
	DBGPRINT((DBG_SS_CERTSRVI, "Query:RowId: SAVED %u\n", pResult->rowid));

	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }
    *pdwRowId = RowId;
    if (NULL != ppbCRL)
    {
	*pcbCRL = cbCRL;
	*ppbCRL = pbCRL;
	pbCRL = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pbCRL)
    {
        LocalFree(pbCRL);
    }
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    DBGPRINT((
	DBG_SS_CERTSRVI,
	"crlGetRowIdAndCRL(%ws) -> RowId=%u, cbCRL=%x, hr=%x\n",
	fDelta? L"Delta" : L"Base",
	*pdwRowId,
	*pcbCRL,
	hr));
    return(hr);
}
#undef ICOLRI_CRLNUMBER
#undef ICOLRI_CRLNAMEID
#undef ICOLRI_CRLRAWCRL
#undef ICOLRI_CRLPUBLISHFLAGS
#undef ICOLRI_CRLTHISUPDATEDATE
#undef ICOLRI_CRLNEXTUPDATEDATE


HRESULT
crlRepublishCRLFromCAContext(
    IN FILETIME const *pftCurrent,
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDelta,
    IN CACTX *pCAContext,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    DWORD cbCRL;
    BYTE *pbCRL = NULL;
    DWORD RowId;

    *pfRetryNeeded = FALSE;
    *phrPublish = S_OK;

    hr = crlGetRowIdAndCRL(fDelta, pCAContext, &RowId, &cbCRL, &pbCRL, NULL);
    _JumpIfError(hr, error, "crlGetRowIdAndCRL");

    hr = crlPublishGeneratedCRL(
		    RowId,
		    pftCurrent,
		    pwszUserName,
		    fDelta,
		    pCAContext->iKey,
		    pbCRL,
		    cbCRL,
		    pCAContext,
		    pfRetryNeeded,
		    phrPublish);
    _JumpIfError(hr, error, "crlPublishGeneratedCRL");

error:
    if (NULL != pbCRL)
    {
        LocalFree(pbCRL);
    }
    return(hr);
}


HRESULT
crlRepublishExistingCRLs(
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDeltaOnly,
    IN BOOL fShadowDelta,
    IN FILETIME const *pftCurrent,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    HRESULT hrPublish;
    BOOL fRetryNeeded;
    DWORD i;

    *pfRetryNeeded = FALSE;
    *phrPublish = S_OK;

    // Walk global CA Context array from the back, and republish CRLs for
    // each unique CA key.  This causes the most current CRL to be published
    // first, and the most current CA Cert context to be used to publish a CRL
    // that covers multiple CA Certs due to key reuse.

    for (i = g_cCACerts; i > 0; i--)
    {
	CACTX *pCAContext = &g_aCAContext[i - 1];

	hr = PKCSVerifyCAState(pCAContext);
	_PrintIfError(hr, "PKCSVerifyCAState");
	if (CTXF_SKIPCRL & pCAContext->Flags)
	{
	    continue;
	}
	if (!fDeltaOnly)
	{
	    // Publish the most recent existing Base CRL

	    hr = CertSrvTestServerState();
	    _JumpIfError(hr, error, "CertSrvTestServerState");

	    hr = crlRepublishCRLFromCAContext(
				    pftCurrent,
				    pwszUserName,
				    FALSE,	// fDelta
				    pCAContext,
				    &fRetryNeeded,
				    &hrPublish);
	    _JumpIfError(hr, error, "crlRepublishCRLFromCAContext");

	    if (fRetryNeeded)
	    {
		*pfRetryNeeded = TRUE;
	    }
	    if (S_OK == *phrPublish)
	    {
		*phrPublish = hrPublish;
	    }
	}

	if (!g_fDeltaCRLPublishDisabled || fShadowDelta)
	{
	    // Publish the most recent existing Delta CRL

	    hr = CertSrvTestServerState();
	    _JumpIfError(hr, error, "CertSrvTestServerState");

	    hr = crlRepublishCRLFromCAContext(
				    pftCurrent,
				    pwszUserName,
				    TRUE,	// fDelta
				    pCAContext,
				    &fRetryNeeded,
				    &hrPublish);
	    _JumpIfError(hr, error, "crlRepublishCRLFromCAContext");

	    if (fRetryNeeded)
	    {
		*pfRetryNeeded = TRUE;
	    }
	    if (S_OK == *phrPublish)
	    {
		*phrPublish = hrPublish;
	    }
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
crlComputeCRLTimes(
    IN BOOL DBGPARMREFERENCED(fDelta),
    IN CSCRLPERIOD const *pccp,
    IN FILETIME const *pftCurrent,
    OUT FILETIME *pftThisUpdate,	 // ftCurrent - clock skew
    IN OUT FILETIME *pftNextUpdate,	 // ftCurrent + period + overlap + skew
    OUT FILETIME *pftNextPublish,	 // ftCurrent + CRL period
    OUT FILETIME *pftPropagationComplete) // ftCurrent + overlap
{
    HRESULT hr;
    LONGLONG lldelta;

    if (0 == pftNextUpdate->dwHighDateTime &&
	0 == pftNextUpdate->dwLowDateTime)
    {
	// Calculate expiration date for this CRL:
	// ftCurrent + CRL period

	DBGPRINTTIME(&fDelta, "*pftCurrent", DPT_DATE, *pftCurrent);
	*pftNextUpdate = *pftCurrent;
	DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "+ count=%d, enum=%d\n",
	    pccp->lCRLPeriodCount,
	    pccp->enumCRLPeriod));

	myMakeExprDateTime(
		    pftNextUpdate,
		    pccp->lCRLPeriodCount,
		    pccp->enumCRLPeriod);
	DBGPRINTTIME(&fDelta, "*pftNextUpdate", DPT_DATE, *pftNextUpdate);
    }
    if (0 > CompareFileTime(pftNextUpdate, pftCurrent))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "*pftNextUpdate in past");
    }

    *pftThisUpdate = *pftCurrent;
    *pftNextPublish = *pftNextUpdate;	// unmodified expiration time

    // Subtract clock skew from the current time for ftThisUpdate time.

    lldelta = g_dwClockSkewMinutes * CVT_MINUTES;
    myAddToFileTime(pftThisUpdate, -lldelta * CVT_BASE);

    // Add clock skew to ftNextUpdate,
    // Add propogation overlap to ftNextUpdate.

    lldelta += pccp->dwCRLOverlapMinutes * CVT_MINUTES;
    myAddToFileTime(pftNextUpdate, lldelta * CVT_BASE);

    *pftPropagationComplete = *pftCurrent;
    lldelta = pccp->dwCRLOverlapMinutes * CVT_MINUTES;
    myAddToFileTime(pftPropagationComplete, lldelta * CVT_BASE);

    DBGPRINTTIME(&fDelta, "*pftCurrent", DPT_DATE, *pftCurrent);
    DBGPRINTTIME(&fDelta, "*pftThisUpdate", DPT_DATE, *pftThisUpdate);
    DBGPRINTTIME(&fDelta, "*pftNextUpdate", DPT_DATE, *pftNextUpdate);
    DBGPRINTTIME(&fDelta, "*pftNextPublish", DPT_DATE, *pftNextPublish);
    DBGPRINTTIME(&fDelta, "*pftPropagationComplete", DPT_DATE, *pftPropagationComplete);

    hr = S_OK;

error:
    return(hr);
}


// crlGenerateAndPublishCRLs
//
// The algorithm for computing base and delta CRL overlap periods is:
// Base:
//    If Base registry overlap period specified:
//    {
//	  Start with Base registry setting rounded down to nearest minute
//	  multiple
//    }
//    else
//    {
//	  Start with 10% of Base CRL period (1/10 period) rounded down to
//	  nearest minute multiple
//	  Maximum 12 hours
//    }
//    Minimum 1.5 times clock skew (usually 1.5 * 10 minutes)
//    Maximum 100% of Base CRL period
//
// Delta:
//    If Delta registry overlap period specified:
//    {
//	  Start with Delta registry setting rounded down to nearest minute
//	  multiple
//    }
//    else
//    {
//	  Start with 100% of Delta CRL period (full period) rounded down to
//	  nearest minute multiple
//	  Maximum 12 hours
//    }
//    Minimum 1.5 times clock skew (usually 1.5 * 10 minutes)
//    Maximum 100% of Delta CRL period

HRESULT
crlGenerateAndPublishCRLs(
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDeltaOnly,			// else base (and delta, if enabled)
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN FILETIME const *pftCurrent,
    IN FILETIME ftNextUpdateBase,
    OUT DWORD *pdwRowIdBase,
    OUT FILETIME *pftQueryDeltaDelete,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    HRESULT hrPublish;
    HKEY hkeyBase = NULL;
    HKEY hkeyCA = NULL;
    BOOL fClamped = FALSE;
    DWORD CRLNumber;
    DWORD CRLNumberDelta;
    DWORD CRLNumberBaseMin = 0;
    DWORD i;
    BOOL fRetryNeeded;
    FILETIME ftNextUpdateDelta;
    FILETIME ftThisUpdate;
    FILETIME ftQueryDelta;
    FILETIME *pftQueryDelta = &ftQueryDelta;
    FILETIME ftLastPublishBase;
    FILETIME ftNextPublishBase;
    FILETIME ftNextUpdateBaseClamped = ftNextUpdateBase; // if clamped
    FILETIME ftNextPublishDelta;
    FILETIME ftPropagationCompleteBase;
    FILETIME ftPropagationCompleteDelta;
    CSCRLPERIOD ccpBase;
    CSCRLPERIOD ccpDelta;

    *pfRetryNeeded = FALSE;
    pftQueryDeltaDelete->dwHighDateTime = 0;
    pftQueryDeltaDelete->dwLowDateTime = 0;
    *phrPublish = S_OK;

    hr = crlGetNextCRLNumber(&CRLNumber);
    _JumpIfError(hr, error, "crlGetNextCRLNumber");

    hr = crlGetRegCRLPublishParams(
			    g_wszSanitizedName,
			    &ccpBase,
			    &ccpDelta);
    _JumpIfError(hr, error, "crlGetRegCRLPublishParams");

    // in manual publish case, 0 implies use default publish period

    CRLNumberDelta = CRLNumber;
    if (fDeltaOnly)
    {
	ftNextUpdateDelta = ftNextUpdateBase;
	ZeroMemory(&ftNextUpdateBase, sizeof(ftNextUpdateBase));
    }
    else
    {
	// son of RFC 2459: Trevor says don't do this (yet):
	// CRLNumberDelta++;
	ZeroMemory(&ftNextUpdateDelta, sizeof(ftNextUpdateDelta));
    }

    hr = crlComputeCRLTimes(
		FALSE,				// fDelta
		&ccpBase,			// IN
		pftCurrent,			// IN
		&ftThisUpdate,			// OUT includes skew
		&ftNextUpdateBase,		// INOUT includes overlap, skew
		&ftNextPublishBase,		// OUT unmodified expire time
		&ftPropagationCompleteBase);	// OUT includes overlap
    _JumpIfError(hr, error, "crlComputeCRLTimes");

    hr = crlComputeCRLTimes(
		TRUE,				// fDelta
		fShadowDelta? &ccpBase : &ccpDelta, // IN
		pftCurrent,			// IN
		&ftThisUpdate,			// OUT includes skew
		&ftNextUpdateDelta,		// INOUT includes overlap, skew
		&ftNextPublishDelta,		// OUT unmodified expire time
		&ftPropagationCompleteDelta);	// OUT includes overlap
    _JumpIfError(hr, error, "crlComputeCRLTimes");

    // Set ftLastPublishBase to *pftCurrent minus lifetime of this base CRL,
    // which is an educated guess for the ftThisPublish value for the last
    // CRL issued.

    ftLastPublishBase = *pftCurrent;
    myAddToFileTime(
	    &ftLastPublishBase,
	    -mySubtractFileTimes(&ftNextPublishBase, pftCurrent));

    // Clamp delta CRL to not end after base CRL.

    if (0 < CompareFileTime(&ftNextPublishDelta, &ftNextPublishBase))
    {
	ftNextPublishDelta = ftNextPublishBase;
	DBGPRINTTIME(NULL, "ftNextPublishDelta", DPT_DATE, ftNextPublishDelta);
    }
    if (0 < CompareFileTime(&ftNextUpdateDelta, &ftNextUpdateBase))
    {
	ftNextUpdateDelta = ftNextUpdateBase;
	DBGPRINTTIME(NULL, "ftNextUpdateDelta", DPT_DATE, ftNextUpdateDelta);
    }
    if (0 < CompareFileTime(&ftPropagationCompleteDelta, &ftPropagationCompleteBase))
    {
	ftPropagationCompleteDelta = ftPropagationCompleteBase;
	DBGPRINTTIME(NULL, "ftPropagationCompleteDelta", DPT_DATE, ftPropagationCompleteDelta);
    }
    if (!g_fDeltaCRLPublishDisabled || fShadowDelta)
    {
	hr = crlGetBaseCRLInfo(
			    pftCurrent,
			    FALSE,		// try newest propagated CRL
			    pdwRowIdBase,
			    &CRLNumberBaseMin,
			    &ftQueryDelta);
	_PrintIfError(hr, "crlGetBaseCRLInfo");
	if (S_OK != hr)
	{
	    hr = crlGetBaseCRLInfo(
				pftCurrent,
				TRUE,		// try oldest unexpired CRL
				pdwRowIdBase,
				&CRLNumberBaseMin,
				&ftQueryDelta);
	    _PrintIfError(hr, "crlGetBaseCRLInfo");
	    if (S_OK != hr)
	    {
		CRLNumberBaseMin = 1;
		if (!fDeltaOnly && 1 == CRLNumber)
		{
		    ftQueryDelta = *pftCurrent;		// empty CRL
		}
		else
		{
		    pftQueryDelta = NULL;		// full CRL
		}
	    }
	}
	if (S_OK == hr)
	{
	    // Delete old CRLs that expired at least one base CRL period prior
	    // to the "minimum" base crl ThisUpdate date found in the database.
	    
	    *pftQueryDeltaDelete = ftQueryDelta;
	    myAddToFileTime(
		    pftQueryDeltaDelete,
		    -mySubtractFileTimes(&ftNextUpdateBase, &ftThisUpdate));
	}
	if (fShadowDelta)
	{
	    CRLNumberBaseMin = CRLNumber;
	}
	CSASSERT(0 != CRLNumberBaseMin);
    }

    // Walk global CA Context array from the back, and generate a CRL for
    // each unique CA key.  This causes the most current CRL to be built
    // first, and the most current CA Cert to be used to build a CRL that
    // covers multiple CA Certs due to key reuse.

    for (i = g_cCACerts; i > 0; i--)
    {
	CACTX *pCAContext = &g_aCAContext[i - 1];

	hr = PKCSVerifyCAState(pCAContext);
	_PrintIfError(hr, "PKCSVerifyCAState");
	if (CTXF_SKIPCRL & pCAContext->Flags)
	{
	    continue;
	}
	if (!fDeltaOnly)
	{
	    // Publish a new Base CRL

	    // make a local copy in case clamped
	    FILETIME ftNextUpdateBaseTemp = ftNextUpdateBase;
	    fClamped = FALSE;

	    hr = CertSrvTestServerState();
	    _JumpIfError(hr, error, "CertSrvTestServerState");

	    hr = crlPublishCRLFromCAContext(
				    CRLNumber,
				    0,		// CRLNumberBaseMin
				    pwszUserName,
				    FALSE,	// fShadowDelta
				    pCAContext,
				    pftCurrent,
				    ftThisUpdate,
				    &ftNextUpdateBaseTemp,
				    &fClamped,
				    NULL,
				    pftCurrent,
				    &ftNextPublishBase,
				    &ftLastPublishBase,
				    &ftPropagationCompleteBase,
				    &fRetryNeeded,
				    &hrPublish);
	    _JumpIfError(hr, error, "crlPublishCRLFromCAContext");

	    if (fRetryNeeded)
	    {
		*pfRetryNeeded = TRUE;
	    }
	    if (S_OK == *phrPublish)
	    {
		*phrPublish = hrPublish;
	    }

	    {
		CertSrv::CAuditEvent event(SE_AUDITID_CERTSRV_AUTOPUBLISHCRL, g_dwAuditFilter);

		hr = event.AddData(true); // %1 base crl?
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(CRLNumber); // %2 CRL#
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(pCAContext->pwszKeyContainerName); // %3 key container
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(ftNextPublishBase); // %4 next publish
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData((LPCWSTR*)pCAContext->papwszCRLFiles); //%5 URLs
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.Report();
		_JumpIfError(hr, error, "CAuditEvent::Report");
	    }
	    if (i == g_cCACerts && fClamped)
	    {
		// new next publish clamps with CA expiration, only update
		// the current crl with new one for later reg save

		ftNextUpdateBaseClamped = ftNextUpdateBaseTemp;
	    }
	}

	if (!g_fDeltaCRLPublishDisabled || fShadowDelta)
	{
	    // Publish a new Delta CRL

	    FILETIME ftNextUpdateDeltaTemp = ftNextUpdateDelta;

	    hr = CertSrvTestServerState();
	    _JumpIfError(hr, error, "CertSrvTestServerState");

	    hr = crlPublishCRLFromCAContext(
					CRLNumberDelta,
					CRLNumberBaseMin,
					pwszUserName,
					fShadowDelta,
					pCAContext,
					pftCurrent,
					ftThisUpdate,
					&ftNextUpdateDeltaTemp,
					NULL,
					pftQueryDelta,
					pftCurrent,
					&ftNextPublishDelta,
					&ftLastPublishBase,	// Base!
					&ftPropagationCompleteDelta,
					&fRetryNeeded,
					&hrPublish);
	    _JumpIfError(hr, error, "crlPublishCRLFromCAContext");

	    if (fRetryNeeded)
	    {
		*pfRetryNeeded = TRUE;
	    }
	    if (S_OK == *phrPublish)
	    {
		*phrPublish = hrPublish;
	    }

	    {
		CertSrv::CAuditEvent event(SE_AUDITID_CERTSRV_AUTOPUBLISHCRL, g_dwAuditFilter);

		hr = event.AddData(false); // %1 base crl?
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(CRLNumberDelta); // %2 CRL#
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(pCAContext->pwszKeyContainerName); // %3 key container
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData(ftNextPublishDelta); // %4 next publish
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.AddData((LPCWSTR*)pCAContext->papwszDeltaCRLFiles); // %5 URLs
		_JumpIfError(hr, error, "CAuditEvent::AddData");

		hr = event.Report();
		_JumpIfError(hr, error, "CAuditEvent::Report");
	    }
	}
    }

    // update the registry and global variables

    if (!fDeltaOnly)
    {
	if (!fClamped)
	{
	    g_ftCRLNextPublish = ftNextPublishBase;
	}
	else
	{
	    g_ftCRLNextPublish = ftNextUpdateBaseClamped;
	}
	hr = crlSetRegCRLNextPublish(
			FALSE,
			g_wszSanitizedName,
			wszREGCRLNEXTPUBLISH,
			&g_ftCRLNextPublish);
	_JumpIfError(hr, error, "crlSetRegCRLNextPublish");
    }

    g_ftDeltaCRLNextPublish = ftNextPublishDelta;

    if (!g_fDeltaCRLPublishDisabled)
    {
	hr = crlSetRegCRLNextPublish(
			TRUE,
			g_wszSanitizedName,
			wszREGCRLDELTANEXTPUBLISH,
			&g_ftDeltaCRLNextPublish);
	_JumpIfError(hr, error, "crlSetRegCRLNextPublish");
    }
    hr = S_OK;

error:
    if (NULL != hkeyCA)
    {
	RegCloseKey(hkeyCA);
    }
    if (NULL != hkeyBase)
    {
	RegCloseKey(hkeyBase);
    }
    return(hr);
}


///////////////////////////////////////////////////
// CRLPublishCRLs is called to publish a set of CRLs.
//
// if fRebuildCRL is TRUE, the CRLs are rebuilt from the database.
// otherwise, the exit module is re-notified of the CRLs.
// For consistency, if the exit module returns ERROR_RETRY, this
// function will write the retry bit into the registry which will
// trigger the Wakeup function, which then recalculates when the
// next publish should happen.
//
// pfRetryNeeded is an OUT param that notifies the autopublish routine if
// a retry is immediately necessary following a rebuilt CRL. In this
// case the registry would not be changed and the registry trigger
// would not fire.
//
// (Current_time - skew) is used as ThisUpdate
// (ftNextUpdate+skew+Overlap) is used as NextUpdate
// (ftNextUpdate) is next wakeup/publish time
//
// There are registry values to specify the overlap.
// HLKLM\SYSTEM\CurrentControlSet\Services\CertSvc\Configuration\<CA Name>:
// CRLOverlapPeriod         REG_SZ = Hours (or Minutes)
// CRLOverlapUnits          REG_DWORD = 0 (0) -- DISABLED
//
// If the above registry values are set and valid, the registry overlap period
// is calculated as:
//   max(Registry CRL Overlap Period, 1.5 * Registry clock skew minutes)
//
// If they are not present or invalid, the overlap period is calculated as:
//   max(
//	min(Registry CRL Period / 10, 12 hours),
//	1.5 * Registry clock skew minutes) +
//   Registry clock skew minutes
//
// ThisUpdate is calculated as:
// max(Current Time - Registry clock skew minutes, CA cert NotBefore date)
//
// NextUpdate is calculated as:
//   min(
//	Current Time +
//	    Registry CRL period +
//	    calculated overlap period +
//	    Registry clock skew minutes,
//	CA cert NotAfter date)
//
// The Next CRL publication time is calculated as:
//   Current Time + Registry CRL period
//
// This function sets g_hCRLManualPublishEvent. Automatic publishing
// is personally responsible for clearing this event if it calls us.

HRESULT
CRLPublishCRLs(
    IN BOOL fRebuildCRL,		// else republish only
    IN BOOL fForceRepublish,		// else check registry retry count
    OPTIONAL IN WCHAR const *pwszUserName, // else timer thread
    IN BOOL fDeltaOnly,			// else base (and delta, if enabled)
    IN BOOL fShadowDelta,		// empty delta CRL with new MinBaseCRL
    IN FILETIME ftNextUpdateBase,
    OUT BOOL *pfRetryNeeded,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;
    BOOL fRetryNeeded = FALSE;
    BOOL fExitNotify = FALSE;
    BOOL fCoInitialized = FALSE;
    DWORD RowIdBase = 0;
    FILETIME ftQueryDeltaDelete = { 0, 0 };
    DWORD dwPreviousAttempts;
    DWORD dwCurrentAttempts;
    static BOOL s_fSkipRetry = FALSE;

    *pfRetryNeeded = FALSE;
    *phrPublish = S_OK;

    if (fDeltaOnly && g_fDeltaCRLPublishDisabled && !fShadowDelta)
    {
	hr = HRESULT_FROM_WIN32(ERROR_RESOURCE_DISABLED);
	_JumpError(hr, error, "g_fDeltaCRLPublishDisabled");
    }

    // retrieve initial retry value (optional registry value)

    hr = myGetCertRegDWValue(
			g_wszSanitizedName,
			NULL,
			NULL,
			wszREGCRLATTEMPTREPUBLISH,
			&dwPreviousAttempts);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
	dwPreviousAttempts = 0;	// assume no previous failed publish attempts
	hr = S_OK;
    }
    _JumpIfErrorStr(
		hr,
		error,
		"myGetCertRegDWValue",
		wszREGCRLATTEMPTREPUBLISH);

    dwCurrentAttempts = dwPreviousAttempts;
    DBGPRINT((
	DBG_SS_CERTSRV,
	"CRLPublishCRLs(fRebuildCRL=%u, fForceRepublish=%u, User=%ws)\n",
	fRebuildCRL,
	fForceRepublish,
	pwszUserName));
    DBGPRINT((
	DBG_SS_CERTSRV,
	"CRLPublishCRLs(fDeltaOnly=%u, fShadowDelta=%u, dwPreviousAttempts=%u)\n",
	fDeltaOnly,
	fShadowDelta,
	dwPreviousAttempts));

    if (0 != dwPreviousAttempts && NULL == pwszUserName && s_fSkipRetry)
    {
	fRetryNeeded = TRUE;
    }
    else
    {
	FILETIME ftCurrent;

	GetSystemTimeAsFileTime(&ftCurrent);

	// generate CRLs if necessary

	if (fRebuildCRL)
	{
	    hr = crlGenerateAndPublishCRLs(
				    pwszUserName,
				    fDeltaOnly,
				    fShadowDelta,
				    &ftCurrent,
				    ftNextUpdateBase,
				    &RowIdBase,
				    &ftQueryDeltaDelete,
				    &fRetryNeeded,
				    phrPublish);
	    _JumpIfError(hr, error, "crlGenerateAndPublishCRLs");

	    fExitNotify = TRUE;
	    dwCurrentAttempts = 1;
	}
	else
	if (fForceRepublish ||
	    (0 < dwPreviousAttempts &&
	     CERTSRV_CRLPUB_RETRY_COUNT_DEFAULT > dwPreviousAttempts))
	{
	    // If the timer thread is auto-republishing due to previously
	    // failed publish attempts, retry base CRLs, too, because we
	    // can't tell if the retry is due to a base or delta CRL error.

	    if (NULL == pwszUserName)
	    {
		fDeltaOnly = FALSE;
	    }

	    hr = crlRepublishExistingCRLs(
			    pwszUserName,
			    fDeltaOnly,
			    fShadowDelta,
			    &ftCurrent,
			    &fRetryNeeded,
			    phrPublish);
	    _JumpIfError(hr, error, "crlRepublishCRLs");

	    fExitNotify = TRUE;
	    dwCurrentAttempts++;
	}

	if (fExitNotify && g_fEnableExit)
	{
	    hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
	    if (S_OK != hr && S_FALSE != hr)
	    {
		_JumpError(hr, error, "CoInitializeEx");
	    }
	    fCoInitialized = TRUE;

	    // make sure exit module(s) get notified for publish and republish
	    // in case of earlier exit module publish failure.

	    hr = ExitNotify(EXITEVENT_CRLISSUED, 0, NULL, MAXDWORD);
	    _PrintIfError(hr, "ExitNotify");
	    if ((HRESULT) ERROR_RETRY == hr ||
		HRESULT_FROM_WIN32(ERROR_RETRY) == hr)
	    {
		fRetryNeeded = TRUE;
		if (S_OK == *phrPublish)
		{
		    *phrPublish = HRESULT_FROM_WIN32(ERROR_RETRY);
		}
	    }
	    CONSOLEPRINT0((DBG_SS_CERTSRV, "Issued CRL Exit Event\n"));
	}

	// If new or existing CRLs successfully published, reset count to 0

	if (fExitNotify && !fRetryNeeded)
	{
	    dwCurrentAttempts = 0;
	    if (CERTLOG_VERBOSE <= g_dwLogLevel)
	    {
		WCHAR *pwszHostName = NULL;
		DWORD LogMsg;

		if (NULL != g_pld)
		{
		    myLdapGetDSHostName(g_pld, &pwszHostName);
		}
		LogMsg = fDeltaOnly?
			    MSG_DELTA_CRLS_PUBLISHED :
			    (g_fDeltaCRLPublishDisabled?
				MSG_BASE_CRLS_PUBLISHED :
				MSG_BASE_AND_DELTA_CRLS_PUBLISHED);
		if (NULL != pwszHostName)
		{
		    LogMsg = fDeltaOnly?
			MSG_DELTA_CRLS_PUBLISHED_HOST_NAME :
			(g_fDeltaCRLPublishDisabled?
			    MSG_BASE_CRLS_PUBLISHED_HOST_NAME :
			    MSG_BASE_AND_DELTA_CRLS_PUBLISHED_HOST_NAME);
		}
		hr = LogEvent(
			EVENTLOG_INFORMATION_TYPE,
			LogMsg,
			(WORD) (NULL == pwszHostName? 0 : 1),	// cStrings
			(WCHAR const **) &pwszHostName);	// apwszStrings
		_PrintIfError(hr, "LogEvent");
	    }
	}

	// If the retry count has changed, update the registry.

	if (dwCurrentAttempts != dwPreviousAttempts)
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"CRLPublishCRLs(Attempts: %u --> %u)\n",
		dwPreviousAttempts,
		dwCurrentAttempts));

	    hr = mySetCertRegDWValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    wszREGCRLATTEMPTREPUBLISH,
			    dwCurrentAttempts);
	    _JumpIfErrorStr(
			hr,
			error,
			"mySetCertRegDWValue",
			wszREGCRLATTEMPTREPUBLISH);

	    // If we tried unsuccessfully too many times to publish these CRLs,
	    // and we're about to give up until a new set is generated, log an
	    // event saying so.

	    if (fExitNotify &&
		CERTSRV_CRLPUB_RETRY_COUNT_DEFAULT == dwCurrentAttempts &&
		CERTLOG_ERROR <= g_dwLogLevel)
	    {
		WCHAR wszAttempts[cwcDWORDSPRINTF];
		WCHAR const *pwsz = wszAttempts;

		wsprintf(wszAttempts, L"%u", dwCurrentAttempts);
		
		hr = LogEvent(
			EVENTLOG_ERROR_TYPE,
			MSG_E_CRL_PUBLICATION_TOO_MANY_RETRIES,
			1,		// cStrings
			&pwsz);	// apwszStrings
		_PrintIfError(hr, "LogEvent");
	    }
	}
	if (fRebuildCRL)
	{
	    // Delete old CRLs only if new CRLs built & published successfully.

	    if (!fRetryNeeded)
	    {
		hr = CertSrvTestServerState();
		_JumpIfError(hr, error, "CertSrvTestServerState");

		hr = crlDeleteExpiredCRLs(
				    &ftCurrent,
				    &ftQueryDeltaDelete,
				    RowIdBase);
		_PrintIfError(hr, "crlDeleteExpiredCRLs");
	    }

	    // Clear force CRL flag only when we build new CRLs.

	    hr = SetSetupStatus(g_wszSanitizedName, SETUP_FORCECRL_FLAG, FALSE);
	    _PrintIfError(hr, "SetSetupStatus");
	}
    }
    s_fSkipRetry = NULL != pwszUserName;

    if (fRebuildCRL || fRetryNeeded)
    {
	// If we are doing ANYTHING that will affect automatic wakeup, trigger
	// our publish event.
	// NOTE: do this last or else state might not be updated

	SetEvent(g_hCRLManualPublishEvent);
    }
    hr = S_OK;

error:
    *pfRetryNeeded = fRetryNeeded;
    if (fCoInitialized)
    {
        CoUninitialize();
    }
    return(hr);
}


HRESULT
CRLGetCRL(
    IN DWORD iCertArg,
    IN BOOL fDelta,
    OPTIONAL OUT CRL_CONTEXT const **ppCRL,
    OPTIONAL OUT DWORD *pdwCRLPublishFlags)
{
    HRESULT hr;
    DWORD State;
    DWORD iCert;
    DWORD iCRL;
    DWORD dwRowId;
    BYTE *pbCRL = NULL;
    DWORD cbCRL;

    if (NULL != ppCRL)
    {
	*ppCRL = NULL;
    }

    hr = PKCSMapCRLIndex(iCertArg, &iCert, &iCRL, &State);
    _JumpIfError(hr, error, "PKCSMapCRLIndex");

    if (MAXDWORD != iCertArg &&
	CA_DISP_VALID != State &&
	CA_DISP_INVALID != State)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "No CRL for this Cert");
    }

    // Now we know iCert is a valid Cert Index:

    hr = crlGetRowIdAndCRL(
		    fDelta,
		    &g_aCAContext[iCert],
		    &dwRowId,
		    &cbCRL,
		    &pbCRL,
		    pdwCRLPublishFlags);
    if (S_OK != hr)
    {
	_PrintError2(
		hr,
		"crlGetRowIdAndCRL",
		fDelta? HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) : S_OK);
	if (MAXDWORD != iCertArg && CA_DISP_INVALID == State)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "No CRL for this expired Cert");
	}
	_JumpError2(
		hr,
		error,
		"crlGetRowIdAndCRL",
		fDelta? HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) : S_OK);
    }

    if (NULL != ppCRL)
    {
	*ppCRL = CertCreateCRLContext(X509_ASN_ENCODING, pbCRL, cbCRL);
        if (NULL == *ppCRL)
        {
	    hr = myHLastError();
            _JumpError(hr, error, "CertCreateCRLContext");
        }
    }
    hr = S_OK;

error:
    if (NULL != pbCRL)
    {
        LocalFree(pbCRL);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\com.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       com.h
//
//--------------------------------------------------------------------------


class MarshalInterface
{
public:
    MarshalInterface(VOID) { m_pwszProgID = NULL; m_szConfig = NULL;}
    ~MarshalInterface(VOID) {}

    HRESULT Initialize(
	    IN WCHAR const *pwszProgID,
	    IN CLSID const *pclsid,
	    IN DWORD cver,
	    IN IID const * const *ppiid,	// cver elements
	    IN DWORD const *pcDispatch,		// cver elements
	    IN DISPATCHTABLE *adt);

    HRESULT Setup(
	    OUT DISPATCHINTERFACE **ppDispatchInterface);

    VOID TearDown(VOID);

    HRESULT Marshal(
	IN DISPATCHINTERFACE *pDispatchInterface);

    HRESULT Remarshal(
	OUT DISPATCHINTERFACE *pDispatchInterface);

    VOID Unmarshal(
	IN OUT DISPATCHINTERFACE *pDispatchInterface);

    HRESULT SetConfig(
        IN LPCWSTR pwszSanitizedName);

    LPCWSTR GetConfig() {return m_szConfig;}
    LPCWSTR GetProgID() {return m_pwszProgID;}

private:
    BOOL               m_fInitialized;
    LPWSTR             m_pwszProgID; 
    CLSID const       *m_pclsid;
    DWORD              m_cver;
    IID const * const *m_ppiid;		// cver elements
    DWORD const       *m_pcDispatch;	// cver elements
    DISPATCHTABLE     *m_adt;
    DWORD	       m_iiid;

    LPCWSTR            m_szConfig;

    BOOL               m_fIDispatch;
    DISPATCHINTERFACE  m_DispatchInterface;

    // GIT cookie
    DWORD              m_dwIFCookie;
};

extern MarshalInterface g_miPolicy;

HRESULT
ExitGetActiveModule(
    IN LONG                Context,
    OUT MarshalInterface **ppmi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\cscom.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cscom.h
//
// Contents:    Cert Server Policy & Exit module callouts
//
//---------------------------------------------------------------------------

#include "certdb.h"


HRESULT ComInit(VOID);

// Releases all Policy/Exit modules
VOID ComShutDown(VOID);

HRESULT
PolicyInit(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSanitizedName);

HRESULT
PolicyVerifyRequest(
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN LONG Flags,
    IN BOOL fNewRequest,
    OPTIONAL IN CERTSRV_RESULT_CONTEXT const *pResult,
    IN DWORD dwComContextIndex,
    OUT LPWSTR *pwszDispositionMessage, // LocalAlloced.
    OUT DWORD *pVerifyStatus); // VR_PENDING || VR_INSTANT_OK || VR_INSTANT_BAD

extern BOOL g_fEnablePolicy;


HRESULT
ExitInit(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSanitizedName);

HRESULT
ExitNotify(
    IN LONG Event,
    IN LONG RequestId,
    OPTIONAL IN CERTSRV_RESULT_CONTEXT const *pResult,
    IN DWORD dwComContextIndex); //MAXDWORD means no context

BSTR
ExitGetDescription(
    IN DWORD iExitMod);

extern BOOL g_fEnableExit;


HRESULT
ComVerifyRequestContext(
    IN BOOL fAllowZero,
    IN DWORD Flags,
    IN LONG Context,
    OUT DWORD *pRequestId);

HRESULT
ComGetClientInfo(
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OUT CERTSRV_COM_CONTEXT **ppComContext);

BOOL
ComParseErrorPrefix(
    OPTIONAL IN WCHAR const *pwszIn,
    OUT HRESULT *phrPrefix,
    OUT WCHAR const **ppwszOut);

HRESULT
RegisterComContext(
    IN CERTSRV_COM_CONTEXT *pComContext,
    IN OUT DWORD *pdwIndex);

VOID
UnregisterComContext(
    IN CERTSRV_COM_CONTEXT *pComContext,
    IN DWORD  dwIndex);

VOID
ReleaseComContext(
    IN CERTSRV_COM_CONTEXT *pComContext);

CERTSRV_COM_CONTEXT*
GetComContextFromIndex(
    IN DWORD  dwIndex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\comtest.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        comtest.cpp
//
// Contents:    Cert Server COM interface test driver
//
// History:     20-Jan-97       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>

#include "csdisp.h"
#include "csprop.h"


#if DBG_COMTEST
BOOL
comTestCIPolicy(
    IN LONG Context,
    IN DWORD Flags)
{
    HRESULT hr;
    DISPATCHINTERFACE diCIPolicy;
    BSTR bstrReq = NULL;
    BSTR bstrCert = NULL;
    BOOL fMustRelease = FALSE;
    DATE Date;
    
    wprintf(L"\n");

    hr = CIPolicy_Init(Flags, &diCIPolicy);
    _JumpIfError(hr, error, "CIPolicy_Init");
    fMustRelease = TRUE;

    hr = CIPolicy_SetContext(&diCIPolicy, Context);
    _JumpIfError(hr, error, "CIPolicy_SetContext");

    hr = CIPolicy_GetRequestProperty(
			    &diCIPolicy,
			    g_wszPropSubjectCommonName,
			    PROPTYPE_STRING,
			    &bstrReq);
    _JumpIfError(hr, error, "CIPolicy_GetRequestProperty");

    wprintf(
	L"%d:CIPolicy_GetRequestProperty(%u, %ws) == `%ws'\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	bstrReq);


    hr = CIPolicy_GetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropSubjectCommonName,
			    PROPTYPE_STRING,
			    &bstrCert);
    _JumpIfError(hr, error, "CIPolicy_GetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_GetCertificateProperty(%u, %ws) == `%ws'\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	bstrCert);

    hr = CIPolicy_SetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropSubjectLocality,
			    PROPTYPE_STRING,
			    L"coreSetPropPolicy_Locality");
    _JumpIfError(hr, error, "CIPolicy_SetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_SetCertificateProperty(%u, %ws, %ws) == %x\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	L"CIPolicy_SetCertificateProperty_Locality",
	hr);

    hr = CIPolicy_GetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropCertificateNotBeforeDate,
			    PROPTYPE_DATE,
			    (BSTR *) &Date);
    _JumpIfError(hr, error, "CIPolicy_GetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_GetCertificateProperty(%u, %ws) == %x (%f)\n",
	Flags,
	Context,
	g_wszPropCertificateNotBeforeDate,
	hr,
	Date);

    hr = CIPolicy_SetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropCertificateNotBeforeDate,
			    PROPTYPE_DATE,
			    (BSTR) &Date);
    _JumpIfError(hr, error, "CIPolicy_SetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_SetCertificateProperty(%u, %ws) == %x (%f)\n",
	Flags,
	Context,
	g_wszPropCertificateNotBeforeDate,
	hr,
	Date);

    Date += 1.5;	// Set validity period to 1.5 days.
    hr = CIPolicy_SetCertificateProperty(
			    &diCIPolicy,
			    g_wszPropCertificateNotAfterDate,
			    PROPTYPE_DATE,
			    (BSTR) &Date);
    _JumpIfError(hr, error, "CIPolicy_SetCertificateProperty");

    wprintf(
	L"%d:CIPolicy_SetCertificateProperty(%u, %ws) == %x (%f)\n",
	Flags,
	Context,
	g_wszPropCertificateNotAfterDate,
	hr,
	Date);

error:
    if (NULL != bstrReq)
    {
	SysFreeString(bstrReq);
    }
    if (NULL != bstrCert)
    {
	SysFreeString(bstrCert);
    }
    if (fMustRelease)
    {
	CIPolicy_Release(&diCIPolicy);
    }
    return(S_OK == hr);
}


BOOL
comTestCIExit(
    IN LONG Context,
    IN DWORD Flags)
{
    HRESULT hr;
    DISPATCHINTERFACE diCIExit;
    BSTR bstrReq = NULL;
    BSTR bstrCert = NULL;
    BOOL fMustRelease = FALSE;
    
    wprintf(L"\n");

    hr = CIExit_Init(Flags, &diCIExit);
    _JumpIfError(hr, error, "CIExit_Init");
    fMustRelease = TRUE;

    hr = CIExit_SetContext(&diCIExit, Context);
    _JumpIfError(hr, error, "CIExit_SetContext");

    hr = CIExit_GetRequestProperty(
			    &diCIExit,
			    g_wszPropSubjectCommonName,
			    PROPTYPE_STRING,
			    &bstrReq);
    _JumpIfError(hr, error, "CIExit_GetRequestProperty");

    wprintf(
	L"%d:CIExit_GetRequestProperty(%u, %ws) == `%ws'\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	bstrReq);


    hr = CIExit_GetCertificateProperty(
			    &diCIExit,
			    g_wszPropSubjectCommonName,
			    PROPTYPE_STRING,
			    &bstrCert);
    _JumpIfError(hr, error, "CIExit_GetCertificateProperty");

    wprintf(
	L"%d:CIExit_GetCertificateProperty(%u, %ws) == `%ws'\n",
	Flags,
	Context,
	g_wszPropSubjectCommonName,
	bstrCert);

error:
    if (NULL != bstrReq)
    {
	SysFreeString(bstrReq);
    }
    if (NULL != bstrCert)
    {
	SysFreeString(bstrCert);
    }
    if (fMustRelease)
    {
	CIExit_Release(&diCIExit);
    }
    return(S_OK == hr);
}


BOOL
ComTest(
    IN LONG Context)
{
    return(
	comTestCIPolicy(Context, DISPSETUP_COMFIRST) &&
	comTestCIPolicy(Context, DISPSETUP_COM) &&
	comTestCIPolicy(Context, DISPSETUP_IDISPATCH) &&
	comTestCIExit(Context, DISPSETUP_COMFIRST) &&
	comTestCIExit(Context, DISPSETUP_COM) &&
	comTestCIExit(Context, DISPSETUP_IDISPATCH));
}
#endif // DBG_COMTEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\core.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        core.cpp
//
// Contents:    Cert Server Core implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lm.h>
#include <esent.h>

#include "cscom.h"
#include "csprop.h"
#include "cspolicy.h"
#include "ciinit.h"
#include "csdisp.h"
#include "csldap.h"
#include "cainfop.h"
#include "elog.h"
#include "certlog.h"
#include "resource.h"

#define __dwFILE__	__dwFILE_CERTSRV_CORE_CPP__


#if DBG_COMTEST
#define DBG_COMTEST_CONST
#else
#define DBG_COMTEST_CONST	const
#endif

#define DBSESSIONCOUNTMIN	4
#define DBSESSIONCOUNTMAX	1024


DBG_COMTEST_CONST BOOL fComTest = FALSE;

SERVERCALLBACKS ServerCallBacks = {
    PropCIGetProperty,
    PropCISetProperty,
    PropCIGetExtension,
    PropCISetExtension,
    PropCIEnumSetup,
    PropCIEnumNext,
    PropCIEnumClose,
};


HINSTANCE g_hInstance;
WCHAR g_wszSharedFolder[MAX_PATH];
WCHAR g_wszSanitizedName[MAX_PATH];
WCHAR *g_pwszSanitizedDSName;
WCHAR g_wszCommonName[MAX_PATH];
WCHAR g_wszPolicyDCName[MAX_PATH];
DWORD g_cwcPolicyDCName = ARRAYSIZE(g_wszPolicyDCName);
WCHAR g_wszParentConfig[MAX_PATH];

WCHAR *g_pwszzAlternatePublishDomains = NULL;
WCHAR *g_pwszzSubjectTemplate = NULL;
WCHAR *g_pwszServerName = NULL;

DWORD g_dwClockSkewMinutes = CCLOCKSKEWMINUTESDEFAULT;
DWORD g_dwViewAgeMinutes = CVIEWAGEMINUTESDEFAULT;
DWORD g_dwViewIdleMinutes = CVIEWIDLEMINUTESDEFAULT;
DWORD g_dwLogLevel = CERTLOG_WARNING;
DWORD g_dwSessionCount = DBSESSIONCOUNTDEFAULT;
DWORD g_dwHighSerial = 0;
BYTE *g_pbHighSerial = NULL;
DWORD g_cbHighSerial;
DWORD g_cbMaxIncomingMessageSize = MAXINCOMINGMESSAGESIZEDEFAULT;
DWORD g_cbMaxIncomingAllocSize = MAXINCOMINGALLOCSIZEDEFAULT;

WCHAR const g_wszRegValidityPeriodString[] = wszREGVALIDITYPERIODSTRING;
WCHAR const g_wszRegValidityPeriodCount[] = wszREGVALIDITYPERIODCOUNT;

WCHAR const g_wszRegCAXchgValidityPeriodString[] = wszREGCAXCHGVALIDITYPERIODSTRING;
WCHAR const g_wszRegCAXchgValidityPeriodCount[] = wszREGCAXCHGVALIDITYPERIODCOUNT;
WCHAR const g_wszRegCAXchgOverlapPeriodString[] = wszREGCAXCHGOVERLAPPERIODSTRING;
WCHAR const g_wszRegCAXchgOverlapPeriodCount[] = wszREGCAXCHGOVERLAPPERIODCOUNT;
WCHAR const g_wszRegCAXchgCertHash[] = wszREGCAXCHGCERTHASH;

WCHAR const g_wszRegSubjectTemplate[] = wszREGSUBJECTTEMPLATE;
WCHAR const g_wszRegKeyConfigPath[] = wszREGKEYCONFIGPATH;
WCHAR const g_wszRegDirectory[] = wszREGDIRECTORY;
WCHAR const g_wszRegActive[] = wszREGACTIVE;
WCHAR const g_wszRegEnabled[] = wszREGENABLED;
WCHAR const g_wszRegPolicyFlags[] = wszREGPOLICYFLAGS;
WCHAR const g_wszCertSrvServiceName[] = wszSERVICE_NAME;
WCHAR const g_wszRegCertEnrollCompatible[] = wszREGCERTENROLLCOMPATIBLE;
WCHAR const g_wszRegEnforceX500NameLengths[] = wszREGENFORCEX500NAMELENGTHS;
WCHAR const g_wszRegForceTeletex[] = wszREGFORCETELETEX;
WCHAR const g_wszRegClockSkewMinutes[] = wszREGCLOCKSKEWMINUTES;
WCHAR const g_wszRegViewAgeMinutes[] = wszREGVIEWAGEMINUTES;
WCHAR const g_wszRegViewIdleMinutes[] = wszREGVIEWIDLEMINUTES;
WCHAR const g_wszRegLogLevel[] = wszREGLOGLEVEL;
WCHAR const g_wszRegHighSerial[] = wszREGHIGHSERIAL;
WCHAR const g_wszRegMaxIncomingMessageSize[] = wszREGMAXINCOMINGMESSAGESIZE;
WCHAR const g_wszRegMaxIncomingAllocSize[] = wszREGMAXINCOMINGALLOCSIZE;

BOOL g_fCertEnrollCompatible = TRUE;
BOOL g_fEnforceRDNNameLengths = TRUE;
DWORD g_KRAFlags = 0;
DWORD g_CRLEditFlags = EDITF_ENABLEAKIKEYID |
			EDITF_ENABLEAKIISSUERNAME |
			EDITF_ENABLEAKIISSUERSERIAL |
			EDITF_ENABLEAKICRITICAL;
ENUM_FORCETELETEX g_fForceTeletex = ENUM_TELETEX_AUTO;
ENUM_CATYPES g_CAType = ENUM_UNKNOWN_CA;

BOOL g_fUseDS = FALSE;
BOOL g_fServerUpgraded = FALSE;
DWORD g_InterfaceFlags = IF_DEFAULT;
HRESULT g_hrJetVersionStoreOutOfMemory;


//+--------------------------------------------------------------------------
// Name properties:

WCHAR const g_wszPropDistinguishedName[] = wszPROPDISTINGUISHEDNAME;
WCHAR const g_wszPropRawName[] = wszPROPRAWNAME;

WCHAR const g_wszPropCountry[] = wszPROPCOUNTRY;
WCHAR const g_wszPropOrganization[] = wszPROPORGANIZATION;
WCHAR const g_wszPropOrgUnit[] = wszPROPORGUNIT;
WCHAR const g_wszPropCommonName[] = wszPROPCOMMONNAME;
WCHAR const g_wszPropLocality[] = wszPROPLOCALITY;
WCHAR const g_wszPropState[] = wszPROPSTATE;
WCHAR const g_wszPropTitle[] = wszPROPTITLE;
WCHAR const g_wszPropGivenName[] = wszPROPGIVENNAME;
WCHAR const g_wszPropInitials[] = wszPROPINITIALS;
WCHAR const g_wszPropSurName[] = wszPROPSURNAME;
WCHAR const g_wszPropDomainComponent[] = wszPROPDOMAINCOMPONENT;
WCHAR const g_wszPropEMail[] = wszPROPEMAIL;
WCHAR const g_wszPropStreetAddress[] = wszPROPSTREETADDRESS;
WCHAR const g_wszPropUnstructuredAddress[] = wszPROPUNSTRUCTUREDADDRESS;
WCHAR const g_wszPropUnstructuredName[] = wszPROPUNSTRUCTUREDNAME;
WCHAR const g_wszPropDeviceSerialNumber[] = wszPROPDEVICESERIALNUMBER;


//+--------------------------------------------------------------------------
// Subject Name properties:

WCHAR const g_wszPropSubjectDot[] = wszPROPSUBJECTDOT;
WCHAR const g_wszPropSubjectDistinguishedName[] = wszPROPSUBJECTDISTINGUISHEDNAME;
WCHAR const g_wszPropSubjectRawName[] = wszPROPSUBJECTRAWNAME;

WCHAR const g_wszPropSubjectCountry[] = wszPROPSUBJECTCOUNTRY;
WCHAR const g_wszPropSubjectOrganization[] = wszPROPSUBJECTORGANIZATION;
WCHAR const g_wszPropSubjectOrgUnit[] = wszPROPSUBJECTORGUNIT;
WCHAR const g_wszPropSubjectCommonName[] = wszPROPSUBJECTCOMMONNAME;
WCHAR const g_wszPropSubjectLocality[] = wszPROPSUBJECTLOCALITY;
WCHAR const g_wszPropSubjectState[] = wszPROPSUBJECTSTATE;
WCHAR const g_wszPropSubjectTitle[] = wszPROPSUBJECTTITLE;
WCHAR const g_wszPropSubjectGivenName[] = wszPROPSUBJECTGIVENNAME;
WCHAR const g_wszPropSubjectInitials[] = wszPROPSUBJECTINITIALS;
WCHAR const g_wszPropSubjectSurName[] = wszPROPSUBJECTSURNAME;
WCHAR const g_wszPropSubjectDomainComponent[] = wszPROPSUBJECTDOMAINCOMPONENT;
WCHAR const g_wszPropSubjectEMail[] = wszPROPSUBJECTEMAIL;
WCHAR const g_wszPropSubjectStreetAddress[] = wszPROPSUBJECTSTREETADDRESS;
WCHAR const g_wszPropSubjectUnstructuredAddress[] = wszPROPSUBJECTUNSTRUCTUREDADDRESS;
WCHAR const g_wszPropSubjectUnstructuredName[] = wszPROPSUBJECTUNSTRUCTUREDNAME;
WCHAR const g_wszPropSubjectDeviceSerialNumber[] = wszPROPSUBJECTDEVICESERIALNUMBER;


//+--------------------------------------------------------------------------
// Issuer Name properties:

WCHAR const g_wszPropIssuerDot[] = wszPROPISSUERDOT;
WCHAR const g_wszPropIssuerDistinguishedName[] = wszPROPISSUERDISTINGUISHEDNAME;
WCHAR const g_wszPropIssuerRawName[] = wszPROPISSUERRAWNAME;

WCHAR const g_wszPropIssuerCountry[] = wszPROPISSUERCOUNTRY;
WCHAR const g_wszPropIssuerOrganization[] = wszPROPISSUERORGANIZATION;
WCHAR const g_wszPropIssuerOrgUnit[] = wszPROPISSUERORGUNIT;
WCHAR const g_wszPropIssuerCommonName[] = wszPROPISSUERCOMMONNAME;
WCHAR const g_wszPropIssuerLocality[] = wszPROPISSUERLOCALITY;
WCHAR const g_wszPropIssuerState[] = wszPROPISSUERSTATE;
WCHAR const g_wszPropIssuerTitle[] = wszPROPISSUERTITLE;
WCHAR const g_wszPropIssuerGivenName[] = wszPROPISSUERGIVENNAME;
WCHAR const g_wszPropIssuerInitials[] = wszPROPISSUERINITIALS;
WCHAR const g_wszPropIssuerSurName[] = wszPROPISSUERSURNAME;
WCHAR const g_wszPropIssuerDomainComponent[] = wszPROPISSUERDOMAINCOMPONENT;
WCHAR const g_wszPropIssuerEMail[] = wszPROPISSUEREMAIL;
WCHAR const g_wszPropIssuerStreetAddress[] = wszPROPISSUERSTREETADDRESS;
WCHAR const g_wszPropIssuerUnstructuredAddress[] = wszPROPISSUERUNSTRUCTUREDADDRESS;
WCHAR const g_wszPropIssuerUnstructuredName[] = wszPROPISSUERUNSTRUCTUREDNAME;
WCHAR const g_wszPropIssuerDeviceSerialNumber[] = wszPROPISSUERDEVICESERIALNUMBER;


//+--------------------------------------------------------------------------
// Request properties:

WCHAR const g_wszPropRequestRequestID[] = wszPROPREQUESTREQUESTID;
WCHAR const g_wszPropRequestRawRequest[] = wszPROPREQUESTRAWREQUEST;
WCHAR const g_wszPropRequestRawArchivedKey[] = wszPROPREQUESTRAWARCHIVEDKEY;
WCHAR const g_wszPropRequestKeyRecoveryHashes[] = wszPROPREQUESTKEYRECOVERYHASHES;
WCHAR const g_wszPropRequestRawOldCertificate[] = wszPROPREQUESTRAWOLDCERTIFICATE;
WCHAR const g_wszPropRequestAttributes[] = wszPROPREQUESTATTRIBUTES;
WCHAR const g_wszPropRequestType[] = wszPROPREQUESTTYPE;
WCHAR const g_wszPropRequestFlags[] = wszPROPREQUESTFLAGS;
WCHAR const g_wszPropRequestStatusCode[] = wszPROPREQUESTSTATUSCODE;
WCHAR const g_wszPropRequestDisposition[] = wszPROPREQUESTDISPOSITION;
WCHAR const g_wszPropRequestDispositionMessage[] = wszPROPREQUESTDISPOSITIONMESSAGE;
WCHAR const g_wszPropRequestSubmittedWhen[] = wszPROPREQUESTSUBMITTEDWHEN;
WCHAR const g_wszPropRequestResolvedWhen[] = wszPROPREQUESTRESOLVEDWHEN;
WCHAR const g_wszPropRequestRevokedWhen[] = wszPROPREQUESTREVOKEDWHEN;
WCHAR const g_wszPropRequestRevokedEffectiveWhen[] = wszPROPREQUESTREVOKEDEFFECTIVEWHEN;
WCHAR const g_wszPropRequestRevokedReason[] = wszPROPREQUESTREVOKEDREASON;
WCHAR const g_wszPropRequesterName[] = wszPROPREQUESTERNAME;
WCHAR const g_wszPropCallerName[] = wszPROPCALLERNAME;
WCHAR const g_wszPropRequestOSVersion[] = wszPROPREQUESTOSVERSION;
WCHAR const g_wszPropRequestCSPProvider[] = wszPROPREQUESTCSPPROVIDER;
//+--------------------------------------------------------------------------
// Request attribute properties:

WCHAR const g_wszPropChallenge[] = wszPROPCHALLENGE;
WCHAR const g_wszPropExpectedChallenge[] = wszPROPEXPECTEDCHALLENGE;


//+--------------------------------------------------------------------------
// Certificate properties:

WCHAR const g_wszPropCertificateRequestID[] = wszPROPCERTIFICATEREQUESTID;
WCHAR const g_wszPropRawCertificate[] = wszPROPRAWCERTIFICATE;
WCHAR const g_wszPropCertificateHash[] = wszPROPCERTIFICATEHASH;
WCHAR const g_wszPropCertificateSerialNumber[] = wszPROPCERTIFICATESERIALNUMBER;
WCHAR const g_wszPropCertificateIssuerNameID[] = wszPROPCERTIFICATEISSUERNAMEID;
WCHAR const g_wszPropCertificateNotBeforeDate[] = wszPROPCERTIFICATENOTBEFOREDATE;
WCHAR const g_wszPropCertificateNotAfterDate[] = wszPROPCERTIFICATENOTAFTERDATE;
WCHAR const g_wszPropCertificateSubjectKeyIdentifier[] = wszPROPCERTIFICATESUBJECTKEYIDENTIFIER;
WCHAR const g_wszPropCertificateRawPublicKey[] = wszPROPCERTIFICATERAWPUBLICKEY;
WCHAR const g_wszPropCertificatePublicKeyLength[] = wszPROPCERTIFICATEPUBLICKEYLENGTH;
WCHAR const g_wszPropCertificatePublicKeyAlgorithm[] = wszPROPCERTIFICATEPUBLICKEYALGORITHM;
WCHAR const g_wszPropCertificateRawPublicKeyAlgorithmParameters[] = wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS;


// Strings loaded from the resource file:

WCHAR const *g_pwszRequestedBy;
WCHAR const *g_pwszDeniedBy;
WCHAR const *g_pwszPublishedBy;
WCHAR const *g_pwszPolicyDeniedRequest;
WCHAR const *g_pwszIssued;
WCHAR const *g_pwszUnderSubmission;
WCHAR const *g_pwszCertConstructionError;
WCHAR const *g_pwszRequestParsingError;
WCHAR const *g_pwszRequestSigError;
WCHAR const *g_pwszKeyArchivalError;
WCHAR const *g_pwszArchiveSigningKeyError;

WCHAR const *g_pwszRevokedBy;
WCHAR const *g_pwszUnrevokedBy;
WCHAR const *g_pwszResubmittedBy;
WCHAR const *g_pwszPrintfCertRequestDisposition;
WCHAR const *g_pwszUnknownSubject;
WCHAR const *g_pwszIntermediateCAStore;
WCHAR const *g_pwszPublishError;
WCHAR const *g_pwszYes;
WCHAR const *g_pwszNo;
WCHAR const *g_pwszInvalidIssuancePolicies;
WCHAR const *g_pwszInvalidApplicationPolicies;

LPWSTR g_wszzSecuredAttributes = NULL;

LPCWSTR g_wszzSecuredAttributesDefault = wszzDEFAULTSIGNEDATTRIBUTES; 


typedef struct _STRINGINITMAP
{
    int		  idResource;
    WCHAR const **ppwszResource;
} STRINGINITMAP;

STRINGINITMAP g_aStringInitStrings[] = {
    { IDS_REVOKEDBY,			&g_pwszRevokedBy },
    { IDS_UNREVOKEDBY,			&g_pwszUnrevokedBy },
    { IDS_RESUBMITTEDBY,		&g_pwszResubmittedBy },
    { IDS_REQUESTEDBY,			&g_pwszRequestedBy },
    { IDS_DENIEDBY,			&g_pwszDeniedBy },
    { IDS_PUBLISHEDBY,			&g_pwszPublishedBy },
    { IDS_POLICYDENIED,			&g_pwszPolicyDeniedRequest },
    { IDS_ISSUED,			&g_pwszIssued },
    { IDS_CERTCONSTRUCTIONERROR,	&g_pwszCertConstructionError },
    { IDS_REQUESTPARSEERROR,		&g_pwszRequestParsingError },
    { IDS_REQUESTSIGERROR,		&g_pwszRequestSigError },
    { IDS_KEYARCHIVALERROR,		&g_pwszKeyArchivalError },
    { IDS_ARCHIVESIGNINGKEYERROR,	&g_pwszArchiveSigningKeyError },
    { IDS_UNDERSUBMISSION,		&g_pwszUnderSubmission },
    { IDS_PRINTFCERTREQUESTDISPOSITION, &g_pwszPrintfCertRequestDisposition },
    { IDS_UNKNOWNSUBJECT, 		&g_pwszUnknownSubject },
    { IDS_INTERMEDIATECASTORE,		&g_pwszIntermediateCAStore },
    { IDS_PUBLISHERROR,			&g_pwszPublishError },
    { IDS_YES,				&g_pwszYes },
    { IDS_NO,				&g_pwszNo },
    { IDS_ALLOW,			&g_pwszAuditResources[0] }, 
    { IDS_DENY,				&g_pwszAuditResources[1] },
    { IDS_CAADMIN,			&g_pwszAuditResources[2] },
    { IDS_OFFICER,			&g_pwszAuditResources[3] },
    { IDS_READ,				&g_pwszAuditResources[4] },
    { IDS_ENROLL,			&g_pwszAuditResources[5] },
    { IDS_INVALIDISSUANCEPOLICIES,	&g_pwszInvalidIssuancePolicies },
    { IDS_INVALIDAPPLICATIONPOLICIES,	&g_pwszInvalidApplicationPolicies },
};


HANDLE *g_rgDSCache = NULL;
DWORD g_cDSCacheCur;
BOOL g_fcritsecDSCache = FALSE;
CRITICAL_SECTION g_critsecDSCache;


// Check if retriever is requester or subject of the cert being retrieved
HRESULT coreCheckRetrieveAccessRight(
    ICertDBRow *prow,
    IN WCHAR const *pcwszUserName)
{
    HRESULT hr;
    WCHAR *pwszRequesterName = NULL;
    WCHAR *pwszCallerName = NULL;

    hr = PKCSGetProperty(
        prow,
        g_wszPropRequesterName,
        PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
        NULL,
        (BYTE **) &pwszRequesterName);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfError(hr, error, "PKCSGetProperty RequesterName");
    }

    if (S_OK != hr ||
	NULL == pwszRequesterName ||
	0 != mylstrcmpiL(pcwszUserName, pwszRequesterName))
    {
        hr = PKCSGetProperty(
            prow,
            g_wszPropCallerName,
            PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            NULL,
            (BYTE **) &pwszCallerName);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _JumpIfError(hr, error, "PKCSGetProperty CallerName");
	}

	if (S_OK != hr ||
	    NULL == pwszCallerName ||
	    0 != mylstrcmpiL(pcwszUserName, pwszCallerName))
        {
	    CAuditEvent audit(0, g_dwAuditFilter);

	    hr = audit.AccessCheck(
			    CA_ACCESS_ALLREADROLES,
			    audit.m_gcNoAuditSuccess | audit.m_gcNoAuditFailure);
	    _JumpIfError(hr, error, "CAuditEvent::AccessCheck");
        }
    }
    hr = S_OK;

error:
    LOCAL_FREE(pwszRequesterName);
    LOCAL_FREE(pwszCallerName);
    return hr;
}


HRESULT
coreDSInitCache()
{
    HRESULT hr;
    
    hr = S_OK;
    __try
    {
	InitializeCriticalSection(&g_critsecDSCache);
	g_fcritsecDSCache = TRUE;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    g_rgDSCache = (HANDLE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				g_dwSessionCount * sizeof(g_rgDSCache[0]));
    if (NULL == g_rgDSCache)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    g_cDSCacheCur = 0;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
coreDSGetHandle(
    OUT HANDLE *phDS,
    OUT BOOL *pfCached)
{
    HRESULT hr;
    HANDLE hDS;

    *phDS = NULL;
    *pfCached = TRUE;

    hDS = NULL;

    EnterCriticalSection(&g_critsecDSCache);
    if (0 != g_cDSCacheCur)
    {
	hDS = g_rgDSCache[--g_cDSCacheCur];
    }
    LeaveCriticalSection(&g_critsecDSCache);

    if (NULL == hDS)
    {
	*pfCached = FALSE;
	hr = DsBind(NULL, NULL, &hDS);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _JumpError(hr, error, "DsBind");
	}
    }
    *phDS = hDS;
    hr = S_OK;

error:
    return(hr);
}


DWORD
coreDSUnbindWorker(
    OPTIONAL IN OUT VOID *pvparms)
{
    HANDLE hDS = (HANDLE) pvparms;

    DsUnBind(&hDS);
    return(0);
}


VOID
coreDSUnbind(
    IN HANDLE hDS,
    IN BOOL fSynchronous)
{
    HRESULT hr;
    HANDLE hThread = NULL;
    DWORD ThreadId;

    if (NULL != hDS)
    {
	if (!fSynchronous)
	{
	    hThread = CreateThread(
			    NULL,	// lpThreadAttributes (Security Attr)
			    0,		// dwStackSize
			    coreDSUnbindWorker,
			    hDS,	// lpParameter
			    0,          // dwCreationFlags
			    &ThreadId);
	    if (NULL == hThread)
	    {
		hr = myHLastError();
		_PrintError(hr, "CreateThread");
	    }
	}
	if (NULL == hThread)
	{
	    coreDSUnbindWorker(hDS);
	}
    }

//error:
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
}


VOID
coreDSEmptyCache(
    IN BOOL fSynchronous)
{
    EnterCriticalSection(&g_critsecDSCache);
    while (0 != g_cDSCacheCur)
    {
	coreDSUnbind(g_rgDSCache[--g_cDSCacheCur], fSynchronous);
    }
    LeaveCriticalSection(&g_critsecDSCache);
}


VOID
coreDSReleaseHandle(
    IN HANDLE hDS)
{
    // only cache g_dwSessionCount DS handles.  They're all equivalent,
    // so if the one being released won't fit in the array, toss it.
    
    EnterCriticalSection(&g_critsecDSCache);
    CSASSERT(0 != g_dwSessionCount);
    if (g_cDSCacheCur < g_dwSessionCount)
    {
	g_rgDSCache[g_cDSCacheCur++] = hDS;
	hDS = NULL;
    }
    LeaveCriticalSection(&g_critsecDSCache);

    if (NULL != hDS)
    {
	coreDSUnbind(hDS, TRUE);
    }
}


typedef struct _LDAPCACHE
{
    _LDAPCACHE	*plcNext;
    WCHAR	*pwszDomainDns;
    LDAP	*pld;
} LDAPCACHE;


typedef struct _FORESTLDAPCACHE
{
    LDAPCACHE	    *plc;
    DWORD	     clc;
    WCHAR	    *pwszDomainDns;
    BOOL	     fcritsec;
    CRITICAL_SECTION critsec;
} FORESTLDAPCACHE;

FORESTLDAPCACHE *g_rgForestLdapCache = NULL;
DWORD g_cForestLdapCache = 0;


HRESULT
coreLdapInitCache()
{
    HRESULT hr;
    WCHAR *pwsz;
    FORESTLDAPCACHE *pflcEnd;
    FORESTLDAPCACHE *pflc;

    g_cForestLdapCache = 1;		// local Forest
    if (NULL != g_pwszzAlternatePublishDomains)
    {
	for (
	    pwsz = g_pwszzAlternatePublishDomains;
	    L'\0' != *pwsz;
	    pwsz += wcslen(pwsz) + 1)
	{
	    g_cForestLdapCache++;
	}
    }
    g_rgForestLdapCache = (FORESTLDAPCACHE *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			g_cForestLdapCache * sizeof(g_rgForestLdapCache[0]));
    if (NULL == g_rgForestLdapCache)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwsz = g_pwszzAlternatePublishDomains;
    pflcEnd = &g_rgForestLdapCache[g_cForestLdapCache];
    for (pflc = g_rgForestLdapCache; pflc < pflcEnd; pflc++)
    {
	if (pflc > g_rgForestLdapCache)
	{
	    pflc->pwszDomainDns = pwsz;
	    pwsz += wcslen(pwsz) + 1;
	}
	hr = S_OK;
	__try
	{
	    InitializeCriticalSection(&pflc->critsec);
	    pflc->fcritsec = TRUE;
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError(hr, error, "InitializeCriticalSection");
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
coreLdapUnbind(
    IN OUT LDAPCACHE *plc)
{
    if (NULL != plc->pld)
    {
	ldap_unbind(plc->pld);
	plc->pld = NULL;
    }
    if (NULL != plc->pwszDomainDns)
    {
	LocalFree(plc->pwszDomainDns);
	plc->pwszDomainDns = NULL;
    }
    LocalFree(plc);
}


VOID
coreLdapFreeCache()
{
    if (NULL != g_rgForestLdapCache)
    {
	FORESTLDAPCACHE *pflcEnd = &g_rgForestLdapCache[g_cForestLdapCache];
	FORESTLDAPCACHE *pflc;
	
	for (pflc = g_rgForestLdapCache; pflc < pflcEnd; pflc++)
	{
	    if (pflc->fcritsec)
	    {
		LDAPCACHE *plc;

		EnterCriticalSection(&pflc->critsec);

		while (NULL != pflc->plc)
		{
		    plc = pflc->plc;
		    pflc->plc = plc->plcNext;
		    plc->plcNext = NULL;
		    coreLdapUnbind(plc);
		}

		LeaveCriticalSection(&pflc->critsec);

		DeleteCriticalSection(&pflc->critsec);
		pflc->fcritsec = FALSE;
	    }
	}
	LocalFree(g_rgForestLdapCache);
	g_rgForestLdapCache = NULL;
    }
}


HRESULT
coreLdapGetCachedHandle(
    IN DWORD iForest,
    OPTIONAL IN WCHAR const *pwszDomainDns,
    OUT WCHAR const **ppwszDomainDns,
    OUT LDAPCACHE **pplc)
{
    HRESULT hr;
    FORESTLDAPCACHE *pflc = NULL;
    BOOL fCritSecEntered = FALSE;
    LDAPCACHE *plc;
    LDAPCACHE **pplcPrev;

    *ppwszDomainDns = NULL;
    *pplc = NULL;

    if (NULL == g_rgForestLdapCache || iForest >= g_cForestLdapCache)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "g_rgForestLdapCache");
    }
    pflc = &g_rgForestLdapCache[iForest];
    *ppwszDomainDns = pflc->pwszDomainDns;

    EnterCriticalSection(&pflc->critsec);
    fCritSecEntered = TRUE;

    pplcPrev = &pflc->plc;
    for (plc = pflc->plc; ; plc = plc->plcNext)
    {
	if (NULL == plc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError2(hr, error, "pflc->plc", hr);
	}
	if (NULL == pwszDomainDns ||
	    0 == mylstrcmpiL(plc->pwszDomainDns, pwszDomainDns))
	{
	    break;
	}
	pplcPrev = &plc->plcNext;
    }
    *pplcPrev = plc->plcNext;
    plc->plcNext = NULL;
    *pplc = plc;
    CSASSERT(0 < pflc->clc);
    pflc->clc--;
    hr = S_OK;

error:
    if (NULL != pflc && fCritSecEntered)
    {
	LeaveCriticalSection(&pflc->critsec);
    }
    return(hr);
}


HRESULT
coreLdapBindHandle(
    IN WCHAR const *pwszDomainDns,
    OUT LDAPCACHE **pplc)
{
    HRESULT hr;
    LDAPCACHE *plc = NULL;

    plc = (LDAPCACHE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(*plc));
    if (NULL == plc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CSASSERT(NULL != pwszDomainDns);

    hr = myDupString(pwszDomainDns, &plc->pwszDomainDns);
    _JumpIfError(hr, error, "myDupString");

    hr = myRobustLdapBindEx(
		    0,			// dwFlags1
		    RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
		    LDAP_VERSION2,	// uVersion
		    pwszDomainDns,	// pwszDomainName
		    &plc->pld,		// ppld
		    NULL);		// ppwszForestDNSName
    _JumpIfError(hr, error, "myRobustLdapBindEx");

    *pplc = plc;
    plc = NULL;
    hr = S_OK;

error:
    if (NULL != plc)
    {
       coreLdapUnbind(plc);
    }
    return(hr);
}


HRESULT
coreLdapGetHandle(
    IN DWORD iForest,
    OPTIONAL IN WCHAR const *pwszDomainDns,	// NULL for 0 < iForest
    OUT LDAPCACHE **pplc,
    OUT BOOL *pfCached)
{
    HRESULT hr;
    WCHAR const *pwszForestDomainDns;

    CSASSERT(NULL != pplc);
    *pplc = NULL;
    *pfCached = TRUE;

    hr = coreLdapGetCachedHandle(
			    iForest,
			    pwszDomainDns,
			    &pwszForestDomainDns,
			    pplc);
    if (S_OK != hr)
    {
	_PrintError(hr, "coreGetLdapCache");
	*pfCached = FALSE;
	if (NULL == pwszDomainDns)
	{
	    CSASSERT(0 < iForest);
            if (NULL == pwszForestDomainDns)
            {
                hr = E_UNEXPECTED;
                _JumpError(hr, error, "pwszForestDomainDns NULL");
            }
	    pwszDomainDns = pwszForestDomainDns;
	}
	hr = coreLdapBindHandle(pwszDomainDns, pplc);
	_JumpIfError(hr, error, "coreBindLdapHandle");
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
coreLdapReleaseHandle(
    IN DWORD iForest,
    IN LDAPCACHE *plc)
{
    if (NULL != g_rgForestLdapCache && iForest < g_cForestLdapCache)
    {
	FORESTLDAPCACHE *pflc = &g_rgForestLdapCache[iForest];

	if (pflc->fcritsec)
	{
	    EnterCriticalSection(&pflc->critsec);
	    plc->plcNext = pflc->plc;
	    pflc->plc = plc;
	    pflc->clc++;
	    LeaveCriticalSection(&pflc->critsec);
	    plc = NULL;
	}
    }
    if (NULL != plc)
    {
	coreLdapUnbind(plc);
    }
}


HRESULT
myAddDomainName(
    IN WCHAR const *pwszSamName,
    OUT WCHAR **ppwszSamName,		// *ppwszSamName is NULL if unchanged
    OUT WCHAR const **ppwszUserName)
{
    HRESULT hr;
    WCHAR const *pwszUserName;
    WCHAR wszDomain[MAX_PATH];

    *ppwszSamName = NULL;
    *ppwszUserName = NULL;

    if (L'\0' == *pwszSamName)
    {
	hr = E_ACCESSDENIED;	// can't have a zero length name
	_JumpError(hr, error, "zero length name");
    }

    // See if it includes a domain name.

    pwszUserName = wcschr(pwszSamName, L'\\');
    if (NULL == pwszUserName)
    {
	DWORD cwc = ARRAYSIZE(wszDomain);
	WCHAR *pwsz;

        // There was no domain portion, so assume part of the current domain.

        if (GetUserNameEx(NameSamCompatible, wszDomain, &cwc))
        {
            // Fix NULL termination bug

            if (0 != cwc)
            {
		cwc--;
            }
	    wszDomain[cwc] = L'\0';
            pwsz = wcschr(wszDomain, L'\\');
            if (NULL != pwsz)
            {
                pwsz++;
                wcsncpy(pwsz, pwszSamName, ARRAYSIZE(wszDomain) - cwc);

		hr = myDupString(wszDomain, ppwszSamName);
		_JumpIfError(hr, error, "myDupString");

		pwszSamName = *ppwszSamName;
            }          
        }
    }
    pwszUserName = wcschr(pwszSamName, L'\\');
    if (NULL == pwszUserName)
    {
        pwszUserName = pwszSamName;
    }
    else
    {
        pwszUserName++;
    }
    *ppwszUserName = pwszUserName;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
coreGetDNFromSamName(
    IN WCHAR const *pwszSamName,
    OUT WCHAR **ppwszDN)
{
    HRESULT hr;
    HANDLE hDS = NULL;
    DS_NAME_RESULT *pNameResults = NULL;

    CSASSERT(NULL != ppwszDN);
    *ppwszDN = NULL;

    for (;;)
    {
	BOOL fCached;

	if (NULL != hDS)
	{
	    coreDSUnbind(hDS, FALSE);
	    hDS = NULL;
	    coreDSEmptyCache(FALSE);
	}
	hr = coreDSGetHandle(&hDS, &fCached);
	_JumpIfError(hr, error, "coreGetDSHandle");

	// Got a connection.  Crack the name:

	hr = DsCrackNames(
		    hDS,
		    DS_NAME_NO_FLAGS,
		    DS_NT4_ACCOUNT_NAME,
		    DS_FQDN_1779_NAME,
		    1,			// one name
		    &pwszSamName,	// one name (IN)
		    &pNameResults);	// OUT
	if (S_OK != hr)
	{
	    // It's probably not worth flushing the DS cache only when certain
	    // errors are detected.

	    hr = myHError(hr);
	    if (fCached)
	    {
		_PrintError(hr, "DsCrackNames");
		continue;
	    }
	    _JumpError(hr, error, "DsCrackNames");
	}
	if (1 > pNameResults->cItems ||
	    DS_NAME_NO_ERROR != pNameResults->rItems[0].status)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	    _JumpError(hr, error, "DsCrackNames result");
	}
	break;
    }
    hr = myDupString(pNameResults->rItems[0].pName, ppwszDN);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pNameResults)
    {
	DsFreeNameResult(pNameResults);
    }
    if (NULL != hDS)
    {
	coreDSReleaseHandle(hDS);
    }
    return(hr);
}


HRESULT
coreGetComContextUserDNFromSamName(
    IN BOOL fDeleteUserDNOnly,
    OPTIONAL IN WCHAR const *pwszSamName,
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OPTIONAL OUT WCHAR const **ppwszDN)		// do NOT free!
{
    HRESULT hr;
    CERTSRV_COM_CONTEXT *pComContext;

    hr = ComGetClientInfo(Context, dwComContextIndex, &pComContext);
    _JumpIfError(hr, error, "ComGetClientInfo");

    if (fDeleteUserDNOnly)
    {
	if (NULL != pComContext->pwszUserDN)
	{
	    LocalFree(pComContext->pwszUserDN);
	    pComContext->pwszUserDN = NULL;
	}
    }
    else
    {
	if (NULL == pComContext->pwszUserDN)
	{
	    hr = coreGetDNFromSamName(pwszSamName, &pComContext->pwszUserDN);
	    _JumpIfError(hr, error, "coreGetDNFromSamName");
	}
    }
    if (NULL != ppwszDN)
    {
	*ppwszDN = pComContext->pwszUserDN;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CoreSetComContextUserDN(
    IN DWORD dwRequestId,
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OPTIONAL OUT WCHAR const **ppwszDN)		// do NOT free!
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    WCHAR *pwszSamName = NULL;
    WCHAR *pwszSamNamePatched = NULL;
    WCHAR const *pwszUserName;

    hr = g_pCertDB->OpenRow(
		    PROPOPEN_READONLY | PROPTABLE_REQCERT,
		    dwRequestId,
		    NULL,
		    &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequesterName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		NULL,
		(BYTE **) &pwszSamName);
    _JumpIfError(hr, error, "PKCSGetProperty");

    hr = myAddDomainName(pwszSamName, &pwszSamNamePatched, &pwszUserName);
    _JumpIfError(hr, error, "myAddDomainName");

    hr = coreGetComContextUserDNFromSamName(
		FALSE,		// fDeleteUserDNOnly
		NULL != pwszSamNamePatched? pwszSamNamePatched : pwszSamName,
		Context,
		dwComContextIndex,
		ppwszDN);
    _JumpIfError(hr, error, "coreGetComContextUserDNFromSamName");

error:
    if (NULL != pwszSamName)
    {
	LocalFree(pwszSamName);
    }
    if (NULL != pwszSamNamePatched)
    {
	LocalFree(pwszSamNamePatched);
    }
    if (NULL != prow)
    {
        prow->Release();
    }
    return(hr);
}


HRESULT
CoreSetArchivedKey(
    IN OUT CERTSRV_COM_CONTEXT *pComContext)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    DWORD cb;

    CSASSERT(0 ==
	((CCCF_KEYARCHIVEDSET | CCCF_KEYARCHIVED) & pComContext->dwFlags));

    hr = g_pCertDB->OpenRow(
		    PROPOPEN_READONLY | PROPTABLE_REQCERT,
		    pComContext->RequestId,
		    NULL,
		    &prow);
    _JumpIfError(hr, error, "OpenRow");

    cb = 0;
    hr = prow->GetProperty(
		    g_wszPropRequestRawArchivedKey,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cb,
		    NULL);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfError(hr, error, "PKCSGetProperty");

	if (0 < cb)
	{
	    pComContext->dwFlags |= CCCF_KEYARCHIVED;
	}
    }
    pComContext->dwFlags |= CCCF_KEYARCHIVEDSET;
    hr = S_OK;

error:
    if (NULL != prow)
    {
        prow->Release();
    }
    return(hr);
}


DWORD g_PolicyFlags;


HRESULT
CoreSetDisposition(
    IN ICertDBRow *prow,
    IN DWORD Disposition)
{
    HRESULT hr;

    hr = prow->SetProperty(
		    g_wszPropRequestDisposition,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(Disposition),
		    (BYTE const *) &Disposition);
    _JumpIfError(hr, error, "SetProperty(disposition)");

error:
    return(hr);
}


DWORD
coreRegGetTimePeriod(
    IN HKEY hkeyCN,
    IN WCHAR const *pwszRegPeriodCount,
    IN WCHAR const *pwszRegPeriodString,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount)
{
    HRESULT hr;
    LONG lCount;
    DWORD dwType;
    DWORD cbValue;
    
    cbValue = sizeof(lCount);
    hr = RegQueryValueEx(
		hkeyCN,
		pwszRegPeriodCount,
		NULL,		// lpdwReserved
		&dwType,
		(BYTE *) &lCount,
		&cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(lCount) == cbValue)
    {
        WCHAR awcPeriod[10];
        
        cbValue = sizeof(awcPeriod);
        hr = RegQueryValueEx(
		    hkeyCN,
		    pwszRegPeriodString,
		    NULL,		// lpdwReserved
		    &dwType,
		    (BYTE *) awcPeriod,
		    &cbValue);
        if (S_OK != hr)
        {
            hr = myHError(hr);
            if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }
            _JumpIfError(hr, error, "RegQueryValueEx");
        }
        else
        {
            
            if (REG_SZ != dwType || sizeof(awcPeriod) <= cbValue)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpIfErrorStr(hr, error, "time period string", pwszRegPeriodString);
            }
            hr = myTranslatePeriodUnits(
				awcPeriod,
				lCount,
				penumPeriod,
				plCount);
            _JumpIfError(hr, error, "myTranslatePeriodUnits");
        }
    }
error:
    return(hr);
}


// Converts a REG_SZ Subject template into a double null terminated REG_MULTI_SZ type string

DWORD
coreConvertSubjectTemplate(
    OUT WCHAR* pwszz,
    IN WCHAR* pwszTemplate,
    IN DWORD cwc)
{
    HRESULT hr;
    WCHAR *pwszToken;
    WCHAR *pwszRemain = pwszTemplate;
    WCHAR *pwszzNew = pwszz;
    DWORD cwszzNew = 0;
    BOOL fSplit;

    for (;;)
    {
        pwszToken = PKCSSplitToken(&pwszRemain, wszNAMESEPARATORDEFAULT, &fSplit);
        if (NULL == pwszToken)
        {
            *pwszzNew = L'\0';
            break;
        }
        cwszzNew += (1 + wcslen(pwszToken)) * sizeof(WCHAR);
        if (cwszzNew > cwc)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "overflow");
        }
        wcscpy(pwszzNew, pwszToken);
        pwszzNew = wcschr(pwszzNew, L'\0');
        pwszzNew++;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
coreReadRegStringValue(
    IN HKEY hkey,
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszzValue)
{
    HRESULT hr;
    DWORD cb;
    DWORD cwc;
    DWORD dwType;
    WCHAR *pwszzValue = NULL;
    
    *ppwszzValue = NULL;
    cb = 0;
    cwc = 0;
    for (;;)
    {
	hr = RegQueryValueEx(
			hkey,
			pwszName,
			NULL,		// lpdwReserved
			&dwType,
			(BYTE *) pwszzValue,
			&cb);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
            _JumpErrorStr(hr, error, "RegQueryValueEx", pwszName);
	}
	if (NULL != pwszzValue)
	{
	    pwszzValue[cwc] = L'\0';
	    pwszzValue[cwc + 1] = L'\0';
	    break;
	}
	if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "RegQueryValueEx: value type");
	}
	cwc = (cb + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1);
	pwszzValue = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 2) * sizeof(WCHAR));
	if (NULL == pwszzValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *ppwszzValue = pwszzValue;
    pwszzValue = NULL;
    hr = S_OK;

error:
    if (NULL != pwszzValue)
    {
	LocalFree(pwszzValue);
    }
    return(hr);
}
			

HRESULT
CoreInit(
    IN BOOL fAuditEnabled)
{
    HRESULT hr;
    HKEY hkeyConfig = NULL;
    HKEY hkeyCN = NULL;
    BYTE abbuf[MAX_PATH * sizeof(TCHAR)];
    WCHAR awcTemplate[MAX_PATH];
    DWORD cbbuf;
    DWORD dwType;
    WCHAR *pwsz;
    DWORD dw, dwCASetupStatus;
    BOOL fLogError = TRUE;
    DWORD LogMsg = MSG_BAD_REGISTRY;
    WCHAR const *pwszLog = NULL;
    WCHAR *pwszHighSerial = NULL;
    int i;
    DWORD cbValue;
    DWORD dwEnabled;
    CAuditEvent AuditSettings;
    WCHAR *pwszFullRequestFileName = NULL;
    
    hr = myGetMachineDnsName(&g_pwszServerName);
    _JumpIfError(hr, error, "myGetMachineDnsName");
    
    for (i = 0; i < ARRAYSIZE(g_aStringInitStrings); i++)
    {
        WCHAR const *pwszT;
        
        pwszT = myLoadResourceString(g_aStringInitStrings[i].idResource);
        if (NULL == pwszT)
        {
            hr = myHLastError();
            _JumpError(hr, error, "myLoadResourceString");
        }
        *g_aStringInitStrings[i].ppwszResource = pwszT;
    }
    g_hrJetVersionStoreOutOfMemory = myJetHResult(JET_errVersionStoreOutOfMemory);

    hr = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        g_wszRegKeyConfigPath,
        0,		// dwReserved
        KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
        &hkeyConfig);
    _JumpIfError(hr, error, "RegOpenKeyEx(Config)");
    
    cbbuf = sizeof(abbuf);
    hr = RegQueryValueEx(
        hkeyConfig,
        g_wszRegDirectory,
        NULL,		// lpdwReserved
        &dwType,
        abbuf,
        &cbbuf);
    if (S_OK != hr)
    {
        hr = myHError(hr);
    }
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpIfError(hr, error, "RegQueryValueEx(Base)");
        
        if (REG_SZ != dwType)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "RegQueryValueEx(Base)");
        }
        if (sizeof(abbuf) < cbbuf)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            _JumpError(hr, error, "RegQueryValueEx(Base)");
        }
        CopyMemory(g_wszSharedFolder, abbuf, cbbuf);
    }
    DBGPRINT((DBG_SS_CERTSRVI, "Shared Folder = '%ws'\n", g_wszSharedFolder));

    cbbuf = sizeof(g_dwSessionCount);
    hr = RegQueryValueEx(
		    hkeyConfig,
		    wszREGDBSESSIONCOUNT,
		    NULL,
		    NULL,
		    (BYTE *) &g_dwSessionCount,
		    &cbbuf);
    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "RegQueryValueEx", wszREGDBSESSIONCOUNT);
	g_dwSessionCount = DBSESSIONCOUNTDEFAULT;
    }
    if (DBSESSIONCOUNTMIN > g_dwSessionCount)
    {
	g_dwSessionCount = DBSESSIONCOUNTMIN;
    }
    if (DBSESSIONCOUNTMAX < g_dwSessionCount)
    {
	g_dwSessionCount = DBSESSIONCOUNTMAX;
    }

    // Find out the name of the active CA(s)
    
    g_wszSanitizedName[0] = L'\0';
    cbbuf = sizeof(g_wszSanitizedName);
    hr = RegQueryValueEx(
        hkeyConfig,
        g_wszRegActive,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) g_wszSanitizedName,
        &cbbuf);
    if ((HRESULT) ERROR_FILE_NOT_FOUND == hr)
    {
#define szForgotSetup "\n\nDid you forget to setup the Cert Server?\n\n\n"

	CONSOLEPRINT0((MAXDWORD, szForgotSetup));
    }
    _JumpIfError(hr, error, "RegQueryValueEx(Base)");
    
    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "RegQueryValueEx: value type");
    }
    g_wszSanitizedName[cbbuf / sizeof(WCHAR)] = L'\0';
    if (REG_MULTI_SZ == dwType)
    {
        i = wcslen(g_wszSanitizedName);
        if (L'\0' != g_wszSanitizedName[i + 1])
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "RegQueryValueEx: multiple Active CAs");
        }
    }
    DBGPRINT((DBG_SS_CERTSRVI, "Active CA (Sanitized Name) = '%ws'\n", g_wszSanitizedName));
    
    pwszLog = g_wszSanitizedName;

    hr = mySanitizedNameToDSName(g_wszSanitizedName, &g_pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");
    
    hr = RegOpenKeyEx(
        hkeyConfig,
        g_wszSanitizedName,
        0,		// dwReserved
        KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
        &hkeyCN);
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "RegOpenKeyEx");
    }
    
    cbValue = sizeof(g_wszCommonName) - 2 * sizeof(WCHAR);
    hr = RegQueryValueEx(
        hkeyCN,
        wszREGCOMMONNAME,
        NULL,
        &dwType,
        (BYTE *)g_wszCommonName,
        &cbValue);
    
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "RegOpenKeyEx");
    }
    if (REG_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "Couldn't find CA common name");
    }
    g_wszCommonName[cbValue / sizeof(WCHAR)] = L'\0';

    pwszLog = g_wszCommonName;
    
    cbValue = sizeof(dwEnabled);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegEnabled,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dwEnabled,
        &cbValue);
    if (S_OK != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "RegQueryValueEx");
    }
    if (REG_DWORD == dwType &&
        sizeof(dwEnabled) == cbValue &&
        0 == dwEnabled)
    {
        DBGPRINT((DBG_SS_CERTSRVI, "CN = '%ws' DISABLED!\n", g_wszSanitizedName));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "RegQueryValueEx: Active CA DISABLED!");
    }
    DBGPRINT((DBG_SS_CERTSRVI, "CN = '%ws': Enabled\n", g_wszSanitizedName));
    
    // to check machine setup status
    hr = GetSetupStatus(NULL, &dw);
    _JumpIfError(hr, error, "GetSetupStatus");
    
    if (!(SETUP_SERVER_FLAG & dw))
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        _JumpError(hr, error, "Server installation was not complete");
    }
    if (SETUP_SERVER_UPGRADED_FLAG & dw)
    {
	g_fServerUpgraded = TRUE;
	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CoreInit: read SETUP_SERVER_UPGRADED_FLAG\n"));
    }
    
    // check per ca
    hr = GetSetupStatus(g_wszSanitizedName, &dwCASetupStatus);
    _JumpIfError(hr, error, "GetSetupStatus");

    dw = dwCASetupStatus;
    
    if (SETUP_SUSPEND_FLAG & dw)
    {
        LogMsg = MSG_E_INCOMPLETE_HIERARCHY;
        hr = myGetCARegFileNameTemplate(
            wszREGREQUESTFILENAME,
            g_pwszServerName,
            g_wszSanitizedName,
            0,
            0,
            &pwszFullRequestFileName);
        _JumpIfErrorStr(hr, error, "myGetCARegFileNameTemplate wszREGREQUESTFILENAME", 
            g_wszSanitizedName);

        pwszLog = pwszFullRequestFileName;

        hr = HRESULT_FROM_WIN32(ERROR_INSTALL_SUSPEND);
        _JumpError(hr, error, "Hierarchy setup incomplete");
    }
    if (!(SETUP_SERVER_FLAG & dw))
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);
        _JumpError(hr, error, "Server installation was not complete");
    }
    if (SETUP_FORCECRL_FLAG & dw)
    {
	// Don't clear SETUP_FORCECRL_FLAG until CRLs successfully generated

	hr = myDeleteCertRegValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    wszREGCRLNEXTPUBLISH);
	_PrintIfErrorStr2(
		    hr,
		    "myDeleteCertRegValue",
		    wszREGCRLNEXTPUBLISH,
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

    // update the CA DS object with the server type flags

    if (SETUP_UPDATE_CAOBJECT_SVRTYPE & dw)
    {
        hr = SetCAObjectFlags(
			g_fAdvancedServer? CA_FLAG_CA_SERVERTYPE_ADVANCED : 0);
        _PrintIfError(hr, "SetCAObjectFlags");
        if (S_OK == hr)
        {
            hr = SetSetupStatus(
			g_wszSanitizedName, 
			SETUP_UPDATE_CAOBJECT_SVRTYPE, 
			FALSE);
            _PrintIfError(hr, "SetSetupStatus");
        }
    }
    
    hr = coreReadRegStringValue(
			hkeyCN,
			wszREGALTERNATEPUBLISHDOMAINS,
			&g_pwszzAlternatePublishDomains);
    _PrintIfError2(
		hr,
		"coreReadRegStringValue",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    
    coreDSInitCache();
    coreLdapInitCache();
    
    cbValue = sizeof(g_PolicyFlags);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegPolicyFlags,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &g_PolicyFlags,
        &cbValue);
    if (S_OK != hr ||
        REG_DWORD != dwType ||
        sizeof(g_PolicyFlags) != cbValue)
    {
        g_PolicyFlags = 0;
    }

    cbValue = sizeof(awcTemplate);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegSubjectTemplate,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) awcTemplate,
        &cbValue);
    if (S_OK == hr &&
        (REG_SZ == dwType || REG_MULTI_SZ == dwType) &&
        sizeof(WCHAR) < cbValue &&
        L'\0' != awcTemplate[0])
    {
        if (L'\0' != awcTemplate[cbValue/sizeof(WCHAR) - 1] ||
            (REG_MULTI_SZ == dwType &&
            L'\0' != awcTemplate[cbValue/sizeof(WCHAR) - 2]) ||
            sizeof(awcTemplate) < cbValue)
        {
            LogMsg = MSG_E_REG_BAD_SUBJECT_TEMPLATE;
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "Bad Subject Template length/termination");
        }
        
        pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue + sizeof(WCHAR));
        if (NULL != pwsz)
        {
            if (dwType == REG_MULTI_SZ)
            {
                CopyMemory(pwsz, awcTemplate, cbValue);
            }
            else
            {
                hr = coreConvertSubjectTemplate(pwsz, awcTemplate, cbValue);
                if (S_OK != hr)
                {
                    LocalFree(pwsz);
                }
                _JumpIfError(hr, error, "coreConvertSubjectTemplate");
            }
            g_pwszzSubjectTemplate = pwsz;
        }
    }
    
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegCertEnrollCompatible,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
        g_fCertEnrollCompatible = dw? TRUE : FALSE;
    }
    
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegEnforceX500NameLengths,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
        g_fEnforceRDNNameLengths = dw? TRUE : FALSE;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        wszREGCRLEDITFLAGS,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
	g_CRLEditFlags = dw;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
	wszREGKRAFLAGS,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
	g_KRAFlags = dw;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
	wszREGKRACERTCOUNT,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr &&
        REG_DWORD == dwType &&
        sizeof(dw) == cbValue)
    {
	g_cKRACertsRoundRobin = dw;
    }
    
    hr = coreRegGetTimePeriod(
        hkeyCN,
        g_wszRegValidityPeriodCount,
        g_wszRegValidityPeriodString,
        &g_enumValidityPeriod,
        &g_lValidityPeriodCount);
    if (S_OK != hr)
    {
        LogMsg = MSG_E_REG_BAD_CERT_PERIOD;
        _JumpError(hr, error, "Bad Registry ValidityPeriod");
    }

    hr = coreRegGetTimePeriod(
        hkeyCN,
        g_wszRegCAXchgValidityPeriodCount,
        g_wszRegCAXchgValidityPeriodString,
        &g_enumCAXchgValidityPeriod,
        &g_lCAXchgValidityPeriodCount);
    _PrintIfError(hr, "Bad Registry CA Xchg Validity Period");

    hr = coreRegGetTimePeriod(
        hkeyCN,
        g_wszRegCAXchgOverlapPeriodCount,
        g_wszRegCAXchgOverlapPeriodString,
        &g_enumCAXchgOverlapPeriod,
        &g_lCAXchgOverlapPeriodCount);
    _PrintIfError(hr, "Bad Registry CA Xchg Overlap Period");

    hr = PKCSUpdateXchgValidityPeriods(NULL);
    _PrintIfError(hr, "PKCSUpdateXchgValidityPeriods");

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegForceTeletex,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
	switch (ENUM_TELETEX_MASK & dw)
        {
	    case ENUM_TELETEX_OFF:
	    case ENUM_TELETEX_ON:
		g_fForceTeletex =
		    (enum ENUM_FORCETELETEX) (ENUM_TELETEX_MASK & dw);
		break;
            
	    default:
		g_fForceTeletex = ENUM_TELETEX_AUTO;
		break;
        }
        if (ENUM_TELETEX_UTF8 & dw)
	{
	    *(DWORD *) &g_fForceTeletex |= ENUM_TELETEX_UTF8;
	}
    }
    
    cbValue = sizeof(g_CAType);
    hr = RegQueryValueEx(
		    hkeyCN,
		    wszREGCATYPE,
		    NULL,
		    &dwType,
		    (BYTE *) &g_CAType,
		    &cbValue);
    _JumpIfError(hr, error, "RegQueryValueEx");

    cbValue = sizeof(g_fUseDS);
    hr = RegQueryValueEx(
		    hkeyCN,
		    wszREGCAUSEDS,
		    NULL,
		    &dwType,
		    (BYTE *) &g_fUseDS,
		    &cbValue);
    _JumpIfError(hr, error, "RegQueryValueEx");


    cbValue = sizeof(g_wszParentConfig) - 2 * sizeof(WCHAR);
    hr = RegQueryValueEx(
		    hkeyCN,
		    wszREGPARENTCAMACHINE,
		    NULL,
		    &dwType,
		    (BYTE *) g_wszParentConfig,
		    &cbValue);
    if (S_OK == hr && REG_SZ == dwType)
    {
	g_wszParentConfig[cbValue / sizeof(WCHAR)] = L'\0';
	pwsz = &g_wszParentConfig[wcslen(g_wszParentConfig)];

	*pwsz++ = L'\\';
	*pwsz = L'\0';

	cbValue =
	    sizeof(g_wszParentConfig) - 
	    (SAFE_SUBTRACT_POINTERS(pwsz, g_wszParentConfig) + 1) *
		sizeof(WCHAR);
	hr = RegQueryValueEx(
		    hkeyCN,
		    wszREGPARENTCANAME,
		    NULL,
		    &dwType,
		    (BYTE *) pwsz,
		    &cbValue);
	if (S_OK == hr && REG_SZ == dwType)
	{
	    pwsz[cbValue / sizeof(WCHAR)] = L'\0';
	}
	else
	{
	    g_wszParentConfig[0] = L'\0';
	}
    }
    else
    {
	g_wszParentConfig[0] = L'\0';
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegClockSkewMinutes,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_dwClockSkewMinutes = dw;
    }
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegViewAgeMinutes,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_dwViewAgeMinutes = dw;
    }
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegViewIdleMinutes,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_dwViewIdleMinutes = dw;
    }
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegMaxIncomingMessageSize,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_cbMaxIncomingMessageSize = dw;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegMaxIncomingAllocSize,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_cbMaxIncomingAllocSize = dw;
    }

    // load CRL globals
    hr = CRLInit(g_wszSanitizedName);
    _JumpIfError(hr, error, "CRLInitializeGlobals");
    
    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegLogLevel,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_dwLogLevel = dw;
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
        g_wszRegHighSerial,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr)
    {
	if (REG_DWORD == dwType)
	{
	    if (sizeof(dw) == cbValue)
	    {
		g_dwHighSerial = dw;
	    }
	}
	else if (REG_SZ == dwType)
	{
	    hr = coreReadRegStringValue(
				hkeyCN,
				g_wszRegHighSerial,
				&pwszHighSerial);
	    _JumpIfError(hr, error, "coreReadRegStringValue");

	    hr = WszToMultiByteInteger(
				FALSE,
				pwszHighSerial,
				&g_cbHighSerial,
				&g_pbHighSerial);
	    _JumpIfError(hr, error, "WszToMultiByteInteger");
	}
    }

    cbValue = sizeof(dw);
    hr = RegQueryValueEx(
        hkeyCN,
	wszREGINTERFACEFLAGS,
        NULL,		// lpdwReserved
        &dwType,
        (BYTE *) &dw,
        &cbValue);
    if (S_OK == hr && REG_DWORD == dwType && sizeof(dw) == cbValue)
    {
        g_InterfaceFlags = dw;
    }


    hr = g_CASD.Initialize(g_wszSanitizedName);
    if(S_OK!=hr)
    {
        LogMsg = MSG_BAD_PERMISSIONS;
        _JumpError(hr, error, "CProtectedSecurityDescriptor::Initialize");
    }

    // Security has changed while certsrv was stopped. We need to update security on 
    // DS & service to make sure they are in sync with the CA permissions

    if(dwCASetupStatus & SETUP_SECURITY_CHANGED)
    {
        hr = g_CASD.MapAndSetDaclOnObjects(g_fUseDS?true:false);
        _PrintIfError(hr, "CProtectedSecurityDescriptor::MapAndSetDaclOnObjects");

        // clear the flag only if successful
        if(S_OK==hr)
        {
            hr = SetSetupStatus(g_wszSanitizedName, SETUP_SECURITY_CHANGED, FALSE);
            _PrintIfError(hr, "SetSetupStatus SETUP_SECURITY_CHANGED FALSE");
        }
    }

    g_CASD.ImportResourceStrings(g_pwszAuditResources);

    // Functionality available only on advanced server:
    // - restricted officers
    // - enforce role separation

    if (g_fAdvancedServer)
    {
        hr = g_OfficerRightsSD.Initialize(g_wszSanitizedName);
        _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Initialize");

        g_OfficerRightsSD.ImportResourceStrings(g_pwszAuditResources);

        hr = AuditSettings.RoleSeparationFlagLoad(g_wszSanitizedName);
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpIfError(hr, error, "CAuditEvent::RoleSeparationFlagLoad");
        }

    }

    hr = AuditSettings.LoadFilter(g_wszSanitizedName);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpIfError(hr, error, "CAuditEvent::LoadFilter");
    }

    if (fAuditEnabled)
    {
	g_dwAuditFilter = AuditSettings.GetFilter();
    }

    if (NULL != g_pwszzSubjectTemplate)
    {
        hr = PKCSSetSubjectTemplate(g_pwszzSubjectTemplate);
        if (S_OK != hr)
        {
            LogMsg = MSG_E_REG_BAD_SUBJECT_TEMPLATE;
	    pwszLog = g_wszSanitizedName;
            _JumpError(hr, error, "PKCSSetSubjectTemplate");
        }
    }
    hr = PKCSSetup(g_wszCommonName, g_wszSanitizedName);
    if (S_OK != hr)
    {
        fLogError = FALSE;		// PKCSSetup logs a specific error
        _JumpError(hr, error, "PKCSSetup");
    }
    
    hr = CertificateInterfaceInit(
        &ServerCallBacks,
        sizeof(ServerCallBacks));
    if (S_OK != hr)
    {
        LogMsg = MSG_CERTIF_MISMATCH;
        _JumpError(hr, error, "CertificateInterfaceInit");
    }

    hr = ComInit();
    _JumpIfError(hr, error, "ComInit");

    hr = RequestInitCAPropertyInfo();
    _JumpIfError(hr, error, "RequestInitCAPropertyInfo");

    // We must have a policy module to continue.
    hr = PolicyInit(g_wszCommonName, g_wszSanitizedName);
    if (S_OK != hr)
    {
        LogMsg = MSG_NO_POLICY;
        _JumpError(hr, error, "PolicyInit");
    }
    CSASSERT(g_fEnablePolicy);
    
    // On error, silently leave exit module(s) disabled.
    hr = ExitInit(g_wszCommonName, g_wszSanitizedName);
    _PrintIfError(hr, "ExitInit");
    
    hr = myGetCertRegMultiStrValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    wszSECUREDATTRIBUTES,
			    &g_wszzSecuredAttributes);
    if (S_OK != hr)
    {
        // Force defaults
        g_wszzSecuredAttributes = (LPWSTR)g_wszzSecuredAttributesDefault;
    }

    if (g_fServerUpgraded)
    {
	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CoreInit: clearing SETUP_SERVER_UPGRADED_FLAG\n"));

	hr = SetSetupStatus(NULL, SETUP_SERVER_UPGRADED_FLAG, FALSE);
	_PrintIfError(hr, "SetSetupStatus");
    }
    fLogError = FALSE;
    
error:
    if (fLogError)
    {
        LogEventString(EVENTLOG_ERROR_TYPE, LogMsg, pwszLog);
    }
    if (NULL != pwszFullRequestFileName)
    {
        LocalFree(pwszFullRequestFileName);
    }
    if (NULL != pwszHighSerial)
    {
        LocalFree(pwszHighSerial);
    }
    if (NULL != hkeyCN)
    {
        RegCloseKey(hkeyCN);
    }
    if (NULL != hkeyConfig)
    {
        RegCloseKey(hkeyConfig);
    }
    if (S_OK != hr)
    {
        CoreTerminate();
        g_CASD.Uninitialize();
        g_OfficerRightsSD.Uninitialize();
    }
    return(hr);
}


VOID
CoreTerminate(VOID)
{
    if (g_fcritsecDSCache)
    {
	coreDSEmptyCache(TRUE);
	DeleteCriticalSection(&g_critsecDSCache);
	g_fcritsecDSCache = FALSE;
    }
    if (NULL != g_rgDSCache)
    {
	LocalFree(g_rgDSCache);
	g_rgDSCache = NULL;
    }
    coreLdapFreeCache();
    DBShutDown(FALSE);
    ComShutDown();
    PKCSTerminate();
    CRLTerminate();
    if (NULL != g_pwszServerName)
    {
	LocalFree(g_pwszServerName);
	g_pwszServerName = NULL;
    }
    if (NULL != g_pwszzAlternatePublishDomains)
    {
	LocalFree(g_pwszzAlternatePublishDomains);
	g_pwszzAlternatePublishDomains = NULL;
    }
    if (NULL != g_pwszzSubjectTemplate)
    {
	LocalFree(g_pwszzSubjectTemplate);
	g_pwszzSubjectTemplate = NULL;
    }
    if (NULL != g_pwszSanitizedDSName)
    {
	LocalFree(g_pwszSanitizedDSName);
	g_pwszSanitizedDSName = NULL;
    }
    if (NULL != g_pbHighSerial)
    {
	LocalFree(g_pbHighSerial);
	g_pbHighSerial = NULL;
    }

    // free only if it points to memory that isn't the default static buffer

    if (NULL != g_wszzSecuredAttributes &&
	g_wszzSecuredAttributes != g_wszzSecuredAttributesDefault)
    {
        LocalFree(g_wszzSecuredAttributes);
        g_wszzSecuredAttributes = NULL;
    }
}


HRESULT
CoreSetRequestDispositionFields(
    IN ICertDBRow *prow,
    IN DWORD ErrCode,
    IN DWORD Disposition,
    IN WCHAR const *pwszDisposition)
{
    HRESULT hr;

    hr = CoreSetDisposition(prow, Disposition);
    _JumpIfError(hr, error, "CoreSetDisposition");

    hr = prow->SetProperty(
		    g_wszPropRequestStatusCode,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(ErrCode),
		    (BYTE const *) &ErrCode);
    _JumpIfError(hr, error, "SetProperty(status code)");

    if (NULL != pwszDisposition)
    {
	hr = prow->SetProperty(
		    g_wszPropRequestDispositionMessage,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    MAXDWORD,
		    (BYTE const *) pwszDisposition);
	_JumpIfError(hr, error, "SetProperty(disposition message)");
    }

error:
    return(hr);
}


HRESULT
coreFindOldArchivedKey(
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;

    if (NULL != pResult->strRenewalCertHash &&
	NULL == pResult->pbArchivedKey &&
	NULL == pResult->pwszKRAHashes)
    {
	hr = g_pCertDB->OpenRow(
		    PROPOPEN_READONLY | PROPTABLE_REQCERT | PROPOPEN_CERTHASH,
		    0,	// RequestId
		    pResult->strRenewalCertHash,
		    &prow);
	_JumpIfErrorStr(hr, error, "OpenRow", pResult->strRenewalCertHash);

	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRequestRawArchivedKey,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &pResult->cbArchivedKey,
		    (BYTE **) &pResult->pbArchivedKey);
	_JumpIfError(hr, error, "PKCSGetProperty");

	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRequestKeyRecoveryHashes,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    (BYTE **) &pResult->pwszKRAHashes);
	_JumpIfError(hr, error, "PKCSGetProperty");
    }
    hr = S_OK;

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


HRESULT
coreCreateRequest(
    IN DWORD dwFlags,
    IN WCHAR const *pwszUserName,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN WCHAR const *pwszAttributes,
    IN DWORD dwComContextIndex,
    OUT ICertDBRow **pprow,		// may return non-NULL on error
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD dwRequestFlags;
    DWORD cb;
    WCHAR *pwszAttrAlloc = NULL;
    
    ICertDBRow *prow = NULL;
    
    hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, pprow);
    _JumpIfError(hr, error, "OpenRow");
    
    prow = *pprow;
    
    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestSubmittedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");
    
    hr = CoreSetDisposition(prow, DB_DISP_ACTIVE);
    _JumpIfError(hr, error, "CoreSetDisposition");
    
    hr = prow->SetProperty(
        g_wszPropRequestType,
        PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
        sizeof(dwFlags),
        (BYTE const *) &dwFlags);
    _JumpIfError(hr, error, "SetProperty(type)");
    
    if (L'\0' != *pwszUserName)
    {
        hr = prow->SetProperty(
            g_wszPropRequesterName,
            PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            MAXDWORD,
            (BYTE const *) pwszUserName);
        _JumpIfError(hr, error, "SetProperty(requester)");

        hr = prow->SetProperty(
            g_wszPropCallerName,
            PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            MAXDWORD,
            (BYTE const *) pwszUserName);
        _JumpIfError(hr, error, "SetProperty(caller)");
    }
    
    if (NULL != pwszAttributes && L'\0' != *pwszAttributes)
    {
	WCHAR const *pwszAttrSave = pwszAttributes;
        
        if (wcslen(pwszAttrSave) > CCH_DBMAXTEXT_ATTRSTRING)
        {
            DBGPRINT((
                DBG_SS_CERTSRV,
                "coreCreateRequest: truncating Attributes %u -> %u chars\n",
                wcslen(pwszAttrSave),
                CCH_DBMAXTEXT_ATTRSTRING));

	    hr = myDupString(pwszAttrSave, &pwszAttrAlloc);
	    _JumpIfError(hr, error, "myDupString");

	    pwszAttrAlloc[CCH_DBMAXTEXT_ATTRSTRING] = L'\0';
	    pwszAttrSave = pwszAttrAlloc;
        }
        hr = prow->SetProperty(
            g_wszPropRequestAttributes,
            PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            MAXDWORD,
            (BYTE const *) pwszAttrSave);
        _JumpIfError(hr, error, "SetProperty(attrib)");
    }
    
    hr = PropParseRequest(prow, dwFlags, cbRequest, pbRequest, pResult);
    _JumpIfError(hr, error, "PropParseRequest");

    hr = PKCSParseAttributes(
			prow,
			pwszAttributes,
			FALSE,
			FALSE,
			PROPTABLE_REQUEST,
			NULL);
    _JumpIfError(hr, error, "PKCSParseAttributes");

    hr = coreFindOldArchivedKey(pResult);
    _PrintIfError(hr, "coreFindOldArchivedKey");

    hr = prow->CopyRequestNames();	// after parsing request attributes!
    _JumpIfError(hr, error, "CopyRequestNames");
    
    hr = PKCSVerifyChallengeString(prow);
    _JumpIfError(hr, error, "PKCSVerifyChallengeString");

    cb = sizeof(dwRequestFlags);
    hr = prow->GetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cb,
		    (BYTE *) &dwRequestFlags);
    _JumpIfError(hr, error, "GetProperty");

    if (CR_FLG_ENROLLONBEHALFOF & dwRequestFlags)
    {
	hr = coreGetComContextUserDNFromSamName(
			    TRUE,		// fDeleteUserDNOnly
			    NULL,		// pwszSamName
			    0,			// Context
			    dwComContextIndex,
			    NULL);		// pwszDN
	_JumpIfError(hr, error, "coreGetComContextUserDNFromSamName");
    }
    hr = S_OK;
    
error:
    if (NULL != pwszAttrAlloc)
    {
	LocalFree(pwszAttrAlloc);
    }
    return(hr);
}


HRESULT
coreFetchCertificate(
    IN ICertDBRow *prow,
    OUT CERTTRANSBLOB *pctbCert)	// CoTaskMem*
{
    HRESULT hr;
    DWORD cbProp;
    
    pctbCert->pb = NULL;
    cbProp = 0;
    hr = prow->GetProperty(
        g_wszPropRawCertificate,
        PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
	NULL,
        &cbProp,
        NULL);
    _JumpIfError(hr, error, "GetProperty(raw cert size)");
    
    pctbCert->pb = (BYTE *) CoTaskMemAlloc(cbProp);
    if (NULL == pctbCert->pb)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "CoTaskMemAlloc(raw cert)");
    }
    hr = prow->GetProperty(
        g_wszPropRawCertificate,
        PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
	NULL,
        &cbProp,
        pctbCert->pb);
    _JumpIfError(hr, error, "GetProperty(raw cert)");
    
error:
    if (S_OK != hr && NULL != pctbCert->pb)
    {
        CoTaskMemFree(pctbCert->pb);
        pctbCert->pb = NULL;
    }
    pctbCert->cb = cbProp;
    return(hr);
}


HRESULT
coreRetrievePending(
    IN ICertDBRow *prow,
    IN BOOL fIncludeCRLs,
    OUT WCHAR **ppwszDisposition,		// LocalAlloc
    OUT CACTX **ppCAContext,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)	// CoTaskMem*
{
    HRESULT hr;
    DWORD cbProp;
    WCHAR *pwszDisposition = NULL;
    DWORD Disposition;
    HRESULT hrRequest;
    BOOL fIssued;

    *ppwszDisposition = NULL;
    *ppCAContext = NULL;
    cbProp = sizeof(Disposition);
    hr = prow->GetProperty(
		g_wszPropRequestDisposition,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		NULL,
		&cbProp,
		(BYTE *) &Disposition);
    _JumpIfError(hr, error, "GetProperty(disposition)");

    cbProp = sizeof(hrRequest);
    hr = prow->GetProperty(
		    g_wszPropRequestStatusCode,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cbProp,
		    (BYTE *) &hrRequest);
    _JumpIfError(hr, error, "GetProperty(status code)");

    hr = PKCSGetProperty(
		    prow,
		    g_wszPropRequestDispositionMessage,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    (BYTE **) &pwszDisposition);
    _PrintIfError2(hr, "PKCSGetProperty", CERTSRV_E_PROPERTY_EMPTY);

    fIssued = FALSE;
    switch (Disposition)
    {
	FILETIME FileTime;

	case DB_DISP_ACTIVE:
	case DB_DISP_PENDING:
	    *pResult->pdwDisposition = CR_DISP_UNDER_SUBMISSION;
	    break;

	case DB_DISP_ISSUED:
	case DB_DISP_CA_CERT:
	case DB_DISP_CA_CERT_CHAIN:
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    if (DB_DISP_CA_CERT == Disposition && IsRootCA(g_CAType))
	    {
		cbProp = sizeof(FileTime);
		hr = prow->GetProperty(
			g_wszPropRequestRevokedEffectiveWhen,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cbProp,
			(BYTE *) &FileTime);
	    }
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		*pResult->pdwDisposition = CR_DISP_ISSUED;
		fIssued = TRUE;
		break;
	    }
	    // FALLTHROUGH

	case DB_DISP_REVOKED:
	    *pResult->pdwDisposition = CR_DISP_REVOKED;
	    fIssued = TRUE;
	    break;

	case DB_DISP_ERROR:
	    *pResult->pdwDisposition = CR_DISP_ERROR;
	    break;

	case DB_DISP_DENIED:
	    *pResult->pdwDisposition = CR_DISP_DENIED;
	    if (FAILED(hrRequest))
	    {
		*pResult->pdwDisposition = hrRequest;
	    }
	    break;

	default:
	    *pResult->pdwDisposition = CR_DISP_INCOMPLETE;
	    break;
    }
    if (fIssued)
    {
	BOOL fErrorLogged = FALSE;

	hr = coreFetchCertificate(prow, pResult->pctbCert);
	_JumpIfError(hr, error, "coreFetchCertificate");

	CSASSERT(NULL != pResult->pctbCert && NULL != pResult->pctbCert->pb);
	hr = PKCSCreateCertificate(
			    prow,
			    Disposition,
			    fIncludeCRLs,
			    FALSE,	// fCrossCert
			    NULL,	// use default signing CACTX
			    &fErrorLogged,
			    ppCAContext,
			    NULL,	// ppwszDispositionCreateCert
			    pResult);

	CSASSERT(!fErrorLogged);

	if (S_OK != hr)
	{
	    if (CERTLOG_ERROR <= g_dwLogLevel)
	    {
		LogEventHResult(
			    EVENTLOG_ERROR_TYPE,
			    MSG_E_CANNOT_BUILD_CERT_OR_CHAIN,
			    hr);
	    }
	    _JumpError(hr, error, "PKCSCreateCertificate");
	}
    }
    *ppwszDisposition = pwszDisposition;
    pwszDisposition = NULL;
    hr = S_OK;

error:
    if (S_OK != hr && NULL != pResult->pctbCert->pb)
    {
        CoTaskMemFree(pResult->pctbCert->pb);
        pResult->pctbCert->pb = NULL;
    }
    if (NULL != pwszDisposition)
    {
	LocalFree(pwszDisposition);
    }
    return(hr);
}


VOID
CoreLogRequestStatus(
    IN ICertDBRow *prow,
    IN DWORD LogMsg,
    IN DWORD ErrCode,
    OPTIONAL IN WCHAR const *pwszDisposition)
{
    HRESULT hr;
    WCHAR *pwszSubject = NULL;
    WCHAR const *pwszSubject2;
    WCHAR wszRequestId[cwcDWORDSPRINTF];
    WCHAR awchr[cwcHRESULTSTRING];
    WORD cString = 0;
    WCHAR const *apwsz[4];
    DWORD ReqId;
    DWORD infotype = EVENTLOG_INFORMATION_TYPE;
    WCHAR const *pwszMessageText = NULL;
    DWORD LogMsg2;
    
    prow->GetRowId(&ReqId);
    wsprintf(wszRequestId, L"%u", ReqId);
    apwsz[cString++] = wszRequestId;

    LogMsg2 = LogMsg;
    switch (LogMsg)
    {
	case MSG_DN_CERT_ISSUED:
	    LogMsg2 = MSG_DN_CERT_ISSUED_WITH_INFO;
	    break;

	case MSG_DN_CERT_PENDING:
	    LogMsg2 = MSG_DN_CERT_PENDING_WITH_INFO;
	    break;

        case MSG_DN_CERT_ADMIN_DENIED:
            LogMsg2 = MSG_DN_CERT_ADMIN_DENIED_WITH_INFO;
            break;

	case MSG_DN_CERT_DENIED:
	    LogMsg2 = MSG_DN_CERT_DENIED_WITH_INFO;
	    infotype = EVENTLOG_WARNING_TYPE;
	    break;

	case MSG_E_PROCESS_REQUEST_FAILED:
	    LogMsg2 = MSG_E_PROCESS_REQUEST_FAILED_WITH_INFO;
	    infotype = EVENTLOG_ERROR_TYPE;
	    break;
    }
    if (EVENTLOG_INFORMATION_TYPE != infotype)
    {
	if (S_OK == ErrCode)
	{
	    ErrCode = (DWORD) SEC_E_CERT_UNKNOWN;	// unknown error
	}
	pwszMessageText = myGetErrorMessageText(ErrCode, TRUE);
	if (NULL == pwszMessageText)
	{
	    pwszMessageText = myHResultToStringRaw(awchr, ErrCode);
	}
	apwsz[cString++] = pwszMessageText;
    }
    
    hr = PKCSGetProperty(
		    prow,
		    g_wszPropSubjectDistinguishedName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    (BYTE **) &pwszSubject);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = PKCSGetProperty(
			prow,
			g_wszPropSubjectDistinguishedName,
			PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			(BYTE **) &pwszSubject);
    }
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = PKCSGetProperty(
			prow,
			g_wszPropRequesterName,
			PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			(BYTE **) &pwszSubject);
    }
    pwszSubject2 = pwszSubject;
    if (S_OK != hr)
    {
        _PrintError(hr, "GetProperty(DN/Requester)");
	pwszSubject2 = g_pwszUnknownSubject;
    }
    apwsz[cString++] = pwszSubject2;
    
    if (NULL != pwszDisposition)
    {
	LogMsg = LogMsg2;
        apwsz[cString++] = pwszDisposition;
    }
    
    if (CERTLOG_VERBOSE <= g_dwLogLevel ||
        (EVENTLOG_WARNING_TYPE == infotype && CERTLOG_WARNING <= g_dwLogLevel) ||
        (EVENTLOG_ERROR_TYPE == infotype && CERTLOG_ERROR <= g_dwLogLevel))
    {
        LogEvent(infotype, LogMsg, cString, apwsz);
    }

#if 0 == i386
# define IOBUNALIGNED(pf) ((sizeof(WCHAR) - 1) & (DWORD) (ULONG_PTR) (pf)->_ptr)
# define ALIGNIOB(pf) \
    { \
	if (IOBUNALIGNED(pf)) \
	{ \
	    fflush(pf); /* fails when running as a service */ \
	} \
	if (IOBUNALIGNED(pf)) \
	{ \
	    fprintf(pf, " "); \
	    fflush(pf); \
	} \
    }
#else
# define IOBUNALIGNED(pf) FALSE
# define ALIGNIOB(pf)
#endif

    {
	BOOL fRetried = FALSE;
	
	for (;;)
	{
	    ALIGNIOB(stdout);
	    __try
	    {
		wprintf(
		    // L"\nCertSrv Request %u: rc=%x: %ws: %ws '%ws'\n"
		    g_pwszPrintfCertRequestDisposition,
		    ReqId,
		    ErrCode,
		    NULL != pwszMessageText? pwszMessageText : L"",
		    NULL != pwszDisposition? pwszDisposition : L"",
		    pwszSubject);
		hr = S_OK;
	    }
	    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	    {
	    }
#pragma warning(push)
#pragma warning(disable: 4127)	// conditional expression is constant
	    if (S_OK == hr || fRetried || !IOBUNALIGNED(stdout))
#pragma warning(pop)
	    {
		break;
	    }
	    ALIGNIOB(stdout);
	    fRetried = TRUE;
	}
    }
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
}


WCHAR *
CoreBuildDispositionString(
    OPTIONAL IN WCHAR const *pwszDispositionBase,
    OPTIONAL IN WCHAR const *pwszUserName,
    OPTIONAL IN WCHAR const *pwszDispositionDetail,
    OPTIONAL IN WCHAR const *pwszDispositionDetail2,
    OPTIONAL IN WCHAR const *pwszBy,
    IN HRESULT hrFail,
    IN BOOL fPublishError)
{
    DWORD cwc = 0;
    WCHAR *pwsz = NULL;
    WCHAR const *pwszMessageText = NULL;
    WCHAR awchr[cwcHRESULTSTRING];

    if (NULL == pwszUserName)
    {
	pwszUserName = L"";
    }
    if (NULL != pwszDispositionBase)
    {
	cwc += wcslen(pwszDispositionBase) + wcslen(pwszUserName);
    }
    if (NULL != pwszDispositionDetail)
    {
	if (0 != cwc)
	{
	    cwc += 2;  // spaces
	}
	cwc += wcslen(pwszDispositionDetail);
    }
    if (NULL != pwszDispositionDetail2)
    {
	if (0 != cwc)
	{
	    cwc += 2;  // spaces
	}
	cwc += wcslen(pwszDispositionDetail2);
    }
    if (NULL != pwszBy)
    {
	if (0 != cwc)
	{
	    cwc += 2;  // spaces
	}
	cwc += wcslen(pwszBy) + wcslen(pwszUserName);
    }
    if (S_OK != hrFail)
    {
	pwszMessageText = myGetErrorMessageText(hrFail, TRUE);
	if (NULL == pwszMessageText)
	{
	    pwszMessageText = myHResultToStringRaw(awchr, hrFail);
	}
	if (0 != cwc)
	{
	    cwc += 2;  // spaces
	}
	if (fPublishError)
	{
	    cwc += wcslen(g_pwszPublishError);
	    cwc += 2;  // spaces
	}
	cwc += wcslen(pwszMessageText);
    }
    if (0 != cwc)
    {
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL != pwsz)
	{
	    pwsz[0] = L'\0';
	    if (NULL != pwszDispositionBase)
	    {
		wsprintf(pwsz, pwszDispositionBase, pwszUserName);
	    }
	    if (NULL != pwszDispositionDetail)
	    {
		if (L'\0' != pwsz[0])
		{
		    wcscat(pwsz, L"  ");
		}
		wcscat(pwsz, pwszDispositionDetail);
	    }
	    if (NULL != pwszDispositionDetail2)
	    {
		if (L'\0' != pwsz[0])
		{
		    wcscat(pwsz, L"  ");
		}
		wcscat(pwsz, pwszDispositionDetail2);
	    }
	    if (NULL != pwszBy)
	    {
		if (L'\0' != pwsz[0])
		{
		    wcscat(pwsz, L"  ");
		}
		wsprintf(&pwsz[wcslen(pwsz)], pwszBy, pwszUserName);
	    }
	    if (S_OK != hrFail)
	    {
		if (L'\0' != pwsz[0] && L'\n' != pwsz[wcslen(pwsz) - 1])
		{
		    wcscat(pwsz, L"  ");
		}
		if (fPublishError)
		{
		    wcscat(pwsz, g_pwszPublishError);
		    wcscat(pwsz, L"  ");
		}
		wcscat(pwsz, pwszMessageText);
	    }
	}
	CSASSERT(wcslen(pwsz) <= cwc);
    }

//error:
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
    return(pwsz);
}


VOID
coreLogPublishError(
    IN DWORD RequestId,
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN BOOL fDelete,
    OPTIONAL IN WCHAR const *pwszError,
    IN HRESULT hrPublish)
{
    HRESULT hr;
    WCHAR const *apwsz[6];
    WORD cpwsz;
    WCHAR wszRequestId[cwcDWORDSPRINTF];
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszMessageText = NULL;
    WCHAR *pwszHostName = NULL;
    DWORD LogMsg;

    wsprintf(wszRequestId, L"%u", RequestId);
    if (NULL != pld)
    {
	myLdapGetDSHostName(pld, &pwszHostName);
    }
    pwszMessageText = myGetErrorMessageText(hrPublish, TRUE);
    if (NULL == pwszMessageText)
    {
	pwszMessageText = myHResultToStringRaw(awchr, hrPublish);
    }
    cpwsz = 0;
    apwsz[cpwsz++] = wszRequestId;
    apwsz[cpwsz++] = pwszDN;
    apwsz[cpwsz++] = pwszMessageText;

    LogMsg = fDelete? MSG_E_CERT_DELETION : MSG_E_CERT_PUBLICATION; 
    if (NULL != pwszHostName)
    {
	LogMsg = fDelete?
	    MSG_E_CERT_DELETION_HOST_NAME : MSG_E_CERT_PUBLICATION_HOST_NAME; 
    }
    else
    {
	pwszHostName = L"";
    }
    apwsz[cpwsz++] = pwszHostName;
    apwsz[cpwsz++] = NULL != pwszError? L"\n" : L"";
    apwsz[cpwsz++] = NULL != pwszError? pwszError : L"";
    CSASSERT(ARRAYSIZE(apwsz) >= cpwsz);

    if (CERTLOG_WARNING <= g_dwLogLevel)
    {
	hr = LogEvent(EVENTLOG_WARNING_TYPE, LogMsg, cpwsz, apwsz);
	_PrintIfError(hr, "LogEvent");
    }

//error:
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
}


HRESULT
corePublishKRACertificate(
    IN DWORD RequestId,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    LDAP *pld = NULL;
    HCERTSTORE hStore = NULL;
    DWORD dwDisposition;
    WCHAR *pwszError = NULL;

    hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
    _JumpIfError(hr, error, "myRobustLdapBindEx");

    hStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE,
			wszKRA_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CertOpenStore", wszKRA_CERTSTORE);
    }

    // It's a new cert.  CERT_STORE_ADD_ALWAYS is faster.

    if (!CertAddCertificateContextToStore(
				    hStore,
				    pcc,
				    CERT_STORE_ADD_ALWAYS,
				    NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }

    hr = myLdapPublishCertToDS(
			pld,
			pcc,
			g_pwszKRAPublishURL,
			wszDSKRACERTATTRIBUTE,
			LPC_KRAOBJECT,
			FALSE,		// fDelete
			&dwDisposition,
			&pwszError);
    _JumpIfError(hr, error, "myLdapPublishCertToDS");

error:
    if (S_OK != hr)
    {
	coreLogPublishError(
			RequestId,
			pld,
			g_pwszKRAPublishURL,
			FALSE,		// fDelete
			pwszError,
			hr);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
    return(hr);
}


HRESULT
CorePublishCrossCertificate(
    IN DWORD RequestId,
    IN CERT_CONTEXT const *pcc,
    IN BOOL fCreateDSObject,
    IN BOOL fDelete)
{
    HRESULT hr;
    LDAP *pld = NULL;
    DWORD dwDisposition;
    WCHAR *pwszError = NULL;
    CAutoLPWSTR pwszCN;
    CAutoLPWSTR pwszSanitizedCN;
    CAutoLPWSTR pwszDSSanitizedCN;
    CAutoLPWSTR pwszDN;
    CAutoLPWSTR pwszSubject;
    WCHAR const *pwszFormatDN = L"ldap:///CN=%ws%ws";
    WCHAR *pwcRelDN;

    hr = myGetCommonName(&pcc->pCertInfo->Subject, TRUE, &pwszCN);
    _JumpIfError(hr, error, "myGetCommonName");

    hr = mySanitizeName(pwszCN, &pwszSanitizedCN);
    _JumpIfError(hr, error, "mySanitizeName");

    hr = mySanitizedNameToDSName(pwszSanitizedCN, &pwszDSSanitizedCN);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    if (NULL == g_pwszAIACrossCertPublishURL)
    {
	// Actually, something went wrong with pkcsExpandURL!
	
	hr = ERROR_DS_INVALID_DN_SYNTAX;
	_JumpError(hr, error, "g_pwszAIACrossCertPublishURL");
    }
    pwcRelDN = wcschr(g_pwszAIACrossCertPublishURL, L',');
    if (NULL == pwcRelDN)
    {
	// Actually, something went wrong with pkcsExpandURL!
	
	hr = ERROR_DS_INVALID_DN_SYNTAX;
	_JumpError(hr, error, "g_pwszAIACrossCertPublishURL");
    }
    pwszDN = (WCHAR *) LocalAlloc(
			    LMEM_FIXED, 
			    (wcslen(pwszFormatDN) +
			     wcslen(pwszDSSanitizedCN) +
			     wcslen(pwcRelDN)) * sizeof(WCHAR));
    if (pwszDN == NULL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wsprintf(pwszDN, pwszFormatDN, pwszDSSanitizedCN, pwcRelDN);

    hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
    _JumpIfError(hr, error, "myRobustLdapBindEx");

    hr = myLdapPublishCertToDS(
			pld,
			pcc,
			pwszDN,
			wszDSCROSSCERTPAIRATTRIBUTE,
			LPC_CAOBJECT | (fCreateDSObject? LPC_CREATEOBJECT : 0),
			fDelete,
			&dwDisposition,
			&pwszError);
    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "myLdapPublishCertToDS", pwszDN);
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
	    IsRootCA(g_CAType))
	{
	    if (NULL != pwszError)
	    {
		LocalFree(pwszError);
		pwszError = NULL;
	    }
	    hr = S_OK;
	}
    }
    _JumpIfErrorStr(hr, error, "myLdapPublishCertToDS", pwszDN);

    if (!fDelete)
    {
	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    &pcc->pCertInfo->Subject,
		    CERT_X500_NAME_STR, //| CERT_NAME_STR_REVERSE_FLAG,
		    &pwszSubject);
	_JumpIfError(hr, error, "myCertNameToStr");

	hr = myLDAPSetStringAttribute(
		    pld,
		    pwszDN,
		    CA_PROP_CERT_DN,
		    pwszSubject,
		    &dwDisposition, 
		    &pwszError);
	_JumpIfErrorStr(hr, error, "myLDAPSetStringAttribute", pwszDN);
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	coreLogPublishError(RequestId, pld, pwszDN, fDelete, pwszError, hr);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
    return(hr);
}


#define wszCONTACTFILTER	L"(&(&(objectCategory=contact)(objectClass=contact))(mail=%s))"

HRESULT
coreGetDNFromEMailName(
    IN LDAP *pld,
    IN WCHAR const *pwszEMailName,
    OUT WCHAR **ppwszDN,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cres;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *apwszAttrs[2];
    WCHAR **ppwszValues = NULL;
    CAutoLPWSTR pwszFilter;
    CAutoBSTR strDomainDN;

    pwszFilter = (LPWSTR) LocalAlloc(LMEM_FIXED, 
        sizeof(WCHAR)*(wcslen(wszCONTACTFILTER)+wcslen(pwszEMailName)));
    _JumpIfAllocFailed(pwszFilter, error);

    wsprintf(pwszFilter, wszCONTACTFILTER, pwszEMailName);

    hr = myGetAuthoritativeDomainDn(pld, &strDomainDN, NULL);
    _JumpIfError(hr, error, "myGetAuthoritativeDomainDn");

    *ppwszDN = NULL;
    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    apwszAttrs[0] = wszDSDNATTRIBUTE;
    apwszAttrs[1] = NULL;

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
        pld,                // ld
        strDomainDN,        // base
        LDAP_SCOPE_SUBTREE, // scope
        pwszFilter,         // filter
        apwszAttrs,         // attrs
        FALSE,              // attrsonly
        &timeval,           // timeout
        &pmsg);             // res
    if (S_OK != hr)
    {
	*pdwDisposition = hr;
	hr = myHLdapError(pld, hr, ppwszError);
	_JumpErrorStr(hr, error, "ldap_search_st", pwszFilter);
    }
    hr = HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND);
    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
	_JumpError(hr, error, "ldap_count_entries");
    }
    pres = ldap_first_entry(pld, pmsg); 
    if (NULL == pres)
    {
	_JumpError(hr, error, "ldap_first_entry");
    }
    ppwszValues = ldap_get_values(pld, pres, wszDSDNATTRIBUTE);
    if (NULL == ppwszValues || NULL == ppwszValues[0])
    {
	_JumpError(hr, error, "ldap_get_values");
    }
    hr = myDupString(ppwszValues[0], ppwszDN);
    _JumpIfError(hr, error, "myDupString");

    *pdwDisposition = LDAP_SUCCESS;

error:
    if (NULL != ppwszValues)
    {
	ldap_value_free(ppwszValues);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


HRESULT
coreGetEMailNameFromDN(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OUT WCHAR **ppwszEMailName,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cres;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *apwszAttrs[2];
    WCHAR **ppwszValues = NULL;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    apwszAttrs[0] = wszDSMAILATTRIBUTE;
    apwszAttrs[1] = NULL;

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszDN),	// base
		LDAP_SCOPE_BASE,		// scope
		NULL,				// filter
		apwszAttrs,			// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	*pdwDisposition = hr;
	hr = myHLdapError(pld, hr, ppwszError);
	_JumpErrorStr(hr, error, "ldap_search_st", pwszDN);
    }
    hr = CERTSRV_E_PROPERTY_EMPTY;
    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
	_JumpError(hr, error, "ldap_count_entries");
    }
    pres = ldap_first_entry(pld, pmsg); 
    if (NULL == pres)
    {
	_JumpError(hr, error, "ldap_first_entry");
    }
    ppwszValues = ldap_get_values(pld, pres, wszDSMAILATTRIBUTE);
    if (NULL == ppwszValues || NULL == ppwszValues[0])
    {
	_JumpError(hr, error, "ldap_get_values");
    }
    hr = myDupString(ppwszValues[0], ppwszEMailName);
    _JumpIfError(hr, error, "myDupString");

    *pdwDisposition = LDAP_SUCCESS;

error:
    if (NULL != ppwszValues)
    {
	ldap_value_free(ppwszValues);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


HRESULT
corePublishCertToForest(
    IN DWORD iForest,
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszDomainDns,	// NULL for 0 < iForest
    OPTIONAL IN WCHAR const *pwszDN,		// NULL for 0 < iForest
    OPTIONAL IN WCHAR const *pwszEMailName,	// NULL for 0 == iForest
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwObjectType,	// LPC_*
    OPTIONAL OUT WCHAR **ppwszEMailName)	// NULL for 0 < iForest
{
    HRESULT hr;
    LDAPCACHE *plc = NULL;
    DWORD dwDisposition;
    WCHAR *pwszContactDN = NULL;
    WCHAR *pwszError = NULL;
    
    if (NULL != ppwszEMailName)
    {
	*ppwszEMailName = NULL;
    }
    hr = S_OK;
    __try
    {
	for (;;)
	{
	    BOOL fCached;

	    if (NULL != pwszError)
	    {
		LocalFree(pwszError);
		pwszError = NULL;
	    }
	    if (NULL != plc)
	    {
		coreLdapUnbind(plc);
		plc = NULL;
		//coreLdapEmptyCache(iForest);
	    }
	    hr = coreLdapGetHandle(iForest, pwszDomainDns, &plc, &fCached); 
	    _LeaveIfError(hr, "coreLdapGetHandle");

	    if (NULL != pwszEMailName)
	    {
		CSASSERT(NULL == pwszDN);
		hr = coreGetDNFromEMailName(
					plc->pld,
					pwszEMailName,
					&pwszContactDN,
					&dwDisposition,
					&pwszError);
		_PrintIfErrorStr(
			    hr,
			    fCached?
				"coreGetDNFromEMailName(cached)" :
				"coreGetDNFromEMailName(noncached)",
			    pwszDN);
		if (!fCached ||
		    !myLdapRebindRequired(dwDisposition, plc->pld))
		{
		    _LeaveIfError(hr, "myLdapPublishCertToDS");
		}
		
		if (S_OK == hr)
		{
		    pwszDN = pwszContactDN;
		}
	    }

	    hr = myLdapPublishCertToDS(
				plc->pld,
				pcc,
				pwszDN,
				wszDSUSERCERTATTRIBUTE,
				dwObjectType,	// LPC_*
				FALSE,		// fDelete
				&dwDisposition,
				&pwszError);
	    if (S_OK == hr)
	    {
		break;
	    }
	    _PrintErrorStr(
			hr,
			fCached?
			    "myLdapPublishCertToDS(cached)" :
			    "myLdapPublishCertToDS(noncached)",
			pwszDN);
	    if (!fCached ||
		!myLdapRebindRequired(dwDisposition, plc->pld))
	    {
		_LeaveError(hr, "myLdapPublishCertToDS");
	    }
	}
	if (NULL != ppwszEMailName)
	{
	    hr = coreGetEMailNameFromDN(
				plc->pld,
				pwszDN,
				ppwszEMailName,
				&dwDisposition,
				&pwszError);
	    _PrintIfErrorStr(hr, "coreGetEMailNameFromDN", pwszDN);
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

//error:
    if (S_OK != hr)
    {
	coreLogPublishError(
			RequestId,
			NULL != plc? plc->pld : NULL,
			pwszDN,
			FALSE,		// fDelete
			pwszError,
			hr);
    }
    if (NULL != plc)
    {
	coreLdapReleaseHandle(iForest, plc);
    }
    if (NULL != pwszContactDN)
    {
	LocalFree(pwszContactDN);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    return(hr);
}


HRESULT
coreGetDomainDnsNameFromDN(
    IN WCHAR const *pwszDN,
    OUT WCHAR **ppwszDomainDns)
{
    HRESULT hr;
    DS_NAME_RESULT *pNameResults = NULL;
    WCHAR const *pwc;
    DWORD cwc;

    CSASSERT(NULL != ppwszDomainDns);
    *ppwszDomainDns = NULL;

    hr = DsCrackNames(
		NULL,			// hDS
		DS_NAME_FLAG_SYNTACTICAL_ONLY,
		DS_FQDN_1779_NAME,
		DS_CANONICAL_NAME,
		1,			// one name
		&pwszDN,		// one name (IN)
		&pNameResults);		// OUT
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "DsCrackNames");
    }
    if (1 > pNameResults->cItems ||
	DS_NAME_NO_ERROR != pNameResults->rItems[0].status)
    {
	hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	_JumpError(hr, error, "DsCrackNames result");
    }
    pwc = wcschr(pNameResults->rItems[0].pName, L'/');
    if (NULL == pwc)
    {
	cwc = wcslen(pNameResults->rItems[0].pName);
    }
    else
    {
	cwc = SAFE_SUBTRACT_POINTERS(pwc, pNameResults->rItems[0].pName);
    }
    *ppwszDomainDns = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (NULL == *ppwszDomainDns)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(
	    *ppwszDomainDns,
	    pNameResults->rItems[0].pName,
	    cwc * sizeof(WCHAR));
    (*ppwszDomainDns)[cwc] = L'\0';

error:
    if (NULL != pNameResults)
    {
	DsFreeNameResult(pNameResults);
    }
    return(hr);
}


HRESULT
corePublishUserCertificate(
    IN DWORD RequestId,
    IN DWORD dwComContextIndex,
    IN WCHAR const *pwszSamName,
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwObjectType)	// LPC_*
{
    HRESULT hr;
    WCHAR *pwszSamNamePatched = NULL;
    WCHAR *pwszDomainDns = NULL;
    WCHAR const *pwszUserName;
    WCHAR const *pwszDN;
    WCHAR *pwszEMailName = NULL;
    DWORD i;

    hr = myAddDomainName(pwszSamName, &pwszSamNamePatched, &pwszUserName);
    _JumpIfError(hr, error, "myAddDomainName");

    if (NULL != pwszSamNamePatched)
    {
	pwszSamName = pwszSamNamePatched;
    }
    hr = coreGetComContextUserDNFromSamName(
			FALSE,		// fDeleteUserDNOnly
			pwszSamName,
			0,			// Context
			dwComContextIndex,
			&pwszDN);
    _JumpIfError(hr, error, "coreGetComContextUserDNFromSamName");

    hr = coreGetDomainDnsNameFromDN(pwszDN, &pwszDomainDns);
    _JumpIfError(hr, error, "coreGetDomainDnsNameFromDN");

    // For the domestic forest, pass the User object's native domain and DN,
    // and collect the EMail name (if any alternate forests were specified).

    hr = corePublishCertToForest(
			    0,			// iForest
			    RequestId,
			    pwszDomainDns,
			    pwszDN,
			    NULL,		// pwszEMailName
			    pcc,
			    dwObjectType,	// LPC_*
			    1 < g_cForestLdapCache? &pwszEMailName : NULL);
    _PrintIfError(hr, "corePublishCertToForest");

    // For alternate forests, pass a NULL domain, the Contact object's EMail
    // name, and do not collect the EMail name.
	
    for (i = 1; i < g_cForestLdapCache; i++)
    {
	if (NULL == pwszEMailName)
	{
	    break;	// EMail name needed to publish to alternate Forests
	}
	hr = corePublishCertToForest(
				i,		// iForest
				RequestId,
				NULL,		// pwszDomainDns
				NULL,		// pwszDN
				pwszEMailName,
				pcc,
				dwObjectType,	// LPC_*
				NULL);		// ppwszEMailName
	_PrintIfError(hr, "corePublishCertToForest");
    }

error:
    if (NULL != pwszEMailName)
    {
        LocalFree(pwszEMailName);
    }
    if (NULL != pwszDomainDns)
    {
        LocalFree(pwszDomainDns);
    }
    if (NULL != pwszSamNamePatched)
    {
	LocalFree(pwszSamNamePatched);
    }
    return(hr);
}


HRESULT
CorePublishCertificate(
    IN ICertDBRow *prow,
    IN DWORD dwComContextIndex)
{
    HRESULT hr;
    DWORD cbProp;
    DWORD RequestId;
    DWORD GeneralFlags;
    DWORD EnrollmentFlags;
    DWORD cbCert;
    BYTE *pbCert = NULL;
    CERT_CONTEXT const *pcc = NULL;
    WCHAR *pwszSamName = NULL;
    
    prow->GetRowId(&RequestId);

    cbProp = sizeof(EnrollmentFlags);
    hr = prow->GetProperty(
		    wszPROPCERTIFICATEENROLLMENTFLAGS,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    &cbProp,
		    (BYTE *) &EnrollmentFlags);
    _PrintIfError2(hr, "GetProperty", CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK != hr)
    {
	EnrollmentFlags = 0;
    }

    if (0 == ((CT_FLAG_PUBLISH_TO_DS | CT_FLAG_PUBLISH_TO_KRA_CONTAINER) &
							    EnrollmentFlags))
    {
	hr = S_OK;
	goto error;
    }

    cbProp = sizeof(GeneralFlags);
    hr = prow->GetProperty(
		    wszPROPCERTIFICATEGENERALFLAGS,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    &cbProp,
		    (BYTE *) &GeneralFlags);
    _PrintIfError2(hr, "GetProperty", CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK != hr)
    {
	GeneralFlags = 0;
    }

    // Get the name of the user or machine

    hr = PKCSGetProperty(
		    prow,
		    g_wszPropRequesterName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    (BYTE **) &pwszSamName);
    _JumpIfError(hr, error, "PKCSGetProperty");

    hr = PKCSGetProperty(
		prow, 
		g_wszPropRawCertificate,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbCert,
		&pbCert);
    _JumpIfError(hr, error, "PKCSGetProperty(raw cert)");

    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    hr = S_OK;
    if (CT_FLAG_PUBLISH_TO_DS & EnrollmentFlags)
    {
	if (CT_FLAG_IS_CROSS_CA & GeneralFlags)
	{
	    hr = CorePublishCrossCertificate(
					RequestId,
					pcc,
					TRUE,	// fCreateDSObject
					FALSE);	// fDelete
	    _PrintIfError(hr, "CorePublishCrossCertificate"); // DS object if necessary
	}
	else
	{
	    hr = corePublishUserCertificate(
				    RequestId,
				    dwComContextIndex,
				    pwszSamName,
				    pcc,
				    (CT_FLAG_MACHINE_TYPE & GeneralFlags)?
					LPC_MACHINEOBJECT : LPC_USEROBJECT);
	    _PrintIfError(hr, "corePublishUserCertificate");
	}
    }

    if (CT_FLAG_PUBLISH_TO_KRA_CONTAINER & EnrollmentFlags)
    {
	HRESULT hr2;
	
	hr2 = corePublishKRACertificate(RequestId, pcc);
	_PrintIfError(hr2, "corePublishKRACertificate");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    _JumpIfError(hr, error, "CorePublishCertificate");

error:
    if (NULL != pwszSamName)
    {
	LocalFree(pwszSamName);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    return(hr);
}


HRESULT
coreAcceptRequest(
    IN ICertDBRow *prow,
    IN BOOL fIncludeCRLs,
    IN DWORD dwComContextIndex,
    OUT BOOL *pfErrorLogged,
    OUT CACTX **ppCAContext,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult,	// CoTaskMem*
    OUT WCHAR **ppwszDispositionCreateCert,
    OUT HRESULT *phrPublish)
{
    HRESULT hr;

    *ppCAContext = NULL;
    *ppwszDispositionCreateCert = NULL;
    *phrPublish = S_OK;

    // Force Cert creation:
    CSASSERT(NULL == pResult->pctbCert || NULL == pResult->pctbCert->pb);

    hr = CoreValidateRequestId(prow, DB_DISP_ACTIVE);
    _JumpIfError(hr, error, "CoreValidateRequestId");

    hr = PKCSCreateCertificate(
			prow,
			DB_DISP_ACTIVE,
			fIncludeCRLs,
			FALSE,		// fAllowCASubject
			NULL,		// use default signing CACTX
			pfErrorLogged,
			ppCAContext,
			ppwszDispositionCreateCert,
			pResult);
    _JumpIfError(hr, error, "PKCSCreateCertificate");

    *phrPublish = CorePublishCertificate(prow, dwComContextIndex);
    _PrintIfError(*phrPublish, "CorePublishCertificate");
    if (S_OK != *phrPublish)
    {
	hr = PKCSSetRequestFlags(prow, TRUE, CR_FLG_PUBLISHERROR);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


HRESULT
coreVerifyRequest(
    IN OUT ICertDBRow **pprow,
    IN DWORD OpRequest,
    IN BOOL fIncludeCRLs,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN DWORD dwComContextIndex,
    OUT DWORD *pReqId,
    OUT LONG *pExitEvent,
    OUT WCHAR **ppwszDisposition,		// LocalAlloc
    OUT CACTX **ppCAContext,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)	// CoTaskMem*
{
    HRESULT hr;
    HRESULT hr2;
    HRESULT hrRequest = S_OK;
    HRESULT hrPublish = S_OK;
    DWORD VerifyStatus;
    DWORD DBDisposition;
    BOOL fResolved;
    LONG ExitEvent;
    BOOL fPending;
    BOOL fSubmit;
    BOOL fRetrieve;
    BOOL fDenied;
    BOOL fUpdateDisposition = FALSE;
    WCHAR *pwszDispositionCreateCert = NULL;

    WCHAR *pwszDispositionRetrieved = NULL;
    WCHAR const *pwszDispositionBase = NULL;
    WCHAR *pwszDispositionDetail = NULL;
    WCHAR *pwszDisposition = NULL;
    WCHAR const *pwszBy = NULL;

    DWORD LogMsg = MSG_E_PROCESS_REQUEST_FAILED;
    BOOL fErrorLogged = FALSE;
    DWORD ReqId;
    ICertDBRow *prow = *pprow;
    
    prow->GetRowId(&ReqId);
    
    *ppCAContext = NULL;
    *pResult->pdwDisposition = CR_DISP_ERROR;
    DBDisposition = DB_DISP_ERROR;
    *ppwszDisposition = NULL;
    
    ExitEvent = EXITEVENT_INVALID;
    
    fSubmit = CR_IN_NEW == OpRequest || CR_IN_RESUBMIT == OpRequest;
    fPending = CR_IN_DENY == OpRequest || CR_IN_RESUBMIT == OpRequest;
    fRetrieve = CR_IN_RETRIEVE == OpRequest;
    
#if DBG_COMTEST
    if (fSubmit && fComTest && !ComTest((LONG) ReqId))
    {
        _PrintError(0, "ComTest");
    }
#endif

    if (fRetrieve)
    {
        hr = coreCheckRetrieveAccessRight(
            prow,
            pwszUserName);
        _JumpIfError(hr, error, "coreCheckRetrieveAccessRight");

        hr = coreRetrievePending(
			    prow,
			    fIncludeCRLs,
			    &pwszDispositionRetrieved,
			    ppCAContext,
			    pResult);	// CoTaskMem*
	_JumpIfError(hr, error, "coreRetrievePending");

	pwszDispositionBase = pwszDispositionRetrieved;
        ExitEvent = EXITEVENT_CERTRETRIEVEPENDING;
    }
    else
    {
        // If the current status is expected to be pending, verify that now,
        // and make the request active.
	//
	// If it was already marked active, then something went wrong last time
	// we processed the request (out of disk space?), and we can try to
	// pick up where we left off, by resubmitting or denying the request.

        if (fPending)
        {
            hr = CoreValidateRequestId(prow, DB_DISP_PENDING);
	    if (CERTSRV_E_BAD_REQUESTSTATUS == hr)
	    {
		hr = CoreValidateRequestId(prow, DB_DISP_ACTIVE);
	    }
	    if (CERTSRV_E_BAD_REQUESTSTATUS == hr && fSubmit)
	    {
		hr = CoreValidateRequestId(prow, DB_DISP_DENIED);
		if (S_OK == hr)
		{
		    DBGPRINT((
			DBG_SS_CERTSRV,
			"Resubmit failed request %u\n",
			ReqId));
		    pResult->dwResultFlags |= CRCF_PREVIOUSLYDENIED;
		    if (CRCF_FAILDENIEDREQUEST & pResult->dwResultFlags)
		    {
			hr = CERTSRV_E_BAD_REQUESTSTATUS;
		    }
		}
	    }
            _JumpIfError(hr, error, "CoreValidateRequestId");

            hr = CoreSetDisposition(prow, DB_DISP_ACTIVE);
            _JumpIfError(hr, error, "CoreSetDisposition");
        }
        fUpdateDisposition = TRUE;
        if (fSubmit)
        {
	    if (fPending)
	    {
		pwszBy = g_pwszResubmittedBy;

		hr = PKCSSetServerProperties(
				prow,
				NULL,		// use default signing CACTX
				NULL,		// pftNotBefore
				NULL,		// pftNotAfter
				g_lValidityPeriodCount,
				g_enumValidityPeriod);
		_JumpIfError(hr, error, "PKCSSetServerProperties");
	    }

            hr = prow->CommitTransaction(TRUE);
            _JumpIfError(hr, error, "CommitTransaction");

            prow->Release();
            prow = NULL;
            *pprow = NULL;

            hr = PolicyVerifyRequest(
			g_wszCommonName,
			ReqId,
			g_PolicyFlags,
			CR_IN_NEW == OpRequest,
			CR_IN_NEW == OpRequest? pResult : NULL,
			dwComContextIndex,
			&pwszDispositionDetail, 
			&VerifyStatus);
	    if (S_OK != hr)
	    {
		_PrintError(hr, "PolicyVerifyRequest");
		if (SUCCEEDED(hr))
		{
		    if (S_FALSE == hr)
		    {
			hr = E_UNEXPECTED;
		    }
		    else
		    {
			hr = myHError(hr);
		    }
		}
		VerifyStatus = hr;
	    }

            hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, ReqId, NULL, &prow);
	    _JumpIfError(hr, error, "OpenRow");

	    CSASSERT(NULL != prow);
            *pprow = prow;
        }
        else	// else we're denying the request!
        {
            VerifyStatus = VR_INSTANT_BAD;
        }

        fResolved = FALSE;
        fDenied = FALSE;
        switch (VerifyStatus)
        {
            case VR_PENDING:
		hr = S_OK;
		DBDisposition = DB_DISP_PENDING;
		ExitEvent = EXITEVENT_CERTPENDING;
		LogMsg = MSG_DN_CERT_PENDING;
		*pResult->pdwDisposition = CR_DISP_UNDER_SUBMISSION;
		pwszDispositionBase = g_pwszUnderSubmission;
		break;

            case VR_INSTANT_OK:
		hr = coreAcceptRequest(
				prow,
				fIncludeCRLs,
				dwComContextIndex,
				&fErrorLogged,
				ppCAContext,
				pResult,
				&pwszDispositionCreateCert,
				&hrPublish);
		if (S_OK != hr)
		{
	            CSASSERT(FAILED(hr));
	            _PrintError(hr, "coreAcceptRequest");
	            pwszDispositionBase = g_pwszCertConstructionError;
	            VerifyStatus = hr;
	            hr = S_OK;
	            fDenied = TRUE;
		}
		else
		{
	            fResolved = TRUE;
	            DBDisposition = DB_DISP_ISSUED;
	            ExitEvent = EXITEVENT_CERTISSUED;
	            LogMsg = MSG_DN_CERT_ISSUED;
	            *pResult->pdwDisposition = CR_DISP_ISSUED;
	            pwszDispositionBase = g_pwszIssued;
		}
		break;

            default:
		if (SUCCEEDED(VerifyStatus))
		{
		    CSASSERT(
			VerifyStatus == VR_PENDING ||
			VerifyStatus == VR_INSTANT_OK ||
			VerifyStatus == VR_INSTANT_BAD);
		    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    _JumpError(hr, error, "VerifyStatus");
		}
		// FALLTHROUGH

            case VR_INSTANT_BAD:
		hr = CoreValidateRequestId(prow, DB_DISP_ACTIVE);
		_JumpIfError(hr, error, "CoreValidateRequestId");

		fDenied = TRUE;
		break;
        }
        if (fDenied)
        {
            fResolved = TRUE;
            DBDisposition = DB_DISP_DENIED;
            ExitEvent = EXITEVENT_CERTDENIED;

            *pResult->pdwDisposition = CR_DISP_DENIED;
            if (FAILED(VerifyStatus))
            {
                *pResult->pdwDisposition = VerifyStatus;
                hrRequest = VerifyStatus;
            }

            if (fSubmit)
            {
	        if (NULL == pwszDispositionBase)
		{
		    pwszDispositionBase = g_pwszPolicyDeniedRequest;
		}
                LogMsg = MSG_DN_CERT_DENIED;
            }
            else
            {
	        pwszDispositionBase = g_pwszDeniedBy;
                LogMsg = MSG_DN_CERT_ADMIN_DENIED;
            }
        }
        if (fResolved)
        {
            hr = PropSetRequestTimeProperty(prow, g_wszPropRequestResolvedWhen);
            _JumpIfError(hr, error, "PropSetRequestTimeProperty");
        }
    }
    
error:
    *pReqId = ReqId;
    *pExitEvent = ExitEvent;
    
    // If we verified or denied the request, set the status & disposition

    // Build the full disposition string

    pwszDisposition = CoreBuildDispositionString(
				    pwszDispositionBase,
				    pwszUserName,
				    pwszDispositionDetail,
				    pwszDispositionCreateCert,
				    pwszBy,
				    hrPublish,
				    TRUE);

    if (NULL != pwszDispositionDetail)
    {
        LocalFree(pwszDispositionDetail);
    }

    if (S_OK == hrRequest && S_OK != hr)
    {
	hrRequest = hr;
    }
    if (fUpdateDisposition && NULL != prow)
    {
        hr2 = CoreSetRequestDispositionFields(
				    prow,
				    hrRequest,
				    DBDisposition,
				    pwszDisposition);
        if (S_OK == hr)
        {
            hr = hr2;
        }
    }

    if (!fErrorLogged &&
         NULL != prow &&
        (fUpdateDisposition || S_OK != hr))
    {
        CoreLogRequestStatus(prow, LogMsg, hrRequest, pwszDisposition);
    }

    if (NULL != ppwszDisposition)
    {
        *ppwszDisposition = pwszDisposition;
    }
    else if (NULL != pwszDisposition)
    {
        LocalFree(pwszDisposition);
    }
    if (NULL != pwszDispositionRetrieved)
    {
        LocalFree(pwszDispositionRetrieved);
    }
    if (NULL != pwszDispositionCreateCert)
    {
        LocalFree(pwszDispositionCreateCert);
    }
    return(hr);
}


HRESULT
coreAuditAddStringProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    IN CertSrv::CAuditEvent *pevent)
{
    HRESULT hr;
    WCHAR const *pwszLogValue = L"";
    WCHAR *pwszPropValue = NULL;

    hr = PKCSGetProperty(
		prow, 
		pwszPropName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		NULL,
		(BYTE **) &pwszPropValue);
    _PrintIfErrorStr2(hr, "PKCSGetProperty", pwszPropName, CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK == hr)
    {
	pwszLogValue = pwszPropValue;
    }
    hr = pevent->AddData(pwszLogValue);
    _JumpIfError(hr, error, "CAuditEvent::AddData");

error:
    if (NULL != pwszPropValue)
    {
	LocalFree(pwszPropValue);
    }
    return(hr);
}

    
HRESULT
coreAuditRequestDisposition(
    OPTIONAL IN ICertDBRow *prow,
    IN DWORD ReqId,
    IN WCHAR const *pwszUserName,
    IN WCHAR const *pwszAttributes,
    IN DWORD dwDisposition)
{
    HRESULT hr;

    CertSrv::CAuditEvent 
    audit(0, g_dwAuditFilter);

    hr = audit.AddData(ReqId); // %1 request ID
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(pwszUserName); // %2 requester
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(pwszAttributes); // %3 attributes
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    hr = audit.AddData(dwDisposition); // %4 disposition
    _JumpIfError(hr, error, "CAuditEvent::AddData");

    if (NULL != prow)
    {
	hr = coreAuditAddStringProperty(
			prow,
			g_wszPropCertificateSubjectKeyIdentifier,
			&audit); // %5 SKI
	_JumpIfError(hr, error, "coreAuditAddStringProperty");

	hr = coreAuditAddStringProperty(
			prow,
			g_wszPropSubjectDistinguishedName,
			&audit); // %6 Subject
	_JumpIfError(hr, error, "coreAuditAddStringProperty");
    }
    else // we need to guarantee the same number of audit params
    {
        hr = audit.AddData(L""); // %5 SKI
        _JumpIfError(hr, error, "");

        hr = audit.AddData(L""); // %6 Subject
        _JumpIfError(hr, error, "");
    }

    switch (dwDisposition)
    {
	case CR_DISP_ISSUED: 
	    audit.SetEventID(SE_AUDITID_CERTSRV_REQUESTAPPROVED);
	    hr = audit.Report();
	    _JumpIfError(hr, error, "CAuditEvent::Report");

	    break;

	case CR_DISP_UNDER_SUBMISSION:
	    audit.SetEventID(SE_AUDITID_CERTSRV_REQUESTPENDING);
	    hr = audit.Report();
	    _JumpIfError(hr, error, "CAuditEvent::Report");

	    break;

	case CR_DISP_DENIED: // fail over
	default:
	    audit.SetEventID(SE_AUDITID_CERTSRV_REQUESTDENIED);
	    hr = audit.Report(false);
	    _JumpIfError(hr, error, "CAuditEvent::Report");
        break;

    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


HRESULT
coreValidateMessageSize(
    IN OPTIONAL LPCWSTR pwszUser,
    IN DWORD cbRequest)
{
    HRESULT hr = S_OK;

    if (cbRequest > g_cbMaxIncomingMessageSize)
    {
        hr = HRESULT_FROM_WIN32(ERROR_MESSAGE_EXCEEDS_MAX_SIZE);

        if (CERTLOG_VERBOSE <= g_dwLogLevel)
        {
            LogEventStringHResult(
			    EVENTLOG_ERROR_TYPE,
			    MSG_E_POSSIBLE_DENIAL_OF_SERVICE_ATTACK,
			    NULL != pwszUser? pwszUser : g_pwszUnknownSubject,
			    hr);
        }
    }
    return(hr);
}


HRESULT
coreInitRequest(
    IN DWORD dwFlags,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN DWORD cbRequest,
    OPTIONAL IN BYTE const *pbRequest,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN DWORD dwComContextIndex,
    OUT DWORD *pOpRequest,
    OUT ICertDBRow **pprow,		// may return non-NULL on error
    OUT WCHAR **ppwszDisposition,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    
    *pprow = NULL;
    *ppwszDisposition = NULL;

    // for Denial-of-Service reasons, don't do anything with a too-long message

    hr = coreValidateMessageSize(pwszUserName, cbRequest);
    _JumpIfError(hr, error, "coreValidateMessageSize");

    // Called in several cases:
    //
    // - CR_IN_NEW: Create a new request and return error/pending/etc &
    //	 possibly the cert:
    //       NULL != pbRequest && NULL != pResult->pctbCert, etc.
    //
    // - CR_IN_DENY: Deny a pending request:
    //       NULL == pbRequest && NULL == pResult->pctbCert, etc.
    //
    // - CR_IN_RESUBMIT: Resubmit a pending request and return hr/pending/etc.
    //       NULL == pbRequest && NULL == pResult->pctbCert, etc.
    //
    // - CR_IN_RETRIEVE: Retrieve a cert for a processed request and return
    //   error/pending/etc & possibly the cert:
    //       NULL == pbRequest && NULL != pResult->pctbCert, etc.
    
    *pOpRequest = (CR_IN_COREMASK & dwFlags);
    switch (*pOpRequest)
    {
        // Process a new request:

        case CR_IN_NEW:
            CSASSERT(NULL != pwszUserName);
            CSASSERT(0 != cbRequest);
            CSASSERT(NULL != pbRequest);

            CSASSERT(0 == *pResult->pdwRequestId);
            *pResult->pdwRequestId = 0;

            hr = coreCreateRequest(
			    ~CR_IN_COREMASK & dwFlags,
		            pwszUserName,
		            cbRequest,
		            pbRequest,
		            pwszAttributes,
			    dwComContextIndex,
		            pprow,
			    pResult);
            _JumpIfError(hr, error, "coreCreateRequest");

            (*pprow)->GetRowId(pResult->pdwRequestId);
            {         
                CertSrv::CAuditEvent 
                    audit(SE_AUDITID_CERTSRV_NEWREQUEST, g_dwAuditFilter);

                hr = audit.AddData(*pResult->pdwRequestId); // %1 request ID
                _JumpIfError(hr, error, "CAuditEvent::AddData");

                hr = audit.AddData(pwszUserName); // %2 requester
                _JumpIfError(hr, error, "CAuditEvent::AddData");

                hr = audit.AddData(pwszAttributes); // %3 attributes
                _JumpIfError(hr, error, "CAuditEvent::AddData");

                hr = audit.Report();
                _JumpIfError(hr, error, "CAuditEvent::Report");
            }
            break;

        // Deny a request:
        // Resubmit a request:

        case CR_IN_DENY:
        case CR_IN_RESUBMIT:
            break;

        // Retrieve a cert:

        case CR_IN_RETRIEVE:
            break;

        default:
	    CSASSERT(*pOpRequest != *pOpRequest);
	    break;
    }
    if (CR_IN_NEW != *pOpRequest)
    {
	hr = E_INVALIDARG;
	if (0 != cbRequest || NULL != pbRequest)
	{
	    _JumpError(hr, error, "unexpected request");
	}
        if ((0 != *pResult->pdwRequestId) ^ (NULL == pwszSerialNumber))
	{
	    _JumpError(hr, error, "expected RequestId or SerialNumber");
	}

	// RetrievePending by RequestId OR SerialNumber in pwszSerialNumber

        hr = g_pCertDB->OpenRow(
			    PROPTABLE_REQCERT,
			    *pResult->pdwRequestId,
			    pwszSerialNumber,
			    pprow);
        _JumpIfError(hr, error, "OpenRow");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	HRESULT hr2;
	
	hr2 = myDupString(
		(CRCF_SIGNATUREERROR & pResult->dwResultFlags)?
		    g_pwszRequestSigError :
		    ((CRCF_ARCHIVESIGNINGKEYERROR & pResult->dwResultFlags)?
			g_pwszArchiveSigningKeyError : 
			((CRCF_KEYARCHIVALERROR & pResult->dwResultFlags)?
			    g_pwszKeyArchivalError :
			    g_pwszRequestParsingError)),
		ppwszDisposition);
	_PrintIfError(hr2, "myDupString");

	if (NULL != pResult->pwszExtendedErrorInfo)
	{
	    hr2 = myAppendString(
			pResult->pwszExtendedErrorInfo,
			L"  ",
			ppwszDisposition);
	    _PrintIfError(hr2, "myAppendString");
	}

	if (NULL != *pprow)
	{
	    hr2 = CoreSetRequestDispositionFields(
					    *pprow,
					    hr,
					    DB_DISP_ERROR,
					    *ppwszDisposition);
	    _PrintIfError(hr2, "CoreSetRequestDispositionFields");
	    
	    CoreLogRequestStatus(
			    *pprow,
			    MSG_E_PROCESS_REQUEST_FAILED,
			    hr,
			    *ppwszDisposition);
	}
    }
    return(hr);
}


HRESULT
CoreProcessRequest(
    IN DWORD dwFlags,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN DWORD cbRequest,
    OPTIONAL IN BYTE const *pbRequest,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN DWORD dwComContextIndex,
    IN DWORD dwRequestId,
    OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    HRESULT hr2;
    WCHAR *pwszDisposition = NULL;
    DWORD OpRequest;
    ICertDBRow *prow = NULL;
    DWORD ReqId;
    LONG ExitEvent = EXITEVENT_INVALID;
    BOOL fCoInitialized = FALSE;
    CACTX *pCAContext;
    BOOL fCommitted = FALSE;
    
    CSASSERT(NULL != pResult->pdwRequestId);
    CSASSERT(NULL != pResult->pdwDisposition);

    if (MAXDWORD == dwRequestId)
    {
	dwRequestId = 0;
    }
    *pResult->pdwRequestId = dwRequestId;
    *pResult->pdwDisposition = CR_DISP_ERROR;
    
    OpRequest = CR_IN_RETRIEVE;
    ReqId = 0;
    hr = CoInitializeEx(NULL, GetCertsrvComThreadingModel());
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitializeEx");
    }
    fCoInitialized = TRUE;

    hr = coreInitRequest(
		    dwFlags,
		    pwszUserName,
		    cbRequest,
		    pbRequest,
		    pwszAttributes,
		    pwszSerialNumber,
		    dwComContextIndex,
		    &OpRequest,
		    &prow,
		    &pwszDisposition,
		    pResult);
    _PrintIfError(hr, "coreInitRequest");

    pCAContext = NULL;
    if (S_OK == hr)
    {
	CSASSERT(NULL == pwszDisposition);	// error string only
	if (CR_IN_NEW != OpRequest)
	{
	    DWORD cb;
	    DWORD dw;
	    
	    cb = sizeof(dw);
	    hr = prow->GetProperty(
			g_wszPropRequestType,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cb,
			(BYTE *) &dw);
	    if (S_OK == hr)
	    {
		dwFlags |= (CR_IN_CRLS & dw);
	    }
	}
	hr = coreVerifyRequest(
			&prow,
			OpRequest,
			0 != (CR_IN_CRLS & dwFlags),
			pwszUserName,
			dwComContextIndex,
			&ReqId,
			&ExitEvent,
			&pwszDisposition,
			&pCAContext,
			pResult);		// CoTaskMem
	_PrintIfError(hr, "coreVerifyRequest");
    }
    else
    {
	WCHAR *pwszDisposition2 = CoreBuildDispositionString(
				    pwszDisposition,
				    NULL,	// pwszUserName
				    NULL,	// pwszDispositionDetail
				    NULL,	// pwszDispositionDetail2
				    NULL,	// pwszBy
				    hr,
				    FALSE);
	if (NULL != pwszDisposition2)
	{
	    if (NULL != pwszDisposition)
	    {
		LocalFree(pwszDisposition);
	    }
	    pwszDisposition = pwszDisposition2;
	}
    }

    if (NULL != pResult->pctbFullResponse)
    {
	BYTE const *pbCert = NULL;
	DWORD cbCert = 0;
	
	if (NULL != pResult->pctbCert && NULL != pResult->pctbCert->pb)
	{
	    pbCert = pResult->pctbCert->pb;
	    cbCert = pResult->pctbCert->cb;
	}
	CSASSERT(NULL == pResult->pctbFullResponse->pb);
	hr2 = PKCSEncodeFullResponse(
			    prow,
			    pResult,
			    hr,
			    pwszDisposition,
			    pCAContext,
			    pbCert,		// pbCertLeaf
			    cbCert,		// cbCertLeaf
			    0 != (CR_IN_CRLS & dwFlags),
			    &pResult->pctbFullResponse->pb,	// CoTaskMem*
			    &pResult->pctbFullResponse->cb);
	_PrintIfError(hr2, "PKCSEncodeFullResponse");
	if (S_OK == hr &&
	    (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr2 || IsWhistler()))
	{
	    hr = hr2;
	}
    }

    if (!((CRCF_FAILDENIEDREQUEST & pResult->dwResultFlags) &&
          (CRCF_PREVIOUSLYDENIED  & pResult->dwResultFlags)))
    {
        hr2 = coreAuditRequestDisposition(
				    prow,
				    ReqId,
				    pwszUserName,
				    pwszAttributes,
				    *pResult->pdwDisposition);
        _PrintIfError(hr2, "coreAuditRequestDisposition");
        if (S_OK == hr)
        {
	    hr = hr2;
        }
    }
    
    if (NULL != pwszDisposition && NULL != pResult->pctbDispositionMessage)
    {
	DWORD cbAlloc = (wcslen(pwszDisposition) + 1) * sizeof(WCHAR);
	BYTE *pbAlloc;

        pbAlloc = (BYTE *) CoTaskMemAlloc(cbAlloc);
        if (NULL != pbAlloc)
        {
	    CopyMemory(pbAlloc, pwszDisposition, cbAlloc);
	    pResult->pctbDispositionMessage->pb = pbAlloc;
	    pResult->pctbDispositionMessage->cb = cbAlloc;
        }
    }
    if (NULL != prow)
    {
	BOOL fSave;

	if (S_OK != hr)
	{
            hr2 = PropSetRequestTimeProperty(prow, g_wszPropRequestResolvedWhen);
            _PrintIfError(hr2, "PropSetRequestTimeProperty");
	}

	fSave = FALSE;
	switch (*pResult->pdwDisposition)
	{
	    case CR_DISP_ISSUED:
	    case CR_DISP_ISSUED_OUT_OF_BAND:
	    case CR_DISP_UNDER_SUBMISSION:
		fSave = TRUE;
		break;

	    default:
		if (KRAF_SAVEBADREQUESTKEY & g_KRAFlags)
		{
		    fSave = TRUE;
		}
		break;
	}
	if (fSave)
	{
	    if (NULL != pResult->pbArchivedKey)
	    {
		hr2 = prow->SetProperty(
			g_wszPropRequestRawArchivedKey,
			PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			pResult->cbArchivedKey,
			pResult->pbArchivedKey);
		_PrintIfError(hr2, "SetProperty(ArchivedKey)");
		if (S_OK == hr)
		{
		    hr = hr2;
		}

		hr2 = prow->SetProperty(
			g_wszPropRequestKeyRecoveryHashes,
			PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			MAXDWORD,
			(BYTE const *) pResult->pwszKRAHashes);
		_PrintIfError(hr2, "SetProperty(KRAHashes)");
		if (S_OK == hr)
		{
		    hr = hr2;
		}
	    }
	}
	else if (CR_IN_DENY == OpRequest || CR_IN_RESUBMIT == OpRequest)
	{
	    BYTE b = 0;

	    hr2 = prow->SetProperty(
		    g_wszPropRequestRawArchivedKey,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    0,
		    &b);	// to avoid E_POINTER errors
	    _PrintIfError(hr2, "SetProperty(ArchivedKey)");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }

	    hr2 = prow->SetProperty(
		    g_wszPropRequestKeyRecoveryHashes,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    0,
		    NULL);
	    _PrintIfError(hr2, "SetProperty(KRAHashes)");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
	if (pResult->fRequestSavedWithoutKey &&
	    (KRAF_SAVEBADREQUESTKEY & g_KRAFlags))
	{
	    fSave = FALSE;
	    switch (*pResult->pdwDisposition)
	    {
		case CR_DISP_INCOMPLETE:
		case CR_DISP_ERROR:
		case CR_DISP_DENIED:
		    fSave = TRUE;
		    break;

		default:
		    if (S_OK != hr)
		    {
			fSave = TRUE;
		    }
		    break;
	    }
	    if (fSave)
	    {
		hr2 = prow->SetProperty(
			g_wszPropRequestRawRequest,
			PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			cbRequest,
			pbRequest);
		_PrintIfError(hr2, "SetProperty(request)");
		if (S_OK == hr)
		{
		    hr = hr2;
		}
	    }
	}

        hr2 = prow->CommitTransaction(TRUE);
        _PrintIfError(hr2, "CommitTransaction");
	fCommitted = S_OK == hr2;
        if (S_OK == hr)
        {
            hr = hr2;
        }
    }
    
error:
    // If the request exists, clean up the DB
    
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
        {
            hr2 = prow->CommitTransaction(FALSE);
            _PrintIfError(hr2, "CommitTransaction");
        }
        prow->Release();
    }
    if (EXITEVENT_INVALID != ExitEvent)
    {
        CSASSERT(fCoInitialized);
        ExitNotify(
		ExitEvent,
		ReqId,
		CR_IN_NEW == OpRequest? pResult : NULL,
		dwComContextIndex);
    }
    if (fCoInitialized)
    {
        CoUninitialize();
    }
    if (S_OK != hr)
    {
        WCHAR const *pwszMsg;

        pwszMsg = myGetErrorMessageText(hr, TRUE);
        if (NULL != pwszMsg)
        {
            CONSOLEPRINT1((DBG_SS_CERTSRV, "%ws\n", pwszMsg));
            LocalFree(const_cast<WCHAR *>(pwszMsg));
        }
    }
    if (NULL != pwszDisposition)
    {
        LocalFree(pwszDisposition);
    }

    // Hide the failed HRESULT in the returned Disposition.
    // This allows the encoded Full response and disposition message to be
    // returned via DCOM or RPC.  Returning S_OK != hr defeats this mechanism.

    if (FAILED(hr) &&
	(CR_DISP_ERROR == *pResult->pdwDisposition ||
	 CR_DISP_DENIED == *pResult->pdwDisposition))
    {
	*pResult->pdwDisposition = hr;
	hr = S_OK;
    }
    {
#define wszFORMATREQUESTID	L"RequestId=%u"
	WCHAR wszRequestId[ARRAYSIZE(wszFORMATREQUESTID) + cwcDWORDSPRINTF];

	hr2 = hr;
	if (S_OK == hr2 && FAILED(*pResult->pdwDisposition))
	{
	    hr2 = *pResult->pdwDisposition;
	}
	if (S_OK != hr2)
	{
	    wsprintf(wszRequestId, wszFORMATREQUESTID, *pResult->pdwRequestId);
	    _PrintErrorStr(hr2, "CoreProcessRequest", wszRequestId);
	}
    }
    return(hr);
}


HRESULT
CoreValidateRequestId(
    IN ICertDBRow *prow,
    IN DWORD ExpectedDisposition)
{
    HRESULT hr;
    DWORD cbProp;
    DWORD Disposition;
    
    cbProp = sizeof(Disposition);
    hr = prow->GetProperty(
        g_wszPropRequestDisposition,
        PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
	NULL,
        &cbProp,
        (BYTE *) &Disposition);
    _PrintIfError(hr, "GetProperty");
    if (S_OK != hr || sizeof(Disposition) != cbProp)
    {
        hr = CERTSRV_E_NO_REQUEST;
    }
    else if (Disposition != ExpectedDisposition)
    {
        hr = CERTSRV_E_BAD_REQUESTSTATUS;
    }
    return(hr);
}


HRESULT
SetCAObjectFlags(
    IN DWORD dwFlags)
{
    HRESULT hr = S_OK;
    HCAINFO hCAInfo = NULL;
    DWORD dwCAFlags;

    hr = CAFindByName(
		g_pwszSanitizedDSName,
		NULL,
		CA_FIND_LOCAL_SYSTEM | CA_FIND_INCLUDE_UNTRUSTED,
		&hCAInfo);
    _JumpIfError(hr, error, "CAFindByName");

    hr = CAGetCAFlags(hCAInfo, &dwCAFlags);
    _JumpIfError(hr, error, "CAGetCAFlags");

    dwCAFlags |= dwFlags;

    hr = CASetCAFlags(hCAInfo, dwCAFlags);
    _JumpIfError(hr, error, "CASetCAFlags");

    hr = CAUpdateCA(hCAInfo);
    _JumpIfError(hr, error, "CAUpdateCA");

error:
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\csext.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csext.h
//
// Contents:    Cert Server globals
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#ifndef __CSEXT_H__
#define __CSEXT_H__

#include "certacl.h"

#ifndef SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE

// Temporary define audit events here

#define SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE   ((ULONG)0x00000321L)
#define SE_AUDITID_CERTSRV_PUBLISHCACERT         ((ULONG)0x0000031fL)

#endif // SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE

// privately used access bit to check for local administrator rights
#define CA_ACCESS_LOCALADMIN 0x00008000
// privately used access bit to trigger a denied audit event
#define CA_ACCESS_DENIED     0x00004000

// Each certificate handler must export the following functions.

#define CMS_CRLPUB_PERIOD	(60*1000)	// 60 seconds (in milliseconds)
//#define CMS_CRLPUB_PERIOD	(60*60*1000)	// 60 minutes (in milliseconds)

#define CCCF_INREQUESTGROUPSET	0x00000001
#define CCCF_INREQUESTGROUP	0x00000002
#define CCCF_KEYARCHIVEDSET	0x00000004
#define CCCF_KEYARCHIVED	0x00000008

typedef struct _CERTSRV_COM_CONTEXT
{
    DWORD	 dwFlags;
    HANDLE	 hAccessToken;
    DWORD	 RequestId;
    DWORD	 iExitModActive;
    WCHAR	*pwszUserDN;
} CERTSRV_COM_CONTEXT;


#define CRCF_SIGNATUREERROR		0x00000001
#define CRCF_KEYARCHIVALERROR		0x00000002
#define CRCF_FAILDENIEDREQUEST		0x00000004
#define CRCF_PREVIOUSLYDENIED		0x00000008
#define CRCF_RENEWAL			0x00000010
#define CRCF_ARCHIVESIGNINGKEYERROR	0x00000020

typedef struct _CERTSRV_RESULT_CONTEXT
{
    DWORD		*pdwRequestId;
    DWORD		 dwResultFlags;	// CRCF_*
    DWORD		 dwFlagsTop;
    BOOL		 fTransactionId;
    DWORD		 dwTransactionId;
    BYTE		*pbSenderNonce;
    DWORD		 cbSenderNonce;
    BOOL		 fRequestSavedWithoutKey;
    BOOL		 fEnrollOnBehalfOf;
    BYTE		*pbKeyHashIn;
    DWORD		 cbKeyHashIn;
    BYTE		*pbKeyHashOut;
    DWORD		 cbKeyHashOut;
    BYTE		*pbArchivedKey;
    DWORD		 cbArchivedKey;
    WCHAR		*pwszKRAHashes;
    BSTR		 strRenewalCertHash;
    DWORD		*pdwDisposition;
    WCHAR		*pwszExtendedErrorInfo;
    CERTTRANSBLOB	*pctbDispositionMessage;
    CERTTRANSBLOB	*pctbCert;
    CERTTRANSBLOB	*pctbCertChain;
    CERTTRANSBLOB	*pctbFullResponse;
} CERTSRV_RESULT_CONTEXT;

VOID ReleaseResult(IN OUT CERTSRV_RESULT_CONTEXT *pResult);


// Certification Authority Cert Context/Chain/Key information:

#define CTXF_SKIPCRL		0x00000001
#define CTXF_CERTMISSING	0x00000002
#define CTXF_CRLZOMBIE		0x00000004
#define CTXF_EXPIRED		0x00000010
#define CTXF_REVOKED		0x00000020

typedef struct _CACTX
{
    DWORD		 Flags;
    DWORD		 iCert;
    DWORD		 iKey;
    DWORD		 NameId;	// MAKECANAMEID(iCert, iKey)
    HRESULT		 hrVerifyStatus;
    CERT_CONTEXT const **apCACertChain;
    DWORD                cCACertChain;
    CERT_CONTEXT const  *pccCA;
    CRYPT_OBJID_BLOB     IssuerKeyId;
    HCRYPTPROV           hProvCA;
    CRYPT_OBJID_BLOB     KeyAuthority2Cert;
    CRYPT_OBJID_BLOB     KeyAuthority2CRL;
    CRYPT_OBJID_BLOB     CDPCert;
    CRYPT_OBJID_BLOB     CDPCRLFreshest;
    CRYPT_OBJID_BLOB     CDPCRLBase;
    CRYPT_OBJID_BLOB     CDPCRLDelta;
    CRYPT_OBJID_BLOB     AIACert;
    char                *pszObjIdSignatureAlgorithm;
    WCHAR		*pwszKeyContainerName;
    WCHAR	       **papwszCRLFiles;
    WCHAR	       **papwszDeltaCRLFiles;
} CACTX;


typedef struct _CACROSSCTX
{
    DWORD		 Flags;
    DWORD		 ReqId;
    CACTX		*pCAContext;
    CACTX		*pCAContextTarget;
    HRESULT		 hrVerifyStatus;
    CERT_CONTEXT const  *pccCACross;
} CACROSSCTX;


typedef struct _CAXCHGCTX
{
    DWORD		 Flags;
    DWORD		 ReqId;
    CERT_CONTEXT const  *pccCAXchg;
    HCRYPTPROV           hProvCA;
    WCHAR		*pwszKeyContainerName;
    DWORD		 iCertSig;
} CAXCHGCTX;


//+****************************************************
// Core Module:

HRESULT
CoreInit(
    IN BOOL fAuditEnabled);

VOID
CoreTerminate(VOID);

HRESULT
CoreValidateRequestId(
    IN ICertDBRow *prow,
    IN DWORD ExpectedDisposition);


// Internal CoreProcessRequest Flags:

#define CR_IN_NEW		0x00000000
#define CR_IN_DENY		0x10000000
#define CR_IN_RESUBMIT		0x20000000
#define CR_IN_RETRIEVE		0x30000000
#define CR_IN_COREMASK		0x30000000

HRESULT
CoreProcessRequest(
    IN DWORD dwType,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN DWORD cbRequest,
    OPTIONAL IN BYTE const *pbRequest,
    OPTIONAL IN WCHAR const *pwszAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN DWORD dwComContextIndex,
    IN DWORD dwRequestId,
    OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
CoreDenyRequest(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN DWORD ExpectedStatus);

VOID
CoreLogRequestStatus(
    IN ICertDBRow *prow,
    IN DWORD LogMsg,
    IN DWORD ErrCode,
    IN WCHAR const *pwszDisposition);

WCHAR *
CoreBuildDispositionString(
    OPTIONAL IN WCHAR const *pwszDispositionBase,
    OPTIONAL IN WCHAR const *pwszUserName,
    OPTIONAL IN WCHAR const *pwszDispositionDetail,
    OPTIONAL IN WCHAR const *pwszDispositionDetail2,
    OPTIONAL IN WCHAR const *pwszDispositionBy,
    IN HRESULT hrFail,
    IN BOOL fPublishError);

HRESULT
CoreSetDisposition(
    IN ICertDBRow *prow,
    IN DWORD Disposition);

HRESULT
CoreSetRequestDispositionFields(
    IN ICertDBRow *prow,
    IN DWORD ErrCode,
    IN DWORD Disposition,
    IN WCHAR const *pwszDisposition);

HRESULT
CoreSetComContextUserDN(
    IN DWORD dwRequestId,
    IN LONG Context,
    IN DWORD dwComContextIndex,
    OPTIONAL OUT WCHAR const **ppwszDN);	// do NOT free!

HRESULT
CoreSetArchivedKey(
    IN OUT CERTSRV_COM_CONTEXT *pComContext);

HRESULT
CorePublishCrossCertificate(
    IN DWORD RequestId,
    IN CERT_CONTEXT const *pcc,
    IN BOOL fCreateDSObject,
    IN BOOL fDelete);

#ifndef DBG_COMTEST
# define DBG_COMTEST DBG_CERTSRV
#endif


#if DBG_COMTEST

extern BOOL fComTest;

BOOL ComTest(LONG Context);

#endif


#ifdef DBG_CERTSRV_DEBUG_PRINT
# define CERTSRVDBGPRINTTIME(pszDesc, pftGMT) \
    CertSrvDbgPrintTime((pszDesc), (pftGMT))
VOID
CertSrvDbgPrintTime(
    IN char const *pszDesc,
    IN FILETIME const *pftGMT);

#else // DBG_CERTSRV_DEBUG_PRINT
# define CERTSRVDBGPRINTTIME(pszDesc, pftGMT)
#endif // DBG_CERTSRV_DEBUG_PRINT


HRESULT
CertSrvBlockThreadUntilStop();

/////////////////////////////////////
// CRL Publication logic

HRESULT
CRLInit(
    IN WCHAR const *pwszSanitizedName);

VOID
CRLTerminate();

HRESULT
CRLPubWakeupEvent(
    OUT DWORD *pdwMSTimeOut);

VOID
CRLComputeTimeOut(
    IN FILETIME const *pftFirst,
    IN FILETIME const *pftLast,
    OUT DWORD *pdwMSTimeOut);

HRESULT
CRLPublishCRLs(
    IN BOOL fRebuildCRL,
    IN BOOL fForceRepublish,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN BOOL fDelta,
    IN BOOL fShadowDelta,
    IN FILETIME ftNextUpdate,
    OUT BOOL *pfNeedRetry,
    OUT HRESULT *phrPublish);

HRESULT
CRLGetCRL(
    IN DWORD iCert,
    IN BOOL fDelta,
    OPTIONAL OUT CRL_CONTEXT const **ppCRL,
    OPTIONAL OUT DWORD *pdwCRLPublishFlags);

HRESULT
CRLWriteToLockedFile(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN BOOL fDelete,
    IN WCHAR const *pwszFile);

DWORD
CRLIsStringInList(
    IN WCHAR const *pwszSearch,
    OPTIONAL IN WCHAR const *pwszzList);

/////////////////////////////////////


HRESULT
PKCSSetup(
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszSanitizedName);

VOID
PKCSTerminate();

WCHAR const *
PKCSMapAttributeName(
    OPTIONAL IN WCHAR const *pwszAttributeName,
    OPTIONAL IN CHAR const *pszObjId,
    OUT DWORD *pdwIndex,
    OUT DWORD *pcchMax);

HRESULT
PKCSGetProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    OPTIONAL OUT DWORD *pcbData,
    OUT BYTE **ppbData);

HRESULT
PKCSVerifyCAState(
    IN OUT CACTX *pCAContext);

HRESULT
PKCSMapCertIndex(
    IN DWORD iCert,
    OUT DWORD *piCert,
    OUT DWORD *pState);

HRESULT
PKCSMapCRLIndex(
    IN DWORD iCert,
    OUT DWORD *piCert,	// returns newest iCert for passed iCert
    OUT DWORD *piCRL,
    OUT DWORD *pState);

HRESULT
PKCSGetCACertStatusCode(
    IN DWORD iCert,
    OUT HRESULT *phrCAStatusCode);

HRESULT
PKCSGetCAState(
    IN LONG PropId,	// CR_PROP_*
    OUT BYTE *pb);

HRESULT
PKCSGetCAVersion(
    OUT DWORD *pb);

HRESULT
PKCSGetKRAState(
    IN DWORD cKRA,
    OUT BYTE *pb);

HRESULT
PKCSSetSubjectTemplate(
    IN WCHAR const *pwszTemplate);

HRESULT
PKCSGetCACert(
    IN LONG PropId,	// CR_PROP_*
    IN DWORD iCert,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert);

HRESULT
PKCSGetCAChain(
    IN DWORD iCert,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCAChain, // CoTaskMem*
    OUT DWORD *pcbCAChain);

HRESULT
PKCSGetCAXchgCert(
    IN DWORD iCert,
    IN WCHAR const *pwszUserName,
    OUT DWORD *piCertSig,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert);

HRESULT
PKCSGetCAXchgChain(
    IN DWORD iCert,
    IN WCHAR const *pwszUserName,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCAChain, // CoTaskMem*
    OUT DWORD *pcbCAChain);

HRESULT
PKCSArchivePrivateKey(
    IN ICertDBRow *prow,
    IN BOOL fV1Cert,
    IN BOOL fOverwrite,
    IN CRYPT_ATTR_BLOB const *pBlobEncrypted,
    OPTIONAL IN OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
PKCSGetArchivedKey(
    IN DWORD dwRequestId,
    OUT BYTE **ppbArchivedKey,
    OUT DWORD *pcbArchivedKey);

HRESULT
PKCSUpdateXchgValidityPeriods(
    OPTIONAL IN HCERTTYPE hCertType);

HRESULT
PKCSGetCRLList(
    IN BOOL fDelta,
    IN DWORD iCert,
    OUT WCHAR const * const **ppapwszCRLList);

HRESULT
PKCSSetServerProperties(
    IN ICertDBRow *prow,
    OPTIONAL IN CACTX *pCAContext,	// signing CACTX
    OPTIONAL IN FILETIME const *pftNotBefore,
    OPTIONAL IN FILETIME const *pftNotAfter,
    IN LONG lValidityPeriodCount,
    IN enum ENUM_PERIOD enumValidityPeriod);

HRESULT
PKCSSetRequestFlags(
    IN ICertDBRow *prow,
    IN BOOL fSet,
    IN DWORD dwChange);

HRESULT
PKCSCreateCertificate(
    IN ICertDBRow *prow,
    IN DWORD Disposition,
    IN BOOL fIncludeCRLs,
    IN BOOL fCrossCert,
    OPTIONAL IN CACTX *pCAContext,	// signing CACTX
    OUT BOOL *pfErrorLogged,
    OPTIONAL OUT CACTX **ppCAContext,
    OPTIONAL OUT WCHAR **ppwszDispositionCreateCert,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult);	// CoTaskMem*

HRESULT
PKCSEncodeFullResponse(
    OPTIONAL IN ICertDBRow *prow,
    IN CERTSRV_RESULT_CONTEXT *pResult,
    IN HRESULT hrRequest,
    IN WCHAR *pwszDispositionString,
    OPTIONAL IN CACTX *pCAContext,
    OPTIONAL IN BYTE const *pbCertLeaf,
    IN DWORD cbCertLeaf,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbResponse,    // CoTaskMem*
    OUT DWORD *pcbResponse);

HRESULT
PKCSVerifyIssuedCertificate(
    IN CERT_CONTEXT const *pCert,
    OUT CACTX **ppCAContext);

HRESULT
PKCSIsRevoked(
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT LONG *pRevocationReason,
    OUT LONG *pDisposition);

HRESULT
PKCSParseImportedCertificate(
    IN ICertDBRow *prow,
    IN BOOL fCrossCert,		// else random imported cert
    IN DWORD Disposition,
    OPTIONAL IN CACTX const *pCAContext,
    IN CERT_CONTEXT const *pCert);

HRESULT
PKCSParseRequest(
    IN DWORD dwFlags,
    IN ICertDBRow *prow,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN CERT_CONTEXT const *pSigningAuthority,
    OUT BOOL *pfRenewal,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
PKCSParseAttributes(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszAttributes,
    IN BOOL fRegInfo,
    IN BOOL fPending,
    IN DWORD dwRDNTable,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf);

HRESULT
PKCSVerifyChallengeString(
    IN ICertDBRow *prow);

HRESULT
PKCSVerifySubjectRDN(
    OPTIONAL IN ICertDBRow *prow,
    IN OUT WCHAR const **ppwszPropertyName,
    OPTIONAL IN WCHAR const *pwszPropertyValue,
    OUT BOOL *pfSubjectDot);

HRESULT
PKCSDeleteAllSubjectRDNs(
    IN ICertDBRow *prow,
    IN DWORD Flags);

WCHAR *
PKCSSplitToken(
    IN OUT WCHAR **ppwszIn,
    IN WCHAR *pwcSeparator,
    OUT BOOL *pfSplit);

HRESULT
PropAddSuffix(
    IN WCHAR const *pwszValue,
    IN WCHAR const *pwszSuffix,
    IN DWORD cwcNameMax,
    OUT WCHAR **ppwszOut);

HRESULT
PropParseRequest(
    IN ICertDBRow *prow,
    IN DWORD dwFlags,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult);

HRESULT
PropSetRequestTimeProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszProp);

HRESULT
PropGetExtension(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue);

HRESULT
PropSetExtension(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN DWORD cbValue,
    IN BYTE const *pbValue);

HRESULT
PropSetAttributeProperty(
    IN ICertDBRow *prow,
    IN BOOL fConcatenateRDNs,
    IN BOOL fPrependNewValue,
    IN DWORD dwTable,
    IN DWORD cchNameMax,
    OPTIONAL IN WCHAR const *pwszSuffix,
    IN WCHAR const *wszName,
    IN WCHAR const *wszValue);

HRESULT
RequestInitCAPropertyInfo(VOID);

HRESULT
RequestGetCAPropertyInfo(
    OUT LONG          *pcProperty,
    OUT CERTTRANSBLOB *pctbPropInfo);

HRESULT
RequestGetCAProperty(
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue);

HRESULT
RequestSetCAProperty(
    IN  wchar_t const *pwszAuthority,
    IN  LONG           PropId,		// CR_PROP_*
    IN  LONG           PropIndex,
    IN  LONG           PropType,	// PROPTYPE_*
    OUT CERTTRANSBLOB *pctbPropertyValue);

DWORD
CertSrvStartServerThread(
    IN VOID *pvArg);

HRESULT
CertSrvEnterServer(
    OUT DWORD *pState);

HRESULT
CertSrvTestServerState();

HRESULT
CertSrvLockServer(
    IN OUT DWORD *pState);

VOID
CertSrvExitServer(
    IN DWORD State,
    IN HRESULT hrExit);

struct IEnumCERTDBRESULTROW;
typedef struct _CAVIEW
{
    struct _CAVIEW       *pCAViewNext;
    IEnumCERTDBRESULTROW *pView;
    VOID                 *pvSearch;
    FILETIME		  ftCreate;
    FILETIME		  ftLastAccess;
} CAVIEW;


HRESULT
CertSrvDelinkCAView(
    IN VOID *pvSearch,
    OPTIONAL OUT CAVIEW **ppCAViewOut);

HRESULT
CertSrvLinkCAView(
    IN BOOL fNew,
    IN VOID *pvSearch,
    IN CAVIEW *pCAViewIn);

HRESULT RPCInit(VOID);

HRESULT RPCTeardown(VOID);

VOID
ServiceMain(
    IN DWORD dwArgc,
    IN LPWSTR *lpszArgv);

HRESULT
ServiceQueryInteractiveFlag(
    OUT BOOL *pfSilent);

BOOL
ServiceReportStatusToSCMgr(
    IN DWORD dwCurrentState,
    IN DWORD dwWin32ExitCode,
    IN DWORD dwCheckPoint,
    IN DWORD dwWaitHint);

#define INCREMENT_EXTENSIONS            16

HRESULT
DBOpen(				// initialize database
    WCHAR const *pwszSanitizedName);

HRESULT
DBShutDown(			// terminate database access
    IN BOOL fPendingNotify);

STDMETHODIMP
CheckCertSrvAccess(
    IN LPCWSTR wszCA,
    IN handle_t hRpc,
    IN ACCESS_MASK Mask,
    OUT BOOL *pfAccessAllowed,
    OPTIONAL OUT HANDLE *phToken);

HRESULT
CertSrvSetRegistryFileTimeValue(
    IN BOOL fConfigLevel,
    IN WCHAR const *pwszRegValueName,
    IN DWORD cpwszDelete,
    OPTIONAL IN WCHAR const * const *papwszRegValueNameDelete);

HRESULT
GetClientUserName(
    OPTIONAL IN RPC_BINDING_HANDLE hRpc,
    OPTIONAL OUT WCHAR **ppwszUserSamName,
    OPTIONAL OUT WCHAR **ppwszUserDN);

HRESULT CertStartClassFactories(VOID);
VOID CertStopClassFactories(VOID);

HRESULT
SetCAObjectFlags(DWORD dwFlags);

namespace CertSrv
{
HRESULT 
GetMembership(
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzRM,
    IN PSID pSid,
    PTOKEN_GROUPS *ppGroups);

HRESULT 
CheckOfficerRights(
    DWORD dwRequestID,
    CertSrv::CAuditEvent &event);

HRESULT 
CheckOfficerRights(
    LPCWSTR pwszRequesterName,
    CertSrv::CAuditEvent &event);

HRESULT
CheckOfficerRightsFromAuthzCC(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzCCOfficer,
    IN WCHAR const *pwszRequesterName);

HRESULT
CheckOfficerRightsFromOfficerName(
    IN WCHAR const *pwszOfficerName,
    IN WCHAR const *pwszRequesterName);

HRESULT
GetCallerAuthzContext(
    OUT AUTHZ_CLIENT_CONTEXT_HANDLE *phAuthzCC);

BOOL
CallbackAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable);
}


HRESULT
PKCSGetKRACert(
    IN DWORD iCert,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert);


#define CSST_STARTSERVICECONTROLLER	0x00000001
#define CSST_CONSOLE			0x00000002

extern enum ENUM_PERIOD g_enumValidityPeriod;
extern LONG g_lValidityPeriodCount;

extern enum ENUM_PERIOD g_enumCAXchgValidityPeriod;
extern LONG g_lCAXchgValidityPeriodCount;

extern enum ENUM_PERIOD g_enumCAXchgOverlapPeriod;
extern LONG g_lCAXchgOverlapPeriodCount;

extern DWORD g_dwDelay2;

extern DWORD g_dwClockSkewMinutes;
extern DWORD g_dwViewAgeMinutes;
extern DWORD g_dwViewIdleMinutes;
extern DWORD g_dwLogLevel;
extern DWORD g_dwSessionCount;
extern DWORD g_dwCRLFlags;
extern DWORD g_dwHighSerial;
extern BYTE *g_pbHighSerial;
extern DWORD g_cbHighSerial;
extern DWORD g_cbMaxIncomingAllocSize;

extern ICertDB *g_pCertDB;
extern BOOL g_fDBRecovered;

extern HCERTSTORE g_hStoreCA;
extern HCRYPTPROV g_hProvCA;

extern BSTR g_strPolicyDescription;
extern BSTR g_strExitDescription;

extern BOOL g_fCertEnrollCompatible;
extern BOOL g_fEnforceRDNNameLengths;
extern BOOL g_fCreateDB;
extern BOOL g_fStartAsService;
extern DWORD g_CRLEditFlags;
extern DWORD g_KRAFlags;
extern DWORD g_cKRACertsRoundRobin;
extern DWORD g_cKRACerts;
extern ENUM_FORCETELETEX g_fForceTeletex;
extern ENUM_CATYPES g_CAType;
extern BOOL g_fUseDS;
extern BOOL g_fServerUpgraded;
extern long g_cTemplateUpdateSequenceNum;
extern DWORD g_InterfaceFlags;
extern HRESULT g_hrJetVersionStoreOutOfMemory;
extern DWORD g_CryptSilent;
extern DWORD g_dwVerifyCertFlags;

extern WCHAR g_wszCAStore[];
extern WCHAR const g_wszCertSrvServiceName[];
extern WCHAR const g_wszRegKeyConfigPath[];

extern WCHAR const g_wszRegDBA[];

extern WCHAR g_wszSanitizedName[];
extern WCHAR *g_pwszSanitizedDSName;
extern WCHAR g_wszCommonName[];
extern WCHAR g_wszPolicyDCName[];
extern DWORD g_cwcPolicyDCName;
extern WCHAR g_wszParentConfig[];

extern WCHAR g_wszDatabase[];
extern WCHAR g_wszLogDir[];
extern WCHAR g_wszSystemDir[];

extern WCHAR *g_pwszServerName;
extern BSTR g_strDomainDN;
extern BSTR g_strConfigDN;
extern WCHAR *g_pwszKRAPublishURL;
extern WCHAR *g_pwszAIACrossCertPublishURL;
extern WCHAR *g_pwszRootTrustCrossCertPublishURL;

extern WCHAR const g_wszRegValidityPeriodString[];
extern WCHAR const g_wszRegValidityPeriodCount[];
extern WCHAR const g_wszRegCAXchgValidityPeriodString[];
extern WCHAR const g_wszRegCAXchgValidityPeriodCount[];
extern WCHAR const g_wszRegCAXchgOverlapPeriodString[];
extern WCHAR const g_wszRegCAXchgOverlapPeriodCount[];
extern WCHAR const g_wszRegCAXchgCertHash[];
extern WCHAR const g_wszRegHighSerial[];

// renewal-friendly properties

extern DWORD g_cCAKeys;    // Total number of CA keys managed by this CA
extern DWORD g_cCACerts;   // Total number of CA certs managed by this CA

extern DWORD g_cExitMod;   // Total number of exit modules loaded by this CA

extern CertSrv::CCertificateAuthoritySD g_CASD;
extern AUTHZ_RESOURCE_MANAGER_HANDLE g_AuthzCertSrvRM;
extern DWORD g_dwAuditFilter;
extern CertSrv::COfficerRightsSD g_OfficerRightsSD;
extern CertSrv::CConfigStorage g_ConfigStorage;
extern CertSrv::CAutoLPWSTR g_pwszDBFileHash;

//+--------------------------------------------------------------------------
// Name properties:

extern WCHAR const g_wszPropDistinguishedName[];
extern WCHAR const g_wszPropRawName[];
extern WCHAR const g_wszPropCountry[];
extern WCHAR const g_wszPropOrganization[];
extern WCHAR const g_wszPropOrgUnit[];
extern WCHAR const g_wszPropCommonName[];
extern WCHAR const g_wszPropLocality[];
extern WCHAR const g_wszPropState[];
extern WCHAR const g_wszPropTitle[];
extern WCHAR const g_wszPropGivenName[];
extern WCHAR const g_wszPropInitials[];
extern WCHAR const g_wszPropSurName[];
extern WCHAR const g_wszPropDomainComponent[];
extern WCHAR const g_wszPropEMail[];
extern WCHAR const g_wszPropStreetAddress[];
extern WCHAR const g_wszPropUnstructuredAddress[];
extern WCHAR const g_wszPropUnstructuredName[];
extern WCHAR const g_wszPropDeviceSerialNumber[];
extern WCHAR const g_wszPropCertificateIssuerNameID[];


//+--------------------------------------------------------------------------
// Subject Name properties:

extern WCHAR const g_wszPropSubjectDot[];
extern WCHAR const g_wszPropSubjectDistinguishedName[];
extern WCHAR const g_wszPropSubjectRawName[];
extern WCHAR const g_wszPropSubjectCountry[];
extern WCHAR const g_wszPropSubjectOrganization[];
extern WCHAR const g_wszPropSubjectOrgUnit[];
extern WCHAR const g_wszPropSubjectCommonName[];
extern WCHAR const g_wszPropSubjectLocality[];
extern WCHAR const g_wszPropSubjectState[];
extern WCHAR const g_wszPropSubjectTitle[];
extern WCHAR const g_wszPropSubjectGivenName[];
extern WCHAR const g_wszPropSubjectInitials[];
extern WCHAR const g_wszPropSubjectSurName[];
extern WCHAR const g_wszPropSubjectDomainComponent[];
extern WCHAR const g_wszPropSubjectEMail[];
extern WCHAR const g_wszPropSubjectStreetAddress[];
extern WCHAR const g_wszPropSubjectUnstructuredAddress[];
extern WCHAR const g_wszPropSubjectUnstructuredName[];
extern WCHAR const g_wszPropSubjectDeviceSerialNumber[];


//+--------------------------------------------------------------------------
// Issuer Name properties:

extern WCHAR const g_wszPropIssuerDot[];
extern WCHAR const g_wszPropIssuerDistinguishedName[];
extern WCHAR const g_wszPropIssuerRawName[];
extern WCHAR const g_wszPropIssuerCountry[];
extern WCHAR const g_wszPropIssuerOrganization[];
extern WCHAR const g_wszPropIssuerOrgUnit[];
extern WCHAR const g_wszPropIssuerCommonName[];
extern WCHAR const g_wszPropIssuerLocality[];
extern WCHAR const g_wszPropIssuerState[];
extern WCHAR const g_wszPropIssuerTitle[];
extern WCHAR const g_wszPropIssuerGivenName[];
extern WCHAR const g_wszPropIssuerInitials[];
extern WCHAR const g_wszPropIssuerSurName[];
extern WCHAR const g_wszPropIssuerDomainComponent[];
extern WCHAR const g_wszPropIssuerEMail[];
extern WCHAR const g_wszPropIssuerStreetAddress[];
extern WCHAR const g_wszPropIssuerUnstructuredAddress[];
extern WCHAR const g_wszPropIssuerUnstructuredName[];
extern WCHAR const g_wszPropIssuerDeviceSerialNumber[];


//+--------------------------------------------------------------------------
// Request properties:

extern WCHAR const g_wszPropRequestRequestID[];
extern WCHAR const g_wszPropRequestRawRequest[];
extern WCHAR const g_wszPropRequestRawArchivedKey[];
extern WCHAR const g_wszPropRequestKeyRecoveryHashes[];
extern WCHAR const g_wszPropRequestRawOldCertificate[];
extern WCHAR const g_wszPropRequestAttributes[];
extern WCHAR const g_wszPropRequestType[];
extern WCHAR const g_wszPropRequestFlags[];
extern WCHAR const g_wszPropRequestStatusCode[];
extern WCHAR const g_wszPropRequestDisposition[];
extern WCHAR const g_wszPropRequestDispositionMessage[];
extern WCHAR const g_wszPropRequestSubmittedWhen[];
extern WCHAR const g_wszPropRequestResolvedWhen[];
extern WCHAR const g_wszPropRequestRevokedWhen[];
extern WCHAR const g_wszPropRequestRevokedEffectiveWhen[];
extern WCHAR const g_wszPropRequestRevokedReason[];
extern WCHAR const g_wszPropRequesterName[];
extern WCHAR const g_wszPropCallerName[];
extern WCHAR const g_wszPropRequestOSVersion[];
extern WCHAR const g_wszPropRequestCSPProvider[];

//+--------------------------------------------------------------------------
// Request attribute properties:

extern WCHAR const g_wszPropChallenge[];
extern WCHAR const g_wszPropExpectedChallenge[];


//+--------------------------------------------------------------------------
// Certificate properties:

extern WCHAR const g_wszPropCertificateRequestID[];
extern WCHAR const g_wszPropRawCertificate[];
extern WCHAR const g_wszPropCertificateHash[];
extern WCHAR const g_wszPropCertificateSerialNumber[];
extern WCHAR const g_wszPropCertificateNotBeforeDate[];
extern WCHAR const g_wszPropCertificateNotAfterDate[];
extern WCHAR const g_wszPropCertificateSubjectKeyIdentifier[];
extern WCHAR const g_wszPropCertificateRawPublicKey[];
extern WCHAR const g_wszPropCertificatePublicKeyLength[];
extern WCHAR const g_wszPropCertificatePublicKeyAlgorithm[];
extern WCHAR const g_wszPropCertificateRawPublicKeyAlgorithmParameters[];


//+--------------------------------------------------------------------------
// Disposition messages:

extern WCHAR const *g_pwszRequestedBy;
extern WCHAR const *g_pwszRevokedBy;
extern WCHAR const *g_pwszUnrevokedBy;
extern WCHAR const *g_pwszPublishedBy;
extern WCHAR const *g_pwszUnknownSubject;
extern WCHAR const *g_pwszInvalidIssuancePolicies;
extern WCHAR const *g_pwszInvalidApplicationPolicies;

extern WCHAR const *g_pwszIntermediateCAStore;

//+--------------------------------------------------------------------------
// Localizable audit strings
extern WCHAR const *g_pwszYes;
extern WCHAR const *g_pwszNo;
extern LPCWSTR g_pwszAuditResources[];

//+--------------------------------------------------------------------------
// Secured attributes:
extern LPWSTR  g_wszzSecuredAttributes;

extern HANDLE g_hServiceStoppingEvent;
extern HANDLE g_hServiceStoppedEvent;

extern HANDLE g_hCRLManualPublishEvent;
extern BOOL g_fCRLPublishDisabled;
extern BOOL g_fDeltaCRLPublishDisabled;

extern HKEY g_hkeyCABase;
extern HWND g_hwndMain;

extern BOOL g_fAdvancedServer;

__inline DWORD GetCertsrvComThreadingModel() { return(COINIT_MULTITHREADED); }

extern CACTX *g_aCAContext;
extern CACTX *g_pCAContextCurrent;


inline HRESULT CheckAuthorityName(PCWSTR pwszAuthority, bool fAllowEmptyName = false)
{
    HRESULT hr;
    if (NULL != pwszAuthority && L'\0' != *pwszAuthority)
    {
    	if (0 != mylstrcmpiL(pwszAuthority, g_wszCommonName))
        {   
            if (0 != mylstrcmpiL(pwszAuthority, g_wszSanitizedName) &&
            0 != mylstrcmpiL(pwszAuthority, g_pwszSanitizedDSName))
	        {
		        hr = E_INVALIDARG;
		        goto error;
	        }
#ifdef DBG_CERTSRV_DEBUG_PRINT
	        if (0 == mylstrcmpiL(pwszAuthority, g_wszSanitizedName))
	        {
		        DBGPRINT((
		            DBG_SS_CERTSRV,
		            "'%ws' called with Sanitized Name: '%ws'\n",
		            g_wszCommonName,
		            pwszAuthority));
	        }
	        else if (0 == mylstrcmpiL(pwszAuthority, g_pwszSanitizedDSName))
	        {
		        DBGPRINT((
		            DBG_SS_CERTSRV,
		            "'%ws' called with Sanitized DS Name: '%ws'\n",
		            g_wszCommonName,
		            pwszAuthority));
	        }
#endif
        }
    }
    else if(!fAllowEmptyName)
    {
        return hr = E_INVALIDARG;
    }

    hr = S_OK;

error:
    return hr;
}

#endif // __CSEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\db3.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        db3.cpp
//
// Contents:    Cert Server Database interface implementation
//
// History:     13-June-97       larrys created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>

#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTSRV_DB3_CPP__


ICertDB *g_pCertDB = NULL;
BOOL g_fDBRecovered = FALSE;

WCHAR g_wszDatabase[MAX_PATH];
WCHAR g_wszLogDir[MAX_PATH];
WCHAR g_wszSystemDir[MAX_PATH];

const WCHAR g_wszCertSrvDotExe[] = L"certsrv.exe";
const int MAXDWORD_STRLEN = 11;

HRESULT
dbCheckRecoveryState(
    IN HKEY hkeyConfig,
    IN DWORD cSession,
    IN DWORD DBFlags,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir);

typedef struct _REGDBDIR
{
    WCHAR const *pwszRegName;
    BOOL	 fMustExist;
    WCHAR       *pwszBuf;
} REGDBDIR;

HRESULT dbGetRestoreDataDWORD(
    LPCWSTR pwszRestoreFile,
    LPCWSTR pwszName,
    DWORD* pdwData)
{
    WCHAR buffer[MAXDWORD_STRLEN]; // large enough to fit MAXDWORD decimal (4294967295)

    GetPrivateProfileString(
        wszRESTORE_SECTION,
        pwszName,
        L"",
        buffer,
        ARRAYSIZE(buffer),
        pwszRestoreFile);

    if(0==wcscmp(buffer, L""))
    {
        return S_FALSE;
    }

    *pdwData = _wtoi(buffer);

    return S_OK;
}

HRESULT dbGetRestoreDataLPWSZ(
    LPCWSTR pwszRestoreFile,
    LPCWSTR pwszName,
    LPWSTR* ppwszData)
{
    HRESULT hr = S_OK;
    WCHAR buffer[MAX_PATH+1];

    GetPrivateProfileString(
        wszRESTORE_SECTION,
        pwszName,
        L"",
        buffer,
        ARRAYSIZE(buffer),
        pwszRestoreFile);

    if(0==wcscmp(buffer, L""))
    {
        return S_FALSE;
    }

    *ppwszData = (LPWSTR)LocalAlloc(LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(buffer)+1));
    _JumpIfAllocFailed(*ppwszData, error);

    wcscpy(*ppwszData, buffer);

error:
    return hr;
}

HRESULT dbGetRestoreDataMULTISZ(
    LPCWSTR pwszRestoreFile,
    LPCWSTR pwszName,
    LPWSTR *ppwszData,
    DWORD *pcbData)
{
   HRESULT hr = S_OK;
   WCHAR buffer[MAX_PATH+1];
   int cData;
   LPWSTR pwszFullName = NULL;
   DWORD cbData = 0;
   LPWSTR pwszData = NULL;
   WCHAR *pwszCrt = NULL; // no free

   pwszFullName = (LPWSTR)LocalAlloc(LMEM_FIXED, 
       sizeof(WCHAR)* 
              (wcslen(pwszName)+
               wcslen(wszRESTORE_NEWLOGSUFFIX)+
               MAXDWORD_STRLEN+1));
   _JumpIfAllocFailed(pwszFullName, error);

   wcscpy(pwszFullName, L"");

   for(cbData=0, cData = 0;; cData++)
   {
       wsprintf(pwszFullName, L"%s%d", pwszName, cData);

       GetPrivateProfileString(
            wszRESTORE_SECTION,
            pwszFullName,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

        if(0==wcscmp(buffer, L""))
        {
            if(0==cData)
            {
                hr = S_FALSE;
                _JumpErrorStr(hr, error, "no restore data", pwszRestoreFile);
            }
            else
            {
                break;
            }
        }

        cbData += wcslen(buffer)+1;

       wsprintf(pwszFullName, L"%s%s%d", pwszName, wszRESTORE_NEWLOGSUFFIX, 
           cData);

       GetPrivateProfileString(
            wszRESTORE_SECTION,
            pwszFullName,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

        if(0==wcscmp(buffer, L""))
        {
            hr = ERROR_INVALID_DATA;
            _JumpErrorStr(hr, error, 
                "restore file contains inconsistent data", pwszRestoreFile);
        }

        cbData += wcslen(buffer)+1;
   }

   cbData++; // trailing zero
   cbData *= sizeof(WCHAR);

   pwszData = (LPWSTR)LocalAlloc(LMEM_FIXED, cbData);
   _JumpIfAllocFailed(pwszData, error);

   for(pwszCrt=pwszData, cData = 0;; cData++)
   {
       wsprintf(pwszFullName, L"%s%d", pwszName, cData);

       GetPrivateProfileString(
            wszRESTORE_SECTION,
            pwszFullName,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

       if(0==wcscmp(buffer, L""))
       {
           break;
       }

       wcscpy(pwszCrt, buffer);
       pwszCrt += wcslen(buffer)+1;

       wsprintf(pwszFullName, L"%s%s%d", pwszName, wszRESTORE_NEWLOGSUFFIX, 
           cData);

       GetPrivateProfileString(
            wszRESTORE_SECTION,
            pwszFullName,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

       wcscpy(pwszCrt, buffer);
       pwszCrt += wcslen(buffer)+1;
   }

   *pwszCrt = L'\0';

   *ppwszData = pwszData;
   *pcbData = cbData;

error:
   LOCAL_FREE(pwszFullName);
   if(S_OK!=hr)
   {
       LOCAL_FREE(pwszData);
   }
   return hr;
}

HRESULT dbRestoreRecoveryStateFromFile(LPCWSTR pwszLogDir)
{
    HRESULT hr = S_OK;
    LPWSTR pwszRestoreFile = NULL;
    WCHAR buffer[256];
    DWORD dwRestoreMapCount, 
        dwRegLowLogNumber,
        dwRegHighLogNumber, 
        dwDatabaseRecovered;
    LPWSTR pwszRestoreMap = NULL;
    DWORD cbRestoreMap = 0;
    LPWSTR pwszPath = NULL;
    HKEY hkey = NULL;
    DWORD dwDisposition;
    HKEY hkeyRestore = NULL;
    BOOL fDatabaseRecovered;

    LPWSTR pwszBackupLogDir = NULL;
    LPWSTR pwszCheckpointFile = NULL;
    LPWSTR pwszLogPath = NULL;

    CSASSERT(pwszLogDir);

    pwszRestoreFile = (LPWSTR)LocalAlloc(LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(pwszLogDir)+wcslen(wszRESTORE_FILENAME)+2));
    _JumpIfAllocFailed(pwszRestoreFile, error);

    wcscpy(pwszRestoreFile, pwszLogDir);
    wcscat(pwszRestoreFile, L"\\");
    wcscat(pwszRestoreFile, wszRESTORE_FILENAME);

    // is there a restore state file?
    if(-1 != GetFileAttributes(pwszRestoreFile))
    {
        // check first if a restore is in progress
        GetPrivateProfileString(
            wszRESTORE_SECTION,
            wszREGRESTORESTATUS,
            L"",
            buffer,
            ARRAYSIZE(buffer),
            pwszRestoreFile);

        if(wcscmp(buffer, L""))
        {
            // restore in progress, bail
            hr = _wtoi(buffer);
            _JumpError(hr, error, "A restore is in progress");
        }

        hr = myRegOpenRelativeKey(
                            NULL,
                            L"",
                            RORKF_CREATESUBKEYS,
                            &pwszPath,
                            NULL,           // ppwszName
                            &hkey);
        _JumpIfError(hr, error, "myRegOpenRelativeKey");


        hr = RegCreateKeyEx(
                        hkey,
                        wszREGKEYRESTOREINPROGRESS,
                        0,                  // Reserved
                        NULL,               // lpClass
                        0,                  // dwOptions
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkeyRestore,
                        &dwDisposition);
        _JumpIfErrorStr(hr, error, "RegCreateKeyEx", wszREGKEYRESTOREINPROGRESS);

        hr = dbGetRestoreDataDWORD(
            pwszRestoreFile,
            wszREGRESTOREMAPCOUNT,
            &dwRestoreMapCount);
        if(S_FALSE==hr)
        {
            // mandatory
            hr = E_ABORT;
        }
        _JumpIfError(hr, error, 
            "restore ini file invalid, wszREGRESTOREMAPCOUNT not found" );

        hr = dbGetRestoreDataDWORD(
            pwszRestoreFile,
            wszREGLOWLOGNUMBER,
            &dwRegLowLogNumber);
        if(S_FALSE==hr)
        {
            // mandatory
            hr = E_ABORT;
        }
        _JumpIfError(hr, error, 
            "restore ini file invalid, wszREGLOWLOGNUMBER not found" );

        hr = dbGetRestoreDataDWORD(
            pwszRestoreFile,
            wszREGHIGHLOGNUMBER,
            &dwRegHighLogNumber);
        if(S_FALSE==hr)
        {
            // mandatory
            hr = E_ABORT;
        }
        _JumpIfError(hr, error, 
            "restore ini file invalid, wszREGHIGHLOGNUMBER not found" );

        hr = dbGetRestoreDataDWORD(
            pwszRestoreFile,
            wszREGDATABASERECOVERED,
            &dwDatabaseRecovered);
        if(S_FALSE==hr)
        {
            // mandatory
            hr = E_ABORT;
        }
        _JumpIfError(hr, error, 
            "restore ini file invalid, wszREGDATABASERECOVERED not found" );

        fDatabaseRecovered = dwDatabaseRecovered?TRUE:FALSE;

        hr = dbGetRestoreDataLPWSZ(
            pwszRestoreFile,
            wszREGBACKUPLOGDIRECTORY,
            &pwszBackupLogDir);
        if(S_FALSE==hr)
        {
            // optional
            hr = S_OK;
        }
        _JumpIfErrorStr(hr, error, "dbGetRestoreDataLPWSZ", wszREGBACKUPLOGDIRECTORY );


        hr = dbGetRestoreDataLPWSZ(
            pwszRestoreFile,
            wszREGCHECKPOINTFILE,
            &pwszCheckpointFile);
        if(S_FALSE==hr)
        {
            // optional
            hr = S_OK;
        }
        _JumpIfErrorStr(hr, error, "dbGetRestoreDataLPWSZ", wszREGCHECKPOINTFILE );


        hr = dbGetRestoreDataLPWSZ(
            pwszRestoreFile,
            wszREGLOGPATH,
            &pwszLogPath);
        if(S_FALSE==hr)
        {
            // optional
            hr = S_OK;
        }
        _JumpIfErrorStr(hr, error, "dbGetRestoreDataLPWSZ", wszREGLOGPATH );


        hr = dbGetRestoreDataMULTISZ(
            pwszRestoreFile,
            wszREGRESTOREMAP,
            &pwszRestoreMap,
            &cbRestoreMap);
        if(S_FALSE==hr)
        {
            // optional
            hr = S_OK;
        }
        _JumpIfErrorStr(hr, error, "dbGetRestoreDataDWORD", L"wszRESTOREMAP");

       hr = RegSetValueEx(
                       hkeyRestore,
                       wszREGRESTOREMAPCOUNT,
                       0,
                       REG_DWORD,
                       (BYTE *) &dwRestoreMapCount,
                       sizeof(DWORD));
       _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGRESTOREMAPCOUNT);

       hr = RegSetValueEx(
                       hkeyRestore,
                       wszREGLOWLOGNUMBER,
                       0,
                       REG_DWORD,
                       (BYTE *) &dwRegLowLogNumber,
                       sizeof(DWORD));
       _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGLOWLOGNUMBER);

       hr = RegSetValueEx(
                       hkeyRestore,
                       wszREGHIGHLOGNUMBER,
                       0,
                       REG_DWORD,
                       (BYTE *) &dwRegHighLogNumber,
                       sizeof(DWORD));
       _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGHIGHLOGNUMBER);

        hr = RegSetValueEx(
                        hkeyRestore,
                        wszREGDATABASERECOVERED,
                        0,
                        REG_BINARY,
                        (BYTE *) &fDatabaseRecovered,
                        sizeof(BOOLEAN));
        _JumpIfError(hr, error, "RegSetValueEx");

        if(pwszBackupLogDir)
        {
            hr = mySetRegistryLocalPathString(
                                        hkeyRestore,
                                        wszREGBACKUPLOGDIRECTORY,
                                        pwszBackupLogDir);
            _JumpIfErrorStr(hr, error, "mySetRegistryLocalPathString", 
                wszREGBACKUPLOGDIRECTORY);
        }

        if(pwszCheckpointFile)
        {
            hr = mySetRegistryLocalPathString(
                                        hkeyRestore,
                                        wszREGCHECKPOINTFILE,
                                        pwszCheckpointFile);
            _JumpIfErrorStr(hr, error, "mySetRegistryLocalPathString", 
                wszREGCHECKPOINTFILE);
        }

        if(pwszLogPath)
        {
            hr = mySetRegistryLocalPathString(
                                        hkeyRestore,
                                        wszREGLOGPATH,
                                        pwszLogPath);
            _JumpIfErrorStr(hr, error, "mySetRegistryLocalPathString", 
               wszREGCHECKPOINTFILE);
        }

        if(pwszRestoreMap)
        {
            hr = RegSetValueEx(
                hkeyRestore,
                wszREGRESTOREMAP,
                0,
                REG_MULTI_SZ,
                (BYTE *) pwszRestoreMap,
                cbRestoreMap);
            _JumpIfErrorStr(hr, error, "RegSetValueEx", wszREGRESTOREMAP);
        }

        if(!DeleteFile(pwszRestoreFile))
        {
            _PrintError(myHLastError(), "DeleteFile restore file");
        }
    }
    else
    {
        hr = myHLastError();
        // no restore state file OK
        if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            hr = S_OK;
        _JumpIfErrorStr(hr, error, "GetFileAttributes", pwszRestoreFile);
    }

error:
    
    LOCAL_FREE(pwszRestoreFile);
    LOCAL_FREE(pwszRestoreMap);
    LOCAL_FREE(pwszPath);
    LOCAL_FREE(pwszBackupLogDir);
    LOCAL_FREE(pwszCheckpointFile);
    LOCAL_FREE(pwszLogPath);
    if(hkey)
    {
        RegCloseKey(hkey);
    }
    if(hkeyRestore)
    {
        RegCloseKey(hkeyRestore);
    }
    return hr;
}


//+--------------------------------------------------------------------------
// DB file storage locations:
//
//   wszREGDBDIRECTORY:
//	Your Name.EDB		from csregstr.h: wszDBFILENAMEEXT .edb
//
//   wszREGDBLOGDIRECTORY:
//	EDB.log			from csregstr.h: wszDBBASENAMEPARM edb
//	EDB00001.log		from csregstr.h: wszDBBASENAMEPARM edb
//	EDB00002.log		from csregstr.h: wszDBBASENAMEPARM edb
//	res1.log
//	res2.log
//
//   wszREGDBSYSDIRECTORY:
//	EDB.chk			from csregstr.h: wszDBBASENAMEPARM edb
//
//   wszREGDBTEMPDIRECTORY:
//	tmp.edb			fixed name
//
//   wszREGDBFLAGS:
//      wszFlags                DBFLAGS_*
//      
// Backed up files:
//   DB files (Attachments):
//	wszREGDBDIRECTORY:	Your Name.EDB -- CSBFT_CERTSERVER_DATABASE
//
//   Log files:
//	wszREGDBLOGDIRECTORY:	EDB00001.log -- CSBFT_LOG
//	wszREGDBLOGDIRECTORY:	EDB00002.log -- CSBFT_LOG
//	wszREGDBDIRECTORY:	Your Name.pat -- CSBFT_PATCH_FILE
//
//+--------------------------------------------------------------------------


///// initialize database access

HRESULT
DBOpen(
    WCHAR const *pwszSanitizedName)
{
    HRESULT hr = S_OK;
    DWORD cb;
    DWORD i;
    DWORD dwState;
    HKEY hkey = NULL;
    WCHAR wszTempDir[MAX_PATH];
    DWORD DBFlags;
    BOOL fRestarted;

    REGDBDIR adbdir[] =
    {
	{ wszREGDBDIRECTORY,        TRUE,  g_wszDatabase, },
	{ wszREGDBLOGDIRECTORY,     TRUE,  g_wszLogDir, },
	{ wszREGDBSYSDIRECTORY,     TRUE,  g_wszSystemDir, },
	{ wszREGDBTEMPDIRECTORY,    TRUE,  wszTempDir, },
    };

    // check machine setup status

    hr = GetSetupStatus(NULL, &dwState);
    _JumpIfError(hr, error, "GetSetupStatus");

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, g_wszRegKeyConfigPath, &hkey);
    _JumpIfError(hr, error, "RegOpenKey(CAName)");

    // get info from registry

    for (i = 0; i < ARRAYSIZE(adbdir); i++)
    {
	cb = sizeof(WCHAR) * MAX_PATH;
	hr = RegQueryValueEx(
			hkey,
			adbdir[i].pwszRegName,
			NULL,
			NULL,
			(BYTE *) adbdir[i].pwszBuf,
			&cb);
	if ((HRESULT) ERROR_FILE_NOT_FOUND == hr && !adbdir[i].fMustExist)
	{
	    adbdir[i].pwszBuf[0] = L'\0';
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "RegQueryValueEx(DB*Dir)");
    }
    if (wcslen(g_wszDatabase) +
	1 +
	wcslen(pwszSanitizedName) +
	wcslen(wszDBFILENAMEEXT) >= ARRAYSIZE(g_wszDatabase))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "g_wszDatabase", pwszSanitizedName);
    }
    wcscat(g_wszDatabase, L"\\");
    wcscat(g_wszDatabase, pwszSanitizedName);
    wcscat(g_wszDatabase, wszDBFILENAMEEXT);

    cb = sizeof(DBFlags);
    hr = RegQueryValueEx(
		    hkey,
		    wszREGDBFLAGS,
		    NULL,
		    NULL,
		    (BYTE *) &DBFlags,
		    &cb);
    if (S_OK != hr)
    {
	//_PrintErrorStr(hr, "RegQueryValueEx", wszREGDBFLAGS);
	DBFlags = DBFLAGS_DEFAULT;
    }
    DBFlags &= ~(DBFLAGS_READONLY | DBFLAGS_DISABLESNAPSHOTBACKUP);
    if (g_fCreateDB || (SETUP_CREATEDB_FLAG & dwState))
    {
	DBFlags |= DBFLAGS_CREATEIFNEEDED;
    }
    if (IF_NOSNAPSHOTBACKUP & g_InterfaceFlags)
    {
	DBFlags |= DBFLAGS_DISABLESNAPSHOTBACKUP;
    }

    hr = dbCheckRecoveryState(
			hkey,
			2,			// cSession
			DBFlags,
			g_wszCertSrvDotExe,	// pwszEventSource
			g_wszLogDir,		// pwszLogDir
			g_wszSystemDir,		// pwszSystemDir
			wszTempDir);		// pwszTempDir
    _JumpIfError(hr, error, "dbCheckRecoveryState");


    CONSOLEPRINT1((DBG_SS_CERTSRV, "Opening Database %ws\n", g_wszDatabase));

    __try
    {
	hr = CoCreateInstance(
			   CLSID_CCertDB,
			   NULL,               // pUnkOuter
			   CLSCTX_INPROC_SERVER,
			   IID_ICertDB,
			   (VOID **) &g_pCertDB);
	_LeaveIfError(hr, "CoCreateInstance(ICertDB)");

	// only perform Hash if the auditing is enabled

	if (AUDIT_FILTER_STARTSTOP & g_dwAuditFilter)
	{
	    hr = myComputeMAC(g_wszDatabase, &g_pwszDBFileHash);
	
	    // db file does not exist when starting the CA first time

	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
	    {
		_PrintErrorStr(hr, "Database file not found, can't calculate hash", g_wszDatabase);
		hr = S_OK;
	    }
	    _LeaveIfErrorStr(hr, "myComputeMAC", g_wszDatabase);
	}

	// S_FALSE means a DB schema change was made that requires a restart
	// to take effect.  Open the DB a second time if S_FALSE is returned.

	fRestarted = FALSE;
	for (;;)
	{
	    hr = g_pCertDB->Open(
			    DBFlags,		// Flags
			    g_dwSessionCount,	// cSession
			    g_wszCertSrvDotExe,	// pwszEventSource
			    g_wszDatabase,	// pwszDBFile
			    g_wszLogDir,	// pwszLogDir
			    g_wszSystemDir,	// pwszSystemDir
			    wszTempDir);	// pwszTempDir
	    if (S_OK == hr)
	    {
		break;
	    }
	    if (S_FALSE == hr && fRestarted)
	    {
		_PrintError(hr, "Open");
		break;
	    }
	    if (S_FALSE != hr)
	    {
		_LeaveError(hr, "Open");
	    }
	    hr = g_pCertDB->ShutDown(0);
            _PrintIfError(hr, "DB ShutDown");

	    fRestarted = TRUE;
	}
	if (SETUP_CREATEDB_FLAG & dwState)
	{
	    hr = SetSetupStatus(NULL, SETUP_CREATEDB_FLAG, FALSE);
	    _LeaveIfError(hr, "SetSetupStatus");
	}
	hr = S_OK;
	CONSOLEPRINT0((DBG_SS_CERTSRV, "Database open\n"));
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (S_OK != hr)
    {
        if (NULL != g_pCertDB)
        {
            g_pCertDB->Release();
            g_pCertDB = NULL;
        }
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return(hr);
}


HRESULT
DBShutDown(
    IN BOOL fPendingNotify)
{
    HRESULT hr = S_OK;

    if (NULL != g_pCertDB)
    {
	hr = g_pCertDB->ShutDown(fPendingNotify? CDBSHUTDOWN_PENDING : 0);
	if (!fPendingNotify)
	{
	    g_pCertDB->Release();
	    g_pCertDB = NULL;
	}
    }
    return(hr);
}


HRESULT
dbRecoverAfterRestore(
    IN DWORD cSession,
    IN DWORD DBFlags,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir,
    IN WCHAR const *pwszCheckPointFile,
    IN WCHAR const *pwszLogPath,
    IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    IN WCHAR const *pwszBackupLogPath,
    IN DWORD genLow,
    IN DWORD genHigh)
{
    HRESULT hr;
    ICertDBRestore *pCertDBRestore = NULL;

    hr = S_OK;
    __try
    {
	WCHAR *apwsz[2];

	hr = CoCreateInstance(
			   CLSID_CCertDBRestore,
			   NULL,               // pUnkOuter
			   CLSCTX_INPROC_SERVER,
			   IID_ICertDBRestore,
			   (VOID **) &pCertDBRestore);
	_LeaveIfError(hr, "CoCreateInstance(ICertDBRestore)");

	hr = pCertDBRestore->RecoverAfterRestore(
					    cSession,
					    DBFlags,
					    pwszEventSource,
					    pwszLogDir,
					    pwszSystemDir,
					    pwszTempDir,
					    pwszCheckPointFile,
					    pwszLogPath,
					    rgrstmap,
					    crstmap,
					    pwszBackupLogPath,
					    genLow,
					    genHigh);
	_LeaveIfError(hr, "RecoverAfterRestore");

	apwsz[0] = wszREGDBLASTFULLBACKUP;
	apwsz[1] = wszREGDBLASTINCREMENTALBACKUP;
	hr = CertSrvSetRegistryFileTimeValue(
					TRUE,
					wszREGDBLASTRECOVERY,
					ARRAYSIZE(apwsz),
					apwsz);
	_PrintIfError(hr, "CertSrvSetRegistryFileTimeValue");
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    if (NULL != pCertDBRestore)
    {
	pCertDBRestore->Release();
    }
    return(hr);
}


HRESULT
dbPerformRecovery(
    IN DWORD cSession,
    IN DWORD DBFlags,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir,
    IN WCHAR const *pwszCheckPointFile,
    IN WCHAR const *pwszLogPath,
    IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    IN WCHAR const *pwszBackupLogPath,
    IN unsigned long genLow,
    IN unsigned long genHigh,
    IN OUT BOOLEAN *pfRecoverJetDatabase)
{
    HRESULT hr = S_OK;

    // Call into JET to let it munge the databases.
    // Note that the JET interpretation of LogPath and BackupLogPath is
    // totally wierd, and we want to pass in LogPath to both parameters.

    if (!*pfRecoverJetDatabase)
    {
	hr = dbRecoverAfterRestore(
				cSession,
				DBFlags,
				pwszEventSource,
				pwszLogDir,
				pwszSystemDir,
				pwszTempDir,
				pwszCheckPointFile,
				pwszLogPath,
				rgrstmap,
				crstmap,
				pwszBackupLogPath,
				genLow,
				genHigh);
	_JumpIfError(hr, error, "dbRecoverAfterRestore");
    }

    // Ok, we were able to recover the database.  Let the other side of the
    // API know about it so it can do something "reasonable".

    *pfRecoverJetDatabase = TRUE;

    // Mark the DB as a restored version - Add any external notification here

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// dbCheckRecoveryState -- recover a database after a restore if necessary.
//
// Parameters:
// pwszParametersRoot - the root of the parameters section for the service in
//     the registry.
//
// Returns: HRESULT - S_OK if successful; error code if not.
//
// The NTBACKUP program will place a key at the location:
// $(pwszParametersRoot)\Restore in Progress
//
// This key contains the following values:
// BackupLogPath - The full path for the logs after a backup
// CheckPointFilePath - The full path for the path that contains the checkpoint
// *HighLogNumber - The maximum log file number found.
// *LowLogNumber - The minimum log file number found.
// LogPath - The current path for the logs.
// JET_RstMap - Restore map for database - this is a REG_MULTISZ, where odd
//    entries go into the pwszDatabase field, and the even entries go into the
//    pwszNewDatabase field of a JET_RstMap
// *JET_RstMap Size - The number of entries in the restoremap.
//
// * - These entries are REG_DWORD's.  All others are REG_SZ's (except where
//     mentioned).
//---------------------------------------------------------------------------

HRESULT
dbCheckRecoveryState(
    IN HKEY hkeyConfig,
    IN DWORD cSession,
    IN DWORD DBFlags,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir)
{
    HRESULT hr;
    HKEY hkeyRestore = NULL;
    DWORD cb;
    WCHAR wszCheckPointFilePath[MAX_PATH];
    WCHAR wszBackupLogPath[MAX_PATH];
    WCHAR wszLogPath[MAX_PATH];
    WCHAR *pwszCheckPointFilePath;
    WCHAR *pwszBackupLogPath;
    WCHAR *pwszLogPath;
    WCHAR *pwszRestoreMap = NULL;
    CSEDB_RSTMAPW *pRstMap = NULL;
    LONG cRstMap;
    LONG i;
    DWORD genLow;
    DWORD genHigh;
    WCHAR *pwsz;
    DWORD dwType;
    HRESULT hrRestoreError;
    BOOLEAN fDatabaseRecovered = FALSE;
    WCHAR wszActiveLogPath[MAX_PATH];

    hr = dbRestoreRecoveryStateFromFile(pwszLogDir);
    _JumpIfError(hr, error, "dbRestoreRecoveryStateFromFile");

    
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, wszREGKEYCONFIGRESTORE, &hkeyRestore);
    if (S_OK != hr)
    {
	// We want to ignore file_not_found - it is ok.

	if (hr == ERROR_FILE_NOT_FOUND)
	{
	    hr = S_OK;
	}
	_PrintIfError(hr, "RegOpenKey");
	goto error;
    }

    CONSOLEPRINT0((DBG_SS_CERTSRV, "Started Database Recovery\n"));

    // If there's a restore in progress, then fail to perform any other
    // restore operations.

    dwType = REG_DWORD;
    cb = sizeof(DWORD);
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGRESTORESTATUS,
		    0,
		    &dwType,
		    (BYTE *) &hrRestoreError,
		    &cb);
    if (S_OK == hr)
    {
	hr = hrRestoreError;
	_JumpError(hr, error, "hrRestoreError");
    }

    cb = sizeof(wszActiveLogPath);
    hr = RegQueryValueEx(
		    hkeyConfig,
		    wszREGDBLOGDIRECTORY,
		    NULL,
		    NULL,
		    (BYTE *) wszActiveLogPath,
		    &cb);
    _JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGDBLOGDIRECTORY);

    // We have now opened the restore-in-progress key.  This means that we have
    // something to do now.  Find out what it is.  First, let's get the backup
    // log file path.

    dwType = REG_SZ;

    cb = sizeof(wszBackupLogPath);
    pwszBackupLogPath = wszBackupLogPath;
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGBACKUPLOGDIRECTORY,
		    0,
		    &dwType,
		    (BYTE *) wszBackupLogPath,
		    &cb);
    if (S_OK != hr)
    {
	if (hr != ERROR_FILE_NOT_FOUND)
	{
	    _JumpError(hr, error, "RegQueryValueEx");
	}
	pwszBackupLogPath = NULL;
    }

    // Then, the checkpoint file path.

    cb = sizeof(wszCheckPointFilePath);
    pwszCheckPointFilePath = wszCheckPointFilePath;
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGCHECKPOINTFILE,
		    0,
		    &dwType,
		    (BYTE *) wszCheckPointFilePath,
		    &cb);
    if (S_OK != hr)
    {
	if (hr != ERROR_FILE_NOT_FOUND)
	{
	    _JumpError(hr, error, "RegQueryValueEx");
	}
	pwszCheckPointFilePath = NULL;
    }

    // Then, the Log path.

    cb = sizeof(wszLogPath);
    pwszLogPath = wszLogPath;
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGLOGPATH,
		    0,
		    &dwType,
		    (BYTE *) wszLogPath,
		    &cb);
    if (S_OK != hr)
    {
	if ((HRESULT) ERROR_FILE_NOT_FOUND != hr)
	{
	    _JumpError(hr, error, "RegQueryValueEx");
	}
	pwszLogPath = NULL;
    }

    // Then, the low log number.

    dwType = REG_DWORD;
    cb = sizeof(genLow);
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGLOWLOGNUMBER,
		    0,
		    &dwType,
		    (BYTE *) &genLow,
		    &cb);
    _JumpIfError(hr, error, "RegQueryValueEx");

    // And, the high log number.

    cb = sizeof(genHigh);
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGHIGHLOGNUMBER,
		    0,
		    &dwType,
		    (BYTE *) &genHigh,
		    &cb);
    _JumpIfError(hr, error, "RegQueryValueEx");

    // Now determine if we had previously recovered the database.

    dwType = REG_BINARY;
    cb = sizeof(fDatabaseRecovered);

    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGDATABASERECOVERED,
		    0,
		    &dwType,
		    &fDatabaseRecovered,
		    &cb);
    if (S_OK != hr && (HRESULT) ERROR_FILE_NOT_FOUND != hr)
    {
	// If there was an error other than "value doesn't exist", bail.

	_JumpError(hr, error, "RegQueryValueEx");
    }

    // Now the tricky one.  We want to get the restore map.
    // First we figure out how big it is.

    dwType = REG_DWORD;
    cb = sizeof(cRstMap);
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGRESTOREMAPCOUNT,
		    0,
		    &dwType,
		    (BYTE *) &cRstMap,
		    &cb);
    _JumpIfError(hr, error, "RegQueryValueEx");

    pRstMap = (CSEDB_RSTMAPW *) LocalAlloc(
					LMEM_FIXED,
					sizeof(CSEDB_RSTMAPW) * cRstMap);
    if (NULL == pRstMap)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // First find out how much memory is needed to hold the restore map.

    dwType = REG_MULTI_SZ;
    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGRESTOREMAP,
		    0,
		    &dwType,
		    NULL,
		    &cb);
    if (S_OK != hr && (HRESULT) ERROR_MORE_DATA != hr)
    {
	_JumpError(hr, error, "RegQueryValueEx");
    }

    pwszRestoreMap = (WCHAR *) LocalAlloc(LMEM_FIXED, cb + 2 * sizeof(WCHAR));
    if (NULL == pwszRestoreMap)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = RegQueryValueEx(
		    hkeyRestore,
		    wszREGRESTOREMAP,
		    0,
		    &dwType,
		    (BYTE *) pwszRestoreMap,
		    &cb);
    _JumpIfError(hr, error, "RegQueryValueEx");
    
    pwszRestoreMap[cb / sizeof(WCHAR)] = L'\0';
    pwszRestoreMap[cb / sizeof(WCHAR) + 1] = L'\0';

    pwsz = pwszRestoreMap;
    for (i = 0; i < cRstMap; i++)
    {
	if (L'\0' == *pwsz)
	{
	    break;
	}
	pRstMap[i].pwszDatabaseName = pwsz;
	pwsz += wcslen(pwsz) + 1;

	if (L'\0' == *pwsz)
	{
	    break;
	}
	pRstMap[i].pwszNewDatabaseName = pwsz;
	pwsz += wcslen(pwsz) + 1;
    }
    if (i < cRstMap || L'\0' != *pwsz)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Restore Map");
    }

    {
        CertSrv::CAuditEvent event(SE_AUDITID_CERTSRV_RESTORESTART, g_dwAuditFilter);
        hr = event.Report();
        _JumpIfError(hr, error, "CAuditEvent::Report");
    }

    hr = dbPerformRecovery(
		cSession,
		DBFlags,
		pwszEventSource,
		pwszLogDir,
		pwszSystemDir,
		pwszTempDir,
		pwszCheckPointFilePath,
		NULL != pwszLogPath? pwszLogPath : wszActiveLogPath,
		pRstMap,
		cRstMap,
		NULL != pwszBackupLogPath? pwszBackupLogPath : wszActiveLogPath,
		genLow,
		genHigh,
		&fDatabaseRecovered);
    if (S_OK != hr)
    {
	// The recovery failed.  If recovering the database succeeded, flag it
	// in the registry so we don't try again.  Ignore RegSetValueEx errors,
	// because the recovery error is more important.

	RegSetValueEx(
		    hkeyRestore,
		    wszREGDATABASERECOVERED,
		    0,
		    REG_BINARY,
		    (BYTE *) &fDatabaseRecovered,
		    sizeof(fDatabaseRecovered));
	_JumpError(hr, error, "dbPerformRecovery");
    }

    {
        CertSrv::CAuditEvent event(SE_AUDITID_CERTSRV_RESTOREEND, g_dwAuditFilter);
        hr = event.Report();
        _JumpIfError(hr, error, "CAuditEvent::Report");
    }

    CONSOLEPRINT0((DBG_SS_CERTSRV, "Completed Database Recovery\n"));

    g_fDBRecovered = TRUE;

    // Ok, we're all done.  We can now delete the key, since we're done
    // with it.

    RegCloseKey(hkeyRestore);
    hkeyRestore = NULL;

    hr = RegDeleteKey(HKEY_LOCAL_MACHINE, wszREGKEYCONFIGRESTORE);
    _JumpIfError(hr, error, "RegDeleteKey");

error:
    if (NULL != pwszRestoreMap)
    {
	LocalFree(pwszRestoreMap);
    }
    if (NULL != pRstMap)
    {
	LocalFree(pRstMap);
    }
    if (NULL != hkeyRestore)
    {
        RegCloseKey(hkeyRestore);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\elog.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        elog.cpp
//
// Contents:    Cert Server Core implementation
//
// History:     02-Jan-97       terences created
//
//---------------------------------------------------------------------------

// TBD: add AddLoggingEvent, which will log to file instead of the event log
// TBD: add audit events
// TBD: add filtering so that criticality sorting of events can take place

#include <pch.cpp>

#pragma hdrstop

#include "certlog.h"
#include "elog.h"

#define __dwFILE__	__dwFILE_CERTSRV_ELOG_CPP__


#if DBG_CERTSRV
WCHAR const *
wszEventType(
    IN DWORD dwEventType)
{
    WCHAR const *pwsz;

    switch (dwEventType)
    {
	case EVENTLOG_ERROR_TYPE:	pwsz = L"Error";	 break;
	case EVENTLOG_WARNING_TYPE:	pwsz = L"Warning";	 break;
	case EVENTLOG_INFORMATION_TYPE:	pwsz = L"Information";	 break;
	case EVENTLOG_AUDIT_SUCCESS:	pwsz = L"AuditSuccess";	 break;
	case EVENTLOG_AUDIT_FAILURE:	pwsz = L"AuditFailure";  break;
	default:			pwsz = L"???";		 break;
    }
    return(pwsz);
}
#endif // DBG_CERTSRV


typedef struct _ELOGTHROTTLE {
    DWORD	dwIdEvent;
    DWORD	dwSeconds;
    LLFILETIME	llftNext;
} ELOGTHROTTLE;


ELOGTHROTTLE s_elogThrottle[] = {
    { MSG_E_POSSIBLE_DENIAL_OF_SERVICE_ATTACK,	20 * CVT_MINUTES, },
    { MSG_E_BAD_DEFAULT_CA_XCHG_CSP,		1 * CVT_DAYS, },
    { MSG_E_BAD_REGISTRY_CA_XCHG_CSP,		1 * CVT_DAYS, },
    { MSG_CLAMPED_BY_CA_CERT,			1 * CVT_DAYS, },
};


BOOL
LogThrottleEvent(
    IN DWORD dwIdEvent)
{
    BOOL fThrottle = FALSE;

    if (CERTLOG_EXHAUSTIVE > g_dwLogLevel)
    {
	ELOGTHROTTLE *pet;

	for (
	    pet = s_elogThrottle;
	    pet < &s_elogThrottle[ARRAYSIZE(s_elogThrottle)];
	    pet++)
	{
	    if (dwIdEvent == pet->dwIdEvent)
	    {
		LLFILETIME llft;
		LLFILETIME llftNext;

		GetSystemTimeAsFileTime(&llft.ft);

		// if it's time to log the next msg (Next < Now)

		llftNext = pet->llftNext;
		if (0 > CompareFileTime(&llftNext.ft, &llft.ft))
		{
		    llft.ll += ((LONGLONG) pet->dwSeconds) * CVT_BASE;
		    pet->llftNext = llft;
		}
		else
		{
		    fThrottle = TRUE;
		}
		break;
	    }
	}
    }

//error:
    return(fThrottle);
}


/*********************************************************************
* FUNCTION: LogEvent(	DWORD   dwEventType,                 	     *
*                       DWORD   dwIdEvent,                           *
*			WORD    cStrings,                            *
*                       LPTSTR *apwszStrings);                        *
*                                                                    *
* PURPOSE: add the event to the event log                            *
*                                                                    *
* INPUT: the event ID to report in the log, the number of insert     *
*        strings, and an array of null-terminated insert strings     *
*                                                                    *
* RETURNS: none                                                      *
*********************************************************************/

HRESULT
LogEvent(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN WORD cStrings,
    IN WCHAR const * const *apwszStrings)
{
    HRESULT hr;
    HANDLE hAppLog = NULL;

#if DBG_CERTSRV
    CONSOLEPRINT3((
	    DBG_SS_CERTSRV,
	    "LogEvent(Type=%x(%ws), Id=%x)\n",
	    dwEventType,
	    wszEventType(dwEventType),
	    dwIdEvent));

    for (DWORD i = 0; i < cStrings; i++)
    {
	CONSOLEPRINT2((
		DBG_SS_CERTSRV,
		"LogEvent[%u]: %ws\n",
		i,
		apwszStrings[i]));
    }
#endif // DBG_CERTSRV

    if (!LogThrottleEvent(dwIdEvent))
    {
	WORD wElogType = (WORD) dwEventType;

	hAppLog = RegisterEventSource(NULL, g_wszCertSrvServiceName);
	if (NULL == hAppLog)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "RegisterEventSource");
	}
	if (!ReportEvent(
		    hAppLog,
		    wElogType,
		    0,
		    dwIdEvent,
		    NULL,
		    cStrings,
		    0,
		    const_cast<WCHAR const **>(apwszStrings),
		    NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "ReportEvent");
	}
    }
    hr = S_OK;

error:
    if (NULL != hAppLog)
    {
	DeregisterEventSource(hAppLog);
    }
    return(hr);
}


HRESULT
LogEventHResult(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN HRESULT hrEvent)
{
    HRESULT hr;
    WCHAR const *apwsz[1];
    WORD cpwsz;
    WCHAR awchr[cwcHRESULTSTRING];

    apwsz[0] = myGetErrorMessageText(hrEvent, TRUE);
    cpwsz = ARRAYSIZE(apwsz);
    if (NULL == apwsz[0])
    {
	apwsz[0] = myHResultToString(awchr, hrEvent);
    }

    hr = LogEvent(dwEventType, dwIdEvent, cpwsz, apwsz);
    _JumpIfError(hr, error, "LogEvent");

error:
    if (NULL != apwsz[0] && awchr != apwsz[0])
    {
	LocalFree(const_cast<WCHAR *>(apwsz[0]));
    }
    return(hr);
}


HRESULT
LogEventString(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    OPTIONAL IN WCHAR const *pwszString)
{
    return(LogEvent(
		dwEventType,
		dwIdEvent,
		(WORD) (NULL == pwszString? 0 : 1),
		NULL == pwszString? NULL : &pwszString));
}


HRESULT
LogEventStringHResult(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN WCHAR const *pwszString,
    IN HRESULT hrEvent)
{
    return(LogEventStringArrayHResult(
			    dwEventType,
			    dwIdEvent,
			    1,		// cStrings
			    &pwszString,
			    hrEvent));
}


HRESULT
LogEventStringArrayHResult(
    IN DWORD dwEventType,
    IN DWORD dwIdEvent,
    IN DWORD cStrings,
    IN WCHAR const * const *apwszStrings,
    IN HRESULT hrEvent)
{
    HRESULT hr;
    WCHAR const *apwsz[10];
    DWORD cpwsz;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszError = NULL;

    CSASSERT(ARRAYSIZE(apwsz) > cStrings);
    cpwsz = min(ARRAYSIZE(apwsz) - 1, cStrings);
    CopyMemory(apwsz, apwszStrings, cpwsz * sizeof(apwsz[0]));

    pwszError = myGetErrorMessageText(hrEvent, TRUE);
    if (NULL == pwszError)
    {
	pwszError = myHResultToString(awchr, hrEvent);
    }
    apwsz[cpwsz] = pwszError;
    cpwsz++;

    hr = LogEvent(dwEventType, dwIdEvent, (WORD) cpwsz, apwsz);
    _JumpIfError(hr, error, "LogEvent");

error:
    if (NULL != pwszError && awchr != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

SOURCE_DIR=..\idl\rpc\$(O)

$(NTTARGETFILE1):	$(SOURCE_DIR)\$(@F) $(@F)0 $(@F)1
    type $(@F)0 > $@
    type $(SOURCE_DIR)\$(@F) >> $@
    type $(@F)1 >> $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certsrv"


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifndef MAXDWORD
# define MAXDWORD MAXULONG
#endif

#include <windows.h>
#include <wincrypt.h>
#include <authz.h>
#include <adtgen.h>
#include <msaudite.h>

#include "certlib.h"
#include "certsrv.h"
#include "certdb.h"
#include "config.h"
#include "audit.h"
#include "csext.h"


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\prop.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        prop.cpp
//
// Contents:    Cert Server Property interface implementation
//
// History:     31-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "cscom.h"
#include "csdisp.h"
#include "com.h"
#include "certlog.h"
#include "certsrvd.h"
#include "dbtable.h"
#include "elog.h"

#define __dwFILE__	__dwFILE_CERTSRV_PROP_CPP__


#ifndef DBG_PROP
# define DBG_PROP	0
#endif


HRESULT
PropSetRequestTimeProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszProp)
{
    HRESULT hr;
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ft))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SystemTimeToFileTime");
    }
    hr = prow->SetProperty(
		pwszProp,
		PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		sizeof(ft),
		(BYTE *) &ft);
    _JumpIfError(hr, error, "SetProperty");

error:
    return(hr);
}


HRESULT
PropParseRequest(
    IN ICertDBRow *prow,
    IN DWORD dwFlags,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;

    pResult->dwFlagsTop = dwFlags;
    hr = PKCSParseRequest(
		    dwFlags,
		    prow,
		    cbRequest,
		    pbRequest,
		    NULL,
		    NULL,
		    pResult);
    _JumpIfError(hr, error, "PKCSParseRequest");

error:
    return(hr);
}


HRESULT
propVerifyDateRange(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN FILETIME const *pft)
{
    HRESULT hr;
    DWORD cbProp;
    FILETIME ftNotBefore;
    FILETIME ftNotAfter;

    hr = E_INVALIDARG;
    CSASSERT((PROPTYPE_MASK & Flags) == PROPTYPE_DATE);

    if ((PROPTABLE_MASK & Flags) != PROPTABLE_CERTIFICATE)
    {
	_JumpError(hr, error, "Flags: Invalid table");
    }
    if (0 != mylstrcmpiS(pwszPropertyName, g_wszPropCertificateNotBeforeDate) &&
	0 != mylstrcmpiS(pwszPropertyName, g_wszPropCertificateNotAfterDate))
    {
	_JumpError(hr, error, "pwszPropertyName: Invalid date property");
    }

    cbProp = sizeof(ftNotBefore);
    hr = prow->GetProperty(
		    g_wszPropCertificateNotBeforeDate,
		    Flags,
		    NULL,
		    &cbProp,
		    (BYTE *) &ftNotBefore);
    _JumpIfError(hr, error, "GetProperty");

    cbProp = sizeof(ftNotAfter);
    hr = prow->GetProperty(
		    g_wszPropCertificateNotAfterDate,
		    Flags,
		    NULL,
		    &cbProp,
		    (BYTE *) &ftNotAfter);
    _JumpIfError(hr, error, "GetProperty");

    if (0 > CompareFileTime(pft, &ftNotBefore) ||
	0 < CompareFileTime(pft, &ftNotAfter))
    {
	CERTSRVDBGPRINTTIME("Old Not Before", &ftNotBefore);
	CERTSRVDBGPRINTTIME(" Old Not After", &ftNotAfter);
	CERTSRVDBGPRINTTIME(
		0 == mylstrcmpiS(
			pwszPropertyName,
			g_wszPropCertificateNotBeforeDate)?
		    "New Not Before" : " New Not After",
		pft);

	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "FILETIME out of range", pwszPropertyName);
    }

error:
    return(myHError(hr));
}


// Returns TRUE if names match!

#define PROPNAMEMATCH(cwcNameVariable, pwszNameVariable, wszNameLiteral) \
    (WSZARRAYSIZE((wszNameLiteral)) == (cwcNameVariable) && \
     0 == LSTRCMPIS((pwszNameVariable), (wszNameLiteral)))

HRESULT
propGetSystemProperty(
    IN WCHAR const *pwszPropName,
    IN DWORD Flags, 
    IN LONG  Context,
    OUT BOOL *pfSystemProperty,
    OUT VARIANT *pvarPropertyValue)
{
    HRESULT hr = S_OK;
    BYTE *pbFree = NULL;
    DWORD cwcPropName;
    DWORD cwcBaseName;
    WCHAR wszBaseName[32];
    WCHAR const *pwszIndex;
    WCHAR wszRenewalSuffix[cwcFILENAMESUFFIXMAX];
    DWORD iCert = MAXDWORD;
    DWORD iCRL;
    DWORD iDummy;
    DWORD State;
    DWORD PropType;
    DWORD cbCopy;
    DWORD cbOut;
    BYTE const *pbOut = NULL;		// PROPTYPE_LONG or PROPTYPE_BINARY
    WCHAR const *pwszOut = NULL;	// PROPTYPE_STRING
    CRL_CONTEXT const *pCRL = NULL;
    CERTSRV_COM_CONTEXT *pComContext;
    BOOL fT;

    *pfSystemProperty = FALSE;
    wszRenewalSuffix[0] = L'\0';
    cbOut = 0;

    // Allow "PropName.#"
    // Copy the base part of the property name to a local buffer, so we can do
    // case ignore string compares.

    cwcPropName = wcslen(pwszPropName);

    cwcBaseName = wcscspn(pwszPropName, L".");
    if (ARRAYSIZE(wszBaseName) - 1 < cwcBaseName)
    {
	cwcBaseName = ARRAYSIZE(wszBaseName) - 1;
    }

    CopyMemory(wszBaseName, pwszPropName, cwcBaseName * sizeof(WCHAR));
    wszBaseName[cwcBaseName] = L'\0';

    pwszIndex = &pwszPropName[cwcBaseName];
    if (L'.' == *pwszIndex)
    {
	pwszIndex++;
	iCert = _wtol(pwszIndex);
	for ( ; L'\0' != *pwszIndex; pwszIndex++)
	{
	    if (!iswdigit(*pwszIndex))
	    {
		CSASSERT(S_OK == hr);	// Not a system property, return S_OK
		goto error;
	    }
	}
    }

    // Assume property type is a long:

    PropType = PROPTYPE_LONG;
    *pfSystemProperty = TRUE;

    if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPCATYPE))
    {
        pbOut = (BYTE const *) &g_CAType;
        cbOut = sizeof(g_CAType);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPUSEDS))
    {
        pbOut = (BYTE const *) &g_fUseDS;
        cbOut = sizeof(g_fUseDS);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPDELTACRLSDISABLED))
    {
        pbOut = (BYTE const *) &g_fDeltaCRLPublishDisabled;
        cbOut = sizeof(g_fDeltaCRLPublishDisabled);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPSERVERUPGRADED))
    {
        pbOut = (BYTE const *) &g_fServerUpgraded;
        cbOut = sizeof(g_fServerUpgraded);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPLOGLEVEL))
    {
        pbOut = (BYTE const *) &g_dwLogLevel;
        cbOut = sizeof(g_dwLogLevel);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPSESSIONCOUNT))
    {
        pbOut = (BYTE const *) &g_dwSessionCount;
        cbOut = sizeof(g_dwSessionCount);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPREQUESTERTOKEN))
    {
	hr = ComGetClientInfo(Context, MAXDWORD, &pComContext);
        _JumpIfError(hr, error, "ComGetClientInfo");

	if (NULL == pComContext->hAccessToken ||
	    INVALID_HANDLE_VALUE == pComContext->hAccessToken)
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    _JumpError(hr, error, "ComGetClientInfo(bad hAccessToken)");
	}
	pbOut = (BYTE const *) &pComContext->hAccessToken;
	cbOut = sizeof(pComContext->hAccessToken);
        PropType = PROPTYPE_BINARY;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPREQUESTERCAACCESS))
    {
	hr = ComGetClientInfo(Context, MAXDWORD, &pComContext);
        _JumpIfError(hr, error, "ComGetClientInfo");

	if (0 == (CCCF_INREQUESTGROUPSET & pComContext->dwFlags))
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    _JumpError(hr, error, "ComGetClientInfo(fInRequestGroup not set)");
	}
	fT = (CCCF_INREQUESTGROUP & pComContext->dwFlags)? TRUE : FALSE;
	pbOut = (BYTE const *) &fT;
	cbOut = sizeof(fT);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPKEYARCHIVED))
    {
	hr = ComGetClientInfo(Context, MAXDWORD, &pComContext);
        _JumpIfError(hr, error, "ComGetClientInfo");

	if (0 == (CCCF_KEYARCHIVEDSET & pComContext->dwFlags))
	{
	    hr = CoreSetArchivedKey(pComContext);
	    _JumpIfError(hr, error, "CoreSetArchivedKey");

	    CSASSERT(CCCF_KEYARCHIVEDSET & pComContext->dwFlags);
	}
	fT = (CCCF_KEYARCHIVED & pComContext->dwFlags)? TRUE : FALSE;
	pbOut = (BYTE const *) &fT;
	cbOut = sizeof(fT);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPUSERDN))
    {
	hr = ComGetClientInfo(Context, MAXDWORD, &pComContext);
        _JumpIfError(hr, error, "ComGetClientInfo");

	if (NULL == pComContext->pwszUserDN)
	{
	    if (!g_fUseDS)
	    {
		hr = CERTSRV_E_PROPERTY_EMPTY;
		_JumpError(hr, error, "ComGetClientInfo(bad pwszUserDN)");
	    }
	    hr = CoreSetComContextUserDN(
				pComContext->RequestId,
				Context,
				MAXDWORD,
				&pwszOut);
	    _JumpIfError(hr, error, "CoreSetComContextUserDN");
	}
	pwszOut = pComContext->pwszUserDN;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPCERTCOUNT))
    {
        pbOut = (BYTE const *) &g_cCACerts;
        cbOut = sizeof(g_cCACerts);
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPSANITIZEDCANAME))
    {
        pwszOut = g_wszSanitizedName;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPSANITIZEDSHORTNAME))
    {
        pwszOut = g_pwszSanitizedDSName;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPMACHINEDNSNAME))
    {
        pwszOut = g_pwszServerName;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPCONFIGDN))
    {
	pwszOut = g_strConfigDN;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPDOMAINDN))
    {
	pwszOut = g_strDomainDN;
    }
    else if (PROPNAMEMATCH(cwcPropName, pwszPropName, wszPROPMODULEREGLOC))
    {
        // future: cache storage location once it is built

        WCHAR *pwszQuasiPath;
        DWORD cwcQuasiPath;
	WCHAR const *pwszPrefix;
        MarshalInterface *pIF;

        if ((PROPCALLER_MASK & Flags) == PROPCALLER_POLICY)
	{
	    pIF = &g_miPolicy;
	    cwcQuasiPath = ARRAYSIZE(L"Policy\\");	// includes L'\0'
	    pwszPrefix = L"Policy\\";
	}
	else
	{
	    hr = ExitGetActiveModule(Context, &pIF);
            _JumpIfError(hr, error, "ExitGetActiveModule");
	    cwcQuasiPath = ARRAYSIZE(L"Exit\\");	// includes L'\0'
	    pwszPrefix = L"Exit\\";
	}

        cwcQuasiPath += wcslen(pIF->GetProgID());
        pwszQuasiPath = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    cwcQuasiPath * sizeof(WCHAR));
        if (NULL == pwszQuasiPath)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wcscpy(pwszQuasiPath, pwszPrefix);
        wcscat(pwszQuasiPath, pIF->GetProgID()); 

        hr = myRegOpenRelativeKey(
			    pIF->GetConfig(),
			    pwszQuasiPath,
			    RORKF_FULLPATH | RORKF_CREATESUBKEYS,
			    (WCHAR **) &pwszOut,
			    NULL,
			    NULL);
	LocalFree(pwszQuasiPath);
        _JumpIfError(hr, error, "myRegOpenRelativeKey");

	CSASSERT(NULL != pwszOut);
	pbFree = (BYTE *) pwszOut;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPRAWCACERTIFICATE))
    {
        hr = PKCSGetCACert(
		    CR_PROP_CASIGCERT,
		    iCert,
		    const_cast<BYTE **>(&pbOut),
		    &cbOut);	// not alloc'd
        _JumpIfError(hr, error, "PKCSGetCACert");

        PropType = PROPTYPE_BINARY;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPRAWCRL))
    {
        hr = CRLGetCRL(iCert, FALSE, &pCRL, NULL);
        _JumpIfError(hr, error, "CRLGetCRL");

        cbOut = pCRL->cbCrlEncoded;
        pbOut = pCRL->pbCrlEncoded;
        PropType = PROPTYPE_BINARY;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPRAWDELTACRL))
    {
        hr = CRLGetCRL(iCert, TRUE, &pCRL, NULL);
        _JumpIfError2(
		hr,
		error,
		"CRLGetCRL",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

        cbOut = pCRL->cbCrlEncoded;
        pbOut = pCRL->pbCrlEncoded;
        PropType = PROPTYPE_BINARY;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCERTSTATE))
    {
        hr = PKCSMapCertIndex(iCert, &iCert, &State);
        _JumpIfError(hr, error, "PKCSMapCertIndex");

        pbOut = (BYTE *) &State;
        cbOut = sizeof(State);
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCERTSUFFIX))
    {
        hr = PKCSMapCertIndex(iCert, &iCert, &State);
        _JumpIfError(hr, error, "PKCSMapCertIndex");

        pwszOut = wszRenewalSuffix;
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCRLINDEX))
    {
        hr = PKCSMapCRLIndex(iCert, &iCert, &iCRL, &State);
        _JumpIfError(hr, error, "PKCSMapCRLIndex");

        pbOut = (BYTE *) &iCRL;
        cbOut = sizeof(iCRL);
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCRLSTATE))
    {
        hr = PKCSMapCRLIndex(iCert, &iCert, &iCRL, &State);
        _JumpIfError(hr, error, "PKCSMapCRLIndex");

        pbOut = (BYTE *) &State;
        cbOut = sizeof(State);
    }
    else if (PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPCRLSUFFIX))
    {
        hr = PKCSMapCRLIndex(iCert, &iDummy, &iCert, &State);
        _JumpIfError(hr, error, "PKCSMapCRLIndex");

	pwszOut = wszRenewalSuffix;
    }
    else if(PROPNAMEMATCH(cwcBaseName, wszBaseName, wszPROPTEMPLATECHANGESEQUENCENUMBER))
    {
        pbOut = (BYTE const *) &g_cTemplateUpdateSequenceNum;
        cbOut = sizeof(g_cTemplateUpdateSequenceNum);
    }
    else
    {
        CSASSERT(S_OK == hr);	// Not a system property, return S_OK
	*pfSystemProperty = FALSE;
        goto error;
    }

    CSASSERT((NULL != pbOut) ^ (NULL != pwszOut)); // exactly 1 must be set

    cbCopy = cbOut;
    if (NULL != pwszOut)
    {
	if (wszRenewalSuffix == pwszOut && 0 != iCert)
	{
            wsprintf(wszRenewalSuffix, L"(%u)", iCert);
	}
	PropType = PROPTYPE_STRING;
	cbOut = wcslen(pwszOut) * sizeof(WCHAR);
	cbCopy = cbOut + sizeof(WCHAR);
	pbOut = (BYTE *) pwszOut;
    }

    if ((PROPTYPE_MASK & Flags) != PropType)
    {
	hr = E_INVALIDARG;
	_JumpError2(hr, error, "bad PropType", hr);
    }

    hr = myUnmarshalVariant(
		    PROPMARSHAL_LOCALSTRING | Flags,
		    cbOut,
		    pbOut,
		    pvarPropertyValue);
    _JumpIfError(hr, error, "myUnmarshalVariant");

error:
    if (NULL != pCRL)
    {
        CertFreeCRLContext(pCRL);
    }
    if (NULL != pbFree)
    {
	LocalFree(pbFree);
    }
    return(hr);
}

class CComputedProperty : public ICertDBComputedColumn
{
public:
    CComputedProperty();
    ~CComputedProperty();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    STDMETHOD(GetAlternateColumnId)(
	IN DWORD ComputedColumnId,
	OUT DWORD *pAlternateColumnId,
	OUT DWORD *pPropType);

    STDMETHOD(ComputeColumnValue)(
	IN DWORD ComputedColumnId,
	IN DWORD AlternateColumnId,
	IN DWORD PropType,
	IN DWORD cbProp,
	IN BYTE const *pbProp,
	OUT DWORD *pdwValue);

    HRESULT SavePropertyArgument(
	IN WCHAR const *pwszPropIn,
	OUT WCHAR **ppwszPropOut);

private:
    WCHAR *m_pwszArg;

    // Reference count
    long        m_cRef;
};


CComputedProperty::CComputedProperty()
{
    m_pwszArg = NULL;
    m_cRef = 1;
}


CComputedProperty::~CComputedProperty()
{
    if (NULL != m_pwszArg)
    {
        LocalFree(m_pwszArg);
    }
}


STDMETHODIMP
CComputedProperty::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertDBComputedColumn *>(this);
    }
    else if (iid == IID_ICertDBComputedColumn)
    {
	*ppv = static_cast<ICertDBComputedColumn *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CComputedProperty::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CComputedProperty::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


STDMETHODIMP
CComputedProperty::ComputeColumnValue(
    IN DWORD ComputedColumnId,
    IN DWORD AlternateColumnId,
    IN DWORD PropType,
    IN DWORD cbProp,
    IN BYTE const *pbProp,
    OUT DWORD *pdwValue)
{
    HRESULT hr;
    WCHAR const *pwszRequesterName;

    *pdwValue = 0;
    if (NULL == m_pwszArg)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "m_pwszArg NULL");
    }
    if ((DTI_REQUESTTABLE | DTR_OFFICER) != ComputedColumnId ||
	(DTI_REQUESTTABLE | DTR_REQUESTERNAME) != AlternateColumnId ||
	PROPTYPE_STRING != PropType ||
	0 == cbProp ||
	((sizeof(WCHAR) - 1) & cbProp))
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "ComputedColumnId");
    }
    pwszRequesterName = (WCHAR const *) pbProp;
    CSASSERT(L'\0' == pwszRequesterName[cbProp / sizeof(WCHAR)]);
    CSASSERT(sizeof(WCHAR) * wcslen(pwszRequesterName) == cbProp);

    hr = CheckOfficerRightsFromOfficerName(m_pwszArg, pwszRequesterName);
    if (S_OK == hr)
    {
	*pdwValue = 1;
    }
    else if (CERTSRV_E_RESTRICTEDOFFICER == hr)
    {
	hr = S_OK;
    }
    _JumpIfError(hr, error, "CheckOfficerRightsFromOfficerName");

error:
    DBGPRINT((
	DBG_SS_CERTSRV,
	"ComputeColumnValue(%ws) = %u  hr=%x\n",
	(WCHAR const *) pbProp,
	*pdwValue,
	hr));
    return(hr);
}


HRESULT
CComputedProperty::SavePropertyArgument(
    IN WCHAR const *pwszPropIn,
    OUT WCHAR **ppwszPropOut)
{
    HRESULT hr;
    WCHAR *pwszT;
    
    CSASSERT(NULL == m_pwszArg);
    hr = myDupString(pwszPropIn, ppwszPropOut);
    _JumpIfError(hr, error, "myDupString");

    pwszT = wcschr(*ppwszPropOut, wcLPAREN);
    if (NULL != pwszT)
    {
	WCHAR *pwsz2 = pwszT;

	while (--pwsz2 >= *ppwszPropOut && L' ' == *pwsz2)
	{
	    *pwsz2 = L'\0';
	}

	*pwszT++ = L'\0';
	while (L' ' == *pwszT)
	{
	    pwszT++;
	}
	hr = myDupString(pwszT, &m_pwszArg);
	_JumpIfError(hr, error, "myDupString");

	pwszT = wcschr(m_pwszArg, wcRPAREN);
	if (NULL == pwszT)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "SavePropertyArgument", pwszPropIn);
	}
	do 
	{
	    *pwszT-- = L'\0';
	} while (pwszT >= m_pwszArg && L' ' == *pwszT);
    }
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CComputedProperty::GetAlternateColumnId(
    IN DWORD ComputedColumnId,
    OUT DWORD *pAlternateColumnId,
    OUT DWORD *pPropType)
{
    HRESULT hr;

    *pAlternateColumnId = 0;
    if ((DTI_REQUESTTABLE | DTR_OFFICER) != ComputedColumnId)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "ComputedColumnId");
    }
    *pAlternateColumnId = DTI_REQUESTTABLE | DTR_REQUESTERNAME;
    *pPropType = PROPTYPE_STRING;
    hr = S_OK;

error:
    return(hr);
}


FNCIGETPROPERTY PropCIGetProperty;

HRESULT
PropCIGetProperty(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DWORD RequestId;
    DWORD cbprop;
    BYTE *pbprop = NULL;
    ICertDBRow *prow = NULL;
    BYTE rgbFastBuf[128];   // many properties are small (128)
    BOOL fSystemProperty;
    CComputedProperty ccp;
    WCHAR *pwszPropAlloc = NULL;

    if (NULL != pvarPropertyValue)
    {
	VariantInit(pvarPropertyValue);
    }
    if (NULL == pwszPropertyName || NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = E_INVALIDARG;
    if ((PROPCALLER_MASK & Flags) != PROPCALLER_POLICY &&
	(PROPCALLER_MASK & Flags) != PROPCALLER_EXIT &&
	(PROPCALLER_MASK & Flags) != PROPCALLER_SERVER)
    {
	_JumpError(hr, error, "Flags: Invalid caller");
    }

    if ((PROPTABLE_MASK & Flags) != PROPTABLE_REQUEST &&
	(PROPTABLE_MASK & Flags) != PROPTABLE_CERTIFICATE &&
	(PROPTABLE_MASK & Flags) != PROPTABLE_ATTRIBUTE)
    {
	_JumpError(hr, error, "Flags: Invalid table");
    }

    fSystemProperty = FALSE;
    if ((PROPTABLE_MASK & Flags) == PROPTABLE_CERTIFICATE)
    {
	hr = ComVerifyRequestContext(TRUE, Flags, Context, &RequestId);
	_JumpIfError(hr, error, "ComVerifyRequestContext");

	// Check for special, hard-coded properties first

	hr = propGetSystemProperty(
			    pwszPropertyName,
			    Flags, 
			    Context,
			    &fSystemProperty,
			    pvarPropertyValue);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "propGetSystemProperty",
		    pwszPropertyName,
		    E_INVALIDARG);
    }

    if (!fSystemProperty)
    {
	DWORD VerifyFlags = Flags;
	
	if (((PROPCALLER_MASK | PROPTABLE_MASK | PROPTYPE_MASK) & Flags) ==
	     (PROPCALLER_SERVER | PROPTABLE_REQUEST | PROPTYPE_LONG) &&
	    0 == LSTRCMPIS(pwszPropertyName, wszPROPREQUESTREQUESTID))
	{
	    VerifyFlags = PROPCALLER_EXIT | (~PROPCALLER_MASK & VerifyFlags);
	}
	hr = ComVerifyRequestContext(FALSE, VerifyFlags, Context, &RequestId);
	_JumpIfError(hr, error, "ComVerifyRequestContext");

        pbprop = rgbFastBuf;
        cbprop = sizeof(rgbFastBuf);

	// PROPCALLER_SERVER indicates this call is only for Context validation
	// -- return a zero RequestId.  This keeps CRL publication exit module
	// notification from failing.

	if (0 == RequestId &&
	    ((PROPCALLER_MASK | PROPTABLE_MASK | PROPTYPE_MASK) & Flags) ==
	     (PROPCALLER_SERVER | PROPTABLE_REQUEST | PROPTYPE_LONG) &&
	    0 == LSTRCMPIS(pwszPropertyName, wszPROPREQUESTREQUESTID))
	{
	    *(DWORD *) pbprop = 0;
	    cbprop = sizeof(DWORD);
	}
	else
	{
	    WCHAR const *pwszPropT;

	    if (PROPTYPE_STRING == (PROPTYPE_MASK & Flags) &&
		PROPTABLE_CERTIFICATE == (PROPTABLE_MASK & Flags))
	    {
		BOOL fSubjectDot;
		
		hr = PKCSVerifySubjectRDN(
				    NULL,	// prow
				    &pwszPropertyName,
				    NULL,	// pwszPropertyValue
				    &fSubjectDot);
		_JumpIfError(hr, error, "PKCSVerifySubjectRDN");
	    }
	    hr = g_pCertDB->OpenRow(
				PROPOPEN_READONLY | PROPTABLE_REQCERT,
				RequestId,
				NULL,
				&prow);
	    _JumpIfError(hr, error, "OpenRow");

	    if ((PROPTABLE_MASK & Flags) == PROPTABLE_REQUEST ||
		(PROPTABLE_MASK & Flags) == PROPTABLE_CERTIFICATE)
	    {
		hr = ccp.SavePropertyArgument(pwszPropertyName, &pwszPropAlloc);
		_JumpIfError(hr, error, "SavePropertyArgument");

		pwszPropT = pwszPropAlloc;
	    }
	    else
	    {
		pwszPropT = pwszPropertyName;
	    }

	    hr = prow->GetProperty(
			    pwszPropT,
			    Flags,
			    g_OfficerRightsSD.IsEnabled()? &ccp : NULL,
			    &cbprop,
			    pbprop);
	    if (S_OK != hr)
	    {
		if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
		{
		    _JumpIfError3(
			    hr,
			    error,
			    "GetProperty",
			    CERTSRV_E_PROPERTY_EMPTY,
			    E_INVALIDARG);
		}
		
		CSASSERT(ARRAYSIZE(rgbFastBuf) < cbprop);

		DBGPRINT((
		    DBG_SS_CERTSRVI,
		    "FastBuf miss: PropCIGetProperty - pbprop %i bytes\n",
		    cbprop));

		pbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
		if (NULL == pbprop)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		
		hr = prow->GetProperty(
				pwszPropT,
				Flags,
				g_OfficerRightsSD.IsEnabled()? &ccp : NULL,
				&cbprop,
				pbprop);
		_JumpIfError(hr, error, "GetProperty");
	    }
        } // property is in-hand

        if ((((PROPTABLE_MASK | PROPTYPE_MASK) & Flags) ==
	        (PROPTABLE_REQUEST | PROPTYPE_BINARY)) &&
           (0 == LSTRCMPIS(pwszPropertyName, wszPROPREQUESTRAWARCHIVEDKEY) ||
            0 == LSTRCMPIS(pwszPropertyName, 
                          wszPROPREQUESTDOT wszPROPREQUESTRAWARCHIVEDKEY)))
        {
            *pbprop = 0;
            cbprop = sizeof(*pbprop);
        }

        hr = myUnmarshalVariant(
		        PROPMARSHAL_LOCALSTRING | Flags,
		        cbprop,
		        pbprop,
		        pvarPropertyValue);
        _JumpIfError(hr, error, "myUnmarshalVariant");
    }

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pbprop && pbprop != rgbFastBuf)
    {
    	LocalFree(pbprop);
    }
    if (NULL != pwszPropAlloc)
    {
    	LocalFree(pwszPropAlloc);
    }
    return(myHError(hr));
}


HRESULT
propSetSystemProperty(
    IN WCHAR const *pwszPropName,
    IN DWORD Flags, 
    OUT BOOL *pfSystemProperty,
    IN VARIANT const *pvarPropertyValue)
{
    HRESULT hr = S_OK;
    DWORD LogLevel = MAXDWORD;
    DWORD infotype = EVENTLOG_INFORMATION_TYPE;
    DWORD LogMsg = MSG_POLICY_LOG_INFORMATION;
    WCHAR *pwsz = NULL;
    DWORD cwcMax;

    *pfSystemProperty = FALSE;
    cwcMax = 1;

    if (0 == LSTRCMPIS(pwszPropName, wszPROPEVENTLOGTERSE))
    {
	LogLevel = CERTLOG_TERSE;
    }
    else
    if (0 == LSTRCMPIS(pwszPropName, wszPROPEVENTLOGERROR))
    {
	LogLevel = CERTLOG_ERROR;
	infotype = EVENTLOG_ERROR_TYPE;
	LogMsg = MSG_POLICY_LOG_ERROR;
    }
    else
    if (0 == LSTRCMPIS(pwszPropName, wszPROPEVENTLOGWARNING))
    {
	LogLevel = CERTLOG_WARNING;
	infotype = EVENTLOG_WARNING_TYPE;
	LogMsg = MSG_POLICY_LOG_WARNING;
    }
    else
    if (0 == LSTRCMPIS(pwszPropName, wszPROPEVENTLOGVERBOSE))
    {
	LogLevel = CERTLOG_VERBOSE;
    }
    else
    if (0 == LSTRCMPIS(pwszPropName, wszPROPDCNAME))
    {
	pwsz = g_wszPolicyDCName;
	cwcMax = g_cwcPolicyDCName;
    }
    else
    {
        CSASSERT(S_OK == hr);	// Not a system property, return S_OK
        goto error;
    }
    *pfSystemProperty = TRUE;

    if (PROPTYPE_STRING != (PROPTYPE_MASK & Flags) ||
	VT_BSTR != pvarPropertyValue->vt ||
	NULL == pvarPropertyValue->bstrVal)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "string property value/type", pwszPropName);
    }

    if (NULL != pwsz)
    {
	// Terminate first to avoid problems with multi-threaded access.

	pwsz[cwcMax - 1] = L'\0';
	wcsncpy(pwsz, pvarPropertyValue->bstrVal, cwcMax - 1);
    }
    else
    {
	CSASSERT(MAXDWORD != LogLevel);
	if (LogLevel <= g_dwLogLevel)
	{
	    WCHAR const *apwsz[2];
	    WCHAR const *pwszMessage = pvarPropertyValue->bstrVal;
	    HRESULT hrPrefix;

	    if (ComParseErrorPrefix(
			    pvarPropertyValue->bstrVal,
			    &hrPrefix,
			    &pwszMessage))
	    {
	    }
	    else
	    {
		pwszMessage = pvarPropertyValue->bstrVal;
	    }
	    apwsz[0] = g_strPolicyDescription;
	    apwsz[1] = pwszMessage;

	    hr = LogEvent(infotype, LogMsg, ARRAYSIZE(apwsz), apwsz);
	    _JumpIfError(hr, error, "LogEvent");
	}
    }
    hr = S_OK;

error:
    return(myHError(hr));
}


FNCISETPROPERTY PropCISetProperty;

HRESULT
PropCISetProperty(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN VARIANT const *pvarPropertyValue)
{
    HRESULT hr;
    DWORD RequestId;
    DWORD cbprop;
    BYTE *pbprop = NULL;
    ICertDBRow *prow = NULL;
    BOOL fSubjectDot = FALSE;
    BOOL fSystemProperty;
    BOOL fCommitted = FALSE;
    
    if (NULL == pwszPropertyName || NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = E_INVALIDARG;
    if ((PROPCALLER_MASK & Flags) != PROPCALLER_POLICY)
    {
	_JumpError(hr, error, "Flags: Invalid caller");
    }
    if ((PROPTABLE_MASK & Flags) != PROPTABLE_CERTIFICATE)
    {
	_JumpError(hr, error, "Flags: Invalid table");
    }

    hr = ComVerifyRequestContext(TRUE, Flags, Context, &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    // Check for special, hard-coded properties first

    fSystemProperty = FALSE;
    hr = propSetSystemProperty(
			pwszPropertyName,
			Flags, 
			&fSystemProperty,
			pvarPropertyValue);
    _JumpIfError(hr, error, "propSetSystemProperty");

    if (!fSystemProperty)
    {
	hr = ComVerifyRequestContext(FALSE, Flags, Context, &RequestId);
	_JumpIfError(hr, error, "ComVerifyRequestContext");

	hr = myMarshalVariant(
			pvarPropertyValue,
			PROPMARSHAL_NULLBSTROK | PROPMARSHAL_LOCALSTRING | Flags,
			&cbprop,
			&pbprop);
	_JumpIfError(hr, error, "myMarshalVariant");

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, RequestId, NULL, &prow);
	_JumpIfError(hr, error, "OpenRow");

	if (PROPTYPE_DATE == (PROPTYPE_MASK & Flags))
	{
	    hr = propVerifyDateRange(
				prow,
				Flags,
				pwszPropertyName,
				(FILETIME *) pbprop);
	    _JumpIfError(hr, error, "propVerifyDateRange");
	}
	else
	if (PROPTYPE_STRING == (PROPTYPE_MASK & Flags) &&
	    PROPTABLE_CERTIFICATE == (PROPTABLE_MASK & Flags))
	{
	    hr = PKCSVerifySubjectRDN(
				prow,
				&pwszPropertyName,
				(WCHAR const *) pbprop,
				&fSubjectDot);
	    _JumpIfError(hr, error, "PKCSVerifySubjectRDN");
	}

	if (NULL == pbprop && fSubjectDot)
	{
	    hr = PKCSDeleteAllSubjectRDNs(prow, Flags);
	    _JumpIfError(hr, error, "PKCSDeleteAllSubjectRDNs");
	}
	else
	{
	    hr = prow->SetProperty(pwszPropertyName, Flags, cbprop, pbprop);
	    _JumpIfError(hr, error, "SetProperty");
	}

	hr = prow->CommitTransaction(CDBROW_COMMIT_SOFTCOMMIT);	// not critical to flush
	_JumpIfError(hr, error, "CommitTransaction");

	fCommitted = TRUE;
    }
    hr = S_OK;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(CDBROW_COMMIT_ROLLBACK);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pbprop)
    {
	LocalFree(pbprop);
    }
    return(myHError(hr));
}


HRESULT
PropGetExtension(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue)    // LocalAlloc
{
    HRESULT hr;
    DWORD cbprop;
    BYTE *pbprop = NULL;

    CSASSERT(
	PROPCALLER_EXIT == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_POLICY == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_SERVER == (PROPCALLER_MASK & Flags));

    CSASSERT(0 == (~(PROPMARSHAL_LOCALSTRING | PROPCALLER_MASK | PROPTYPE_MASK) & Flags));

    hr = myVerifyObjId(pwszExtensionName);
    _JumpIfError(hr, error, "myVerifyObjId");

    cbprop = 0;
    hr = prow->GetExtension(pwszExtensionName, pdwExtFlags, &cbprop, NULL);
    _JumpIfError2(hr, error, "GetExtension(NULL)", CERTSRV_E_PROPERTY_EMPTY);

    pbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
    if (NULL == pbprop)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc(ExtValue)");
    }

    hr = prow->GetExtension(pwszExtensionName, pdwExtFlags, &cbprop, pbprop);
    _JumpIfError(hr, error, "GetExtension");

    if (PROPTYPE_BINARY == (PROPTYPE_MASK & Flags))
    {
	*pcbValue = cbprop;
	*ppbValue = pbprop;
	pbprop = NULL;
    }
    else
    {
	hr = myDecodeExtension(Flags, pbprop, cbprop, ppbValue, pcbValue);
	_JumpIfError(hr, error, "myDecodeExtension");
    }

error:
    if (NULL != pbprop)
    {
	LocalFree(pbprop);
    }
    return(myHError(hr));
}


HRESULT
PropSetExtension(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN DWORD cbValue,
    IN BYTE const *pbValue)
{
    HRESULT hr;
    DWORD cbprop;
    BYTE *pbprop = NULL;

    CSASSERT(
	PROPCALLER_ADMIN == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_POLICY == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_SERVER == (PROPCALLER_MASK & Flags) ||
	PROPCALLER_REQUEST == (PROPCALLER_MASK & Flags));

    CSASSERT(0 == (~(PROPMARSHAL_LOCALSTRING | PROPCALLER_MASK | PROPTYPE_MASK) & Flags));

    hr = myVerifyObjId(pwszExtensionName);
    _JumpIfError(hr, error, "myVerifyObjId");

    if (PROPTYPE_BINARY == (PROPTYPE_MASK & Flags))
    {
	cbprop = cbValue;
	pbprop = (BYTE *) pbValue;
    }
    else
    {
	hr = myEncodeExtension(Flags, pbValue, cbValue, &pbprop, &cbprop);
	_JumpIfError(hr, error, "myEncodeExtension");
    }

    hr = prow->SetExtension(pwszExtensionName, ExtFlags, cbprop, pbprop);
    _JumpIfError(hr, error, "SetExtension");

error:
    if (NULL != pbprop && pbprop != pbValue)
    {
	LocalFree(pbprop);
    }
    return(hr);
}


FNCIGETEXTENSION PropCIGetExtension;

HRESULT
PropCIGetExtension(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT VARIANT *pvarValue)
{
    HRESULT hr;
    DWORD RequestId;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    ICertDBRow *prow = NULL;

    if (NULL != pvarValue)
    {
	VariantInit(pvarValue);
    }
    if (NULL == pwszExtensionName || NULL == pdwExtFlags || NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = ComVerifyRequestContext(FALSE, Flags, Context, &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    hr = g_pCertDB->OpenRow(PROPOPEN_READONLY | PROPTABLE_REQCERT, RequestId, NULL, &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PropGetExtension(
		    prow,
		    PROPMARSHAL_LOCALSTRING | Flags,
		    pwszExtensionName,
		    pdwExtFlags,
		    &cbValue,
		    &pbValue);
    _JumpIfError2(hr, error, "PropGetExtension", CERTSRV_E_PROPERTY_EMPTY);

    hr = myUnmarshalVariant(
		    PROPMARSHAL_LOCALSTRING | Flags,
		    cbValue,
		    pbValue,
		    pvarValue);
    _JumpIfError(hr, error, "myUnmarshalVariant");

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    return(hr);
}


FNCISETPROPERTY PropCISetExtension;

HRESULT
PropCISetExtension(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN VARIANT const *pvarValue)
{
    HRESULT hr;
    DWORD RequestId;
    DWORD cbprop;
    BYTE *pbprop = NULL;
    ICertDBRow *prow = NULL;
    BOOL fCommitted = FALSE;
    
    if (NULL == pwszExtensionName || NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if ((PROPCALLER_MASK & Flags) != PROPCALLER_POLICY)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags: Invalid caller");
    }
    hr = ComVerifyRequestContext(FALSE, Flags, Context, &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    hr = myMarshalVariant(
		    pvarValue,
		    PROPMARSHAL_LOCALSTRING | Flags,
		    &cbprop,
		    &pbprop);
    _JumpIfError(hr, error, "myMarshalVariant");

    hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, RequestId, NULL, &prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PropSetExtension(
		    prow,
		    PROPMARSHAL_LOCALSTRING | Flags,
		    pwszExtensionName,
		    ExtFlags,
		    cbprop,
		    pbprop);
    _JumpIfError(hr, error, "PropSetExtension");

    hr = prow->CommitTransaction(CDBROW_COMMIT_SOFTCOMMIT);	// not critical to flush
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(CDBROW_COMMIT_ROLLBACK);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pbprop)
    {
	LocalFree(pbprop);
    }
    return(myHError(hr));
}


FNCIENUMSETUP PropCIEnumSetup;

HRESULT
PropCIEnumSetup(
    IN LONG Context,
    IN LONG Flags,
    IN OUT CIENUM *pciEnum)
{
    HRESULT hr;
    DWORD RequestId;
    
    CSASSERT(CSExpr(CIE_CALLER_POLICY == PROPCALLER_POLICY));
    CSASSERT(CSExpr(CIE_CALLER_EXIT == PROPCALLER_EXIT));
    CSASSERT(CSExpr(CIE_CALLER_MASK == PROPCALLER_MASK));
    
    hr = ComVerifyRequestContext(FALSE, Flags, Context, &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    hr = pciEnum->EnumSetup(RequestId, Context, Flags);
    _JumpIfError(hr, error, "EnumSetup");

error:
    return(hr);
}


FNCIENUMNEXT PropCIEnumNext;

HRESULT
PropCIEnumNext(
    IN OUT CIENUM *pciEnum,
    OUT BSTR *pstrPropertyName)
{
    HRESULT hr;
    DWORD RequestId;

    CSASSERT(CSExpr(CIE_CALLER_POLICY == PROPCALLER_POLICY));
    CSASSERT(CSExpr(CIE_CALLER_EXIT == PROPCALLER_EXIT));
    CSASSERT(CSExpr(CIE_CALLER_MASK == PROPCALLER_MASK));
    
    hr = ComVerifyRequestContext(
			    FALSE,
			    pciEnum->GetFlags(),
			    pciEnum->GetContext(),
			    &RequestId);
    _JumpIfError(hr, error, "ComVerifyRequestContext");

    hr = pciEnum->EnumNext(pstrPropertyName);
    _JumpIfError2(hr, error, "EnumNext", S_FALSE);

error:
    return(hr);
}


FNCIENUMCLOSE PropCIEnumClose;

HRESULT
PropCIEnumClose(
    IN OUT CIENUM *pciEnum)
{
    HRESULT hr;
    
    hr = pciEnum->EnumClose();
    _JumpIfError(hr, error, "EnumClose");

error:
    return(hr);
}


HRESULT
PropSetAttributeProperty(
    IN ICertDBRow *prow,
    IN BOOL fConcatenateRDNs,
    IN BOOL fPrependNewValue,
    IN DWORD dwTable,
    IN DWORD cwcNameMax,
    OPTIONAL IN WCHAR const *pwszSuffix,
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValue)
{
    HRESULT hr = S_OK;
    WCHAR *pwszTemp = NULL;
    WCHAR const *pwszValue2 = pwszValue;
    DWORD cbProp;
    DWORD dwFlags = dwTable | PROPTYPE_STRING | PROPCALLER_SERVER;

    CSASSERT(
	PROPTABLE_ATTRIBUTE == dwTable ||
	PROPTABLE_REQUEST == dwTable ||
	PROPTABLE_CERTIFICATE == dwTable);


    // if the name and value are both non-empty ...

    if (NULL != pwszName && L'\0' != *pwszName &&
	NULL != pwszValue && L'\0' != *pwszValue)
    {
	if (PROPTABLE_ATTRIBUTE != dwTable)
	{
	    if (g_fEnforceRDNNameLengths && wcslen(pwszValue) > cwcNameMax)
	    {
		hr = CERTSRV_E_BAD_REQUESTSUBJECT;
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "RDN component too long: %u/%u: %ws=\"%ws\"\n",
		    wcslen(pwszValue),
		    cwcNameMax,
		    pwszName,
		    pwszValue));
		_JumpErrorStr(hr, error, "RDN component too long", pwszValue);
	    }
	    if (fConcatenateRDNs)
	    {
		cbProp = 0;
		hr = prow->GetProperty(pwszName, dwFlags, NULL, &cbProp, NULL);
		if (CERTSRV_E_PROPERTY_EMPTY != hr)
		{
		    DWORD cwcAdd;
		    
		    _JumpIfError(hr, error, "GetProperty");

		    cwcAdd = 1 + wcslen(pwszValue);

                    // cbProp includes trailing L'\0' when out buffer is NULL

		    pwszTemp = (WCHAR *) LocalAlloc(
					    LMEM_FIXED,
					    cbProp + sizeof(WCHAR) * cwcAdd);
		    if (NULL == pwszTemp)
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		    }

                    // If there are multiple RDN components for the same DB
                    // column, concatenate them.

		    if (fPrependNewValue)
		    {
			wcscpy(pwszTemp, pwszValue);
			wcscat(pwszTemp, wszNAMESEPARATORDEFAULT);
			CSASSERT(wcslen(pwszTemp) == cwcAdd);
		    }

		    hr = prow->GetProperty(
			    pwszName,
			    dwFlags,
			    NULL,
			    &cbProp,
			    (BYTE *) &pwszTemp[fPrependNewValue? cwcAdd : 0]);
		    _JumpIfError(hr, error, "GetProperty");

                    // If there are multiple RDN components for the same DB
                    // column, concatenate them.

		    if (!fPrependNewValue)
		    {
			wcscat(pwszTemp, wszNAMESEPARATORDEFAULT);
			wcscat(pwszTemp, pwszValue);
		    }
		    pwszValue2 = pwszTemp;

                    // cbProp now does NOT include trailing L'\0'

                    CSASSERT(
			sizeof(WCHAR) * wcslen(pwszTemp) ==
			cbProp + sizeof(WCHAR) * cwcAdd);
		}
	    }
	    else if (NULL != pwszSuffix)
	    {
		hr = myAddNameSuffix(
				pwszValue,
				pwszSuffix,
				cwcNameMax,
				&pwszTemp);
		_JumpIfError(hr, error, "myAddNameSuffix");
		
		pwszValue2 = pwszTemp;
	    }
	}
	hr = prow->SetProperty(
			pwszName,
			dwFlags,
			MAXDWORD,
			(BYTE const *) pwszValue2);
	_JumpIfError(hr, error, "SetProperty");
    }

error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\event.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999 - 2000
//
// File:        event.cpp
//
// Contents:    Cert CAuditEvent class implementation
//
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop
#include <sid.h>
#include <authzi.h>

#define __dwFILE__	__dwFILE_CERTSRV_EVENT_CPP__


using namespace CertSrv;

CAuditEvent::AUDIT_CATEGORIES cat[] = 
{    // event ID                            // event category         no of   check role separation
                                                                    //args    for this event
    {SE_AUDITID_CERTSRV_SHUTDOWN,           AUDIT_FILTER_STARTSTOP,    0,   TRUE},
    {SE_AUDITID_CERTSRV_SERVICESTART,       AUDIT_FILTER_STARTSTOP,    4,   FALSE},
    {SE_AUDITID_CERTSRV_SERVICESTOP,        AUDIT_FILTER_STARTSTOP,    4,   FALSE},

    {SE_AUDITID_CERTSRV_BACKUPSTART,        AUDIT_FILTER_BACKUPRESTORE,1,   TRUE},
    {SE_AUDITID_CERTSRV_BACKUPEND,          AUDIT_FILTER_BACKUPRESTORE,0,   TRUE},
    {SE_AUDITID_CERTSRV_RESTORESTART,       AUDIT_FILTER_BACKUPRESTORE,0,   FALSE},
    {SE_AUDITID_CERTSRV_RESTOREEND,         AUDIT_FILTER_BACKUPRESTORE,0,   FALSE},

    {SE_AUDITID_CERTSRV_DENYREQUEST,        AUDIT_FILTER_CERTIFICATE,  1,   TRUE},
    {SE_AUDITID_CERTSRV_RESUBMITREQUEST,    AUDIT_FILTER_CERTIFICATE,  1,   TRUE},
    {SE_AUDITID_CERTSRV_SETEXTENSION,       AUDIT_FILTER_CERTIFICATE,  5,   TRUE},
    {SE_AUDITID_CERTSRV_SETATTRIBUTES,      AUDIT_FILTER_CERTIFICATE,  2,   TRUE},
    {SE_AUDITID_CERTSRV_IMPORTCERT,         AUDIT_FILTER_CERTIFICATE,  2,   TRUE},
    {SE_AUDITID_CERTSRV_NEWREQUEST,         AUDIT_FILTER_CERTIFICATE,  3,   FALSE},
    {SE_AUDITID_CERTSRV_REQUESTAPPROVED,    AUDIT_FILTER_CERTIFICATE,  6,   FALSE},
    {SE_AUDITID_CERTSRV_REQUESTDENIED,      AUDIT_FILTER_CERTIFICATE,  6,   FALSE},
    {SE_AUDITID_CERTSRV_REQUESTPENDING,     AUDIT_FILTER_CERTIFICATE,  6,   FALSE},
    {SE_AUDITID_CERTSRV_DELETEROW,          AUDIT_FILTER_CERTIFICATE,  3,   TRUE},
    {SE_AUDITID_CERTSRV_PUBLISHCACERT,      AUDIT_FILTER_CERTIFICATE,  3,   FALSE},

    {SE_AUDITID_CERTSRV_REVOKECERT,         AUDIT_FILTER_CERTREVOCATION, 2, TRUE},
    {SE_AUDITID_CERTSRV_PUBLISHCRL,         AUDIT_FILTER_CERTREVOCATION, 3, TRUE},
    {SE_AUDITID_CERTSRV_AUTOPUBLISHCRL,     AUDIT_FILTER_CERTREVOCATION, 5, FALSE},

    {SE_AUDITID_CERTSRV_SETSECURITY,        AUDIT_FILTER_CASECURITY,   1,   TRUE},
    {SE_AUDITID_CERTSRV_SETAUDITFILTER,     AUDIT_FILTER_CASECURITY,   1,   TRUE},
    {SE_AUDITID_CERTSRV_SETOFFICERRIGHTS,   AUDIT_FILTER_CASECURITY,   2,   TRUE},
    {SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE,AUDIT_FILTER_CASECURITY,   1,   FALSE},

    {SE_AUDITID_CERTSRV_GETARCHIVEDKEY,     AUDIT_FILTER_KEYAARCHIVAL, 1,   TRUE},
    {SE_AUDITID_CERTSRV_KEYARCHIVED,        AUDIT_FILTER_KEYAARCHIVAL, 3,   FALSE},
    {SE_AUDITID_CERTSRV_IMPORTKEY,          AUDIT_FILTER_KEYAARCHIVAL, 1,   TRUE},

    {SE_AUDITID_CERTSRV_SETCONFIGENTRY,     AUDIT_FILTER_CACONFIG,     3,   TRUE},
    {SE_AUDITID_CERTSRV_SETCAPROPERTY,      AUDIT_FILTER_CACONFIG,     4,   TRUE},
};
CAuditEvent::AUDIT_CATEGORIES *CAuditEvent::m_gAuditCategories = cat;

DWORD CAuditEvent::m_gdwAuditCategoriesSize = sizeof(cat)/sizeof(cat[0]);

bool CAuditEvent::m_gfRoleSeparationEnabled = false;

CAuditEvent::CAuditEvent(ULONG ulEventID, DWORD dwFilter) :
    m_cEventData(0),
    m_cRequiredEventData(0),
    m_dwFilter(dwFilter),
    m_fRoleSeparationEnabled(false),
    m_pISS(NULL),
    m_hClientToken(NULL),
    m_pCASD(NULL),
    m_ClientContext(NULL),
    m_pSDPrivileges(NULL),
    m_pDaclPrivileges(NULL),
    m_hRpc(NULL),
    m_Error(0),
    m_MaskAllowed(0),
    m_crtGUID(0),
    m_pUserSid(NULL),
    m_hAuditEventType(NULL)
{
    m_AuthzHandle = NULL;

    m_Request.ObjectTypeList = NULL;
    m_Request.PrincipalSelfSid = NULL;
    m_Request.ObjectTypeListLength = 0;
    m_Request.OptionalArguments = NULL;

    m_Reply.ResultListLength = 1;
    m_Reply.GrantedAccessMask = &m_MaskAllowed;
    m_Reply.Error = &m_Error;
    m_Reply.SaclEvaluationResults = &m_SaclEval;

    SetEventID(ulEventID);
};

// initializes internal data associated with a particular audit event
void CAuditEvent::SetEventID(ULONG ulEventID)
{
    m_ulEventID = ulEventID;

    for(DWORD c=0; c<m_gdwAuditCategoriesSize; c++)
    {
        if(((DWORD)m_ulEventID)==((DWORD)m_gAuditCategories[c].ulAuditID))
        {
            m_fRoleSeparationEnabled = 
                m_gAuditCategories[c].fRoleSeparationEnabled;

            m_cRequiredEventData = m_gAuditCategories[c].dwParamCount;

            CSASSERT(m_EventDataMaxSize>=m_cRequiredEventData);

            if(!m_gAuditCategories[c].hAuditEventType)
            {
                AuthziInitializeAuditEventType(
                    0,
                    SE_CATEGID_OBJECT_ACCESS,
                    (USHORT)m_ulEventID,
                    (USHORT)m_gAuditCategories[c].dwParamCount,
                    &m_gAuditCategories[c].hAuditEventType);

            }
            m_hAuditEventType = m_gAuditCategories[c].hAuditEventType;
            break;
        }
    }
}

CAuditEvent::~CAuditEvent()
{
    for(DWORD cData=0;cData<m_cEventData;cData++)
        delete m_pEventDataList[cData];

    FreeCachedHandles();
}

void CAuditEvent::CleanupAuditEventTypeHandles()
{
    for(DWORD c=0; c<m_gdwAuditCategoriesSize; c++)
    {
        if(m_gAuditCategories[c].hAuditEventType)
        {
            AuthziFreeAuditEventType(m_gAuditCategories[c].hAuditEventType);
        }
    }
}

bool CAuditEvent::IsEventValid()
{
    for(DWORD c=0; c<m_gdwAuditCategoriesSize; c++)
    {
        if(m_ulEventID==m_gAuditCategories[c].ulAuditID)
            return true;
    }
    return false;
}

bool CAuditEvent::IsEventEnabled()
{
    if(0==m_ulEventID) // event is used for access check only
        return false;

    for(DWORD c=0; c<m_gdwAuditCategoriesSize; c++)
    {
        if(((DWORD)m_ulEventID)==((DWORD)m_gAuditCategories[c].ulAuditID))
        {
            return (m_dwFilter&m_gAuditCategories[c].dwFilter)?true:false;
        }
    }
    // if get here the event has an unknown ID
    CSASSERT(CSExpr(!L"Invalid event found"));
    return false;
}

inline bool CAuditEvent::IsEventRoleSeparationEnabled()
{
    return RoleSeparationIsEnabled() && m_fRoleSeparationEnabled;
}

HRESULT CAuditEvent::AddData(DWORD dwValue)
{
    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_UI4;
    V_UI4(pvtData) = dwValue;
    return S_OK;
}

HRESULT CAuditEvent::AddData(PBYTE pData, DWORD dwDataLen)
{
    CSASSERT(pData && dwDataLen);

    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_BLOB;
    pvtData->blob.cbSize = dwDataLen;
    pvtData->blob.pBlobData = (BYTE*)CoTaskMemAlloc(dwDataLen);
    if(!pvtData->blob.pBlobData)
    {
        return E_OUTOFMEMORY;
    }
    memcpy(pvtData->blob.pBlobData, pData, dwDataLen);
    return S_OK;
}

HRESULT CAuditEvent::AddData(bool fData)
{
    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_BOOL;
    V_BOOL(pvtData) = fData?VARIANT_TRUE:VARIANT_FALSE;
    return S_OK;
}

HRESULT CAuditEvent::AddData(LPCWSTR pcwszData)
{
    if(!pcwszData)
        pcwszData = L"";

    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_LPWSTR;
    pvtData->pwszVal = 
        (LPWSTR)CoTaskMemAlloc((wcslen(pcwszData)+1)*sizeof(WCHAR));
    if(!pvtData->pwszVal)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(pvtData->pwszVal, pcwszData);
    return S_OK;
}

HRESULT CAuditEvent::AddData(LPCWSTR *ppcwszData)
{
    CSASSERT(ppcwszData);

    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_LPWSTR;

    DWORD dwTextLen = 1;

    for(LPCWSTR *ppcwszStr=ppcwszData; *ppcwszStr; ppcwszStr++)
    {
        dwTextLen += wcslen(*ppcwszStr)+2;
    }
    
    pvtData->pwszVal = 
        (LPWSTR)CoTaskMemAlloc(dwTextLen*sizeof(WCHAR));
    if(!pvtData->pwszVal)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(pvtData->pwszVal, L"");
    for(ppcwszStr=ppcwszData;  *ppcwszStr; ppcwszStr++)
    {
        wcscat(pvtData->pwszVal, *ppcwszStr);
        wcscat(pvtData->pwszVal, L"; ");
    }
    return S_OK;
}

HRESULT CAuditEvent::AddData(FILETIME time)
{
    PROPVARIANT *pvtData = CreateNewEventData();
    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }

    FILETIME ftZero = {0,0};
    #define wszTIMEZERO	L"0"

    if(0 == CompareFileTime(&time, &ftZero))
    {
        V_VT(pvtData) = VT_LPWSTR;
        pvtData->pwszVal = (LPWSTR) CoTaskMemAlloc(sizeof(wszTIMEZERO));
	if (NULL == pvtData->pwszVal)
	{
            return E_OUTOFMEMORY;
        }
        wcscpy(pvtData->pwszVal, wszTIMEZERO);
    }
    else
    {
        V_VT(pvtData) = VT_FILETIME;
        pvtData->filetime = time;
    }
    return S_OK;
}

HRESULT CAuditEvent::AddData(const VARIANT *pvar, bool fDoublePercentInStrings=false)
{
    CSASSERT(pvar);

    EventData *pData = CreateNewEventData1();
    if(!pData)
    {
        return E_OUTOFMEMORY;
    }
    pData->m_fDoublePercentsInStrings = fDoublePercentInStrings;

    HRESULT hr = VariantCopy((VARIANT*)&pData->m_vtData, (VARIANT*)pvar);
    myRegisterMemAlloc((VARIANT *) &pData->m_vtData, 0, CSM_VARIANT);

    return hr;
}


HRESULT CAuditEvent::AddData(ULARGE_INTEGER *puliValue)
{
    PROPVARIANT *pvtData = CreateNewEventData();
    DWORD dwDataLen = sizeof(*puliValue);

    if(!pvtData)
    {
        return E_OUTOFMEMORY;
    }
    V_VT(pvtData) = VT_UI8;
    memcpy(&pvtData->uhVal, puliValue, dwDataLen);
    return S_OK;
}

PROPVARIANT *CAuditEvent::CreateNewEventData()
{
    EventData *pData = CreateNewEventData1();
    return &pData->m_vtData;
}

CAuditEvent::EventData *CAuditEvent::CreateNewEventData1()
{
    EventData *pData = new EventData;
    if(!pData)
    {
        return NULL;
    }
    m_pEventDataList[m_cEventData++] = pData;
    return pData;
}


HRESULT ConvertToStringBOOL(
    BOOL fVal,
    LPWSTR *ppwszOut)

{
    LPCWSTR pwszBoolVal = 
        fVal==VARIANT_TRUE?
        g_pwszYes:
        g_pwszNo;

    *ppwszOut = (LPWSTR) LocalAlloc(
        LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(pwszBoolVal)+1));

    if(!*ppwszOut)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(*ppwszOut, pwszBoolVal);
    return S_OK;
}

HRESULT CAuditEvent::EventData::ConvertToString(LPWSTR *ppwszValue)
{
    HRESULT hr = S_OK;
    switch(V_VT(&m_vtData))
    {
    case VT_I2:
        hr = ConvertToStringI2I4(V_I2(&m_vtData), ppwszValue);
        break;
    case VT_BYREF|VT_I2:
        hr = ConvertToStringI2I4(*V_I2REF(&m_vtData), ppwszValue);
        break;
    case VT_I4:
        hr = ConvertToStringI2I4(V_I4(&m_vtData), ppwszValue);
        break;
    case VT_BYREF|VT_I4:
        hr = ConvertToStringI2I4(*V_I4REF(&m_vtData), ppwszValue);
        break;
    case VT_UI2:
        hr = ConvertToStringUI2UI4(V_UI2(&m_vtData), ppwszValue);
        break;
    case VT_BYREF|VT_UI2:
        hr = ConvertToStringUI2UI4(*V_UI2REF(&m_vtData), ppwszValue);
        break;
    case VT_UI4:
        hr = ConvertToStringUI2UI4(V_UI4(&m_vtData), ppwszValue);
        break;
    case VT_BYREF|VT_UI4:
        hr = ConvertToStringUI2UI4(*V_UI4REF(&m_vtData), ppwszValue);
        break;

    case VT_BLOB:
	// We don't call CryptBinaryToString directly anywhere in the CA tree.
	// This avoids errors when linking in the CryptBinaryToString code
	// for NT 4 reskit builds.

        hr = myCryptBinaryToString(
                m_vtData.blob.pBlobData,
                m_vtData.blob.cbSize,
                CRYPT_STRING_BASE64,
                ppwszValue);
        break;

    case VT_BOOL:
        hr = ConvertToStringBOOL(V_BOOL(&m_vtData), ppwszValue);
        break;
    case VT_BOOL|VT_BYREF:
        hr = ConvertToStringBOOL(*V_BOOLREF(&m_vtData), ppwszValue);
        break;

    case VT_LPWSTR:
        hr = ConvertToStringWSZ(
            m_vtData.pwszVal, 
            ppwszValue,
            m_fDoublePercentsInStrings);
        break;
    case VT_BSTR:
        hr = ConvertToStringWSZ(
            V_BSTR(&m_vtData), 
            ppwszValue,
            m_fDoublePercentsInStrings);
        break;
    case VT_BSTR|VT_BYREF:
        hr = ConvertToStringWSZ(
            *V_BSTRREF(&m_vtData), 
            ppwszValue,
            m_fDoublePercentsInStrings);
        break;

    case VT_FILETIME:
        hr = myFileTimeToWszTime(
                &m_vtData.filetime,
                TRUE,
                ppwszValue);
        break;

    case VT_ARRAY|VT_UI1:
        hr = ConvertToStringArrayUI1(V_ARRAY(&m_vtData), ppwszValue);
        break;
    case VT_ARRAY|VT_UI1|VT_BYREF:
        hr = ConvertToStringArrayUI1(*V_ARRAYREF(&m_vtData), ppwszValue);
        break;
    case VT_ARRAY|VT_BSTR:
        hr = ConvertToStringArrayBSTR(
            V_ARRAY(&m_vtData), 
            ppwszValue,
            m_fDoublePercentsInStrings);
        break;
    case VT_ARRAY|VT_BSTR|VT_BYREF:
        hr = ConvertToStringArrayBSTR(
            *V_ARRAYREF(&m_vtData), 
            ppwszValue,
            m_fDoublePercentsInStrings);
        break;

    default:
        {
            LPCWSTR pwszValOut = cAuditString_UnknownDataType;
            VARIANT varOut;
            VariantInit(&varOut);

            hr = VariantChangeType(&varOut, (VARIANT*)&m_vtData, 0, VT_BSTR);
            if(S_OK==hr)
            {
                pwszValOut = V_BSTR(&varOut);
            }
            *ppwszValue = (LPWSTR) LocalAlloc(
                LMEM_FIXED,
                sizeof(WCHAR)*(wcslen(pwszValOut)+1));
            if(!*ppwszValue)
            {
                return E_OUTOFMEMORY;
            }
            wcscpy(*ppwszValue, pwszValOut);
            VariantClear(&varOut);
            hr = S_OK;
        }
        break;
    }
    
    return hr;
}

HRESULT CAuditEvent::Report(bool fSuccess /* = true */)
{
    HRESULT hr;
    AUTHZ_AUDIT_EVENT_HANDLE AuthzAIH = NULL;
    PAUDIT_PARAMS pAuditParams = NULL;
    PAUDIT_PARAM pParamArray = NULL;

    if(!IsEventEnabled())
    {
        return S_OK;
    }
    hr = BuildAuditParamArray(pParamArray);
    _JumpIfError(hr, error, "GetAuditText");

    if(!AuthziAllocateAuditParams(
        &pAuditParams, 
        (USHORT)(m_cEventData+2))) // authz adds 2 
    {                                                             // extra params
        hr = myHLastError();                                      // internally
        _JumpError(hr, error, "AuthziAllocateAuditParams");
    }

#ifndef _DISABLE_AUTHZ_
    if(!AuthziInitializeAuditParamsFromArray(
            fSuccess?APF_AuditSuccess:APF_AuditFailure,
            g_AuthzCertSrvRM,
            (USHORT)m_cEventData,
            pParamArray,
            pAuditParams))
#else
    SetLastError(E_INVALIDARG);
#endif
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthziInitializeAuditParamsFromArray");
    }

    if (!AuthziInitializeAuditEvent(0,
                                   g_AuthzCertSrvRM,
                                   m_hAuditEventType,
                                   pAuditParams,
                                   NULL,
                                   INFINITE,
                                   L"",
                                   L"",
                                   L"",
                                   L"",
                                   &AuthzAIH))

    {
        hr = myHLastError();
        _JumpIfError(hr, error, "AuthzInitializeAuditInfo");
    }

   if(!AuthziLogAuditEvent( 0, AuthzAIH, NULL ))
   {
       hr = myHLastError();
       _JumpIfError(hr, error, "AuthzGenAuditEvent");
   }

    DBGPRINT((
	DBG_SS_AUDIT,
	"Audit event ID=%d\n",
	m_ulEventID));

error:

    if(AuthzAIH)
    {
        AuthzFreeAuditEvent(AuthzAIH);
    }

    if(pAuditParams)
    {
        AuthziFreeAuditParams(pAuditParams);
    }

    FreeAuditParamArray(pParamArray);

    return hr;
}

HRESULT CAuditEvent::SaveFilter(LPCWSTR pcwszSanitizedName)
{
    return mySetCertRegDWValue(
			    pcwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGAUDITFILTER,
                m_dwFilter);
}

HRESULT CAuditEvent::LoadFilter(LPCWSTR pcwszSanitizedName)
{
    return myGetCertRegDWValue(
			    pcwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGAUDITFILTER,
                &m_dwFilter);
}

HRESULT CAuditEvent::Impersonate()
{
    HRESULT hr;
    HANDLE hThread = NULL;

    CSASSERT(NULL==m_pISS);
    CSASSERT(NULL==m_hClientToken);
    
    if (NULL == m_hRpc)
    {
        // dcom impersonate
        hr = CoGetCallContext(IID_IServerSecurity, (void**)&m_pISS);
        _JumpIfError(hr, error, "CoGetCallContext");

        hr = m_pISS->ImpersonateClient();
        _JumpIfError(hr, error, "ImpersonateClient");
    }
    else
    {
        // rpc impersonate
        hr = RpcImpersonateClient((RPC_BINDING_HANDLE) m_hRpc);
        if (S_OK != hr)
        {
            hr = myHError(hr);
            _JumpError(hr, error, "RpcImpersonateClient");
        }
    }

    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "GetCurrentThread");
    }
    if (!OpenThreadToken(hThread,
                         TOKEN_QUERY | TOKEN_DUPLICATE,
                         FALSE,  // client impersonation
                         &m_hClientToken))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "OpenThreadToken");
    }

error:

    if(S_OK!=hr)
    {
        if(NULL!=m_pISS)
        {
            m_pISS->Release();
            m_pISS = NULL;
        }
    }
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    return hr;
}

HRESULT CAuditEvent::RevertToSelf()
{
    HRESULT hr = S_OK;
//    CSASSERT(m_pISS||m_hRpc);

    if (NULL != m_hRpc) // rpc
    {
        hr = RpcRevertToSelf();
        if (S_OK != hr)
        {
            hr = myHError(hr);
            _JumpError(hr, error, "RpcRevertToSelf");
        }
        m_hRpc = NULL;
    }
    else  if(m_pISS) // dcom
    {
        hr = m_pISS->RevertToSelf();
        _JumpIfError(hr, error, "IServerSecurity::RpcRevertToSelf");

        m_pISS->Release();
        m_pISS = NULL;
    }

error:
    return hr;
}

HANDLE CAuditEvent::GetClientToken()
{
    CSASSERT(m_hClientToken);
    HANDLE hSave = m_hClientToken;
    m_hClientToken = NULL;
    return hSave;
}

// dwAuditFlags - not asking for both success and failure implicitely
// means the handles will be cached for future audit
HRESULT
CAuditEvent::AccessCheck(
    ACCESS_MASK Mask,
    DWORD dwAuditFlags,
    handle_t hRpc,
    HANDLE *phToken)
{
    HRESULT hr = S_OK;
    LUID luid = {0,0};
    bool fAccessAllowed = false;
    DWORD dwRoles = 0;
    bool fImpersonating = false;

    FreeCachedHandles();

    m_hRpc = hRpc;

    if (!g_CASD.IsInitialized())
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
        _JumpError(hr, error, "Security not enabled");
    }
    
    hr = g_CASD.LockGet(&m_pCASD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = Impersonate();
    _JumpIfError(hr, error, "CAuditEvent::Impersonate");
    
    fImpersonating = true;

    // fail if RPC/COM encryption is required but client auth level is not 
    // "privacy"
    hr = EnforceEncryption(CA_ACCESS_ENROLL==Mask);
    _JumpIfError(hr, error, "EnforceEncryption");

    hr = EnforceLocalVsRemote(Mask);
    _JumpIfError(hr, error, "EnforceLocalVsRemote");

    if(!AuthzInitializeContextFromToken(
            0,
            m_hClientToken,
            g_AuthzCertSrvRM,
            NULL,
            luid,
            NULL,
            &m_ClientContext))
    {
        hr = myHLastError();
        _PrintError(hr, "AuthzInitializeContextFromToken");
    
        if (E_INVALIDARG == hr && (!IsWhistler() || 2 <= g_fAdvancedServer))
        {
            hr = S_OK;
            fAccessAllowed = TRUE;
        }
        goto error;
    }

    if(Mask & CA_ACCESS_LOCALADMIN)
    {
        bool fLocalAdmin;

        hr = myIsCurrentUserBuiltinAdmin(&fLocalAdmin);
        _JumpIfError(hr, error, "myIsCurrentUserBuiltinAdmin");

        if(fLocalAdmin)
        {
            dwRoles |= CA_ACCESS_LOCALADMIN;
        }
    }

    RevertToSelf();
    fImpersonating = false;

    // Get privilege based roles if checking access on a privilege role
    // or if role separation is enabled when we have to know all roles
    if(IsEventRoleSeparationEnabled() ||
       Mask & (CA_ACCESS_OPERATOR|CA_ACCESS_AUDITOR|CA_ACCESS_LOCALADMIN))
    {
        hr = GetPrivilegeRoles(&dwRoles);
        _JumpIfError(hr, error, "CAuditEvent::GetPrivilegeRolesCount");

        hr = BuildPrivilegeSecurityDescriptor(dwRoles);
        _JumpIfError(hr, error, "CAuditEvent::BuildPrivilegeSecurityDescriptor");
    }

    // Get security descriptor based roles
    m_Request.DesiredAccess = MAXIMUM_ALLOWED;
    CSASSERT(!m_AuthzHandle);
    if(!AuthzAccessCheck(
            0,
            m_ClientContext,
            &m_Request,
            NULL, //no audit
            m_pCASD,
            m_pSDPrivileges?(&m_pSDPrivileges):NULL,
            m_pSDPrivileges?1:0,
            &m_Reply,
            IsEventEnabled()?&m_AuthzHandle:NULL)) // no caching if no audit
                                                   // event will be generated
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzAccessCheck");
    }
    
    dwRoles |= m_Reply.GrantedAccessMask[0];
    
    if(m_Reply.Error[0]==ERROR_SUCCESS &&
       m_Reply.GrantedAccessMask[0]&Mask)
    {
        fAccessAllowed = true;
    }

    if(IsEventRoleSeparationEnabled() &&
       GetBitCount(dwRoles&CA_ACCESS_MASKROLES)>1)
    {
        hr = CERTSRV_E_ROLECONFLICT;
        fAccessAllowed = false;
        // don't return yet, we need to generate an audit
    }

    // Next is a fake access check to generate an audit. 
    // Access is denied if:
    // - role separation is enabled and user has more than one role
    // - none of the roles requested is allowed

    // Generate audit if event is enabled and 
    if(IsEventEnabled() &&
        (!fAccessAllowed && !(dwAuditFlags&m_gcNoAuditFailure) ||
         fAccessAllowed && !(dwAuditFlags&m_gcNoAuditSuccess)))
    {

        m_Request.DesiredAccess = 
            fAccessAllowed?
            m_Reply.GrantedAccessMask[0]&Mask:
            Mask;

        if(CERTSRV_E_ROLECONFLICT==hr)
            m_Request.DesiredAccess = 0x0000ffff; //force a failure audit
        
        HRESULT hr2 = CachedGenerateAudit();
        if(S_OK != hr2)
        {
            hr = hr2;
            _JumpIfError(hr, error, "CAuditEvent::CachedGenerateAudit");
        }
    }

    if(phToken)
    {
        *phToken = GetClientToken();
    }

error:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    if(!IsEventEnabled())
    {
        FreeCachedHandles();
    }

    if(S_OK==hr)
    {
        hr = fAccessAllowed?S_OK:E_ACCESSDENIED;
    }

    return(hr);
}

HRESULT 
CAuditEvent::CachedGenerateAudit()
{
    HRESULT hr = S_OK;
    AUTHZ_AUDIT_EVENT_HANDLE AuditInfo = NULL;
    PAUDIT_PARAMS pAuditParams = NULL;
    PAUDIT_PARAM pParamArray = NULL;

    if(!IsEventEnabled())
    {
        FreeCachedHandles();
        return S_OK;
    }

    CSASSERT(m_AuthzHandle);

    hr = BuildAuditParamArray(pParamArray);
    _JumpIfError(hr, error, "GetAuditText");

    if(!AuthziAllocateAuditParams(
        &pAuditParams, 
        (USHORT)(m_cEventData+2))) // authz adds 2 
    {                                                             // extra params
        hr = myHLastError();                                      // internally
        _JumpError(hr, error, "AuthziAllocateAuditParams");
    }

#ifndef _DISABLE_AUTHZ_
    if(!AuthziInitializeAuditParamsFromArray(
            APF_AuditSuccess|APF_AuditFailure,
            g_AuthzCertSrvRM,
            (USHORT)m_cEventData,
            pParamArray,
            pAuditParams))
#else
    SetLastError(E_INVALIDARG);
#endif
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzInitAuditParams");
    }

    if(!AuthziInitializeAuditEvent(
            0,
            g_AuthzCertSrvRM,
            m_hAuditEventType,
            pAuditParams,
            NULL,
            INFINITE,
            L"",
            L"",
            L"",
            L"",
            &AuditInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzInitAuditInfoHandle");
    }

    if(!AuthzCachedAccessCheck(
            0,
            m_AuthzHandle,
            &m_Request,
            AuditInfo,
            &m_Reply))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzCachedAccessCheck");
    }

error:

    if(AuditInfo)
    {
        AuthzFreeAuditEvent(AuditInfo);
    }

    if(pAuditParams)
    {
        AuthziFreeAuditParams(pAuditParams);
    }

    FreeCachedHandles();
    FreeAuditParamArray(pParamArray);

    return hr;
}


void CAuditEvent::FreeCachedHandles()
{
    if(m_hClientToken)
    {
        CloseHandle(m_hClientToken);
        m_hClientToken = NULL;
    }

    if(m_AuthzHandle)
    {
        AuthzFreeHandle(m_AuthzHandle);
        m_AuthzHandle = NULL;
    }

    if(m_pCASD)
    {
        g_CASD.Unlock();
        m_pCASD = NULL;
    }

    if(m_ClientContext)
    {
        AuthzFreeContext(m_ClientContext);
        m_ClientContext = NULL;
    }

    if(m_pUserSid)
    {
        LocalFree(m_pUserSid);
        m_pUserSid = NULL;
    }
    if(m_pSDPrivileges)
    {
        LocalFree(m_pSDPrivileges);
        m_pSDPrivileges = NULL;
    }
    if(m_pDaclPrivileges)
    {
        LocalFree(m_pDaclPrivileges);
        m_pDaclPrivileges = NULL;
    }
}

HRESULT CAuditEvent::RoleSeparationFlagSave(LPCWSTR pcwszSanitizedName)
{
    return mySetCertRegDWValue(
			    pcwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGROLESEPARATIONENABLED,
                RoleSeparationIsEnabled()?1:0);
}

HRESULT CAuditEvent::RoleSeparationFlagLoad(LPCWSTR pcwszSanitizedName)
{
    DWORD dwFlags = 0;
    HRESULT hr = myGetCertRegDWValue(
			        pcwszSanitizedName,
			        NULL,
			        NULL,
			        wszREGROLESEPARATIONENABLED,
                    &dwFlags);
    if(S_OK==hr)
    {
        RoleSeparationEnable(dwFlags?true:false);
    }

    return hr;
}

HRESULT CAuditEvent::GetPrivilegeRoles(PDWORD pdwRoles)
{
    HRESULT hr = S_OK;
    PTOKEN_USER pTokenUser = NULL;
    DWORD cbTokenUser = 0;
    PTOKEN_GROUPS pTokenGroups = NULL;
    DWORD cbTokenGroups = 0;
    DWORD dwRoles = 0;
    LSA_HANDLE lsahPolicyHandle = NULL;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS NTStatus;

    // first get roles for the user itself
    AuthzGetInformationFromContext(
            m_ClientContext,
            AuthzContextInfoUserSid,
            0,
            &cbTokenUser,
            NULL);       
     
    if(GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

    pTokenUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, cbTokenUser);
    _JumpIfAllocFailed(pTokenUser, error);

    if(!AuthzGetInformationFromContext(
            m_ClientContext,
            AuthzContextInfoUserSid,
            cbTokenUser,
            &cbTokenUser,
            pTokenUser))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

    // Object attributes are reserved, so initalize to zeroes.
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    NTStatus = LsaOpenPolicy(
                NULL,
                &ObjectAttributes,
                POLICY_LOOKUP_NAMES,
                &lsahPolicyHandle);
    if(STATUS_SUCCESS!=NTStatus)
    {
        hr = myHError(LsaNtStatusToWinError(NTStatus));
        _JumpError(hr, error, "LsaOpenPolicy");
    }
  
    CSASSERT(!m_pUserSid);
    m_pUserSid = (PSID)LocalAlloc(LMEM_FIXED, GetLengthSid(pTokenUser->User.Sid));
    _JumpIfAllocFailed(m_pUserSid, error);

    CopySid(
        GetLengthSid(pTokenUser->User.Sid), 
        m_pUserSid,
        pTokenUser->User.Sid);

    hr = GetUserPrivilegeRoles(lsahPolicyHandle, &pTokenUser->User, &dwRoles);
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr =S_OK;
    }
    _JumpIfError(hr, error, "CAuditEvent::GetUserPrivilegeRoles");

    *pdwRoles |= dwRoles;

    // then find the roles assigned to the groups the user is member of

    AuthzGetInformationFromContext(
            m_ClientContext,
            AuthzContextInfoGroupsSids,
            0,
            &cbTokenGroups,
            NULL);

    if(GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

    pTokenGroups = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED, cbTokenGroups);
    _JumpIfAllocFailed(pTokenGroups, error);

    if(!AuthzGetInformationFromContext(
            m_ClientContext,
            AuthzContextInfoGroupsSids,
            cbTokenGroups,
            &cbTokenGroups,
            pTokenGroups))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzGetContextInformation");
    }

    for(DWORD cGroups = 0; cGroups<pTokenGroups->GroupCount; cGroups++)
    {
        dwRoles = 0;
        hr = GetUserPrivilegeRoles(
                lsahPolicyHandle,
                &pTokenGroups->Groups[cGroups], 
                &dwRoles);
        if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
        {
            hr =S_OK;
        }
        _JumpIfError(hr, error, "CAuditEvent::GetUserPrivilegeRoles");

        *pdwRoles |= dwRoles;
    }

error:
    if(pTokenUser)
    {
        LocalFree(pTokenUser);
    }
    if(pTokenGroups)
    {
        LocalFree(pTokenGroups);
    }
    if(lsahPolicyHandle)
    {
        LsaClose(lsahPolicyHandle);
    }
    return hr;
}


HRESULT CAuditEvent::GetUserPrivilegeRoles(
    LSA_HANDLE lsah,
    PSID_AND_ATTRIBUTES pSA, 
    PDWORD pdwRoles)
{
    NTSTATUS NTStatus;
    PLSA_UNICODE_STRING pLSAString = NULL;
    ULONG cRights, c;
    
    NTStatus = LsaEnumerateAccountRights(
                lsah,
                pSA->Sid,
                &pLSAString,
                &cRights);

    if(STATUS_SUCCESS!=NTStatus)
    {
        return(myHError(LsaNtStatusToWinError(NTStatus)));
    }

    for(c=0; c<cRights; c++)
    {
        if(0==_wcsicmp(SE_SECURITY_NAME, pLSAString[c].Buffer))
        {
            *pdwRoles |= CA_ACCESS_AUDITOR;
        }
        else if(0==_wcsicmp(SE_BACKUP_NAME, pLSAString[c].Buffer))
        {
            *pdwRoles |= CA_ACCESS_OPERATOR;
        }
    }

    if(pLSAString)
    {
        LsaFreeMemory(pLSAString);
    }

    return S_OK;
}

HRESULT
CAuditEvent::GetMyRoles(
    DWORD *pdwRoles)
{
    HRESULT hr = S_OK;
    LUID luid = {0,0};
    DWORD dwRoles = 0;
    bool fImpersonating = false;

    if (!g_CASD.IsInitialized())
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
        _JumpError(hr, error, "Security not enabled");
    }
    
    hr = g_CASD.LockGet(&m_pCASD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = Impersonate();
    _JumpIfError(hr, error, "CAuditEvent::Impersonate");

    // fail if RPC/COM encryption is required but client auth level is not 
    // "privacy"
    hr = EnforceEncryption(false); // false == admin interface
    _JumpIfError(hr, error, "EnforceEncryption");

    fImpersonating = true;

    if(!AuthzInitializeContextFromToken(
            0,
            m_hClientToken,
            g_AuthzCertSrvRM,
            NULL,
            luid,
            NULL,
            &m_ClientContext))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzInitializeContextFromToken");
    }

    RevertToSelf();
    fImpersonating = false;

    hr = GetPrivilegeRoles(&dwRoles);
    _JumpIfError(hr, error, "CAuditEvent::GetPrivilegeRoles");

    m_Request.DesiredAccess = MAXIMUM_ALLOWED;
    m_Reply.GrantedAccessMask[0] = 0;

    if(!AuthzAccessCheck(
            0,
            m_ClientContext,
            &m_Request,
            NULL, //no audit
            m_pCASD,
            NULL,
            0,
            &m_Reply,
            NULL))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AuthzAccessCheck");
    }
    
    dwRoles |= (m_Reply.GrantedAccessMask[0] &
                (CA_ACCESS_MASKROLES | // returned mask could also
                 CA_ACCESS_READ |      // include generic rights (like
                 CA_ACCESS_ENROLL));   // read and write DACL) which
                                       // we are not interested in
    *pdwRoles = dwRoles;

error:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    FreeCachedHandles();

    return(hr);
}


// Build a one ace DACL security descriptor with the roles
// passed in
HRESULT CAuditEvent::BuildPrivilegeSecurityDescriptor(DWORD dwRoles)
{
    HRESULT hr = S_OK;
    DWORD dwDaclSize;
    PSID pOwnerSid = NULL; // no free
    PSID pGroupSid = NULL; // no free
    BOOL fDefaulted;

    CSASSERT(NULL == m_pSDPrivileges);
    CSASSERT(NULL == m_pDaclPrivileges);

    m_pSDPrivileges = (PSECURITY_DESCRIPTOR)LocalAlloc(
                        LMEM_FIXED,
                        SECURITY_DESCRIPTOR_MIN_LENGTH);
    _JumpIfAllocFailed(m_pSDPrivileges, error);

    if (!InitializeSecurityDescriptor(
            m_pSDPrivileges,
            SECURITY_DESCRIPTOR_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    CSASSERT(m_pUserSid && IsValidSid(m_pUserSid));

    dwDaclSize =  sizeof(ACL) +
        sizeof(ACCESS_ALLOWED_ACE)-sizeof(DWORD)+
        GetLengthSid(m_pUserSid);
    
    m_pDaclPrivileges = (PACL)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, dwDaclSize);
    _JumpIfAllocFailed(m_pDaclPrivileges, error);

    if(!InitializeAcl(m_pDaclPrivileges, dwDaclSize, ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    if(!AddAccessAllowedAce(
            m_pDaclPrivileges,
            ACL_REVISION,
            dwRoles,
            m_pUserSid))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AddAccessAllowedAce");
    }

    if(!GetSecurityDescriptorOwner(m_pCASD,
                                  &pOwnerSid,
                                  &fDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorOwner");
    }

    if(!SetSecurityDescriptorOwner(m_pSDPrivileges,
                                  pOwnerSid,
                                  fDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorOwner");
    }

    if(!GetSecurityDescriptorGroup(m_pCASD,
                                  &pGroupSid,
                                  &fDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorGroup");
    }

    if(!SetSecurityDescriptorGroup(m_pSDPrivileges,
                                  pGroupSid,
                                  fDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorGroup");
    }

    if(!SetSecurityDescriptorDacl(m_pSDPrivileges,
                                  TRUE,
                                  m_pDaclPrivileges,
                                  FALSE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    CSASSERT(IsValidSecurityDescriptor(m_pSDPrivileges));

error:

    if(S_OK != hr)
    {
        if(m_pDaclPrivileges)
        {
            LocalFree(m_pDaclPrivileges);
            m_pDaclPrivileges = NULL;
        }

        if(m_pSDPrivileges)
        {
            LocalFree(m_pSDPrivileges);
            m_pSDPrivileges = NULL;
        }
    }
    return hr;
}

HRESULT CAuditEvent::BuildAuditParamArray(PAUDIT_PARAM& rpParamArray)
{
    HRESULT hr = S_OK;

    // number of parameters added should be the same as the number of
    // params defined in the audit format string in msaudite.dll
    CSASSERT(m_cEventData == m_cRequiredEventData);

    rpParamArray = (PAUDIT_PARAM) LocalAlloc(
        LMEM_FIXED | LMEM_ZEROINIT, 
        sizeof(AUDIT_PARAM)*m_cEventData);
    _JumpIfAllocFailed(rpParamArray, error);

    for(USHORT c=0;c<m_cEventData;c++)
    {
        rpParamArray[c].Type = APT_String;
        
        hr = m_pEventDataList[c]->ConvertToString(
            &rpParamArray[c].String);
        _JumpIfError(hr, error, "ConvertToString");
    }

error:
    return hr;
}

void CAuditEvent::FreeAuditParamArray(PAUDIT_PARAM pParamArray)
{
    if(pParamArray)
    {
        for(USHORT c=0;c<m_cEventData;c++)
        {
            if(pParamArray[c].String)
                LocalFree(pParamArray[c].String);
        }

        LocalFree(pParamArray);
    }
}

HRESULT CAuditEvent::EnforceEncryption(bool fRequestInterface)
{
    HRESULT hr = S_OK;

    if((fRequestInterface?
        IF_ENFORCEENCRYPTICERTREQUEST:
        IF_ENFORCEENCRYPTICERTADMIN) & 
       g_InterfaceFlags)
    {
        if(m_pISS) // DCOM
        {
            DWORD dwAuthLevel;
            hr = m_pISS->QueryBlanket(
                NULL, NULL, NULL,
                &dwAuthLevel,
                NULL, NULL, NULL);
            _JumpIfError(hr, error, "IServerSecurity::QueryBlanket");

            if(RPC_C_AUTHN_LEVEL_PKT_PRIVACY != dwAuthLevel)
            {
                hr = E_ACCESSDENIED;
                _JumpError(hr, error, "call not encrypted");
            }
        }
        else // RPC
        {
            CSASSERT(m_hRpc);

            unsigned long ulAuthLevel;

            hr = RpcBindingInqAuthClient(
                    m_hRpc,
                    NULL, NULL,
                    &ulAuthLevel,
                    NULL, NULL);
            _JumpIfError(hr, error, "RpcBindingInqAuthClient");

            if(RPC_C_AUTHN_LEVEL_PKT_PRIVACY != ulAuthLevel)
            {
                hr = E_ACCESSDENIED;
                _JumpError(hr, error, "call not encrypted");
            }
        }
    }

error:
    return hr;
}

HRESULT CAuditEvent::EnforceLocalVsRemote(ACCESS_MASK Mask)
{
    HRESULT hr = S_OK;
    DWORD dwEnforceNoLocalFlag, dwEnforceNoRemoteFlag;
    PSID psidNetwork = NULL;
    BOOL fIsRemote;

    hr = GetNetworkSID(&psidNetwork);
    _JumpIfError(hr, error, "GetLocalSid");

    if(!CheckTokenMembership(m_hClientToken, psidNetwork, &fIsRemote))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CheckTokenMembership");
    }

    switch(Mask)
    {
        case CA_ACCESS_OPERATOR:
            dwEnforceNoRemoteFlag   = IF_NOREMOTEICERTADMINBACKUP;
            dwEnforceNoLocalFlag    = IF_NOLOCALICERTADMINBACKUP;
            break;
        case CA_ACCESS_ENROLL:
            dwEnforceNoRemoteFlag   = IF_NOREMOTEICERTREQUEST;
            dwEnforceNoLocalFlag    = IF_NOLOCALICERTREQUEST;
            break;
        default:
            dwEnforceNoRemoteFlag   = IF_NOREMOTEICERTADMIN;
            dwEnforceNoLocalFlag    = IF_NOLOCALICERTADMIN;
            break;
    }

    if((fIsRemote && (g_InterfaceFlags & dwEnforceNoRemoteFlag)) ||
      (!fIsRemote && (g_InterfaceFlags & dwEnforceNoLocalFlag)))
    {
        hr = E_ACCESSDENIED;
    }

error:
    if (NULL != psidNetwork)
    {
	FreeSid(psidNetwork);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certsrv\pkcs.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pkcs.cpp
//
// Contents:    Cert Server Extension interfaces -- PKCS implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdio.h>
#include <time.h>

#define SECURITY_WIN32
#include <security.h>
#include <esent.h>

#include "dbtable.h"
#include "resource.h"
#include "cscom.h"
#include "csprop.h"
#include "elog.h"
#include "certlog.h"
#include "csdisp.h"
#include "cscsp.h"
#include <certca.h>
#include <esent.h>

#include <winldap.h>
#include "csldap.h"
#include "cainfop.h"

#define __dwFILE__	__dwFILE_CERTSRV_PKCS_CPP__


CSURLTEMPLATE *g_paRevURL = NULL;
DWORD g_caRevURL = 0;

CSURLTEMPLATE *g_paCACertURL = NULL;
DWORD g_caCACertURL = 0;

BSTR g_strDomainDN = NULL;
BSTR g_strConfigDN = NULL;

WCHAR *g_pwszKRAPublishURL = NULL;
WCHAR *g_pwszAIACrossCertPublishURL = NULL;
WCHAR *g_pwszRootTrustCrossCertPublishURL = NULL;


// Note on Renewal and Key reuse:
//
// Cert Indexes, Key Indexes and CRL Name Indexes are all zero based.
//
// One CRL is issued by this CA for each unique key.  Each CRL covers all of
// the certs issued by this CA for one key, even though the key may have been
// used by multiple renewal certs.
//
// The database IssuerNameID PROPTYPE_LONG column holds the Key Index in the
// top 16 bits and the Cert Index in the bottom 16 bits.  This allows a pair of
// query restrictions to reduce the result row set to those revoked certs
// that will be placed into a single CRL.
//
// When Cert File, Key Container, CRL File or DS Object name templates include
// an Index Suffix, an empty string suffix, "", is used when the index is zero.
// Otherwise the Suffix is "(%u)", where the index itself is passed to wsprintf
// to construct the %u field.
//
// Cert Indexes increment each time the CA cert is renewed.  Because 16 bit
// Cert Indexes are stored in the database, a CA may have up to 64k certs,
// and be renewed a maximum of 64k-1 times.
//
// The Cert File Name Suffix is built from the Cert Index.
//
// Key Indexes:  The original installed CA cert uses a Key Index of 0.
// If a renewal cert uses the same key as any previous cert used by this CA,
// the Key Index for the new CA cert is taken from the previous CA cert.
// If a renewal cert uses a new Key, the Cert Index is used for the Key Index.
// The primary reason sequential Key Indexes are not used for new keys is that
// too much context information is required to determine the next Key Index --
// which is particularly difficult to obtain when performing PFX restore.
//
// The Key Container Name Suffix is built from the Key Index.
//
//
// CRL Indexes:  same as Key Index.
// CRL File Name Suffix:  same as Key Container Name Suffix.
//
// Example:		Cert   CertName	Key	KeyName	CRL	CRLName
//			Index	Suffix	Index	Suffix	Index	Suffix
// Original Install	0	""	0	""	0	""
//
// Renew, new Key	1	"(1)"	1	"(1)"	1	"(1)"
// *Renew, reuse Key	2	"(2)"	1	"(1)"	1	"(1)"
// *Renew, reuse Key	3	"(3)"	1	"(1)"	1	"(1)"
//
// Renew, new Key	4	"(4)"	4	"(4)"	4	"(4)"
// *Renew, reuse Key	5	"(5)"	4	"(4)"	4	"(4)"
//
// Renew, new Key	6	"(6)"	6	"(6)"	6	"(6)"
// *Renew, reuse Key	7	"(7)"	6	"(6)"	6	"(6)"
//
//
// CCertRequest::GetCACertificate can be used to fetch Certs and CRLs by Index.
// This API always accepts a Cert Index.
//
// When fetching a certificate:  If the Cert Index is valid, the appropriate
// certificate or chain is returned, even if it is expired or revoked.
//
// When fetching a CRL:  If the Cert Index is valid AND if the Cert Index
// MATCHES the Key Index for the indexed Cert, the appropriate CRL is returned.
// This means that an error will be returned when requesting CRLs associated
// with entries in the above table that reused keys (marked with an asterisk
// in the first column).  The nearest previous unmarked entry's CRL covers
// revocations for the marked entries.
//
//
// CCertServer{Policy,Exit}::GetCertificateProperty can be used to fetch
// information about Certs and CRLs.  This API allows an optional numeric
// suffix on the property name, as in "RawCRL.3".  The suffix is always
// interpreted as a Cert Index.
//
// wszPROPCERTCOUNT:  Returns total CA Cert count, including expired and
// revoked certs.  No numeric Cert Index suffix is allowed.
//
// wszPROPRAWCACERTIFICATE:  Returns the Cert for the passed Cert Index.
// Returns the Cert for the most recent Cert Index if no Cert Index is
// specified.  Expired and revoked certs are still retrievable.
//
// wszPROPCERTSTATE:  Returns the Cert State for the passed Cert Index.
// Returns the Cert State for the most recent Cert Index if no Cert Index is
// specified.
// Values for wszPROPCERTSTATE (see certadm.h):
//   CA_DISP_REVOKED    // This Cert has been revoked.
//   CA_DISP_VALID      // This Cert is still valid
//   CA_DISP_INVALID    // This Cert has expired.
//   CA_DISP_ERROR      // Cert unavailable (placehholder in registry?)
//
// wszPROPCERTSUFFIX: Returns the Cert FileName Suffix for the passed Cert
// Index.  Returns the Cert FileName Suffix for the most recent Cert Index if
// no Cert Index is specified.
//
// wszPROPRAWCRL:  Returns the CRL for the passed Cert Index.  As with
// CCertRequest::GetCACertificate, it is an error to fetch a CRL for a Cert
// that reused keys.  In the above table, only "RawCRL.0", "RawCRL.1",
// "RawCRL.4", "RawCRL.6" & "RawCRL" are allowed.  "RawCRL" will fetch the most
// recent CRL.  Use the wszPROPCRLSTATE with a numeric Cert Index suffix to
// determine which CRLs are valid to fetch.  CA_DISP_ERROR indicates the
// CRL cannot be fetched.  CA_DISP_REVOKED and CA_DISP_INVALID CRLs are still
// retrievable via this method call.
//
// All of the other CRL-related property fetches are supported for all valid
// Cert Index values:
//
// wszPROPCRLINDEX:  Returns the CRL Index value for the passed Cert Index.
// Returns the CRL Index value for the most recent Cert Index if no Cert Index
// is specified.
//
// wszPROPCRLSTATE:  Returns the CRL State for the passed Cert Index.
// Returns the CRL State for the most recent Cert Index if no Cert Index is
// specified.
// Values for wszPROPCRLSTATE (see certadm.h):
//   CA_DISP_REVOKED    // All unexpired certs using this Cert's CRL have been
//                      // revoked.
//   CA_DISP_VALID      // This Cert is still publishing CRLs as needed.
//   CA_DISP_INVALID    // All certs using this Cert's CRL are expired.
//   CA_DISP_ERROR      // This Cert's CRL is managed by another Cert.
//
// wszPROPCRLSUFFIX: Returns the CRL FileName Suffix for the passed Cert Index.
// Returns the CRL FileName Suffix for the most recent Cert Index if no Cert
// Index is specified.


CACTX *g_aCAContext;		// allocated array of CACTXs
CACTX *g_pCAContextCurrent;	// current CACTX is last g_aCAContext element
CACROSSCTX *g_aCACrossForward;	// allocated array of CACROSSCTXs; root CA only
CACROSSCTX *g_aCACrossBackward;	// allocated array of CACROSSCTXs; root CA only

typedef struct _KRACTX
{
    DWORD		 Flags;
    HRESULT		 hrVerifyStatus;
    CERT_CONTEXT const  *pccKRA;
    BSTR		 strKRAHash;
} KRACTX;

KRACTX *g_aKRAContext;

DWORD g_cKRACertsRoundRobin = 0;

DWORD g_cCAKeys;    // Total number of unique CA keys managed by this CA
DWORD g_cCACerts;   // Total number of CA certs managed by this CA
DWORD g_cKRACerts;  // Total number of KRA certs loaded by this CA

BOOL g_fcritsecCAXchg = FALSE;
CRITICAL_SECTION g_critsecCAXchg;

CAXCHGCTX *g_aCAXchgContext;	// allocated array of CAXCHGCTXs
CAXCHGCTX *g_pCAXchgContextCurrent;	// current CAXCHGCTX is last element
DWORD g_cCAXchgCerts;		// number of CA Xchg certs managed by this CA
HCERTSTORE g_hStoreCAXchg = NULL;
DWORD g_dwXchgProvType;
WCHAR *g_pwszXchgProvName = NULL;
ALG_ID g_XchgidAlg;
BOOL g_fXchgMachineKeyset;
DWORD g_dwXchgKeySize;
DWORD g_dwVerifyCertFlags;

LONG g_lValidityPeriodCount = dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE;
enum ENUM_PERIOD g_enumValidityPeriod = dwVALIDITYPERIODENUMDEFAULT;

enum ENUM_PERIOD g_enumCAXchgValidityPeriod = dwCAXCHGVALIDITYPERIODENUMDEFAULT;
LONG g_lCAXchgValidityPeriodCount = dwCAXCHGVALIDITYPERIODCOUNTDEFAULT;

enum ENUM_PERIOD g_enumCAXchgOverlapPeriod = dwCAXCHGOVERLAPPERIODENUMDEFAULT;
LONG g_lCAXchgOverlapPeriodCount = dwCAXCHGOVERLAPPERIODCOUNTDEFAULT;

typedef enum {
    ST_COUNTRY = 0,
    ST_ORGANIZATION,
    ST_ORGANIZATIONALUNIT,
    ST_COMMONNAME,
    ST_LOCALITY,
    ST_STATEORPROVINCE,
    ST_TITLE,
    ST_GIVENNAME,
    ST_INITIALS,
    ST_SURNAME,
    ST_DOMAINCOMPONENT,
    ST_EMAIL,
    ST_STREETADDRESS,
    ST_UNSTRUCTUREDNAME,
    ST_UNSTRUCTUREDADDRESS,
    ST_DEVICESERIALNUMBER,
    ST_NULL
};

typedef struct _SUBJECTTABLE
{
    WCHAR const         *pwszPropName;
    CHAR const          *pszObjId;
    WCHAR const * const *apwszAttributeName;
    DWORD                cchMax;
    DWORD                dwValueType;
    DWORD                dwSubjectTableIndex;
    DWORD                dwSubjectTemplateIndex;
} SUBJECTTABLE;


WCHAR const *apwszAttrCountry[] = {
    wszATTRCOUNTRY1,
    wszATTRCOUNTRY2,
    TEXT(szOID_COUNTRY_NAME),
    NULL
};

WCHAR const *apwszAttrOrg[] = {
    wszATTRORG1,
    wszATTRORG2,
    wszATTRORG3,
    TEXT(szOID_ORGANIZATION_NAME),
    NULL
};

WCHAR const *apwszAttrOrgUnit[] = {
    wszATTRORGUNIT1,
    wszATTRORGUNIT2,
    wszATTRORGUNIT3,
    wszATTRORGUNIT4,
    TEXT(szOID_ORGANIZATIONAL_UNIT_NAME),
    NULL
};

WCHAR const *apwszAttrCommonName[] = {
    wszATTRCOMMONNAME1,
    wszATTRCOMMONNAME2,
    TEXT(szOID_COMMON_NAME),
    NULL
};

WCHAR const *apwszAttrLocality[] = {
    wszATTRLOCALITY1,
    wszATTRLOCALITY2,
    TEXT(szOID_LOCALITY_NAME),
    NULL
};

WCHAR const *apwszAttrState[] = {
    wszATTRSTATE1,
    wszATTRSTATE2,
    wszATTRSTATE3,
    TEXT(szOID_STATE_OR_PROVINCE_NAME),
    NULL
};

WCHAR const *apwszAttrTitle[] = {
    wszATTRTITLE1,
    wszATTRTITLE2,
    TEXT(szOID_TITLE),
    NULL
};

WCHAR const *apwszAttrGivenName[] = {
    wszATTRGIVENNAME1,
    wszATTRGIVENNAME2,
    TEXT(szOID_GIVEN_NAME),
    NULL
};

WCHAR const *apwszAttrInitials[] = {
    wszATTRINITIALS1,
    wszATTRINITIALS2,
    TEXT(szOID_INITIALS),
    NULL
};

WCHAR const *apwszAttrSurName[] = {
    wszATTRSURNAME1,
    wszATTRSURNAME2,
    TEXT(szOID_SUR_NAME),
    NULL
};

WCHAR const *apwszAttrDomComp[] = {
    wszATTRDOMAINCOMPONENT1,
    wszATTRDOMAINCOMPONENT2,
    TEXT(szOID_DOMAIN_COMPONENT),
    NULL
};

WCHAR const *apwszAttrEMail[] = {
    wszATTREMAIL1,
    wszATTREMAIL2,
    TEXT(szOID_RSA_emailAddr),
    NULL
};

WCHAR const *apwszAttrStreetAddr[] = {
    wszATTRSTREETADDRESS1,
    wszATTRSTREETADDRESS2,
    TEXT(szOID_STREET_ADDRESS),
    NULL
};

WCHAR const *apwszAttrUnstructName[] = {
    wszATTRUNSTRUCTUREDNAME1,
    TEXT(szOID_RSA_unstructName),
    NULL
};

WCHAR const *apwszAttrUnstructAddr[] = {
    wszATTRUNSTRUCTUREDADDRESS1,
    TEXT(szOID_RSA_unstructAddr),
    NULL
};

WCHAR const *apwszAttrDeviceSerialNumber[] = {
    wszATTRDEVICESERIALNUMBER1,
    TEXT(szOID_DEVICE_SERIAL_NUMBER),
    NULL
};


SUBJECTTABLE pkcs_subject[] =
{
    {
        // "Country",
	g_wszPropSubjectCountry,
        szOID_COUNTRY_NAME,
	apwszAttrCountry,
	cchCOUNTRYNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_COUNTRY,
	MAXDWORD,
    },
    {
        // "Organization",
	g_wszPropSubjectOrganization,
        szOID_ORGANIZATION_NAME,
	apwszAttrOrg,
	cchORGANIZATIONNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_ORGANIZATION,
	MAXDWORD,
    },
    {
        // "OrganizationalUnit",
	g_wszPropSubjectOrgUnit,
        szOID_ORGANIZATIONAL_UNIT_NAME,
	apwszAttrOrgUnit,
	cchORGANIZATIONALUNITNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_ORGANIZATIONALUNIT,
	MAXDWORD,
    },
    {
        // "CommonName",
	g_wszPropSubjectCommonName,
        szOID_COMMON_NAME,
	apwszAttrCommonName,
	cchCOMMONNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_COMMONNAME,
	MAXDWORD,
    },
    {
        // "Locality",
	g_wszPropSubjectLocality,
        szOID_LOCALITY_NAME,
	apwszAttrLocality,
	cchLOCALITYMANAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_LOCALITY,
	MAXDWORD,
    },
    {
        // "StateOrProvince",
	g_wszPropSubjectState,
        szOID_STATE_OR_PROVINCE_NAME,
	apwszAttrState,
	cchSTATEORPROVINCENAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_STATEORPROVINCE,
	MAXDWORD,
    },
    {
        // "Title",
        g_wszPropSubjectTitle,
        szOID_TITLE,
	apwszAttrTitle,
	cchTITLEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_TITLE,
	MAXDWORD,
    },
    {
        // "GivenName",
        g_wszPropSubjectGivenName,
        szOID_GIVEN_NAME,
	apwszAttrGivenName,
	cchGIVENNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_GIVENNAME,
	MAXDWORD,
    },
    {
        // "Initials",
        g_wszPropSubjectInitials,
        szOID_INITIALS,
	apwszAttrInitials,
	cchINITIALSMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_INITIALS,
	MAXDWORD,
    },
    {
        // "SurName",
        g_wszPropSubjectSurName,
        szOID_SUR_NAME,
	apwszAttrSurName,
	cchSURNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_SURNAME,
	MAXDWORD,
    },
    {
        // "DomainComponent",
	g_wszPropSubjectDomainComponent,
        szOID_DOMAIN_COMPONENT,
	apwszAttrDomComp,
	cchDOMAINCOMPONENTMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_DOMAINCOMPONENT,
	MAXDWORD,
    },
    {
        // "EMail",
	g_wszPropSubjectEMail,
        szOID_RSA_emailAddr,
	apwszAttrEMail,
	cchEMAILMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_EMAIL,
	MAXDWORD,
    },
    {
        // "StreetAddress",
	g_wszPropSubjectStreetAddress,
        szOID_STREET_ADDRESS,
	apwszAttrStreetAddr,
	cchSTREETADDRESSMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_STREETADDRESS,
	MAXDWORD,
    },
    {
        // "UnstructuredName",
	g_wszPropSubjectUnstructuredName,
        szOID_RSA_unstructName,
	apwszAttrUnstructName,
	cchUNSTRUCTUREDNAMEMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_UNSTRUCTUREDNAME,
	MAXDWORD,
    },
    {
        // "UnstructuredAddress",
	g_wszPropSubjectUnstructuredAddress,
        szOID_RSA_unstructAddr,
	apwszAttrUnstructAddr,
	cchUNSTRUCTUREDADDRESSMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_UNSTRUCTUREDADDRESS,
	MAXDWORD,
    },
    {
        // "DeviceSerialNumber",
	g_wszPropSubjectDeviceSerialNumber,
        szOID_DEVICE_SERIAL_NUMBER,
	apwszAttrDeviceSerialNumber,
	cchDEVICESERIALNUMBERMAX,
        CERT_RDN_PRINTABLE_STRING,
        ST_DEVICESERIALNUMBER,
	MAXDWORD,
    },
    {
	NULL,
        NULL,
        NULL,
        0,
        0,
        ST_NULL,
	MAXDWORD,
    },
};

#define CSUBJECTTABLE (sizeof(pkcs_subject) / sizeof(pkcs_subject[0]))

SUBJECTTABLE const *pkcs_apSubject[CSUBJECTTABLE];
SUBJECTTABLE const **pkcs_ppSubjectLast;
BOOL pkcsfSubjectTemplate = FALSE;

WCHAR const g_wszCNXchgSuffix[] = wszCNXCHGSUFFIX;


VOID
pkcsSetDistinguishedName(
    IN ICertDBRow *prow,
    IN DWORD dwTable,
    IN CERT_NAME_BLOB const *pSubject)
{
    DWORD cwc;
    WCHAR awcName[CCH_DBMAXTEXT_DN + 1];
    HRESULT hr;

    CSASSERT(PROPTABLE_REQUEST == dwTable || PROPTABLE_CERTIFICATE == dwTable);

    cwc = CertNameToStr(
		    X509_ASN_ENCODING,
		    const_cast<CERT_NAME_BLOB *>(pSubject),
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    awcName,
		    ARRAYSIZE(awcName));
    if (0 != cwc && L'\0' != awcName[0])
    {
#if DBG_CERTSRV
	DWORD ReqId;

	prow->GetRowId(&ReqId);
	DBGPRINT((
            DBG_SS_CERTSRVI,
	    "%ws DN(%u): '%ws'\n",
	    PROPTABLE_REQUEST == dwTable? L"Request" : L"Certificate",
	    ReqId,
	    awcName));
#endif
	if (wcslen(awcName) == ARRAYSIZE(awcName) - 1)
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"pkcsSetDistinguishedName: possible DN truncation: %u chars: '%ws'\n",
		ARRAYSIZE(awcName) - 1,
		awcName));
	}
	hr = prow->SetProperty(
		g_wszPropSubjectDistinguishedName,
		PROPTYPE_STRING | PROPCALLER_SERVER | dwTable,
		MAXDWORD,
		(BYTE const *) awcName);
	_PrintIfError(hr, "SetProperty(DN)");
    }
}


WCHAR const *
PKCSMapAttributeName(
    OPTIONAL IN WCHAR const *pwszAttributeName,
    OPTIONAL IN CHAR const *pszObjId,
    OUT DWORD *pdwIndex,
    OUT DWORD *pcchMax)
{
    SUBJECTTABLE const *pSubjectTable;
    WCHAR const *pwszPropName = NULL;

    for (pSubjectTable = pkcs_subject; ; pSubjectTable++)
    {
	WCHAR const * const *ppwsz;

	if (NULL == pSubjectTable->pwszPropName)
	{
	    goto error;
	}
	if (NULL != pwszAttributeName)
	{
	    for (ppwsz = pSubjectTable->apwszAttributeName;
		 NULL != *ppwsz;
		 ppwsz++)
	    {
		if (0 == mylstrcmpiS(pwszAttributeName, *ppwsz))
		{
		    break;
		}
	    }
	    if (NULL != *ppwsz ||
		0 == mylstrcmpiS(pwszAttributeName, pSubjectTable->pwszPropName))
	    {
		break;
	    }
	}
	if (NULL != pszObjId &&
	    0 == strcmp(pszObjId, pSubjectTable->pszObjId))
	{
	    break;
	}
    }
    CSASSERT(NULL != pSubjectTable->pwszPropName);
    pwszPropName = pSubjectTable->pwszPropName;
    *pdwIndex = pSubjectTable->dwSubjectTableIndex;
    *pcchMax = pSubjectTable->cchMax;

error:
    return(pwszPropName);
}


HRESULT
pkcsFindCAContext(
    IN DWORD iCert,		// MAXDWORD -> use current
    IN DWORD iKey,		// MAXDWORD -> use current
    OUT CACTX **ppCAContext)
{
    HRESULT hr = E_INVALIDARG;
    DWORD i;
    CACTX *pCAContext;

    *ppCAContext = NULL;

    // Lookup is either by cert index OR by key index, but not both or neither

    CSASSERT((MAXDWORD == iCert) ^ (MAXDWORD == iKey));

    if (MAXDWORD != iCert)
    {
	if ((~_16BITMASK & iCert) || iCert >= g_cCACerts)
	{
	    _JumpError(hr, error, "bad cert index");
	}
	*ppCAContext = &g_aCAContext[iCert];
	CSASSERT(iCert == (*ppCAContext)->iCert);
    }
    else
    {
	CSASSERT(MAXDWORD != iKey);

	if ((~_16BITMASK & iKey) || iKey >= g_cCAKeys)
	{
	    _JumpError(hr, error, "bad key index");
	}
	for (i = g_cCACerts; ; i--)
	{
	    if (0 == i)
	    {
		_JumpError(hr, error, "key index not found");
	    }
	    pCAContext = &g_aCAContext[i - 1];
	    if (iKey == pCAContext->iKey)
	    {
		*ppCAContext = pCAContext;
		break;
	    }
	}
    }
    hr = S_OK;		// found it!

error:
    return(hr);
}


// Returns Cert Index in *piCert on success.
//
// returned in *piCert:
//  If iCert input value is not MAXDWORD, validate & return iCert.
//  If iCert input value is MAXDWORD, return the most current Cert Index.

HRESULT
PKCSMapCertIndex(
    IN DWORD iCert,
    OUT DWORD *piCert,
    OUT DWORD *pState)
{
    HRESULT hr;
    CACTX *pCAContext;
    DBGCODE(DWORD iCertSave = iCert);

    *pState = CA_DISP_ERROR;
    if (MAXDWORD == iCert)
    {
	iCert = g_cCACerts - 1;
    }
    if (iCert >= g_cCACerts)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad CertIndex");
    }
    pCAContext = &g_aCAContext[iCert];
    hr = PKCSVerifyCAState(pCAContext);
    _PrintIfError(hr, "PKCSVerifyCAState");

    *pState = CA_DISP_VALID;
    if (CTXF_CERTMISSING & pCAContext->Flags)
    {
	*pState = CA_DISP_ERROR;
    }
    else
    if (CTXF_REVOKED & pCAContext->Flags)
    {
	*pState = CA_DISP_REVOKED;
    }
    else
    if (CTXF_EXPIRED & pCAContext->Flags)
    {
	*pState = CA_DISP_INVALID;
    }
    *piCert = iCert;
    hr = S_OK;

error:
    DBGPRINT((
            DBG_SS_CERTSRVI,
	    "PKCSMapCertIndex(%u) --> %u, s=%u, hr=%x\n",
	    iCertSave,
	    *piCert,
	    *pState,
	    hr));
    return(hr);
}


VOID
pkcsVerifyCACrossState(
    IN OUT CACROSSCTX *pCACross)
{
    HRESULT hr;
    
    if (0 == pCACross->Flags && NULL != pCACross->pccCACross)
    {
	hr = myVerifyCertContext(
			    pCACross->pccCACross,	// pCert
			    0,				// dwFlags
			    0,				// cUsageOids
			    NULL,			// apszUsageOids
			    HCCE_LOCAL_MACHINE,		// hChainEngine
			    NULL,			// hAdditionalStore
			    NULL);			// ppwszMissingIssuer
	pCACross->hrVerifyStatus = hr;
	if (S_OK != hr)
	{
	    _PrintError2(hr, "myVerifyCertContext", CRYPT_E_REVOCATION_OFFLINE);
	    if (CERT_E_UNTRUSTEDROOT == hr || TRUST_E_CERT_SIGNATURE == hr)
	    {
		hr = S_OK;
	    }
	    else
	    if (CERT_E_EXPIRED == hr)
	    {
		pCACross->Flags |= CTXF_EXPIRED;
	    }
	    else if (CRYPT_E_REVOKED == hr || CERT_E_REVOKED == hr)
	    {
		pCACross->Flags |= CTXF_REVOKED;
	    }
	    else if (CRYPT_E_REVOCATION_OFFLINE == hr)
	    {
		HRESULT hr2;
		DWORD dwState;

		hr2 = GetSetupStatus(NULL, &dwState);
		if ((S_OK == hr2 && (SETUP_CREATEDB_FLAG & dwState)) ||
		    CERTLOG_WARNING > g_dwLogLevel)
		{
		    hr = S_OK;
		}
	    }
	    else if (CRYPT_E_NO_REVOCATION_CHECK == hr)
	    {
		if (CERTLOG_VERBOSE > g_dwLogLevel)
		{
		    hr = S_OK;
		}
	    }
	    _JumpIfError(hr, error, "myVerifyCertContext");
	}
    }
error:
    ;
}


// Returns Cert Index in *piCert on success.
//
// returned in *piCert:
//  If iCert input value is not MAXDWORD, validate & return iCert.
//  If iCert input value is MAXDWORD, return the most current Cert Index.

HRESULT
pkcsMapCrossCertIndex(
    IN BOOL fForward,
    IN DWORD iCert,
    OUT DWORD *piCert,
    OUT DWORD *pState)
{
    HRESULT hr;
    CACROSSCTX *pCACross;
    DBGCODE(DWORD iCertSave = iCert);

    *pState = CA_DISP_ERROR;
    if (MAXDWORD == iCert)
    {
	iCert = g_cCACerts - 1;
    }
    if (iCert >= g_cCACerts)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad CertIndex");
    }
    pCACross = fForward? g_aCACrossForward : g_aCACrossBackward;
    if (NULL != pCACross)
    {
	pCACross += iCert;

	if (NULL != pCACross->pccCACross)
	{
	    pkcsVerifyCACrossState(pCACross);

	    *pState = CA_DISP_VALID;
	    if (CTXF_CERTMISSING & pCACross->Flags)
	    {
		*pState = CA_DISP_ERROR;
	    }
	    else
	    if (CTXF_REVOKED & pCACross->Flags)
	    {
		*pState = CA_DISP_REVOKED;
	    }
	    else
	    if (CTXF_EXPIRED & pCACross->Flags)
	    {
		*pState = CA_DISP_INVALID;
	    }
	}
    }
    *piCert = iCert;
    hr = S_OK;

error:
    DBGPRINT((
            DBG_SS_CERTSRVI,
	    "PKCSMapCrossCertIndex(%u) --> %u, s=%u, hr=%x\n",
	    iCertSave,
	    *piCert,
	    *pState,
	    hr));
    return(hr);
}


// Returns Cert Index in *piCert and CRL Index in *piCRL on success.
//
// returned in *piCert:
//  If iCert input value is not MAXDWORD, validate iCert.  Look up the newest
//  Cert Index that uses the same key as the passed iCert.
//  If iCert input value is MAXDWORD, return the most current Cert Index.
//
// returned in *piCRL:
//  CRL index (same as Key Index)
//

HRESULT
PKCSMapCRLIndex(
    IN DWORD iCert,
    OUT DWORD *piCert,	// returns newest iCert w/matching iKey for passed iCert
    OUT DWORD *piCRL,
    OUT DWORD *pState)
{
    HRESULT hr;
    CACTX *pCAContext;
    CACTX *pCAContextNewest;
    DWORD i;
    DBGCODE(DWORD iCertSave = iCert);

    hr = PKCSMapCertIndex(iCert, piCert, pState);
    _JumpIfError(hr, error, "PKCSMapCertIndex");

    // Now we know *piCert is a valid Cert Index:

    pCAContext = &g_aCAContext[*piCert];
    *piCRL = pCAContext->iKey;

    // find the newest iCert with matching iKey

    for (i = *piCert + 1; i < g_cCACerts; i++)
    {
	if (*piCRL != g_aCAContext[i].iKey)
	{
	    break;
	}
	*piCert = i;
    }
    pCAContextNewest = &g_aCAContext[*piCert];

    if (CTXF_CRLZOMBIE & pCAContext->Flags)
    {
	*pState = CA_DISP_VALID;
    }
    else
    if (pCAContext->iCert != pCAContext->iKey)
    {
	*pState = CA_DISP_ERROR;
    }
    else
    if ((CTXF_EXPIRED & pCAContext->Flags) &&
	0 == (CTXF_SKIPCRL & pCAContextNewest->Flags))
    {
	*pState = CA_DISP_VALID;
    }
    hr = S_OK;

error:
    DBGPRINT((
            DBG_SS_CERTSRVI,
	    "PKCSMapCRLIndex(%u) --> %u, iCRL=%u, s=%u, hr=%x\n",
	    iCertSave,
	    *piCert,
	    *piCRL,
	    *pState,
	    hr));
    return(hr);
}


HRESULT
PKCSGetCACertStatusCode(
    IN DWORD iCert,
    OUT HRESULT *phrCAStatusCode)
{
    HRESULT hr;
    DWORD State;
    
    *phrCAStatusCode = E_FAIL;

    hr = PKCSMapCertIndex(iCert, &iCert, &State);
    _JumpIfError(hr, error, "PKCSMapCertIndex");

    *phrCAStatusCode = g_aCAContext[iCert].hrVerifyStatus;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
PKCSGetCAState(
    IN LONG PropId,	// CR_PROP_*
    OUT BYTE *pb)
{
    HRESULT hr = S_OK;
    DWORD i;

    for (i = 0; i < g_cCACerts; i++)
    {
	DWORD State;

	switch (PropId)
	{
	    DWORD iCert;
	    DWORD iCRL;

	    case CR_PROP_CAFORWARDCROSSCERTSTATE:
	    case CR_PROP_CABACKWARDCROSSCERTSTATE:
		hr = pkcsMapCrossCertIndex(
				CR_PROP_CAFORWARDCROSSCERTSTATE == PropId,
				i,
				&iCert,
				&State);
		_JumpIfError(hr, error, "pkcsMapCrossCertIndex");

		break;

	    case CR_PROP_CACERTSTATE:
	    case CR_PROP_CACERTVERSION:
		hr = PKCSMapCertIndex(i, &iCert, &State);
		_JumpIfError(hr, error, "PKCSMapCertIndex");

		break;

	    case CR_PROP_CRLSTATE:
		hr = PKCSMapCRLIndex(i, &iCert, &iCRL, &State);
		_JumpIfError(hr, error, "PKCSMapCRLIndex");

		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "PropId");

		break;
	}
	CSASSERT(0 == (~0xff & State));
	*pb++ = (BYTE) State;
    }

error:
    return(hr);
}


HRESULT
PKCSGetCAVersion(
    OUT DWORD *pdw)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < g_cCACerts; i++)
    {
	DWORD State;
	DWORD iCert;

	hr = PKCSMapCertIndex(i, &iCert, &State);
	_JumpIfError(hr, error, "PKCSMapCertIndex");

	// Now we know iCert is a valid Cert Index:

	*pdw++ = g_aCAContext[iCert].NameId;
    }
    hr = S_OK;

error:
    return(hr);
}


inline DWORD
MapHRESULTToKRADisposition(
    IN HRESULT hr)
{
    switch(hr)
    {
	case CERT_E_EXPIRED:    return KRA_DISP_EXPIRED;

	case CRYPT_E_NOT_FOUND: return KRA_DISP_NOTFOUND;

	case CERT_E_REVOKED:
	case CRYPT_E_REVOKED:   return KRA_DISP_REVOKED;

	case S_OK:              return KRA_DISP_VALID;

	case CERT_E_UNTRUSTEDROOT:
	case CERT_E_CHAINING:   return KRA_DISP_UNTRUSTED;

	case ERROR_NOT_FOUND:   return KRA_DISP_NOTLOADED;

	default:                return KRA_DISP_INVALID;
    }
}


HRESULT
PKCSGetKRAState(
    IN DWORD cKRA,
    OUT BYTE *pb)
{
    HRESULT hr = S_OK;
    DWORD dwCount;
    HCERTSTORE hKRAStore = NULL;
    CERT_CONTEXT const *pCertContext = NULL;

    hKRAStore = CertOpenStore(
		    CERT_STORE_PROV_SYSTEM_W,
		    X509_ASN_ENCODING,
		    NULL,                   // hProv
		    CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
		    wszKRA_CERTSTORE);
    if (NULL == hKRAStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore KRA");
    }

    for (dwCount = 0; dwCount < cKRA; dwCount++)
    {
        hr = myFindCACertByHashIndex(
			hKRAStore,
			g_wszSanitizedName,
			CSRH_CAKRACERT,
			dwCount,
			NULL,
			&pCertContext);
        if (S_OK == hr)
        {
            hr = myVerifyKRACertContext(pCertContext, g_dwVerifyCertFlags);
            
            // check if the CA is using this cert (was able to load it last
	    // time it started)

            if (S_OK == hr)
            {
                hr = ERROR_NOT_FOUND;
		if (NULL != g_aKRAContext)
		{
		    DWORD iKRALoaded;

		    for (iKRALoaded = 0; iKRALoaded < g_cKRACerts; iKRALoaded++)
		    {
			if (myAreCertContextBlobsSame(
					    pCertContext,
					    g_aKRAContext[iKRALoaded].pccKRA))
			{
			    // the CA loaded this KRA cert

			    hr = g_aKRAContext[iKRALoaded].hrVerifyStatus;
			    break;
			}
		    }
		}
            }
        }

        CSASSERT(0 == (~0xff & MapHRESULTToKRADisposition(hr)));
        pb[dwCount] = (BYTE)MapHRESULTToKRADisposition(hr);
        hr = S_OK;
        CertFreeCertificateContext(pCertContext);
        pCertContext = NULL;
    }

error:

    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if (NULL != hKRAStore)
    {
        CertCloseStore(hKRAStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }

    return hr;
}


HRESULT
pkcsSetRequestNameInfo(
    IN ICertDBRow *prow,
    IN CERT_NAME_BLOB const *pSubject,
    OPTIONAL IN WCHAR const *pwszCNSuffix,
    IN BOOL fReorderLikeRDNs,
    IN OUT DWORD *pdwRequestFlags,
    OUT BOOL *pfSubjectNameSet)
{
    HRESULT hr;
    CERT_RDN *prdn;
    CERT_RDN *prdnEnd;
    CERT_NAME_INFO *pNameInfo = NULL;
    WCHAR const *pwszPropName;
    DWORD cbNameInfo;
    DWORD dwIndex;
    DWORD cchMax;
    BYTE afSubjectTable[CSUBJECTTABLE];	// see PKCSParseAttributes note

    *pfSubjectNameSet = FALSE;
    ZeroMemory(afSubjectTable, sizeof(afSubjectTable));
    CSASSERT(CSExpr(0 == FALSE));

    hr = prow->SetProperty(
		    g_wszPropSubjectRawName,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    pSubject->cbData,
		    pSubject->pbData);
    _JumpIfError(hr, error, "SetProperty");

    pkcsSetDistinguishedName(prow, PROPTABLE_REQUEST, pSubject);

    if (!myDecodeName(
                X509_ASN_ENCODING,
		X509_UNICODE_NAME,
                pSubject->pbData,
                pSubject->cbData,
                CERTLIB_USE_LOCALALLOC,
                &pNameInfo,
                &cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    if (ENUM_TELETEX_ON == (ENUM_TELETEX_MASK & g_fForceTeletex))
    {
        *pdwRequestFlags |= CR_FLG_FORCETELETEX;
    }
    if (ENUM_TELETEX_UTF8 & g_fForceTeletex)
    {
        *pdwRequestFlags |= CR_FLG_FORCEUTF8;
    }
    if (fReorderLikeRDNs)
    {
	DWORD dwSubjectTemplateIndex = 0;
	
	for (
	    prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	    fReorderLikeRDNs && prdn < prdnEnd;
	    prdn++)
	{
	    if (1 != prdn->cRDNAttr)
	    {
		fReorderLikeRDNs = FALSE;
		break;
	    }
	    pwszPropName = PKCSMapAttributeName(
					    NULL,
					    prdn->rgRDNAttr[0].pszObjId,
					    &dwIndex,
					    &cchMax);
	    if (NULL != pwszPropName)
	    {
		DBGPRINT((
			DBG_SS_CERTSRVI,
			"dwSubjectTemplateIndex: %x -> %x\n",
			dwSubjectTemplateIndex,
			pkcs_subject[dwIndex].dwSubjectTemplateIndex));
		if (MAXDWORD == pkcs_subject[dwIndex].dwSubjectTemplateIndex ||
		    dwSubjectTemplateIndex >
			pkcs_subject[dwIndex].dwSubjectTemplateIndex)
		{
		    fReorderLikeRDNs = FALSE;
		    break;
		}
		dwSubjectTemplateIndex = 
			pkcs_subject[dwIndex].dwSubjectTemplateIndex;
	    }
	}
    }

    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    switch (prdna->dwValueType)
	    {
		case CERT_RDN_PRINTABLE_STRING:
		case CERT_RDN_UNICODE_STRING:
		case CERT_RDN_TELETEX_STRING:
		case CERT_RDN_IA5_STRING:
		case CERT_RDN_UTF8_STRING:
		    break;

		default:
		    continue;
	    }

	    if (NULL == prdna->Value.pbData ||
		sizeof(WCHAR) > prdna->Value.cbData ||
		((sizeof(WCHAR) - 1) & prdna->Value.cbData) ||
		L'\0' == *(WCHAR *) prdna->Value.pbData ||
		L'\0' != *(WCHAR *) &prdna->Value.pbData[prdna->Value.cbData])
	    {
		continue;
	    }

            if (CERT_RDN_TELETEX_STRING == prdna->dwValueType &&
                ENUM_TELETEX_AUTO == (ENUM_TELETEX_MASK & g_fForceTeletex))
            {
                *pdwRequestFlags |= CR_FLG_FORCETELETEX;
            }

	    pwszPropName = PKCSMapAttributeName(
					NULL,
					prdna->pszObjId,
					&dwIndex,
					&cchMax);
	    if (NULL != pwszPropName)
            {
                BOOL fCN;

		// CAPI null-terminates strings

                CSASSERT(
		 sizeof(WCHAR) * wcslen((WCHAR const *) prdna->Value.pbData) ==
		 prdna->Value.cbData);

		fCN = 0 == strcmp(szOID_COMMON_NAME, prdna->pszObjId);

		hr = PropSetAttributeProperty(
				prow,
				afSubjectTable[dwIndex], // fConcatenateRDNs
				fReorderLikeRDNs,
				PROPTABLE_REQUEST,
				cchMax,
				fCN? pwszCNSuffix : NULL,
				pwszPropName,
				(WCHAR const *) prdna->Value.pbData);
		if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) == hr)
		{
		    hr = CERTSRV_E_BAD_REQUESTSUBJECT;
		}
		_JumpIfError(hr, error, "PropSetAttributeProperty");

		afSubjectTable[dwIndex] = TRUE;
		*pfSubjectNameSet = TRUE;

		if (fCN)
		{
		    pwszCNSuffix = NULL;
		}
            }
        }
    }
    hr = S_OK;

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


HRESULT
PKCSSetRequestFlags(
    IN ICertDBRow *prow,
    IN BOOL fSet,
    IN DWORD dwChange)
{
    HRESULT hr;
    DWORD dwOld;
    DWORD dwNew;
    DWORD cb;
    
    cb = sizeof(dwOld);
    hr = prow->GetProperty(
		g_wszPropRequestFlags,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		NULL,
		&cb,
		(BYTE *) &dwOld);
    _JumpIfError(hr, error, "GetProperty");

    if (fSet)
    {
	dwNew = dwOld | dwChange;
    }
    else
    {
	dwNew = dwOld & ~dwChange;
    }

    if (dwOld != dwNew)
    {
	hr = prow->SetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(dwNew),
		    (BYTE const *) &dwNew);
	_JumpIfError(hr, error, "SetProperty(RequestFlags)");
    }

error:
    return(hr);
}


HRESULT
pkcsSetAttributeProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValue,
    IN DWORD dwTable,
    IN BYTE afSubjectTable[],
    OUT BOOL *pfSubjectModified,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf)
{
    HRESULT hr;
    WCHAR const *pwszPropName;
    DWORD dwIndex;
    DWORD cwcMax;
    BOOL fConcatenateRDNs;

    *pfSubjectModified = FALSE;
    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }

    pwszPropName = NULL;
    cwcMax = MAXDWORD;
    dwIndex = 0;
    if (CRLF_ALLOW_REQUEST_ATTRIBUTE_SUBJECT & g_dwCRLFlags)
    {
	// See if the attribute name can be mapped to a standard property.

	pwszPropName = PKCSMapAttributeName(pwszName, NULL, &dwIndex, &cwcMax);
    }
    if (NULL != pwszPropName)
    {
	fConcatenateRDNs = afSubjectTable[dwIndex];
	afSubjectTable[dwIndex] = TRUE;
	*pfSubjectModified = TRUE;
    }
    else
    {
	pwszPropName = pwszName;
	fConcatenateRDNs = FALSE;
	dwTable = PROPTABLE_ATTRIBUTE;

	if (0 == mylstrcmpiS(pwszPropName, g_wszPropRequesterName))
	{
	    if (NULL == pfEnrollOnBehalfOf)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "NULL pfEnrollOnBehalfOf");
	    }
	    *pfEnrollOnBehalfOf = TRUE;
	    dwTable = PROPTABLE_REQUEST;
	}
    }
    hr = PropSetAttributeProperty(
			    prow,
			    fConcatenateRDNs,
			    FALSE,	// fPrependNewValue
			    dwTable,
			    cwcMax,
			    NULL,	// pwszSuffix
			    pwszPropName,
			    pwszValue);
    _JumpIfError(hr, error, "PropSetAttributeProperty");

error:
    return(hr);
}


// Note on Request Attribute and Subject RDN processing:
//
// Subject RDN strings and Request Attributes may be set several ways, in
// the following order.  Subsequent changes overwrite earlier changes, so the
// order implies precedence:
//
// - Subject in the inner PKCS10 (if no PKCS10 subject, then use the Subject
//	in the PKCS7 renewal cert)
// - the next outer PKCS7 or CMC Attributes 
// - ...
// - the most outer PKCS7 or CMC Attributes 
// - Request Attribute string passed with the request when first submitted
// - Policy Module may set subject RDNs in the certificate table
// - ICertAdmin::SetAttributes' Request Attribute string (if request pending)
//
// "PKCS7 or CMC Attributes" means either of the following:
// 1) Authenticated Attributes associated with a (non-CMC) PKCS7 signer info.
// 2) Tagged Attributes and/or RegInfo Control Attributes in a CMC request.
//
// None of the secured attributes listed in the registry (which is set to
// wszzDEFAULTSIGNEDATTRIBUTES by default) may be set unless the source is
// PKCS7 or CMC Attributes.
//
// The original request attribute string is stored in the RequestAttributes
// column in the request table.  It is never modified after that.  Individual
// request attribute values are parsed out of this string (when the request is
// submitted and when ICertAdmin::SetAttributes is called) and stored in a
// Subject RDN column of the request or certificate table if the attribute
// name matches an alias for a Subject RDN, or in a unique row in the
// attribute table otherwise.
//
// Individual Subject RDNs may be specified multiple times (multiple "OU",
// "CN", strings).  If all of the RDNs were set from the same source,
// they must be concatenated, but if some RDNs were specified from one source,
// then modified by another source, the previous set of RDNs should be
// overwritten by the new ones.  If the original Request Attribute string
// specified "CN:foo\nOU:ou2\nCN:bar", the two CN strings should be
// concatenated.  If one or more CN values are also specified later by a
// single call to ICertAdmin::SetAttributes, the original CN values should be
// overwritten by the new value(s).
//
// It is possible to have the CN strings specified by one source and the OU
// strings specified by another.
//
// Before the policy module gets control, all Subject RDN changes are written
// to the Request table.  Just before dispatching to the policy module, the
// Request Subject RDNs are copied to the Certificate Table RDNs.  The policy
// module may modify the Certificate Table RDNs only.
//
// If the request is made pending, ICertAdmin::SetAttributes may be used to
// modify request attributes and Certificate Table RDNs.
//
// The certificate Subject is constructed from the Certificate Table RDNs.

HRESULT
PKCSParseAttributes(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszAttributes,
    IN BOOL fRegInfo,
    IN BOOL fPending,
    IN DWORD dwRDNTable,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszBuf;
    WCHAR const *pwszName;
    WCHAR const *pwszValue;
    DWORD iSecuredAttribute;
    BYTE afSubjectTable[CSUBJECTTABLE];	// see PKCSParseAttributes note
    WCHAR *pwszNameAlloc = NULL;
    WCHAR *pwszValueAlloc = NULL;
    BOOL fSubjectModified = FALSE;
    static WCHAR const s_wszzPendingAttributes[] =
	wszPROPCERTTEMPLATE
	L"\0";

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }
    if (NULL == pwszAttributes)
    {
	hr = S_OK;
        goto error;		// silently ignore empty string
    }

    hr = myDupString(pwszAttributes, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszBuf = pwszDup;

    ZeroMemory(afSubjectTable, sizeof(afSubjectTable));
    CSASSERT(CSExpr(0 == FALSE));

    for (;;)
    {
	hr = myParseNextAttribute(&pwszBuf, fRegInfo, &pwszName, &pwszValue);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "myParseNextAttribute");

	if (fRegInfo)
	{
	    if (NULL != pwszNameAlloc)
	    {
		LocalFree(pwszNameAlloc);
		pwszNameAlloc = NULL;
	    }
	    if (NULL != pwszValueAlloc)
	    {
		LocalFree(pwszValueAlloc);
		pwszValueAlloc = NULL;
	    }
	    hr = myUncanonicalizeURLParm(pwszName, &pwszNameAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    hr = myUncanonicalizeURLParm(pwszValue, &pwszValueAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    pwszName = pwszNameAlloc;
	    pwszValue = pwszValueAlloc;
	}

	iSecuredAttribute = MAXDWORD;
	if (!fRegInfo)
	{
	    // Only set the attribute if it's not one of the attributes
	    // that is required to be secure.

	    iSecuredAttribute = CRLIsStringInList(
					    pwszName,
					    g_wszzSecuredAttributes);
	}
        if (fPending && MAXDWORD == iSecuredAttribute)
	{
	    // Only set the attribute if it's not one of the attributes
	    // that is disallowed for pending requests.

	    iSecuredAttribute = CRLIsStringInList(
					    pwszName,
					    s_wszzPendingAttributes);
	}
        if (MAXDWORD == iSecuredAttribute)
        {
	    BOOL fEnrollOnBehalfOf = FALSE;
	    BOOL fSubjectModifiedT = FALSE;

	    hr = pkcsSetAttributeProperty(
			prow,
			pwszName,
			pwszValue,
			dwRDNTable,
			afSubjectTable,
			&fSubjectModified,
			NULL != pfEnrollOnBehalfOf? &fEnrollOnBehalfOf : NULL);
	    _JumpIfError(hr, error, "PKCSSetRequestFlags");

	    if (fSubjectModifiedT)
	    {
		fSubjectModified = TRUE;
	    }
	    if (fEnrollOnBehalfOf)
	    {
		*pfEnrollOnBehalfOf = TRUE;
	    }
        }
    }
    if (fSubjectModified)
    {
	hr = PKCSSetRequestFlags(prow, FALSE, CR_FLG_SUBJECTUNMODIFIED);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");
    }
    hr = S_OK;

error:
    if (NULL != pwszNameAlloc)
    {
	LocalFree(pwszNameAlloc);
    }
    if (NULL != pwszValueAlloc)
    {
	LocalFree(pwszValueAlloc);
    }
    if (NULL != pwszDup)
    {
        LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
pkcsSetAltSubjectNameExtension(
    IN ICertDBRow *prow,
    IN DWORD ExtFlags,
    IN CERT_EXTENSION const *rgExtension,
    IN DWORD cExtension,
    IN DWORD cAltSubjectExtension)
{
    HRESULT hr = S_OK;
    CERT_ALT_NAME_INFO **apInfo = NULL;
    DWORD i;
    DWORD j;
    DWORD cInfo = 0;
    DWORD cb;
    CERT_ALT_NAME_INFO ResultInfo;
    DWORD cbResult;
    BYTE *pbResult = NULL;

    ResultInfo.cAltEntry = 0;
    ResultInfo.rgAltEntry = NULL;

    apInfo = (CERT_ALT_NAME_INFO **) LocalAlloc(
			LMEM_FIXED,
			sizeof(CERT_ALT_NAME_INFO *) * cAltSubjectExtension);
    if (NULL == apInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // Decode all AltNames

    for (i = 0; i < cExtension; i++)
    {
        // This is an OID, generated by capi2, so we don't need to
        // do a case-insensitive comparison

        if (0 == strcmp(rgExtension[i].pszObjId, szOID_SUBJECT_ALT_NAME2))
        {
	    CSASSERT(cInfo < cAltSubjectExtension);

            // Decode to plain text

            if (!myDecodeObject(
		            X509_ASN_ENCODING,
		            X509_ALTERNATE_NAME,
		            rgExtension[i].Value.pbData,
		            rgExtension[i].Value.cbData,
		            CERTLIB_USE_LOCALALLOC,
		            (VOID **) &apInfo[cInfo],
		            &cb))
            {
		hr = myHLastError();
                _JumpError(hr, error, "myDecodeObject");
            }
            if (rgExtension[i].fCritical)
            {
                ExtFlags |= EXTENSION_CRITICAL_FLAG;
            }
            ResultInfo.cAltEntry += apInfo[cInfo]->cAltEntry;
            cInfo++;
        }
    }
    CSASSERT(cInfo == cAltSubjectExtension);

    ResultInfo.rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
			LMEM_FIXED,
			ResultInfo.cAltEntry * sizeof(CERT_ALT_NAME_ENTRY));
    if (NULL == ResultInfo.rgAltEntry)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "LocalAlloc");
    }

    j = 0;
    for (i = 0; i < cInfo; i++)
    {
        CopyMemory(
		&ResultInfo.rgAltEntry[j],
		apInfo[i]->rgAltEntry,
		apInfo[i]->cAltEntry * sizeof(CERT_ALT_NAME_ENTRY));
        j += apInfo[i]->cAltEntry;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &ResultInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbResult,
		    &cbResult))
    {
	hr = myHLastError();
        _JumpError(hr, error, "myEncodeObject");
    }

    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_REQUEST,
		    TEXT(szOID_SUBJECT_ALT_NAME2),
		    ExtFlags,
		    cbResult,
		    pbResult);
    _JumpIfError(hr, error, "PropSetExtension");

error:
    if (NULL != apInfo)
    {
        for (i = 0; i < cInfo; i++)
        {
            if (NULL != apInfo[i])
            {
                LocalFree(apInfo[i]);
            }
        }
        LocalFree(apInfo);
    }
    if (NULL != ResultInfo.rgAltEntry)
    {
        LocalFree(ResultInfo.rgAltEntry);
    }
    if (NULL != pbResult)
    {
        LocalFree(pbResult);
    }
    return(hr);
}


// Scan extension array, and merge all the AltSubjectName Extensions into one.

HRESULT
pkcsSetExtensions(
    IN ICertDBRow *prow,
    IN DWORD ExtFlags,
    IN CERT_EXTENSION const *rgExtension,
    IN DWORD cExtension)
{
    HRESULT hr;
    WCHAR *pwszObjId = NULL;
    CERT_EXTENSION const *pExt;
    CERT_EXTENSION const *pExtEnd;
    DWORD cAltSubjectExtension = 0;

    pExtEnd = &rgExtension[cExtension];
    for (pExt = rgExtension; pExt < pExtEnd; pExt++)
    {
	DWORD ExtFlagsT;

	if (EXTENSION_ORIGIN_RENEWALCERT == (EXTENSION_ORIGIN_MASK & ExtFlags))
	{
	    char const * const *ppszObjId;
	    static char const * const apszObjIdFilter[] = {
		szOID_CERTSRV_CA_VERSION,
		szOID_AUTHORITY_INFO_ACCESS,
		szOID_CRL_DIST_POINTS,
		szOID_AUTHORITY_KEY_IDENTIFIER2,
		szOID_SUBJECT_KEY_IDENTIFIER,
		NULL
	    };
	    for (ppszObjId = apszObjIdFilter; NULL != *ppszObjId; ppszObjId++)
	    {
		if (0 == strcmp(*ppszObjId, pExt->pszObjId))
		{
		    break;
		}
	    }
	    if (NULL != *ppszObjId)	// if in list
	    {
		continue;		// skip this extension
	    }
	}
	else
	if (EXTENSION_ORIGIN_CACERT == (EXTENSION_ORIGIN_MASK & ExtFlags))
	{
	    char const * const *ppszObjId;
	    static char const * const apszObjIdAllowed[] = {
		szOID_SUBJECT_KEY_IDENTIFIER,
		NULL
	    };
	    for (ppszObjId = apszObjIdAllowed; NULL != *ppszObjId; ppszObjId++)
	    {
		if (0 == strcmp(*ppszObjId, pExt->pszObjId))
		{
		    break;
		}
	    }
	    if (NULL == *ppszObjId)	// if not in list
	    {
		continue;		// skip this extension
	    }
	}

	if (NULL != pwszObjId)
	{
	    LocalFree(pwszObjId);
	    pwszObjId = NULL;
	}
	if (!myConvertSzToWsz(&pwszObjId, pExt->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz(ObjId)");
	}
	ExtFlagsT = ExtFlags;
	if (pExt->fCritical)
	{
	    ExtFlagsT |= EXTENSION_CRITICAL_FLAG;
	}

        // AltSubjectName needs to be merged, so we do that later.
        // This is an OID, generated by capi2, so we don't need to
        // do a case-insensitive comparison.

        if (0 == lstrcmp(pwszObjId, TEXT(szOID_SUBJECT_ALT_NAME2)))
        {
	    cAltSubjectExtension++;
            continue;
        }

	hr = PropSetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_REQUEST,
			pwszObjId,
			ExtFlagsT,
			pExt->Value.cbData,
			pExt->Value.pbData);
	_JumpIfError(hr, error, "PropSetExtension");

	DBGPRINT((
		DBG_SS_CERTSRVI,
		"PropSetExtension(%ws, f=%x, cb=%x, pb=%x)\n",
		pwszObjId,
		ExtFlagsT,
		pExt->Value.cbData,
		pExt->Value.pbData));
    }

    if (0 != cAltSubjectExtension)
    {
	hr = pkcsSetAltSubjectNameExtension(
					prow,
					ExtFlags,
					rgExtension,
					cExtension,
					cAltSubjectExtension);
	_JumpIfError(hr, error, "pkcsSetAltSubjectNameExtension");
    }
    hr = S_OK;

error:
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsSetOSVersion(
    IN ICertDBRow *prow,
    IN CRYPT_ATTR_BLOB *pAttrBlob)
{
    HRESULT hr;
    CERT_NAME_VALUE *pOSVersionString = NULL;
    BSTR strVersion = NULL;
    DWORD cb;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_ANY_STRING,
		    pAttrBlob->pbData,
		    pAttrBlob->cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pOSVersionString,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (NULL != pOSVersionString)
    {
	if (!IS_CERT_RDN_CHAR_STRING(pOSVersionString->dwValueType))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "version string is numeric data");
	}

	// If it's an 8 bit string, convert it to UNICODE

	if (CERT_RDN_UNIVERSAL_STRING > pOSVersionString->dwValueType)
	{
	    // Pass byte count in to allocate enough characters for
	    // the converted Unicode string

	    strVersion = SysAllocStringLen(
					NULL,
					pOSVersionString->Value.cbData);

	    // This is expected to be only numbers and '.'s,

	    if (NULL == strVersion)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "SysAllocStringLen");
	    }
	    mbstowcs(
		strVersion,
		(char const *) pOSVersionString->Value.pbData,
		pOSVersionString->Value.cbData);
	}
	else if (CERT_RDN_BMP_STRING == pOSVersionString->dwValueType ||
		 CERT_RDN_UNICODE_STRING == pOSVersionString->dwValueType)
	{
	    strVersion = SysAllocStringLen(
		    (WCHAR *) pOSVersionString->Value.pbData,
		    pOSVersionString->Value.cbData/sizeof(WCHAR));
	    if (NULL == strVersion)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "SysAllocStringLen");
	    }
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "unknown string type");
	}

	hr = prow->SetProperty(
			g_wszPropRequestOSVersion,
			PROPTYPE_STRING |
			    PROPCALLER_SERVER |
			    PROPTABLE_ATTRIBUTE,
			SysStringByteLen(strVersion),
			(BYTE *) strVersion);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = S_OK;

error:
    if (NULL != strVersion)
    {
	SysFreeString(strVersion);
    }
    if (NULL != pOSVersionString)
    {
	LocalFree(pOSVersionString);
    }
    return(hr);
}


HRESULT
pkcsSetCSPProvider(
    IN ICertDBRow *prow,
    IN CRYPT_ATTR_BLOB *pAttrBlob)
{
    HRESULT hr;
    CRYPT_CSP_PROVIDER *pccp = NULL;

    hr = myDecodeCSPProviderAttribute(
			    pAttrBlob->pbData,
			    pAttrBlob->cbData,
			    &pccp);
    _JumpIfError(hr, error, "myDecodeCSPProviderAttribute");

    if (NULL != pccp->pwszProviderName && L'\0' != *pccp->pwszProviderName)
    {
	hr = prow->SetProperty(
			g_wszPropRequestCSPProvider,
			PROPTYPE_STRING |
			    PROPCALLER_SERVER |
			    PROPTABLE_ATTRIBUTE,
			MAXDWORD,
			(BYTE const *) pccp->pwszProviderName);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = S_OK;

error:
    if (NULL != pccp)
    {
	LocalFree(pccp);
    }
    return(hr);
}


HRESULT
pkcsSetExtensionsFromAttributeBlob(
    IN ICertDBRow *prow,
    IN DWORD ExtFlags,
    IN CRYPT_ATTRIBUTE const *pAttrib)
{
    HRESULT hr;
    CRYPT_ATTR_BLOB *pAttrBlob;
    CERT_NAME_VALUE *pNameInfo = NULL;
    CERT_EXTENSIONS *pCertExtensions = NULL;
    DWORD cb;

    pAttrBlob = pAttrib->rgValue;
    for (;;)
    {
	if (NULL != pCertExtensions)
	{
	    LocalFree(pCertExtensions);
	    pCertExtensions = NULL;
	}
	if (myDecodeObject(
			X509_ASN_ENCODING,
			X509_EXTENSIONS,
			pAttrBlob->pbData,
			pAttrBlob->cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pCertExtensions,
			&cb))
	{
	    break;	// success
	}
	hr = myHLastError();

	// if we already decoded the attribute as a T61 string, or if it is
	// not a PKCS 9.14 attribute, fail -- we don't know what it contains.

	if (NULL != pNameInfo ||
	    0 != strcmp(pAttrib->pszObjId, szOID_RSA_certExtensions))
	{
	    _JumpError(hr, error, "myDecodeObject");
	}

	// Decode the attribute as a T61 string.  Some implementations wrap the
	// PKCS 9.14 extension array in an extra level of encoding as a Teletex
	// string.

	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_ANY_STRING,
			pAttrBlob->pbData,
			pAttrBlob->cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pNameInfo,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}

	// Loop again and try to decode the raw name blob as X509_EXTENSIONS.

	pAttrBlob = &pNameInfo->Value;
    }
    hr = pkcsSetExtensions(
		    prow,
		    EXTENSION_DISABLE_FLAG | ExtFlags,
		    pCertExtensions->rgExtension,
		    pCertExtensions->cExtension);
    _JumpIfError(hr, error, "pkcsSetExtensions(attributes)");

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    if (NULL != pCertExtensions)
    {
	LocalFree(pCertExtensions);
    }
    return(hr);
}


HRESULT
PKCSGetProperty(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    OPTIONAL OUT DWORD *pcbData,
    OUT BYTE **ppbData)
{
    HRESULT hr;
    BYTE *pbData = NULL;
    DWORD cbData;

    if (NULL != pcbData)
    {
	*pcbData = 0;
    }
    *ppbData = NULL;

    cbData = 0;
    hr = prow->GetProperty(pwszPropName, Flags, NULL, &cbData, pbData);
    _JumpIfError2(hr, error, "GetProperty", CERTSRV_E_PROPERTY_EMPTY);

    pbData = (BYTE *) LocalAlloc(LMEM_FIXED, cbData);
    if (NULL == pbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    hr = prow->GetProperty(pwszPropName, Flags, NULL, &cbData, pbData);
    _JumpIfError(hr, error, "GetProperty");

    if (NULL != pcbData)
    {
	*pcbData = cbData;
    }
    *ppbData = pbData;
    pbData = NULL;

error:
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    return(hr);
}


VOID
pkcsFreePublicKeyInfo(
    IN OUT CERT_PUBLIC_KEY_INFO *pPublicKeyInfo)
{
    if (NULL != pPublicKeyInfo->Algorithm.pszObjId)
    {
	LocalFree(pPublicKeyInfo->Algorithm.pszObjId);
    }
    if (NULL != pPublicKeyInfo->Algorithm.Parameters.pbData)
    {
	LocalFree(pPublicKeyInfo->Algorithm.Parameters.pbData);
    }
    if (NULL != pPublicKeyInfo->PublicKey.pbData)
    {
	LocalFree(pPublicKeyInfo->PublicKey.pbData);
    }
    ZeroMemory(pPublicKeyInfo, sizeof(*pPublicKeyInfo));
}


HRESULT
pkcsGetPublicKeyInfo(
    IN ICertDBRow *prow,
    OUT CERT_PUBLIC_KEY_INFO *pPublicKeyInfo)
{
    HRESULT hr;
    WCHAR *pwszObjId = NULL;

    ZeroMemory(pPublicKeyInfo, sizeof(*pPublicKeyInfo));
    hr = PKCSGetProperty(
		    prow,
		    g_wszPropCertificatePublicKeyAlgorithm,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    (BYTE **) &pwszObjId);
    _JumpIfError(hr, error, "PKCSGetProperty");

    if (!myConvertWszToSz(&pPublicKeyInfo->Algorithm.pszObjId, pwszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz(AlgObjId)");
    }

    hr = PKCSGetProperty(
		prow,
		g_wszPropCertificateRawPublicKeyAlgorithmParameters,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&pPublicKeyInfo->Algorithm.Parameters.cbData,
		&pPublicKeyInfo->Algorithm.Parameters.pbData);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfError(hr, error, "PKCSGetProperty");
    }

    hr = PKCSGetProperty(
		prow,
		g_wszPropCertificateRawPublicKey,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&pPublicKeyInfo->PublicKey.cbData,
		&pPublicKeyInfo->PublicKey.pbData);
    _JumpIfError(hr, error, "PKCSGetProperty");

error:
    if (S_OK != hr)
    {
	pkcsFreePublicKeyInfo(pPublicKeyInfo);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


VOID
pkcsLogKRACertError(
    IN DWORD LogMsg,
    IN DWORD iHash,
    OPTIONAL IN CERT_CONTEXT const *pcc,
    IN HRESULT hrLog)
{
    HRESULT hr;
    WCHAR awc[cwcDWORDSPRINTF];
    WCHAR *pwszName = NULL;
    WCHAR const *pwszError = NULL;
    WCHAR const *apwsz[3];

    wsprintf(awc, L"%u", iHash);
    apwsz[0] = awc;

    if (NULL != pcc)
    {
	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    &pcc->pCertInfo->Subject,
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    &pwszName);
	_PrintIfError(hr, "myCertNameToStr");
    }
    apwsz[1] = NULL != pwszName? pwszName : L"";

    pwszError = myGetErrorMessageText(hrLog, TRUE);
    apwsz[2] = NULL != pwszError? pwszError : L"";

    LogEvent(EVENTLOG_ERROR_TYPE, LogMsg, ARRAYSIZE(apwsz), apwsz);

//error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
}


HRESULT
pkcsCryptGetDefaultProvider(
    DWORD dwProvType,
    DWORD dwFlags,
    WCHAR **ppwszProvName)
{
    HRESULT hr;
    DWORD cb;

    *ppwszProvName = NULL;
    cb = 0;
    for (;;)
    {
	if (!CryptGetDefaultProvider(
			    dwProvType,
			    NULL,		// pdwReserved
			    dwFlags,
			    *ppwszProvName,
			    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGetDefaultProvider");
	}
	if (NULL != *ppwszProvName)
	{
	    break;
	}
	*ppwszProvName = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == *ppwszProvName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsEncryptPrivateKey(
    IN BYTE *pbDecrypted,
    IN DWORD cbDecrypted,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)	// CoTaskMem*
{
    HRESULT hr;
    DWORD i;
    DWORD iKRACert;
    DWORD cwc;
    CERT_CONTEXT const **rgKRACerts = NULL;
    WCHAR *pwszKRAHashes = NULL;
    DWORD *rgKRAIndexes = NULL;
    DWORD cKRAUsed;
    KRACTX *pKRAContext;
    BOOL fInvalidated;
    DWORD iKRAStart;
    WCHAR *pwszProviderName = NULL;
    static bool fUseCAProv = true;

    if (NULL != pResult->pbArchivedKey || NULL != pResult->pwszKRAHashes)
    {
	hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
	_JumpError(hr, error, "multiple archived keys");
    }

    CSASSERT(
	NULL != g_aKRAContext &&
	0 != g_cKRACerts &&
	0 != g_cKRACertsRoundRobin);

    rgKRAIndexes = (DWORD *) LocalAlloc(
			    LMEM_FIXED,
			    g_cKRACertsRoundRobin * sizeof(rgKRAIndexes[0]));
    if (NULL == rgKRAIndexes)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptGenRandom(
		g_pCAContextCurrent->hProvCA,
		sizeof(iKRAStart),
		(BYTE *) &iKRAStart))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGenRandom");
    }
    cwc = 0;
    fInvalidated = FALSE;
    for (
	cKRAUsed = 0, i = 0;
	cKRAUsed < g_cKRACertsRoundRobin && i < g_cKRACerts;
	i++)
    {
	iKRACert = (iKRAStart + i) % g_cKRACerts;
	pKRAContext = &g_aKRAContext[iKRACert];

	if (S_OK != pKRAContext->hrVerifyStatus)
	{
	    continue;
	}
	hr = myVerifyKRACertContext(pKRAContext->pccKRA, g_dwVerifyCertFlags);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myVerifyKRACertContext");
	    pKRAContext->hrVerifyStatus = hr;
	    if (CERT_E_EXPIRED == hr)
	    {
		pKRAContext->Flags |= CTXF_EXPIRED;
	    }
	    else
	    // Assume revoked for other errors
	    // if (CRYPT_E_REVOKED == hr || CERT_E_REVOKED == hr)
	    {
		pKRAContext->Flags |= CTXF_REVOKED;
	    }
	    pkcsLogKRACertError(
			MSG_E_INVALID_KRA_CERT,
			iKRACert,
			pKRAContext->pccKRA,
			hr);
	    fInvalidated = TRUE;
	    continue;
	}
	cwc += wcslen(pKRAContext->strKRAHash) + 1;
	rgKRAIndexes[cKRAUsed] = iKRACert;
	cKRAUsed++;
    }

    if (0 == cKRAUsed || g_cKRACertsRoundRobin > cKRAUsed)
    {
	if (fInvalidated)
	{
	    LogEvent(EVENTLOG_ERROR_TYPE, MSG_E_TOO_MANY_KRA_INVALID, 0, NULL);
	}
	hr = CERTSRV_E_NO_VALID_KRA;
	_JumpError(hr, error, "too many invalid KRA certs");
    }

    rgKRACerts = (CERT_CONTEXT const **) LocalAlloc(
				LMEM_FIXED,
				cKRAUsed * sizeof(rgKRACerts[0]));
    if (NULL == rgKRACerts)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszKRAHashes = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszKRAHashes)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszKRAHashes[0] = L'\0';
    for (i = 0; i < cKRAUsed; i++)
    {
	pKRAContext = &g_aKRAContext[rgKRAIndexes[i]];
	rgKRACerts[i] = pKRAContext->pccKRA;
	if (0 != i)
	{
	    wcscat(pwszKRAHashes, L"\n");
	}
	wcscat(pwszKRAHashes, pKRAContext->strKRAHash);
    }
    CSASSERT(wcslen(pwszKRAHashes) + 1 == cwc);

    if (CRLF_REVCHECK_IGNORE_OFFLINE & g_KRAFlags)
    {
        fUseCAProv = false;
    }
    hr = myCryptEncryptMessage(
			g_XchgidAlg,
			cKRAUsed,		// cCertRecipient
			rgKRACerts,		// rgCertRecipient
			pbDecrypted,
			cbDecrypted,
			fUseCAProv? g_pCAContextCurrent->hProvCA : NULL,
			&pResult->pbArchivedKey,
			&pResult->cbArchivedKey);
    if (FAILED(hr) && fUseCAProv)
    {
        // Failed to use the CA HCRYPTPROV, fall back to default

	hr = pkcsCryptGetDefaultProvider(
			    PROV_RSA_FULL,
			    CRYPT_MACHINE_DEFAULT,
			    &pwszProviderName);
	_JumpIfError(hr, error, "pkcsCryptGetDefaultProvider");

	hr = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_E_USE_DEFAULT_CA_XCHG_CSP,
		    1,			// cpwsz
		    &pwszProviderName);	// apwsz
	_PrintIfError(hr, "LogEvent");

        fUseCAProv = false;
        hr = myCryptEncryptMessage(
			    g_XchgidAlg,
			    cKRAUsed,		// cCertRecipient
			    rgKRACerts,		// rgCertRecipient
			    pbDecrypted,
			    cbDecrypted,
			    NULL,
			    &pResult->pbArchivedKey,
			    &pResult->cbArchivedKey);
    }
    _JumpIfError(hr, error, "myCryptEncryptMessage");

    pResult->pwszKRAHashes = pwszKRAHashes;
    pwszKRAHashes = NULL;

error:
    if (NULL != pwszProviderName)
    {
        LocalFree(pwszProviderName);
    }
    if (NULL != rgKRAIndexes)
    {
	LocalFree(rgKRAIndexes);
    }
    if (NULL != pwszKRAHashes)
    {
	LocalFree(pwszKRAHashes);
    }
    if (NULL != rgKRACerts)
    {
	LocalFree(rgKRACerts);
    }
    return(hr);
}



// PKCSArchivePrivateKey -- archive a private key
//
// Description of Algorithm:
// -------------------------
//
// Client constructs request:
//     CryptExportKey(NULL, NULL, PRIVATEKEYBLOB, ...)
//     CryptEncryptMessage(CALG_3DES, &CAExchangeCert, ...)
// 
// Server decrypts and verifies key in request:
//     CryptDecryptMessage(..., &PrivateKeyBlob)
// 
// Server imports decrypted key into temporary key container:
//     CryptAcquireContext(
//                 &hProv,
//                 pwszTempKeyContainerName,
//                 NULL,
//                 PROV_RSA_FULL,
//                 CRYPT_NEWKEYSET)
//     CryptImportKey(PrivateKeyBlob, &PrivateKey)
//     CryptDestroyKey(PrivateKey)
//     CryptReleaseContext()
// 
// Server validates key for encryption:
//     CryptAcquireContext(
//                 &hProv,
//                 pwszTempKeyContainerName,
//                 NULL,
//                 PROV_RSA_FULL,
//                 0)
//     CryptImportPublicKeyInfo(RequestPublicKey, &PublicKey)
//     CryptGenKey(hProv, CALC_RC4, CRYPT_EXPORTABLE, &SymmetricKey)
//     CryptGenRandom(hProv, ...)
//     CryptEncrypt(SymmetricKey, ..)
//     CryptExportKey(SymmetricKey, PublicKey, SIMPLEBLOB, &SymmetricKeyBlob)
//     CryptDestroyKey(SymmetricKey)
// 
//     CryptGetUserKey(hProv, AT_KEYEXCHANGE, &PrivateKey)
//     CryptImportKey(hProv, SymmetricKeyBlob, PrivateKey, ..., &SymmetricKey)
//     CryptDecrypt(SymmetricKey, ...)
// 
//     CryptExportPublicKeyInfo(hProv, AT_KEYEXCHANGE, &ExportedPublicKey)
//     CertComparePublicKeyInfo(ExportedPublicKey, RequestPublicKey)
//     memcmp(RandomCleartext, DecryptedClearText)
//     CryptDestroyKey(all keys)
//     CryptReleaseContext()
// 
// Server verifies request public key matches decrypted public key:
//     CryptExportPublicKeyInfo(
//                         hProv,
//                         AT_KEYEXCHANGE,
//                         &PublicKeyBlobFromDecryptedPrivateKey)
//     CertComparePublicKeyInfo(
//                         PublicKeyBlobFromDecryptedPrivateKe,
//                         PublicKeyBlobFromRequest),
// 
// Server deletes temporary key container:
//     CryptAcquireContext(
//                 &hProv,
//                 pwszTempKeyContainerName,
//                 NULL,
//                 PROV_RSA_FULL,
//                 CRYPT_DELETEKEYSET)
// 
// Server encrypts key to one or more KRA certs:
//     CryptEncryptMessage(CALG_3DES, KRACertCount, &KRACertArray, ...)

HRESULT
PKCSArchivePrivateKey(
    IN ICertDBRow *prow,
    IN BOOL fV1Cert,
    IN BOOL fOverwrite,
    IN CRYPT_ATTR_BLOB const *pBlobEncrypted,
    OPTIONAL IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    BYTE *pbDecrypted = NULL;
    DWORD cbDecrypted;
    DWORD iCertSig;
    BYTE *pbCert;	// do not free!
    DWORD cbCert;
    DWORD cb;
    CERT_PUBLIC_KEY_INFO PublicKeyInfo;
    WCHAR *pwszUserName = NULL;
    BYTE *pbKeyHash = NULL;
    DWORD cbKeyHash;
    CERTSRV_RESULT_CONTEXT tempResultContext;
    BOOL fSigningKey = FALSE;

    ZeroMemory(&tempResultContext, sizeof(tempResultContext));
    ZeroMemory(&PublicKeyInfo, sizeof(PublicKeyInfo));
    cbDecrypted = 0;
    cbKeyHash = 0;

    if (0 == g_cKRACerts || g_cKRACertsRoundRobin > g_cKRACerts)
    {
	hr = CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED;
	_JumpError(hr, error, "not enough KRA certs loaded");
    }

    if (NULL != pResult)
    {
	if (NULL == pResult->pbKeyHashIn)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "missing encrypted key hash");
	}
	hr = myCalculateKeyArchivalHash(
			    pBlobEncrypted->pbData,
			    pBlobEncrypted->cbData,
			    &pbKeyHash,
			    &cbKeyHash);
	_JumpIfError(hr, error, "myCalculateKeyArchivalHash");

	if (pResult->cbKeyHashIn != cbKeyHash ||
	    0 != memcmp(pResult->pbKeyHashIn, pbKeyHash, cbKeyHash))
	{
	    hr = NTE_BAD_KEY;
	    _JumpError(hr, error, "key hash mismatch");
	}
	hr = PKCSSetRequestFlags(prow, TRUE, CR_FLG_VALIDENCRYPTEDKEYHASH);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");
    }
    hr = prow->GetProperty(
		    g_wszPropRequestRawArchivedKey,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cb,
		    NULL);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	if (S_OK == hr && !fOverwrite)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
	}
	_JumpIfError2(
		hr,
		error,
		"GetProperty",
		HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));
    }

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequesterName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		NULL,
		(BYTE **) &pwszUserName);
    _JumpIfError(hr, error, "PKCSGetProperty");

    if (NULL == g_hStoreCAXchg)
    {
	hr = PKCSGetCAXchgCert(0, pwszUserName, &iCertSig, &pbCert, &cbCert);
	_JumpIfError(hr, error, "PKCSGetCAXchgCert");
    }
    CSASSERT(NULL != g_hStoreCAXchg);
    hr = myCryptDecryptMessage(
		    g_hStoreCAXchg,
		    pBlobEncrypted->pbData,
		    pBlobEncrypted->cbData,
		    CERTLIB_USE_LOCALALLOC,
		    &pbDecrypted,
		    &cbDecrypted);
    _JumpIfError(hr, error, "myCryptDecryptMessage");

    DBGDUMPHEX((DBG_SS_CERTSRVI, DH_PRIVATEDATA, pbDecrypted, cbDecrypted));

    hr = pkcsGetPublicKeyInfo(prow, &PublicKeyInfo);
    _JumpIfError(hr, error, "pkcsGetPublicKeyInfo");

    hr = myValidateKeyBlob(
			pbDecrypted,
			cbDecrypted,
			&PublicKeyInfo,
			fV1Cert,
			&fSigningKey,
			NULL);
    _JumpIfError(hr, error, "myValidateKeyBlob");

    if (fSigningKey && 0 == (KRAF_ENABLEARCHIVEALL & g_KRAFlags))
    {
	if (NULL != pResult)
	{
	    pResult->dwResultFlags |= CRCF_ARCHIVESIGNINGKEYERROR;
	}
	hr = NTE_BAD_KEY_STATE;
	_JumpError(hr, error, "fSigningKey");
    }

    hr = pkcsEncryptPrivateKey(
			pbDecrypted,
			cbDecrypted,
			NULL != pResult? pResult : &tempResultContext);
    _JumpIfError(hr, error, "pkcsEncryptPrivateKey");

    // if a key import, save to database

    if (NULL == pResult) 
    {
        hr = prow->SetProperty(
                g_wszPropRequestRawArchivedKey,
                PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
                tempResultContext.cbArchivedKey,
                tempResultContext.pbArchivedKey);
        _JumpIfError(hr, error, "SetProperty(ArchivedKey)");

        hr = prow->SetProperty(
                g_wszPropRequestKeyRecoveryHashes,
                PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
                MAXDWORD,
                (BYTE const *) tempResultContext.pwszKRAHashes);
        _JumpIfError(hr, error, "SetProperty(KRAHashes)");
    }

    if (NULL != pResult && NULL == pResult->pbKeyHashOut)
    {
	pResult->pbKeyHashOut = pbKeyHash;
	pResult->cbKeyHashOut = cbKeyHash;
	pbKeyHash = NULL;
    }

    {
	CertSrv::CAuditEvent audit(SE_AUDITID_CERTSRV_KEYARCHIVED, g_dwAuditFilter);
	DWORD dwRequestID = 0;
	cb = sizeof(DWORD);

	if (audit.IsEventEnabled())
	{
	    hr = prow->GetProperty(
			g_wszPropRequestRequestID,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cb,
			(BYTE *)&dwRequestID);
	    _JumpIfError(hr, error, "Report");

	    hr = audit.AddData(dwRequestID); // %1 request ID
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    hr = audit.AddData(pwszUserName); // %2 requester
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    // %3 KRA hashes
	    hr = audit.AddData(
		(NULL != pResult? pResult : &tempResultContext)->pwszKRAHashes);
	    _JumpIfError(hr, error, "CAuditEvent::AddData");

	    hr = audit.Report();
	    _JumpIfError(hr, error, "Report");
	}
    }

error:
    if (S_OK != hr && NULL != pResult)
    {
	pResult->dwResultFlags |= CRCF_KEYARCHIVALERROR;
    }
    pkcsFreePublicKeyInfo(&PublicKeyInfo);
    if (NULL != pbDecrypted)
    {
	SecureZeroMemory(pbDecrypted, cbDecrypted);	// Private Key Material!
	LocalFree(pbDecrypted);
    }
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != pbKeyHash)
    {
	LocalFree(pbKeyHash);
    }
    ReleaseResult(&tempResultContext);
    return(hr);
}


HRESULT
pkcsSaveRequestWithoutArchivedKey(
    IN ICertDBRow *prow,
    IN DWORD cbIn,
    IN BYTE const *pbIn)
{
    HRESULT hr;
    HCRYPTMSG hMsg = NULL;
    DWORD cSigner;
    DWORD iSigner;
    DWORD i;
    DWORD cb;
    BYTE *pbWithoutKey = NULL;
    DWORD cbWithoutKey;
    CRYPT_ATTRIBUTES *pAttrib = NULL;
    BOOL fKeyDeleted = FALSE;

    hMsg = CryptMsgOpenToDecode(
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    0,			// dwFlags
			    0,			// dwMsgType
			    NULL,		// hCryptProv
			    NULL,		// pRecipientInfo
			    NULL);		// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToDecode");
    }

    if (!CryptMsgUpdate(hMsg, pbIn, cbIn, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    cb = sizeof(cSigner);
    if (!CryptMsgGetParam(
		    hMsg,
		    CMSG_SIGNER_COUNT_PARAM,
		    0,
		    &cSigner,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgGetParam(signer count)");
    }

    DBGPRINT((DBG_SS_CERTSRV, "cSigner=%u\n", cSigner));

    for (iSigner = 0; iSigner < cSigner; iSigner++)
    {
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_SIGNER_UNAUTH_ATTR_PARAM,
			    iSigner,		// dwIndex
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pAttrib,
			    &cb);
	_PrintIfError2(hr, "myCryptMsgGetParam(content)", hr);
	if (S_FALSE == hr)
	{
	    continue;
	}
	_JumpIfError(hr, error, "myCryptMsgGetParam(content)");

	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "iSigner=%u, cAttr=%u\n",
	    iSigner,
	    pAttrib->cAttr));

	// Loop through deleting attributes from the end to avoid invalidated
	// indexes, which may result from deleting earlier attributes.

	for (i = 0; i < pAttrib->cAttr; i++)
	{
	    CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA DelPara;
	    DWORD iAttr = pAttrib->cAttr - i - 1;

	    DBGPRINT((
		DBG_SS_CERTSRV,
		"iSigner=%u, iAttr=%u %hs\n",
		iSigner,
		iAttr,
		pAttrib->rgAttr[iAttr].pszObjId));
	    if (0 == strcmp(
			pAttrib->rgAttr[iAttr].pszObjId,
			szOID_ARCHIVED_KEY_ATTR))
	    {
		ZeroMemory(&DelPara, sizeof(DelPara));
		DelPara.cbSize = sizeof(DelPara);
		DelPara.dwSignerIndex = iSigner;
		DelPara.dwUnauthAttrIndex = iAttr;

		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "Delete Key(signer=%u, attrib=%u)\n",
		    DelPara.dwSignerIndex,
		    DelPara.dwUnauthAttrIndex));

		if (!CryptMsgControl(
				hMsg,
				0,
				CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR,
				&DelPara))
		{
		    hr = myHLastError();
		    _PrintError(hr, "CryptMsgControl");
		}
		fKeyDeleted = TRUE;
	    }
	}
	LocalFree(pAttrib);
	pAttrib = NULL;
    }
    if (!fKeyDeleted)
    {
	hr = S_FALSE;
	_JumpError(hr, error, "no Encrypted Key attribute");
    }

    hr = myCryptMsgGetParam(
			hMsg,
			CMSG_ENCODED_MESSAGE,
			0,		// dwIndex
                        CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbWithoutKey,
			&cbWithoutKey);
    _JumpIfError(hr, error, "myCryptMsgGetParam(content)");

    hr = prow->SetProperty(
		    g_wszPropRequestRawRequest,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    cbWithoutKey,
		    pbWithoutKey);
    _JumpIfError(hr, error, "SetProperty(request)");

error:
    if (NULL != pAttrib)
    {
	LocalFree(pAttrib);
    }
    if (NULL != pbWithoutKey)
    {
	LocalFree(pbWithoutKey);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    return(hr);
}


#define PSA_DISALLOW_EXTENSIONS		0x00000001
#define PSA_DISALLOW_NAMEVALUEPAIRS	0x00000002
#define PSA_DISALLOW_ARCHIVEDKEY	0x00000004

HRESULT
pkcsSetAttributes(
    IN ICertDBRow *prow,
    IN DWORD ExtFlags,
    IN DWORD dwDisallowFlags,
    IN CRYPT_ATTRIBUTE const *rgAttrib,
    IN DWORD cAttrib,
    IN DWORD cbRequest,
    OPTIONAL IN BYTE const *pbRequest,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    CRYPT_ATTRIBUTE const *pAttrib;
    CRYPT_ATTRIBUTE const *pAttribEnd;
    DWORD i;
    BYTE afSubjectTable[CSUBJECTTABLE];	// see PKCSParseAttributes note
    CRYPT_DATA_BLOB *pBlob = NULL;
    BOOL fSubjectModified = FALSE;

    ZeroMemory(afSubjectTable, sizeof(afSubjectTable));
    CSASSERT(CSExpr(0 == FALSE));

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }

    pAttribEnd = &rgAttrib[cAttrib];
    for (pAttrib = rgAttrib; pAttrib < pAttribEnd; pAttrib++)
    {
        if (0 == strcmp(pAttrib->pszObjId, szOID_OS_VERSION))
        {
            if (1 != pAttrib->cValue)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    hr = pkcsSetOSVersion(prow, pAttrib->rgValue);
	    _JumpIfError(hr, error, "pkcsSetOSVersion");
        }
        else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ENROLLMENT_CSP_PROVIDER))
        {
            // Check to see if we have a CSPPROVIDER attribute.  We use this in
            // the policy module to determine if xenroll generated the request,
	    // so we can behave differently for old xenroll requests (put the
	    // UPN in the subject to avoid enrollment loops)

            if (1 != pAttrib->cValue)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    hr = pkcsSetCSPProvider(prow, pAttrib->rgValue);
	    _JumpIfError(hr, error, "pkcsSetCSPProvider");
        }
        else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ENCRYPTED_KEY_HASH))
        {
	    DWORD cb;
	    
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    if (NULL != pResult->pbKeyHashIn || NULL != pBlob)
	    {
                _JumpError(hr, error, "Multiple key hashes");
	    }
            if (1 != pAttrib->cValue)
            {
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pAttrib->rgValue[0].pbData,
			    pAttrib->rgValue[0].cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pBlob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    pResult->pbKeyHashIn = (BYTE *) LocalAlloc(
						LMEM_FIXED,
						pBlob->cbData);
	    if (NULL == pResult->pbKeyHashIn)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(pResult->pbKeyHashIn, pBlob->pbData, pBlob->cbData);
	    pResult->cbKeyHashIn = pBlob->cbData;
	}
        else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ARCHIVED_KEY_ATTR))
        {
	    // Pull encrypted private key out of the attribute for archival.
	    //
	    // Save request in database without private key now, to keep the
	    // error path from saving the request later *with* the key.

	    if (NULL != pbRequest)
	    {
		hr = pkcsSaveRequestWithoutArchivedKey(
						prow,
						cbRequest,
						pbRequest);
		_PrintIfError(hr, "pkcsSaveRequestWithoutArchivedKey");
		if (S_OK == hr)
		{
		    pResult->fRequestSavedWithoutKey = TRUE;
		}
	    }

	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    if (PSA_DISALLOW_ARCHIVEDKEY & dwDisallowFlags)
	    {
		hr = CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL;
		_JumpError(hr, error, "archived key disallowed");
	    }
            if (1 != pAttrib->cValue)
            {
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    hr = PKCSArchivePrivateKey(
				prow,
				FALSE,
				FALSE,
				&pAttrib->rgValue[0],
				pResult);
	    _JumpIfError(hr, error, "PKCSArchivePrivateKey");
        }
	else
	if (0 == strcmp(pAttrib->pszObjId, szOID_CERT_EXTENSIONS) ||
	    0 == strcmp(pAttrib->pszObjId, szOID_RSA_certExtensions))
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    if (PSA_DISALLOW_EXTENSIONS & dwDisallowFlags)
            {
                _JumpError(hr, error, "extensions disallowed");
            }
            if (1 != pAttrib->cValue)
            {
                _JumpError(hr, error, "Attribute Value count != 1");
            }
	    hr = pkcsSetExtensionsFromAttributeBlob(
						prow,
						ExtFlags,
						pAttrib);
	    _JumpIfError(hr, error, "pkcsSetExtensionsFromAttributeBlob");
	}
	else
	if (0 == strcmp(pAttrib->pszObjId, szOID_ENROLLMENT_NAME_VALUE_PAIR))
	{
	    // Can't apply name value pair attributes to a renewal or CMC

	    if (PSA_DISALLOW_NAMEVALUEPAIRS & dwDisallowFlags)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "name/value pairs disallowed");
	    }

	    for (i = 0; i < pAttrib->cValue; i++)
	    {
		CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pInfo = NULL;
		DWORD cbInfo = 0;
		CRYPT_ATTR_BLOB const *pvalue = &pAttrib->rgValue[i];

		if (!myDecodeNameValuePair(
					X509_ASN_ENCODING,
					pvalue->pbData,
					pvalue->cbData,
					CERTLIB_USE_LOCALALLOC,
					&pInfo,
					&cbInfo))
		{
		    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    _JumpError(hr, error, "myDecodeNameValuePair");

		    // if the attribute name & value are both non-empty ...
		}

		BOOL fEnrollOnBehalfOf = FALSE;
		BOOL fSubjectModifiedT = FALSE;

		hr = pkcsSetAttributeProperty(
			prow,
			pInfo->pwszName,
			pInfo->pwszValue,
			PROPTABLE_REQUEST,
			afSubjectTable,
			&fSubjectModified,
			NULL != pfEnrollOnBehalfOf? &fEnrollOnBehalfOf : NULL);
		if (fSubjectModifiedT)
		{
		    fSubjectModified = TRUE;
		}
		if (fEnrollOnBehalfOf)
		{
		    *pfEnrollOnBehalfOf = TRUE;
		}
		if (NULL != pInfo)
		{
		    LocalFree(pInfo);
		}
		_JumpIfError(hr, error, "pkcsSetAttributeProperty");
	    }
	}
	else
	{
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"Skipping authenticated attribute %hs\n",
		pAttrib->pszObjId));
	}
    }
    if (fSubjectModified)
    {
	hr = PKCSSetRequestFlags(prow, FALSE, CR_FLG_SUBJECTUNMODIFIED);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");
    }
    hr = S_OK;

error:
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    return(hr);
}


HRESULT
pkcsVerifyCertContext(
    OPTIONAL IN FILETIME const *pft,
    IN BOOL fTimeOnly,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    FILETIME ft;

    if (NULL == pft)
    {
	GetSystemTimeAsFileTime(&ft);
	pft = &ft;
    }
    if (0 > CompareFileTime(pft, &pcc->pCertInfo->NotBefore))
    {
	hr = CERT_E_EXPIRED;
	_JumpError(hr, error, "cert not yet valid");
    }
    if (0 < CompareFileTime(pft, &pcc->pCertInfo->NotAfter))
    {
	hr = CERT_E_EXPIRED;
	_JumpError(hr, error, "cert is expired");
    }
    if (!fTimeOnly)
    {
	hr = myVerifyCertContext(
			pcc,			// pCert
			g_dwVerifyCertFlags,	// dwFlags
			0,			// cUsageOids
			NULL,			// apszUsageOids
			HCCE_LOCAL_MACHINE,	// hChainEngine
			NULL,			// hAdditionalStore
			NULL);			// ppwszMissingIssuer
	_JumpIfError(hr, error, "myVerifyCertContext");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsSetValidityPeriod(
    IN ICertDBRow *prow,
    IN CACTX *pCAContext,
    OPTIONAL IN FILETIME const *pftNotBefore,
    OPTIONAL IN FILETIME const *pftNotAfter,
    IN LONG lValidityPeriodCount,
    IN enum ENUM_PERIOD enumValidityPeriod)
{
    HRESULT hr;
    FILETIME ftNotBefore;
    FILETIME ftNotAfter;
    LONGLONG delta;

    GetSystemTimeAsFileTime(&ftNotBefore);

    hr = pkcsVerifyCertContext(&ftNotBefore, TRUE, pCAContext->pccCA);
    _JumpIfErrorStr(hr, error, "pkcsVerifyCertContext", L"CA cert invalid");

    if (NULL != pftNotBefore && NULL != pftNotAfter)
    {
	ftNotBefore = *pftNotBefore;	// Caller already computed tome stamps
	ftNotAfter = *pftNotAfter;
    }
    else
    {
	ftNotAfter = ftNotBefore;

	// Set start date to the current time minus clock skew.  But ensure the
	// new cert's start date is not before the CA certificate's start date.

	delta = g_dwClockSkewMinutes * CVT_MINUTES;
	myAddToFileTime(&ftNotBefore, -delta * CVT_BASE);

	if (0 > CompareFileTime(
			    &ftNotBefore,
			    &pCAContext->pccCA->pCertInfo->NotBefore))
	{
	    ftNotBefore = pCAContext->pccCA->pCertInfo->NotBefore;
	}

	// Set the end date to the start date plus the registry-configured
	// validity period.  Then clamp the new cert's end date to the CA
	// certificate's end date.

	myMakeExprDateTime(
		    &ftNotAfter,
		    lValidityPeriodCount,
		    enumValidityPeriod);

	if (0 < CompareFileTime(
			    &ftNotAfter,
			    &pCAContext->pccCA->pCertInfo->NotAfter))
	{
	    ftNotAfter = pCAContext->pccCA->pCertInfo->NotAfter;
	    if (CERTLOG_VERBOSE <= g_dwLogLevel)
	    {
		DWORD dwRequestId;
		WCHAR const *apwsz[2];
		WCHAR awc[cwcDWORDSPRINTF];

		prow->GetRowId(&dwRequestId);
		wsprintf(awc, L"%u", dwRequestId);
		apwsz[0] = g_wszCommonName;
		apwsz[1] = awc;

		LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_CLAMPED_BY_CA_CERT,
		    ARRAYSIZE(apwsz),
		    apwsz);
	    }
	}
    }

    hr = prow->SetProperty(
		    g_wszPropCertificateNotBeforeDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
                    sizeof(ftNotBefore),
                    (BYTE *) &ftNotBefore);
    _JumpIfError(hr, error, "pkcsSetValidityPeriod:SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCertificateNotAfterDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
                    sizeof(ftNotAfter),
                    (BYTE *) &ftNotAfter);
    _JumpIfError(hr, error, "pkcsSetValidityPeriod:SetProperty");

error:
    return(hr);
}


HRESULT
pkcsSetServerExtension(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszObjId,
    IN DWORD cbExt,
    OPTIONAL IN BYTE const *pbExt)
{
    HRESULT hr;
    BYTE *pbOld = NULL;
    DWORD cbOld;
    DWORD ExtFlags;

    ExtFlags = 0;
    if (NULL == pbExt)
    {
	CSASSERT(0 == cbExt);

	hr = PropGetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    pwszObjId,
		    &ExtFlags,
		    &cbOld,
		    &pbOld);
	if (S_OK != hr)
	{
	    ExtFlags = 0;
	}
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    ExtFlags |= EXTENSION_DISABLE_FLAG;
	}
    }
    if (NULL != pbExt || (EXTENSION_DISABLE_FLAG & ExtFlags))
    {
	ExtFlags &= ~EXTENSION_ORIGIN_MASK;
	ExtFlags |= EXTENSION_ORIGIN_SERVER;
	hr = PropSetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_SERVER,
			pwszObjId,
			ExtFlags,
			cbExt,
			pbExt);
	_JumpIfError(hr, error, "PropSetExtension");
    }
    hr = S_OK;

error:
    if (NULL != pbOld)
    {
	LocalFree(pbOld);
    }
    return(hr);
}


HRESULT
pkcsSetPublicKeyProperties(
    IN ICertDBRow *prow,
    IN CERT_PUBLIC_KEY_INFO const *pSubjectPublicKeyInfo)
{
    HRESULT hr;
    WCHAR *pwszObjId = NULL;
    CERT_EXTENSION ext;
    DWORD ExtFlags;
    DWORD dwCaller;
    DWORD cbitKey;

    ext.Value.pbData = NULL;

    // Public Key size must be a multiple of 8 bits.
    if (0 != pSubjectPublicKeyInfo->PublicKey.cUnusedBits)
    {
	hr = NTE_BAD_KEY;
	_JumpError(hr, error, "PublicKey.cUnusedBits");
    }
    hr = prow->SetProperty(
		    g_wszPropCertificateRawPublicKey,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    pSubjectPublicKeyInfo->PublicKey.cbData,
		    pSubjectPublicKeyInfo->PublicKey.pbData);
    _JumpIfError(hr, error, "SetProperty");

    cbitKey = CertGetPublicKeyLength(
		    X509_ASN_ENCODING,
		    const_cast<CERT_PUBLIC_KEY_INFO *>(pSubjectPublicKeyInfo));
    hr = prow->SetProperty(
		    g_wszPropCertificatePublicKeyLength,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    sizeof(cbitKey),
		    (BYTE const *) &cbitKey);
    _JumpIfError(hr, error, "SetProperty(KeyLength)");

    if (!myConvertSzToWsz(
		    &pwszObjId,
		    pSubjectPublicKeyInfo->Algorithm.pszObjId,
		    -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertSzToWsz(AlgObjId)");
    }
    hr = prow->SetProperty(
		    g_wszPropCertificatePublicKeyAlgorithm,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    MAXDWORD,
		    (BYTE const *) pwszObjId);
    _JumpIfError(hr, error, "SetProperty");

    if (NULL != pSubjectPublicKeyInfo->Algorithm.Parameters.pbData)
    {
	hr = prow->SetProperty(
		    g_wszPropCertificateRawPublicKeyAlgorithmParameters,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    pSubjectPublicKeyInfo->Algorithm.Parameters.cbData,
		    pSubjectPublicKeyInfo->Algorithm.Parameters.pbData);
	_JumpIfError(hr, error, "SetProperty");
    }

    // Subject Key Identifier extension:

    hr = PropGetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    TEXT(szOID_SUBJECT_KEY_IDENTIFIER),
		    &ExtFlags,
		    &ext.Value.cbData,
		    &ext.Value.pbData);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfError(hr, error, "PropGetExtension");

	dwCaller = PROPCALLER_REQUEST;
	ExtFlags &= ~EXTENSION_DISABLE_FLAG;
    }
    else
    {
	dwCaller = PROPCALLER_SERVER;
	ExtFlags = EXTENSION_ORIGIN_SERVER;

	hr = myCreateSubjectKeyIdentifierExtension(
					pSubjectPublicKeyInfo,
					&ext.Value.pbData,
					&ext.Value.cbData);
	_JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");
    }

    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | dwCaller,
		    TEXT(szOID_SUBJECT_KEY_IDENTIFIER),
		    ExtFlags,
		    ext.Value.cbData,
		    ext.Value.pbData);
    _JumpIfError(hr, error, "PropSetExtension");

error:
    if (NULL != ext.Value.pbData)
    {
	LocalFree(ext.Value.pbData);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsParsePKCS10Request(
    IN DWORD DBGCODE(dwFlags),
    IN ICertDBRow *prow,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN CERT_CONTEXT const *pSigningAuthority,
    OUT BOOL *pfRenewal,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD cbCertInfo;
    CERT_REQUEST_INFO *pRequestInfo = NULL;
    CRYPT_ATTRIBUTE const *pAttrib;
    CRYPT_ATTRIBUTE const *pAttribEnd;
    CRYPT_ATTR_BLOB *pAttrBlob;
    CERT_CONTEXT const *pOldCert = NULL;
    DWORD dwRequestFlags = 0;
    BOOL fRenewal = FALSE;
    BOOL fSubjectNameSet;
    BOOL fReorderLikeRDNs;

    CSASSERT(CR_IN_PKCS10 == (CR_IN_FORMATMASK & dwFlags));
    CSASSERT(
	CR_IN_PKCS10 == (CR_IN_FORMATMASK & pResult->dwFlagsTop) ||
	CR_IN_PKCS7 == (CR_IN_FORMATMASK & pResult->dwFlagsTop) ||
	CR_IN_CMC == (CR_IN_FORMATMASK & pResult->dwFlagsTop));

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pbRequest,
		    cbRequest,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pRequestInfo,
		    &cbCertInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    // verify with the public key passed in the PKCS10

    if (!CryptVerifyCertificateSignature(
			    NULL,
			    X509_ASN_ENCODING,
			    const_cast<BYTE *>(pbRequest),
			    cbRequest,
			    &pRequestInfo->SubjectPublicKeyInfo))
    {
	hr = myHLastError();
	_PrintError3(
		hr,
		"CryptVerifyCertificateSignature",
		E_INVALIDARG,
		CRYPT_E_ASN1_BADTAG);
	if (CR_IN_CMC == (CR_IN_FORMATMASK & pResult->dwFlagsTop))
	{
	    if (E_INVALIDARG == hr)			// NULL signature?
	    {
		CRYPT_DATA_BLOB Blob;
		
		Blob.cbData = cbRequest;
		Blob.pbData = const_cast<BYTE *>(pbRequest);
		if (!CryptVerifyCertificateSignatureEx(
					NULL,		// hCryptProv
					X509_ASN_ENCODING,
					CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB,
					&Blob,
					CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL,
					NULL,		// pvIssuer
					0,		// dwFlags
					NULL))		// pvReserved
		{
		    HRESULT hr2 = myHLastError();

		    _PrintError(hr2, "CryptVerifyCertificateSignatureEx");
		    pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
		}
		else
		{
		    hr = S_OK;
		}
	    }
	}
	if (E_INVALIDARG == hr || CRYPT_E_ASN1_BADTAG == hr)
	{
	    hr = NTE_BAD_SIGNATURE;
	}
	_JumpIfError(hr, error, "CryptVerifyCertificateSignature");
    }

    // handle renewal certificate extensions BEFORE processing the rest of
    // the request attributes (which may also contain extensions)

    pAttribEnd = &pRequestInfo->rgAttribute[pRequestInfo->cAttribute];
    for (pAttrib = pRequestInfo->rgAttribute; pAttrib < pAttribEnd; pAttrib++)
    {
        if (0 == strcmp(pAttrib->pszObjId, szOID_RENEWAL_CERTIFICATE))
        {
	    hr = CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE;
            if (fRenewal)
	    {
                _JumpError(hr, error, "Multiple renewal certs!");
	    }
	    if (CR_IN_PKCS7 != (CR_IN_FORMATMASK & pResult->dwFlagsTop) &&
		CR_IN_CMC != (CR_IN_FORMATMASK & pResult->dwFlagsTop))
	    {
                _JumpError(hr, error, "renewal cert must be in PKCS7 or CMC");
	    }
            if (1 != pAttrib->cValue)
            {
                _JumpError(hr, error, "Attribute Value count != 1");
            }
            pAttrBlob = pAttrib->rgValue;

            pOldCert = CertCreateCertificateContext(
						X509_ASN_ENCODING,
						pAttrBlob->pbData,
						pAttrBlob->cbData);
            if (NULL == pOldCert)
            {
                _JumpError(hr, error, "CertCreateCertificateContext");
            }

            // The old raw certificate, and the signer of the PKCS7 must match!

            if (NULL == pSigningAuthority ||
		!myAreCertContextBlobsSame(pSigningAuthority, pOldCert))
            {
		_JumpError(hr, error, "myAreCertContextBlobsSame");
            }

            // This is a renewal, mark it as such.

            hr = prow->SetProperty(
		            g_wszPropRequestRawOldCertificate,
		            PROPTYPE_BINARY |
				PROPCALLER_SERVER |
				PROPTABLE_REQUEST,
		            pAttrBlob->cbData,
		            pAttrBlob->pbData);
            _JumpIfError(hr, error, "SetProperty(old cert)");

	    hr = pkcsSetExtensions(
			prow,
			EXTENSION_ORIGIN_RENEWALCERT | EXTENSION_DISABLE_FLAG,
			pOldCert->pCertInfo->rgExtension,
			pOldCert->pCertInfo->cExtension);
            _JumpIfError(hr, error, "pkcsSetExtensions(old cert)");

            fRenewal = TRUE;

	    if (CertComparePublicKeyInfo(
			X509_ASN_ENCODING,
			&pRequestInfo->SubjectPublicKeyInfo,
			&pOldCert->pCertInfo->SubjectPublicKeyInfo))
	    {
		BYTE abHash[CBMAX_CRYPT_HASH_LEN];
		DWORD cbHash;

		cbHash = sizeof(abHash);
		if (!CertGetCertificateContextProperty(
					    pOldCert,
					    CERT_SHA1_HASH_PROP_ID,
					    abHash,
					    &cbHash))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CertGetCertificateContextProperty");
		}
		hr = MultiByteIntegerToBstr(
					TRUE,
					cbHash,
					abHash,
					&pResult->strRenewalCertHash);
		_JumpIfError(hr, error, "MultiByteIntegerToBstr");
	    }
        }
    }

    // handle certificate extensions/known atributes

    hr = pkcsSetAttributes(
		    prow,
		    EXTENSION_ORIGIN_REQUEST,
		    PSA_DISALLOW_ARCHIVEDKEY,
		    pRequestInfo->rgAttribute,
		    pRequestInfo->cAttribute,
		    0,
		    NULL,
		    NULL,
		    pResult);
    _JumpIfError(hr, error, "pkcsSetAttributes(PKCS10)");

    // If an XEnroll request, reverse the order of similar adjacent RDNs

    fReorderLikeRDNs = FALSE;
    if (0 == (CRLF_DISABLE_RDN_REORDER & g_dwCRLFlags))
    {
	DWORD cb;
	
	hr = prow->GetProperty(
			g_wszPropRequestOSVersion,
			PROPTYPE_STRING |
			    PROPCALLER_SERVER |
			    PROPTABLE_ATTRIBUTE,
			NULL,
			&cb,
			NULL);
	_PrintIfError(hr, "GetProperty");
	if (S_OK == hr && 0 != cb)
	{
	    fReorderLikeRDNs = TRUE;
	}
    }
    hr = pkcsSetRequestNameInfo(
			prow,
			&pRequestInfo->Subject,
			NULL,		// pwszCNSuffix
			fReorderLikeRDNs,
			&dwRequestFlags,
			&fSubjectNameSet);
    _JumpIfError(hr, error, "pkcsSetRequestNameInfo");

    if (fSubjectNameSet)
    {
	dwRequestFlags |= CR_FLG_SUBJECTUNMODIFIED;
    }

    if (fRenewal)
    {
	if (!fSubjectNameSet)
	{
	    CSASSERT(NULL != pOldCert);
	    CSASSERT(NULL != pOldCert->pCertInfo);
	    hr = pkcsSetRequestNameInfo(
			    prow,
			    &pOldCert->pCertInfo->Subject,
			    NULL,		// pwszCNSuffix
			    FALSE,		// fReorderLikeRDNs
			    &dwRequestFlags,
			    &fSubjectNameSet);
	    _JumpIfError(hr, error, "pkcsSetRequestNameInfo");
	}
        dwRequestFlags |= CR_FLG_RENEWAL;
    }

    hr = prow->SetProperty(
            g_wszPropRequestFlags,
            PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            sizeof(dwRequestFlags),
            (BYTE const *) &dwRequestFlags);
    _JumpIfError(hr, error, "SetProperty(RequestFlags)");

    hr = pkcsSetPublicKeyProperties(prow, &pRequestInfo->SubjectPublicKeyInfo);
    _JumpIfError(hr, error, "pkcsSetPublicKeyProperties");

    hr = PKCSSetServerProperties(
			prow,
			NULL,		// use default signing context
			NULL,		// pftNotBefore
			NULL,		// pftNotAfter
			g_lValidityPeriodCount,
			g_enumValidityPeriod);
    _JumpIfError(hr, error, "PKCSSetServerProperties");

    if (NULL != pfRenewal)
    {
        *pfRenewal = fRenewal;
    }

error:
    if (NULL != pOldCert)
    {
	CertFreeCertificateContext(pOldCert);
    }
    if (NULL != pRequestInfo)
    {
	LocalFree(pRequestInfo);
    }
    return(hr);
}


HRESULT
PKCSVerifyChallengeString(
    IN ICertDBRow *prow)
{
    HRESULT hr;
    DWORD cb;
    WCHAR wszPassed[MAX_PATH];
    WCHAR wszExpected[MAX_PATH];

    cb = sizeof(wszExpected);
    hr = prow->GetProperty(
		    g_wszPropExpectedChallenge,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_ATTRIBUTE,
		    NULL,
		    &cb,
		    (BYTE *) wszExpected);
    if (S_OK != hr || L'\0' == wszExpected[0])
    {
	hr = S_OK;	// no challenge expected
	goto error;
    }

    cb = sizeof(wszPassed);
    hr = prow->GetProperty(
		    g_wszPropChallenge,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_ATTRIBUTE,
		    NULL,
		    &cb,
		    (BYTE *) wszPassed);
    if (S_OK != hr)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
	_JumpError(hr, error, "Missing Challenge String");
    }
    if (0 != wcscmp(wszExpected, wszPassed))
    {
	CONSOLEPRINT2((
		    DBG_SS_CERTSRV,
		    "Challenge: passed(%ws) expected(%ws)\n",
		    wszPassed,
		    wszExpected));

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
	_JumpError(hr, error, "Invalid Challenge String");
    }
    hr = prow->SetProperty(
		    g_wszPropExpectedChallenge,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_ATTRIBUTE,
		    0,
		    NULL);
    _PrintIfError(hr, "SetProperty");

    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsParseKeyGenRequest(
    IN DWORD DBGCODE(dwFlags),
    IN ICertDBRow *prow,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN OUT CERTSRV_RESULT_CONTEXT * /* pResult */ )
{
    HRESULT hr;
    DWORD cbKeyGenRequest;
    CERT_KEYGEN_REQUEST_INFO *pKeyGenRequest = NULL;
    DWORD dwRequestFlags;

    CSASSERT(CR_IN_KEYGEN == (CR_IN_FORMATMASK & dwFlags));

    // Decode KeyGenRequest structure
    if (!myDecodeKeyGenRequest(
		    pbRequest,
		    cbRequest,
		    CERTLIB_USE_LOCALALLOC,
		    &pKeyGenRequest,
		    &cbKeyGenRequest))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeKeyGen");
    }

    // verify with the public key passed in the PKCS10
    if (!CryptVerifyCertificateSignature(
			    NULL,
			    X509_ASN_ENCODING,
			    (BYTE *) pbRequest,
			    cbRequest,
			    &pKeyGenRequest->SubjectPublicKeyInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptVerifyCertificateSignature");
    }

    hr = pkcsSetPublicKeyProperties(
				prow,
				&pKeyGenRequest->SubjectPublicKeyInfo);
    _JumpIfError(hr, error, "pkcsSetPublicKeyProperties");

    hr = PKCSSetServerProperties(
			prow,
			NULL,		// use default signing context
			NULL,		// pftNotBefore
			NULL,		// pftNotAfter
			g_lValidityPeriodCount,
			g_enumValidityPeriod);
    _JumpIfError(hr, error, "PKCSSetServerProperties");

    hr = prow->SetProperty(
		    g_wszPropExpectedChallenge,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_ATTRIBUTE,
		    MAXDWORD,
		    (BYTE *) pKeyGenRequest->pwszChallengeString);
    _JumpIfError(hr, error, "SetProperty");

    dwRequestFlags = 0;
    switch (ENUM_TELETEX_MASK & g_fForceTeletex)
    {
	case ENUM_TELETEX_ON:
	case ENUM_TELETEX_AUTO:
	    dwRequestFlags |= CR_FLG_FORCETELETEX;
	    break;
    }
    if (ENUM_TELETEX_UTF8 & g_fForceTeletex)
    {
        dwRequestFlags |= CR_FLG_FORCEUTF8;
    }

    hr = prow->SetProperty(
            g_wszPropRequestFlags,
            PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
            sizeof(dwRequestFlags),
            (BYTE const *) &dwRequestFlags);
    _JumpIfError(hr, error, "SetProperty(RequestFlags)");

error:
    if (NULL != pKeyGenRequest)
    {
	LocalFree(pKeyGenRequest);
    }
    return(hr);
}


// Validate the certificate:
//    Signed by CA Certificate
//    issuer name == CA Certificate subject
//    NotBefore >= CA Certificate NotBefore
//    NotAfter <= CA Certificate NotAfter
//    if KEYID2 issuer KeyId set: == CA Certificate KeyId
//    if KEYID2 issuer Name set: == CA Certificate Issuer
//    if KEYID2 issuer Serial Number set: == CA Certificate serial number

HRESULT
pkcsVerifyCertIssuer(
    IN CERT_CONTEXT const *pCert,
    IN CACTX const *pCAContext)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    CERT_INFO const *pCertInfo = pCert->pCertInfo;
    CERT_INFO const *pCACertInfo;
    CERT_EXTENSION const *pExt;
    CERT_EXTENSION const *pExtEnd;
    CERT_AUTHORITY_KEY_ID2_INFO *pkeyAuth = NULL;
    DWORD cbkeyAuth;
    CERT_NAME_BLOB const *pName;

    CSASSERT(NULL != pCAContext);
    if (NULL == pCAContext->pccCA)
    {
	hr = NTE_BAD_SIGNATURE;
	_JumpError2(hr, error, "pCAContext->pccCA", hr);
    }
    pCACertInfo = pCAContext->pccCA->pCertInfo;

    // verify with the CA cert's public key

    if (!CryptVerifyCertificateSignature(
				NULL,
				X509_ASN_ENCODING,
				pCert->pbCertEncoded,
				pCert->cbCertEncoded,
				const_cast<CERT_PUBLIC_KEY_INFO *>(
				    &pCACertInfo->SubjectPublicKeyInfo)))
    {
	hr = myHLastError();
	_JumpError2(hr, error, "CryptVerifyCertificateSignature", hr);
    }

    // Check Issuer name:

    if (!myAreBlobsSame(
		pCACertInfo->Subject.pbData,
		pCACertInfo->Subject.cbData,
		pCertInfo->Issuer.pbData,
		pCertInfo->Issuer.cbData))
    {
	_JumpError(hr, error, "Bad Issuer Name");
    }

    // Check that NotBefore >= CA Certificate NotBefore

    if (0 > CompareFileTime(&pCertInfo->NotBefore, &pCACertInfo->NotBefore))
    {
	_JumpError(hr, error, "NotBefore too early");
    }

    // Check that NotAfter <= CA Certificate NotAfter

    if (0 < CompareFileTime(&pCertInfo->NotAfter, &pCACertInfo->NotAfter))
    {
	_JumpError(hr, error, "NotAfter too late");
    }

    pExtEnd = &pCert->pCertInfo->rgExtension[pCert->pCertInfo->cExtension];
    for (pExt = pCert->pCertInfo->rgExtension; pExt < pExtEnd; pExt++)
    {
        if (0 == strcmp(pExt->pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER2))
        {
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_AUTHORITY_KEY_ID2,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pkeyAuth,
			    &cbkeyAuth))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }

	    // Check Issuer KeyId:

	    if (NULL != pCAContext->IssuerKeyId.pbData &&
		NULL != pkeyAuth->KeyId.pbData &&
		!myAreBlobsSame(
			pCAContext->IssuerKeyId.pbData,
			pCAContext->IssuerKeyId.cbData,
			pkeyAuth->KeyId.pbData,
			pkeyAuth->KeyId.cbData))
	    {
		_JumpError(hr, error, "Bad AuthorityKeyId KeyId");
	    }

	    // Check Issuer name:

	    if (1 == pkeyAuth->AuthorityCertIssuer.cAltEntry &&
		CERT_ALT_NAME_DIRECTORY_NAME ==
		pkeyAuth->AuthorityCertIssuer.rgAltEntry[0].dwAltNameChoice)
	    {
		pName = &pkeyAuth->AuthorityCertIssuer.rgAltEntry[0].DirectoryName;

		if (NULL != pName->pbData &&
		    !myAreBlobsSame(
			pCACertInfo->Issuer.pbData,
			pCACertInfo->Issuer.cbData,
			pName->pbData,
			pName->cbData))
		{
		    _JumpError(hr, error, "Bad AuthorityKeyId Issuer Name");
		}
	    }

	    // Check Issuer SerialNumber:

	    if (NULL != pkeyAuth->AuthorityCertSerialNumber.pbData &&
		!myAreSerialNumberBlobsSame(
			    &pCACertInfo->SerialNumber,
			    &pkeyAuth->AuthorityCertSerialNumber))
	    {
		_JumpError(hr, error, "Bad AuthorityKeyId Issuer Serial Number");
	    }
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != pkeyAuth)
    {
	LocalFree(pkeyAuth);
    }
    return(hr);
}


HRESULT
PKCSVerifyIssuedCertificate(
    IN CERT_CONTEXT const *pCert,
    OUT CACTX **ppCAContext)
{
    HRESULT hr;
    DWORD i;
    CACTX *pCAContext;

    *ppCAContext = NULL;

    CSASSERT(0 != g_cCACerts);
    hr = S_OK;
    for (i = g_cCACerts; i > 0; i--)
    {
	pCAContext = &g_aCAContext[i - 1];

	hr = pkcsVerifyCertIssuer(pCert, pCAContext);
	if (S_OK == hr)
	{
	    *ppCAContext = pCAContext;
	    break;
	}
	if (HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY) != hr)
	{
	    _PrintError2(hr, "pkcsVerifyCertIssuer", NTE_BAD_SIGNATURE);
	}
    }

//error:
    return(hr);
}


HRESULT
pkcsSetCertHash(
    IN ICertDBRow *prow,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    BSTR strHash = NULL;

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pcc,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = prow->SetProperty(
		g_wszPropCertificateHash,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE const *) strHash);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
pkcsSetCertAndKeyHashes(
    IN ICertDBRow *prow,
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BSTR strHash = NULL;

    hr = pkcsSetCertHash(prow, pcc);
    _JumpIfError(hr, error, "pkcsSetCertHash");

    hr = myGetPublicKeyHash(
		    pcc->pCertInfo,
		    &pcc->pCertInfo->SubjectPublicKeyInfo,
		    &pbHash,
		    &cbHash);
    _JumpIfError(hr, error, "myGetPublicKeyHash");

    hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = prow->SetProperty(
		g_wszPropCertificateSubjectKeyIdentifier,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE const *) strHash);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    return(hr);
}


HRESULT
pkcsSetTemplateProperty(
    IN ICertDBRow *prow,
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    CERT_EXTENSION const *pExt;
    CERT_NAME_VALUE *pName = NULL;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    DWORD cb;
    WCHAR const *pwszTemplate = NULL;
    WCHAR *pwszObjId = NULL;

    // look for v2 template extension

    pExt = CertFindExtension(
		    szOID_CERTIFICATE_TEMPLATE,
		    pCert->pCertInfo->cExtension,
		    pCert->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERTIFICATE_TEMPLATE,
		    pExt->Value.pbData,
		    pExt->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pTemplate,
		    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:myDecodeObject");
	}
	if (!myConvertSzToWsz(&pwszObjId, pTemplate->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertSzToBstr");
	}
	pwszTemplate = pwszObjId;
    }
    else
    {
	// look for v1 template extension

	pExt = CertFindExtension(
			szOID_ENROLL_CERTTYPE_EXTENSION,
			pCert->pCertInfo->cExtension,
			pCert->pCertInfo->rgExtension);
	if (NULL != pExt)
	{
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pName,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Policy:myDecodeObject");
	    }
	    pwszTemplate = (WCHAR const *) pName->Value.pbData;
	}
    }
    if (NULL != pwszTemplate)
    {
	hr = prow->SetProperty(
		wszPROPCERTIFICATETEMPLATE,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE const *) pwszTemplate);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = S_OK;

error:
    if (NULL != pName)
    {
        LocalFree(pName);
    }
    if (NULL != pTemplate)
    {
        LocalFree(pTemplate);
    }
    if (NULL != pwszObjId)
    {
        LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsSetRevocationFields(
    IN ICertDBRow *prow)
{
    HRESULT hr;
    DWORD DBDisposition;
    DWORD Reason;
    WCHAR *pwszMachineRequesterName = NULL;
    WCHAR const *pwszDisposition = NULL;
    
    DBDisposition = DB_DISP_REVOKED;
    hr = prow->SetProperty(
		g_wszPropRequestDisposition,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		sizeof(DBDisposition),
		(BYTE *) &DBDisposition);
    _JumpIfError(hr, error, "SetProperty");

    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestRevokedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");

    hr = PropSetRequestTimeProperty(
			    prow,
			    g_wszPropRequestRevokedEffectiveWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");

    Reason = CRL_REASON_UNSPECIFIED;
    hr = prow->SetProperty(
	    g_wszPropRequestRevokedReason,
	    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(Reason),
		    (BYTE const *) &Reason);
    _JumpIfError(hr, error, "SetProperty");

    hr = myGetComputerObjectName(NameSamCompatible, &pwszMachineRequesterName);
    if (S_OK != hr)
    {
	_PrintError(hr, "myGetComputerObjectName");

	hr = myGetUserNameEx(NameSamCompatible, &pwszMachineRequesterName);
	_JumpIfError(hr, error, "myGetUserNameEx");
    }

    pwszDisposition = CoreBuildDispositionString(
					g_pwszRevokedBy,
					pwszMachineRequesterName,
					NULL,
					NULL,
					NULL,
					S_OK,
					FALSE);
    if (NULL == pwszDisposition)
    {
	pwszDisposition = g_pwszRevokedBy;
    }

    hr = prow->SetProperty(
		    g_wszPropRequestDispositionMessage,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    MAXDWORD,
		    (BYTE const *) pwszDisposition);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != pwszMachineRequesterName)
    {
        LocalFree(pwszMachineRequesterName);
    }
    if (NULL != pwszDisposition && pwszDisposition != g_pwszRevokedBy)
    {
	LocalFree(const_cast<WCHAR *>(pwszDisposition));
    }
    return(hr);
}


HRESULT
PKCSParseImportedCertificate(
    IN ICertDBRow *prow,
    IN BOOL fCrossCert,		// else random imported cert
    IN DWORD Disposition,
    OPTIONAL IN CACTX const *pCAContext,
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    CERT_INFO const *pCertInfo = pCert->pCertInfo;
    DWORD dwRequestFlags = 0;
    BOOL fSubjectNameSet;
    HRESULT ErrCode = S_OK;
    BSTR strSerialNumber = NULL;

    // set raw cert property in the db
    hr = prow->SetProperty(
		g_wszPropRawCertificate,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		pCert->cbCertEncoded,
		pCert->pbCertEncoded);
    _JumpIfError(hr, error, "SetProperty");

    // set extensions
    hr = pkcsSetExtensions(
			prow,
			EXTENSION_ORIGIN_IMPORTEDCERT,
			pCertInfo->rgExtension,
			pCertInfo->cExtension);
    _JumpIfError(hr, error, "pkcsSetExtensions");

    // set request name info
    hr = pkcsSetRequestNameInfo(
			prow,
			&pCertInfo->Subject,
			NULL,		// pwszCNSuffix
			FALSE,		// fReorderLikeRDNs
			&dwRequestFlags,
			&fSubjectNameSet);
    _JumpIfError(hr, error, "pkcsSetRequestNameInfo");

    hr = pkcsSetPublicKeyProperties(prow, &pCertInfo->SubjectPublicKeyInfo);
    _JumpIfError(hr, error, "pkcsSetPublicKeyProperties");

    hr = prow->CopyRequestNames();
    _JumpIfError(hr, error, "CopyRequestNames");

    hr = pkcsSetCertAndKeyHashes(prow, pCert);
    _JumpIfError(hr, error, "pkcsSetCertAndKeyHashes");

    hr = prow->SetProperty(
		    g_wszPropCertificateNotBeforeDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
                    sizeof(pCertInfo->NotBefore),
                    (BYTE *) &pCertInfo->NotBefore);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCertificateNotAfterDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
                    sizeof(pCertInfo->NotAfter),
                    (BYTE *) &pCertInfo->NotAfter);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		g_wszPropSubjectRawName,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		pCertInfo->Subject.cbData,
		pCertInfo->Subject.pbData);
    _JumpIfError(hr, error, "SetProperty");

    // set distinguished name
    pkcsSetDistinguishedName(prow, PROPTABLE_CERTIFICATE, &pCertInfo->Subject);

    if (fCrossCert)
    {
	dwRequestFlags |= CR_FLG_CACROSSCERT;
    }
    hr = prow->SetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(dwRequestFlags),
		    (BYTE const *) &dwRequestFlags);
    _JumpIfError(hr, error, "SetProperty(RequestFlags)");

    // set disposition issued
    hr = prow->SetProperty(
			g_wszPropRequestDisposition,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(Disposition),
			(BYTE const *) &Disposition);
    _JumpIfError(hr, error, "SetProperty(disposition)");

    if (DB_DISP_REVOKED == Disposition)
    {
	hr = pkcsSetRevocationFields(prow);
	_JumpIfError(hr, error, "pkcsSetRevocationFields");
    }

    // set disposition status code
    hr = prow->SetProperty(
			g_wszPropRequestStatusCode,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			sizeof(ErrCode),
			(BYTE const *) &ErrCode);
    _JumpIfError(hr, error, "SetProperty(status code)");

    if (NULL != pCAContext)
    {
	hr = prow->SetProperty(
		    g_wszPropCertificateIssuerNameID,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    sizeof(pCAContext->NameId),
		    (BYTE *) &pCAContext->NameId);
	_JumpIfError(hr, error, "SetProperty");
    }

    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestSubmittedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");

    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestResolvedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");

    hr = pkcsSetTemplateProperty(prow, pCert);
    _JumpIfError(hr, error, "pkcsSetTemplateProperty");

    // Convert serial number to string and set in DB

    hr = MultiByteIntegerToBstr(
			FALSE,
			pCertInfo->SerialNumber.cbData,
			pCertInfo->SerialNumber.pbData,
			&strSerialNumber);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = prow->SetProperty(
		g_wszPropCertificateSerialNumber,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE *) strSerialNumber);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != strSerialNumber)
    {
        SysFreeString(strSerialNumber);
    }
    return(hr);
}


// Return TRUE if Data and Cert references apply to the specified CMC message

BOOL
pkcsCMCReferenceMatch(
    IN DWORD DataReference,	// nested CMC message Body Part Id
    IN DWORD CertReference,	// PKCS10 Cert Request Body Part Id
    IN DWORD dwCmcDataReference,
    IN DWORD cCertReference,
    IN DWORD const *rgdwCertReference)
{
    BOOL fMatch = FALSE;
    DWORD i;

    if (MAXDWORD != DataReference && dwCmcDataReference == DataReference)
    {
	fMatch = TRUE;
    }
    else if (MAXDWORD != CertReference && 0 == dwCmcDataReference)
    {
	for (i = 0; i < cCertReference; i++)
	{
	    if (rgdwCertReference[i] == CertReference)
	    {
		fMatch = TRUE;
		break;
	    }
	}
    }
    return(fMatch);
}


HRESULT
pkcsSetCMCExtensions(
    IN ICertDBRow *prow,
    IN DWORD DataReference,	// nested CMC message Body Part Id
    IN DWORD CertReference,	// PKCS10 Cert Request Body Part Id
    IN BYTE const *pbData,
    IN DWORD cbData)
{
    HRESULT hr;
    CMC_ADD_EXTENSIONS_INFO *pcmcExt = NULL;
    DWORD cb;

    // Decode CMC_ADD_EXTENSIONS_INFO from Attribute Blob

    CSASSERT(NULL == pcmcExt);
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_EXTENSIONS,
		    pbData,
		    cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcExt,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (pkcsCMCReferenceMatch(
		    DataReference,
		    CertReference,
		    pcmcExt->dwCmcDataReference,
		    pcmcExt->cCertReference,
		    pcmcExt->rgdwCertReference))
    {
	hr = pkcsSetExtensions(
			prow,
			EXTENSION_ORIGIN_CMC | EXTENSION_DISABLE_FLAG,
			pcmcExt->rgExtension,
			pcmcExt->cExtension);
	_JumpIfError(hr, error, "pkcsSetExtensions(request)");
    }
    hr = S_OK;

error:
    if (NULL != pcmcExt)
    {
	LocalFree(pcmcExt);
    }
    return(hr);
}


HRESULT
pkcsSetCMCAttributes(
    IN ICertDBRow *prow,
    IN DWORD DataReference,	// nested CMC message Body Part Id
    IN DWORD CertReference,	// PKCS10 Cert Request Body Part Id
    IN BYTE const *pbData,
    IN DWORD cbData,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    CMC_ADD_ATTRIBUTES_INFO *pcmcAttrib = NULL;
    DWORD cb;

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }

    // Decode CMC_ADD_ATTRIBUTES_INFO from Attribute Blob

    CSASSERT(NULL == pcmcAttrib);
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_ATTRIBUTES,
		    pbData,
		    cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcAttrib,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (pkcsCMCReferenceMatch(
		    DataReference,
		    CertReference,
		    pcmcAttrib->dwCmcDataReference,
		    pcmcAttrib->cCertReference,
		    pcmcAttrib->rgdwCertReference))
    {
	hr = pkcsSetAttributes(
			prow,
			EXTENSION_ORIGIN_CMC,
			PSA_DISALLOW_EXTENSIONS | PSA_DISALLOW_ARCHIVEDKEY,
			pcmcAttrib->rgAttribute,
			pcmcAttrib->cAttribute,
			0,
			NULL,
			pfEnrollOnBehalfOf,
			pResult);
	_JumpIfError(hr, error, "pkcsSetAttributes(CMC)");
    }
    hr = S_OK;

error:
    if (NULL != pcmcAttrib)
    {
	LocalFree(pcmcAttrib);
    }
    return(hr);
}


// map "email_mail" to "email"
// map "email_*" to "*"?
// mail_firstName=Terry&mail_lastName=Cheung+CMC+Zero+2&mail_email=
// tcheung%40verisign%2Ecom&challenge=test&

HRESULT
pkcsSetCMCRegInfo(
    IN ICertDBRow *prow,
    IN BYTE const *pbOctet,
    IN DWORD cbOctet,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf)
{
    HRESULT hr;
    WCHAR *pwszRA = NULL;

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }
    hr = myDecodeCMCRegInfo(pbOctet, cbOctet, &pwszRA);
    _JumpIfError(hr, error, "myDecodeCMCRegInfo");

    hr = PKCSParseAttributes(
			prow,
			pwszRA,
			TRUE,
			FALSE,
			PROPTABLE_REQUEST,
			pfEnrollOnBehalfOf);
    _JumpIfError(hr, error, "PKCSParseAttributes");

error:
    if (NULL != pwszRA)
    {
	LocalFree(pwszRA);
    }
    return(hr);
}


HRESULT
pkcsSetTaggedAttributes(
    IN ICertDBRow *prow,
    IN DWORD DataReference,	// nested CMC message Body Part Id
    IN DWORD CertReference,	// PKCS10 Cert Request Body Part Id
    IN CMC_TAGGED_ATTRIBUTE const *pTaggedAttribute,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD i;
    CRYPT_ATTRIBUTE const *pAttribute = &pTaggedAttribute->Attribute;
    DWORD cb;
    BOOL fEnrollOnBehalfOf;

    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }
    for (i = 0; i < pAttribute->cValue; i++)
    {
	if (0 == strcmp(szOID_CMC_ADD_EXTENSIONS, pAttribute->pszObjId))
	{
	    hr = pkcsSetCMCExtensions(
				prow,
				DataReference,
				CertReference,
				pAttribute->rgValue[i].pbData,
				pAttribute->rgValue[i].cbData);
	    _JumpIfError(hr, error, "pkcsSetCMCExtensions");
	}
	else
	if (0 == strcmp(szOID_CMC_ADD_ATTRIBUTES, pAttribute->pszObjId))
	{
	    fEnrollOnBehalfOf = FALSE;

	    hr = pkcsSetCMCAttributes(
			prow,
			DataReference,
			CertReference,
			pAttribute->rgValue[i].pbData,
			pAttribute->rgValue[i].cbData,
			NULL != pfEnrollOnBehalfOf? &fEnrollOnBehalfOf : NULL,
			pResult);
	    _JumpIfError(hr, error, "pkcsSetCMCAttributes");

	    if (fEnrollOnBehalfOf)
	    {
		CSASSERT(NULL != pfEnrollOnBehalfOf);
		*pfEnrollOnBehalfOf = TRUE;
	    }
	}
	else
	if (0 == strcmp(szOID_CMC_REG_INFO, pAttribute->pszObjId))
	{
	    fEnrollOnBehalfOf = FALSE;

	    hr = pkcsSetCMCRegInfo(
			prow,
			pAttribute->rgValue[i].pbData,
			pAttribute->rgValue[i].cbData,
			NULL != pfEnrollOnBehalfOf? &fEnrollOnBehalfOf : NULL);
	    _JumpIfError(hr, error, "pkcsSetCMCRegInfo");

	    if (fEnrollOnBehalfOf)
	    {
		CSASSERT(NULL != pfEnrollOnBehalfOf);
		*pfEnrollOnBehalfOf = TRUE;
	    }
	}
	else
	if (0 == strcmp(szOID_CMC_TRANSACTION_ID, pAttribute->pszObjId))
	{
	    DWORD dwTransactionId;
	    
	    cb = sizeof(dwTransactionId);
	    dwTransactionId = 0;
	    if (!CryptDecodeObject(
				X509_ASN_ENCODING,
				X509_INTEGER,
				pAttribute->rgValue[i].pbData,
				pAttribute->rgValue[i].cbData,
				0,
				&dwTransactionId,
				&cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptDecodeObject");
	    }
	    pResult->fTransactionId = TRUE;
	    pResult->dwTransactionId = dwTransactionId;
	}
	else
	if (0 == strcmp(szOID_CMC_SENDER_NONCE, pAttribute->pszObjId))
	{
	    CRYPT_DATA_BLOB *pBlob;
	    BYTE *pb;

	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pAttribute->rgValue[i].pbData,
			    pAttribute->rgValue[i].cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pBlob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, pBlob->cbData);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
	    }
	    else
	    {
		CopyMemory(pb, pBlob->pbData, pBlob->cbData);
		if (NULL != pResult->pbSenderNonce)
		{
		    LocalFree(pResult->pbSenderNonce);
		}
		pResult->pbSenderNonce = pb;
		pResult->cbSenderNonce = pBlob->cbData;
		hr = S_OK;
	    }
	    LocalFree(pBlob);
	    _JumpIfError(hr, error, "LocalAlloc");
	}
	else if (0 == (CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES & g_dwCRLFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "unknown tagged attribute");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+------------------------------------------------------------------------
// pkcsParseCMCRequest
//
// Crack a CMC request and dig the goodies out of it.
// Crack the contents of the CMC request recursively.
//-------------------------------------------------------------------------

HRESULT
pkcsParseCMCRequest(
    IN ICertDBRow *prow,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    OPTIONAL IN CERT_CONTEXT const *pCertSigner,
    OPTIONAL OUT BOOL *pfRenewal,
    OPTIONAL OUT BOOL *pfEnrollOnBehalfOf,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    DWORD cb;
    CMC_DATA_INFO *pcmcData = NULL;
    DWORD i;
    DWORD DataReference = MAXDWORD;	// nested CMC message Body Part Id
    DWORD CertReference = MAXDWORD;	// PKCS10 Cert Request Body Part Id

    if (NULL != pfRenewal)
    {
	*pfRenewal = FALSE;
    }
    if (NULL != pfEnrollOnBehalfOf)
    {
	*pfEnrollOnBehalfOf = FALSE;
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_DATA,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcData,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (0 != pcmcData->cTaggedOtherMsg)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "unknown other message");
    }

    // Process nested CMC messages

    if (0 != pcmcData->cTaggedContentInfo)
    {
	CMC_TAGGED_CONTENT_INFO const *pTaggedContentInfo;

	// Only handle one CMC message at a time for now.

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	if (1 < pcmcData->cTaggedContentInfo)
	{
	    _JumpError(hr, error, "multiple nested CMC messages");
	}

	// Disallow CMC message recursion below a PKCS10 request.

	if (0 != pcmcData->cTaggedRequest)
	{
	    _JumpError(hr, error, "recursion below PKCS10 request");
	}

	// Recurse on the nested CMC message

	pTaggedContentInfo = &pcmcData->rgTaggedContentInfo[0];

	hr = PKCSParseRequest(
			CR_IN_CMC | (~CR_IN_FORMATMASK & pResult->dwFlagsTop),
			prow,
			pTaggedContentInfo->EncodedContentInfo.cbData,
			pTaggedContentInfo->EncodedContentInfo.pbData,
			pCertSigner,
			pfRenewal,
			pResult);
	_JumpIfError(hr, error, "PKCSParseRequest");

	DataReference = pTaggedContentInfo->dwBodyPartID;
    }

    // Process nested PKCS10 requests

    if (0 != pcmcData->cTaggedRequest)
    {
	CMC_TAGGED_REQUEST const *pTaggedRequest;
	CMC_TAGGED_CERT_REQUEST const *pTaggedCertRequest;

	// Only handle one request at a time for now.

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	if (1 < pcmcData->cTaggedRequest)
	{
	    _JumpError(hr, error, "multiple PKCS10 requests");
	}

	pTaggedRequest = &pcmcData->rgTaggedRequest[0];

	// The request must be a PKCS10 request

	if (CMC_TAGGED_CERT_REQUEST_CHOICE !=
	    pTaggedRequest->dwTaggedRequestChoice)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "recursion below PKCS10 request");
	}

	pTaggedCertRequest = pTaggedRequest->pTaggedCertRequest;

	hr = PKCSParseRequest(
		    CR_IN_PKCS10 | (~CR_IN_FORMATMASK & pResult->dwFlagsTop),
		    prow,
		    pTaggedCertRequest->SignedCertRequest.cbData,
		    pTaggedCertRequest->SignedCertRequest.pbData,
		    pCertSigner,
		    pfRenewal,
		    pResult);
	_JumpIfError(hr, error, "PKCSParseRequest");

	CertReference = pTaggedCertRequest->dwBodyPartID;
    }

    // Process extensions and attributes

    for (i = 0; i < pcmcData->cTaggedAttribute; i++)
    {
	hr = pkcsSetTaggedAttributes(
			prow,
			DataReference,
			CertReference,
			&pcmcData->rgTaggedAttribute[i],
			pfEnrollOnBehalfOf,
			pResult);
	_JumpIfError(hr, error, "pkcsSetTaggedAttributes");
    }
    hr = S_OK;

error:
    if (NULL != pcmcData)
    {
	LocalFree(pcmcData);
    }
    return(hr);
}


HRESULT
pkcsAppendPolicies(
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    OPTIONAL IN WCHAR const *pwszzPolicies)
{
    HRESULT hr;
    WCHAR *pwszOld = NULL;
    WCHAR *pwszNew = NULL;
    WCHAR const *pwszIn;
    WCHAR *pwsz;
    DWORD cwc = 0;
    DWORD cb;

    hr = PKCSGetProperty(
		prow,
		pwszPropName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cb,
		(BYTE **) &pwszOld);
    _PrintIfError2(hr, "PKCSGetProperty", hr);
    if (S_OK != hr)
    {
	pwszOld = NULL;
    }
    if (NULL != pwszOld)
    {
	cwc = wcslen(pwszOld) + 1;	// allow for \n separator
    }

    // pwszzPolicies == NULL means the cert is good for *all* policies.
    // Store "*"
    //
    // *pwszzPolicies == L'\0' means the cert is good for *no* policies.
    // Store "-"

    if (NULL == pwszzPolicies)
    {
	pwszzPolicies = L"*\0";
    }
    else if (L'\0' == *pwszzPolicies)
    {
	pwszzPolicies = L"-\0";
    }
    for (pwszIn = pwszzPolicies; L'\0' != *pwszIn; pwszIn += wcslen(pwszIn) + 1)
	    ;

    cwc += SAFE_SUBTRACT_POINTERS(pwszIn, pwszzPolicies);
    pwszNew = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pwsz = pwszNew;

    if (NULL != pwszOld)
    {
	wcscpy(pwsz, pwszOld);
	pwsz += wcslen(pwsz);

	wcscpy(pwsz, L"\n");
	pwsz++;
    }

    for (pwszIn = pwszzPolicies; L'\0' != *pwszIn; pwszIn += wcslen(pwszIn) + 1)
    {
	if (pwszIn != pwszzPolicies)
	{
	    wcscpy(pwsz, L",");
	    pwsz++;
	}
	wcscpy(pwsz, pwszIn);
	pwsz += wcslen(pwsz);
    }
    CSASSERT(&pwsz[1] == &pwszNew[cwc]);

    hr = prow->SetProperty(
	    pwszPropName,
	    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
	    MAXDWORD,
	    (BYTE const *) pwszNew);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != pwszOld)
    {
	LocalFree(pwszOld);
    }
    if (NULL != pwszNew)
    {
	LocalFree(pwszNew);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// pkcsParsePKCS7Request
//
// Crack a PKCS7 and dig the goodies out of it.
// Verify the signature of the 7 against the cert given in the 7.
// Crack the contents of the 7 recursively.
//-------------------------------------------------------------------------

HRESULT
pkcsParsePKCS7Request(
    IN BOOL fTopLevel,
    IN DWORD dwFlags,
    IN ICertDBRow *prow,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;
    BYTE *pbContents = NULL;
    DWORD cbContents;
    CERT_CONTEXT const *pCertSigner = NULL;
    HCERTSTORE hStore = NULL;
    HCRYPTMSG hMsg = NULL;
    char *pszInnerContentObjId = NULL;
    DWORD i;
    BOOL fCMC;
    BOOL fRenewal = FALSE;
    char *apszEnrollOids[] = {szOID_ENROLLMENT_AGENT};
    DWORD dwVerifyContextFlags;
    DWORD dwMsgType;
    DWORD cSigner;
    DWORD cFirstSigner;
    BOOL fFirstSigner;
    DWORD cRecipient;
    DWORD cb;
    CMSG_CMS_SIGNER_INFO *pcsi = NULL;
    DWORD dwDisallowFlags;
    DWORD iElement;
    WCHAR *pwszzIssuancePolicies = NULL;
    WCHAR *pwszzApplicationPolicies = NULL;
    WCHAR *pwszExtendedErrorInfo = NULL;
    CERT_REQUEST_INFO *pRequest = NULL;
    BOOL fEnrollOnBehalfOf;

    CSASSERT(
	CR_IN_PKCS7 == (CR_IN_FORMATMASK & dwFlags) ||
	CR_IN_CMC == (CR_IN_FORMATMASK & dwFlags));

    // Crack the 7 and verify the signature.

    hr = myDecodePKCS7(
		    pbIn,
		    cbIn,
		    &pbContents,
		    &cbContents,
		    &dwMsgType,
		    &pszInnerContentObjId,
		    &cSigner,
		    &cRecipient,
		    &hStore,
		    &hMsg);
    _JumpIfError(hr, error, "myDecodePKCS7");

    if (CMSG_SIGNED != dwMsgType || 0 == cSigner)
    {
	hr = CRYPT_E_NO_SIGNER;
	_JumpIfError(hr, error, "myDecodePKCS7(no signing cert)");
    }

    fCMC = NULL != pszInnerContentObjId &&
	   0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA);

    // Decode the contents.

    if (fCMC)
    {
	if (CR_IN_CMC != (CR_IN_FORMATMASK & dwFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "dwFlags");
	}
	// CMC renewal requests may have one 'first' signer (non-NULL KeyId or
	// Dummy signer) and one additional Issuer+Serial signer.  If the
	// request has the appropriate signatures, pass the cert to the lowest
	// level to see if it really is a renewal request.

	if (1 <= cSigner && 2 >= cSigner)
	{
	    DWORD iCertSigner = MAXDWORD;

	    cFirstSigner = 0;
	    for (i = 0; i < cSigner; i++)
	    {
		if (NULL != pcsi)
		{
		    LocalFree(pcsi);
		    pcsi = NULL;
		}
		hr = myCryptMsgGetParam(
				    hMsg,
				    CMSG_CMS_SIGNER_INFO_PARAM,
				    i,
				    CERTLIB_USE_LOCALALLOC,
				    (VOID **) &pcsi,
				    &cb);
		_JumpIfError(hr, error, "myCryptMsgGetParam");

		fFirstSigner = FALSE;
		if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
		    (NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
		     0 == strcmp(
			    szOID_PKIX_NO_SIGNATURE,
			    pcsi->HashEncryptionAlgorithm.pszObjId)))
		{
		    fFirstSigner = TRUE;
		    cFirstSigner++;
		}
		else
		{
		    if (MAXDWORD != iCertSigner)
		    {
			iCertSigner = MAXDWORD;	// must not be a renewal
			break;
		    }
		    iCertSigner = i;
		}
	    }
	    if (MAXDWORD != iCertSigner && 1 >= cFirstSigner)
	    {
		iElement = iCertSigner;
		if (!CryptMsgGetAndVerifySigner(
					hMsg,
					0,		// cSignerStore
					NULL,		// rghSignerStore
					CMSG_USE_SIGNER_INDEX_FLAG,
					&pCertSigner,
					&iElement))
		{
		    pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptMsgGetAndVerifySigner");
		}
	    }
	}
	fEnrollOnBehalfOf = FALSE;
	hr = pkcsParseCMCRequest(
			    prow,
			    cbContents,
			    pbContents,
			    pCertSigner,
			    &fRenewal,
			    &fEnrollOnBehalfOf,
			    pResult);
	_JumpIfError(hr, error, "pkcsParseCMCRequest");

	if (fEnrollOnBehalfOf)
	{
	    pResult->fEnrollOnBehalfOf = TRUE;
	}
    }
    else
    {
	if (CR_IN_PKCS7 != (CR_IN_FORMATMASK & dwFlags))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "dwFlags");
	}

	// Expect only one signer for PKCS7 renewal requests.  Pass the cert
	// to the lowest level to see if it really is a renewal request.

	iElement = 0;
	if (!CryptMsgGetAndVerifySigner(
				hMsg,
				0,		// cSignerStore
				NULL,		// rghSignerStore
				CMSG_USE_SIGNER_INDEX_FLAG,
				&pCertSigner,
				&iElement))
	{
	    pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptMsgGetAndVerifySigner");
	}
	hr = PKCSParseRequest(
		CR_IN_FORMATANY | (~CR_IN_FORMATMASK & pResult->dwFlagsTop),
		prow,
		cbContents,
		pbContents,
		pCertSigner,
		&fRenewal,
		pResult);
	_JumpIfError(hr, error, "PKCSParseRequest");
    }

    // Loop through the signers, verifying signatures and saving attributes.

    cFirstSigner = 0;
    for (i = 0; i < cSigner; i++)
    {
	if (NULL != pcsi)
	{
	    LocalFree(pcsi);
	    pcsi = NULL;
	}
	if (NULL != pwszzIssuancePolicies)
	{
	    LocalFree(pwszzIssuancePolicies);
	    pwszzIssuancePolicies = NULL;
	}
	if (NULL != pwszzApplicationPolicies)
	{
	    LocalFree(pwszzApplicationPolicies);
	    pwszzApplicationPolicies = NULL;
	}
	if (NULL != pwszExtendedErrorInfo)
	{
	    LocalFree(pwszExtendedErrorInfo);
	    pwszExtendedErrorInfo = NULL;
	}
	if (NULL != pCertSigner)
	{
	    CertFreeCertificateContext(pCertSigner);
	    pCertSigner = NULL;
	}
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_CMS_SIGNER_INFO_PARAM,
			    i,
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pcsi,
			    &cb);
	if (S_OK != hr)
	{
	    pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
	    _JumpError(hr, error, "myCryptMsgGetParam");
	}

	fFirstSigner = FALSE;
	if (fCMC &&
	    (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
	     (NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
	      0 == strcmp(
		    szOID_PKIX_NO_SIGNATURE,
		    pcsi->HashEncryptionAlgorithm.pszObjId))))
	{
	    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA cvse;

	    fFirstSigner = TRUE;
	    ZeroMemory(&cvse, sizeof(cvse));
	    cvse.cbSize = sizeof(cvse);
	    cvse.dwSignerIndex = i;

	    if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice)
	    {
		if (NULL == pRequest)
		{
		    hr = myGetInnerPKCS10(
				    hMsg,
				    pszInnerContentObjId,
				    &pRequest);
		    _JumpIfError(hr, error, "myGetInnerPKCS10");
		}
		cvse.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
		cvse.pvSigner = &pRequest->SubjectPublicKeyInfo;
	    }
	    else
	    {
		cvse.dwSignerType = CMSG_VERIFY_SIGNER_NULL;
	    }

	    if (!CryptMsgControl(
			    hMsg,
			    0,		// dwFlags
			    CMSG_CTRL_VERIFY_SIGNATURE_EX,
			    &cvse))
	    {
		pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgControl(VerifySig)");
	    }
	}
	else
	{
	    iElement = i;
	    if (!CryptMsgGetAndVerifySigner(
				    hMsg,
				    0,			// cSignerStore
				    NULL,		// rghSignerStore
				    CMSG_USE_SIGNER_INDEX_FLAG,
				    &pCertSigner,
				    &iElement))
	    {
		pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgGetAndVerifySigner");
	    }
	}

	// Only enroll-on-behalf-of requests may contain Name, Value pairs.
	// Only enroll-on-behalf-of requests and renewal requests may contain
	// certificate extensions.

	dwDisallowFlags = PSA_DISALLOW_ARCHIVEDKEY;
	if (fRenewal)
	{
	    dwDisallowFlags |= PSA_DISALLOW_NAMEVALUEPAIRS;
	    pResult->dwResultFlags |= CRCF_RENEWAL;
	}
	if (fCMC)
	{
	    dwDisallowFlags |= PSA_DISALLOW_EXTENSIONS |
			       PSA_DISALLOW_NAMEVALUEPAIRS;
	}
	fEnrollOnBehalfOf = FALSE;
	hr = pkcsSetAttributes(
			prow,
			EXTENSION_ORIGIN_PKCS7,
			dwDisallowFlags,
			pcsi->AuthAttrs.rgAttr,
			pcsi->AuthAttrs.cAttr,
			0,
			NULL,
			&fEnrollOnBehalfOf,
			pResult);
	_JumpIfError(hr, error, "pkcsSetAttributes(Authenticated)");

	if (fEnrollOnBehalfOf)
	{
	    pResult->fEnrollOnBehalfOf = TRUE;
	}

	// Pull encrypted private key out of unauthenticated attributes

	hr = pkcsSetAttributes(
			prow,
			EXTENSION_ORIGIN_PKCS7,
			((fTopLevel && fFirstSigner)? 0 :  PSA_DISALLOW_ARCHIVEDKEY) |
			    PSA_DISALLOW_EXTENSIONS |
			    PSA_DISALLOW_NAMEVALUEPAIRS,
			pcsi->UnauthAttrs.rgAttr,
			pcsi->UnauthAttrs.cAttr,
			cbIn,
			fTopLevel? pbIn : NULL,
			NULL,
			pResult);
	_JumpIfError(hr, error, "pkcsSetAttributes(UNauthenticated)");

	if (fFirstSigner)
	{
	    cFirstSigner++;
	}
	else
	{
	    BOOL fEnrollmentAgent;

	    // This is a renewal request, an enroll-on-behalf-of request, a CMC
	    // request or just a request inside a PKCS 7 -- verify the cert
	    // chain for all signers.  If enroll-on-behalf-of on an Enterprise
	    // CA (if requester name is set in the authenticated attributes),
	    // check the signing cert via NTAuth policy and check for
	    // szOID_ENROLLMENT_AGENT usage.  NtAuth verification was added to
	    // control the ability of enroll-on-behalf agents to add usernames
	    // to the PKCS7 wrapper.

	    fEnrollmentAgent = pResult->fEnrollOnBehalfOf &&
#ifdef CERTSRV_EOBO_DCR_APPROVED
			(CRLF_ENFORCE_ENROLLMENT_AGENT & g_dwCRLFlags);
#else
			((CRLF_ENFORCE_ENROLLMENT_AGENT & g_dwCRLFlags) ||
			 IsEnterpriseCA(g_CAType));
#endif
	    dwVerifyContextFlags = g_dwVerifyCertFlags;
	    if (pResult->fEnrollOnBehalfOf && IsEnterpriseCA(g_CAType))
	    {
		dwVerifyContextFlags |= CA_VERIFY_FLAGS_NT_AUTH;
	    }

	    hr = myVerifyCertContextEx(
			    pCertSigner,
			    dwVerifyContextFlags,
			    0,				// dwmsTimeout
			    fEnrollmentAgent? ARRAYSIZE(apszEnrollOids) : 0,
			    fEnrollmentAgent? apszEnrollOids : NULL,
			    0,				// cIssuanceOids
			    NULL,			// apszIssuanceOids
			    HCCE_LOCAL_MACHINE,		// hChainEngine
			    NULL,			// pft
			    hStore,			// hAdditionalStore
			    NULL,			// pfnCallback
			    NULL,			// ppwszMissingIssuer
			    &pwszzIssuancePolicies,
			    &pwszzApplicationPolicies,
			    &pwszExtendedErrorInfo,
			    NULL);			// pTrustStatus
	    if (S_OK != hr)
	    {
		pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
		_JumpError(hr, error, "myVerifyCertContextEx");
	    }
	    if (NULL != pwszExtendedErrorInfo)
	    {
		hr = myAppendString(
			    pwszExtendedErrorInfo,
			    L", ",
			    &pResult->pwszExtendedErrorInfo);
		_JumpIfError(hr, error, "myAppendString");
	    }
	    if (fTopLevel)
	    {
		// save Issuance Policies

		hr = pkcsAppendPolicies(
				    prow,
				    wszPROPSIGNERPOLICIES,
				    pwszzIssuancePolicies);
		_JumpIfError(hr, error, "pkcsAppendPolicies");

		// save Application Policies

		hr = pkcsAppendPolicies(
				    prow,
				    wszPROPSIGNERAPPLICATIONPOLICIES,
				    pwszzApplicationPolicies);
		_JumpIfError(hr, error, "pkcsAppendPolicies");
	    }
	}
    }
    if (pResult->fEnrollOnBehalfOf)
    {
	hr = PKCSSetRequestFlags(prow, TRUE, CR_FLG_ENROLLONBEHALFOF);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");

	if (fCMC && cSigner == cFirstSigner)
	{
	    pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
	    hr = CRYPT_E_NO_TRUSTED_SIGNER;
	    _JumpError(hr, error, "No NTAuth signer");
	}
    }
    if ((fCMC && 1 < cFirstSigner) || (!fCMC && 0 < cFirstSigner))
    {
	pResult->dwResultFlags |= CRCF_SIGNATUREERROR;
	hr = NTE_BAD_SIGNATURE;
	_JumpError(hr, error, "cFirstSigner");
    }

error:
    if (NULL != pRequest)
    {
	LocalFree(pRequest);
    }
    if (NULL != pcsi)
    {
	LocalFree(pcsi);
    }
    if (NULL != pwszzIssuancePolicies)
    {
	LocalFree(pwszzIssuancePolicies);
    }
    if (NULL != pwszzApplicationPolicies)
    {
	LocalFree(pwszzApplicationPolicies);
    }
    if (NULL != pwszExtendedErrorInfo)
    {
	LocalFree(pwszExtendedErrorInfo);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pCertSigner)
    {
	CertFreeCertificateContext(pCertSigner);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbContents)
    {
	LocalFree(pbContents);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    return(hr);
}


typedef struct _REQUESTFORMATS
{
    char const *pszFormat;
    DWORD       dwFlags;
} REQUESTFORMATS;


REQUESTFORMATS g_arf[] = {
    { X509_CERT_REQUEST_TO_BE_SIGNED,   CR_IN_PKCS10 },
    { X509_KEYGEN_REQUEST_TO_BE_SIGNED, CR_IN_KEYGEN },
};
#define CREQUESTFORMATS		ARRAYSIZE(g_arf)


HRESULT
pkcsCrackRequestType(
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    OUT DWORD *pdwFlags)
{
    HRESULT hr = S_OK;
    DWORD cb;
    BYTE *pbDecoded = NULL;
    REQUESTFORMATS const *prf;
    REQUESTFORMATS const *prfEnd;
    HCRYPTMSG hMsg = NULL;
    char *pszInnerContentObjId = NULL;

    prfEnd = &g_arf[CREQUESTFORMATS];
    for (prf = g_arf; prf < prfEnd; prf++)
    {
	CSASSERT(NULL == pbDecoded);
	if (myDecodeObject(
			X509_ASN_ENCODING,
			prf->pszFormat,
			pbRequest,
			cbRequest,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbDecoded,
			&cb))
	{
	    *pdwFlags = prf->dwFlags;
	    break;
	}
	hr = myHLastError();
	CSASSERT(S_OK != hr);
    }
    if (prf >= prfEnd)
    {
	CSASSERT(S_OK != hr);

	hr = myDecodePKCS7(
			pbRequest,
			cbRequest,
			NULL,		// ppbContents
			NULL,		// pcbContents
			NULL,		// pdwMsgType
			&pszInnerContentObjId,
			NULL,		// pcSigner
			NULL,		// pcRecipient
			NULL,		// phStore
			&hMsg);
	_JumpIfError(hr, error, "myDecodePKCS7");

	*pdwFlags = CR_IN_PKCS7;	// default to renewal

	if (NULL != pszInnerContentObjId &&
	    0 == strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA))
	{
	    *pdwFlags = CR_IN_CMC;
	}
    }
    hr = S_OK;

error:
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    return(hr);
}


HRESULT
PKCSParseRequest(
    IN DWORD dwFlags,
    IN ICertDBRow *prow,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest,
    IN CERT_CONTEXT const *pSigningAuthority,
    OPTIONAL OUT BOOL *pfRenewal,
    IN OUT CERTSRV_RESULT_CONTEXT *pResult)
{
    HRESULT hr;

    if (NULL != pfRenewal)
    {
	*pfRenewal = FALSE;
    }

    if (CR_IN_FORMATANY == (CR_IN_FORMATMASK & dwFlags))
    {
	hr = pkcsCrackRequestType(cbRequest, pbRequest, &dwFlags);
	_JumpIfError(hr, error, "pkcsCrackRequestType");

	dwFlags |= ~CR_IN_FORMATMASK & pResult->dwFlagsTop;

	// If this is the top level caller, store a more specific request type:

	if (NULL == pfRenewal)
	{
	    pResult->dwFlagsTop = dwFlags;
	    hr = prow->SetProperty(
		g_wszPropRequestType,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		sizeof(dwFlags),
		(BYTE const *) &dwFlags);
	    _JumpIfError(hr, error, "SetProperty(reqtype)");
	}
    }

    switch (CR_IN_FORMATMASK & dwFlags)
    {
	case CR_IN_PKCS10:
	    hr = pkcsParsePKCS10Request(
				    dwFlags,
				    prow,
				    cbRequest,
				    pbRequest,
				    pSigningAuthority,
				    pfRenewal,
				    pResult);
	    _JumpIfError(hr, error, "pkcsParsePKCS10Request");
	    break;

	case CR_IN_KEYGEN:
	    hr = pkcsParseKeyGenRequest(
				    dwFlags,
				    prow,
				    cbRequest,
				    pbRequest,
				    pResult);
	    _JumpIfError(hr, error, "pkcsParseKeyGenRequest");
	    break;

	case CR_IN_CMC:
	case CR_IN_PKCS7:
	    // PKCS7 requests can either be an 'enroll on behalf of', renewal
	    // request or a CMC request.  We need to recursively unwrap it to
	    // process it.

	    hr = pkcsParsePKCS7Request(
				NULL == pfRenewal,	// fTopLevel
				dwFlags,
				prow,
				cbRequest,
				pbRequest,
				pResult);
	    _JumpIfError(hr, error, "pkcsParsePKCS7Request");

	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "dwFlags");
    }

error:
    if (NULL == pfRenewal)
    {
	HRESULT hr2;
	DWORD cbData;

	hr2 = prow->GetProperty(
		    g_wszPropRequestRawRequest,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cbData,
		    NULL);
	if (S_OK != hr2)
	{
	    hr2 = prow->SetProperty(
			g_wszPropRequestRawRequest,
			PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			cbRequest,
			pbRequest);
	    _PrintIfError(hr2, "SetProperty(request)");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    return(hr);
}


HRESULT
PKCSGetCRLList(
    IN BOOL fDelta,
    IN DWORD iCert,
    OUT WCHAR const * const **ppapwszCRLList)
{
    HRESULT hr = E_INVALIDARG;

    *ppapwszCRLList = NULL;
    if (iCert < g_cCACerts)
    {
	CACTX *pCAContext = &g_aCAContext[iCert];

	if (NULL == pCAContext->pccCA)
	{
	    hr = S_FALSE;
	    goto error;
	}
	*ppapwszCRLList = fDelta?
			    pCAContext->papwszDeltaCRLFiles :
			    pCAContext->papwszCRLFiles;
	if (NULL != *ppapwszCRLList)
	{
	    hr = S_OK;
	}
    }
error:
    return(hr);
}


HRESULT
pkcsBuildCRLList(
    IN BOOL fDelta,
    IN OUT CACTX *pCAContext,
    OUT WCHAR ***ppapwszOut)
{
    HRESULT hr;
    DWORD PublishFlag = fDelta? CSURL_SERVERPUBLISHDELTA : CSURL_SERVERPUBLISH;
    DWORD cFiles;
    CSURLTEMPLATE const *pTemplate;
    CSURLTEMPLATE const *pTemplateEnd;

    cFiles = 0;
    pTemplateEnd = &g_paRevURL[g_caRevURL];
    for (pTemplate = g_paRevURL; pTemplate < pTemplateEnd; pTemplate++)
    {
	if (PublishFlag & pTemplate->Flags)
	{
	    cFiles++;
	}
    }
    *ppapwszOut = (WCHAR **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				(cFiles + 1) * sizeof((*ppapwszOut)[0]));
    if (NULL == *ppapwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    DBGPRINT((
	DBG_SS_CERTSRVI,
	"CRLList alloc[%u] = %x @%x\n",
	cFiles,
	*ppapwszOut,
	ppapwszOut));

    CSASSERT(NULL != g_strDomainDN && NULL != g_strConfigDN);
    cFiles = 0;
    for (pTemplate = g_paRevURL; pTemplate < pTemplateEnd; pTemplate++)
    {
	if (PublishFlag & pTemplate->Flags)
	{
	    hr = myFormatCertsrvStringArray(
		    FALSE,			// fURL
		    g_pwszServerName,		// pwszServerName_p1_2
		    g_wszSanitizedName,		// pwszSanitizedName_p3_7
		    pCAContext->iKey,		// iCert_p4 -- use iKey!!
		    MAXDWORD,			// iCertTarget_p4
		    g_strDomainDN,		// pwszDomainDN_p5
		    g_strConfigDN,		// pwszConfigDN_p6
		    pCAContext->iKey,		// iCRL_p8
		    fDelta,			// fDeltaCRL_p9
		    FALSE,			// fDSAttrib_p10_11
		    1,				// cStrings
		    (LPCWSTR *) &pTemplate->pwszURL, // apwszStringsIn
		    &(*ppapwszOut)[cFiles]);	     // apwszStringsOut
	    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"CRLList format[%u] = %x @%x (%ws)\n",
		cFiles,
		(*ppapwszOut)[cFiles],
		&(*ppapwszOut)[cFiles],
		(*ppapwszOut)[cFiles]));

	    cFiles++;
	}
    }
    (*ppapwszOut)[cFiles] = NULL;
    hr = S_OK;

error:
    // Freeing the CACTX structure during shutdown will free orphaned CRL paths
    return(hr);
}


HRESULT
pkcsBuildKeyAuthority2(
    IN DWORD EditFlags,
    IN CACTX const *pCAContext,
    OUT CRYPT_OBJID_BLOB *pKeyAuthority2)
{
    HRESULT hr = S_OK;
    CERT_AUTHORITY_KEY_ID2_INFO keyAuth;
    CERT_ALT_NAME_ENTRY AltNameEntry;

    if (0 ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL) & EditFlags))
    {
	goto error;
    }
    ZeroMemory(&keyAuth, sizeof(keyAuth));

    // Issuer's KeyId:

    if ((EDITF_ENABLEAKIKEYID & EditFlags) &&
	NULL != pCAContext->IssuerKeyId.pbData)
    {
	keyAuth.KeyId = pCAContext->IssuerKeyId;
    }

    // The Issuer's Issuer name and the Issuer's SerialNumber combined
    // should uniquely identify the Issuer cert.

    // Issuer's Issuer name:
    // -------- ------ ----

    if (EDITF_ENABLEAKIISSUERNAME & EditFlags)
    {
	AltNameEntry.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
	AltNameEntry.DirectoryName = pCAContext->pccCA->pCertInfo->Issuer;
	keyAuth.AuthorityCertIssuer.cAltEntry = 1;
	keyAuth.AuthorityCertIssuer.rgAltEntry = &AltNameEntry;
    }

    // Issuer's SerialNumber:

    if (EDITF_ENABLEAKIISSUERSERIAL & EditFlags)
    {
	keyAuth.AuthorityCertSerialNumber =
	    pCAContext->pccCA->pCertInfo->SerialNumber;
    }

    // put in Key Authority Info

    if (!myEncodeKeyAuthority2(
			X509_ASN_ENCODING,
			&keyAuth,
			CERTLIB_USE_LOCALALLOC,
			&pKeyAuthority2->pbData,
			&pKeyAuthority2->cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeKeyAuthority2");
    }

error:
    return(hr);
}


HRESULT
pkcsBuildCDP(
    IN DWORD Flags,
    IN BOOL fDelta,
    IN CACTX const *pCAContext,
    OUT CRYPT_OBJID_BLOB *pCDP)
{
    HRESULT hr;
    DWORD i;
    CSURLTEMPLATE const *pTemplate;
    CSURLTEMPLATE const *pTemplateEnd;
    CRL_DIST_POINTS_INFO CRLDistInfo;
    CRL_DIST_POINT CRLDistPoint;
    CERT_ALT_NAME_INFO *pAltInfo;

    ZeroMemory(&CRLDistPoint, sizeof(CRLDistPoint));
    pAltInfo = &CRLDistPoint.DistPointName.FullName;

    pCDP->pbData = NULL;
    pCDP->cbData = 0;

    pTemplateEnd = g_paCACertURL;
    if (0 != g_caRevURL)
    {
	pTemplateEnd = &g_paRevURL[g_caRevURL];
	for (pTemplate = g_paRevURL; pTemplate < pTemplateEnd; pTemplate++)
	{
	    if (Flags & pTemplate->Flags)
	    {
		pAltInfo->cAltEntry++;
	    }
	}
    }
    if (0 == pAltInfo->cAltEntry)
    {
	hr = S_FALSE;
	goto error;
    }

    CRLDistInfo.cDistPoint = 1;
    CRLDistInfo.rgDistPoint = &CRLDistPoint;

    CRLDistPoint.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;

    pAltInfo->rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			pAltInfo->cAltEntry * sizeof(pAltInfo->rgAltEntry[0]));
    if (NULL == pAltInfo->rgAltEntry)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    CSASSERT(NULL != g_strDomainDN && NULL != g_strConfigDN);
    i = 0;
    for (pTemplate = g_paRevURL; pTemplate < pTemplateEnd; pTemplate++)
    {
	if (Flags & pTemplate->Flags)
	{
	    hr = myFormatCertsrvStringArray(
		    TRUE,			// fURL
		    g_pwszServerName,		// pwszServerName_p1_2
		    g_wszSanitizedName,		// pwszSanitizedName_p3_7
		    pCAContext->iCert,		// iCert_p4
		    MAXDWORD,			// iCertTarget_p4
		    g_strDomainDN,		// pwszDomainDN_p5
		    g_strConfigDN,		// pwszConfigDN_p6
		    pCAContext->iKey,		// iCRL_p8
		    fDelta,			// fDeltaCRL_p9
		    TRUE,			// fDSAttrib_p10_11
		    1,				// cStrings
		    (LPCWSTR *) &pTemplate->pwszURL,   // apwszStringsIn
		    &pAltInfo->rgAltEntry[i].pwszURL); // apwszStringsOut
	    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

	    pAltInfo->rgAltEntry[i].dwAltNameChoice = CERT_ALT_NAME_URL;
	    i++;
	}
    }
    CSASSERT(pAltInfo->cAltEntry == i);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    &CRLDistInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pCDP->pbData,
		    &pCDP->cbData))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pAltInfo->rgAltEntry)
    {
	for (i = 0; i < pAltInfo->cAltEntry; i++)
	{
	    if (NULL != pAltInfo->rgAltEntry[i].pwszURL)
	    {
		LocalFree(pAltInfo->rgAltEntry[i].pwszURL);
	    }
	}
	LocalFree(pAltInfo->rgAltEntry);
    }
    return(hr);
}


HRESULT
pkcsBuildAIA(
    IN DWORD Flags,
    IN CACTX const *pCAContext,
    OUT CRYPT_OBJID_BLOB *pAIA)
{
    HRESULT hr;
    DWORD cAIA;
    DWORD i;
    CSURLTEMPLATE const *pTemplate;
    CSURLTEMPLATE const *pTemplateEnd;
    CERT_AUTHORITY_INFO_ACCESS caio;
    CERT_ACCESS_DESCRIPTION *pcad;

    caio.cAccDescr = 0;
    caio.rgAccDescr = NULL;

    pAIA->pbData = NULL;
    pAIA->cbData = 0;

    cAIA = 0;
    pTemplateEnd = g_paCACertURL;
    if (0 != g_caRevURL)
    {
	pTemplateEnd = &g_paCACertURL[g_caCACertURL];
	for (pTemplate = g_paCACertURL; pTemplate < pTemplateEnd; pTemplate++)
	{
	    if (Flags & pTemplate->Flags)
	    {
		cAIA++;
	    }
	}
    }
    if (0 == cAIA)
    {
	hr = S_FALSE;
	goto error;
    }

    caio.rgAccDescr = (CERT_ACCESS_DESCRIPTION *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cAIA * sizeof(caio.rgAccDescr[0]));
    if (NULL == caio.rgAccDescr)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    CSASSERT(NULL != g_strDomainDN && NULL != g_strConfigDN);
    for (pTemplate = g_paCACertURL; pTemplate < pTemplateEnd; pTemplate++)
    {
	if (Flags & pTemplate->Flags)
	{
	    pcad = &caio.rgAccDescr[caio.cAccDescr];

	    pcad->pszAccessMethod = (CSURL_ADDTOCERTOCSP & pTemplate->Flags)?
		szOID_PKIX_OCSP : szOID_PKIX_CA_ISSUERS;
	    pcad->AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;

	    hr = myFormatCertsrvStringArray(
		    TRUE,			// fURL
		    g_pwszServerName,		// pwszServerName_p1_2
		    g_wszSanitizedName,		// pwszSanitizedName_p3_7
		    pCAContext->iCert,		// iCert_p4
		    MAXDWORD,			// iCertTarget_p4
		    g_strDomainDN,		// pwszDomainDN_p5
		    g_strConfigDN,		// pwszConfigDN_p6
		    pCAContext->iKey,		// iCRL_p8
		    FALSE,			// fDeltaCRL_p9
		    TRUE,			// fDSAttrib_p10_11
		    1,				// cStrings
		    (LPCWSTR *) &pTemplate->pwszURL, // apwszStringsIn
		    &pcad->AccessLocation.pwszURL);  // apwszStringsOut

	    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

	    caio.cAccDescr++;
	}
    }
    CSASSERT(caio.cAccDescr == cAIA);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_INFO_ACCESS,
		    &caio,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pAIA->pbData,
		    &pAIA->cbData))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != caio.rgAccDescr)
    {
	for (i = 0; i < caio.cAccDescr; i++)
	{
	    pcad = &caio.rgAccDescr[i];
	    if (NULL != pcad->AccessLocation.pwszURL)
	    {
		LocalFree(pcad->AccessLocation.pwszURL);
	    }
	}
	LocalFree(caio.rgAccDescr);
    }
    return(hr);
}


HRESULT
PKCSSetServerProperties(
    IN ICertDBRow *prow,
    OPTIONAL IN CACTX *pCAContext,	// signing CACTX
    OPTIONAL IN FILETIME const *pftNotBefore,
    OPTIONAL IN FILETIME const *pftNotAfter,
    IN LONG lValidityPeriodCount,
    IN enum ENUM_PERIOD enumValidityPeriod)
{
    HRESULT hr;
    CRYPT_OBJID_BLOB aBlob[3];
    CRYPT_OBJID_BLOB *pBlob;
    DWORD i;

    ZeroMemory(aBlob, sizeof(aBlob));
    if (NULL == pCAContext)
    {
	pCAContext = g_pCAContextCurrent;
    }
    hr = pkcsBuildKeyAuthority2(g_CRLEditFlags, pCAContext, &aBlob[0]);
    _JumpIfError(hr, error, "pkcsBuildKeyAuthority2");

    hr = pkcsSetServerExtension(
			prow,
			TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
			aBlob[0].cbData,
			aBlob[0].pbData);
    _JumpIfError(hr, error, "pkcsSetServerExtension");

    pBlob = &pCAContext->CDPCert;
    if (pCAContext != g_pCAContextCurrent)
    {
	hr = pkcsBuildCDP(
		    CSURL_ADDTOCERTCDP,
		    FALSE,		// fDelta
		    pCAContext,
		    &aBlob[1]);
	_JumpIfError(hr, error, "pkcsBuildCDP");

	pBlob = &aBlob[1];
    }
    hr = pkcsSetServerExtension(
			prow,
			TEXT(szOID_CRL_DIST_POINTS),
			pBlob->cbData,
			pBlob->pbData);
    _JumpIfError(hr, error, "pkcsSetServerExtension");

    pBlob = &pCAContext->AIACert;
    if (pCAContext != g_pCAContextCurrent)
    {
	hr = pkcsBuildAIA(
		    CSURL_ADDTOCERTCDP | CSURL_ADDTOCERTOCSP,
		    pCAContext,
		    &aBlob[2]);
	_JumpIfError(hr, error, "pkcsBuildAIA");

	pBlob = &aBlob[2];
    }
    hr = pkcsSetServerExtension(
			prow,
			TEXT(szOID_AUTHORITY_INFO_ACCESS),
			pBlob->cbData,
			pBlob->pbData);
    _JumpIfError(hr, error, "pkcsSetServerExtension");

    hr = pkcsSetValidityPeriod(
			prow,
			pCAContext,
			pftNotBefore,
			pftNotAfter,
			lValidityPeriodCount,
			enumValidityPeriod);
    _JumpIfError(hr, error, "pkcsSetValidityPeriod");

error:
    for (i = 0; i < ARRAYSIZE(aBlob); i++)
    {
	if (NULL != aBlob[i].pbData)
	{
	    LocalFree(aBlob[i].pbData);
	}
    }
    return(hr);
}


// Find the newest cert with the matching key container name:

HRESULT
pkcsFindMatchingKeyContext(
    OPTIONAL IN CERT_PUBLIC_KEY_INFO *pPublicKeyInfo,
    IN DWORD iKey,
    OUT CACTX **ppCAContext)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    DWORD i;
    CACTX *pCAContext;

    *ppCAContext = NULL;
    for (i = g_cCACerts; i > 0; i--)
    {
	pCAContext = &g_aCAContext[i - 1];

	if ((MAXDWORD != iKey && iKey == pCAContext->iKey) ||
	    (NULL != pCAContext->pccCA &&
	     NULL != pPublicKeyInfo &&
	     CertComparePublicKeyInfo(
			X509_ASN_ENCODING,
			pPublicKeyInfo,
			&pCAContext->pccCA->pCertInfo->SubjectPublicKeyInfo)))
	{
	    // by design, CertComparePublicKeyInfo doesn't set last error!

	    *ppCAContext = pCAContext;
	    hr = S_OK;
	    break;
	}
    }
    return(hr);
}


HRESULT
pkcsLoadURLTemplates(
    IN WCHAR const *pwszRegName,
    OUT CSURLTEMPLATE **ppaURL,
    OUT DWORD *pcaURL)
{
    HRESULT hr;
    WCHAR *pwszzTemplates = NULL;
    WCHAR *pwsz;
    DWORD cTemplate = 0;
    CSURLTEMPLATE *pTemplate;
    DWORD Flags;
    WCHAR *pwsz2;

    *ppaURL = NULL;
    *pcaURL = 0;

    // get (multiple) path templates

    hr = myGetCertRegMultiStrValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    pwszRegName,
			    &pwszzTemplates);
    _JumpIfError(hr, error, "myGetCertRegStrValue");

    for (pwsz = pwszzTemplates; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	Flags = _wtoi(pwsz);
	pwsz2 = pwsz;
	while (iswdigit(*pwsz2))
	{
	    pwsz2++;
	}
	if (0 != Flags && pwsz2 > pwsz && L':' == *pwsz2)
	{
	    cTemplate++;
	}
    }
    if (0 != cTemplate)
    {
	*ppaURL = (CSURLTEMPLATE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cTemplate * sizeof((*ppaURL)[0]));
	if (NULL == *ppaURL)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pTemplate = *ppaURL;
	*pcaURL = cTemplate;

	for (pwsz = pwszzTemplates; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    Flags = _wtoi(pwsz);
	    pwsz2 = pwsz;
	    while (iswdigit(*pwsz2))
	    {
		pwsz2++;
	    }
	    if (0 != Flags && pwsz2 > pwsz && L':' == *pwsz2)
	    {
		pTemplate->Flags = Flags;

		hr = myDupString(&pwsz2[1], &pTemplate->pwszURL);
		_JumpIfError(hr, error, "myDupString");

		pTemplate++;
	    }
	}
	CSASSERT(pTemplate == &(*ppaURL)[*pcaURL]);
    }

error:
    if (NULL != pwszzTemplates)
    {
	LocalFree(pwszzTemplates);
    }
    return(hr);
}


VOID
pkcsFreeTemplates(
    IN OUT CSURLTEMPLATE **ppaURL,
    IN OUT DWORD *pcaURL)
{
    CSURLTEMPLATE *pTemplate;
    CSURLTEMPLATE *pTemplateEnd;

    if (0 != *pcaURL && NULL != *ppaURL)
    {
	pTemplateEnd = &(*ppaURL)[*pcaURL];
	for (pTemplate = *ppaURL; pTemplate < pTemplateEnd; pTemplate++)
	{
	    if (NULL != pTemplate->pwszURL)
	    {
		LocalFree(pTemplate->pwszURL);
	    }
	}
	LocalFree(*ppaURL);
	*ppaURL = NULL;
    }
}


HRESULT
pkcsGetCertFilename(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCertTarget,
    OUT WCHAR **ppwszCertFile)
{
    HRESULT hr;
    WCHAR wszBuf[MAX_PATH];
    WCHAR *pwszIndexedName = NULL;
    DWORD cwc;

    *ppwszCertFile = NULL;

    hr = myAllocIndexedName(
			pwszSanitizedName,
			iCert,
			iCertTarget,
			&pwszIndexedName);
    _JumpIfError(hr, error, "myAllocIndexedName");

    cwc = GetEnvironmentVariable(L"SystemRoot", wszBuf, ARRAYSIZE(wszBuf));
    if (0 == cwc)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "GetEnvironmentVariable");
    }
    if (ARRAYSIZE(wszBuf) < cwc)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "%SystemRoot%");
    }
    cwc = wcslen(wszBuf) +
	    WSZARRAYSIZE(L"\\System32\\" wszCERTENROLLSHAREPATH L"\\") +
	    wcslen(g_pwszServerName) +
	    WSZARRAYSIZE(L"_") +
	    wcslen(pwszIndexedName) +
	    WSZARRAYSIZE(L".crt") +
	    1;

    *ppwszCertFile = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == *ppwszCertFile)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(*ppwszCertFile, wszBuf);
    wcscat(*ppwszCertFile, L"\\System32\\" wszCERTENROLLSHAREPATH L"\\");
    wcscat(*ppwszCertFile, g_pwszServerName);
    wcscat(*ppwszCertFile, L"_");
    wcscat(*ppwszCertFile, pwszIndexedName);
    wcscat(*ppwszCertFile, L".crt");
    CSASSERT(1 + wcslen(*ppwszCertFile) == cwc);

error:
    if (NULL != pwszIndexedName)
    {
	LocalFree(pwszIndexedName);
    }
    return(hr);
}


HRESULT
pkcsReloadMissingCertByHash(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD dwRegHashChoice,
    IN BYTE const *pbHashReg,
    IN DWORD cbHashReg,
    IN DWORD iHash,
    IN WCHAR const *pwszStoreName)
{
    HRESULT hr;
    DWORD cbHash;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    BSTR strHash = NULL;
    ICertDBRow *prow = NULL;
    DWORD cbCert;
    BYTE *pbCert = NULL;
    WCHAR *pwszCertFile = NULL;
    CERT_CONTEXT const *pcc = NULL;
    HCERTSTORE hStore = NULL;

    hr = MultiByteIntegerToBstr(TRUE, cbHashReg, pbHashReg, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    DBGPRINT((
	    DBG_SS_CERTSRV,
	    "Reloading %wsContext[%u]\n    %ws\n",
	    CSRH_CASIGCERT == dwRegHashChoice? L"CA" : L"KRA",
	    iHash,
	    strHash));

    hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY |
			    PROPOPEN_CERTHASH |
			    PROPTABLE_REQCERT,
			0,
			strHash,
			&prow);
    _PrintIfErrorStr(hr, "OpenRow", strHash);
    if (S_OK == hr)
    {
	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRawCertificate,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbCert,
		    (BYTE **) &pbCert);
	_JumpIfError(hr, error, "PKCSGetProperty(cert)");
    }
    else if (CSRH_CASIGCERT != dwRegHashChoice)
    {
	_JumpError(hr, error, "OpenRow");
    }
    else
    {
	hr = pkcsGetCertFilename(
			pwszSanitizedName,
			iHash,
			MAXDWORD,	// iCertTarget
			&pwszCertFile);
	_JumpIfError(hr, error, "myGetCertFilename");

	hr = DecodeFileW(pwszCertFile, &pbCert, &cbCert, CRYPT_STRING_ANY);
	_JumpIfError(hr, error, "DecodeFileW");
    }

    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pcc,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    if (cbHash != cbHashReg || 0 != memcmp(abHash, pbHashReg, cbHash))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "wrong Cert");
    }

    hStore = CertOpenStore(
		    CERT_STORE_PROV_SYSTEM_REGISTRY_W,
		    X509_ASN_ENCODING,
		    NULL,			// hProv
		    CERT_SYSTEM_STORE_LOCAL_MACHINE,
		    pwszStoreName);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CertOpenStore", pwszStoreName);
    }
    if (!CertAddCertificateContextToStore(
			    hStore,
			    pcc,
			    CERT_STORE_ADD_USE_EXISTING,
			    NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }

    // Add as encoded blob to avoid all properties, key prov info, etc.

    if (!CertAddEncodedCertificateToStore(
			hStore,
			X509_ASN_ENCODING,
			pbCert,
			cbCert,
			CERT_STORE_ADD_REPLACE_EXISTING,
			NULL))			// ppCertContext
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }
    DBGPRINT((
	DBG_SS_CERTSRV,
	"Reloaded %wsContext[%u]\n",
	CSRH_CASIGCERT == dwRegHashChoice? L"CA" : L"KRA",
	iHash));
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pwszCertFile)
    {
	LocalFree(pwszCertFile);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
pkcsReloadMissingCAOrKRACert(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD dwRegHashChoice,
    IN DWORD iHash,
    IN WCHAR const *pwszStoreName)
{
    HRESULT hr;
    BYTE *pbHashReg = NULL;
    DWORD cbHashReg;

    hr = myGetCARegHash(
		    pwszSanitizedName,
		    dwRegHashChoice,
		    iHash,
		    &pbHashReg,
		    &cbHashReg);
    _JumpIfError(hr, error, "myGetCARegHash");

    hr = pkcsReloadMissingCertByHash(
		    pwszSanitizedName,
		    dwRegHashChoice,
		    pbHashReg,
		    cbHashReg,
		    iHash,
		    pwszStoreName);
    _JumpIfError(hr, error, "pkcsReloadMissingCertByHash");

error:
    if (NULL != pbHashReg)
    {
	LocalFree(pbHashReg);
    }
    return(hr);
}


VOID
pkcsFreeBlobArray(
    IN DWORD cBlob,
    CERT_BLOB *rgBlob)
{
    DWORD i;

    for (i = 0; i < cBlob; i++)
    {
	if (NULL != rgBlob[i].pbData)
	{
	    LocalFree(rgBlob[i].pbData);
	}
    }
    LocalFree(rgBlob);
}


HRESULT
pkcsGetKRACertBlobs(
    IN ICertDBRow *prow,
    OUT DWORD *pcCertBlob,
    OUT CERT_BLOB **prgCertBlob)
{
    HRESULT hr;
    WCHAR *pwszHashes = NULL;
    WCHAR *pwsz;
    DWORD cb;
    DWORD cHash;
    DWORD i;
    CERT_BLOB *rgBlob = NULL;
    HCERTSTORE hStore = NULL;
    CRYPT_DATA_BLOB HashBlob;
    DWORD cBlobLoaded;
    CERT_CONTEXT const *pcc = NULL;

    HashBlob.pbData = NULL;
    cBlobLoaded = 0;

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequestKeyRecoveryHashes,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cb,
		(BYTE **) &pwszHashes);
    _JumpIfError(hr, error, "PKCSGetProperty(KRA hashes)");

    cHash = 1;
    pwsz = pwszHashes;
    for (;;)
    {
	pwsz = wcschr(pwsz, L'\n');
	if (NULL == pwsz)
	{
	    break;
	}
	*pwsz++ = L'\0';
	cHash++;
    }
    rgBlob = (CERT_BLOB *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cHash * sizeof(rgBlob[0]));
    if (NULL == rgBlob)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // open KRA store

    hStore = CertOpenStore(
		    CERT_STORE_PROV_SYSTEM_W,
		    X509_ASN_ENCODING,
		    NULL,			// hProv
		    CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
		    wszKRA_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    pwsz = pwszHashes;
    for (i = 0; i < cHash; i++)
    {
	BOOL fReloaded;

	hr = WszToMultiByteInteger(
				TRUE,
				pwsz,
				&HashBlob.cbData,
				&HashBlob.pbData);
	_JumpIfError(hr, error, "WszToMultiByteInteger");

	fReloaded = FALSE;
	for (;;)
	{
	    pcc = CertFindCertificateInStore(
					hStore,
					X509_ASN_ENCODING,
					0,
					CERT_FIND_HASH,
					&HashBlob,
					NULL);
	    if (fReloaded || NULL != pcc)
	    {
		break;
	    }
	    hr = pkcsReloadMissingCertByHash(
					g_wszSanitizedName,
					CSRH_CAKRACERT,
					HashBlob.pbData,
					HashBlob.cbData,
					i,
					wszKRA_CERTSTORE);
	    _PrintIfError(hr, "pkcsReloadMissingCertByHash");

	    CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
	    hStore = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM_W,
			    X509_ASN_ENCODING,
			    NULL,			// hProv
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
				CERT_STORE_READONLY_FLAG,
			    wszKRA_CERTSTORE);
	    if (NULL == hStore)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertOpenStore");
	    }
	    fReloaded = TRUE;
	}
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _PrintError(hr, "CertFindCertificateInStore");
	}
	else
	{
	    rgBlob[cBlobLoaded].pbData = (BYTE *) LocalAlloc(
							LMEM_FIXED,
							pcc->cbCertEncoded);
	    if (NULL == rgBlob[cBlobLoaded].pbData)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    rgBlob[cBlobLoaded].cbData = pcc->cbCertEncoded;
	    CopyMemory(
		    rgBlob[cBlobLoaded].pbData,
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded);
	    cBlobLoaded++;

	    CertFreeCertificateContext(pcc);
	    pcc = NULL;
	}
	pwsz += wcslen(pwsz) + 1;
	LocalFree(HashBlob.pbData);
	HashBlob.pbData = NULL;
    }
    *pcCertBlob = cBlobLoaded;
    *prgCertBlob = rgBlob;
    rgBlob = NULL;

error:
    if (NULL != rgBlob)
    {
	pkcsFreeBlobArray(cBlobLoaded, rgBlob);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != HashBlob.pbData)
    {
	LocalFree(HashBlob.pbData);
    }
    if (NULL != pwszHashes)
    {
	LocalFree(pwszHashes);
    }
    return(hr);
}


HRESULT
pkcsGetHashAsOctet(
    IN ICertDBRow *prow,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    WCHAR *pwszHash = NULL;
    DWORD cb;
    CRYPT_DATA_BLOB Blob;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    BYTE *pbCert = NULL;
    DWORD cbCert;
    CERT_CONTEXT const *pcc = NULL;

    *ppbData = NULL;
    Blob.pbData = NULL;

    hr = PKCSGetProperty(
		prow,
		g_wszPropCertificateHash,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cb,
		(BYTE **) &pwszHash);
    if (S_OK != hr)
    {
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _JumpError(hr, error, "PKCSGetProperty(hash)");
	}
	hr = PKCSGetProperty(
		    prow,
		    g_wszPropRawCertificate,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    &cbCert,
		    &pbCert);
	_JumpIfError(hr, error, "PKCSGetProperty(cert)");

	pcc = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pbCert,
					cbCert);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
	Blob.cbData = sizeof(abHash);
	if (!CertGetCertificateContextProperty(
				    pcc,
				    CERT_SHA1_HASH_PROP_ID,
				    abHash,
				    &Blob.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}
	Blob.pbData = abHash;
    }
    else
    {
	hr = WszToMultiByteInteger(TRUE, pwszHash, &Blob.cbData, &Blob.pbData);
	_JumpIfError(hr, error, "WszToMultiByteInteger");
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &Blob,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbData,
		    pcbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pwszHash)
    {
	LocalFree(pwszHash);
    }
    if (NULL != Blob.pbData && abHash != Blob.pbData)
    {
	LocalFree(Blob.pbData);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


VOID
AddCertBlobToArray(
    IN CERT_CONTEXT const *pcc,
    IN CERT_BLOB *rgCertBlobAll,
    IN CERT_BLOB **ppCertBlob)
{
    CERT_BLOB *pCertBlob = *ppCertBlob;
    DWORD i;
    DWORD cBlob;

    cBlob = SAFE_SUBTRACT_POINTERS(pCertBlob, rgCertBlobAll);
    for (i = 0; i < cBlob; i++)
    {
	if (rgCertBlobAll[i].cbData == pcc->cbCertEncoded &&
	    0 == memcmp(
		    rgCertBlobAll[i].pbData,
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded))
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"Duplicate Recovery Blob Cert[%u]\n",
		i));
	    goto error;
	}
    }
    DBGPRINT((
	DBG_SS_CERTSRV,
	"Adding Recovery Blob Cert[%u]\n",
	cBlob));
    pCertBlob->cbData = pcc->cbCertEncoded;
    pCertBlob->pbData = pcc->pbCertEncoded;
    pCertBlob++;

    *ppCertBlob = pCertBlob;

error:
    ;
}


HRESULT
PKCSGetArchivedKey(
    IN DWORD dwRequestId,
    OUT BYTE **ppbArchivedKey,	// CoTaskMem*
    OUT DWORD *pcbArchivedKey)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    BYTE *pbCertUser = NULL;
    DWORD cbCertUser;
    HCRYPTMSG hMsg = NULL;
    CACTX *pCAContext;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CERT_CONTEXT const *pccUser = NULL;
    CERT_CHAIN_CONTEXT const *pCertChainContextUser = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CERT_BLOB *rgCertBlobKRA = NULL;
    DWORD cCertBlobKRA;
    CERT_BLOB *rgCertBlobAll = NULL;
    DWORD cCertBlobAll;
    CERT_BLOB *pCertBlob;
    CRYPT_ATTRIBUTE HashAttrib;
    CRYPT_ATTR_BLOB HashAttribBlob;
    DWORD i;

    *ppbArchivedKey = NULL;
    HashAttribBlob.pbData = NULL;
    cCertBlobKRA = 0;

    hr = g_pCertDB->OpenRow(
			PROPOPEN_READONLY | PROPTABLE_REQCERT,
			dwRequestId,
			NULL,
			&prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequestRawArchivedKey,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cbKey,
		&pbKey);
    _JumpIfError(hr, error, "PKCSGetProperty(key)");

    hr = pkcsGetKRACertBlobs(prow, &cCertBlobKRA, &rgCertBlobKRA);
    _JumpIfError(hr, error, "pkcsGetKRACertBlobs");

    hr = pkcsGetHashAsOctet(
		    prow,
		    &HashAttribBlob.pbData,
		    &HashAttribBlob.cbData);
    _JumpIfError(hr, error, "pkcsGetHashAsOctet");

    HashAttrib.pszObjId = szOID_ARCHIVED_KEY_CERT_HASH;
    HashAttrib.cValue = 1;
    HashAttrib.rgValue = &HashAttribBlob;

    hr = PKCSGetProperty(
		prow,
		g_wszPropRawCertificate,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbCertUser,
		&pbCertUser);
    _JumpIfError(hr, error, "PKCSGetProperty(cert)");

    pccUser = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    pbCertUser,
				    cbCertUser);
    if (NULL == pccUser)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    // build the user cert chain

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,
			    pccUser,
			    NULL,
			    NULL,
			    &CertChainPara,
			    0,
			    NULL,
			    &pCertChainContextUser))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateChain");
    }

    // make sure there is at least 1 simple chain

    if (0 == pCertChainContextUser->cChain)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "No user chain");
    }

    // Encode the encrypted key into a PKCS 7, signed by the current CA cert.
    // Initialize the CMSG_SIGNER_ENCODE_INFO structure for one signer.

    pCAContext = g_pCAContextCurrent;
    cCertBlobAll = cCertBlobKRA +
		   pCAContext->cCACertChain +
		   pCertChainContextUser->rgpChain[0]->cElement;

    rgCertBlobAll = (CERT_BLOB *) LocalAlloc(
				    LMEM_FIXED,
				    cCertBlobAll * sizeof(rgCertBlobAll[0]));
    if (NULL == rgCertBlobAll)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pCertBlob = rgCertBlobAll;

    CopyMemory(pCertBlob, rgCertBlobKRA, cCertBlobKRA * sizeof(pCertBlob[0]));
    pCertBlob += cCertBlobKRA;

    // Add the current CA cert chain

    for (i = 0; i < pCAContext->cCACertChain; i++)
    {
	AddCertBlobToArray(
		    pCAContext->apCACertChain[i],
		    rgCertBlobAll,
		    &pCertBlob);
    }

    // Add the user cert chain

    {
	CERT_SIMPLE_CHAIN *pSimpleChain;

	pSimpleChain = pCertChainContextUser->rgpChain[0];
	for (i = 0; i < pSimpleChain->cElement; i++)
	{
	    AddCertBlobToArray(
			pSimpleChain->rgpElement[i]->pCertContext,
			rgCertBlobAll,
			&pCertBlob);
	}
    }
    CSASSERT(pCertBlob <= &rgCertBlobAll[cCertBlobAll]);
    DBGPRINT((
	DBG_SS_CERTSRV,
	"Recovery Certs: %u --> %u\n",
	cCertBlobAll,
	SAFE_SUBTRACT_POINTERS(pCertBlob, rgCertBlobAll)));
    cCertBlobAll = SAFE_SUBTRACT_POINTERS(pCertBlob, rgCertBlobAll);

    ZeroMemory(&SignerEncodeInfo, sizeof(SignerEncodeInfo));
    SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);
    SignerEncodeInfo.pCertInfo = pCAContext->pccCA->pCertInfo;
    SignerEncodeInfo.hCryptProv = pCAContext->hProvCA;
    SignerEncodeInfo.dwKeySpec = AT_SIGNATURE;
    SignerEncodeInfo.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    SignerEncodeInfo.cAuthAttr = 1;
    SignerEncodeInfo.rgAuthAttr = &HashAttrib;
    //SignerEncodeInfo.cUnauthAttr = 0;
    //SignerEncodeInfo.rgUnauthAttr = NULL;
    //SignerEncodeInfo.HashEncryptionAlgorithm.pszObjId = ???;

    // CERT_ID_SHA1_HASH is not yet implemented in CryptMsgOpenToEncode
    //SignerEncodeInfo.SignerId.dwIdChoice = CERT_ID_SHA1_HASH;
    //SignerEncodeInfo.SignerId.HashId.cbData = cb;
    //SignerEncodeInfo.SignerId.HashId.pbData = abHash;

    ZeroMemory(&SignedMsgEncodeInfo, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.cSigners = 1;
    SignedMsgEncodeInfo.rgSigners = &SignerEncodeInfo;
    SignedMsgEncodeInfo.cCertEncoded = cCertBlobAll;
    SignedMsgEncodeInfo.rgCertEncoded = rgCertBlobAll;
    //SignedMsgEncodeInfo.cCrlEncoded = 0;
    //SignedMsgEncodeInfo.rgCrlEncoded = NULL;

    hMsg = CryptMsgOpenToEncode(
			    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			    0,				// dwFlags
			    CMSG_SIGNED,		// dwMsgType
			    &SignedMsgEncodeInfo,	// pvMsgEncodeInfo
			    NULL,			// pszInnerContentObjID
			    NULL);			// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToDecode");
    }

    if (!CryptMsgUpdate(hMsg, pbKey, cbKey, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    // Return the encoded and signed content.
    // Use CMSG_CONTENT_PARAM to get the signed message.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_CONTENT_PARAM,
		    0,
		    CERTLIB_USE_COTASKMEMALLOC,
		    (VOID **) ppbArchivedKey,
		    pcbArchivedKey);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

error:
    if (pCertChainContextUser != NULL)
    {
	CertFreeCertificateChain(pCertChainContextUser);
    }
    if (NULL != pccUser)
    {
	CertFreeCertificateContext(pccUser);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != rgCertBlobKRA)
    {
	pkcsFreeBlobArray(cCertBlobKRA, rgCertBlobKRA);
    }
    if (NULL != rgCertBlobAll)
    {
	LocalFree(rgCertBlobAll);
    }
    if (NULL != HashAttribBlob.pbData)
    {
	LocalFree(HashAttribBlob.pbData);
    }
    if (NULL != pbKey)
    {
	LocalFree(pbKey);
    }
    if (NULL != pbCertUser)
    {
	LocalFree(pbCertUser);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


HRESULT
pkcsGetKeyContainerName(
    IN CERT_CONTEXT const *pccCA,
    OUT WCHAR **ppwszKeyContainerName)
{
    HRESULT hr;
    CRYPT_HASH_BLOB KeyIdentifier;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD cb;

    KeyIdentifier.pbData = NULL;
    *ppwszKeyContainerName = NULL;

    hr = myGetPublicKeyHash(
			pccCA->pCertInfo,
			&pccCA->pCertInfo->SubjectPublicKeyInfo,
			&KeyIdentifier.pbData,
			&KeyIdentifier.cbData);
    _JumpIfError(hr, error, "myGetPublicKeyHash");

    cb = 0;
    for (;;)
    {
	if (!CryptGetKeyIdentifierProperty(
			    &KeyIdentifier,
			    CERT_KEY_PROV_INFO_PROP_ID,
			    CRYPT_KEYID_MACHINE_FLAG,
			    NULL,			// pwszComputerName
			    NULL,			// pvReserved
			    pkpi,
			    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Cert index");
	}
	if (NULL != pkpi)
	{
	    break;
	}
	pkpi = (CRYPT_KEY_PROV_INFO *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pkpi)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = myDupString(pkpi->pwszContainerName, ppwszKeyContainerName);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != KeyIdentifier.pbData)
    {
	LocalFree(KeyIdentifier.pbData);
    }
    return(hr);
}


HRESULT
pkcsLoadCAContext(
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR *pwszProvName,
    IN DWORD dwProvType,
    IN ALG_ID idAlg,
    IN BOOL fMachineKeyset,
    IN DWORD iHash,
    IN OUT HCERTSTORE *phMyStore)
{
    HRESULT hr;
    HCRYPTPROV hProvCA = NULL;
    char *pszObjIdSignatureAlgorithm = NULL;
    WCHAR *pwszKeyContainerName = NULL;
    CERT_CONTEXT const *pccCA = NULL;
    DWORD cCACertChain;
    CERT_CONTEXT const **apCACertChain = NULL;
    CERT_CHAIN_CONTEXT const *pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CRYPT_KEY_PROV_INFO *pKey = NULL;
    CACTX *pCAContext;
    int i;
    DWORD cbKey;
    DWORD iCert;
    DWORD iKey;
    DWORD NameId;
    BOOL fReloaded;

    hr = myGetSigningOID(
		    NULL,	// hProv
		    pwszProvName,
		    dwProvType,
		    idAlg,
		    &pszObjIdSignatureAlgorithm);
    _JumpIfError(hr, error, "myGetSigningOID");

    if (~_16BITMASK & iHash)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Cert index");
    }

    fReloaded = FALSE;
    cCACertChain = 0;
    for (;;)
    {
	hr = myFindCACertByHashIndex(
				*phMyStore,
				pwszSanitizedName,
				CSRH_CASIGCERT,
				iHash,
				&NameId,
				&pccCA);
	iCert = iHash;
	iKey = iCert;
	if (S_OK == hr)
	{
	    break;
	}

	// if no hash entry exists for this index, fake up a CA Context
	// as a place holder.

	if (S_FALSE == hr)
	{
	    CSASSERT(MAXDWORD == NameId);
	    CSASSERT(NULL == pccCA);
	    break;
	}
	if (fReloaded || CRYPT_E_NOT_FOUND != hr)
	{
	    _JumpError(hr, error, "myFindCACertByHashIndex");
	}
	_PrintError(hr, "myFindCACertByHashIndex");

	// The CA cert is missing from the HKLM "my" store -- look it up in
	// the DB or the CertEnroll directory, and put it back in the store.

	hr = pkcsReloadMissingCAOrKRACert(
				pwszSanitizedName,
				CSRH_CASIGCERT,
				iHash,
				wszMY_CERTSTORE);
	_JumpIfError(hr, error, "pkcsReloadMissingCAOrKRACert");

	CertCloseStore(*phMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
	*phMyStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,			// hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE,
			wszMY_CERTSTORE);
	if (NULL == *phMyStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}
	fReloaded = TRUE;
    }

    CSASSERT(S_FALSE == hr || S_OK == hr);
    if (S_OK == hr)
    {
	if (MAXDWORD != NameId && iCert != CANAMEIDTOICERT(NameId))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"NameId=%u.%u iCert=%u\n",
		CANAMEIDTOICERT(NameId),
		CANAMEIDTOIKEY(NameId),
		iCert));
	    _JumpError(hr, error, "bad iCert");
	}

	fReloaded = FALSE;
	for (;;)
	{
	    if (NULL != pwszKeyContainerName)
	    {
		LocalFree(pwszKeyContainerName);
		pwszKeyContainerName = NULL;
	    }
	    if (!fReloaded)
	    {
		// get the private key provider info

		if (!myCertGetCertificateContextProperty(
						pccCA,
						CERT_KEY_PROV_INFO_PROP_ID,
						CERTLIB_USE_LOCALALLOC,
						(VOID **) &pKey,
						&cbKey))
		{
		    hr = myHLastError();
		    if (CRYPT_E_NOT_FOUND != hr)
		    {
			_JumpError(hr, error, "myCertGetCertificateContextProperty");
		    }
		    _PrintError(hr, "CertGetCertificateContextProperty");

		    // The Key Provider Info is missing -- use the sanitized
		    // name and key index to construct the key container name.
		    // If that key matches, we'll write out the new Key
		    // Provider Info below.

		    hr = myAllocIndexedName(
			    pwszSanitizedName,
			    MAXDWORD != NameId? CANAMEIDTOIKEY(NameId) : iCert,
			    MAXDWORD,		// iCertTarget
			    &pwszKeyContainerName);
		    _JumpIfError(hr, error, "myAllocIndexedName");
		}
		else
		{
		    hr = myDupString(pKey->pwszContainerName, &pwszKeyContainerName);
		    _JumpIfError(hr, error, "myDupString");
		}
	    }
	    else
	    {
		hr = pkcsGetKeyContainerName(pccCA, &pwszKeyContainerName);
		_JumpIfError(hr, error, "pkcsGetKeyContainerName");
	    }

	    // test signing

	    hr = myValidateSigningKey(
			    pwszKeyContainerName,
			    pwszProvName,
			    dwProvType,
			    0 != g_CryptSilent,
			    fMachineKeyset,
			    FALSE,	// fForceSignatureTest
			    pccCA,
			    NULL,	// pPublicKeyInfo
			    idAlg,
			    NULL,	// pfSigningTestAttempted
			    NULL);	// phProv
	    if (S_OK == hr)
	    {
		break;
	    }
	    if (fReloaded)
	    {
		_JumpError(hr, error, "myValidateSigningKey");
	    }
	    _PrintError(hr, "myValidateSigningKey");

	    fReloaded = TRUE;
	}

	// If the Key Provider Info is missing, write out new Key Provider Info

	if (NULL == pKey)
	{
	    CRYPT_KEY_PROV_INFO kpi;

	    ZeroMemory(&kpi, sizeof(kpi));
	    kpi.pwszContainerName = pwszKeyContainerName;
	    kpi.pwszProvName = pwszProvName;
	    kpi.dwProvType = dwProvType;
	    kpi.dwFlags = fMachineKeyset? CRYPT_MACHINE_KEYSET : 0;
	    kpi.dwKeySpec = AT_SIGNATURE;

	    if (!CertSetCertificateContextProperty(
					    pccCA,
					    CERT_KEY_PROV_INFO_PROP_ID,
					    0,
					    &kpi))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertSetCertificateContextProperty");
	    }
	    DBGPRINT((
		DBG_SS_CERTSRV,
		"Reloaded CAContext[%u] KeyProvInfo[%u]\n",
		iCert,
		iKey));
	}

	hr = pkcsFindMatchingKeyContext(
			    &pccCA->pCertInfo->SubjectPublicKeyInfo,
			    MAXDWORD,
			    &pCAContext);
	if (S_OK != hr && MAXDWORD != NameId)
	{
	    iKey = CANAMEIDTOIKEY(NameId);
	    if (iKey < iCert)
	    {
		hr = pkcsFindMatchingKeyContext(NULL, iKey, &pCAContext);
		_JumpIfError(hr, error, "pkcsFindMatchingKeyContext");
	    }
	}
	if (S_OK == hr)
	{
	    iKey = pCAContext->iKey;
	    if (MAXDWORD != NameId && iKey != CANAMEIDTOIKEY(NameId))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "bad iKey");
	    }
	    if (NULL == pCAContext->pccCA)
	    {
		CSASSERT(pCAContext->Flags & CTXF_CERTMISSING);
		pCAContext->Flags |= CTXF_CRLZOMBIE;
	    }
	    else
	    {
		// CRLs will be handled by the newest CA cert for this key.
		// Turn off CRLs for older CA certs with this key.
		
		CSASSERT(0 == (pCAContext->Flags & CTXF_CERTMISSING));
		DBGPRINT((
		    DBG_SS_CERTSRVI,
		    "pkcsLoadCAContext(%u) DUPKEY, %u.%u: f=%x->%x\n",
		    iHash,
		    pCAContext->iCert,
		    pCAContext->iKey,
		    pCAContext->Flags,
		    pCAContext->Flags | CTXF_SKIPCRL));
		pCAContext->Flags |= CTXF_SKIPCRL;
	    }
	}
	else
	{
	    g_cCAKeys++;	// this key has not previously been loaded
	}

	DBGPRINT((
	    DBG_SS_CERTSRV,
	    "CAContext[%u]: Key %u: %ws\n",
	    iCert,
	    iKey,
	    pwszKeyContainerName));

	// get private key handler for later use if current CA

	if (!myCertSrvCryptAcquireContext(
				   &hProvCA,
				   pwszKeyContainerName,
				   pwszProvName,
				   dwProvType,
				   g_CryptSilent,
				   fMachineKeyset))
	{
	    hr = myHLastError();
	    _JumpErrorStr(
			hr,
			error,
			"myCertSrvCryptAcquireContext",
			pwszKeyContainerName);
	}

	// now try to figure out the chain

	ZeroMemory(&CertChainPara, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(
				HCCE_LOCAL_MACHINE,
				pccCA,
				NULL,
				NULL,
				&CertChainPara,
				0,
				NULL,
				&pCertChainContext))
	{
	    hr = myHLastError();
	    goto error;
	}

	// make sure there is at least 1 simple chain

	if (pCertChainContext->cChain == 0)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "No valid trust chain could be formed");
	}

	// tell global how many elements we have in our chain

	cCACertChain = pCertChainContext->rgpChain[0]->cElement;

	// Allocate memory for global.  Allocate one extra pointer to allow loop
	// to assign NULL pointer in place in array.  Leave the count set to the
	// actual number of CA cert contexts, excluding the NULL pointer.

	apCACertChain = (CERT_CONTEXT const **) LocalAlloc(
				    LMEM_FIXED,
				    (cCACertChain + 1) * sizeof(apCACertChain[0]));
	if (NULL == apCACertChain)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	// copy chain in reverse order: from parent to child

	for (i = cCACertChain - 1; i >= 0; i--)
	{
	    apCACertChain[i] = CertDuplicateCertificateContext(
		pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext);

	    if (NULL == apCACertChain[i])
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertDuplicateCertificateContext");
	    }
	}
    }

    for (i = 0; i < (int) g_cCACerts; i++)
    {
	if (iCert < g_aCAContext[i].iCert)
	{
	    MoveMemory(
		    &g_aCAContext[i + 1],
		    &g_aCAContext[i],
		    (g_cCACerts - i) * sizeof(g_aCAContext[0]));
	    break;
	}
    }
    g_cCACerts++;

    pCAContext = &g_aCAContext[i];
    ZeroMemory(pCAContext, sizeof(*pCAContext));

    if (NULL == pccCA)
    {
	pCAContext->Flags |= CTXF_CERTMISSING | CTXF_SKIPCRL;
    }
    pCAContext->iCert = iCert;
    pCAContext->iKey = iKey;
    pCAContext->NameId = MAKECANAMEID(iCert, iKey);

    pCAContext->hProvCA = hProvCA;
    hProvCA = NULL;

    pCAContext->pccCA = pccCA;
    pccCA = NULL;

    if (NULL != apCACertChain)
    {
	pCAContext->cCACertChain = cCACertChain;
	pCAContext->apCACertChain = apCACertChain;
	apCACertChain = NULL;
    }

    pCAContext->pszObjIdSignatureAlgorithm = pszObjIdSignatureAlgorithm;
    pszObjIdSignatureAlgorithm = NULL;

    pCAContext->pwszKeyContainerName = pwszKeyContainerName;
    pwszKeyContainerName = NULL;


    // Ignore failure from here on -- collected data is optional

    if (NULL != pCAContext->pccCA)
    {
	hr = myGetPublicKeyHash(
			pCAContext->pccCA->pCertInfo,
			&pCAContext->pccCA->pCertInfo->SubjectPublicKeyInfo,
			&pCAContext->IssuerKeyId.pbData,
			&pCAContext->IssuerKeyId.cbData);
	_PrintIfError(hr, "myGetPublicKeyHash");

	if (0 == (CTXF_SKIPCRL & pCAContext->Flags))
	{
	    hr = pkcsBuildKeyAuthority2(
				g_CRLEditFlags,
				pCAContext,
				&pCAContext->KeyAuthority2CRL);
	    _PrintIfError(hr, "pkcsBuildKeyAuthority2");

	    hr = pkcsBuildCDP(
			CSURL_ADDTOFRESHESTCRL,
			TRUE,		// fDelta
			pCAContext,
			&pCAContext->CDPCRLFreshest);
	    _PrintIfError(hr, "pkcsBuildCDP");

	    hr = pkcsBuildCDP(
			CSURL_ADDTOCRLCDP,
			FALSE,		// fDelta
			pCAContext,
			&pCAContext->CDPCRLBase);
	    _PrintIfError(hr, "pkcsBuildCDP");

	    hr = pkcsBuildCDP(
			CSURL_ADDTOCRLCDP,
			TRUE,		// fDelta
			pCAContext,
			&pCAContext->CDPCRLDelta);
	    _PrintIfError(hr, "pkcsBuildCDP");

	    hr = pkcsBuildCRLList(
				FALSE,
				pCAContext,
				&pCAContext->papwszCRLFiles);
	    _JumpIfError(hr, error, "pkcsBuildCRLList");

	    hr = pkcsBuildCRLList(
				TRUE,
				pCAContext,
				&pCAContext->papwszDeltaCRLFiles);
	    _JumpIfError(hr, error, "pkcsBuildCRLList");
	}
    }
    hr = S_OK;

error:
    if (NULL != hProvCA)
    {
	CryptReleaseContext(hProvCA, 0);
    }
    if (NULL != pszObjIdSignatureAlgorithm)
    {
	LocalFree(pszObjIdSignatureAlgorithm);
    }
    if (NULL != pwszKeyContainerName)
    {
	LocalFree(pwszKeyContainerName);
    }
    if (NULL != pKey)
    {
	LocalFree(pKey);
    }
    if (pCertChainContext != NULL)
    {
	CertFreeCertificateChain(pCertChainContext);
    }
    if (NULL != pccCA)
    {
	CertFreeCertificateContext(pccCA);
    }
    return(hr);
}


HRESULT
pkcsLoadCAContextArray(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    DWORD cCACerts;
    HCERTSTORE hMyStore = NULL;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;
    ALG_ID idAlg;
    BOOL fMachineKeyset;
    DWORD iHash;

    // get provider name

    hr = myGetCertSrvCSP(
		    FALSE,	// fEncryptionCSP
		    pwszSanitizedName,
		    &dwProvType,
		    &pwszProvName,
		    &idAlg,
		    &fMachineKeyset,
		    NULL);	// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    // open MY store

    hMyStore = CertOpenStore(
		    CERT_STORE_PROV_SYSTEM_W,
		    X509_ASN_ENCODING,
		    NULL,			// hProv
		    CERT_SYSTEM_STORE_LOCAL_MACHINE,
		    wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    // find & load CA certs, etc.

    hr = myGetCARegHashCount(pwszSanitizedName, CSRH_CASIGCERT, &cCACerts);
    if (S_OK == hr && 0 == cCACerts)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    _JumpIfError(hr, error, "myGetCARegHashCount");

    g_aCAContext = (CACTX *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cCACerts * sizeof(g_aCAContext[0]));
    if (NULL == g_aCAContext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    for (iHash = 0; iHash < cCACerts; iHash++)
    {
	hr = pkcsLoadCAContext(
			pwszSanitizedName,
			pwszProvName,
			dwProvType,
			idAlg,
			fMachineKeyset,
			iHash,
			&hMyStore);
	if (S_FALSE == hr)
	{
	    continue;
	}
	_JumpIfError(hr, error, "pkcsLoadCAContext");
    }

    g_pCAContextCurrent = &g_aCAContext[g_cCACerts - 1];

    // Only build a Key Authority extension for the current CACTX -- it's the
    // only one used to issue certs.

    hr = pkcsBuildKeyAuthority2(
			EDITF_ENABLEAKIKEYID |
			    EDITF_ENABLEAKIISSUERNAME |
			    EDITF_ENABLEAKIISSUERSERIAL,
			g_pCAContextCurrent,
			&g_pCAContextCurrent->KeyAuthority2Cert);
    _PrintIfError(hr, "pkcsBuildKeyAuthority2");

    // Only build a CDP extension for the current CACTX -- it's the
    // only one used to issue certs.

    hr = pkcsBuildCDP(
		CSURL_ADDTOCERTCDP,
		FALSE,		// fDelta
		g_pCAContextCurrent,
		&g_pCAContextCurrent->CDPCert);
    _PrintIfError(hr, "pkcsBuildCDP");

    // Only build an AIA extension for the current CACTX -- it's the
    // only one used to issue certs.

    hr = pkcsBuildAIA(
		CSURL_ADDTOCERTCDP | CSURL_ADDTOCERTOCSP,
		g_pCAContextCurrent,
		&g_pCAContextCurrent->AIACert);
    _PrintIfError(hr, "pkcsBuildAIA");

    hr = S_OK;

error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    if (NULL != hMyStore)
    {
	CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


BOOL
pkcsCompareBlob(
    IN CERT_BLOB const *pBlob1,
    IN CERT_BLOB const *pBlob2)
{
    return(
	pBlob1->cbData == pBlob2->cbData &&
	0 == memcmp(pBlob1->pbData, pBlob2->pbData, pBlob1->cbData));
}


HRESULT
pkcsAddInheritedExtension(
    IN ICertDBRow *prow,
    IN char const *pszObjId,
    OPTIONAL IN CACTX const *pCAContext,
    OPTIONAL IN CACTX const *pCAContextTarget,
    OUT BOOL *pfAdded)
{
    HRESULT hr;
    CERT_EXTENSION const *pExt;
    CERT_EXTENSION const *pExtTarget;
    WCHAR *pwszObjId = NULL;

    *pfAdded = FALSE;
    if (NULL == pCAContext)
    {
	pCAContext = g_pCAContextCurrent;
    }
    pExt = CertFindExtension(
		pszObjId,
		pCAContext->pccCA->pCertInfo->cExtension,
		pCAContext->pccCA->pCertInfo->rgExtension);
    if (NULL != pCAContextTarget)
    {
	pExtTarget = CertFindExtension(
			pszObjId,
			pCAContextTarget->pccCA->pCertInfo->cExtension,
			pCAContextTarget->pccCA->pCertInfo->rgExtension);
	if ((NULL != pExt) ^ (NULL != pExtTarget))
	{
	    hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
	    _JumpError(hr, error, "target/source ext inconsistent");
	}
	if (NULL != pExt && !pkcsCompareBlob(&pExt->Value, &pExtTarget->Value))
	{
	    hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
	    _JumpError(hr, error, "target/source ext inconsistent");
	}
    }
    if (NULL != pExt)
    {
	if (!myConvertSzToWsz(&pwszObjId, pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz(ObjId)");
	}
	hr = PropSetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_SERVER,
			pwszObjId,
			EXTENSION_ORIGIN_CACERT,	// ExtFlags
			pExt->Value.cbData,
			pExt->Value.pbData);
	_JumpIfError(hr, error, "PropSetExtension");

	*pfAdded = TRUE;
    }
    hr = S_OK;

error:
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsAddCannedCertExtensions(
    IN ICertDBRow *prow,
    IN DWORD Flags,
    OPTIONAL IN CACTX const *pCAContext,
    OPTIONAL IN CACTX const *pCAContextTarget,
    OUT char const **ppszObjIdExtError)
{
    HRESULT hr;
    CERT_EXTENSION aExt[5];
    WCHAR const *apwszObjId[ARRAYSIZE(aExt)];
    DWORD cExt = 0;
    DWORD i;
    BOOL fExtAdded;
    char const *pszObjId = NULL;
    static char *s_apszObjIdXchg[] =
    {
	szOID_KP_CA_EXCHANGE,
    };
    static char *s_apszObjIdAll[] =
    {
	szOID_ANY_CERT_POLICY,
    };

    ZeroMemory(aExt, sizeof(aExt));
    if (NULL == pCAContext)
    {
	pCAContext = g_pCAContextCurrent;
    }

    // szOID_KEY_USAGE
    {
	CRYPT_BIT_BLOB KeyUsage;
	BYTE abKeyUsage[1];

	abKeyUsage[0] = (BYTE) (CRLF_USE_XCHG_CERT_TEMPLATE == Flags?
	    CERT_KEY_ENCIPHERMENT_KEY_USAGE : myCASIGN_KEY_USAGE);

	KeyUsage.pbData = abKeyUsage;
	KeyUsage.cbData = sizeof(abKeyUsage);
	KeyUsage.cUnusedBits = 0;

	if (!myEncodeKeyUsage(
			X509_ASN_ENCODING,
			&KeyUsage,
			CERTLIB_USE_LOCALALLOC,
			&aExt[cExt].Value.pbData,
			&aExt[cExt].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeKeyUsage");
	}
	apwszObjId[cExt] = TEXT(szOID_KEY_USAGE);
	cExt++;
    }

    if (CRLF_USE_XCHG_CERT_TEMPLATE == Flags)
    {
	// szOID_ENHANCED_KEY_USAGE
	{
	    CERT_ENHKEY_USAGE eku;

	    eku.cUsageIdentifier = ARRAYSIZE(s_apszObjIdXchg);
	    eku.rgpszUsageIdentifier = s_apszObjIdXchg;

	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_ENHANCED_KEY_USAGE,
			    &eku,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &aExt[cExt].Value.pbData,
			    &aExt[cExt].Value.cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myEncodeObject");
	    }
	    apwszObjId[cExt] = TEXT(szOID_ENHANCED_KEY_USAGE);
	    cExt++;
	}

	// szOID_APPLICATION_CERT_POLICIES
	{
	    CERT_POLICY_INFO acpi[ARRAYSIZE(s_apszObjIdXchg)];
	    CERT_POLICIES_INFO cps;

	    ZeroMemory(acpi, sizeof(acpi));
	    cps.cPolicyInfo = ARRAYSIZE(s_apszObjIdXchg);
	    cps.rgPolicyInfo = acpi;
	    for (i = 0; i < ARRAYSIZE(s_apszObjIdXchg); i++)
	    {
		acpi[i].pszPolicyIdentifier = s_apszObjIdXchg[i];
	    }
	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_CERT_POLICIES,
			    &cps,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &aExt[cExt].Value.pbData,
			    &aExt[cExt].Value.cbData))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myEncodeObject");
	    }
	    apwszObjId[cExt] = TEXT(szOID_APPLICATION_CERT_POLICIES);
	    cExt++;
	}
    }
    else
    {
	// szOID_ENHANCED_KEY_USAGE

	pszObjId = szOID_ENHANCED_KEY_USAGE;
	hr = pkcsAddInheritedExtension(
				prow,
				pszObjId,
				pCAContext,
				pCAContextTarget,
				&fExtAdded);
	_JumpIfError(hr, error, "pkcsAddInheritedExtension");

	// szOID_APPLICATION_CERT_POLICIES

	pszObjId = szOID_APPLICATION_CERT_POLICIES;
	hr = pkcsAddInheritedExtension(
				prow,
				pszObjId,
				pCAContext,
				pCAContextTarget,
				&fExtAdded);
	_JumpIfError(hr, error, "pkcsAddInheritedExtension");
    }

    // szOID_CERT_POLICIES

    pszObjId = szOID_CERT_POLICIES;
    hr = pkcsAddInheritedExtension(
			    prow,
			    pszObjId,
			    pCAContext,
			    pCAContextTarget,
			    &fExtAdded);
    _JumpIfError(hr, error, "pkcsAddInheritedExtension");

    pszObjId = NULL;

    if (CRLF_USE_XCHG_CERT_TEMPLATE != Flags && !fExtAdded)
    {
	CERT_POLICY_INFO acpi[ARRAYSIZE(s_apszObjIdAll)];
	CERT_POLICIES_INFO cps;

	ZeroMemory(acpi, sizeof(acpi));
	cps.cPolicyInfo = ARRAYSIZE(s_apszObjIdAll);
	cps.rgPolicyInfo = acpi;
	for (i = 0; i < ARRAYSIZE(s_apszObjIdAll); i++)
	{
	    acpi[i].pszPolicyIdentifier = s_apszObjIdAll[i];
	}
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_CERT_POLICIES,
			&cps,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aExt[cExt].Value.pbData,
			&aExt[cExt].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	apwszObjId[cExt] = TEXT(szOID_CERT_POLICIES);
	cExt++;
    }

    if (CRLF_USE_XCHG_CERT_TEMPLATE != Flags)
    {
	// szOID_BASIC_CONSTRAINTS2

	CERT_BASIC_CONSTRAINTS2_INFO Constraints;

	Constraints.fCA = TRUE;
	Constraints.fPathLenConstraint = FALSE;
	Constraints.dwPathLenConstraint = 0;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_BASIC_CONSTRAINTS2,
			&Constraints,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aExt[cExt].Value.pbData,
			&aExt[cExt].Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aExt[cExt].fCritical = TRUE;
	apwszObjId[cExt] = TEXT(szOID_BASIC_CONSTRAINTS2);
	cExt++;
    }
    CSASSERT(cExt <= ARRAYSIZE(aExt));
    hr = S_OK;

error:
    *ppszObjIdExtError = pszObjId;
    for (i = 0; i < ARRAYSIZE(aExt); i++)
    {
	if (NULL != aExt[i].Value.pbData)
	{
	    HRESULT hr2;

	    hr2 = PropSetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_SERVER,
			apwszObjId[i],
			EXTENSION_ORIGIN_SERVER |
			    (aExt[i].fCritical? EXTENSION_CRITICAL_FLAG : 0),
			aExt[i].Value.cbData,
			aExt[i].Value.pbData);
	    _PrintIfErrorStr(hr2, "PropSetExtension", apwszObjId[i]);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	    LocalFree(aExt[i].Value.pbData);
	}
    }
    return(hr);
}


HRESULT
pkcsAddInternalCertExtensions(
    IN ICertDBRow *prow,
    IN BOOL fCrossCert,				// else CA Xchg cert
    IN WCHAR const *pwszTemplate,
    OPTIONAL IN CACTX *pCAContext,		// signing CACTX
    OPTIONAL IN CACTX *pCAContextTarget,	// target CACTX
    OUT char const **ppszObjIdExtError)
{
    HRESULT hr;
    CERT_EXTENSION Ext;
    HCERTTYPE hCertType = NULL;
    CERT_EXTENSIONS *pExtensions = NULL;
    WCHAR *pwszObjId = NULL;
    DWORD Flags = fCrossCert?
	CRLF_USE_CROSS_CERT_TEMPLATE : CRLF_USE_XCHG_CERT_TEMPLATE;

    ZeroMemory(&Ext, sizeof(Ext));
    *ppszObjIdExtError = NULL;

    // szOID_ENROLL_CERTTYPE_EXTENSION

    hr = myBuildCertTypeExtension(pwszTemplate, &Ext);
    _JumpIfError(hr, error, "myBuildCertTypeExtension");

    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),
		    EXTENSION_ORIGIN_SERVER,		// ExtFlags
		    Ext.Value.cbData,
		    Ext.Value.pbData);
    _JumpIfError(hr, error, "PropSetExtension");

    hr = S_FALSE;
    if (!fCrossCert || (Flags & g_dwCRLFlags))
    {
	hr = CAFindCertTypeByName(
		    pwszTemplate,
		    NULL,
		    CT_FIND_LOCAL_SYSTEM |
			CT_ENUM_MACHINE_TYPES |
			CT_ENUM_USER_TYPES |
			CT_FLAG_NO_CACHE_LOOKUP,
		    &hCertType);
    }
    if (S_OK != hr)
    {
	_PrintErrorStr2(hr, "CAFindCertTypeByName", pwszTemplate, S_FALSE);
	if (Flags & g_dwCRLFlags)
	{
	    _JumpIfError(hr, error, "PropSetExtension");
	}
	hr = pkcsAddCannedCertExtensions(
				    prow,
				    Flags,
				    pCAContext,
				    pCAContextTarget,
				    ppszObjIdExtError);
	_JumpIfError(hr, error, "pkcsAddCannedCertExtensions");
    }
    else
    {
	BOOL fExtAdded;

	if (Flags & g_dwCRLFlags)
	{
	    hr = CACertTypeAccessCheckEx(
				hCertType,
				NULL,
				CERTTYPE_ACCESS_CHECK_ENROLL);
	    if (E_ACCESSDENIED == hr)
	    {
		// map E_ACCESSDENIED to a more meaningful error

		hr = CERTSRV_E_TEMPLATE_DENIED;
	    }
	    _JumpIfError(hr, error, "CACertTypeAccessCheckEx");
	}

	hr = CAGetCertTypeExtensions(hCertType, &pExtensions);
	_JumpIfError(hr, error, "CAGetCertTypeExtensions");

	// szOID_CERT_POLICIES

	hr = pkcsAddInheritedExtension(
				prow,
				szOID_CERT_POLICIES,
				pCAContext,
				pCAContextTarget,
				&fExtAdded);
	if (S_OK != hr)
	{
	    *ppszObjIdExtError = szOID_CERT_POLICIES;
	    _JumpError(hr, error, "pkcsAddInheritedExtension");
	}

	if (NULL != pExtensions && 0 != pExtensions->cExtension)
	{
	    CERT_EXTENSION *pExt;
	    CERT_EXTENSION *pExtEnd;

	    pExt = pExtensions->rgExtension;
	    pExtEnd = &pExt[pExtensions->cExtension];
	    for ( ; pExt < pExtEnd; pExt++)
	    {
		if (NULL != pwszObjId)
		{
		    LocalFree(pwszObjId);
		    pwszObjId = NULL;
		}
		if (!myConvertSzToWsz(&pwszObjId, pExt->pszObjId, -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "myConvertSzToWsz(ObjId)");
		}
		hr = PropSetExtension(
			    prow,
			    PROPTYPE_BINARY | PROPCALLER_SERVER,
			    pwszObjId,
			    EXTENSION_ORIGIN_SERVER |
				(pExt->fCritical? EXTENSION_CRITICAL_FLAG : 0),
			    pExt->Value.cbData,
			    pExt->Value.pbData);
		_JumpIfError(hr, error, "PropSetExtension");
	    }
	}

	if (CRLF_USE_XCHG_CERT_TEMPLATE == Flags)
	{
	    hr = PKCSUpdateXchgValidityPeriods(hCertType);
	    _PrintIfError(hr, "PKCSUpdateXchgValidityPeriods");
	}
    }
    hr = S_OK;

error:
    if (NULL != Ext.Value.pbData)
    {
	LocalFree(Ext.Value.pbData);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    if (NULL != hCertType)
    {
	if (NULL != pExtensions)
	{
	    CAFreeCertTypeExtensions(hCertType, pExtensions);
	}
	CACloseCertType(hCertType);
    }
    return(hr);
}


HRESULT
pkcsAddCrossCertVersionExtension(
    IN ICertDBRow *prow,
    IN DWORD CrossCAVersion)
{
    HRESULT hr;
    BYTE *pbExt = NULL;
    DWORD cbExt;

    // Build the Cross CA Version extension

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_INTEGER,
		&CrossCAVersion,
		0,
		CERTLIB_USE_LOCALALLOC,
		&pbExt,
		&cbExt))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = PropSetExtension(
		    prow,
		    PROPTYPE_BINARY | PROPCALLER_SERVER,
		    TEXT(szOID_CERTSRV_CROSSCA_VERSION),
		    EXTENSION_ORIGIN_SERVER,	// ExtFlags
		    cbExt,
		    pbExt);
    _JumpIfError(hr, error, "PropSetExtension");

error:
    if (NULL != pbExt)
    {
        LocalFree(pbExt);
    }
    return(hr);
}


HRESULT
pkcsCreateNewInternalCert(
    IN ICertDBRow *prow,
    IN CERT_NAME_BLOB const *pSubject,
    IN HCRYPTPROV hProv,
    OPTIONAL IN WCHAR const *pwszUserName,
    IN BOOL fCrossCert,			// else CA Xchg cert
    OPTIONAL IN CACTX *pCAContext,	// signing CACTX
    OPTIONAL IN CACTX *pCAContextTarget,// target CACTX
    OPTIONAL IN FILETIME const *pftNotBefore,
    OPTIONAL IN FILETIME const *pftNotAfter,
    OUT CERT_CONTEXT const **ppcc)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fErrorLogged = FALSE;
    DWORD dwRequestFlags;
    WCHAR const *pwszTemplate;
    BOOL fSubjectNameSet;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cb;
    CERTTRANSBLOB ctbCert;		// CoTaskMem*
    CERTSRV_RESULT_CONTEXT Result;
    WCHAR *pwszDisposition = NULL;
    WCHAR *pwszDispositionCreateCert = NULL;
    WCHAR *pwszMachineRequesterName = NULL;
    char const *pszObjIdExtError = NULL;

    ZeroMemory(&ctbCert, sizeof(ctbCert));
    *ppcc = NULL;

    dwRequestFlags = fCrossCert? CR_FLG_CACROSSCERT : CR_FLG_CAXCHGCERT;
    pwszTemplate = fCrossCert? wszCERTTYPE_CROSS_CA : wszCERTTYPE_CA_EXCHANGE;

    hr = myGetComputerObjectName(NameSamCompatible, &pwszMachineRequesterName);
    if (S_OK != hr)
    {
	_PrintError(hr, "myGetComputerObjectName");

	hr = myGetUserNameEx(NameSamCompatible, &pwszMachineRequesterName);
	_JumpIfError(hr, error, "myGetUserNameEx");
    }
    if (NULL == pwszUserName)
    {
	pwszUserName = pwszMachineRequesterName;
    }

    hr = prow->SetProperty(
		g_wszPropRequesterName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		MAXDWORD,
		(BYTE const *) pwszMachineRequesterName);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		g_wszPropCallerName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		MAXDWORD,
		(BYTE const *) pwszUserName);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		wszPROPCERTIFICATETEMPLATE,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		MAXDWORD,
		(BYTE const *) pwszTemplate);
    _JumpIfError(hr, error, "SetProperty");

    if (!myCryptExportPublicKeyInfo(
				hProv,
				fCrossCert? AT_SIGNATURE : AT_KEYEXCHANGE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestSubmittedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");

    hr = PropSetRequestTimeProperty(prow, g_wszPropRequestResolvedWhen);
    _JumpIfError(hr, error, "PropSetRequestTimeProperty");

    hr = CoreSetDisposition(prow, DB_DISP_ACTIVE);
    _JumpIfError(hr, error, "CoreSetDisposition");

    hr = pkcsSetRequestNameInfo(
			prow,
			pSubject,
			fCrossCert? NULL : g_wszCNXchgSuffix,
			FALSE,		// fReorderLikeRDNs
			&dwRequestFlags,
			&fSubjectNameSet);
    _JumpIfError(hr, error, "pkcsSetRequestNameInfo");

    hr = prow->SetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    sizeof(dwRequestFlags),
		    (BYTE const *) &dwRequestFlags);
    _JumpIfError(hr, error, "SetProperty(RequestFlags)");

    CSASSERT(fSubjectNameSet);

    hr = pkcsSetPublicKeyProperties(prow, pPubKey);
    _JumpIfError(hr, error, "pkcsSetPublicKeyProperties");

    hr = prow->CopyRequestNames();
    _JumpIfError(hr, error, "CopyRequestNames");

    hr = PKCSSetServerProperties(
			    prow,
			    pCAContext,		// optional signing context
			    pftNotBefore,
			    pftNotAfter,
			    g_lCAXchgValidityPeriodCount,
			    g_enumCAXchgValidityPeriod);
    _JumpIfError(hr, error, "PKCSSetServerProperties");

    hr = pkcsAddInternalCertExtensions(
				prow,
				fCrossCert,
				pwszTemplate,
				pCAContext,
				pCAContextTarget,
				&pszObjIdExtError);
    _JumpIfError(hr, error, "pkcsAddInternalCertExtensions");

    ZeroMemory(&Result, sizeof(Result));
    Result.pctbCert = &ctbCert;
    hr = PKCSCreateCertificate(
			prow,
			DB_DISP_ISSUED,
			FALSE,		// fIncludeCRLs
			fCrossCert,
			pCAContext,	// optional signing context
			&fErrorLogged,
			NULL,		// ppCAContext
			&pwszDispositionCreateCert,
			&Result);
    _JumpIfError(hr, error, "PKCSCreateCertificate");

    *ppcc = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				ctbCert.pb,
				ctbCert.cb);
    if (NULL == *ppcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    hr = S_OK;

error:
    pwszDisposition = CoreBuildDispositionString(
					g_pwszRequestedBy,
					pwszUserName,
					pwszDispositionCreateCert,
					NULL,
					NULL,
					S_OK,
					FALSE);

    hr2 = CoreSetRequestDispositionFields(
				prow,
				hr,
				S_OK == hr? DB_DISP_ISSUED : DB_DISP_DENIED,
				pwszDisposition);
    _PrintIfError(hr2, "CoreSetRequestDispositionFields");
    if (S_OK == hr)
    {
	hr = hr2;
    }
    if (S_OK != hr && !fErrorLogged)
    {
	DWORD LogMsg;
	WCHAR const *apwsz[3];
	DWORD cpwsz;
	WCHAR wszVersion[2 * cwcDWORDSPRINTF + 1];
	
	cpwsz = 0;
	LogMsg = MSG_E_CANNOT_CREATE_XCHG_CERT;
	if (fCrossCert)
	{
	    wszVersion[0] = L'\0';
	    if (NULL != pCAContext && NULL != pCAContextTarget)
	    {
		wsprintf(
		    wszVersion, L"(%u-%u)", 
		    pCAContext->iCert,
		    pCAContextTarget->iCert);
	    }
	    apwsz[cpwsz++] = wszVersion;
	    LogMsg = MSG_E_CANNOT_CREATE_CROSS_CERT;
	    if (NULL != pszObjIdExtError)
	    {
		LogMsg = MSG_E_CROSS_CERT_EXTENSION_CONFLICT;
		apwsz[cpwsz++] = myGetOIDNameA(pszObjIdExtError);
	    }
	}
	apwsz[cpwsz++] = NULL != pwszDisposition?
			pwszDisposition : pwszDispositionCreateCert;

	LogEventStringArrayHResult(
			EVENTLOG_ERROR_TYPE,
			LogMsg,
			cpwsz,
			apwsz,
			hr);
    }
    if (NULL != pwszMachineRequesterName)
    {
        LocalFree(pwszMachineRequesterName);
    }
    if (NULL != pwszDisposition)
    {
        LocalFree(pwszDisposition);
    }
    if (NULL != pwszDispositionCreateCert)
    {
        LocalFree(pwszDispositionCreateCert);
    }
    if (NULL != ctbCert.pb)
    {
	CoTaskMemFree(ctbCert.pb);
    }
    if (NULL != pPubKey)
    {
	LocalFree(pPubKey);
    }
    return(hr);
}


HRESULT
pkcsFormXchgKeyContainerName(
    IN DWORD dwRequestId,
    OUT WCHAR **ppwszKeyContainer)
{
    HRESULT hr;
    DWORD cwcSuffix;
    DWORD cwcName;
    WCHAR wszSuffix[ARRAYSIZE(g_wszCNXchgSuffix) + 1 + cwcDWORDSPRINTF + 1];
    WCHAR wszKeyContainer[MAX_PATH];

    *ppwszKeyContainer = NULL;

    cwcSuffix = wsprintf(wszSuffix, L"%ws(%u)", g_wszCNXchgSuffix, dwRequestId);
    CSASSERT(ARRAYSIZE(wszSuffix) > cwcSuffix);

    cwcName = wcslen(g_wszSanitizedName);
    if (cwcName > MAX_PATH - cwcSuffix)
    {
	cwcName = MAX_PATH - cwcSuffix;
    }
    CSASSERT(ARRAYSIZE(wszKeyContainer) > cwcName);
    wcscpy(wszKeyContainer, g_wszSanitizedName);
    wcscpy(&wszKeyContainer[cwcName], wszSuffix);

    hr = myDupString(wszKeyContainer, ppwszKeyContainer);
    _JumpIfError(hr, error, "myDupString");

    DBGPRINT((
	DBG_SS_CERTSRV,
	"pkcsFormXchgKeyContainerName: %ws\n",
	*ppwszKeyContainer));

error:
    return(hr);
}


VOID
pkcsDeleteKey(
    OPTIONAL IN WCHAR const *pwszKeyContainer)
{
    HRESULT hr;
    HCRYPTPROV hProv;

    if (NULL != pwszKeyContainer)
    {
	if (!CryptAcquireContext(
			    &hProv,
			    pwszKeyContainer,
			    g_pwszXchgProvName,
			    g_dwXchgProvType,
			    CRYPT_DELETEKEYSET |
			     g_CryptSilent |
			     (g_fXchgMachineKeyset? CRYPT_MACHINE_KEYSET : 0)))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptAcquireContext");
	}
    }
error:
    ;
}


VOID
pkcsLoadCAXchgCSPInfo(
    IN BOOL fSetDefaults)
{
    HRESULT hr = S_FALSE;

    if (NULL != g_pwszXchgProvName)
    {
	LocalFree(g_pwszXchgProvName);
	g_pwszXchgProvName = NULL;
    }
    if (!fSetDefaults)
    {
	hr = myGetCertSrvCSP(
			TRUE,	// fEncryptionCSP
			g_wszSanitizedName,
			&g_dwXchgProvType,
			&g_pwszXchgProvName,
			&g_XchgidAlg,
			&g_fXchgMachineKeyset,
			&g_dwXchgKeySize);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myGetCertSrvCSP(CAXchg)");
	}
    }
    if (S_OK != hr)
    {
	g_dwXchgProvType = PROV_RSA_FULL;
	g_pwszXchgProvName = NULL;
	g_XchgidAlg = CALG_3DES;
	g_fXchgMachineKeyset = TRUE;
	g_dwXchgKeySize = 0;
    }
    if (0 == g_dwXchgKeySize)
    {
	g_dwXchgKeySize = 1024;
    }
}


HRESULT
pkcsCreateNewCAXchgCert(
    IN WCHAR const *pwszUserName)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    BOOL fErrorLogged = FALSE;
    DWORD i;
    CAXCHGCTX CAXchgContext;
    CAXCHGCTX *rgCAXchgContext;

    ZeroMemory(&CAXchgContext, sizeof(CAXchgContext));

    hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, &prow);
    _JumpIfError(hr, error, "OpenRow");

    prow->GetRowId(&CAXchgContext.ReqId);

    hr = pkcsFormXchgKeyContainerName(
				CAXchgContext.ReqId,
				&CAXchgContext.pwszKeyContainerName);
    _JumpIfError(hr, error, "pkcsFormXchgKeyContainerName");

    for (i = 0; ; i++)
    {
	hr = myGenerateKeys(
			CAXchgContext.pwszKeyContainerName,
			g_pwszXchgProvName,
			g_CryptSilent,
			g_fXchgMachineKeyset,
			AT_KEYEXCHANGE,
			g_dwXchgProvType,
			g_dwXchgKeySize,
			&CAXchgContext.hProvCA);
	if (S_OK == hr)
	{
	    break;
	}
	_PrintErrorStr(hr, "myGenerateKeys", g_pwszXchgProvName);
	LogEventHResult(
		    NULL == g_pwszXchgProvName?
			EVENTLOG_ERROR_TYPE :
			EVENTLOG_WARNING_TYPE,
		    NULL == g_pwszXchgProvName?
			MSG_E_BAD_DEFAULT_CA_XCHG_CSP :
			MSG_E_BAD_REGISTRY_CA_XCHG_CSP,
		    hr);
	if (0 != i || NULL == g_pwszXchgProvName)
	{
	    fErrorLogged = TRUE;
	    _JumpError(hr, error, "myGenerateKeys");
	}
	pkcsLoadCAXchgCSPInfo(TRUE);	// switch to default CSP
    }
    if (0 != i)
    {
	hr = LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_E_USE_DEFAULT_CA_XCHG_CSP,
		    0,			// cpwsz
		    NULL);		// apwsz
	_PrintIfError(hr, "LogEvent");
    }
    hr = mySetKeyContainerSecurity(CAXchgContext.hProvCA);
    _JumpIfError(hr, error, "mySetKeyContainerSecurity");

    hr = pkcsCreateNewInternalCert(
			prow,
			&g_pCAContextCurrent->pccCA->pCertInfo->Subject,
			CAXchgContext.hProvCA,
			pwszUserName,
			FALSE,			// fCrossCert
			NULL,			// use default signing CACTX
			NULL,			// pCAContextTarget
			NULL,			// pftNotBefore
			NULL,			// pftNotAfter
			&CAXchgContext.pccCAXchg);
    _JumpIfError(hr, error, "pkcsCreateNewInternalCert");

    if (NULL == g_aCAXchgContext)
    {
	CSASSERT(0 == g_cCAXchgCerts);
	rgCAXchgContext = (CAXCHGCTX *) LocalAlloc(
					    LMEM_FIXED,
					    sizeof(rgCAXchgContext[0]));
    }
    else
    {
	rgCAXchgContext = (CAXCHGCTX *) LocalReAlloc(
			    g_aCAXchgContext,
			    (g_cCAXchgCerts + 1) * sizeof(rgCAXchgContext[0]),
			    LMEM_MOVEABLE);
    }
    if (NULL == rgCAXchgContext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc/ReAlloc");
    }
    g_aCAXchgContext = rgCAXchgContext;
    g_aCAXchgContext[g_cCAXchgCerts] = CAXchgContext;

    g_pCAXchgContextCurrent = &g_aCAXchgContext[g_cCAXchgCerts];

    g_cCAXchgCerts++;
    ZeroMemory(&CAXchgContext, sizeof(CAXchgContext));
    hr = S_OK;

error:
    if (NULL != prow)
    {
	HRESULT hr2;

	hr2 = prow->CommitTransaction(TRUE);
	_PrintIfError(hr2, "CommitTransaction");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
	if (S_OK != hr2)
	{
	    hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != CAXchgContext.pccCAXchg)
    {
	CertFreeCertificateContext(CAXchgContext.pccCAXchg);
    }
    if (NULL != CAXchgContext.hProvCA)
    {
	CryptReleaseContext(CAXchgContext.hProvCA, 0);
	pkcsDeleteKey(CAXchgContext.pwszKeyContainerName);
    }
    if (NULL != CAXchgContext.pwszKeyContainerName)
    {
	LocalFree(CAXchgContext.pwszKeyContainerName);
    }
    return(hr);
}


HRESULT
pkcsCreateNewCrossCert(
    IN OUT CACROSSCTX *pCACross,
    IN FILETIME const *pftNotBefore,
    IN FILETIME const *pftNotAfter)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    WCHAR wszIndex[2 * cwcDWORDSPRINTF + 1];
    CERT_INFO const *pCertInfoCATarget;

    wsprintf(
	wszIndex,
	L"%u-%u",
	pCACross->pCAContext->iCert,
	pCACross->pCAContextTarget->iCert);

    hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, &prow);
    _JumpIfErrorStr(hr, error, "OpenRow", wszIndex);
  
    prow->GetRowId(&pCACross->ReqId);

    pCertInfoCATarget = pCACross->pCAContextTarget->pccCA->pCertInfo;
    hr = pkcsSetExtensions(
		prow,
		EXTENSION_ORIGIN_CACERT,
		pCertInfoCATarget->rgExtension,
		pCertInfoCATarget->cExtension);
    _JumpIfError(hr, error, "pkcsSetExtensions(old cert)");

    hr = pkcsAddCrossCertVersionExtension(
			    prow,
			    MAKECROSSCAVERSION(
					pCACross->pCAContext->iCert,
					pCACross->pCAContextTarget->iCert));
    _JumpIfError(hr, error, "pkcsAddCrossCertExtensions");

    hr = pkcsCreateNewInternalCert(
		    prow,
		    &pCertInfoCATarget->Subject,
		    pCACross->pCAContextTarget->hProvCA, // for the public key
		    NULL,			// pwszUserName
		    TRUE,			// fCrossCert
		    pCACross->pCAContext,	// signing context
		    pCACross->pCAContextTarget,	// target context
		    pftNotBefore,
		    pftNotAfter,
		    &pCACross->pccCACross);
    _JumpIfErrorStr(hr, error, "pkcsCreateNewInternalCert", wszIndex);

error:
    if (NULL != prow)
    {
	HRESULT hr2;

	hr2 = prow->CommitTransaction(TRUE);
	_PrintIfError(hr2, "CommitTransaction");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
	if (S_OK != hr2)
	{
	    hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    return(hr);
}


CERT_CONTEXT const *
pkcsFindCertificateInStore(
    IN HCERTSTORE hStore,
    IN CERT_CONTEXT const *pCert)
{
    BYTE rgbHash[CBMAX_CRYPT_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = sizeof(rgbHash);

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData) ||
	sizeof(rgbHash) != HashBlob.cbData)
    {
        return(NULL);
    }
    return(CertFindCertificateInStore(
		hStore,
		X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,// dwCertEncodingType
		0,					// dwFindFlags
		CERT_FIND_SHA1_HASH,
		(const void *) &HashBlob,
		NULL));					// pPrevCertContext
}


HRESULT
pkcsWriteCertToStore(
    IN WCHAR const *pwszStore,
    IN BOOL fEnterprise,
    IN BOOL fDelete,
    IN CERT_CONTEXT const *pcc,
    OUT LONG *plDisposition)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pccT;

    *plDisposition = 0;
    hStore = CertOpenStore(
                       CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                       X509_ASN_ENCODING,
                       NULL,			// hProv
		       fEnterprise?
			   CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE :
			   CERT_SYSTEM_STORE_LOCAL_MACHINE,
		       pwszStore);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }
    pccT = pkcsFindCertificateInStore(hStore, pcc);
    if (NULL != pccT)
    {
	if (fDelete)
	{
	    CertDeleteCertificateFromStore(pccT);
	    *plDisposition = -1;
	}
	else
	{
	    // already added; do nothing

	    CertFreeCertificateContext(pccT);
	}
    }
    else
    {
	if (!fDelete)
	{
	    if (!CertAddCertificateContextToStore(
				    hStore,
				    pcc,
				    CERT_STORE_ADD_USE_EXISTING,
				    NULL))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertAddCertificateContextToStore");
	    }
	    *plDisposition = 1;
	}
	else
	{
	    // already deleted; do nothing
	}
    }
    hr = S_OK;

error:
    if (NULL != hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


// if necessary, publish to System32\CertSrv\CertEnroll directory
// if necessary, publish to HKLM CA cert store
// if necessary, publish to crossCertificatePair in this CA's AIA object

HRESULT
pkcsPublishCrossCert(
    IN OUT CACROSSCTX *pCACross,
    IN BOOL fDelete)
{
    HRESULT hr;
    HRESULT hr2;
    WCHAR *pwszFile = NULL;
    LONG lDisposition;

    hr = pkcsGetCertFilename(
			g_wszSanitizedName,
			pCACross->pCAContext->iCert,
			pCACross->pCAContextTarget->iCert,
			&pwszFile);
    _JumpIfError(hr, error, "myGetCertFilename");

    hr = CRLWriteToLockedFile(
			pCACross->pccCACross->pbCertEncoded,
			pCACross->pccCACross->cbCertEncoded,
			fDelete,
			pwszFile);
    _PrintIfError(hr, "CRLWriteToLockedFile");

    hr2 = pkcsWriteCertToStore(
			wszCA_CERTSTORE,
			FALSE,		// fEnterprise
			fDelete,
			pCACross->pccCACross,
			&lDisposition);
    if (S_OK == hr)
    {
	hr = hr2;	// return first error
    }
    _PrintIfError(hr2, "pkcsWriteCertToStore");

    if (g_fUseDS)
    {
        // don't attempt to create the object, should already be there

	hr = CorePublishCrossCertificate(
			    pCACross->ReqId, 
			    pCACross->pccCACross,
			    FALSE,	// fCreateDSObject
			    fDelete);	// fDelete
	if (S_OK == hr)
	{
	    hr = hr2;	// return first error
	}
	_JumpIfError(hr2, error, "CorePublishCrossCertificate");
    }
    _JumpIfError(hr, error, "pkcsPublishCrossCert");

error:
    if (NULL != pwszFile)
    {
	LocalFree(pwszFile);
    }
    return(hr);
}


// Verify the cert matches the expected Cross cert contents:
// 1) verify timestamps meet expectations
// 2) Issuer and Subject both match CA binary subject
// 3) it is a CrossCA cert (v1 CrossCA template extension)
// 4) IssuerNameId matches source CA cert key index
// 5) SubjectKeyId matches target CA cert SubjectKeyId

HRESULT
pkcsVerifyCrossCertificate(
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN FILETIME const *pftNotBefore,
    IN FILETIME const *pftNotAfter,
    IN OUT CACROSSCTX *pCACross)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CERT_NAME_BLOB const *pSubject;
    CERT_EXTENSION const *pExtCross;
    CERT_EXTENSION const *pExt;
    CERT_NAME_VALUE *pName = NULL;
    CERT_AUTHORITY_KEY_ID2_INFO *pInfo = NULL;
    CERT_BLOB *pSKIBlob = NULL;
    DWORD cb;

    CSASSERT(NULL == pCACross->pccCACross);
    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    // verify timestamps meet expectations
    // verify Subject & Issuer match CA Subject

    pSubject = &pCACross->pCAContext->pccCA->pCertInfo->Subject;
    if (0 != CompareFileTime(pftNotBefore, &pcc->pCertInfo->NotBefore) ||
	0 != CompareFileTime(pftNotAfter, &pcc->pCertInfo->NotAfter) ||
	!pkcsCompareBlob(pSubject, &pcc->pCertInfo->Subject) ||
	!pkcsCompareBlob(pSubject, &pcc->pCertInfo->Issuer))
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError2(hr, error, "NotBefore/NotAfter/Subject/Issuer", hr);
    }

    // verify v1 CrossCA template extension

    pExtCross = CertFindExtension(
		    szOID_ENROLL_CERTTYPE_EXTENSION,
		    pcc->pCertInfo->cExtension,
		    pcc->pCertInfo->rgExtension);
    if (NULL == pExtCross)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "No Template");
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    pExtCross->Value.pbData,
		    pExtCross->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pName,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }
    if (0 != LSTRCMPIS(
		(WCHAR const *) pName->Value.pbData,
		wszCERTTYPE_CROSS_CA))
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "No Template");
    }

    // verify SKI matches target SKI

    pExtCross = CertFindExtension(
		    szOID_SUBJECT_KEY_IDENTIFIER,
		    pcc->pCertInfo->cExtension,
		    pcc->pCertInfo->rgExtension);
    pExt = CertFindExtension(
		    szOID_SUBJECT_KEY_IDENTIFIER,
		    pCACross->pCAContextTarget->pccCA->pCertInfo->cExtension,
		    pCACross->pCAContextTarget->pccCA->pCertInfo->rgExtension);
    if (NULL == pExtCross ||
	NULL == pExt ||
	!pkcsCompareBlob(&pExtCross->Value, &pExt->Value))
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "SKI");
    }

    // verify AKI KeyId matches source SKI

    pExtCross = CertFindExtension(
		    szOID_AUTHORITY_KEY_IDENTIFIER2,
		    pcc->pCertInfo->cExtension,
		    pcc->pCertInfo->rgExtension);
    pExt = CertFindExtension(
		    szOID_SUBJECT_KEY_IDENTIFIER,
		    pCACross->pCAContext->pccCA->pCertInfo->cExtension,
		    pCACross->pCAContext->pccCA->pCertInfo->rgExtension);
    if (NULL == pExtCross || NULL == pExt)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "SKI");
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
                    X509_AUTHORITY_KEY_ID2,
		    pExtCross->Value.pbData,
		    pExtCross->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
                    (VOID **) &pInfo,
                    &cb))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "Policy:myDecodeObject");
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    pExt->Value.pbData,
		    pExt->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
                    (VOID **) &pSKIBlob,
                    &cb))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "Policy:myDecodeObject");
    }
    if (!pkcsCompareBlob(pSKIBlob, &pInfo->KeyId))
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "AKI");
    }
    pCACross->pccCACross = pcc;
    pcc = NULL;
    hr = S_OK;

error:
    if (NULL != pSKIBlob)
    {
        LocalFree(pSKIBlob);
    }
    if (NULL != pName)
    {
        LocalFree(pName);
    }
    if (NULL != pInfo)
    {
	LocalFree(pInfo);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


// Query for a cert matching the CA's Common Name AND
// IssuerNameId matches source CA cert key index

DWORD g_aColCross[] = {

#define ICOL_RAWCERTIFICATE	0
    DTI_CERTIFICATETABLE | DTC_RAWCERTIFICATE,
};

HRESULT
pkcsLoadCrossCertFromDB(
    IN OUT CACROSSCTX *pCACross,
    IN FILETIME const *pftNotBefore,
    IN FILETIME const *pftNotAfter)
{
    HRESULT hr;
    CERTVIEWRESTRICTION acvr[3];
    CERTVIEWRESTRICTION *pcvr;
    DWORD NameIdMin;
    DWORD NameIdMax;
    IEnumCERTDBRESULTROW *pView = NULL;
    DWORD celtFetched;
    DWORD i;
    BOOL fEnd;
    CERTDBRESULTROW aResult[1];
    BOOL fResultActive = FALSE;

    CSASSERT(NULL == pCACross->pccCACross);

    // Set up restrictions as follows:

    pcvr = acvr;

    // CommonName == g_wszCommonName

    pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_COMMONNAME;
    pcvr->SeekOperator = CVR_SEEK_EQ;
    pcvr->SortOrder = CVR_SORT_ASCEND;
    pcvr->pbValue = (BYTE *) g_wszCommonName;
    pcvr->cbValue = sizeof(WCHAR) * (wcslen(g_wszCommonName) + 1);
    pcvr++;

    // NameId >= MAKECANAMEID(iCert == 0, iKey)

    NameIdMin = MAKECANAMEID(0, pCACross->pCAContext->iKey);
    pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID;
    pcvr->SeekOperator = CVR_SEEK_GE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMin;
    pcvr->cbValue = sizeof(NameIdMin);
    pcvr++;

    // NameId <= MAKECANAMEID(iCert == _16BITMASK, iKey)

    NameIdMax = MAKECANAMEID(_16BITMASK, pCACross->pCAContext->iKey);
    pcvr->ColumnIndex = DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID;
    pcvr->SeekOperator = CVR_SEEK_LE;
    pcvr->SortOrder = CVR_SORT_NONE;
    pcvr->pbValue = (BYTE *) &NameIdMax;
    pcvr->cbValue = sizeof(NameIdMax);
    pcvr++;

    CSASSERT(ARRAYSIZE(acvr) == SAFE_SUBTRACT_POINTERS(pcvr, acvr));

    celtFetched = 0;
    hr = g_pCertDB->OpenView(
			ARRAYSIZE(acvr),
			acvr,
			ARRAYSIZE(g_aColCross),
			g_aColCross,
			0,		// no worker thread
			&pView);
    _JumpIfError(hr, error, "OpenView");

    fEnd = FALSE;
    while (!fEnd)
    {
	hr = pView->Next(NULL, ARRAYSIZE(aResult), aResult, &celtFetched);
	if (S_FALSE == hr)
	{
	    fEnd = TRUE;
	    if (0 == celtFetched)
	    {
		break;
	    }
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "Next");

	fResultActive = TRUE;

	CSASSERT(ARRAYSIZE(aResult) >= celtFetched);

	for (i = 0; i < celtFetched; i++)
	{
	    CERTDBRESULTROW *pResult = &aResult[i];

	    CSASSERT(ARRAYSIZE(g_aColCross) == pResult->ccol);

	    if (NULL == pResult->acol[ICOL_RAWCERTIFICATE].pbValue)
	    {
		continue;
	    }
	    CSASSERT(PROPTYPE_BINARY == (PROPTYPE_MASK & pResult->acol[ICOL_RAWCERTIFICATE].Type));


	    hr = pkcsVerifyCrossCertificate(
				pResult->acol[ICOL_RAWCERTIFICATE].pbValue,
				pResult->acol[ICOL_RAWCERTIFICATE].cbValue,
				pftNotBefore,
				pftNotAfter,
				pCACross);
	    _PrintIfError2(hr, "pkcsVerifyCrossCertificate", hr);
	    if (S_OK == hr)
	    {
		CSASSERT(NULL != pCACross->pccCACross);
		fEnd = TRUE;
		break;
	    }
	}
	pView->ReleaseResultRow(celtFetched, aResult);
	fResultActive = FALSE;
    }
    hr = NULL != pCACross->pccCACross? S_OK : CRYPT_E_NOT_FOUND;
    _JumpIfError(hr, error, "pCACross->pccCACross");

error:
    if (NULL != pView)
    {
	if (fResultActive)
	{
	    pView->ReleaseResultRow(celtFetched, aResult);
	}
	pView->Release();
    }
    return(hr);
}
#undef ICOL_RAWCERTIFICATE


HRESULT
pkcsLoadCrossCertFromFile(
    IN OUT CACROSSCTX *pCACross,
    IN FILETIME const *pftNotBefore,
    IN FILETIME const *pftNotAfter)
{
    HRESULT hr;
    WCHAR *pwszFile = NULL;
    BYTE *pbCert = NULL;
    DWORD cbCert;

    hr = pkcsGetCertFilename(
			g_wszSanitizedName,
			pCACross->pCAContext->iCert,
			pCACross->pCAContextTarget->iCert,
			&pwszFile);
    _JumpIfError(hr, error, "myGetCertFilename");

    hr = DecodeFileW(pwszFile, &pbCert, &cbCert, CRYPT_STRING_ANY);
    _JumpIfError(hr, error, "DecodeFileW");

    hr = pkcsVerifyCrossCertificate(
			pbCert,
			cbCert,
			pftNotBefore,
			pftNotAfter,
			pCACross);
    _JumpIfError(hr, error, "pkcsVerifyCrossCertificate");

error:
    if (NULL != pwszFile)
    {
	LocalFree(pwszFile);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    return(hr);
}


HRESULT
pkcsImportCAOrCrossOrKRACert(
    IN CERT_CONTEXT const *pcc,
    IN BOOL fCrossCert,		// else CA or KRA cert
    IN DWORD DBDisposition,
    OPTIONAL IN CACTX const *pCAContext)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    BSTR strHash = NULL;
    ICertDBRow *prow = NULL;
    WCHAR *pwszUserName = NULL;
    DWORD cb;
    BOOL fCommit = FALSE;
    BOOL fCommitted = FALSE;

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
			pcc,
			CERT_HASH_PROP_ID,
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    // Import Cert if it doesn't already exist in DB:

    hr = g_pCertDB->OpenRow(
			PROPOPEN_CERTHASH | PROPTABLE_REQCERT,
			0,
			strHash,
			&prow);
    if (S_OK != hr)
    {
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _JumpError(hr, error, "OpenRow");
	}

	hr = g_pCertDB->OpenRow(PROPTABLE_REQCERT, 0, NULL, &prow);
	_JumpIfError(hr, error, "OpenRow");

	hr = PKCSParseImportedCertificate(
				    prow,
				    fCrossCert,
				    DBDisposition,
				    pCAContext,
				    pcc);
	_JumpIfError(hr, error, "PKCSParseImportedCertificate");

	fCommit = TRUE;
    }

    // Set requester name if missing

    hr = prow->GetProperty(
		g_wszPropRequesterName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		NULL,
		&cb,
		NULL);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = myGetComputerObjectName(NameSamCompatible, &pwszUserName);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myGetComputerObjectName");

	    hr = myGetUserNameEx(NameSamCompatible, &pwszUserName);
	    _JumpIfError(hr, error, "myGetUserNameEx");
	}

	hr = prow->SetProperty(
		    g_wszPropRequesterName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    MAXDWORD,
		    (BYTE const *) pwszUserName);
	_JumpIfError(hr, error, "SetProperty");

	hr = prow->SetProperty(
		    g_wszPropCallerName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    MAXDWORD,
		    (BYTE const *) pwszUserName);
	_JumpIfError(hr, error, "SetProperty");

	fCommit = TRUE;
    }
    if (DB_DISP_REVOKED == DBDisposition)
    {
	DWORD DispositionOld;

	cb = sizeof(DispositionOld);
	hr = prow->GetProperty(
			g_wszPropRequestDisposition,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cb,
			(BYTE *) &DispositionOld);
	_JumpIfError(hr, error, "GetProperty(Disposition)");

	CSASSERT(
	    DB_DISP_ISSUED == DispositionOld ||
	    DB_DISP_REVOKED == DispositionOld);
	if (DB_DISP_ISSUED == DispositionOld)
	{
	    fCommit = TRUE;
	    hr = pkcsSetRevocationFields(prow);
	    _JumpIfError(hr, error, "pkcsSetRevocationFields");
	}
    }
    hr = prow->CommitTransaction(fCommit);
    _JumpIfError(hr, error, "CommitTransaction");

    fCommitted = TRUE;
    hr = S_OK;

error:
    if (NULL != prow)
    {
	if (S_OK != hr && !fCommitted)
	{
	    HRESULT hr2 = prow->CommitTransaction(FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
	}
	prow->Release();
    }
    if (NULL != pwszUserName)
    {
	LocalFree(pwszUserName);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


// If the row exists in the database, do not create a new Cross cert -- even if
// the attempt to create a cross cert failed.  The row must be deleted to cause
// a new Cross cert creation attempt.
// If the cert exists in the row, load the cert context without validation.

HRESULT
pkcsLoadCrossCert(
    IN OUT CACROSSCTX *pCACross,
    IN FILETIME *pftNow,
    IN BOOL fForward,
    IN BOOL fRevoke)
{
    HRESULT hr;
    CACTX *pCAContextOld;
    CACTX *pCAContextNew;
    FILETIME const *pftNotBefore;
    FILETIME const *pftNotAfter;

    if (fForward)
    {
	pCAContextOld = pCACross->pCAContext;
	pCAContextNew = pCACross->pCAContextTarget;
    }
    else
    {
	pCAContextOld = pCACross->pCAContextTarget;
	pCAContextNew = pCACross->pCAContext;
    }

    if (NULL != pCAContextOld->pccCA && NULL != pCAContextNew->pccCA)
    {
        pftNotBefore = &pCAContextNew->pccCA->pCertInfo->NotBefore;
        pftNotAfter = &pCAContextOld->pccCA->pCertInfo->NotAfter;

        // Query for Cross cert -- see above criteria

        hr = pkcsLoadCrossCertFromDB(pCACross, pftNotBefore, pftNotAfter);
        _PrintIfError(hr, "pkcsLoadCrossCertFromDB");

        // if not in DB, look in CertEnroll directory

        if (NULL == pCACross->pccCACross)
        {
	    hr = pkcsLoadCrossCertFromFile(pCACross, pftNotBefore, pftNotAfter);
	    _PrintIfError(hr, "pkcsLoadCrossCertFromFile");
        }

        // if not yet loaded or found, create a new one

        if (NULL == pCACross->pccCACross)
        {
	    // Only create a cross cert if:
	    // 1) neither CA cert is revoked -- if !fRevoke
	    // 2) old CA cert is not yet expired
	    // 3) overlap period exists

	    if (!fRevoke &&
		0 > CompareFileTime(pftNow, pftNotAfter) &&
	        0 > CompareFileTime(pftNotBefore, pftNotAfter))
	    {
	        hr = pkcsCreateNewCrossCert(pCACross, pftNotBefore, pftNotAfter);
	        _JumpIfError(hr, error, "pkcsCreateNewCrossCert");

	        if (CERTLOG_TERSE <= g_dwLogLevel)
	        {
		    WCHAR const *apwsz[2];
		    WCHAR awc[2 * cwcDWORDSPRINTF + 2 + 1];

		    wsprintf(
		        awc,
		        L"(%u-%u)", 
		        pCACross->pCAContext->iCert,
		        pCACross->pCAContextTarget->iCert);
		    apwsz[0] = g_wszCommonName;
		    apwsz[1] = awc;

		    LogEvent(
		        EVENTLOG_INFORMATION_TYPE,
		        MSG_CREATED_CROSS_CERT,
		        ARRAYSIZE(apwsz),
		        apwsz);
	        }
	    }
        }

        // if cert loaded:

        if (NULL != pCACross->pccCACross)
        {
	    HRESULT hr2;
	    
	    pkcsVerifyCACrossState(pCACross);

	    hr = pkcsImportCAOrCrossOrKRACert(
				    pCACross->pccCACross,
				    TRUE,	// fCrossCert
				    fRevoke? DB_DISP_REVOKED : DB_DISP_ISSUED,
				    pCACross->pCAContext);
	    _PrintIfError(hr, "pkcsImportCAOrCrossOrKRACert");

	    hr2 = pkcsPublishCrossCert(pCACross, fRevoke);
	    _PrintIfError(hr2, "pkcsPublishCrossCert");

	    if (S_OK == hr)
	    {
	        hr = hr2;
	    }
	    _JumpIfError(hr, error, "Import/Publish Cross Cert");
        }
    }
    hr = S_OK;

error:
    return(hr);
}


BOOL
pkcsShouldDelete(
    IN CACTX const *pCAContext,
    IN BOOL fRevokedOnly)
{
    BOOL fDelete = FALSE;

    if ((CTXF_REVOKED & pCAContext->Flags) &&
	0 == (CRLF_PRESERVE_REVOKED_CA_CERTS & g_dwCRLFlags))
    {
	fDelete = TRUE;
    }
    if (!fRevokedOnly &&
	(CTXF_EXPIRED & pCAContext->Flags) &&
	0 == (CRLF_PRESERVE_EXPIRED_CA_CERTS & g_dwCRLFlags))
    {
	fDelete = TRUE;
    }
    return(fDelete);
}


HRESULT
pkcsLoadCrossCertArray()
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;
    FILETIME ftNow;

    g_aCACrossForward = (CACROSSCTX *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				g_cCACerts * sizeof(g_aCACrossForward[0]));
    if (NULL == g_aCACrossForward)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    g_aCACrossBackward = (CACROSSCTX *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				g_cCACerts * sizeof(g_aCACrossBackward[0]));
    if (NULL == g_aCACrossBackward)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    GetSystemTimeAsFileTime(&ftNow);
    hr = S_OK;
    for (i = 0; i < g_cCACerts - 1; i++)
    {
	if (g_aCAContext[i].iKey != g_aCAContext[i + 1].iKey)
	{
	    BOOL fRevoke;
	    
	    fRevoke = pkcsShouldDelete(&g_aCAContext[i], TRUE) ||
		       pkcsShouldDelete(&g_aCAContext[i + 1], TRUE);

	    g_aCACrossForward[i].pCAContext = &g_aCAContext[i];
	    g_aCACrossForward[i].pCAContextTarget = &g_aCAContext[i + 1];
	    if (fRevoke)
	    {
		g_aCACrossForward[i].Flags |= CTXF_REVOKED;
	    }
	    hr2 = pkcsLoadCrossCert(
				&g_aCACrossForward[i],
				&ftNow,
				TRUE,		// fForward
				fRevoke);
	    _PrintIfError(hr2, "pkcsLoadCrossCert");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }

	    g_aCACrossBackward[i + 1].pCAContext = &g_aCAContext[i + 1];
	    g_aCACrossBackward[i + 1].pCAContextTarget = &g_aCAContext[i];
	    if (fRevoke)
	    {
		g_aCACrossBackward[i + 1].Flags |= CTXF_REVOKED;
	    }
	    hr2 = pkcsLoadCrossCert(
				&g_aCACrossBackward[i + 1],
				&ftNow,
				FALSE,		// fForward
				fRevoke);
	    _PrintIfError(hr2, "pkcsLoadCrossCert");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    _JumpIfError(hr, error, "pkcsLoadCrossCert");

error:
    return(hr);
}


HRESULT
pkcsImportCAContext(
    IN CACTX const *pCAContext)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;
    WCHAR *pwszCertFile = NULL;
    BOOL fDelete;
    CERT_CONTEXT const *pCert = NULL;
    LONG lDisposition;

    hr = S_OK;
    CSASSERT(NULL != pCAContext->pccCA);
    for (i = 0; i < pCAContext->cCACertChain; i++)
    {
	pCert = pCAContext->apCACertChain[i];

	// If missing, save the cert to the database.

	hr2 = pkcsImportCAOrCrossOrKRACert(
			    pCert,
			    FALSE,	// fCrossCert
			    0 == i? DB_DISP_CA_CERT : DB_DISP_CA_CERT_CHAIN,
			    pCAContext);
	if (S_OK != hr2)
	{
	    if (S_OK == hr)
	    {
		hr = hr2;	// return first error
	    }
	    _PrintError(hr2, "pkcsImportCAOrCrossOrKRACert");
	    continue;
	}
    }

    hr2 = pkcsGetCertFilename(
			g_wszSanitizedName,
			pCAContext->iCert,
			MAXDWORD,	// iCertTarget
			&pwszCertFile);
    if (S_OK == hr)
    {
	hr = hr2;	// return first error
    }
    _JumpIfError(hr2, error, "myGetCertFilename");

    fDelete = pkcsShouldDelete(pCAContext, FALSE);

    // If necessary, save/delete the cert to/from the CertEnroll directory.

    hr2 = CRLWriteToLockedFile(
	    pCAContext->pccCA->pbCertEncoded,
	    pCAContext->pccCA->cbCertEncoded,
	    fDelete,
	    pwszCertFile);
    if (S_OK == hr)
    {
	hr = hr2;	// return first error
    }
    _PrintIfError(hr2, "CRLWriteToLockedFile");

    // If necessary, add/delete the cert to/from the HKLM Machine CA store.

    hr2 = pkcsWriteCertToStore(
			wszCA_CERTSTORE,
			FALSE,			// fEnterprise
			fDelete,
			pCAContext->pccCA,
			&lDisposition);
    if (S_OK == hr)
    {
	hr = hr2;	// return first error
    }
    _PrintIfError(hr2, "pkcsWriteCertToStore");

    if (fDelete)
    {
	// If present, delete the cert from the HKLM Enterprise CA store.

	hr2 = pkcsWriteCertToStore(
			    wszCA_CERTSTORE,
			    TRUE,		// fEnterprise
			    TRUE,		// fDelete
			    pCAContext->pccCA,
			    &lDisposition);
	if (S_OK == hr)
	{
	    hr = hr2;	// return first error
	}
	_PrintIfError(hr2, "pkcsWriteCertToStore");

	if (IsRootCA(g_CAType))
	{
	    // If present, delete the cert from the HKLM Machine Root store.

	    hr2 = pkcsWriteCertToStore(
				wszROOT_CERTSTORE,
				FALSE,		// fEnterprise
				TRUE,		// fDelete
				pCAContext->pccCA,
				&lDisposition);
	    if (S_OK == hr)
	    {
		hr = hr2;	// return first error
	    }

	    // If present, delete the cert from the HKLM Enterprise Root store.

	    hr2 = pkcsWriteCertToStore(
				wszROOT_CERTSTORE,
				TRUE,		// fEnterprise
				TRUE,		// fDelete
				pCAContext->pccCA,
				&lDisposition);
	    if (S_OK == hr)
	    {
		hr = hr2;	// return first error
	    }
	    _PrintIfError(hr2, "pkcsWriteCertToStore");
	}
    }
    else
    {
	// If executing with a DS available, expect group policy to supply the
	// root cert.  Log an event if we don't find the root cert in the HKLM
	// Enterprise Root store.

	if (g_fUseDS &&
	    NULL != pCert &&
	    CertCompareCertificateName(
				X509_ASN_ENCODING,
				&pCert->pCertInfo->Subject,
				&pCert->pCertInfo->Issuer))
	{
	    hr2 = pkcsWriteCertToStore(
				wszROOT_CERTSTORE,
				TRUE,		// fEnterprise
				FALSE,		// fDelete
				pCert,
				&lDisposition);
	    _PrintIfError(hr2, "pkcsWriteCertToStore");
	    if (0 < lDisposition)
	    {
		WCHAR awc[cwcDWORDSPRINTF];
		WCHAR const *apwsz[1];

		// Was missing -- probably not being sucked down from Group
		// Policy's Root CA object query.  Complain loudly.

		wsprintf(awc, L"%u", pCAContext->iCert);
		apwsz[0] = awc;
		LogEvent(
		    EVENTLOG_WARNING_TYPE,
		    MSG_E_MISSING_POLICY_ROOT,
		    ARRAYSIZE(apwsz),
		    apwsz);
	    }
	}
    }
    _JumpIfError(hr, error, "pkcsImportCAContext");

error:
    if (NULL != pwszCertFile)
    {
	LocalFree(pwszCertFile);
    }
    return(hr);
}


HRESULT
pkcsImportCAContextArray()
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;
    WCHAR *pwszCertDir = NULL;
    WCHAR *pwsz;

    hr = pkcsGetCertFilename(g_wszSanitizedName, 0, MAXDWORD, &pwszCertDir);
    _JumpIfError(hr, error, "myGetCertFilename");

    pwsz = wcsrchr(pwszCertDir, L'\\');
    CSASSERT(NULL != pwsz);
    *pwsz = L'\0';
    CreateDirectory(pwszCertDir, NULL);	// in case it's missing

    for (i = 0; i < g_cCACerts; i++)
    {
	CACTX *pCAContext = &g_aCAContext[i];

	if (NULL == pCAContext->pccCA)
	{
	    continue;
	}
	hr2 = pkcsImportCAContext(pCAContext);
	if (S_OK != hr2)
	{
	    _PrintError(hr2, "pkcsImportCAContext");
	    if (S_OK == hr)
	    {
		hr = hr2;	// return first error
	    }
	}
    }

error:
    if (NULL != pwszCertDir)
    {
	LocalFree(pwszCertDir);
    }
    return(hr);
}


HRESULT
pkcsExpandURL(
    IN WCHAR const *pwszURLTemplate,
    IN BOOL fDSAttrib,
    OUT WCHAR **ppwszURL)
{
    HRESULT hr;

    *ppwszURL = NULL;

    CSASSERT(NULL != g_strDomainDN && NULL != g_strConfigDN);
    hr = myFormatCertsrvStringArray(
	    FALSE,			// fURL
	    g_pwszServerName,		// pwszServerName_p1_2
	    g_wszSanitizedName,		// pwszSanitizedName_p3_7
	    0,				// iCert_p4
	    MAXDWORD,			// iCertTarget_p4
	    g_strDomainDN,		// pwszDomainDN_p5
	    g_strConfigDN,		// pwszConfigDN_p6
	    0,				// iCRL_p8
	    FALSE,			// fDeltaCRL_p9
	    fDSAttrib,			// fDSAttrib_p10_11
	    1,				// cStrings
	    &pwszURLTemplate,		// apwszStringsIn
	    ppwszURL);			// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

error:
    return(hr);
}


HRESULT
pkcsObtainDSStore(
    IN WCHAR const *pwszURLTemplate,
    OUT HCERTSTORE *phCertStore)
{
    HRESULT hr;
    HCERTSTORE hEnterpriseStore;
    WCHAR *pwszURL = NULL;

    if (NULL == pwszURLTemplate || NULL == phCertStore)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *phCertStore = NULL;

    hr = pkcsExpandURL(pwszURLTemplate, TRUE, &pwszURL);
    _JumpIfError(hr, error, "pkcsExpandURL");

    hEnterpriseStore = myUrlCertOpenStore(
			    CRYPT_WIRE_ONLY_RETRIEVAL |
				CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
				CRYPT_LDAP_SIGN_RETRIEVAL,
			    pwszURL);
    if (NULL == hEnterpriseStore)
    {
        hr = myHLastError();
	_JumpError(hr, error, "myUrlCertOpenStore");
    }
    *phCertStore = hEnterpriseStore;
    hr = S_OK;
    
error:
    if (NULL != pwszURL)
    {
        LocalFree(pwszURL);
    }
    return(hr);
}


HRESULT
pkcsVerifyRootRevocationStatus(
    IN OUT CACTX *pCAContext,
    OUT BOOL *pfRevoked)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cb;
    BSTR strHash = NULL;
    ICertDBRow *prow = NULL;
    DWORD Disposition;

    *pfRevoked = FALSE;
    cb = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pCAContext->pccCA,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    hr = MultiByteIntegerToBstr(TRUE, cb, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = g_pCertDB->OpenRow(
		    PROPOPEN_READONLY | PROPOPEN_CERTHASH | PROPTABLE_REQCERT,
		    0,
		    strHash,
		    &prow);
    _JumpIfError(hr, error, "OpenRow(xchg cert)");

    cb = sizeof(Disposition);
    hr = prow->GetProperty(
		    g_wszPropRequestDisposition,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cb,
		    (BYTE *) &Disposition);
    _JumpIfError(hr, error, "GetProperty(Disposition)");

    if (DB_DISP_CA_CERT == Disposition)
    {
	DWORD Reason;
	FILETIME ftRevoked;
	FILETIME ftCurrent;
	
	cb = sizeof(Reason);
	hr = prow->GetProperty(
			g_wszPropRequestRevokedReason,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cb,
			(BYTE *) &Reason);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	    goto error;
	}
	_JumpIfError(hr, error, "GetProperty(Reason)");

	cb = sizeof(ftRevoked);
	hr = prow->GetProperty(
			g_wszPropRequestRevokedEffectiveWhen,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cb,
			(BYTE *) &ftRevoked);

	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	    goto error;
	}
	_JumpIfError(hr, error, "GetProperty(RevokedEffectiveWhen)");

	GetSystemTimeAsFileTime(&ftCurrent);
	if (0 >= CompareFileTime(&ftRevoked, &ftCurrent))
	{
	    *pfRevoked = TRUE;
	}
    }
    hr = S_OK;

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != prow)
    {
	prow->Release();
    }
    return(hr);
}


HRESULT
pkcsVerifySignatureCertContext(
    IN OUT CACTX *pCAContext,
    IN HCERTSTORE hNTAuthStore)
{
    HRESULT hr;
    WCHAR awc[cwcDWORDSPRINTF];

    hr = myVerifyCertContext(
			pCAContext->pccCA,	// pCert
			0,			// dwFlags
			0,			// cUsageOids
			NULL,			// apszUsageOids
			HCCE_LOCAL_MACHINE,	// hChainEngine
			NULL,			// hAdditionalStore
			NULL);			// ppwszMissingIssuer
    _PrintIfError2(hr, "myVerifyCertContext", CRYPT_E_REVOCATION_OFFLINE);

    if (IsRootCA(g_CAType) &&
	(S_OK == hr ||
	 CERT_E_UNTRUSTEDROOT == hr ||
	 CRYPT_E_REVOCATION_OFFLINE == hr ||
	 CRYPT_E_NO_REVOCATION_CHECK == hr))
    {
	HRESULT hr2;
	BOOL fRevoked;

	hr2 = pkcsVerifyRootRevocationStatus(pCAContext, &fRevoked);
	_PrintIfError2(hr2, "pkcsVerifyRootRevocationStatus", CERTSRV_E_PROPERTY_EMPTY);
	if (S_OK == hr2 && fRevoked)
	{
	    hr = CRYPT_E_REVOKED;
	    _PrintError(hr, "pkcsVerifyRootRevocationStatus");
	}
	else
	{
	    FILETIME ftCurrent;
	    
	    GetSystemTimeAsFileTime(&ftCurrent);
	    if (0 < CompareFileTime(
			    &ftCurrent,
			    &pCAContext->pccCA->pCertInfo->NotAfter))
	    {
		hr = CERT_E_EXPIRED;
		_PrintError(hr, "CA certificate is expired");
	    }
	}
    }
    pCAContext->hrVerifyStatus = hr;
    if (S_OK != hr)
    {
	DWORD LogMsg = MAXDWORD;
	DWORD dwLogTypeOld = EVENTLOG_INFORMATION_TYPE;
	DWORD dwLogTypeCurrent = EVENTLOG_ERROR_TYPE;

	if (CERT_E_EXPIRED == hr)
	{
	    DBGCODE(DWORD f = pCAContext->Flags);

	    pCAContext->Flags |= CTXF_EXPIRED;

	    if (0 == (CRLF_PUBLISH_EXPIRED_CERT_CRLS & g_dwCRLFlags))
	    {
		pCAContext->Flags |= CTXF_SKIPCRL;
	    }
	    DBGPRINT((
		DBG_SS_CERTSRVI,
		"pkcsVerifySignatureCertContext(%u.%u) EXPIRED, f=%x->%x, hr=%x\n",
		pCAContext->iCert,
		pCAContext->iKey,
		f,
		pCAContext->Flags,
		hr));
	    LogMsg = MSG_E_CA_CERT_EXPIRED;
	}
	else if (CRYPT_E_REVOKED == hr || CERT_E_REVOKED == hr)
	{
	    pCAContext->Flags |= CTXF_REVOKED | CTXF_SKIPCRL;
	    LogMsg = MSG_E_CA_CERT_REVOKED;
	    dwLogTypeOld = EVENTLOG_WARNING_TYPE;
	}
	else if (CRYPT_E_REVOCATION_OFFLINE == hr)
	{
	    HRESULT hr2;
	    DWORD dwState;

	    hr2 = GetSetupStatus(NULL, &dwState);
	    if ((S_OK != hr2 || 0 == (SETUP_CREATEDB_FLAG & dwState)) &&
		CERTLOG_WARNING <= g_dwLogLevel)
	    {
		LogMsg = MSG_E_CA_CERT_REVOCATION_OFFLINE;
		dwLogTypeCurrent = EVENTLOG_WARNING_TYPE;
	    }
	    else
	    {
		hr = S_OK;
	    }
	}
	else if (CRYPT_E_NO_REVOCATION_CHECK == hr)
	{
	    if (CERTLOG_VERBOSE <= g_dwLogLevel)
	    {
		LogMsg = MSG_E_CA_CERT_REVOCATION_NOT_CHECKED;
		dwLogTypeCurrent = EVENTLOG_WARNING_TYPE;
	    }
	    else
	    {
		hr = S_OK;
	    }
	}
	else
	{
	    LogMsg = MSG_E_CA_CHAIN;
	}

	if (S_OK != hr)
	{
	    WCHAR const *apwsz[3];
	    WCHAR awchr[cwcHRESULTSTRING];

	    CSASSERT(MAXDWORD != LogMsg);
            wsprintf(awc, L"%u", pCAContext->iCert);
            apwsz[0] = g_wszCommonName;
	    apwsz[1] = myGetErrorMessageText(hr, TRUE);
	    if (NULL == apwsz[1])
	    {
		apwsz[1] = myHResultToString(awchr, hr);
	    }
            apwsz[2] = awc;

            LogEvent(
		pCAContext->iCert + 1 < g_cCACerts?
		    dwLogTypeOld : dwLogTypeCurrent,
		LogMsg,
		ARRAYSIZE(apwsz),
		apwsz);

	    if (NULL != apwsz[1] && awchr != apwsz[1])
	    {
		LocalFree(const_cast<WCHAR *>(apwsz[1]));
	    }
	}
	_JumpIfError(hr, error, "myVerifyCertContext");
    }

    // The CA's certificate looks good.  We verify the CA's certificate
    // is in the NTAuth store

    if (NULL != hNTAuthStore)
    {
	CERT_CONTEXT const *pCertContext;

        pCertContext = pkcsFindCertificateInStore(
						hNTAuthStore,
						pCAContext->pccCA);
        if (NULL == pCertContext)
        {
	    WCHAR const *apwsz[2];

            wsprintf(awc, L"%u", pCAContext->iCert);
            apwsz[0] = awc;
            apwsz[1] = g_wszCommonName;

            LogEvent(
		EVENTLOG_WARNING_TYPE,
		MSG_CA_CERT_NO_IN_AUTH,
		ARRAYSIZE(apwsz),
		apwsz);
        }
        if (NULL != pCertContext)
	{
            CertFreeCertificateContext(pCertContext);
	}
    }

error:
    return(hr);
}


HRESULT
pkcsVerifySignatureCertContextArray()
{
    HRESULT hr;
    DWORD i;
    HCERTSTORE hNTAuthStore = NULL;

    CSASSERT(0 != g_cCACerts);

    // We need to verify CA's certificates should be in the NTAuth store
    // if the certificate is not yet expired or revoked

    if (IsEnterpriseCA(g_CAType))
    {
        hr = pkcsObtainDSStore(g_wszLDAPNTAuthURLTemplate, &hNTAuthStore);
	_PrintIfError(hr, "pkcsObtainDSStore");
	if (NULL == hNTAuthStore)
	{
	    WCHAR const *pwszCommonName = g_wszCommonName;

            LogEvent(
		EVENTLOG_WARNING_TYPE,
		MSG_CA_CERT_NO_AUTH_STORE,
		1,
		&pwszCommonName);
	}
    }

    hr = S_OK;
    for (i = 0; i < g_cCACerts; i++)
    {
	CACTX *pCAContext = &g_aCAContext[i];

	if (NULL == pCAContext->pccCA)
	{
	    continue;
	}

	// Ignore all errors except for the current CA (last array entry)

	hr = pkcsVerifySignatureCertContext(pCAContext, hNTAuthStore);
	_PrintIfError(hr, "pkcsVerifySignatureCertContext");
    }

//error:
    if (NULL != hNTAuthStore)
    {
        CertCloseStore(hNTAuthStore, 0);
    }
    return(hr);
}


HRESULT
PKCSVerifyCAState(
    IN OUT CACTX *pCAContext)
{
    HRESULT hr;
    
    if (0 == (~CTXF_SKIPCRL & pCAContext->Flags) && 
        NULL != pCAContext->pccCA)
    {
	hr = pkcsVerifySignatureCertContext(pCAContext, NULL);
	_JumpIfError(hr, error, "pkcsVerifySignatureCertContext");
    }
    hr = pCAContext->hrVerifyStatus;

error:
    return(hr);
}


HRESULT
pkcsVerifyDSCACert(
    IN LDAP *pld)
{
    HRESULT hr;
    HCAINFO hCAInfo = NULL;
    CERT_CONTEXT const *pDSCertContext = NULL;

    CSASSERT(NULL != g_pCAContextCurrent && NULL != g_pCAContextCurrent->pccCA);

    hr = CAFindByName(
		g_pwszSanitizedDSName,
		(LPCWSTR) pld,
		CA_FIND_LOCAL_SYSTEM |
		    CA_FIND_INCLUDE_UNTRUSTED | // skip CA cert checking
		    CA_FLAG_SCOPE_IS_LDAP_HANDLE,
		&hCAInfo);
    _JumpIfErrorStr(hr, error, "CAFindByName", g_wszSanitizedName);

    hr = CAGetCACertificate(hCAInfo, &pDSCertContext);
    _JumpIfError(hr, error, "CAGetCACertificate");

    if (!pDSCertContext ||
        pDSCertContext->cbCertEncoded !=
	    g_pCAContextCurrent->pccCA->cbCertEncoded ||
        0 != memcmp(
		pDSCertContext->pbCertEncoded,
                g_pCAContextCurrent->pccCA->pbCertEncoded,
                g_pCAContextCurrent->pccCA->cbCertEncoded))
    {
        // published cert is invalid or old, publish the current one

        hr = CASetCACertificate(hCAInfo, g_pCAContextCurrent->pccCA);
        _JumpIfError(hr, error, "CASetCACertificate");

        hr = CAUpdateCA(hCAInfo);
        _JumpIfError(hr, error, "CAUpdateCA");

        {
            CAuditEvent audit(SE_AUDITID_CERTSRV_PUBLISHCACERT, g_dwAuditFilter);
	    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
	    DWORD cbHash;

	    cbHash = sizeof(abHash);
	    if (!CertGetCertificateContextProperty(
					g_pCAContextCurrent->pccCA,
					CERT_SHA1_HASH_PROP_ID,
					abHash,
					&cbHash))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertGetCertificateContextProperty");
	    }

	    // %1 Certificate Hash

            hr = audit.AddData(abHash, cbHash);
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = audit.AddData(g_pCAContextCurrent->pccCA->pCertInfo->NotBefore); // %2 Valid From
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = audit.AddData(g_pCAContextCurrent->pccCA->pCertInfo->NotAfter); //%3 Valid To
            _JumpIfError(hr, error, "CAuditEvent::AddData");

            hr = audit.Report();
            _JumpIfError(hr, error, "CAuditEvent::Report");
        }
    }
    hr = S_OK;

error:
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    if (NULL != pDSCertContext)
    {
        CertFreeCertificateContext(pDSCertContext);
    }
    return(hr);
}


// Verify all of this CA's unexpired signature certs are in the DS.
// Republish any that aren't.  Cleans up DS replication conflicts.

HRESULT
pkcsPublishCAContextArray(
    IN LDAP *pld)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;
    HCERTSTORE hAIAStore = NULL;
    WCHAR *pwszDSError = NULL;
    WCHAR *pwszURL = NULL;
    WCHAR *pwszDN;

    CSASSERT(0 != g_cCACerts);

    // We need to verify each CA certificate is in the DS AIA store,
    // if not yet expired or revoked

    hr = pkcsObtainDSStore(g_wszzLDAPIssuerCertURLTemplate, &hAIAStore);
    _JumpIfError(hr, error, "pkcsObtainDSStore");

    CSASSERT(NULL != hAIAStore);

    hr = pkcsExpandURL(g_wszzLDAPIssuerCertURLTemplate, FALSE, &pwszURL);
    _JumpIfError(hr, error, "pkcsExpandURL");

    pwszDN = pwszURL;
    for (i = 0; i < 3; i++)
    {
	pwszDN = wcschr(pwszDN, L'/');
	if (NULL == pwszDN)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad pwszURL");
	}
	pwszDN++;
    }

    for (i = 0; i < g_cCACerts; i++)
    {
	CACTX *pCAContext = &g_aCAContext[i];
	CERT_CONTEXT const *pcc;
	BOOL fDelete;
	DWORD dwDisposition;
	WCHAR awc[cwcDWORDSPRINTF];
	WCHAR const *apwsz[4];

	if (NULL == pCAContext->pccCA)
	{
	    continue;
	}

	// Ignore verify errors except for the current CA (last array entry)

	fDelete = FALSE;
	hr = PKCSVerifyCAState(pCAContext);
	if (S_OK != hr)
	{
	    _PrintError(hr, "PKCSVerifyCAState");
	    fDelete = pkcsShouldDelete(pCAContext, FALSE);
	    if (!fDelete)
	    {
	    	continue;	// don't publish/delete: (transient invalidity?)
	    }
	}

        pcc = pkcsFindCertificateInStore(hAIAStore, pCAContext->pccCA);
        if (NULL != pcc)
        {
            CertFreeCertificateContext(pcc);
	    if (!fDelete)
	    {
		continue;	// don't publish if already published
	    }
	}
	else
	{
	    if (fDelete)
	    {
		continue;	// don't delete if already deleted
	    }
	}
	if (NULL != pwszDSError)
	{
	    LocalFree(pwszDSError);
	    pwszDSError = NULL;
	}
	hr2 = myLdapPublishCertToDS(
			    pld,
			    pCAContext->pccCA,
			    pwszDN,
			    wszDSCACERTATTRIBUTE,
			    LPC_CAOBJECT | LPC_CREATEOBJECT,
			    fDelete,
			    &dwDisposition,
			    &pwszDSError);

	wsprintf(awc, L"%u", pCAContext->iCert);
	apwsz[0] = awc;
	apwsz[1] = pwszDN;

	if (S_OK != hr2)
	{
	    WCHAR const *pwszError = NULL;
	    WCHAR awchr[cwcHRESULTSTRING];

	    apwsz[2] = pwszDSError;
	    pwszError = myGetErrorMessageText(hr2, TRUE);
	    apwsz[3] = pwszError;
	    if (NULL == apwsz[3])
	    {
		apwsz[3] = myHResultToString(awchr, hr2);
	    }
	    LogEvent(
		EVENTLOG_WARNING_TYPE,
		fDelete?
		    MSG_E_CANNOT_DELETE_INVALID_CA_CERT :
		    MSG_E_CANNOT_ADD_MISSING_CA_CERT,
		ARRAYSIZE(apwsz),
		apwsz);
	    if (NULL != pwszError)
	    {
		LocalFree(const_cast<WCHAR *>(pwszError));
	    }

	    _PrintErrorStr(dwDisposition, "myLdapPublishCertToDS", pwszDSError);
	    if (fDelete)
	    {
		_PrintErrorStr(hr2, "myLdapPublishCertToDS", L"Delete");
	    }
	    _PrintErrorStr(hr2, "myLdapPublishCertToDS", pwszDN);
	}
	else
	{
	    DBGPRINT((
		DBG_SS_CERTSRV,
		fDelete?
		    "Deleted CA Cert[%u] from %ws\n" :
		    "Published CA Cert[%u] to %ws\n",
		i,
		pwszDN));
	    LogEvent(
		EVENTLOG_INFORMATION_TYPE,
		fDelete?
		    MSG_E_DELETED_INVALID_CA_CERT :
		    MSG_E_ADDED_MISSING_CA_CERT,
		min(ARRAYSIZE(apwsz), 2),
		apwsz);
	}
    }
    _JumpIfError(hr, error, "pkcsPublishCAContextArray");

error:
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != pwszDSError)
    {
	LocalFree(pwszDSError);
    }
    if (NULL != hAIAStore)
    {
        CertCloseStore(hAIAStore, 0);
    }
    return(hr);
}


VOID
pkcsReleaseKRACertArray()
{
    DWORD i;

    if (NULL != g_aKRAContext)
    {
	for (i = 0; i < g_cKRACerts; i++)
	{
	    if (NULL != g_aKRAContext[i].pccKRA)
	    {
		CertFreeCertificateContext(g_aKRAContext[i].pccKRA);
	    }
	    if (NULL != g_aKRAContext[i].strKRAHash)
	    {
		SysFreeString(g_aKRAContext[i].strKRAHash);
	    }
	}
	LocalFree(g_aKRAContext);
	g_aKRAContext = NULL;
    }
    g_cKRACerts = 0;
}


HRESULT
pkcsLoadKRACertContext(
    IN DWORD iHash,
    IN OUT HCERTSTORE *phStore)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    BSTR strHash = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    DWORD LogMsg = 0;
    BOOL fReloaded;
    KRACTX *pKRAContext;

    DBGPRINT((DBG_SS_CERTSRV, "Loading KRA Cert[%u]:\n", iHash));

    fReloaded = FALSE;
    for (;;)
    {
	hr = myFindCACertByHashIndex(
				*phStore,
				g_wszSanitizedName,
				CSRH_CAKRACERT,
				iHash,
				NULL,		// pNameId
				&pcc);
	if (S_OK == hr)
	{
	    break;
	}
	if (fReloaded || CRYPT_E_NOT_FOUND != hr)
	{
	    _JumpError(hr, error, "myFindCACertByHashIndex");
	}
	_PrintError(hr, "myFindCACertByHashIndex");

	// The KRA cert is missing from the HKLM "kra" store -- look it up in
	// the DB, and put it back in the store.

	hr = pkcsReloadMissingCAOrKRACert(
				g_wszSanitizedName,
				CSRH_CAKRACERT,
				iHash,
				wszKRA_CERTSTORE);
	_JumpIfError(hr, error, "pkcsReloadMissingCAOrKRACert");

	CertCloseStore(*phStore, CERT_CLOSE_STORE_CHECK_FLAG);
	*phStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,			// hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_READONLY_FLAG,
			wszKRA_CERTSTORE);
	if (NULL == *phStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}
	fReloaded = TRUE;
    }

    hr = pkcsImportCAOrCrossOrKRACert(pcc, FALSE, DB_DISP_KRA_CERT, NULL);
    _JumpIfError(hr, error, "pkcsImportCAOrCrossOrKRACert");

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pcc,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    pKRAContext = &g_aKRAContext[g_cKRACerts];
    g_cKRACerts++;

    pKRAContext->pccKRA = pcc;
    pKRAContext->strKRAHash = strHash;
    strHash = NULL;
    pcc = NULL;

    // Ignore failure from here on -- collected data is optional

    hr = myVerifyKRACertContext(pKRAContext->pccKRA, g_dwVerifyCertFlags);
    pKRAContext->hrVerifyStatus = hr;
    if (S_OK != hr)
    {
	if (CERT_E_EXPIRED == hr)
	{
	    pKRAContext->Flags |= CTXF_EXPIRED;
	}
	else
	// Assume revoked for other errors
	// if (CRYPT_E_REVOKED == hr || CERT_E_REVOKED == hr)
	{
	    pKRAContext->Flags |= CTXF_REVOKED;
	}
	LogMsg = MSG_E_INVALID_KRA_CERT;
	_JumpError(hr, error, "myVerifyKRACertContext");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (0 == LogMsg)
	{
	    LogMsg = MSG_E_CANNOT_LOAD_KRA_CERT;
	}
	pkcsLogKRACertError(LogMsg, iHash, pcc, hr);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
pkcsLoadKRACertArray()
{
    HRESULT hr;
    DWORD iHash;
    DWORD cKRACerts;
    HCERTSTORE hStore = NULL;
    DWORD LogMsg = 0;
    DWORD cKRACertsValid;
    WCHAR wszDword0[cwcDWORDSPRINTF];
    WCHAR wszDword1[cwcDWORDSPRINTF];

    if (!g_fAdvancedServer)
    {
	LogMsg = MSG_E_KRA_NOT_ADVANCED_SERVER;
	hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
	_JumpError(hr, error, "!g_fAdvancedServer");
    }

    wszDword0[0] = L'\0';
    wszDword1[0] = L'\0';

    // open KRA store

    hStore = CertOpenStore(
		    CERT_STORE_PROV_SYSTEM_W,
		    X509_ASN_ENCODING,
		    NULL,			// hProv
		    CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
		    wszKRA_CERTSTORE);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }

    // find & load KRA certs

    hr = myGetCARegHashCount(g_wszSanitizedName, CSRH_CAKRACERT, &cKRACerts);
    if (S_OK == hr && 0 == cKRACerts)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    _JumpIfError(hr, error, "myGetCARegHashCount");

    g_aKRAContext = (KRACTX *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cKRACerts * sizeof(g_aKRAContext[0]));
    if (NULL == g_aKRAContext)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    cKRACertsValid = 0;
    for (iHash = 0; iHash < cKRACerts; iHash++)
    {
	hr = pkcsLoadKRACertContext(iHash, &hStore);
	_PrintIfError(hr, "pkcsLoadKRACertContext");
	if (S_OK == hr)
	{
	    cKRACertsValid++;
	}
    }
    if (0 == cKRACertsValid || g_cKRACertsRoundRobin > cKRACertsValid)
    {
	wsprintf(wszDword0, L"%u", cKRACertsValid);
	wsprintf(wszDword1, L"%u", g_cKRACertsRoundRobin);
	LogMsg = MSG_E_TOO_FEW_VALID_KRA_CERTS;

	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "cKRACertsValid");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (MSG_E_TOO_FEW_VALID_KRA_CERTS == LogMsg)
	{
	    WCHAR const *apwsz[2];

	    apwsz[0] = wszDword0;
	    apwsz[1] = wszDword1;

	    LogEvent(EVENTLOG_ERROR_TYPE, LogMsg, ARRAYSIZE(apwsz), apwsz);
	}
	else
	{
	    if (0 == LogMsg)
	    {
		LogMsg = MSG_E_LOADING_KRA_CERTS;
	    }
	    LogEventHResult(EVENTLOG_ERROR_TYPE, LogMsg, hr);
	}
	pkcsReleaseKRACertArray();
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
pkcsPatchDN(
    IN HRESULT hrFail,
    IN WCHAR const *pwszRegName,
    IN OUT BSTR *pstrDSValue)
{
    HRESULT hr;
    WCHAR *pwszRegValue = NULL;
    
    hr = myGetCertRegStrValue(
		    g_wszSanitizedName,
		    NULL,
		    NULL,
		    pwszRegName,
		    &pwszRegValue);
    _PrintIfErrorStr(hr, "myGetCertRegStrValue", pwszRegName);

    // If the DS DN was retrieved, make sure the registry matches

    if (NULL != *pstrDSValue)
    {
	if (NULL == pwszRegValue || 0 != lstrcmp(*pstrDSValue, pwszRegValue))
	{
	    // set reg value

	    hr = mySetCertRegStrValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    pwszRegName,
			    *pstrDSValue);
	    _PrintIfErrorStr(hr, "mySetCertRegStrValue", pwszRegName);
	}
    }

    // Else if the registry DN was retrieved, just use it

    else
    if (NULL != pwszRegValue && L'\0' != *pwszRegValue)
    {
	if (!myConvertWszToBstr(pstrDSValue, pwszRegValue, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertWszToBstr");
	}
    }

    // If neither DN was retrieved, fail if g_fUsedDS or alloc an empty string:

    else
    {
	if (g_fUseDS)
	{
	    hr = hrFail;
	    _JumpError(hr, error, "both DS and Reg NULL");
	}
	*pstrDSValue = SysAllocString(L"");
	if (NULL == *pstrDSValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "SysAllocString");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszRegValue)
    {
	LocalFree(pwszRegValue);
    }
    return(hr);
}


HRESULT
pkcsGetAuthoritativeDomainDn(
    IN WCHAR const *pwszCommonName,
    OUT LDAP **ppld,
    OUT BSTR *pstrDomainDN,
    OUT BSTR *pstrConfigDN)
{
    HRESULT hr;
    HRESULT hr2;

    // Get domain and config containers (%5, %6)

    *ppld = NULL;
    *pstrDomainDN = NULL;
    *pstrConfigDN = NULL;

    hr2 = S_OK;
    if (g_fUseDS)
    {
	hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			ppld,
			NULL);			  // ppwszForestDNSName
	if (S_OK != hr)
	{
	    _PrintError(hr, "myRobustLdapBindEx");
	}
	else
	{
	    hr = myGetAuthoritativeDomainDn(*ppld, pstrDomainDN, pstrConfigDN);
	    _PrintIfError(hr, "myGetAuthoritativeDomainDn");
	}
	if (S_OK != hr)
	{
	    LogEventStringHResult(
			EVENTLOG_ERROR_TYPE,
			MSG_E_DS_RETRY,
			pwszCommonName,
			hr);
	}
	hr2 = hr;
    }
    hr = pkcsPatchDN(hr2, wszREGDSCONFIGDN, pstrConfigDN);
    _JumpIfError(hr, error, "pkcsPatchDN");

    hr = pkcsPatchDN(hr2, wszREGDSDOMAINDN, pstrDomainDN);
    _JumpIfError(hr, error, "pkcsPatchDN");

error:
    return(hr);
}

HRESULT
PKCSSetup(
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    LDAP *pld = NULL;
    DWORD LogMsg = MAXDWORD;
    BOOL fWarn = FALSE;

    g_dwVerifyCertFlags = 0;
    if (CRLF_REVCHECK_IGNORE_OFFLINE & g_dwCRLFlags)
    {
	g_dwVerifyCertFlags |= CA_VERIFY_FLAGS_IGNORE_OFFLINE;
    }
    if (CRLF_REVCHECK_IGNORE_NOREVCHECK & g_dwCRLFlags)
    {
	g_dwVerifyCertFlags |= CA_VERIFY_FLAGS_IGNORE_NOREVCHECK;
    }
    // set crypt handles and load certificate chain

    __try
    {
	InitializeCriticalSection(&g_critsecCAXchg);
	g_fcritsecCAXchg = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    hr = pkcsGetAuthoritativeDomainDn(
				pwszCommonName,
				&pld,
				&g_strDomainDN,
				&g_strConfigDN);
    if (S_OK != hr)
    {
	LogMsg = MSG_E_NO_DS;
	_JumpError(hr, error, "pkcsGetAuthoritativeDomainDn");
    }

    // get (multiple) CRL path templates

    hr = pkcsLoadURLTemplates(
		    wszREGCRLPUBLICATIONURLS,
		    &g_paRevURL,
		    &g_caRevURL);
    _PrintIfErrorStr(hr, "pkcsLoadURLTemplates", wszREGCRLPUBLICATIONURLS);

    // get (multiple) CA Cert path templates

    hr = pkcsLoadURLTemplates(
		    wszREGCACERTPUBLICATIONURLS,
		    &g_paCACertURL,
		    &g_caCACertURL);
    _PrintIfErrorStr(hr, "pkcsLoadURLTemplates", wszREGCACERTPUBLICATIONURLS);

    hr = DBOpen(pwszSanitizedName);
    if (S_OK != hr)
    {
	LogMsg = MSG_E_DB_INIT_FAILED;
	_JumpError(hr, error, "PKCSSetup:DBOpen");
    }

    hr = pkcsLoadCAContextArray(pwszSanitizedName);
    if (S_OK != hr)
    {
	LogMsg = MSG_E_CA_CERT_INVALID;
	_JumpError(hr, error, "pkcsLoadCAContextArray");
    }

    hr = pkcsVerifySignatureCertContextArray();
    {
	// Import the certs into the database even if there were errors.
	// Import them after verifying them so we can delete revoked and
	// expired CA certs from various locations.
	
	HRESULT hr2 = pkcsImportCAContextArray();
	_PrintIfError(hr2, "pkcsImportCAContextArray");
    }
    if (S_OK != hr)
    {
	LogMsg = MSG_E_CA_CERT_INVALID;
	_JumpError(hr, error, "pkcsVerifySignatureCertContextArray");
    }

    if (0 != g_cKRACertsRoundRobin)
    {
	hr = pkcsLoadKRACertArray();
	_PrintIfError(hr, "pkcsLoadKRACertArray");
    }

    hr = pkcsExpandURL(
		g_wszzLDAPKRACertURLTemplate,
		FALSE,
		&g_pwszKRAPublishURL);
    _JumpIfError(hr, error, "pkcsExpandURL");

    hr = pkcsExpandURL(
		g_wszzLDAPIssuerCertURLTemplate,
		FALSE,
		&g_pwszAIACrossCertPublishURL);
    _JumpIfError(hr, error, "pkcsExpandURL");

    hr = pkcsExpandURL(
		g_wszLDAPRootTrustURLTemplate,
		FALSE,
		&g_pwszRootTrustCrossCertPublishURL);
    _JumpIfError(hr, error, "pkcsExpandURL");

    if (IsRootCA(g_CAType) &&
	0 == (CRLF_DISABLE_ROOT_CROSS_CERTS & g_dwCRLFlags))
    {
	hr = pkcsLoadCrossCertArray();
	_PrintIfError(hr, "pkcsLoadCrossCertArray");
    }
    if (NULL != pld)
    {
	hr = pkcsVerifyDSCACert(pld);
	_PrintIfError(hr, "pkcsVerifyDSCACert");

	hr = pkcsPublishCAContextArray(pld);
	_PrintIfError(hr, "pkcsPublishCAContextArray");
    }
    hr = S_OK;

error:
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
    if (S_OK != hr)
    {
	if (MAXDWORD == LogMsg)
	{
	    LogMsg = MSG_E_GENERIC_STARTUP_FAILURE;
	}
	PKCSTerminate();
	LogEventStringHResult(
			EVENTLOG_ERROR_TYPE,
			LogMsg,
			pwszCommonName,
			hr);
	if (fWarn)
	{
	    hr = S_OK;
	}
    }
    return(hr);
}


VOID
pkcsReleaseCACertificateChain(
    CERT_CONTEXT const **apCACertChain,
    DWORD                cCACertChain)
{
    DWORD i;

    if (NULL != apCACertChain)
    {
	for (i = 0; i < cCACertChain; ++i)
	{
	    CertFreeCertificateContext(apCACertChain[i]);
	}
	LocalFree(apCACertChain);
    }
}


VOID
pkcsReleaseCAContext(
    IN OUT CACTX *pCAContext)
{
    pkcsReleaseCACertificateChain(
			    pCAContext->apCACertChain,
			    pCAContext->cCACertChain);
    //pCAContext->apCACertChain = NULL;
    //pCAContext->pccCA = NULL;
    if (NULL != pCAContext->hProvCA)
    {
	CryptReleaseContext(pCAContext->hProvCA, 0);
    }
    if (NULL != pCAContext->IssuerKeyId.pbData)
    {
	LocalFree(pCAContext->IssuerKeyId.pbData);
    }
    if (NULL != pCAContext->pszObjIdSignatureAlgorithm)
    {
	LocalFree(pCAContext->pszObjIdSignatureAlgorithm);
    }
    if (NULL != pCAContext->KeyAuthority2Cert.pbData)
    {
	LocalFree(pCAContext->KeyAuthority2Cert.pbData);
    }
    if (NULL != pCAContext->KeyAuthority2CRL.pbData)
    {
	LocalFree(pCAContext->KeyAuthority2CRL.pbData);
    }
    if (NULL != pCAContext->CDPCert.pbData)
    {
	LocalFree(pCAContext->CDPCert.pbData);
    }
    if (NULL != pCAContext->CDPCRLFreshest.pbData)
    {
	LocalFree(pCAContext->CDPCRLFreshest.pbData);
    }
    if (NULL != pCAContext->CDPCRLBase.pbData)
    {
	LocalFree(pCAContext->CDPCRLBase.pbData);
    }
    if (NULL != pCAContext->CDPCRLDelta.pbData)
    {
	LocalFree(pCAContext->CDPCRLDelta.pbData);
    }
    if (NULL != pCAContext->AIACert.pbData)
    {
	LocalFree(pCAContext->AIACert.pbData);
    }
    if (NULL != pCAContext->pwszKeyContainerName)
    {
	LocalFree(pCAContext->pwszKeyContainerName);
    }
    if (NULL != pCAContext->papwszCRLFiles)
    {
	WCHAR **ppwsz;

	for (ppwsz = pCAContext->papwszCRLFiles; NULL != *ppwsz; ppwsz++)
	{
	    LocalFree(*ppwsz);
	}
	LocalFree(pCAContext->papwszCRLFiles);
    }
    if (NULL != pCAContext->papwszDeltaCRLFiles)
    {
	WCHAR **ppwsz;

	for (ppwsz = pCAContext->papwszDeltaCRLFiles; NULL != *ppwsz; ppwsz++)
	{
	    LocalFree(*ppwsz);
	}
	LocalFree(pCAContext->papwszDeltaCRLFiles);
    }
}


VOID
pkcsReleaseCACrossContextArray(
    IN OUT CACROSSCTX **prgCACross)
{
    DWORD i;
    CACROSSCTX *pCACross = *prgCACross;

    if (NULL != pCACross)
    {
	for (i = 0; i < g_cCACerts; i++)
	{
	    if (NULL != pCACross[i].pccCACross)
	    {
		CertFreeCertificateContext(pCACross[i].pccCACross);
	    }
	}
	LocalFree(pCACross);
	*prgCACross = NULL;
    }
}


VOID
pkcsReleaseCAContextArray()
{
    DWORD i;

    pkcsReleaseCACrossContextArray(&g_aCACrossForward);
    pkcsReleaseCACrossContextArray(&g_aCACrossBackward);
    if (NULL != g_aCAContext)
    {
	for (i = 0; i < g_cCACerts; i++)
	{
	    pkcsReleaseCAContext(&g_aCAContext[i]);
	}
	LocalFree(g_aCAContext);
	g_aCAContext = NULL;
    }
    g_cCACerts = 0;
    g_pCAContextCurrent = NULL;
}


// Trim  off leading and trailing whitespace and separator characters

WCHAR *
pkcsTrimToken(
    IN WCHAR *pwszIn,
    IN WCHAR wchSeparator)
{
    WCHAR *pwsz;

    while (wchSeparator == *pwszIn || iswspace(*pwszIn))
    {
	pwszIn++;
    }
    pwsz = &pwszIn[wcslen(pwszIn)];
    while (--pwsz >= pwszIn &&
	(wchSeparator == *pwsz || iswspace(*pwsz)))
    {
	*pwsz = L'\0';
    }
    if (L'\0' == *pwszIn)
    {
	pwszIn = NULL;
    }
    return(pwszIn);
}


WCHAR *
PKCSSplitToken(
    IN OUT WCHAR **ppwszIn,
    IN WCHAR *pwcSeparator,
    OUT BOOL *pfSplit)
{
    WCHAR *pwszOut = NULL;
    WCHAR *pwszNext = NULL;
    BOOL fSplit = FALSE;
    WCHAR *pwszIn;
    WCHAR *pwsz;

    pwszIn = *ppwszIn;
    if (NULL != pwszIn)
    {
	pwszOut = pwszIn;
	if (NULL != pwcSeparator)
	{
	    pwsz = wcschr(pwszIn, *pwcSeparator);
	    if (NULL != pwsz)
	    {
		*pwsz = L'\0';

		pwszNext = pkcsTrimToken(&pwsz[1], *pwcSeparator);
		pwszOut = pkcsTrimToken(pwszOut, *pwcSeparator);
		fSplit = TRUE;
	    }
	}
    }
    *ppwszIn = pwszNext;
    *pfSplit = fSplit;
    return(pwszOut);
}


HRESULT
PKCSSetSubjectTemplate(
    IN WCHAR const *pwszzTemplate)
{
    HRESULT hr;
    WCHAR const *pwszz;
    WCHAR const *pwszPropName;
    SUBJECTTABLE const **ppSubject;
    SUBJECTTABLE const **pps;
    SUBJECTTABLE *pSubject;
    DWORD dwIndex;
    DWORD cchMax;

    hr = E_INVALIDARG;
    if (NULL == pwszzTemplate)
    {
	_JumpError(hr, error, "pwszzTemplate NULL");
    }
    ppSubject = pkcs_apSubject; // fill in this empty subject array with string matches

    for (pwszz = pwszzTemplate; L'\0' != *pwszz; pwszz += wcslen(pwszz) + 1)
    {
	pwszPropName = PKCSMapAttributeName(pwszz, NULL, &dwIndex, &cchMax);
	if (NULL == pwszPropName)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "PKCSMapAttributeName", pwszz);
	}

	for (pSubject = pkcs_subject; ; pSubject++)
	{
	    if (NULL == pSubject->pwszPropName)
	    {
		_JumpError(hr, error, "pkcs_subject lookup");
	    }
	    if (0 == mylstrcmpiS(pwszPropName, pSubject->pwszPropName))
	    {
		break;
	    }
	}
	for (pps = pkcs_apSubject; pps < ppSubject; pps++)
	{
	    if (*pps == pSubject)
	    {
		_JumpErrorStr(hr, error, "pkcs_subject duplicate", pwszz);
	    }
	}
	if (ppSubject >= &pkcs_apSubject[CSUBJECTTABLE])
	{
	    _JumpError(hr, error, "pkcs_subject overflow");
	}
	pSubject->dwSubjectTemplateIndex = SAFE_SUBTRACT_POINTERS(
							    ppSubject,
							    pkcs_apSubject);
	*ppSubject++ = pSubject;

	DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "Subject Template[%u] <== Subject[%u]: %hs -- %ws\n",
	    pSubject->dwSubjectTemplateIndex,
	    pSubject->dwSubjectTableIndex,
	    pSubject->pszObjId,
	    pSubject->pwszPropName));
    }
    CSASSERT(ppSubject <= &pkcs_apSubject[CSUBJECTTABLE]);

    if (ppSubject == pkcs_apSubject)
    {
	_JumpError(hr, error, "pwszzTemplate empty");
    }
    pkcs_ppSubjectLast = ppSubject - 1;
    pkcsfSubjectTemplate = TRUE;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsSplitRDNComponents(
    IN SUBJECTTABLE const *pSubjectTable,
    IN OUT WCHAR *pwszRDN,	// Parsing stomps string in-place
    IN DWORD cAttrMax,
    OUT DWORD *pcAttr,
    OUT CERT_RDN_ATTR *rgAttr)
{
    HRESULT hr;
    DWORD cAttr;
    DWORD i;
    DWORD cwc;
    WCHAR *pwszRemain;
    WCHAR const *pwszToken;
    WCHAR *pwszT;
    BOOL fSplit;

    *pcAttr = 0;
    cAttr = 0;
    if (NULL != pwszRDN)
    {
	// Allocate memory for each RDN component filled in:

	pwszRemain = pwszRDN;
	for (;;)
	{
	    pwszToken = PKCSSplitToken(
				&pwszRemain,
				wszNAMESEPARATORDEFAULT,
				&fSplit);
	    if (NULL == pwszToken)
	    {
		break;
	    }

	    if (cAttr >= cAttrMax)
	    {
		hr = CERTSRV_E_BAD_REQUESTSUBJECT;
		_JumpError(hr, error, "Subject RDN overflow");
	    }

	    cwc = wcslen(pwszToken);
	    if (g_fEnforceRDNNameLengths && cwc > pSubjectTable->cchMax)
	    {
		DBGPRINT((
		    DBG_SS_CERTSRV,
		    "RDN component too long: %u/%u: %ws[%u]=\"%ws\"\n",
		    cwc,
		    pSubjectTable->cchMax,
		    pSubjectTable->pwszPropName,
		    cAttr,
		    pwszToken));
		hr = CERTSRV_E_BAD_REQUESTSUBJECT;
		_JumpErrorStr(hr, error, "RDN component too long", pwszToken);
	    }
	    pwszT = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	    if (NULL == pwszT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc(pwszToken)");
	    }
	    wcscpy(pwszT, pwszToken);

	    rgAttr[cAttr].pszObjId = (char *) pSubjectTable->pszObjId;
	    rgAttr[cAttr].dwValueType = CERT_RDN_ANY_TYPE;  // 'best' encoding
	    rgAttr[cAttr].Value.pbData = (BYTE *) pwszT;
	    rgAttr[cAttr].Value.cbData = 0;	// Indicate Unicode input

	    cAttr++;
	}
    }
    *pcAttr = cAttr;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	for (i = 0; i < cAttr; i++)
	{
	    LocalFree(rgAttr[i].Value.pbData);
	}
    }
    return(hr);
}


#define CSUBJECTRDNMAX	(4 * CSUBJECTTABLE)

HRESULT
pkcsEncodeSubjectName(
    IN ICertDBRow *prow,
    IN CERT_RDN_ATTR const *rgAttr,
    IN DWORD cAttr,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    DWORD i;
    DWORD cbprop;
    DWORD dwRequestFlags;
    DWORD dwFlags;
    CERT_RDN rgRDN[CSUBJECTRDNMAX];
    CERT_NAME_INFO nameinfo;

    CSASSERT(ARRAYSIZE(rgRDN) >= cAttr);
    for (i = 0; i < cAttr; i++)
    {
	rgRDN[i].cRDNAttr = 1;
	rgRDN[i].rgRDNAttr = (CERT_RDN_ATTR *) &rgAttr[i];
    }
    nameinfo.cRDN = cAttr;
    nameinfo.rgRDN = rgRDN;

    cbprop = sizeof(dwRequestFlags);
    hr = prow->GetProperty(
			g_wszPropRequestFlags,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cbprop,
			(BYTE *) &dwRequestFlags);
    _JumpIfError(hr, error, "GetProperty");

    CSASSERT(sizeof(dwRequestFlags) == cbprop);
    dwFlags = 0;
    if (CR_FLG_FORCETELETEX & dwRequestFlags)
    {
	dwFlags |= CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    }
    if (CR_FLG_FORCEUTF8 & dwRequestFlags)
    {
	dwFlags |= CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;
    }

    if (!myEncodeName(
		X509_ASN_ENCODING,
		&nameinfo,
		dwFlags,
		CERTLIB_USE_LOCALALLOC,
		ppbData,
		pcbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeName");
    }

error:
    return(hr);
}


HRESULT
pkcsBuildSubjectFromNamesTable(
    IN ICertDBRow *prow,
    OUT CERT_NAME_BLOB *pSubject)
{
    HRESULT hr;
    DWORD cbData = 0;
    DWORD i;
    DWORD cAttr;
    DWORD cAttrT;
    CERT_RDN_ATTR rgAttr[CSUBJECTRDNMAX];
    SUBJECTTABLE const * const *ppSubject;
    WCHAR *pwszData = NULL;

    pSubject->pbData = NULL;
    CSASSERT(NULL != pkcs_ppSubjectLast);

    cAttr = 0;
    for (
	ppSubject = pkcs_ppSubjectLast;
	ppSubject >= pkcs_apSubject;
	ppSubject--)
    {
	hr = PKCSGetProperty(
		prow,
		(*ppSubject)->pwszPropName,
		PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		&cbData,
		(BYTE **) &pwszData);
	if (S_OK != hr)
	{
	    continue;
	}
	if (0 != cbData)
	{
	    // Allocates memory for each RDN component filled in:

	    hr = pkcsSplitRDNComponents(
				*ppSubject,
				pwszData,
				ARRAYSIZE(rgAttr) - cAttr,
				&cAttrT,
				&rgAttr[cAttr]);
	    _JumpIfError(hr, error, "SplitRDNComponents");

	    cAttr += cAttrT;
	}
	LocalFree(pwszData);
	pwszData = NULL;
    }

    // done building string of subject entries, time to encode

    hr = pkcsEncodeSubjectName(
		    prow,
		    rgAttr,
		    cAttr,
		    &pSubject->pbData,
		    &pSubject->cbData);
    _JumpIfError(hr, error, "pkcsEncodeSubjectName");

    hr = prow->SetProperty(
		g_wszPropSubjectRawName,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		pSubject->cbData,
		pSubject->pbData);
    _JumpIfError(hr, error, "SetProperty");

    pkcsSetDistinguishedName(prow, PROPTABLE_CERTIFICATE, pSubject);

error:
    for (i = 0; i < cAttr; i++)
    {
	LocalFree(rgAttr[i].Value.pbData);
    }
    if (NULL != pwszData)
    {
	LocalFree(pwszData);
    }
    return(hr);
}


HRESULT
pkcsCheck7f(
    IN ICertDBRow *prow,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    OUT BOOL *pfErrorLogged)
{
    HRESULT hr;
    WCHAR *pwszSubject = NULL;
    WCHAR const *pwszSubject2;
    WCHAR wszDword[cwcDWORDSPRINTF];
    WCHAR wszRequestId[cwcDWORDSPRINTF];
    WORD cString = 0;
    WCHAR const *apwsz[4];

    DWORD State;
    DWORD Index1;
    DWORD Index2;
    DWORD cwcField;
    WCHAR wszField[128];
    DWORD cwcObjectId;
    WCHAR wszObjectId[128];
    WCHAR const *pwszObjectIdDescription = NULL;
    WCHAR *wszBuf = NULL;
    const DWORD dwDefaultBufSize = 2048 * sizeof(WCHAR);

    *pfErrorLogged = FALSE;
    cwcField = sizeof(wszField)/sizeof(wszField[0]);
    cwcObjectId = sizeof(wszObjectId)/sizeof(wszObjectId[0]);
    hr = myCheck7f(
		pbCert,
		cbCert,
		FALSE,
		&State,
		&Index1,
		&Index2,
		&cwcField,
		wszField,
		&cwcObjectId,
		wszObjectId,
		&pwszObjectIdDescription);	// Static: do not free!
    _JumpIfError(hr, error, "myCheck7f");

    if (CHECK7F_NONE != State)
    {
	DWORD ReqId;

	wszBuf = (WCHAR *) LocalAlloc(LMEM_FIXED, dwDefaultBufSize);
	if (NULL == wszBuf)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	prow->GetRowId(&ReqId);
	wsprintf(wszRequestId, L"%u", ReqId);
	apwsz[cString++] = wszRequestId;
	apwsz[cString++] = wszDword;

	hr = PKCSGetProperty(
		    prow,
		    g_wszPropSubjectDistinguishedName,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    (BYTE **) &pwszSubject);
	pwszSubject2 = pwszSubject;
	if (S_OK != hr)
	{
	    _PrintError(hr, "GetProperty(DN)");
	    pwszSubject2 = g_pwszUnknownSubject;
	}
	apwsz[cString++] = pwszSubject2;

	wcscpy(wszBuf, wszField);
	if (0 != Index1)
	{
	    wsprintf(
		&wszBuf[wcslen(wszBuf)],
		0 != Index2? L"[%u,%u]" : L"[%u]",
		Index1 - 1,
		Index2 - 1);
	}

	if (0 != cwcObjectId)
	{
	    wcscat(wszBuf, L" ObjectId=");
	    wcscat(wszBuf, wszObjectId);
	}
	if (NULL != pwszObjectIdDescription)
	{
	    // If buffer too small, reallocate enough space for old buffer,
	    // OID description, () and trailing zero
	    DWORD dwBufLen = (wcslen(wszBuf)+wcslen(pwszObjectIdDescription)+3)*
			     sizeof(WCHAR);
	    if (dwDefaultBufSize < dwBufLen)
	    {
		WCHAR *pTempBuf = (WCHAR *) LocalReAlloc(
						    wszBuf,
						    dwBufLen,
						    LMEM_MOVEABLE);
		if (NULL == pTempBuf)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalReAlloc");
		}
		wszBuf = pTempBuf;
	    }
	    wcscat(wszBuf, L" (");
	    wcscat(wszBuf, pwszObjectIdDescription);
	    wcscat(wszBuf, L")");
	}
	apwsz[cString++] = wszBuf;

	hr = CERTSRV_E_ENCODING_LENGTH;
	wsprintf(wszDword, L"0x%x", hr);

	if (CERTLOG_ERROR <= g_dwLogLevel)
	{
	    LogEvent(
		EVENTLOG_ERROR_TYPE,
		MSG_E_BADCERTLENGTHFIELD,
		cString,
		apwsz);
	}
	CONSOLEPRINT4((
		    DBG_SS_CERTSRV,
		    "CertSrv Request %u: rc=%x: Bad encoded length detected: %ws \"%ws\"\n",
		    ReqId,
		    hr,
		    wszBuf,
		    pwszSubject));
	*pfErrorLogged = TRUE;
    }

error:
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    if (NULL != wszBuf)
    {
	LocalFree(wszBuf);
    }
    return(hr);
}


HRESULT
pkcsCreateCertSerialNumber(
    IN ICertDBRow *prow,
    IN CACTX const *pCAContext,
    OUT BSTR *pstrSerialNumber)
{
    HRESULT hr;
    DWORD dw;
    USHORT us;
    BYTE abRandom[8];
    BYTE abSerial[max(
      sizeof(dw) + sizeof(us) + sizeof(dw),
      sizeof(dw) + sizeof(us) + sizeof(abRandom) + sizeof(dw) + sizeof(BYTE))];
    BSTR strHighSerial = NULL;
    BSTR strSerialNumber = NULL;
    DWORD cbSerial;
    BYTE *pb;
    BOOL fCritSecEntered = FALSE;
//#define TEST_SPECIAL_SERIAL_NUMBERS
#ifdef TEST_SPECIAL_SERIAL_NUMBERS
    BOOL fAddZeroByte = FALSE;
#endif

    *pstrSerialNumber = NULL;
    pb = abSerial;

    prow->GetRowId(&dw);
    CopyMemory(pb, &dw, sizeof(dw));
    pb += sizeof(dw);

    us = (USHORT) pCAContext->iCert;
    CopyMemory(pb, &us, sizeof(us));
    pb += sizeof(us);

    if (MAXDWORD == g_dwHighSerial)
    {
	EnterCriticalSection(&g_critsecCAXchg);
	fCritSecEntered = TRUE;

	if (NULL == g_pbHighSerial)
	{
	    if (!CryptGenRandom(
			g_pCAContextCurrent->hProvCA,
			ARRAYSIZE(abRandom),
			abRandom))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptGenRandom");
	    }

	    g_pbHighSerial = (BYTE *) LocalAlloc(LMEM_FIXED, sizeof(abRandom));
	    if (NULL == g_pbHighSerial)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    g_cbHighSerial = sizeof(abRandom);
	    CopyMemory(g_pbHighSerial, abRandom, sizeof(abRandom));
	    hr = MultiByteIntegerToBstr(
				FALSE,
				sizeof(abRandom),
				abRandom,
				&strHighSerial);
	    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

	    hr = mySetCertRegStrValue(
			    g_wszSanitizedName,
			    NULL,
			    NULL,
			    g_wszRegHighSerial,
			    strHighSerial);
	    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", g_wszRegHighSerial);

	    g_dwHighSerial = 0;
	}
	if (fCritSecEntered)
	{
	    LeaveCriticalSection(&g_critsecCAXchg);
	    fCritSecEntered = FALSE;
	}
    }
    if (NULL != g_pbHighSerial)
    {
	DWORD cbLeft = sizeof(abSerial) - SAFE_SUBTRACT_POINTERS(pb, abSerial);

	if (g_cbHighSerial > cbLeft)
	{
	    g_cbHighSerial = cbLeft;
	}
	CopyMemory(pb, g_pbHighSerial, g_cbHighSerial);
	pb += g_cbHighSerial;
    }
    else
    if (0 != g_dwHighSerial)
    {
	if (!CryptGenRandom(
		    g_pCAContextCurrent->hProvCA,
		    ARRAYSIZE(abRandom),
		    abRandom))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptGenRandom");
	    memset(abRandom, g_dwHighSerial, sizeof(abRandom));
	}
	CopyMemory(pb, abRandom, sizeof(abRandom));
	pb += sizeof(abRandom);

	CopyMemory(pb, &dw, sizeof(dw));
	pb += sizeof(dw);

	*pb++ = (BYTE) g_dwHighSerial;
    }
    else
    {
	dw = GetTickCount();
	CopyMemory(pb, &dw, sizeof(dw));
	pb += sizeof(dw);
    }
    cbSerial = SAFE_SUBTRACT_POINTERS(pb, abSerial);

    // Make sure the serial number doesn't overflow the buffer:

    CSASSERT(sizeof(abSerial) >= cbSerial);

    // IETF max serial number length is 20 bytes:

    CSASSERT(20 >= cbSerial);

    pb--;
    if (0 == *pb)
    {
	*pb = 'a';
    }
    else if (0 == (0xf0 & *pb))
    {
	*pb |= 0x10;	// make high nibble non-zero
    }
    *pb &= 0x7f;	// Some clients can't handle negative serial numbers:
#ifdef TEST_SPECIAL_SERIAL_NUMBERS
    if (1 & abSerial[0])
    {
	*pb |= 0x80;	// Test negative serial numbers:
	if (2 & abSerial[0])
	{
	    *pb-- = 0;		// Test high zero byte serial numbers:
	    *pb |= 0x80;	// Test negative serial numbers:
	    fAddZeroByte = TRUE;
	}
    }
#endif

    hr = MultiByteIntegerToBstr(FALSE, cbSerial, abSerial, &strSerialNumber);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

#ifdef TEST_SPECIAL_SERIAL_NUMBERS
    if (fAddZeroByte)
    {
	BSTR str = NULL;

	str = SysAllocStringLen(NULL, 2 + wcslen(strSerialNumber));
	if (NULL != str)
	{
	    wcscpy(str, L"00");
	    wcscat(str, strSerialNumber);
	    SysFreeString(strSerialNumber);
	    strSerialNumber = str;
	}
    }
#endif

    *pstrSerialNumber = strSerialNumber;
    strSerialNumber = NULL;
    hr = S_OK;

error:
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_critsecCAXchg);
	fCritSecEntered = FALSE;
    }
    if (NULL != strHighSerial)
    {
	SysFreeString(strHighSerial);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
PKCSVerifySubjectRDN(
    OPTIONAL IN ICertDBRow *prow,
    IN OUT WCHAR const **ppwszPropertyName,
    OPTIONAL IN WCHAR const *pwszPropertyValue,
    OUT BOOL *pfSubjectDot)
{
    HRESULT hr;
    WCHAR const *pwsz;
    WCHAR const *pwszName = *ppwszPropertyName;
    WCHAR wszPrefix[ARRAYSIZE(wszPROPSUBJECTDOT)];
    SUBJECTTABLE const *pSubjectTable;
    DWORD i;
    DWORD cAttr = 0;
    CERT_RDN_ATTR rgAttr[CSUBJECTRDNMAX];
    WCHAR *pwszValue = NULL;
    DWORD cbData;
    BYTE *pbData = NULL;

    hr = S_OK;
    *pfSubjectDot = FALSE;

    // Check to see if the request is for L"Subject.".

    pwsz = wcschr(pwszName, L'.');
    if (NULL != pwsz &&
	SAFE_SUBTRACT_POINTERS(pwsz, pwszName) + 2 == ARRAYSIZE(wszPrefix))
    {
	pwsz++;		// skip past L'.'

	CopyMemory(
	    wszPrefix,
	    pwszName,
	    (SAFE_SUBTRACT_POINTERS(pwsz, pwszName) * sizeof(WCHAR)));
	wszPrefix[ARRAYSIZE(wszPrefix) - 1] = L'\0';

	if (0 == LSTRCMPIS(wszPrefix, wszPROPSUBJECTDOT))
	{
	    pwszName = pwsz;
	    if (L'\0' == *pwszName)
	    {
		*pfSubjectDot = TRUE;
	    }
	}
    }

    pSubjectTable = NULL;
    if (!*pfSubjectDot)
    {
	for (pSubjectTable = pkcs_subject; ; pSubjectTable++)
	{
	    WCHAR const * const *ppwsz;

	    if (NULL == pSubjectTable->pwszPropName)
	    {
		goto error;
	    }

	    // Check for matching full name without "Subject." prefix:

	    pwsz = wcschr(pSubjectTable->pwszPropName, L'.');
	    if (NULL != pwsz && 0 == mylstrcmpiS(pwszName, &pwsz[1]))
	    {
		break;
	    }

	    // Check for matching OID or abbreviated name:

	    for (
		ppwsz = pSubjectTable->apwszAttributeName;
		NULL != *ppwsz;
		ppwsz++)
	    {
		if (0 == mylstrcmpiS(pwszName, *ppwsz))
		{
		    break;
		}
	    }
	    if (NULL != *ppwsz)
	    {
		*ppwszPropertyName = pSubjectTable->pwszPropName;
		break;
	    }
	}
    }

    // It's a valid Certificate Table Subject RDN.  Call pkcsSplitRDNComponents
    // to split the string into individual RDN components and optionally
    // enforce each component is under the maximum length.

    DBGPRINT((
	    DBG_SS_CERTSRVI,
	    "PKCSVerifySubjectRDN(%ws) --> '%ws'\n",
	    *ppwszPropertyName,
	    pwszName));

    if (NULL != prow)
    {
	if (!*pfSubjectDot && NULL != pwszPropertyValue)
	{
	    pwszValue = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszPropertyValue) + 1) * sizeof(WCHAR));
	    if (NULL == pwszValue)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    wcscpy(pwszValue, pwszPropertyValue);

	    CSASSERT(NULL != pSubjectTable);
	    hr = pkcsSplitRDNComponents(
				pSubjectTable,
				pwszValue,
				ARRAYSIZE(rgAttr),
				&cAttr,
				rgAttr);
	    _JumpIfError(hr, error, "SplitRDNComponents");

	    // Call myEncodeName merely to test for valid string data.
	    // Some RDN OIDs are restricted to IA5 strings.

	    hr = pkcsEncodeSubjectName(prow, rgAttr, cAttr, &pbData, &cbData);
	    _JumpIfError(hr, error, "pkcsEncodeSubjectName");
	}
	hr = PKCSSetRequestFlags(prow, FALSE, CR_FLG_SUBJECTUNMODIFIED);
	_JumpIfError(hr, error, "PKCSSetRequestFlags");
    }

error:
    for (i = 0; i < cAttr; i++)
    {
	LocalFree(rgAttr[i].Value.pbData);
    }
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
PKCSDeleteAllSubjectRDNs(
    IN ICertDBRow *prow,
    IN DWORD Flags)
{
    HRESULT hr;
    SUBJECTTABLE const *pSubjectTable;

    for (pSubjectTable = pkcs_subject; ; pSubjectTable++)
    {
	if (NULL == pSubjectTable->pwszPropName)
	{
	    break;
	}
	hr = prow->SetProperty(pSubjectTable->pwszPropName, Flags, 0, NULL);
	_JumpIfError(hr, error, "SetProperty");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
pkcsVerifyEKUPolices(
    IN CERT_CONTEXT const *pcc,
    OPTIONAL IN WCHAR const *pwszzPolicies,
    IN WCHAR const *pwszInvalidPoliciesPrefix,
    OUT WCHAR **ppwszInvalidPolicies)
{
    HRESULT hr;
    CERT_ENHKEY_USAGE *pEKUs = NULL;
    DWORD i;
    WCHAR const *pwsz;
    WCHAR *pwszObjId = NULL;

    *ppwszInvalidPolicies = NULL;
    if (NULL == pwszzPolicies)
    {
        hr = S_OK;
        goto error;
    }

    hr = myCertGetEnhancedKeyUsage(
			pcc,
			CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
			&pEKUs);
    if (CRYPT_E_NOT_FOUND == hr)
    {
        hr = S_OK;
        goto error;
    }
    _JumpIfError(hr, error, "myCertGetEnhancedKeyUsage");

    for (i = 0; i < pEKUs->cUsageIdentifier; i++)
    {
	CSASSERT(NULL == pwszObjId);

	if (!myConvertSzToWsz(
			&pwszObjId,
			pEKUs->rgpszUsageIdentifier[i],
			-1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz(ObjId)");
	}
	for (pwsz = pwszzPolicies; ; pwsz += wcslen(pwsz) + 1)
	{
	    if (L'\0' == *pwsz)
	    {
		hr = myAppendString(pwszObjId, L", ", ppwszInvalidPolicies);
		_JumpIfError(hr, error, "myAppendString");

		hr = CERT_E_INVALID_POLICY;
		_PrintErrorStr(hr, "Chain invalidates policy", pwszObjId);
		break;
	    }
	    if (0 == lstrcmp(pwsz, pwszObjId))
	    {
		break;
	    }
	}
	LocalFree(pwszObjId);
	pwszObjId = NULL;
    }
    if (NULL != *ppwszInvalidPolicies)
    {
	HRESULT hr2;
	
	hr2 = myPrependString(pwszInvalidPoliciesPrefix, L" ", ppwszInvalidPolicies);
	_PrintIfError(hr2, "myPrependString");
    }
    _JumpIfErrorStr(
		hr,
		error,
		"Chain invalidates policy",
		*ppwszInvalidPolicies);

error:
    if (NULL != pEKUs)
    {
	LocalFree(pEKUs);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
pkcsVerifyIssuedPolices(
    IN CERT_CONTEXT const *pcc,
    IN CHAR const *pszObjId,
    OPTIONAL IN WCHAR const *pwszzPolicies,
    IN WCHAR const *pwszInvalidPoliciesPrefix,
    OUT WCHAR **ppwszInvalidPolicies)
{
    HRESULT hr;
    CERT_EXTENSION const *pExt;
    CERT_POLICIES_INFO *pcpsi = NULL;
    DWORD cb;
    DWORD i;
    WCHAR const *pwsz;
    WCHAR *pwszObjId = NULL;

    *ppwszInvalidPolicies = NULL;
    if (NULL == pwszzPolicies)
    {
	hr = S_OK;
	goto error;
    }
    pExt = CertFindExtension(
			pszObjId,
			pcc->pCertInfo->cExtension,
			pcc->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
        hr = CRYPT_E_NOT_FOUND;
        goto error;
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_POLICIES,
		    pExt->Value.pbData,
		    pExt->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcpsi,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = S_OK;
    for (i = 0; i < pcpsi->cPolicyInfo; i++)
    {
	CSASSERT(NULL == pwszObjId);

	if (!myConvertSzToWsz(
			&pwszObjId,
			pcpsi->rgPolicyInfo[i].pszPolicyIdentifier,
			-1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz(ObjId)");
	}
	for (pwsz = pwszzPolicies; ; pwsz += wcslen(pwsz) + 1)
	{
	    if (L'\0' == *pwsz)
	    {
		hr = myAppendString(pwszObjId, L", ", ppwszInvalidPolicies);
		_JumpIfError(hr, error, "myAppendString");

		hr = CERT_E_INVALID_POLICY;
		_PrintErrorStr(hr, "Chain invalidates policy", pwszObjId);
		break;
	    }
	    if (0 == lstrcmp(pwsz, pwszObjId))
	    {
		break;
	    }
	}
	LocalFree(pwszObjId);
	pwszObjId = NULL;
    }
    if (NULL != *ppwszInvalidPolicies)
    {
	HRESULT hr2;
	
	hr2 = myPrependString(pwszInvalidPoliciesPrefix, L" ", ppwszInvalidPolicies);
	_PrintIfError(hr2, "myPrependString");
    }
    _JumpIfErrorStr(
		hr,
		error,
		"Chain invalidates policy",
		*ppwszInvalidPolicies);

error:
    if (NULL != pcpsi)
    {
	LocalFree(pcpsi);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


int _cdecl
fnRDNSort(
    IN VOID const *pvrdn1,
    IN VOID const *pvrdn2)
{
    CERT_RDN_ATTR const *prdna1 = &((CERT_RDN const *) pvrdn1)->rgRDNAttr[0];
    CERT_RDN_ATTR const *prdna2 = &((CERT_RDN const *) pvrdn2)->rgRDNAttr[0];
    int r;

    r = strcmp(prdna1->pszObjId, prdna2->pszObjId);
    if (0 == r)
    {
	r = prdna1->dwValueType - prdna2->dwValueType;
	if (0 == r)
	{
	    r = prdna1->Value.cbData - prdna2->Value.cbData;
	    if (0 == r)
	    {
		r = mylstrcmpiL(
			(WCHAR const *) prdna1->Value.pbData,
			(WCHAR const *) prdna2->Value.pbData);
	    }
	}
    }
    return(r);
}


HRESULT
pkcsGetSortedName(
    IN CERT_NAME_BLOB const *pName,
    OUT WCHAR **ppwszName)
{
    HRESULT hr;
    DWORD i;
    CERT_NAME_INFO *pNameInfo = NULL;
    CERT_NAME_INFO NameInfo;
    CERT_RDN *prdn;
    CERT_RDN_ATTR *rgrdna = NULL;
    CERT_RDN_ATTR *prdna;
    CERT_NAME_BLOB NameBlob;
    DWORD cb;
    
    *ppwszName = NULL;
    NameInfo.rgRDN = NULL;
    NameBlob.pbData = NULL;
    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pName->pbData,
		pName->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cb))
    {

	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }
    NameInfo.cRDN = 0;
    for (i = 0; i < pNameInfo->cRDN; i++)
    {
	NameInfo.cRDN += pNameInfo->rgRDN[i].cRDNAttr;
    }
    NameInfo.rgRDN = (CERT_RDN *) LocalAlloc(
				    LMEM_FIXED,
				    NameInfo.cRDN * sizeof(NameInfo.rgRDN[0]));
    if (NULL == NameInfo.rgRDN)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    rgrdna = (CERT_RDN_ATTR *) LocalAlloc(
				    LMEM_FIXED,
				    NameInfo.cRDN * sizeof(rgrdna[0]));
    if (NULL == rgrdna)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    prdn = NameInfo.rgRDN;
    prdna = rgrdna;
    for (i = 0; i < pNameInfo->cRDN; i++)
    {
	CERT_RDN const *prdnT = &pNameInfo->rgRDN[i];
	DWORD j;

	for (j = 0; j < prdnT->cRDNAttr; j++)
	{
	    prdn->cRDNAttr = 1;
	    prdn->rgRDNAttr = prdna;
	    *prdna = prdnT->rgRDNAttr[j];
	    prdn++;
	    prdna++;
	}
    }
    qsort(NameInfo.rgRDN, NameInfo.cRDN, sizeof(NameInfo.rgRDN[0]), fnRDNSort);

    if (!myEncodeName(
		X509_ASN_ENCODING,
		&NameInfo,
		CERT_RDN_ENABLE_UTF8_UNICODE_FLAG,
		CERTLIB_USE_LOCALALLOC,
		&NameBlob.pbData,
		&NameBlob.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeName");
    }

    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&NameBlob,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		ppwszName);
    _JumpIfError(hr, error, "myCertNameToStr");

error:
    if (NULL != NameBlob.pbData)
    {
	LocalFree(NameBlob.pbData);
    }
    if (NULL != NameInfo.rgRDN)
    {
	LocalFree(NameInfo.rgRDN);
    }
    if (NULL != rgrdna)
    {
	LocalFree(rgrdna);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


HRESULT
pkcsCompareNames(
    IN CERT_NAME_BLOB const *pName1,
    IN CERT_NAME_BLOB const *pName2,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    WCHAR *pwszName1 = NULL;
    WCHAR *pwszName2 = NULL;

    *pfMatch = FALSE;

    hr = pkcsGetSortedName(pName1, &pwszName1);
    _JumpIfError(hr, error, "pkcsGetSortedName");

    hr = pkcsGetSortedName(pName2, &pwszName2);
    _JumpIfError(hr, error, "pkcsGetSortedName");

    if (0 == mylstrcmpiL(pwszName1, pwszName2))
    {
	*pfMatch = TRUE;
    }
    hr = S_OK;

error:
    if (NULL != pwszName1)
    {
	LocalFree(pwszName1);
    }
    if (NULL != pwszName2)
    {
	LocalFree(pwszName2);
    }
    return(hr);
}


HRESULT
pkcsEncodeSubjectCert(
    IN ICertDBRow *prow,
    IN CACTX const *pCAContext,
    IN BOOL fCrossCert,
    OUT BYTE **ppbEncoded,  // CoTaskMem*
    OUT DWORD *pcbEncoded,
    OUT BOOL *pfErrorLogged,
    OUT WCHAR **ppwszDispositionCreateCert)
{
    HRESULT hr;
    HRESULT hr2;
    HRESULT hrValidate = S_OK;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;
    DWORD ExtFlags;
    BSTR strSerialNumber = NULL;
    IEnumCERTDBNAME *penum = NULL;
    CERTDBNAME cdbn;
    FILETIME ftNotBefore;
    DWORD dwRequestFlags;
    WCHAR *pwszSubject = NULL;
    DWORD dwFlags;

    CERT_INFO Cert;
    CERT_EXTENSION *pExt = NULL;
    DWORD           cExt = INCREMENT_EXTENSIONS;

    DWORD cbprop;
    DWORD i;
    CERT_CONTEXT const *pcc = NULL;
    WCHAR *pwszzIssuancePolicies = NULL;
    WCHAR *pwszzApplicationPolicies = NULL;
    WCHAR *pwszInvalidIssuancePolicies = NULL;
    WCHAR *pwszInvalidApplicationPolicies = NULL;
    WCHAR *pwszExtendedErrorInfo = NULL;
    CERT_TRUST_STATUS TrustStatus;

    cdbn.pwszName = NULL;
    *pfErrorLogged = FALSE;
    *ppwszDispositionCreateCert = NULL;

    // CERT
    ZeroMemory(&Cert, sizeof(Cert));
    pExt = (CERT_EXTENSION *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cExt * sizeof(*pExt));
    if (NULL == pExt)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    Cert.dwVersion = CERT_V3;

    hr = pkcsCreateCertSerialNumber(prow, pCAContext, &strSerialNumber);
    _JumpIfError(hr, error, "pkcsCreateCertSerialNumber");

    // convert to int
    hr = WszToMultiByteInteger(
			    FALSE,
			    strSerialNumber,
			    &Cert.SerialNumber.cbData,
			    &Cert.SerialNumber.pbData);
    _JumpIfError(hr, error, "WszToMultiByteInteger");


    Cert.SignatureAlgorithm.pszObjId = pCAContext->pszObjIdSignatureAlgorithm;
    Cert.Issuer = pCAContext->pccCA->pCertInfo->Subject;


    cbprop = sizeof(Cert.NotBefore);
    hr = prow->GetProperty(
		    g_wszPropCertificateNotBeforeDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    &cbprop,
		    (BYTE *) &Cert.NotBefore);
    _JumpIfError(hr, error, "GetProperty");

    CSASSERT(sizeof(Cert.NotBefore) == cbprop);

    cbprop = sizeof(Cert.NotAfter);
    hr = prow->GetProperty(
		    g_wszPropCertificateNotAfterDate,
		    PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    NULL,
		    &cbprop,
		    (BYTE *) &Cert.NotAfter);
    _JumpIfError(hr, error, "GetProperty");

    CSASSERT(sizeof(Cert.NotAfter) == cbprop);

    CSASSERT(NULL == Cert.Subject.pbData);

    cbprop = sizeof(dwRequestFlags);
    hr = prow->GetProperty(
		g_wszPropRequestFlags,
		PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		NULL,
		&cbprop,
		(BYTE *) &dwRequestFlags);
    _JumpIfError(hr, error, "GetProperty");

    if (!pkcsfSubjectTemplate ||
	fCrossCert ||
	((CRLF_REBUILD_MODIFIED_SUBJECT_ONLY & g_dwCRLFlags) &&
	 (CR_FLG_SUBJECTUNMODIFIED & dwRequestFlags)))
    {
	hr = PKCSGetProperty(
		    prow,
		    g_wszPropSubjectRawName,
		    PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    &Cert.Subject.cbData,
		    &Cert.Subject.pbData);
	if (S_OK == hr &&
	    0 == Cert.Subject.cbData &&
	    NULL != Cert.Subject.pbData)
	{
	    LocalFree(Cert.Subject.pbData);
	    Cert.Subject.pbData = NULL;
	}
    }

    if (NULL == Cert.Subject.pbData)
    {
	hr = pkcsBuildSubjectFromNamesTable(prow, &Cert.Subject);
	_JumpIfError(hr, error, "pkcsBuildSubjectFromNamesTable");
    }

    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&Cert.Subject,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		&pwszSubject);
    _JumpIfError(hr, error, "myCertNameToStr");

    if (!fCrossCert)
    {
	BOOL fMatch;
	
	hr = pkcsCompareNames(&Cert.Issuer, &Cert.Subject, &fMatch);
	_JumpIfError(hr, error, "pkcsCompareNames");

	if (fMatch)
	{
	    hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	    _JumpError(hr, error, "Subject string matches Issuer");
	}
    }

    // if the subject is empty, Subject Alt Name extension must be critical:

    if (L'\0' == *pwszSubject)
    {
	BYTE *pbAltName = NULL;
	DWORD cbAltName;
	
	hr = PropGetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_SERVER,
			TEXT(szOID_SUBJECT_ALT_NAME2),
			&ExtFlags,
			&cbAltName,
			&pbAltName);
	_PrintIfErrorStr(hr, "PropGetExtension", TEXT(szOID_SUBJECT_ALT_NAME2));

	// Empty subject: Require a non-empty, non-disabled Subject Alt Name 2
	// extension.  An empty extension with a single empty entry can be
	// constructed in four bytes.  We don't attempt to detect multiple
	// empty name entries.

	if (S_OK == hr &&
	    NULL != pbAltName &&
	    4 < cbAltName &&
	    0 == (EXTENSION_DISABLE_FLAG & ExtFlags))
	{
	    if (0 == (EXTENSION_CRITICAL_FLAG & ExtFlags))
	    {
		ExtFlags |= EXTENSION_CRITICAL_FLAG;
		hr = PropSetExtension(
				prow,
				PROPTYPE_BINARY | PROPCALLER_SERVER,
				TEXT(szOID_SUBJECT_ALT_NAME2),
				ExtFlags,
				cbAltName,
				pbAltName);
	    }
	    LocalFree(pbAltName);
	    _JumpIfError(hr, error, "PropSetExtension");
	}
	else
	{
	    hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	    _JumpError(hr, error, "empty Subject+missing/disabled SubjectAltName");
	}
    }

    hr = pkcsGetPublicKeyInfo(prow, &Cert.SubjectPublicKeyInfo);
    _JumpIfError(hr, error, "pkcsGetPublicKeyInfo");

    Cert.rgExtension = pExt;
    i = 0;

    hr = prow->EnumCertDBName(CIE_TABLE_EXTENSIONS, &penum);
    _JumpIfError(hr, error, "EnumCertDBName");

    hr = CERTSRV_E_PROPERTY_EMPTY;
    for (;;)
    {
	ULONG celtFetched;

	if (cExt == i)
	{
	    CERT_EXTENSION *pExtT;

	    // reached max, increse size
	    cExt += INCREMENT_EXTENSIONS;
	    pExtT = (CERT_EXTENSION *) LocalReAlloc(
						pExt,
						cExt * sizeof(*pExt),
						LMEM_ZEROINIT | LMEM_MOVEABLE);
	    if (NULL == pExtT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalReAlloc");
	    }
	    pExt = pExtT;
	    Cert.rgExtension = pExt;
	}

	hr = penum->Next(1, &cdbn, &celtFetched);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "Next");

	CSASSERT(1 == celtFetched);
	CSASSERT(NULL != cdbn.pwszName);

	if (!myConvertWszToSz(
			&Cert.rgExtension[i].pszObjId,
			cdbn.pwszName,
			-1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertWszToSz(ExtObjId)");
	}

	hr = PropGetExtension(
			prow,
			PROPTYPE_BINARY | PROPCALLER_SERVER,
			cdbn.pwszName,
			&ExtFlags,
			&Cert.rgExtension[i].Value.cbData,
			&Cert.rgExtension[i].Value.pbData);
	_JumpIfError(hr, error, "PropGetExtension");

	DBGPRINT((
		DBG_SS_CERTSRVI,
		"pkcsEncodeSubjectCert: Ext=%ws, ExtFlags=%x, len=%x\n",
		cdbn.pwszName,
		ExtFlags,
		Cert.rgExtension[i].Value.cbData));

	Cert.rgExtension[i].fCritical =
	    (EXTENSION_CRITICAL_FLAG & ExtFlags)? TRUE : FALSE;

	CoTaskMemFree(cdbn.pwszName);
	cdbn.pwszName = NULL;

	if (EXTENSION_DISABLE_FLAG & ExtFlags)
	{
	    if (NULL != pExt[i].pszObjId)
	    {
		LocalFree(pExt[i].pszObjId);
		pExt[i].pszObjId = NULL;
	    }
	    if (NULL != pExt[i].Value.pbData)
	    {
		LocalFree(pExt[i].Value.pbData);
		pExt[i].Value.pbData = NULL;
	    }
	    continue;
	}
	i++;
    }

    Cert.cExtension = i;

    // encode the cert contents

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    &Cert,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbCertEncoded,
		    &cbCertEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    // sign the cert, then encode the signed info
    hr = myEncodeSignedContent(
			pCAContext->hProvCA,
			X509_ASN_ENCODING,
			Cert.SignatureAlgorithm.pszObjId,
			pbCertEncoded,
			cbCertEncoded,
			CERTLIB_USE_COTASKMEMALLOC,
			ppbEncoded,
			pcbEncoded); // use CoTaskMem*
    _JumpIfError(hr, error, "myEncodeSignedContent");

    pcc = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				*ppbEncoded,
				*pcbEncoded);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

    if (g_fCertEnrollCompatible)
    {
	hr = pkcsCheck7f(
		    prow,
		    *ppbEncoded,
		    *pcbEncoded,
		    pfErrorLogged);
	if (S_OK != hr)
	{
	    CoTaskMemFree(*ppbEncoded);
	    *ppbEncoded = NULL;
	    _JumpError(hr, error, "pkcsCheck7f");
	}
    }

    ftNotBefore = pcc->pCertInfo->NotBefore;
    myMakeExprDateTime(&ftNotBefore, g_dwClockSkewMinutes, ENUM_PERIOD_MINUTES);

    dwFlags = g_dwVerifyCertFlags;
    if (fCrossCert)
    {
	dwFlags |= CA_VERIFY_FLAGS_IGNORE_OFFLINE;
    }
    if (CRLF_IGNORE_INVALID_POLICIES & g_dwCRLFlags)
    {
	dwFlags |= CA_VERIFY_FLAGS_IGNORE_INVALID_POLICIES;
    }
    hr = myVerifyCertContextEx(
			pcc,			// pCert
			dwFlags,
			0,			// dwmsTimeout
			0,			// cUsageOids
			NULL,			// apszUsageOids
			0,			// cIssuanceOids
			NULL,			// apszIssuanceOids
			HCCE_LOCAL_MACHINE,	// hChainEngine
			&ftNotBefore,		// pft
			NULL,			// hAdditionalStore
			NULL,			// pfnCallback
			NULL,			// ppwszMissingIssuer
			&pwszzIssuancePolicies,
			&pwszzApplicationPolicies,
			&pwszExtendedErrorInfo,
			&TrustStatus);
    _PrintIfError(hr, "myVerifyCertContextEx");

    // Ignore old Crypt32 cross cert chain verification errors

    if ((CERT_E_UNTRUSTEDROOT == hr || TRUST_E_CERT_SIGNATURE == hr) &&
	(CRLF_IGNORE_CROSS_CERT_TRUST_ERROR & g_dwCRLFlags) &&
	fCrossCert)
    {
	hr = S_OK;
    }
    hrValidate = hr;

    if (S_OK == hrValidate)
    {
	hr = pkcsVerifyIssuedPolices(
				pcc,
				szOID_CERT_POLICIES,
				pwszzIssuancePolicies,
				g_pwszInvalidIssuancePolicies,
				&pwszInvalidIssuancePolicies);
	_PrintIfError(hr, "pkcsVerifyIssuedPolices");
	if (CRYPT_E_NOT_FOUND == hr)
	{
	    hr = S_OK;	// ignore error if extension is not found
	}
	if (S_OK == hrValidate &&
	    0 == (CRLF_IGNORE_INVALID_POLICIES & g_dwCRLFlags) &&
	    (CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY & TrustStatus.dwInfoStatus))
	{
	    hrValidate = hr;
	}

	hr = pkcsVerifyIssuedPolices(
				pcc,
				szOID_APPLICATION_CERT_POLICIES,
				pwszzApplicationPolicies,
				g_pwszInvalidApplicationPolicies,
				&pwszInvalidApplicationPolicies);
	_PrintIfError(hr, "pkcsVerifyIssuedPolices(szOID_APPLICATION_CERT_POLICIES)");
	if (CRYPT_E_NOT_FOUND == hr)
	{
	    // application policies extension empty, fail over to EKU
	    hr = pkcsVerifyEKUPolices(
				pcc,
				pwszzApplicationPolicies,
				g_pwszInvalidApplicationPolicies,
				&pwszInvalidApplicationPolicies);
	    _PrintIfError(hr, "pkcsVerifyIssuedPolices(szOID_ENHANCED_KEY_USAGE)");
	}
	if (S_OK == hrValidate &&
	    0 == (CRLF_IGNORE_INVALID_POLICIES & g_dwCRLFlags))
	{
	    hrValidate = hr;
	}
    }
    if (S_OK != hrValidate)
    {
	if (0 == (CRLF_SAVE_FAILED_CERTS & g_dwCRLFlags))
	{
	    goto error;
	}
    }

    hr = pkcsSetCertAndKeyHashes(prow, pcc);
    _JumpIfError(hr, error, "pkcsSetCertAndKeyHashes");

    hr = prow->SetProperty(
		    g_wszPropCertificateIssuerNameID,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    sizeof(pCAContext->NameId),
		    (BYTE *) &pCAContext->NameId);
    _JumpIfError(hr, error, "SetProperty");

    hr = prow->SetProperty(
		    g_wszPropCertificateSerialNumber,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    MAXDWORD,
		    (BYTE *) strSerialNumber);
    _JumpIfError(hr, error, "SetProperty");

#ifdef TEST_SPECIAL_SERIAL_NUMBERS
    if (L'0' == strSerialNumber[0] && L'0' == strSerialNumber[1])
    {
	hr = prow->SetProperty(
		    g_wszPropCertificateSerialNumber,
		    PROPTYPE_STRING | PROPCALLER_SERVER | PROPTABLE_CERTIFICATE,
		    MAXDWORD,
		    (BYTE *) &strSerialNumber[2]);
	_JumpIfError(hr, error, "SetProperty");
    }
#endif

error:
    if (S_OK != hrValidate)
    {
	hr = hrValidate;
    }
    *ppwszDispositionCreateCert = pwszInvalidIssuancePolicies;
    pwszInvalidIssuancePolicies = NULL;
    if (NULL != pwszInvalidApplicationPolicies)
    {
	hr2 =  myAppendString(
			pwszInvalidApplicationPolicies,
			L"  ",
			ppwszDispositionCreateCert);
	_PrintIfError(hr2, "myAppendString");
    }
    if (NULL != pwszExtendedErrorInfo)
    {
	hr2 =  myAppendString(
			pwszExtendedErrorInfo,
			L"  ",
			ppwszDispositionCreateCert);
	_PrintIfError(hr2, "myAppendString");
    }
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    if (NULL != pwszzIssuancePolicies)
    {
	LocalFree(pwszzIssuancePolicies);
    }
    if (NULL != pwszzApplicationPolicies)
    {
	LocalFree(pwszzApplicationPolicies);
    }
    if (NULL != pwszInvalidIssuancePolicies)
    {
	LocalFree(pwszInvalidIssuancePolicies);
    }
    if (NULL != pwszInvalidApplicationPolicies)
    {
	LocalFree(pwszInvalidApplicationPolicies);
    }
    if (NULL != pwszExtendedErrorInfo)
    {
	LocalFree(pwszExtendedErrorInfo);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pExt)
    {
	i = 0;
	if (NULL != cdbn.pwszName)
	{
	    CoTaskMemFree(cdbn.pwszName);
	}
	while (cExt != i)
	{
	    if (NULL != pExt[i].pszObjId)
	    {
		LocalFree(pExt[i].pszObjId);
	    }
	    if (NULL != pExt[i].Value.pbData)
	    {
		LocalFree(pExt[i].Value.pbData);
	    }
	    i++;
	}
	LocalFree(pExt);
    }
    if (NULL != penum)
    {
	penum->Release();
    }
    if (NULL != Cert.SerialNumber.pbData)
    {
	LocalFree(Cert.SerialNumber.pbData);
    }
    if (NULL != Cert.Subject.pbData)
    {
	LocalFree(Cert.Subject.pbData);
    }
    pkcsFreePublicKeyInfo(&Cert.SubjectPublicKeyInfo);
    if (NULL != pbCertEncoded)
    {
	LocalFree(pbCertEncoded);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


VOID
pkcsFreeCRLChain(
    IN DWORD cCert,
    OPTIONAL IN OUT CERT_BLOB *prgCertBlob,
    OPTIONAL IN OUT CERT_CONTEXT const **rgCert,
    IN DWORD cCRL,
    OPTIONAL IN OUT CRL_BLOB *rgCRLBlob,
    OPTIONAL IN OUT CRL_CONTEXT const **rgCRL)
{
    DWORD i;

    if (NULL != prgCertBlob)
    {
	LocalFree(prgCertBlob);
    }
    if (NULL != rgCert)
    {
	for (i = 0; i < cCert; i++)
	{
	    if (NULL != rgCert[i])
	    {
		CertFreeCertificateContext(rgCert[i]);
	    }
	}
	LocalFree(rgCert);
    }
    if (NULL != rgCRLBlob)
    {
	LocalFree(rgCRLBlob);
    }
    if (NULL != rgCRL)
    {
	for (i = 0; i < cCRL; i++)
	{
	    if (NULL != rgCRL[i])
	    {
		CertFreeCRLContext(rgCRL[i]);
	    }
	}
	LocalFree(rgCRL);
    }
}


// Build the CA's cert chain and collect all paremt CA CRLs.
// Add in the optional passed leaf cert and the CA's CRLs.
// This ensures that the chain includes at least this CA's correct cert & CRLs.


HRESULT
pkcsBuildCRLChain(
    OPTIONAL IN CACTX *pCAContext,
    OPTIONAL IN BYTE const *pbCertLeaf,
    IN DWORD cbCertLeaf,
    IN BOOL fIncludeCRLs,
    OUT DWORD *pcCert,
    OPTIONAL OUT CERT_BLOB **prgCertBlob,
    OUT CERT_CONTEXT const ***prgCert,
    OUT DWORD *pcCRLBlob,
    OPTIONAL OUT CRL_BLOB **prgCRLBlob,
    OUT CRL_CONTEXT const ***prgCRL)
{
    HRESULT hr;
    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    DWORD cElement;
    CERT_CHAIN_ELEMENT **rgpElement;
    DWORD cCert = 0;
    CERT_CONTEXT const **rgpCert = NULL;
    CERT_CONTEXT const *pccCertLeaf = NULL;
    CERT_BLOB *rgCertBlob = NULL;
    DWORD cCRL = 0;
    CRL_CONTEXT const **rgpCRL = NULL;
    CRL_BLOB *rgCRLBlob = NULL;
    DWORD i;
    DWORD iCert;
    DWORD iCRL;

    if (NULL != prgCertBlob)
    {
	*prgCertBlob = NULL;
    }
    *prgCert = NULL;
    if (NULL != prgCRLBlob)
    {
	*prgCRLBlob = NULL;
    }
    *prgCRL = NULL;

    if (NULL != pbCertLeaf)
    {
	pccCertLeaf = CertCreateCertificateContext(
						X509_ASN_ENCODING,
						pbCertLeaf,
						cbCertLeaf);
	if (NULL == pccCertLeaf)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
    }
    CSASSERT(NULL != pCAContext || NULL != pccCertLeaf);
    if (NULL == pCAContext || fIncludeCRLs)
    {
	// Get the CA cert chain and parent CA CRLs:

	ZeroMemory(&ChainParams, sizeof(ChainParams));
	ChainParams.cbSize = sizeof(ChainParams);
	//ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
	//ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
	//ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

	if (!CertGetCertificateChain(
				HCCE_LOCAL_MACHINE,	// hChainEngine
				NULL != pCAContext?
				    pCAContext->pccCA : pccCertLeaf,
				NULL,		// pTime
				NULL,		// hAdditionalStore
				&ChainParams,	// pChainPara
				CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
				NULL,		// pvReserved
				&pChainContext))	// ppChainContext
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateChain");
	}
	if (0 == pChainContext->cChain ||
	    0 == pChainContext->rgpChain[0]->cElement)
	{
	    hr = CRYPT_E_NOT_FOUND;
	    _JumpError(hr, error, "No chain");
	}
	cElement = pChainContext->rgpChain[0]->cElement;
	rgpElement = pChainContext->rgpChain[0]->rgpElement;
    }
    else
    {
	cElement = pCAContext->cCACertChain;
	rgpElement = NULL;
    }
    cCert = cElement;
    cCRL = 2 * (cCert + 1);	// Worst case.  *Always* include this CA's CRLs
    if (NULL != pbCertLeaf)
    {
	cCert++;
    }
    rgpCert = (CERT_CONTEXT const **) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    cCert * sizeof(rgpCert[0]));
    if (NULL == rgpCert)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (fIncludeCRLs)
    {
	rgpCRL = (CRL_CONTEXT const **) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    cCRL * sizeof(rgpCRL[0]));
	if (NULL == rgpCRL)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    iCert = 0;
    iCRL = 0;

    // Add parent CA certs and CRLs:

    if (NULL == pCAContext || fIncludeCRLs)
    {
	for (i = 0; i < cElement; i++)
	{
	    CSASSERT(NULL != rgpElement);
	    CERT_CHAIN_ELEMENT const *pElement = rgpElement[i];
	    CERT_REVOCATION_INFO *pRevocationInfo;

	    rgpCert[iCert] = CertDuplicateCertificateContext(
						    pElement->pCertContext);
	    if (NULL != rgpCert[iCert])
	    {
		iCert++;
	    }
	    pRevocationInfo = pElement->pRevocationInfo;

	    if (fIncludeCRLs &&
		NULL != pRevocationInfo &&
		CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
		    pRevocationInfo->cbSize &&
		NULL != pRevocationInfo->pCrlInfo)
	    {
		CERT_REVOCATION_CRL_INFO *pCrlInfo;

		pCrlInfo = pRevocationInfo->pCrlInfo;
		if (NULL != pCrlInfo)
		{
		    if (NULL != pCrlInfo->pBaseCrlContext)
		    {
			rgpCRL[iCRL] = CertDuplicateCRLContext(
						pCrlInfo->pBaseCrlContext);
			if (NULL != rgpCRL[iCRL])
			{
			    iCRL++;
			}
		    }
		    if (NULL != pCrlInfo->pDeltaCrlContext)
		    {
			rgpCRL[iCRL] = CertDuplicateCRLContext(
						pCrlInfo->pDeltaCrlContext);
			if (NULL != rgpCRL[iCRL])
			{
			    iCRL++;
			}
		    }
		}
	    }
	}
    }
    else
    {
	for (i = 0; i < pCAContext->cCACertChain; i++)
	{
	    rgpCert[iCert] = CertDuplicateCertificateContext(
					    pCAContext->apCACertChain[i]);
	    if (NULL != rgpCert[iCert])
	    {
		iCert++;
	    }
	}
    }

    if (NULL != pCAContext)
    {
	// Add issued cert at the end -- optional Leaf cert:

	if (NULL != pbCertLeaf)
	{
	    for (i = 0; i < iCert; i++)
	    {
		if (cbCertLeaf == rgpCert[i]->cbCertEncoded &&
		    0 == memcmp(
			    pbCertLeaf,
			    rgpCert[i]->pbCertEncoded,
			    cbCertLeaf))
		{
		    break;
		}
	    }
	    if (i == iCert)	// if not found in existing array
	    {
		rgpCert[iCert] = CertDuplicateCertificateContext(pccCertLeaf);
		if (NULL != rgpCert[iCert])
		{
		    iCert++;
		}
	    }
	}

	// Add current CA's Base and delta CRLs:

	if (fIncludeCRLs)
	{
	    hr = CRLGetCRL(
			pCAContext->iKey,
			FALSE,		// fDelta
			&rgpCRL[iCRL],
			NULL);		// pdwCRLPublishFlags
	    _JumpIfError(hr, error, "CRLGetCRL(base)"); // Base CRL must exist

	    iCRL++;

	    hr = CRLGetCRL(
			pCAContext->iKey,
			TRUE,		// fDelta
			&rgpCRL[iCRL],
			NULL);		// pdwCRLPublishFlags
	    _PrintIfError(hr, "CRLGetCRL(delta)");	// Delta CRL might not exist
	    if (S_OK == hr)
	    {
		iCRL++;
	    }
	}
    }
    CSASSERT(iCert <= cCert);
    CSASSERT(iCRL <= cCRL);

    if (NULL != prgCertBlob)
    {
	rgCertBlob = (CERT_BLOB *) LocalAlloc(
					LMEM_FIXED,
					iCert * sizeof(rgCertBlob[0]));
	if (NULL == rgCertBlob)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	for (i = 0; i < iCert; i++)
	{
	    rgCertBlob[i].cbData = rgpCert[i]->cbCertEncoded;
	    rgCertBlob[i].pbData = rgpCert[i]->pbCertEncoded;
	}
    }
    if (NULL != prgCRLBlob && 0 != iCRL)
    {
	rgCRLBlob = (CERT_BLOB *) LocalAlloc(
					LMEM_FIXED,
					iCRL * sizeof(rgCRLBlob[0]));
	if (NULL == rgCRLBlob)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	for (i = 0; i < iCRL; i++)
	{
	    rgCRLBlob[i].cbData = rgpCRL[i]->cbCrlEncoded;
	    rgCRLBlob[i].pbData = rgpCRL[i]->pbCrlEncoded;
	}
    }
    *pcCert = iCert;
    *prgCert = rgpCert;
    rgpCert = NULL;
    if (NULL != prgCertBlob)
    {
	*prgCertBlob = rgCertBlob;
	rgCertBlob = NULL;
    }

    *pcCRLBlob = iCRL;
    *prgCRL = rgpCRL;
    rgpCRL = NULL;
    if (NULL != prgCRLBlob)
    {
	*prgCRLBlob = rgCRLBlob;
	rgCRLBlob = NULL;
    }
    hr = S_OK;

error:
    pkcsFreeCRLChain(cCert, rgCertBlob, rgpCert, cCRL, rgCRLBlob, rgpCRL);
    if (NULL != pccCertLeaf)
    {
        CertFreeCertificateContext(pccCertLeaf);
    }
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


HRESULT
pkcsRetrieveKeyHashFromRequest(
    IN ICertDBRow *prow,
    OUT BYTE **ppbKeyHashOut,
    OUT DWORD *pcbKeyHashOut)
{
    HRESULT hr;
    HCRYPTMSG hMsg = NULL;
    char *pszInnerContentObjId = NULL;
    BYTE *pbRequest = NULL;
    DWORD cbRequest;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    CMC_ADD_ATTRIBUTES_INFO *pcmcAttrib = NULL;
    DWORD cb;
    CRYPT_ATTRIBUTE const *pAttrib;
    CRYPT_ATTRIBUTE const *pAttribEnd;
    CRYPT_DATA_BLOB *pBlob = NULL;
    CMC_DATA_INFO *pcmcData = NULL;
    DWORD i;
    DWORD DataReference = MAXDWORD;	// nested CMC message Body Part Id
    DWORD CertReference = MAXDWORD;	// PKCS10 Cert Request Body Part Id
    
    *ppbKeyHashOut = NULL;

    hr = PKCSGetProperty(
		prow,
		g_wszPropRequestRawRequest,
		PROPTYPE_BINARY | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		&cbRequest,
		(BYTE **) &pbRequest);
    _JumpIfError(hr, error, "PKCSGetProperty(xchg cert)");

    hr = myDecodePKCS7(
		    pbRequest,
		    cbRequest,
		    &pbContent,
		    &cbContent,
		    NULL,		// pdwMsgType
		    &pszInnerContentObjId,
		    NULL,		// pcSigner
		    NULL,		// pcRecipient
		    NULL,		// phStore
		    &hMsg);
    _JumpIfError(hr, error, "myDecodePKCS7");

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_DATA,
		    pbContent,
		    cbContent,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcData,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (1 == pcmcData->cTaggedRequest)
    {
	CertReference = pcmcData->rgTaggedRequest[0].pTaggedCertRequest->dwBodyPartID;
    }
    // Process extensions and attributes

    for (i = 0; i < pcmcData->cTaggedAttribute; i++)
    {
	if (0 != strcmp(
		    szOID_CMC_ADD_ATTRIBUTES,
		    pcmcData->rgTaggedAttribute[i].Attribute.pszObjId))
	{
	    continue;
	}
	// Decode CMC_ADD_ATTRIBUTES_INFO from Attribute Blob

	if (NULL != pcmcAttrib)
	{
	    LocalFree(pcmcAttrib);
	    pcmcAttrib = NULL;
	}
	if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_ADD_ATTRIBUTES,
		    pcmcData->rgTaggedAttribute[i].Attribute.rgValue[0].pbData,
		    pcmcData->rgTaggedAttribute[i].Attribute.rgValue[0].cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcAttrib,
		    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
	if (!pkcsCMCReferenceMatch(
			DataReference,
			CertReference,
			pcmcAttrib->dwCmcDataReference,
			pcmcAttrib->cCertReference,
			pcmcAttrib->rgdwCertReference))
	{
	    continue;
	}
	pAttrib = pcmcAttrib->rgAttribute;
	if (NULL == pAttrib)
	{
	    continue;
	}
	pAttribEnd = &pAttrib[pcmcAttrib->cAttribute];
	for ( ; pAttrib < pAttribEnd; pAttrib++)
	{
	    if (0 != strcmp(pAttrib->pszObjId, szOID_ENCRYPTED_KEY_HASH))
	    {
		continue;
	    }
	    if (NULL != pBlob)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Multiple encrypted key hashes");
	    }
	    if (1 != pAttrib->cValue)
	    {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                _JumpError(hr, error, "Attribute Value count != 1");
	    }
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pAttrib->rgValue[0].pbData,
			    pAttrib->rgValue[0].cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pBlob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    *ppbKeyHashOut = (BYTE *) LocalAlloc(
						LMEM_FIXED,
						pBlob->cbData);
	    if (NULL == *ppbKeyHashOut)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(*ppbKeyHashOut, pBlob->pbData, pBlob->cbData);
	    *pcbKeyHashOut = pBlob->cbData;
	}
    }
    if (NULL == pBlob)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "No encrypted key hash");
    }
    hr = S_OK;

error:
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    if (NULL != pcmcData)
    {
	LocalFree(pcmcData);
    }
    if (NULL != pcmcAttrib)
    {
	LocalFree(pcmcAttrib);
    }
    if (NULL != pbContent)
    {
	LocalFree(pbContent);
    }
    if (NULL != pbRequest)
    {
	LocalFree(pbRequest);
    }
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    return(hr);
}


// Build a PKCS7 CMC response

HRESULT
PKCSEncodeFullResponse(
    OPTIONAL IN ICertDBRow *prow,
    IN CERTSRV_RESULT_CONTEXT *pResult,
    IN HRESULT hrRequest,
    IN WCHAR *pwszDispositionString,
    OPTIONAL IN CACTX *pCAContext,
    OPTIONAL IN BYTE const *pbCertLeaf,
    IN DWORD cbCertLeaf,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbResponse,    // CoTaskMem*
    OUT DWORD *pcbResponse)
{
    HRESULT hr;
    CMC_RESPONSE_INFO Response;
    CMC_STATUS_INFO Status;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    DWORD dwBodyPartIdOfRequest = 1;
    DWORD dwCMCDataReference = 0;
    DWORD dwBodyPartId = 1;
    CMC_TAGGED_ATTRIBUTE aTaggedAttribute[5];
    DWORD ita = 0;
    CRYPT_ATTRIBUTE aAttr[2];
    DWORD iAttr = 0;
    CRYPT_ATTR_BLOB aAttrBlob[7];
    DWORD iblob = 0;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CMC_PEND_INFO PendInfo;
    DWORD ReqId;
    DWORD dwRequestFlags;
    DWORD cb;
    DWORD i;
    HCRYPTMSG hMsg = NULL;
    CERT_CONTEXT const **prgCert = NULL;
    CRL_CONTEXT const **prgCRL = NULL;
    CHAR szNonce[(11 + 1) + (8 + 1) * 3];

    ZeroMemory(aAttrBlob, sizeof(aAttrBlob));
    ZeroMemory(&Status, sizeof(Status));
    ZeroMemory(&Response, sizeof(Response));

    ZeroMemory(&SignedMsgEncodeInfo, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.cSigners = 1;
    SignedMsgEncodeInfo.rgSigners = &SignerEncodeInfo;
    //SignedMsgEncodeInfo.cCertEncoded = 0;
    //SignedMsgEncodeInfo.rgCertEncoded = NULL;
    //SignedMsgEncodeInfo.cCrlEncoded = 0;
    //SignedMsgEncodeInfo.rgCrlEncoded = NULL;

    Status.cBodyList = 1;
    Status.dwOtherInfoChoice = CMC_OTHER_INFO_NO_CHOICE;
    Status.rgdwBodyList = &dwBodyPartIdOfRequest;
    Status.pwszStatusString = pwszDispositionString;

    switch (*pResult->pdwDisposition)
    {
	case CR_DISP_ISSUED:
	case CR_DISP_ISSUED_OUT_OF_BAND:
	case CR_DISP_REVOKED:	// map revoked to CMC_STATUS_FAILED?
	    Status.dwStatus = CMC_STATUS_SUCCESS;
	    break;

	case CR_DISP_UNDER_SUBMISSION:
	    Status.dwStatus = CMC_STATUS_PENDING;
	    Status.dwOtherInfoChoice = CMC_OTHER_INFO_PEND_CHOICE;
	    Status.pPendInfo = &PendInfo;

	    CSASSERT(NULL != prow);
	    prow->GetRowId(&ReqId);

	    PendInfo.PendToken.cbData = sizeof(ReqId);
	    PendInfo.PendToken.pbData = (BYTE *) &ReqId;

	    cb = sizeof(PendInfo.PendTime);
	    hr = prow->GetProperty(
			g_wszPropRequestSubmittedWhen,
			PROPTYPE_DATE | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cb,
			(BYTE *) &PendInfo.PendTime);
	    _JumpIfError(hr, error, "GetProperty");

	    break;

	//case CR_DISP_INCOMPLETE:
	//case CR_DISP_ERROR:
	//case CR_DISP_DENIED:
	default:
	    Status.dwStatus = CMC_STATUS_FAILED;
	    if (NULL != prow)
	    {
		cb = sizeof(hrRequest);
		hr = prow->GetProperty(
			g_wszPropRequestStatusCode,
			PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
			NULL,
			&cb,
			(BYTE *) &hrRequest);
		_JumpIfError(hr, error, "GetProperty(status code)");
	    }
	    switch (hrRequest)
	    {
		case CERTSRV_E_BAD_REQUESTSUBJECT:
		    Status.dwFailInfo = CMC_FAIL_BAD_REQUEST;
		    Status.dwOtherInfoChoice = CMC_OTHER_INFO_FAIL_CHOICE;
		    break;
	    }
	    break;
    }

    // Encode control attributes for Status, Transaction Id, Sender and
    // Recipient Nonces and Issued Cert Hash.

    ZeroMemory(aTaggedAttribute, sizeof(aTaggedAttribute));

    // Status:

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_STATUS,
		    &Status,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &aAttrBlob[iblob].pbData,
		    &aAttrBlob[iblob].cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    aTaggedAttribute[ita].dwBodyPartID = dwBodyPartId++;
    aTaggedAttribute[ita].Attribute.pszObjId = szOID_CMC_STATUS_INFO;
    aTaggedAttribute[ita].Attribute.cValue = 1;
    aTaggedAttribute[ita].Attribute.rgValue = &aAttrBlob[iblob];
    iblob++;
    ita++;

    // Transaction Id:

    if (pResult->fTransactionId)
    {
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			&pResult->dwTransactionId,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aTaggedAttribute[ita].dwBodyPartID = dwBodyPartId++;
	aTaggedAttribute[ita].Attribute.pszObjId = szOID_CMC_TRANSACTION_ID;
	aTaggedAttribute[ita].Attribute.cValue = 1;
	aTaggedAttribute[ita].Attribute.rgValue = &aAttrBlob[iblob];
	iblob++;
	ita++;
    }

    if (NULL != pResult->pbSenderNonce && 0 != pResult->cbSenderNonce)
    {
	CRYPT_DATA_BLOB Blob;
	FILETIME ft;
	DWORD dw;
	DWORD cch;

	// Recipient Nonce:

	Blob.pbData = const_cast<BYTE *>(pResult->pbSenderNonce);
	Blob.cbData = pResult->cbSenderNonce;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			&Blob,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aTaggedAttribute[ita].dwBodyPartID = dwBodyPartId++;
	aTaggedAttribute[ita].Attribute.pszObjId = szOID_CMC_RECIPIENT_NONCE;
	aTaggedAttribute[ita].Attribute.cValue = 1;
	aTaggedAttribute[ita].Attribute.rgValue = &aAttrBlob[iblob];
	iblob++;
	ita++;

	// Sender Nonce:

	GetSystemTimeAsFileTime(&ft);
	dw = GetTickCount();

	cch = sprintf(
		    szNonce,
		    "%u %08lx %08lx-%08lx",
		    *pResult->pdwRequestId,
		    dw,
		    ft.dwHighDateTime,
		    ft.dwLowDateTime);
	CSASSERT(ARRAYSIZE(szNonce) > cch);

	Blob.pbData = (BYTE *) szNonce;
	Blob.cbData = cch;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			&Blob,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aTaggedAttribute[ita].dwBodyPartID = dwBodyPartId++;
	aTaggedAttribute[ita].Attribute.pszObjId = szOID_CMC_SENDER_NONCE;
	aTaggedAttribute[ita].Attribute.cValue = 1;
	aTaggedAttribute[ita].Attribute.rgValue = &aAttrBlob[iblob];
	iblob++;
	ita++;
    }

    // Issued Cert Hash:

    if (NULL != pbCertLeaf)
    {
	CSASSERT(NULL != prow);
	hr = pkcsGetHashAsOctet(
			prow,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData);
	_JumpIfError(hr, error, "pkcsGetHashAsOctet");

	aAttr[iAttr].pszObjId = szOID_ISSUED_CERT_HASH;
	aAttr[iAttr].cValue = 1;
	aAttr[iAttr].rgValue = &aAttrBlob[iblob];
	iblob++;
	iAttr++;
    }

    dwRequestFlags = 0;
    if (NULL != prow)
    {
	cb = sizeof(dwRequestFlags);
	hr = prow->GetProperty(
		    g_wszPropRequestFlags,
		    PROPTYPE_LONG | PROPCALLER_SERVER | PROPTABLE_REQUEST,
		    NULL,
		    &cb,
		    (BYTE *) &dwRequestFlags);
	if (S_OK != hr)
	{
	    _PrintError(hr, "GetProperty");
	    dwRequestFlags = 0;
	}
    }

    // Computed hash of private key encrypted to this CA, for client
    // confirmation.

    if (CR_FLG_VALIDENCRYPTEDKEYHASH & dwRequestFlags)
    {
	CRYPT_DATA_BLOB Blob;

	if (NULL == pResult->pbKeyHashOut)
	{
	    hr = pkcsRetrieveKeyHashFromRequest(
					prow,
					&pResult->pbKeyHashOut,
					&pResult->cbKeyHashOut);
	    _JumpIfError(hr, error, "pkcsRetrieveKeyHashFromRequest");
	}
	Blob.pbData = pResult->pbKeyHashOut;
	Blob.cbData = pResult->cbKeyHashOut;
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			&Blob,
			0,
			CERTLIB_USE_LOCALALLOC,
			&aAttrBlob[iblob].pbData,
			&aAttrBlob[iblob].cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	aAttr[iAttr].pszObjId = szOID_ENCRYPTED_KEY_HASH;
	aAttr[iAttr].cValue = 1;
	aAttr[iAttr].rgValue = &aAttrBlob[iblob];
	iblob++;
	iAttr++;
    }

    if (0 != iAttr)
    {
	hr = BuildCMCAttributes(
			iAttr,		// cAttribute
			aAttr,		// rgAttribute
			dwCMCDataReference,
			dwBodyPartIdOfRequest,
			dwBodyPartId++,
			&aTaggedAttribute[ita],
			&aAttrBlob[iblob]);
	_JumpIfError(hr, error, "BuildCMCAttributes");

	iblob++;
	ita++;
    }

    CSASSERT(ARRAYSIZE(aTaggedAttribute) >= ita);
    CSASSERT(ARRAYSIZE(aAttr) >= iAttr);
    CSASSERT(ARRAYSIZE(aAttrBlob) >= iblob);

    Response.cTaggedAttribute = ita;
    Response.rgTaggedAttribute = aTaggedAttribute;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    CMC_RESPONSE,
		    &Response,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbContent,
		    &cbContent))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    if (NULL == pCAContext)
    {
	pCAContext = g_pCAContextCurrent;
    }
    ZeroMemory(&SignerEncodeInfo, sizeof(SignerEncodeInfo));
    SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);
    SignerEncodeInfo.pCertInfo = pCAContext->pccCA->pCertInfo;
    SignerEncodeInfo.hCryptProv = pCAContext->hProvCA;
    SignerEncodeInfo.dwKeySpec = AT_SIGNATURE;
    SignerEncodeInfo.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    //SignerEncodeInfo.pvHashAuxInfo = NULL;
    //SignerEncodeInfo.cAuthAttr = 0;
    //SignerEncodeInfo.rgAuthAttr = NULL;
    //SignerEncodeInfo.cUnauthAttr = 0;
    //SignerEncodeInfo.rgUnauthAttr = NULL;

    if (NULL != pbCertLeaf)
    {
	hr = pkcsBuildCRLChain(
			pCAContext,
			pbCertLeaf,
			cbCertLeaf,
			fIncludeCRLs,
			&SignedMsgEncodeInfo.cCertEncoded,
			&SignedMsgEncodeInfo.rgCertEncoded,
			&prgCert,
			&SignedMsgEncodeInfo.cCrlEncoded,
			&SignedMsgEncodeInfo.rgCrlEncoded,
			&prgCRL);
	_JumpIfError(hr, error, "pkcsBuildCRLChain");
    }

    hMsg = CryptMsgOpenToEncode(
			PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
			CMSG_CMS_ENCAPSULATED_CONTENT_FLAG,	// dwFlags
			CMSG_SIGNED,
			&SignedMsgEncodeInfo,
			szOID_CT_PKI_RESPONSE,
			NULL);		// pStreamInfo
    if (NULL == hMsg)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgOpenToEncode");
    }

    if (!CryptMsgUpdate(hMsg, pbContent, cbContent, TRUE))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptMsgUpdate");
    }

    // Return the encoded and signed content.
    // Use CMSG_CONTENT_PARAM to get the signed message.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_CONTENT_PARAM,
		    0,
		    CERTLIB_USE_COTASKMEMALLOC,
		    (VOID **) ppbResponse,
		    pcbResponse);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

    if (CRLF_LOG_FULL_RESPONSE & g_dwCRLFlags)
    {
	mydbgDumpHex(DBG_SS_ERROR, 0, *ppbResponse, *pcbResponse);
    }

error:
    pkcsFreeCRLChain(
		SignedMsgEncodeInfo.cCertEncoded,
		SignedMsgEncodeInfo.rgCertEncoded,
		prgCert,
		SignedMsgEncodeInfo.cCrlEncoded,
		SignedMsgEncodeInfo.rgCrlEncoded,
		prgCRL);
    for (i = 0; i < ARRAYSIZE(aAttrBlob); i++)
    {
	if (NULL != aAttrBlob[i].pbData)
	{
	    LocalFree(aAttrBlob[i].pbData);
	}
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pbContent)
    {
	LocalFree(pbContent);
    }
    return(hr);
}


// Build a PKCS7 NULL signature with encapsulated certs

HRESULT
pkcsEncodeCertChain(
    OPTIONAL IN CACTX *pCAContext,
    OPTIONAL IN BYTE const *pbCertLeaf,
    IN DWORD cbCertLeaf,
    IN BYTE const *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCertChain,    // CoTaskMem*
    OUT DWORD *pcbCertChain)
{
    HRESULT hr;
    CRYPT_SIGN_MESSAGE_PARA csmp;
    CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithm = { szOID_OIWSEC_sha1, 0, 0 };

    // init csmp for empty signature

    ZeroMemory(&csmp, sizeof(csmp));
    csmp.cbSize = sizeof(csmp);
    csmp.dwMsgEncodingTyp