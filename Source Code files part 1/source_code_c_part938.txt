	dwStringID is optional. When not specified, it is assumed to
//				be IDS_NONE.
//
//---------------------------------------------------------------------------
void QuitMsiInst (IN const UINT	uExitCode,
				  IN DWORD	dwMsgType,
				  IN DWORD	dwStringID /*= IDS_NONE*/)
{
	DWORD Status = ERROR_SUCCESS;
	
	if (flgNone != dwMsgType)
		ShowErrorMessage (uExitCode, dwMsgType, dwStringID);
	
	//
	// Rollback as gracefully as possible in case of an error.
	// Also, if a reboot was initiated. Then there is not much we can do since
	// we cannot start any new processes anyway. So we just skip this code
	// in that case to avoid ugly pop-ups about being unable to start the 
	// applications because the system is shutting down.
	//
	if (ERROR_SUCCESS != uExitCode &&
		ERROR_SUCCESS_REBOOT_REQUIRED != uExitCode &&
		ERROR_SUCCESS_REBOOT_INITIATED != uExitCode)
	{
		// First unregister the installer from the temp. location.
		if (TEXT('\0') != g_szTempStore && 
			FileExists (TEXT("msiexec.exe"), g_szTempStore, FALSE) &&
			FileExists (TEXT("msi.dll"), g_szTempStore, FALSE) &&
			SetCurrentDirectory(g_szTempStore))
		{
			DebugMsg((TEXT("Unregistering the installer from the temporary location.")));
			RunProcess (g_szExecLocal, g_szUnregister, Status);
		}
		// Then reregister the installer from the system folder if possible.
		if (TEXT('\0') != g_szSystemDir &&
			SetCurrentDirectory(g_szSystemDir) &&
			FileExists (TEXT("msiexec.exe"), g_szSystemDir, FALSE) &&
			FileExists (TEXT("msi.dll"), g_szSystemDir, FALSE))
		{
			DebugMsg((TEXT("Reregistering the installer from the system folder.")));
			RunProcess (g_szExecLocal, g_szRegister, Status);
		}
		
		//
		// The rereg value that we put in the run once key is not required
		// anymore. So get rid of it.
		//
		if (TEXT('\0') != g_szRunOnceRereg[0])
		{
			DebugMsg((TEXT("Deleting the RunOnce value for registering the installer from the temp. folder.")));
			DelRunOnceValue (g_szRunOnceRereg);
		}
		
		//
		// Purge NT4 upgrade migration inf and cat files since they are not
		// queued up for deletion upon reboot. Ignore any errors.
		//
		PurgeNT4MigrationFiles();
	}
	else
	{
		//
		// If we are on NT4, register our exception package on success so that 
		// upgrades to Win2K don't overwrite our new darwin bits with its older bits
		// Ignore errors.
		//
		HandleNT4Upgrades();
	}

	// Exit the process
	DebugMsg((TEXT("Exiting msiinst.exe with error code %d."), uExitCode));
	ExitProcess (uExitCode);
}

//+--------------------------------------------------------------------------
//
//  Function:	ModifyCommandLine
//
//  Synopsis:	Looks at the command line and adds any transform information
//				if necessary. It also generates the command line for suppressing
//				reboots if the "delayreboot" option is chosen.
//
//  Arguments:	[in] szCmdLine : the original command line with which msiinst is invoked.
//				[in] opMode : indicate the operation mode for msiinst: normal, delayed boot with UI or delayed boot without UI
//				[in] fRebootRequested : a reboot is requested is needed due to processing to this point
//				[out] szFinalCmdLine : the processed commandline.
//
//  Returns:	ERROR_SUCCESS if succesful.
//				an error code otherwise.
//
//  History:	10/10/2000  RahulTh  created
//
//  Notes:		This function does not verify the validity of the passed in
//				parameters. That is the responsibility of the caller.
//
//---------------------------------------------------------------------------
DWORD ModifyCommandLine (IN LPCTSTR szCmdLine,
						 IN const OPMODE	opMode,
						 IN const BOOL fRebootRequested,
						 OUT LPTSTR szFinalCmdLine
						 )
{
	WIN32_FIND_DATA FindFileData;
	HANDLE			hFind = INVALID_HANDLE_VALUE;
	IStorage*		piStorage = NULL;
	const OLECHAR * szwImport;
	HRESULT			hResult;
	LANGID			wLanguage;
	const TCHAR *	szCommand;
	BOOL fRebootNeeded = FALSE;
	const TCHAR szInstallSDBProperty[] = TEXT(" INSTALLSDB=1");
	
	switch (opMode)
	{
	case opNormal:
		fRebootNeeded = fRebootRequested;
		// reboots not allowed in any of the quiet modes.
	case opNormalQuiet:
		szCommand = szCmdLine;
		break;
	case opDelayBoot:
		szCommand = g_szDelayedBootCmdLine;
		break;
	case opDelayBootQuiet:
		szCommand = g_szDelayedBootCmdLineQuiet;
		break;
	default:
		DebugMsg((TEXT("Invalid operation mode: %d."), opMode));
		break;
	}
	
	// Find the database, and open the storage to look for transforms
	hFind = FindFirstFile(TEXT("*msi.msi"), &FindFileData);
	if (INVALID_HANDLE_VALUE == hFind) 
		return GetLastError();
	FindClose(hFind);

	DebugMsg((TEXT("Found MSI Database: %s"), FindFileData.cFileName));

	// convert base name to unicode
#ifndef UNICODE
	OLECHAR rgImportPathBuf[MAX_PATH];
	int cchWide = ::MultiByteToWideChar(CP_ACP, 0, (LPCTSTR)FindFileData.cFileName, -1, rgImportPathBuf, MAX_PATH);
	szwImport = rgImportPathBuf;
#else	// UNICODE
	szwImport = FindFileData.cFileName;
#endif

	hResult = StgOpenStorage(szwImport, (IStorage*)0, STGM_READ | STGM_SHARE_EXCLUSIVE, (SNB)0, (DWORD)0, &piStorage);
	if (S_OK == hResult)
	{

		// choose the appropriate transform

		// This algorithm is basically MsiLoadString.  It needs to stay in sync with 
		// MsiLoadStrings algorithm
		wLanguage = GetUserDefaultLangID();

		if (wLanguage == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE))   // this one language does not default to base language
			wLanguage  = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
	
		if (!FindTransform(piStorage, wLanguage)   // also tries base language and neutral
		  && (!FindTransform(piStorage, wLanguage = (WORD)GetUserDefaultLangID())) 
		  && (!FindTransform(piStorage, wLanguage = (WORD)GetSystemDefaultLangID())) 
		  && (!FindTransform(piStorage, wLanguage = LANG_ENGLISH)
		  && (!FindTransform(piStorage, wLanguage = LANG_NEUTRAL))))
		{
			// use default
			if (fRebootNeeded)
			{		
				wsprintf(szFinalCmdLine, TEXT("%s %s=%s"), szCommand, g_szMsiRebootProperty, g_szMsiRebootForce);
			}
			else
			{
				stringcopy (szFinalCmdLine, szCommand, 1024);
				szFinalCmdLine[1023] = TEXT('\0');
			}
			DebugMsg((TEXT("No localized transform available.")));
		}
		 else
		{
			// this assumes that there is no REBOOT property set from the instmsi.sed file when fRebootNeeded == FALSE
			TCHAR* pszFormat = (fRebootNeeded) ? TEXT("%s TRANSFORMS=:%d.mst %s=%s") : TEXT("%s TRANSFORMS=:%d.mst");

			// use the transform for the given language.
			wsprintf(szFinalCmdLine, pszFormat, szCommand, wLanguage, g_szMsiRebootProperty, g_szMsiRebootForce);
		}

		piStorage->Release();
	}
	else
	{
		return GetWin32ErrFromHResult(hResult);
	}
	
	if (ShouldInstallSDBFiles() &&
		MAXCMDLINELEN >= (lstrlen(szFinalCmdLine) + sizeof(szInstallSDBProperty)))
	{
		lstrcat (szFinalCmdLine, szInstallSDBProperty);
	}
	
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimerg\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiloc\sources.inc ===
TARGETNAME=MsiLoc
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

USE_LIBCMT=1
USE_NATIVE_EH=1

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\user32.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR);

SOURCES=..\msiloc.cpp \
		..\msiloc.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimerg\msimerg.cpp ===
#if 0  // makefile definitions
DESCRIPTION = Merge Database Utility
MODULENAME = MsiMerg
SUBSYSTEM = console
FILEVERSION = Msi
LINKLIBS = OLE32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       msimerg.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f msimerg.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 Console Application project
//      2. Add msimerg.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

#define W32DOWS_LEAN_AND_MEAN  // faster compile
#define W32
#define MSI

#include <windows.h>
#ifndef RC_INVOKED    // start of source code
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <stdio.h>
#include "MsiQuery.h" // MSI API

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

const TCHAR szHelp[] = TEXT("Copyright (C) Microsoft Corporation, 1997-2001.  All rights reserved.\nMsi Merge Tool --- Merge Two Databases\n\nMsiMerg(d).exe {base db} {ref db}\n");
const TCHAR szTable[] = TEXT("_MergeErrors");

const int cchDisplayBuf = 4096;										
HANDLE g_hStdOut;
TCHAR g_rgchBuffer[4096];

//________________________________________________________________________________
//
// Function prototypes
//________________________________________________________________________________

void Display(LPCTSTR szMessage);
void ErrorExit(UINT iError, LPCTSTR szMessage);
void CheckError(UINT iError, LPCTSTR szMessage);
void Merge(TCHAR* szBaseDb, TCHAR* szRefDb);

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// Determine handle
	g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped
	
	if (argc == 2 && ((_tcscmp(argv[1], TEXT("-?")) == 0) || (_tcscmp(argv[1], TEXT("/?")) == 0)))
		ErrorExit( 0, szHelp);

	// Check for enough arguments and valid options
	CheckError(argc != 3, TEXT("msimerg(d).exe {base db} {ref db}"));
	Merge(argv[1], argv[2]);
	ErrorExit(0, TEXT("Done"));
	return 0;
}


//________________________________________________________________________________
//
// Merge function
//    Merge(...);
//________________________________________________________________________________

void Merge(TCHAR* szBaseDb, TCHAR* szRefDb)
{
	PMSIHANDLE hBaseDb = 0;
	PMSIHANDLE hRefDb = 0;

	CheckError(MSI::MsiOpenDatabase(szBaseDb, MSIDBOPEN_TRANSACT, &hBaseDb), TEXT("Error Opening Base Database"));
	CheckError(MSI::MsiOpenDatabase(szRefDb, MSIDBOPEN_READONLY, &hRefDb), TEXT("Error Opening Reference Databaes"));
	UINT uiError = MSI::MsiDatabaseMerge(hBaseDb, hRefDb, szTable);
	CheckError(MSI::MsiDatabaseCommit(hBaseDb), TEXT("Error Saving Database"));
	CheckError(uiError, TEXT("Error Merging Database, Check _MergeErrors Table for Merge conflicts"));
}

//________________________________________________________________________________
//
// Error handling and Display functions:
//    Display(...);
//	   ErrorExit(...);
//    CheckError(...);
//
//________________________________________________________________________________

void Display(LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut = _tcsclen(szMessage);;
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif
			DWORD cbWritten;
			W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
	}
}


void ErrorExit(UINT iError, LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut;
		TCHAR szBuffer[256];  // errors only, not used for display output
		if (iError == 0)
			cbOut = lstrlen(szMessage);
		else
		{
			LPCTSTR szTemplate = (iError & 0x80000000L)
										? TEXT("Error 0x%X. %s\n")
										: TEXT("Error %i. %s\n");
			cbOut = _stprintf(szBuffer, szTemplate, iError, szMessage);
			szMessage = szBuffer;
		}
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif // UNICODE
			DWORD cbWritten;
			W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
	}
	MSI::MsiCloseAllHandles();
	W32::ExitProcess(szMessage != 0);
}

void CheckError(UINT iError, LPCTSTR szMessage)
{
	if (iError != ERROR_SUCCESS)
		ErrorExit(iError, szMessage);
}

#else // RC_INVOKED, end of source code, start of resources
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimerg\sources.inc ===
TARGETNAME=MsiMerg
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\OLE32.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msimerg.cpp \
	..\msimerg.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiloc\msiloc.cpp ===
#if 0  // makefile definitions
DESCRIPTION = MSI Localization tool
MODULENAME = msiloc
SUBSYSTEM = console
FILEVERSION = MSI
LINKLIBS = OLE32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+--------------------------------------------------------------------------------------------------+\\
//                                                                                                    \\
//  Microsoft Windows                                                                                 \\
//                                                                                                    \\
//  Copyright (C) Microsoft Corporation, 1999-2001                                                         \\
//                                                                                                    \\
//  File:       msiloc.cpp                                                                            \\
//                                                                                                    \\
//----------------------------------------------------------------------------------------------------\\ 

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f msiloc.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 Console Application project
//      2. Add msiloc.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>

#ifndef RC_INVOKED    // start of source code

#ifndef W32	// if W32 not defined
#define W32
#endif	// W32 defined

#ifndef MSI	// if MSI not defined
#define MSI
#endif	// MSI defined


///////////////////////////////////////////////////////////////////////////////
// HEADERS
#include "msiquery.h"
#include "msidefs.h"
#include <stdio.h>   // wprintf
#include <stdlib.h>  // strtoul
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <assert.h>  // assert

/////////////////////////////////////////////////////////////////////////////
// CONSTANT STRINGS
/*headers for resource file*/
const TCHAR szWndwHdrFile[]      = TEXT("#include <windows.h>");
const TCHAR szCommCtrlHdrFile[]  = TEXT("#include <commctrl.h>");
/*tabs and carriage returns*/
const TCHAR szCRLF[]             = TEXT("\r\n");
const TCHAR szCommaTab[]         = TEXT(",\t");
const TCHAR szTab[]              = TEXT("\t");
const TCHAR szCurlyBeg[]         = TEXT("{");
const TCHAR szCurlyEnd[]         = TEXT("}");
const TCHAR szQuotes[]           = TEXT("\"");
/*resource types or keywords WINDOWS*/
const TCHAR resDialog[]          = TEXT("DIALOGEX");
const TCHAR resPushButton[]      = TEXT("PUSHBUTTON");
const TCHAR resCheckBox[]        = TEXT("CHECKBOX");
const TCHAR resGroupBox[]        = TEXT("GROUPBOX");
const TCHAR resRadioButton[]     = TEXT("RADIOBUTTON");
const TCHAR resControl[]         = TEXT("CONTROL");
const TCHAR resBitmap[]          = TEXT("BITMAP");
const TCHAR resIcon[]            = TEXT("ICON");
const TCHAR resJPEG[]            = TEXT("JPEG");
const TCHAR resStringTable[]     = TEXT("STRINGTABLE");
const TCHAR tokCaption[]         = TEXT("CAPTION");
const TCHAR resSelTreeClass[]   = TEXT("WC_TREEVIEW");
const TCHAR resButtonClass[]    = TEXT("BUTTON");
const TCHAR resProgBar32Class[] = TEXT("PROGRESS_CLASS");
const TCHAR resListViewClass[]  = TEXT("WC_LISTVIEW");
const TCHAR resStaticClass[]    = TEXT("STATIC");
const TCHAR resComboBoxClass[]  = TEXT("COMBOBOX");
const TCHAR resEditClass[]      = TEXT("EDIT");
const TCHAR resListBoxClass[]   = TEXT("LISTBOX");
const TCHAR resRichEditClass[]  = TEXT("STATIC"); // TEXT("RICHEDIT") not working;
/*control types INSTALLER*/
const TCHAR* szMsiPushbutton =      TEXT("PushButton");
const TCHAR* szMsiBillboard  =      TEXT("Billboard");
const TCHAR* szMsiVolumeCostList =  TEXT("VolumeCostList");
const TCHAR* szMsiScrollableText =  TEXT("ScrollableText");
const TCHAR* szMsiMaskedEdit =      TEXT("MaskedEdit");
const TCHAR* szMsiCheckBox =        TEXT("CheckBox");
const TCHAR* szMsiGroupBox =        TEXT("GroupBox");
const TCHAR* szMsiText =            TEXT("Text");
const TCHAR* szMsiListBox =         TEXT("ListBox");
const TCHAR* szMsiEdit =            TEXT("Edit");
const TCHAR* szMsiPathEdit =        TEXT("PathEdit");
const TCHAR* szMsiProgressBar =     TEXT("ProgressBar");
const TCHAR* szMsiDirList =         TEXT("DirectoryList");
const TCHAR* szMsiList =            TEXT("ListView");
const TCHAR* szMsiComboBox =        TEXT("ComboBox");
const TCHAR* szMsiDirCombo =        TEXT("DirectoryCombo");
const TCHAR* szMsiVolSelCombo =     TEXT("VolumeSelectCombo");
const TCHAR* szMsiRadioButtonGroup =TEXT("RadioButtonGroup");
const TCHAR* szMsiRadioButton =     TEXT("RadioButton");
const TCHAR* szMsiBitmap =          TEXT("Bitmap");
const TCHAR* szMsiSelTree =         TEXT("SelectionTree");
const TCHAR* szMsiIcon =            TEXT("Icon");
const TCHAR* szMsiLine =            TEXT("Line");
/*max sizes*/
const int iMaxResStrLen          = 256;
const TCHAR strOverLimit[]       = TEXT("!! STR OVER LIMIT !!");
////////////////////////////////////////////////////////////////////////
// EXPORT SQL QUERIES
/*particular column of strings from a particular table*/
const TCHAR* sqlStrCol = TEXT("SELECT %s, `%s` FROM `%s`");
const TCHAR sqlCreateStrMap[] = TEXT("CREATE TABLE `_RESStrings` (`Table` CHAR(72) NOT NULL, `Column` CHAR(72) NOT NULL, `Key` CHAR(0), `RCID` SHORT NOT NULL PRIMARY KEY `Table`, `Column`, `Key`)");
const TCHAR* sqlSelMaxStrRcId = TEXT("SELECT `RCID` FROM `_RESStrings` WHERE `Table`='MAX_RESOURCE_ID' AND `Column`='MAX_RESOURCE_ID'");
const TCHAR* sqlStrMark = TEXT("SELECT `Table`,`Column`, `Key`, `RCID` FROM `_RESStrings`");
const TCHAR* sqlInsertStr = TEXT("SELECT `Table`,`Column`,`Key`, `RCID` FROM `_RESStrings`");
const TCHAR* sqlFindStrResId  = TEXT("SELECT `RCID` FROM `_RESStrings` WHERE `Table`='%s' AND `Column`='%s' AND `Key`='%s'");
/*binary table*/
const TCHAR* sqlBinary = TEXT("SELECT `Name`,`Data` FROM `Binary`");
const int ibcName = 1; // these constants must match query above
const int ibcData = 2;
/*dialog table*/
const TCHAR* sqlCreateDlgMap = TEXT("CREATE TABLE `_RESDialogs` (`RCStr` CHAR(72) NOT NULL, `Dialog` CHAR(72) PRIMARY KEY `RCStr`)");
const TCHAR* sqlDlgMap = TEXT("SELECT `RCStr`,`Dialog` FROM `_RESDialogs`");
const TCHAR* sqlDialog = TEXT("SELECT `Dialog`,`HCentering`,`VCentering`,`Width`,`Height`,`Attributes`,`Title` FROM `Dialog`");
const TCHAR* sqlDialogSpecific = TEXT("SELECT `Dialog`,`HCentering`,`VCentering`,`Width`,`Height`,`Attributes`,`Title` FROM `Dialog` WHERE `Dialog`=?");
const int idcName   = 1; // these constants must match query above
const int idcX      = 2;
const int idcY      = 3;
const int idcWd     = 4;
const int idcHt     = 5;
const int idcAttrib = 6;
const int idcTitle  = 7;
/*control table*/
const TCHAR* sqlCreateCtrlMark = TEXT("CREATE TABLE `_RESControls` (`Dialog_` CHAR(72) NOT NULL, `Control_` CHAR(72) NOT NULL, `RCID` INT NOT NULL  PRIMARY KEY `Dialog_`, `Control_`)"); 
const TCHAR* sqlCtrlMark = TEXT("SELECT `Dialog_`,`Control_`,`RCID` FROM `_RESControls`");
const TCHAR* sqlSelMaxRcId = TEXT("SELECT `RCID` FROM `_RESControls` WHERE `Dialog_`='MAX_RESOURCE_ID' AND `Control_`='MAX_RESOURCE_ID'");
const TCHAR* sqlInsertCtrl = TEXT("SELECT `Dialog_`,`Control_`,`RCID` FROM `_RESControls`");
const TCHAR* sqlFindResId  = TEXT("SELECT `RCID` FROM `_RESControls` WHERE `Dialog_`='%s' AND `Control_`='%s'");
const TCHAR* sqlControl = TEXT("SELECT `Control`,`Type`,`X`,`Y`,`Width`,`Height`,`Attributes`,`Text`,`Property` FROM `Control` WHERE `Dialog_`=?");
const int iccName    = 1; // these constants must match query above
const int iccType    = 2;
const int iccX       = 3;
const int iccY       = 4;
const int iccWd      = 5;
const int iccHt      = 6;
const int iccAttrib  = 7;
const int iccText    = 8;
const int iccProperty= 9;
/*radiobutton table*/
const TCHAR* sqlRadioButton = TEXT("SELECT `Order`, `X`, `Y`, `Width`, `Height`, `Text` FROM `RadioButton` WHERE `Property`=?");
const int irbcOrder = 1; // these constants must match query above
const int irbcX     = 2;
const int irbcY     = 3;
const int irbcWd    = 4;
const int irbcHt    = 5;
const int irbcText  = 6;
////////////////////////////////////////////////////////////////////////
// IMPORT SQL QUERIES
/*dialog table*/
const TCHAR* sqlDialogImport = TEXT("SELECT `HCentering`,`VCentering`,`Width`,`Height`,`Title` FROM `Dialog` WHERE `Dialog`=?");
const int idiHCentering = 1; // these constants must match query above
const int idiVCentering = 2;
const int idiWidth      = 3;
const int idiHeight     = 4;
const int idiTitle      = 5;
/*control table*/
const TCHAR* sqlControlImport = TEXT("SELECT `X`,`Y`,`Width`,`Height`,`Text` FROM `Control` WHERE `Dialog_`=? AND `Control`=?");
const int iciX          = 1; // these constants must match query above
const int iciY          = 2;
const int iciWidth      = 3;
const int iciHeight     = 4;
const int iciText       = 5;
/*radiobutton table*/
const TCHAR* sqlRadioButtonImport = TEXT("SELECT `Width`, `Height`, `Text` FROM `RadioButton` WHERE `Property`=? AND `Order`=?");
const int irbiWidth     = 1; // these constants must match query above
const int irbiHeight    = 2;
const int irbiText      = 3;
/*string table*/
const TCHAR* sqlStringImport = TEXT("SELECT `%s` FROM `%s` WHERE ");
const TCHAR* sqlStrTemp      = TEXT("SELECT * FROM `%s`");
/*find Installer name*/
const TCHAR sqlDialogInstallerName[] = TEXT("SELECT `Dialog` FROM `_RESDialogs` WHERE `RCStr`=?");
const TCHAR sqlControlInstallerName[] = TEXT("SELECT `Dialog_`,`Control_` FROM `_RESControls` WHERE `RCID`=?");
const TCHAR sqlStringInstallerName[] = TEXT("SELECT `Table`,`Column`,`Key` FROM `_RESStrings` WHERE `RCID`=? AND `Table`<>'MAX_RESOURCE_ID'");
//////////////////////////////////////////////////////////////////////////
// MISCELLANEOUS - CODEPAGE, etc.
const TCHAR szTokenSeps[] = TEXT(":");
const TCHAR* szCodepageFile = TEXT("codepage.idt");
const TCHAR* szForceCodepage = TEXT("_ForceCodepage");
const TCHAR* szLineFeed = TEXT("\r\n\r\n");
const TCHAR* szCodepageExport = TEXT("_ForceCodepage.idt");
//////////////////////////////////////////////////////////////////////////
// COMMAND LINE PARSING
/*mode*/
const int iEXPORT_MSI     = 1 << 0;
const int iIMPORT_RES     = 1 << 1;
/*data type*/
const int iDIALOGS = 1 << 2;
const int iSTRINGS = 1 << 3;
/*extra options*/
const int iSKIP_BINARY = 1 << 4;
const int iCREATE_NEW_DB = 1 << 5;
/*max values*/
const int MAX_DIALOGS = 32;
const int MAX_STRINGS = 32;
////////////////////////////////////////////////////////////////////////////
// ENUMS
static enum bdtBinaryDataType
{
	bdtBitmap,        // bitmap
	bdtJPEG,          // JPEG
	bdtIcon,          // Icon
	bdtEXE_DLL_SCRIPT // EXE, DLL, or SCRIPT
};
/////////////////////////////////////////////////////////////////////////////
// FUNCTION PROTOTYPES
BOOL __stdcall EnumDialogCallback(HINSTANCE hModule, const TCHAR* szType, TCHAR* szDialogName, long lParam);
BOOL __stdcall EnumStringCallback(HINSTANCE hModule, const TCHAR* szType, TCHAR* szName, long lParam);
BOOL __stdcall EnumLanguageCallback(HINSTANCE hModule, const TCHAR* szType, const TCHAR* szName, WORD wIDLanguage, long lParam);
/////////////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES - IMPORT 
UINT g_uiCodePage;
WORD g_wLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL); // initialize to language neutral


//__________________________________________________________________________________________
//
// CLASSES
//__________________________________________________________________________________________

/////////////////////////////////////////////////////////////////////////////
// class CGenerateRC -- handles creation of .rc file from .msi database
//
class CGenerateRC
{
public: // constructor and destructor
	CGenerateRC(const TCHAR* szDatabase, const TCHAR* szSavedDatabase) : m_szDatabase(szSavedDatabase), m_szOrigDb(szDatabase),
		m_hFile(0), m_hDatabase(0), m_iCtrlResID(0), m_fError(FALSE), m_cWriteFileErr(0), m_iStrResID(0), m_fWroteBinary(FALSE){};
	~CGenerateRC();
public: // methods
	UINT OutputDialogs(BOOL fBinary);
	UINT OutputDialog(TCHAR* szDialog, BOOL fBinary);
	UINT OutputString(TCHAR* szTable, TCHAR* szColumn);
	BOOL IsInErrorState(){return m_fError;}
private: // methods
	UINT   Initialize();
	UINT   CreateResourceFile();
	BOOL   WriteDialogToRC(TCHAR* szDialog, TCHAR* szTitle, int x, int y, int wd, int ht, int attrib);
	BOOL   PrintDimensions(int x, int y, int wd, int ht);
	BOOL   OutputControls(TCHAR* szDialog);
	UINT   OutputDialogInit(BOOL fBinary);
	UINT   OutputDialogFinalize();
	UINT   OutputStringInit();
	BOOL   WriteBinaries();
	BOOL   WriteRadioButtons(TCHAR* szDialog, TCHAR* szRBGroup, TCHAR* szProperty, int x, int y, int attrib);
	BOOL   WriteControlToRC(TCHAR* szDialog, TCHAR* szCtrlName, TCHAR* szCtrlType, TCHAR* szCtrlText, TCHAR* szCtrlProperty, int x,
							int y, int wd, int ht, int attrib);
	BOOL   WriteStdWinCtrl(int iResId, const TCHAR* resType, TCHAR* szCtrlText, int x, int y, int wd, int ht, int attrib);
	BOOL   WriteWin32Ctrl(int iResId, const TCHAR* szClass, TCHAR* szCtrlText, TCHAR* szAttrib, int x, int y, int wd, int ht, int attrib);
	UINT   VerifyDatabaseCodepage();
	TCHAR* EscapeSlashAndQuoteForRC(TCHAR* szStr);
private: // data
	const TCHAR* m_szDatabase; // name of database to generate from
	const TCHAR* m_szOrigDb;   // name of original database
	HANDLE       m_hFile;      // handle to resource file
	MSIHANDLE    m_hDatabase;  // handle to database
	int          m_iCtrlResID; // current max resource Id used for controls
	int          m_iStrResID;  // current max resource Id used for strings
	BOOL         m_fError;     // store current error state
	BOOL         m_fWroteBinary;// already wrote binary data to rc file
	int          m_cWriteFileErr; // number of write file errors
};

///////////////////////////////////////////////////////////////////////////////
// class CImportRes -- handles import of resource .dll file into .msi database
//
class CImportRes
{
public: // constructor and destructor
	CImportRes(const TCHAR* szDatabase, const TCHAR* szSaveDatabase, const TCHAR* szDLLFile) : m_szDatabase(szSaveDatabase), m_szOrigDb(szDatabase), m_szDLLFile(szDLLFile), m_hDatabase(0), m_fError(FALSE),
				m_hControl(0), m_hDialog(0), m_hRadioButton(0), m_hInst(0), m_fSetCodepage(FALSE), m_fFoundLang(FALSE){};
   ~CImportRes();
public: // methods
	UINT ImportDialogs();
	UINT ImportStrings();
	UINT ImportDialog(TCHAR* szDialog);
	BOOL IsInErrorState(){return m_fError;}
public: // but only for enumeration purposes
	BOOL WasLanguagePreviouslyFound(){return m_fFoundLang;}
	void SetFoundLang(BOOL fValue){ m_fFoundLang = fValue; }
	BOOL LoadDialog(HINSTANCE hModule, const TCHAR* szType, TCHAR* szDialog);
	BOOL LoadString(HINSTANCE hModule, const TCHAR* szType, TCHAR* szString);
	void SetErrorState(BOOL fState) { m_fError = fState; }
	BOOL SetCodePage(WORD wLang);
private: // methods
	UINT ImportDlgInit();
	UINT Initialize();
	UINT VerifyDatabaseCodepage();
private: // data
	const TCHAR* m_szOrigDb;   // orginal database for opening
	const TCHAR* m_szDatabase; // name of database to save to, optional if you want to create a new Db
	const TCHAR* m_szDLLFile;  // name of DLL file to import
	MSIHANDLE    m_hDatabase;  // handle to database
	MSIHANDLE    m_hControl;   // handle to control table
	MSIHANDLE    m_hDialog;    // handle to dialog table
	MSIHANDLE    m_hRadioButton;// handle to radiobutton table
	BOOL         m_fError;     // store current error state
	HINSTANCE    m_hInst;      // DLL (with localized resources)
	BOOL         m_fSetCodepage; // whether codepage of database has been set
	BOOL         m_fFoundLang;  // whether resource has already been found in previous language
};

///////////////////////////////////////////////////////////////////////////////////////
// CDialogStream class -- used for walking DLGTEMPLATEEX and DLGITEMTEMPLATE in memory
//
class CDialogStream  
{
public:  
	short  __stdcall GetInt16();
	int    __stdcall GetInt32();
	int    __stdcall GetInt8();
	TCHAR* __stdcall GetStr();
	BOOL   __stdcall Align16();
	BOOL   __stdcall Align32();
	BOOL   __stdcall Undo16();
	BOOL   __stdcall Move(int cbBytes);
public:  // constructor, destructor
	 CDialogStream(HGLOBAL hResource);
	~CDialogStream();
private:
	char*  m_pch;
};

//_______________________________________________________________________________________
//
// CGENERATERC CLASS IMPLEMENTATION
//_______________________________________________________________________________________

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::~CGenerateRC
// --  Handles destruction of necessary objects.
// --  Commits database if no errors
CGenerateRC::~CGenerateRC()
{
	UINT iStat;
	if (m_hFile)
		W32::CloseHandle(m_hFile);
	if (m_hDatabase)
	{
		// commit database for internal tables
		// only commit database if no errors
		if (!m_fError && !m_cWriteFileErr)
		{
			if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseCommit(m_hDatabase)))
				_tprintf(TEXT("!! DATABASE COMMIT FAILED.  Error = %d\n"), iStat);
		}
		else
			_tprintf(TEXT("!! NO CHANGES SAVED TO DATABASE. '%d' WriteFile errors occured. Error state = %s\n"), m_cWriteFileErr, m_fError ? TEXT("ERRORS OCCURED") : TEXT("NO ERRORS"));
		MSI::MsiCloseHandle(m_hDatabase);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::CreateResourceFile
// -- Creates .rc file using base name from .msi file
// -- Outputs required header files to .rc file
UINT CGenerateRC::CreateResourceFile()
{
	// assumption of database with ".msi" extension
	// resource file generated from the database we are saving to
	// if m_szDatabase = NULL, then no output database specified, so use m_szOrigDb
	// if m_szDatabase, then output database specified, so use m_szDatabase
	int cLen = _tcsclen(m_szDatabase ? m_szDatabase : m_szOrigDb);
	TCHAR* szFile = new TCHAR[cLen+1];
	_tcscpy(szFile, m_szDatabase ? m_szDatabase : m_szOrigDb); // copy name over
	assert(szFile[cLen-1] == TEXT('i') && szFile[cLen-2] == TEXT('s') && szFile[cLen-3] == TEXT('m'));

	// remove "msi" and change to "rc"
	szFile[cLen-1] = TEXT('\0');
	szFile[cLen-2] = TEXT('c');
	szFile[cLen-3] = TEXT('r');

	if (m_szDatabase)
		_tprintf(TEXT("LOG>> Original Database: %s, Saved Database: %s, Generated RC File: %s\n"), m_szOrigDb, m_szDatabase, szFile);
	else
		_tprintf(TEXT("LOG>> Database: %s, Generated RC file: %s\n"), m_szOrigDb , szFile);

	// attempt to create resource file
	m_hFile = W32::CreateFile(szFile, GENERIC_WRITE, FILE_SHARE_WRITE, 
								0, CREATE_ALWAYS, 0, 0);
	if (!m_hFile)
	{
		_tprintf(TEXT("Unable to create resource file: %s\n"), szFile);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}

	// write required headers to resource file (needed for successful compilation)
	DWORD dwBytesWritten; 
	// need <windows.h> for most rc requirements
	if (!W32::WriteFile(m_hFile, szWndwHdrFile, sizeof(szWndwHdrFile)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;
	// need <commctrl.h> for listview control
	if (!W32::WriteFile(m_hFile, szCommCtrlHdrFile, sizeof(szCommCtrlHdrFile)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;

	// whitespace output (required)
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwBytesWritten, 0))
		m_cWriteFileErr++;

	// return success 
	return m_cWriteFileErr ? ERROR_FUNCTION_FAILED : ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteBinaries
BOOL CGenerateRC::WriteBinaries()
{
	m_fWroteBinary = TRUE;
	MSICONDITION eCond = MSI::MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("Binary"));
	if (eCond == MSICONDITION_ERROR)
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseIsTablePersisent(Binary)\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	if (eCond != MSICONDITION_TRUE)
	{
		_tprintf(TEXT("LOG>> Binary table does not exist or is not persistent\n"));
		return TRUE;
	}
	
#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN WRITING BINARY DATA TO RESOURCE FILE...\n"));
#endif

	UINT iStat;
	PMSIHANDLE hViewBinary = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlBinary, &hViewBinary)))
		return m_fError = TRUE, FALSE; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewBinary, 0)))
		return m_fError = TRUE, FALSE; // error - ABORT
	PMSIHANDLE hRecBinary = 0;
	bdtBinaryDataType bdt;
	DWORD dwWritten;
	while (ERROR_SUCCESS == (iStat = MSI::MsiViewFetch(hViewBinary, &hRecBinary)))
	{
		TCHAR szFileBuf[2*MAX_PATH];
		TCHAR szPathBuf[MAX_PATH+1];
		DWORD dwLen;
		MSI::MsiRecordGetString(hRecBinary, ibcName, TEXT(""), &dwLen);
		TCHAR* szName = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecBinary, ibcName, szName, &dwLen)))
			return m_fError = TRUE, FALSE; // error - ABORT

		// find the temp directory to dump out the binary data into temp files
		if (0 == W32::GetTempPath(MAX_PATH, szPathBuf))
			return m_fError = TRUE, FALSE; // error - ABORT
		// generate a temporary file name, prefix with IBD for Installer Binary Data
		if (0 == W32::GetTempFileName(szPathBuf, TEXT("IBD"), 0, szFileBuf))
			return m_fError = TRUE, FALSE; // error - ABORT
		// create the file
		HANDLE hBinFile = W32::CreateFile(szFileBuf, GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0);
		// verify handle
		if (hBinFile == INVALID_HANDLE_VALUE)
			return m_fError = TRUE, FALSE; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>Binary data temp file created: '%s'\n"), szFileBuf);
#endif

		// read in stream of data and write to file
		char szStream[1024];
		DWORD cbBuf = sizeof(szStream);
		BOOL fFirstRun = TRUE;
		do 
		{
			if (MsiRecordReadStream(hRecBinary, ibcData, szStream, &cbBuf) !=ERROR_SUCCESS)
				break; /* error */
			if (fFirstRun)
			{
				// binary data prefixed with "BM" in stream
				if (szStream[0] == 'B' && szStream[1] == 'M')
					bdt = bdtBitmap;
				else if (szStream[0] == 0xFF && szStream[1] == 0xD8)
					bdt = bdtJPEG;
				else if (szStream[0] == 'M' && szStream[1] == 'Z')
					bdt = bdtEXE_DLL_SCRIPT; // 'MZ prefix with exe's and dll's
				else if (szStream[0] == 0x00 && szStream[1] == 0x00)
					bdt = bdtIcon;
				else bdt = bdtEXE_DLL_SCRIPT;
#ifdef DEBUG
			if (fFirstRun && bdt != bdtEXE_DLL_SCRIPT)
				_tprintf(TEXT("LOG>> Writing <%s> '%s'\n"), bdt == bdtIcon ? TEXT("ICON") : ((bdt == bdtJPEG) ? TEXT("JPEG") : TEXT("BITMAP")), szName);
#endif // DEBUG
				fFirstRun = FALSE;
			}
			if (cbBuf && bdt != bdtEXE_DLL_SCRIPT)
			{
				if (!WriteFile(hBinFile, szStream, cbBuf, &dwWritten, 0))
					return m_fError = TRUE, FALSE; // error - ABORT
			}
		}
		while (cbBuf == sizeof(szStream) && bdt != bdtEXE_DLL_SCRIPT);
		
		// close file
		if (!W32::CloseHandle(hBinFile))
			return m_fError = TRUE, FALSE; // error - ABORT

		if (bdt == bdtEXE_DLL_SCRIPT)
			continue; // skip over DLL and EXE binary data, not UI related

		// output to resource file
		// escape chars in str
		TCHAR* szEscTitle = EscapeSlashAndQuoteForRC(szFileBuf);
		if (_tcsclen(szEscTitle) > iMaxResStrLen)
		{
			_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> BITMAP FILE: %s\n"), szName);
			continue; // can't output this
		}
		/*NAMEID<tab>*/
		if (!W32::WriteFile(m_hFile, szName, _tcsclen(szName)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		switch (bdt)
		{
		case bdtBitmap: /*BITMAP*/
			if (!W32::WriteFile(m_hFile, resBitmap, _tcsclen(resBitmap)*sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			break;
		case bdtJPEG:   /*JPEG*/
			if (!W32::WriteFile(m_hFile, resJPEG, _tcsclen(resJPEG)*sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			break;
		case bdtIcon: /*ICON*/
			if (!W32::WriteFile(m_hFile, resIcon, _tcsclen(resIcon)*sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			break;
		default:
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		/*<tab>"filename"*/
		if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szEscTitle, _tcslen(szEscTitle)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (szEscTitle)
			delete szEscTitle;
		if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		if (szName)
			delete [] szName;
	}
	if (ERROR_NO_MORE_ITEMS != iStat)
		return m_fError = TRUE, FALSE; // error - ABORT

	// whitespace in .rc file for readability
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...END WRITING BINARY DATA TO RESOURCE FILE...\n"));
#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputStringInit
UINT CGenerateRC::OutputStringInit()
{
	/**********************************************************************************
	 create internal table for mapping string IDs to strings
	 TABLE: _RESStrings
	 COLUMNS: RCID (Short, Primary Key), Table (String), Column (String), Key (String) 
	***********************************************************************************/
	UINT iStat;
	// see if _RESStrings table is already there
	MSICONDITION eCondition = MSI::MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("_RESStrings"));
	if (eCondition == MSICONDITION_TRUE)
	{
		// table persistent
		// find the last resource Id
		PMSIHANDLE hViewSelMaxRc = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlSelMaxStrRcId, &hViewSelMaxRc)))
			return m_fError = TRUE, iStat; // error - ABORT
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewSelMaxRc, 0)))
			return m_fError = TRUE, iStat; // error - ABORT
		PMSIHANDLE hRecMaxRc = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewFetch(hViewSelMaxRc, &hRecMaxRc)))
			return m_fError = TRUE, iStat; // error - ABORT
		// update resource Id
		m_iStrResID = MSI::MsiRecordGetInteger(hRecMaxRc, 1);
#ifdef DEBUG
	_tprintf(TEXT("LOG>> _RESStrings Table is Present. MAX RES ID = %d\n"), m_iStrResID);
#endif
	}
	else if (eCondition == MSICONDITION_FALSE || eCondition == MSICONDITION_ERROR) // error or table temporary
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	else
	{
		// table not exist -- create it
		PMSIHANDLE h_StrMarkingView = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlCreateStrMap, &h_StrMarkingView)))
			return m_fError = TRUE, iStat; // error - ABORT
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(h_StrMarkingView, 0)))
			return m_fError = TRUE, iStat; // error - ABORT
	}
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputString
UINT CGenerateRC::OutputString(TCHAR* szTable, TCHAR* szColumn)
{
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = Initialize()))
		return m_fError = TRUE, iStat; // error - ABORT
	
	// initialize _RESStrings marking table
	if (ERROR_SUCCESS != (iStat = OutputStringInit()))
		return m_fError = TRUE, iStat; // error - ABORT

	// verify table exists
	MSICONDITION eCond = MSI::MsiDatabaseIsTablePersistent(m_hDatabase, szTable);
	switch (eCond)
	{
	case MSICONDITION_FALSE: // table is temporary
	case MSICONDITION_NONE: // table does not exist
		_tprintf(TEXT("LOG_ERROR>> TABLE: %s is temporary or does not exist.\n"), szTable);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	case MSICONDITION_ERROR: // error occured
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseIsTablePersistent\n"));
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	case MSICONDITION_TRUE: // table is persistent
		break; 
	default:
		assert(0);
	}

	// build query to open view on table
	PMSIHANDLE hRecPrimaryKeys = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseGetPrimaryKeys(m_hDatabase, szTable, &hRecPrimaryKeys)))
		return m_fError = TRUE, iStat; // error - ABORT
	int cPrimaryKeys = MSI::MsiRecordGetFieldCount(hRecPrimaryKeys);
	TCHAR szKeyCols[720] = {0};
	for (int i=1; i<=cPrimaryKeys;i++)
	{
		DWORD dwLen = 0;
		MSI::MsiRecordGetString(hRecPrimaryKeys, i, TEXT(""), &dwLen);
		TCHAR* szColName = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecPrimaryKeys, i, szColName, &dwLen)))
			return m_fError = TRUE, iStat; // error - abort
		if (i != 1)
			lstrcat(szKeyCols, TEXT(","));
		lstrcat(szKeyCols, szColName);
		if (szColName)
			delete [] szColName;
	}
	TCHAR sql[2048];
	_stprintf(sql, sqlStrCol, szKeyCols, szColumn, szTable);
	PMSIHANDLE hViewStrCol = 0;

	// open view
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sql, &hViewStrCol)))
	{
		if (ERROR_BAD_QUERY_SYNTAX == iStat)
			_tprintf(TEXT("LOG_ERROR>> Query failed, probably because the column '%s' does not exist in table '%s'\n"), szColumn, szTable);
		else
			_tprintf(TEXT("LOG_ERROR>> MsiDatabaseOpenView(Column=%s, Table=%s)\n"), szColumn, szTable);
		return m_fError = TRUE, iStat; // error - ABORT
	}
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewStrCol, 0)))
		return m_fError = TRUE, iStat; // error - ABORT

	// verify column is localizable
	PMSIHANDLE hRecColNames = 0;
	PMSIHANDLE hRecColType = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewGetColumnInfo(hViewStrCol, MSICOLINFO_NAMES, &hRecColNames)))
		return m_fError = TRUE, iStat; // error - ABORT
	int cCols = MSI::MsiRecordGetFieldCount(hRecColNames);
	int iStrCol = 0;
	for (int iFindCol = 1; iFindCol <= cCols; iFindCol++)
	{
		DWORD dwLen = 72;
		TCHAR szColumnName[72];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecColNames, iFindCol, szColumnName, &dwLen)))
			return m_fError = TRUE, iStat; // error - ABORT
		if (_tcscmp(szColumnName, szColumn) == 0)
		{
			iStrCol = iFindCol;
			break;
		}
	}
	assert(iStrCol);
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewGetColumnInfo(hViewStrCol, MSICOLINFO_TYPES, &hRecColType)))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiViewGetColumnInfo\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}
	DWORD cchColType = 0;
	MSI::MsiRecordGetString(hRecColType, iStrCol, TEXT(""), &cchColType);
	TCHAR* szColType = new TCHAR[++cchColType];
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecColType, iStrCol, szColType, &cchColType)))
		return m_fError = TRUE, iStat; // error - ABORT

	// for column to be localizable, first char in szColType must be an 'L' or an 'l'
	if (*szColType != 'L' && *szColType != 'l')
	{
		_tprintf(TEXT("LOG_ERROR>> Column '%s' of Table '%s' is not localizable\n"), szColumn, szTable);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}

	if (szColType)
		delete [] szColType;

	// write whitespace for readability
	// whitespace in .rc file for readability
	DWORD dwWritten;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// output STRINGTABLE resource header
	// format is:
	//  STRINGTABLE  [[optional-statements]]  {      stringID string      . . .  }
	/*STRINGTABLE*/
	if (!W32::WriteFile(m_hFile, resStringTable, _tcsclen(resStringTable)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>{*/
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCurlyBeg, sizeof(szCurlyBeg)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	
	// output all strings
	PMSIHANDLE hRecStr = 0;
	while (ERROR_SUCCESS == (iStat = MSI::MsiViewFetch(hViewStrCol, &hRecStr)))
	{
		// string to localize is at cPrimaryKeys+1 in record hRecStr
		// generate key identifier
		TCHAR szKeyIdentifier[720] = {0};
		for (int iKey = 1; iKey<=cPrimaryKeys;iKey++)
		{
			DWORD dwLen = 0;
			MSI::MsiRecordGetString(hRecStr, iKey, TEXT(""), &dwLen);
			TCHAR* szKey = new TCHAR[++dwLen];
			if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecStr, iKey, szKey, &dwLen)))
				return m_fError = TRUE, iStat; // error - ABORT
			if (iKey != 1)
				lstrcat(szKeyIdentifier, TEXT(":"));
			lstrcat(szKeyIdentifier, szKey);
			if (szKey)
				delete [] szKey;
		}

		int iResId = 0;
		// attempt to find resource ID if previously used
		_stprintf(sql, sqlFindStrResId, szTable, szColumn, szKeyIdentifier);
		PMSIHANDLE hViewFindRes = 0;
		PMSIHANDLE hRecFindRes = 0;
		UINT iStat;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sql, &hViewFindRes)))
			return FALSE; // error - ABORT
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewFindRes, 0)))
			return FALSE; // error - ABORT
		if (ERROR_SUCCESS == (iStat = MSI::MsiViewFetch(hViewFindRes, &hRecFindRes)))
		{
			// grab res id
			iResId = MSI::MsiRecordGetInteger(hRecFindRes, 1);
		}
		else if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// use next available resource Id
			iResId = ++m_iStrResID;
		}
		else
			return m_fError = TRUE, iStat; // error - ABORT

		// output string to resource file
		/*<tab>ID*/
		if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		TCHAR szTempBuf[10];
		wsprintf(szTempBuf, TEXT("%d"), iResId);
		if (!W32::WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		DWORD dwLenStr = 0;
		MSI::MsiRecordGetString(hRecStr, cPrimaryKeys+1, TEXT(""), &dwLenStr);
		TCHAR* szStr = new TCHAR[++dwLenStr];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecStr, cPrimaryKeys+1, szStr, &dwLenStr)))
			return m_fError = TRUE, iStat; // error - ABORT
#ifdef DEBUG
		_tprintf(TEXT("LOG>> WRITING string '%s'. TABLE:%s COLUMN:%s KEY:%s\n"), szStr, szTable, szColumn, szKeyIdentifier);
#endif
		// escape chars in str
		TCHAR* szEscTitle = EscapeSlashAndQuoteForRC(szStr);
		if (_tcsclen(szEscTitle) > iMaxResStrLen)
		{
			_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> STRING: %s FROM TABLE: %s, COLUMN: %s, KEY: %s\n"), szStr, szTable, szColumn, szKeyIdentifier);
			continue; // can't output this
		}
		if (szStr)
			delete [] szStr;
		/*,<tab>"str"*/
		if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szEscTitle, _tcslen(szEscTitle)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (szEscTitle)
			delete szEscTitle;
		if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		// update resid in _RESStrings
		PMSIHANDLE hViewRes = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlInsertStr, &hViewRes)))
			return m_fError = TRUE, iStat;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewRes, 0)))
			return m_fError = TRUE, iStat;
		PMSIHANDLE hRecInsertStr = MSI::MsiCreateRecord(4);
		assert(hRecInsertStr);
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetInteger(hRecInsertStr, 4, iResId)))
			return m_fError = TRUE, iStat;
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecInsertStr, 1, szTable)))
			return m_fError = TRUE, iStat;
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecInsertStr, 2, szColumn)))
			return m_fError = TRUE, iStat;
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecInsertStr, 3, szKeyIdentifier)))
			return m_fError = TRUE, iStat;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(hViewRes, MSIMODIFY_ASSIGN, hRecInsertStr)))
			return m_fError = TRUE, iStat;
	}
	if (iStat != ERROR_NO_MORE_ITEMS)
		return m_fError = TRUE, iStat; // error - ABORT

	/*}*/
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCurlyEnd, sizeof(szCurlyEnd)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;


	// update _RESStrings table with MAX_RESOURCE_ID
	PMSIHANDLE hViewStrMark = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlStrMark, &hViewStrMark)))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewStrMark, 0)))
		return m_fError = TRUE, iStat; // error - ABORT
	PMSIHANDLE hRecMaxRcId = MSI::MsiCreateRecord(4);
	assert(hRecMaxRcId);
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecMaxRcId, 1, TEXT("MAX_RESOURCE_ID"))))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecMaxRcId, 2, TEXT("MAX_RESOURCE_ID"))))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecMaxRcId, 3, TEXT(""))))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetInteger(hRecMaxRcId, 4, m_iStrResID)))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(hViewStrMark, MSIMODIFY_ASSIGN, hRecMaxRcId)))
		return m_fError = TRUE, iStat; // error - ABORT

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::Initialize
UINT CGenerateRC::Initialize()
{
	UINT iStat;
	// open database if not already open
	assert(m_szOrigDb);
	if (!m_hDatabase)
	{
		// if m_szDatabase is specified, then we use it for specifying an output database
		iStat = MSI::MsiOpenDatabase(m_szOrigDb, m_szDatabase ? m_szDatabase : MSIDBOPEN_TRANSACT, &m_hDatabase);
		if (ERROR_SUCCESS != iStat)
		{
			_tprintf(TEXT("LOG_ERROR>> Unable to open database %s\n"), m_szOrigDb);
			return m_fError = TRUE, iStat; // error - ABORT
		}
	}

	// verify database codepage is NEUTRAL
	if  (ERROR_SUCCESS != (iStat = VerifyDatabaseCodepage()))
		return m_fError = TRUE, iStat; // error - ABORT

	// create resource file if not already created
	if (!m_hFile && ERROR_SUCCESS != (iStat = CreateResourceFile()))
	{
		_tprintf(TEXT("LOG_ERROR>> Unable to create resource file.\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputDialogFinalize
UINT CGenerateRC::OutputDialogFinalize()
{
	// update _RESControls table with MAX_RESOURCE_ID
	PMSIHANDLE hViewCtrlMark = 0;
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlCtrlMark, &hViewCtrlMark)))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewCtrlMark, 0)))
		return m_fError = TRUE, iStat; // error - ABORT
	PMSIHANDLE hRecMaxRcId = MSI::MsiCreateRecord(3);
	assert(hRecMaxRcId);
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecMaxRcId, 1, TEXT("MAX_RESOURCE_ID"))))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecMaxRcId, 2, TEXT("MAX_RESOURCE_ID"))))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetInteger(hRecMaxRcId, 3, m_iCtrlResID)))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(hViewCtrlMark, MSIMODIFY_ASSIGN, hRecMaxRcId)))
		return m_fError = TRUE, iStat; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...END WRITING DIALOG DATA TO RESOURCE FILE...\n"));
#endif

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::VerifyDatabaseCodepage
UINT CGenerateRC::VerifyDatabaseCodepage()
{
	UINT iStat;
	// only output from language neutral database
	TCHAR szTempPath[MAX_PATH];
	W32::GetTempPath(MAX_PATH, szTempPath);
	// export _ForceCodepage table so can verify codepage
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseExport(m_hDatabase, TEXT("_ForceCodepage"), szTempPath, szCodepageExport)))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseExport(_ForceCodepage)\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}
	// open _ForceCodepage.idt to read it
	TCHAR szFullPath[MAX_PATH + 32];
	wsprintf(szFullPath, TEXT("%s%s"), szTempPath, szCodepageExport);
	HANDLE hFile = W32::CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
	if (hFile == NULL)
	{
		_tprintf(TEXT("LOG_ERROR>> W32::OpenFile(_ForceCodepage.idt)\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}
	// read file for information
	DWORD dwSize = W32::GetFileSize(hFile, NULL);
	if (0xFFFFFFFF == dwSize)
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	char* szBuf = new char[dwSize+1];
	DWORD dwRead;
	if (!W32::ReadFile(hFile, (LPVOID)szBuf, dwSize, &dwRead, NULL))
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	// parse buffer
	// format should be : blank line, blank line, "codepage<tab>_ForceCodepage"
	assert(dwRead != 0);
	char* pch = szBuf;
	int cBlankLines = 0;
	while (dwRead && cBlankLines != 2)
	{
		if (*pch == '\n')
			cBlankLines++;
		pch++;
		dwRead--;
	}
	if (!dwRead || cBlankLines != 2)
	{
		_tprintf(TEXT("LOG_ERROR>> Invalid ForceCodepage idt format\n"));
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}
	// codepage is next
	char* pchCodepage = pch;
	while (dwRead && *pch != ' ' && *pch != '\t')
	{
		pch++;
		dwRead--;
	}
	assert(dwRead);
	*pch = '\0';
	// convert codepage to int
	UINT uiCodepage = strtoul(pchCodepage, NULL, 10);
	if (uiCodepage != 0) // 0 is language neutral
	{
		_tprintf(TEXT("LOG_ERROR>> DATABASE IS NOT LANGUAGE NEUTRAL. CANNOT EXPORT\n"));
		_tprintf(TEXT("LOG_ERROR>> CURRENT CODEPAGE IS %d\n"), uiCodepage);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
	if (!W32::CloseHandle(hFile))
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputDialogInit
UINT CGenerateRC::OutputDialogInit(BOOL fBinary)
{
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = Initialize()))
		return m_fError = TRUE, iStat; // error - ABORT

	// only output if Dialog table exists
	MSICONDITION eCond = MSI::MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("Dialog"));
	if (eCond == MSICONDITION_ERROR)
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseIsTablePersistent(Dialog)\n"));
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
	// require PERSISTENT tables
	if (eCond != MSICONDITION_TRUE)
	{
		_tprintf(TEXT("LOG>> Dialog table is not persistent or does not exist\n"));
		return ERROR_SUCCESS;
	}
		
	/**********************************************************************************
	 create internal table for mapping DIALOGS to Dialogs (resource file stores
	 strings IDs in ALL CAPS.  Installer is case-sensitive
	 TABLE: _RESDialogs
	 COLUMNS: RCStr (String, Primary Key), Dialog (String, Primary Key) 
	***********************************************************************************/
	
	// see if _RESDialogs table is already there
	MSICONDITION eCondition = MSI::MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("_RESDialogs"));
	if (eCondition == MSICONDITION_TRUE)
	{
		// table persistent
#ifdef DEBUG
		_tprintf(TEXT("LOG>> _RESDialogs Table is Present.\n"));
#endif
	}
	else if (eCondition == MSICONDITION_FALSE || eCondition == MSICONDITION_ERROR) // error or table temporary
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	else
	{
		// table not exist -- create it
		PMSIHANDLE h_DlgMarkingView = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlCreateDlgMap, &h_DlgMarkingView)))
			return m_fError = TRUE, iStat; // error - ABORT
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(h_DlgMarkingView, 0)))
			return m_fError = TRUE, iStat; // error - ABORT
	}

	/**********************************************************************************
	 create internal table for managing resource IDs of controls
	 TABLE: _RESControls
	 COLUMNS: Dialog_ (String, Primary Key), Control_ (String, Primary Key), RCID (Int)  
	***********************************************************************************/

	// see if _RESControls table is already there
	eCondition = MSI::MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("_RESControls"));
	if (eCondition == MSICONDITION_TRUE)
	{
		// table persistent
		// find the last resource Id
		PMSIHANDLE hViewSelMaxRc = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlSelMaxRcId, &hViewSelMaxRc)))
			return m_fError = TRUE, iStat; // error - ABORT
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewSelMaxRc, 0)))
			return m_fError = TRUE, iStat; // error - ABORT
		PMSIHANDLE hRecMaxRc = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewFetch(hViewSelMaxRc, &hRecMaxRc)))
			return m_fError = TRUE, iStat; // error - ABORT
		// update resource Id
		m_iCtrlResID = MSI::MsiRecordGetInteger(hRecMaxRc, 1);
#ifdef DEBUG
	_tprintf(TEXT("LOG>> _RESControls Table is Present. MAX RES ID = %d\n"), m_iCtrlResID);
#endif

	}
	else if (eCondition == MSICONDITION_ERROR || eCondition == MSICONDITION_FALSE) // error or temporary
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	else
	{
		// table not exist -- create it
		PMSIHANDLE h_CtrlMarkingView = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlCreateCtrlMark, &h_CtrlMarkingView)))
			return m_fError = TRUE, iStat; // error - ABORT
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(h_CtrlMarkingView, 0)))
			return m_fError = TRUE, iStat; // error - ABORT
	}
#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN WRITING DIALOG DATA TO RESOURCE FILE...\n"));
#endif

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputDialogs
UINT CGenerateRC::OutputDialogs(BOOL fBinary)
{
	// write out each dialog in Dialog table
	// According to MSDN, new applications should use DIALOGEX resource instead of DIALOG

	UINT iStat;
	if (ERROR_SUCCESS != (iStat = OutputDialogInit(fBinary)))
		return m_fError = TRUE, iStat; // error - ABORT

		// write out the bitmaps and icons from the Binary table
#ifdef DEBUG
	if (!fBinary)
		_tprintf(TEXT("LOG>> SKIPPING Binary data export.\n"));
#endif
	if (fBinary && !m_fWroteBinary && !WriteBinaries())
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	// prepare Dialog strResource --> Dialog mapping table
	PMSIHANDLE hViewDlgMap = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlDlgMap, &hViewDlgMap)))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewDlgMap, 0)))
		return m_fError = TRUE, iStat; // error - ABORT
	PMSIHANDLE hRecDlgMap = MSI::MsiCreateRecord(2);
	assert(hRecDlgMap);

	// open view on Dialog table
	PMSIHANDLE hViewDialog = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlDialog, &hViewDialog)))
		return m_fError = TRUE, iStat; // error - ABORT

	// execute view
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewDialog, 0)))
		return m_fError = TRUE, iStat; // error - ABORT

	// fetch all row records of dialogs from Dialog table and output to .rc file
	PMSIHANDLE hRecDialog = 0;
	while (ERROR_NO_MORE_ITEMS != (iStat = MSI::MsiViewFetch(hViewDialog, &hRecDialog)))
	{
		if (ERROR_SUCCESS != iStat)
			return m_fError = TRUE, iStat; // error - ABORT

		// use dialog name as nameID
		// Reasoning: guarantees uniqueness since Dialog name is primary key of table
		// Potential caveat:  Dialog strId is stored in ALL CAPS. Installer is case-sensitive
		//   so we must store a mapping between this and original.  Could have case where we
		//   try Action1 and ACTion1 as two different strIds.  RC will fail on this
		
		// 1st call, obtain size needed
		// 2nd call, get string
		DWORD dwLen = 0;
		MSI::MsiRecordGetString(hRecDialog, idcName, TEXT(""), &dwLen);
		TCHAR* szDialog = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecDialog, idcName, szDialog, &dwLen)))
			return m_fError = TRUE, iStat; // error - ABORT

		// update Dialog Mapping table with information
		MSI::MsiRecordSetString(hRecDlgMap, 2, szDialog);
		TCHAR szTempDialog[72];
		_tcscpy(szTempDialog, szDialog);
		MSI::MsiRecordSetString(hRecDlgMap, 1, _tcsupr(szTempDialog)); // resource file format, ALL CAPS
		
		// update _RESDialogs table, note:  we will overwrite pre-existing. Rely on rc.exe to bail 
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(hViewDlgMap, MSIMODIFY_ASSIGN, hRecDlgMap)))
			return m_fError = TRUE, iStat; // error - ABORT

		// get x, y, wd, ht, and attrib values
		int x,y,wd,ht,attrib;
		x      = MSI::MsiRecordGetInteger(hRecDialog, idcX);
		y      = MSI::MsiRecordGetInteger(hRecDialog, idcY);
		wd     = MSI::MsiRecordGetInteger(hRecDialog, idcWd);
		ht     = MSI::MsiRecordGetInteger(hRecDialog, idcHt);
		attrib = MSI::MsiRecordGetInteger(hRecDialog, idcAttrib);


		// obtain title of dialog
		MSI::MsiRecordGetString(hRecDialog, idcTitle, TEXT(""), &dwLen);
		TCHAR* szTitle = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecDialog, idcTitle, szTitle, &dwLen)))
			return m_fError = TRUE, iStat; // error - ABORT

		if (!WriteDialogToRC(szDialog, szTitle, x, y, wd, ht, attrib))
			return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	}

	if (ERROR_SUCCESS != (iStat = OutputDialogFinalize()))
		return m_fError = TRUE, iStat; // error - ABORT


	// return success
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputDialog
UINT CGenerateRC::OutputDialog(TCHAR* szDialog, BOOL fBinary)
{
	// write out specified dialog in Dialog table
	// According to MSDN, new applications should use DIALOGEX resource instead of DIALOG

	UINT iStat;
	if (ERROR_SUCCESS != (iStat = OutputDialogInit(fBinary)))
		return m_fError = TRUE, iStat; // error - ABORT

	// prepare Dialog strResource --> Dialog mapping table
	PMSIHANDLE hViewDlgMap = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlDlgMap, &hViewDlgMap)))
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewDlgMap, 0)))
		return m_fError = TRUE, iStat; // error - ABORT
	PMSIHANDLE hRecDlgMap = MSI::MsiCreateRecord(2);
	assert(hRecDlgMap);

	// open view on Dialog table
	PMSIHANDLE hViewDialog = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlDialogSpecific, &hViewDialog)))
		return m_fError = TRUE, iStat; // error - ABORT

	// execute view
	PMSIHANDLE hRecFindDlg = MSI::MsiCreateRecord(1);
	assert(hRecFindDlg);
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecFindDlg, 1, szDialog)))
		return m_fError = TRUE, iStat; // error - ABORT

	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewDialog, hRecFindDlg)))
		return m_fError = TRUE, iStat; // error - ABORT

	// fetch specified Dialog from Dialog table and output to .rc file
	PMSIHANDLE hRecDialog = 0;
	if (ERROR_SUCCESS == (iStat = MSI::MsiViewFetch(hViewDialog, &hRecDialog)))
	{
		// write out the bitmaps and icons from the Binary table
#ifdef DEBUG
		if (!fBinary)
			_tprintf(TEXT("LOG>> SKIPPING Binary data export.\n"));
#endif
		if (fBinary && !m_fWroteBinary && !WriteBinaries())
			return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
		// use dialog name as nameID
		// Reasoning: guarantees uniqueness since Dialog name is primary key of table
		// Potential caveat:  Dialog strId is stored in ALL CAPS. Installer is case-sensitive
		//   so we must store a mapping between this and original.  Could have case where we
		//   try Action1 and ACTion1 as two different strIds.  RC will fail on this
		
		// 1st call, obtain size needed
		// 2nd call, get string
		DWORD dwLen = 0;
		MSI::MsiRecordGetString(hRecDialog, idcName, TEXT(""), &dwLen);
		TCHAR* szDialog = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecDialog, idcName, szDialog, &dwLen)))
			return m_fError = TRUE, iStat; // error - ABORT

		// update Dialog Mapping table with information
		MSI::MsiRecordSetString(hRecDlgMap, 2, szDialog);
		TCHAR szTempDialog[72];
		_tcscpy(szTempDialog, szDialog);
		MSI::MsiRecordSetString(hRecDlgMap, 1, _tcsupr(szTempDialog)); // resource file format, ALL CAPS
		
		// update _RESDialogs table, note:  we will overwrite pre-existing. Rely on rc.exe to bail 
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(hViewDlgMap, MSIMODIFY_ASSIGN, hRecDlgMap)))
			return m_fError = TRUE, iStat; // error - ABORT

		// get x, y, wd, ht, and attrib values
		int x,y,wd,ht,attrib;
		x      = MSI::MsiRecordGetInteger(hRecDialog, idcX);
		y      = MSI::MsiRecordGetInteger(hRecDialog, idcY);
		wd     = MSI::MsiRecordGetInteger(hRecDialog, idcWd);
		ht     = MSI::MsiRecordGetInteger(hRecDialog, idcHt);
		attrib = MSI::MsiRecordGetInteger(hRecDialog, idcAttrib);


		// obtain title of dialog
		MSI::MsiRecordGetString(hRecDialog, idcTitle, TEXT(""), &dwLen);
		TCHAR* szTitle = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecDialog, idcTitle, szTitle, &dwLen)))
			return m_fError = TRUE, iStat; // error - ABORT

		if (!WriteDialogToRC(szDialog, szTitle, x, y, wd, ht, attrib))
			return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	}
	else if (ERROR_NO_MORE_ITEMS == iStat)
	{
		_tprintf(TEXT("LOG_ERROR>> Dialog '%s' not found in Dialog table\n"), szDialog);
		if (ERROR_SUCCESS != (iStat = OutputDialogFinalize()))
			return m_fError = TRUE, iStat;
		return ERROR_SUCCESS; // error, but not fatal...keep processing
	}
	else
	{
		_tprintf(TEXT("LOG_ERROR>> MsiViewFetch(specific dialog)\n"));
		return iStat;
	}

	if (ERROR_SUCCESS != (iStat = OutputDialogFinalize()))
		return m_fError = TRUE, iStat; // error - ABORT

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::EscapeSlashAndQuteForRc
TCHAR* CGenerateRC::EscapeSlashAndQuoteForRC(TCHAR* szStr)
{
	TCHAR* szNewStr = 0;
	
	// check for NULL str
	if (szStr == 0)
		return szNewStr;

	// determine if str contains any esc char
	int cEscChar = 0;
	TCHAR* pch = szStr;
	while (*pch != 0)
	{
		if (*pch == TEXT('\\') || *pch == TEXT('"'))
			cEscChar++;
		pch++;
	}

	if (cEscChar == 0)
	{
		int iLen = _tcsclen(szStr) + 1; // for null
		szNewStr = new TCHAR[iLen];
		_tcscpy(szNewStr, szStr);
	}
	else
	{
		int iLen = _tcsclen(szStr) + 1 + cEscChar;
		szNewStr = new TCHAR[iLen];
		pch = szStr;
		TCHAR* pchNew = szNewStr;
		while (*pch != 0)
		{
			if (*pch == TEXT('\\'))
				*pchNew++ = TEXT('\\');
			else if (*pch == TEXT('"'))
				*pchNew++ = TEXT('"');
			*pchNew++ = *pch++;
		}
		*pchNew = TEXT('\0');
	}
	
	return szNewStr;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteDialogToRC
BOOL CGenerateRC::WriteDialogToRC(TCHAR* szDialog, TCHAR* szTitle, int x, int y, int wd, int ht, int attrib)
{
#ifdef DEBUG
	_tprintf(TEXT("LOG>> Writing <%s> Dialog\n"), szDialog);
#endif
	// Format for DIALOGEX is:
	// nameID DIALOGEX x, y, width, height [ , helpID]]  [[ optional-statements]]  {control-statements}

	// write out to file

	DWORD dwWritten;
	/*nameId*/
	if (!W32::WriteFile(m_hFile, szDialog, _tcsclen(szDialog)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>DIALOGEX*/
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, resDialog, sizeof(resDialog)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*x, y, wd, ht DIMENSIONS*/
	if (!PrintDimensions(x, y, wd, ht))
		return m_fError = TRUE, FALSE; // error - ABORT
	//TODO??: HelpId
	/*<tab>CAPTION<tab>"str"*/
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, tokCaption, sizeof(tokCaption)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	// escape chars in str
	TCHAR* szEscTitle = EscapeSlashAndQuoteForRC(szTitle);
	if (_tcsclen(szEscTitle) > iMaxResStrLen)
	{
		_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> DIALOG: %s\n"), szDialog);
		_tcscpy(szEscTitle, strOverLimit);
	}
	if (!W32::WriteFile(m_hFile, szEscTitle, _tcslen(szEscTitle)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (szEscTitle)
		delete szEscTitle;
	if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	//attributes are ignored at this time (would require conversion from Installer to Windows and masking of Installer specific)
	/*<tab>{*/
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCurlyBeg, sizeof(szCurlyBeg)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	// Select all controls associated with said dialog and output
	if (!OutputControls(szDialog))
		return m_fError = TRUE, FALSE; // error - ABORT
	if (!W32::WriteFile(m_hFile, szCurlyEnd, sizeof(szCurlyEnd)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// whitespace in .rc file for readability
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;


	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::PrintDimensions
BOOL CGenerateRC::PrintDimensions(int x, int y, int wd, int ht)
{
	// TODO: may require special coordinate computation (system units versus Installer dialog units)
	TCHAR szTempBuf[64];
	DWORD dwWritten;

	/*<tab>x*/
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	wsprintf(szTempBuf, TEXT("%d"), x);
	if (!W32::WriteFile(m_hFile, szTempBuf, _tcsclen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*,<tab>y*/
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	wsprintf(szTempBuf, TEXT("%d"), y);
	if (!W32::WriteFile(m_hFile, szTempBuf, _tcsclen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*,<tab>wd*/
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	wsprintf(szTempBuf, TEXT("%d"), wd);
	if (!W32::WriteFile(m_hFile, szTempBuf, _tcsclen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*,<tab>ht*/
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	wsprintf(szTempBuf, TEXT("%d"), ht);
	if (!W32::WriteFile(m_hFile, szTempBuf, _tcsclen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::OutputControls
BOOL CGenerateRC::OutputControls(TCHAR* szDialog)
{
	//PUNTED: output in tab order
	//REASON: extremely difficult to get right, very difficult if changes are made when importing

	// TODO: Handle output in correct tab order.  Fairly easy for export if you remember to output
	// all non tab order controls first.  The Control_Next column of the Control table would be
	// used as well as the Control_First column of the Dialog table.  Control_First is the start
	// of the tab order.  Control_Next is the next control in the tab order.  It is difficult to
	// handle the tab order when importing if you allow the tab order to change between export
	// and import.
	UINT iStat;

	// only have controls to write if Control table exists
	MSICONDITION eCond = MSI::MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("Control"));
	if (eCond == MSICONDITION_ERROR)
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseIsTablePersistent(Control)\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	// require Control table to be persistent
	if (eCond != MSICONDITION_TRUE)
	{
		_tprintf(TEXT("LOG: Control table is not persistent or present\n"));
		return TRUE;
	}

	// open view on Control table
	PMSIHANDLE hViewControl = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlControl, &hViewControl)))
		return m_fError = TRUE, FALSE; // error - ABORT

	// create Dialog execution record
	PMSIHANDLE hRec = MSI::MsiCreateRecord(1);
	assert(hRec);
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRec, 1, szDialog)))
		return m_fError = TRUE, FALSE; // error - ABORT

	// execute sql query
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewControl, hRec)))
		return m_fError = TRUE, FALSE; // error - ABORT

	// begin fetching rows from Control table
	PMSIHANDLE hRecControl = 0;
	while (ERROR_NO_MORE_ITEMS != (iStat = MSI::MsiViewFetch(hViewControl, &hRecControl)))
	{
		if (ERROR_SUCCESS != iStat)
			return m_fError = TRUE, FALSE; // error - ABORT


		/**********************************************
		 obtain all values for control
		***********************************************/
		// control's type determines how control is output to resource file
		// 1st call, obtain size needed
		// 2nd call, get string
		DWORD dwLen = 0;
		MSI::MsiRecordGetString(hRecControl, iccType, TEXT(""), &dwLen);
		TCHAR* szCtrlType = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecControl, iccType, szCtrlType, &dwLen)))
			return m_fError = TRUE, FALSE; // error - ABORT
		dwLen = 0;
		MSI::MsiRecordGetString(hRecControl, iccName, TEXT(""), &dwLen);
		TCHAR* szCtrlName = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecControl, iccName, szCtrlName, &dwLen)))
			return m_fError = TRUE, FALSE; // error - ABORT
		dwLen = 0;
		MSI::MsiRecordGetString(hRecControl, iccText, TEXT(""), &dwLen);
		TCHAR* szCtrlText = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecControl, iccText, szCtrlText, &dwLen)))
			return m_fError = TRUE, FALSE; // error - ABORT
		dwLen = 0;
		MSI::MsiRecordGetString(hRecControl, iccProperty, TEXT(""), &dwLen);
		TCHAR* szCtrlProperty = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecControl, iccProperty, szCtrlProperty, &dwLen)))
			return m_fError = TRUE, FALSE; // error - ABORT

		// get x, y, wd, ht, and attrib values
		int x,y,wd,ht,attrib;
		x      = MSI::MsiRecordGetInteger(hRecControl, iccX);
		y      = MSI::MsiRecordGetInteger(hRecControl, iccY);
		wd     = MSI::MsiRecordGetInteger(hRecControl, iccWd);
		ht     = MSI::MsiRecordGetInteger(hRecControl, iccHt);
		attrib = MSI::MsiRecordGetInteger(hRecControl, iccAttrib);

#ifdef DEBUG
	_tprintf(TEXT("LOG>>\tWriting control <%s>\n"), szCtrlName);
#endif

		if (!WriteControlToRC(szDialog, szCtrlName, szCtrlType, szCtrlText, szCtrlProperty, x, y, wd, ht, attrib))
			return m_fError = TRUE, FALSE;
	}
	
	// return success
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// NOTES:
// 1.)Output control to RC file according to control type
// 2.)For simplicity, controls are classified into two types:
//                StdWinCtrl and Win32Ctrl.  
//		StdWinCtrl = PushButtons, RadioButtons, ComboBoxes, and ListBoxes
//		Win32Ctrl  = ListView, ComboBox, etc.
//
// 3.)Some controls used in the installer are simply StdWinCtrls with special
//      attributes set
// 
// 4.)Bitmaps and Icons should be output to prevent improper resizing of dialogs.
//      If a dialog were shrunk, the display area could be reduced to the point where
//      the bitmap or icon would not be shown correctly
///////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteControlToRC
BOOL CGenerateRC::WriteControlToRC(TCHAR* szDialog, TCHAR* szCtrlName, TCHAR* szCtrlType, TCHAR* szCtrlText, TCHAR* szCtrlProperty, int x,
								   int y, int wd, int ht, int attrib)
{
	assert(szCtrlType != NULL);

	int iResId = 0;
	// attempt to find resource ID if previously used
	TCHAR sqlTempBuf[512];
	wsprintf(sqlTempBuf, sqlFindResId, szDialog, szCtrlName);
	PMSIHANDLE hViewFindRes = 0;
	PMSIHANDLE hRecFindRes = 0;
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlTempBuf, &hViewFindRes)))
		return FALSE; // error - ABORT
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewFindRes, 0)))
		return FALSE; // error - ABORT
	if (ERROR_SUCCESS == (iStat = MSI::MsiViewFetch(hViewFindRes, &hRecFindRes)))
	{
		// grab res id
		iResId = MSI::MsiRecordGetInteger(hRecFindRes, 1);
	}
	else if (ERROR_NO_MORE_ITEMS == iStat)
	{
		// use next available resource Id
		iResId = ++m_iCtrlResID;
	}
	else
		return FALSE; // error - ABORT


	if (0 == _tcscmp(szCtrlType, szMsiPushbutton))
	{
		// StdWin
		if (!WriteStdWinCtrl(iResId, resPushButton, szCtrlText, x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiText))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resStaticClass, szCtrlText, TEXT("SS_LEFT"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiBillboard))
	{
		// StdWin
		// output GROUPBOX for placeholder for billboard
		//PUNTED: output Billboard separate using Billboard and BBControl tables
		//REASON: would have to somehow connect changes in Billboard size back and forth with Dialog displayed on
		if (!WriteStdWinCtrl(iResId, resGroupBox, szCtrlText, x, y, wd, ht, attrib))
			return FALSE;
	}
	else if (0 == _tcscmp(szCtrlType, szMsiVolumeCostList))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resListViewClass, szCtrlText, TEXT("WS_GROUP"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiCheckBox))
	{
		// StdWin
		if (!WriteStdWinCtrl(iResId, resCheckBox, szCtrlText, x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiGroupBox))
	{
		// StdWin
		if (!WriteStdWinCtrl(iResId, resGroupBox, szCtrlText, x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiRadioButtonGroup))
	{
		// StdWin
		if (!WriteStdWinCtrl(iResId, resGroupBox, szCtrlText, x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
		// write out radiobuttons
		if (!WriteRadioButtons(szDialog, szCtrlName, szCtrlProperty, x, y, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiListBox))
	{
		// Win32
		//TODO: handling of extra attributes like LBS_STANDARD or LBS_NOTIFY
		if (!WriteWin32Ctrl(iResId, resListBoxClass, szCtrlText, TEXT("LBS_STANDARD"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if ((0 == _tcscmp(szCtrlType, szMsiEdit))
	|| (0 == _tcscmp(szCtrlType, szMsiPathEdit))
	|| (0 == _tcscmp(szCtrlType, szMsiMaskedEdit)))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resEditClass, szCtrlText, TEXT("0x000"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiProgressBar))
	{
		// Win32
		//TODO: handling of extra attributes like BS_OWNERDRAW
		if (!WriteWin32Ctrl(iResId, resProgBar32Class, szCtrlText, TEXT("0x000"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiDirList))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resListViewClass, szCtrlText, TEXT("WS_BORDER"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiList))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resListViewClass, szCtrlText, TEXT("WS_BORDER"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiComboBox))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resComboBoxClass, szCtrlText, TEXT("CBS_AUTOHSCROLL"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiDirCombo))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resComboBoxClass, szCtrlText, TEXT("WS_VSCROLL"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiVolSelCombo))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resComboBoxClass, szCtrlText, TEXT("WS_VSCROLL"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiBitmap))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resStaticClass, szCtrlText, TEXT("SS_BITMAP | SS_CENTERIMAGE"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiIcon))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resStaticClass, szCtrlText, TEXT("SS_ICON | SS_CENTERIMAGE"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiSelTree))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resSelTreeClass, szCtrlText, TEXT("WS_BORDER"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiLine))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resStaticClass, szCtrlText, TEXT("SS_ETCHEDHORZ | SS_SUNKEN"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
	}
	else if (0 == _tcscmp(szCtrlType, szMsiScrollableText))
	{
		// Win32
		if (!WriteWin32Ctrl(iResId, resRichEditClass, szCtrlText, TEXT("WS_GROUP"), x, y, wd, ht, attrib))
			return FALSE; // error - ABORT
		return TRUE;
	}
	else
	{
		// unsupported control type
		_tprintf(TEXT("!! >> Control Type: '%s' is unsupported\n"), szCtrlType);
		return FALSE;
	}

	// update _RESControls table with new info
	PMSIHANDLE hViewRes = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlInsertCtrl, &hViewRes)))
	{
		_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
		return FALSE;
	}
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewRes, 0)))
	{
		_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
		return FALSE;
	}
	PMSIHANDLE hRecInsertCtrl = MSI::MsiCreateRecord(3);
	assert(hRecInsertCtrl);
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecInsertCtrl, 1, szDialog)))
	{
		_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
		return FALSE;
	}
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecInsertCtrl, 2, szCtrlName)))
	{
		_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
		return FALSE;
	}
	if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetInteger(hRecInsertCtrl, 3, iResId)))
	{
		_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
		return FALSE;
	}
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(hViewRes, MSIMODIFY_ASSIGN, hRecInsertCtrl)))
	{
		_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
		return FALSE;
	}

	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteRadioButtons
BOOL CGenerateRC::WriteRadioButtons(TCHAR* szDialog, TCHAR* szRBGroup, TCHAR* szProperty, int x, int y, int attrib)
{
	// Format for RadioButton is
	//  RADIOBUTTON<tab>"str",<tab>RESID,<tab>x,<tab>y,<tab>wd,<tab>ht[[,<tab> STYLE ]]
	// radiobuttons come from the RadioButton table based on the Property of the RBGroup in the Control table
	// radiobutton dimensions (X and Y) are local to the radiobutton group
	// because you can have multiple radiobutton groups with the same property in a dialog, we have to use the following
	// scheme when updating the _RESControls table:
	// Dialog<tab>RadioButtonGroup:Property:Order<tab>RESID

	// make sure radiobutton table exists
	MSICONDITION eCond = MSI::MsiDatabaseIsTablePersistent(m_hDatabase, TEXT("RadioButton"));
	switch (eCond)
	{
	case MSICONDITION_ERROR:
	case MSICONDITION_NONE:
	case MSICONDITION_FALSE:
		_tprintf(TEXT("LOG_ERROR>> RadioButton table does not exist, is not persistent, or an error occured.\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	case MSICONDITION_TRUE:
		break;
	default:
		assert(0);
	}
	int iResId = 0;

	// open view on RadioButton table
	PMSIHANDLE hViewRB = 0;
	if (ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, sqlRadioButton, &hViewRB))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseOpenView(RadioButton)\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	PMSIHANDLE hRecExec = MSI::MsiCreateRecord(1);
	assert(hRecExec);
	if (ERROR_SUCCESS != MSI::MsiRecordSetString(hRecExec, 1, szProperty))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiRecordSetString(property)\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	// execute view
	if (ERROR_SUCCESS != MSI::MsiViewExecute(hViewRB, hRecExec))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiViewExecute\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}
	// fetch record
	PMSIHANDLE hRecRB = 0;
	UINT iStat;
	while (ERROR_SUCCESS == (iStat = MSI::MsiViewFetch(hViewRB, &hRecRB)))
	{
		DWORD dwLen = 0;
		MSI::MsiRecordGetString(hRecRB, irbcText, TEXT(""), &dwLen);
		TCHAR* szRBText = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecRB, irbcText, szRBText, &dwLen)))
		{
			_tprintf(TEXT("LOG_ERROR>> MsiRecordGetString(radio button text).  %d\n"), iStat);
			return m_fError = TRUE, FALSE; // error - ABORT
		}
		int iRBX = MSI::MsiRecordGetInteger(hRecRB, irbcX);
		int iRBY = MSI::MsiRecordGetInteger(hRecRB, irbcY);
		int iRBWd = MSI::MsiRecordGetInteger(hRecRB, irbcWd);
		int iRBHt = MSI::MsiRecordGetInteger(hRecRB, irbcHt);

		// grab order value
		int iOrder = MSI::MsiRecordGetInteger(hRecRB, irbcOrder);
		// attempt to find resource ID if previously used
		TCHAR szGeneratedName[255];
		wsprintf(szGeneratedName, TEXT("%s:%s:%d"), szRBGroup, szProperty, iOrder); 
		TCHAR sqlTempBuf[512];
		wsprintf(sqlTempBuf, sqlFindResId, szDialog, szGeneratedName);
		PMSIHANDLE hViewFindRes = 0;
		PMSIHANDLE hRecFindRes = 0;
		UINT iStat;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlTempBuf, &hViewFindRes)))
			return FALSE; // error - ABORT
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewFindRes, 0)))
			return FALSE; // error - ABORT
		if (ERROR_SUCCESS == (iStat = MSI::MsiViewFetch(hViewFindRes, &hRecFindRes)))
		{
			// grab res id
			iResId = MSI::MsiRecordGetInteger(hRecFindRes, 1);
		}
		else if (ERROR_NO_MORE_ITEMS == iStat)
		{
			// use next available resource Id
			iResId = ++m_iCtrlResID;
		}
		else
			return FALSE; // error - ABORT

		TCHAR szTempBuf[64];
		DWORD dwWritten;
		/*KEYWORD*/
		if (!W32::WriteFile(m_hFile, resRadioButton, _tcsclen(resRadioButton)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		/*<tab>"str",*/
		if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		// escape chars in str
		TCHAR* szEscText = EscapeSlashAndQuoteForRC(szRBText);
		if (_tcsclen(szEscText) > iMaxResStrLen)
		{
			_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> CONTROL ID: %d\n"), iResId);
			_tcscpy(szEscText, strOverLimit);
		}
		if (!W32::WriteFile(m_hFile, szEscText, _tcslen(szEscText)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (szEscText)
			delete szEscText;
		if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		/*<tab>RESId,*/
		if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		wsprintf(szTempBuf, TEXT("%d"), iResId);
		if (!W32::WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;
		/*x, y, wd, ht DIMENSIONS*/
		// for RB, X & Y dimensions are local to group, so must add in group's x and y
		if (!PrintDimensions(x+iRBX, y+iRBY, iRBWd, iRBHt))
			return FALSE; // error - ABORT
		//attributes are ignored at this time (would require conversion from Installer to Windows and masking of Installer specific)
		if (attrib & msidbControlAttributesBitmap)
		{
			// control with bitmap picture -- want to prevent localization of picture property names
			/*,<tab>BS_BITMAP*/
			if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			wsprintf(szTempBuf, TEXT("BS_BITMAP"));
			if (!W32::WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten,0))
				m_cWriteFileErr++;
		}
		else if (attrib & msidbControlAttributesIcon)
		{
			// control with icon picture
			/*<tab>BS_ICON*/
			if(!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			wsprintf(szTempBuf, TEXT("BS_BITMAP"));
			if (!W32::WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten,0))
				m_cWriteFileErr++;
		}
		if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
			m_cWriteFileErr++;

		// update _RESControls table with new info
		PMSIHANDLE hViewRes = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlInsertCtrl, &hViewRes)))
		{
			_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
			return FALSE;
		}
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewRes, 0)))
		{
			_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
			return FALSE;
		}
		PMSIHANDLE hRecInsertCtrl = MSI::MsiCreateRecord(3);
		assert(hRecInsertCtrl);
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecInsertCtrl, 1, szDialog)))
		{
			_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
			return FALSE;
		}
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecInsertCtrl, 2, szGeneratedName)))
		{
			_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
			return FALSE;
		}
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetInteger(hRecInsertCtrl, 3, iResId)))
		{
			_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
			return FALSE;
		}
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(hViewRes, MSIMODIFY_ASSIGN, hRecInsertCtrl)))
		{
			_tprintf(TEXT("!! >> Unable to update _RESControls table\n"));
			return FALSE;
		}
	}
	if (ERROR_NO_MORE_ITEMS != iStat)// doesn't catch where property never in RadioButton table
	{
		_tprintf(TEXT("LOG_ERROR>> MsiViewFetch(RadioButton table)\n"));
		return m_fError = TRUE, FALSE; // error - ABORT
	}

	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteStdWinCtrl
BOOL CGenerateRC::WriteStdWinCtrl(int iResId, const TCHAR* resType, TCHAR* szCtrlText, int x, int y, int wd, int ht, int attrib)
{
	// Format for StdWinCtrl is
	//   KEYWORD<tab>"str",<tab>RESID,<tab>x,<tab>y,<tab>wd,<tab>ht[[,<tab> STYLE ]]
	// Keyword can be one of PUSHBUTTON, CHECKBOX, GROUPBOX

	TCHAR szTempBuf[64];
	DWORD dwWritten;
	/*KEYWORD*/
	if (!W32::WriteFile(m_hFile, resType, _tcsclen(resType)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>"str",*/
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	// escape chars in str
	TCHAR* szEscText = EscapeSlashAndQuoteForRC(szCtrlText);
	if (_tcsclen(szEscText) > iMaxResStrLen)
	{
		_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> CONTROL ID: %d\n"), iResId);
		_tcscpy(szEscText, strOverLimit);
	}
	if (!W32::WriteFile(m_hFile, szEscText, _tcslen(szEscText)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (szEscText)
		delete szEscText;
	if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>RESId,*/
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	wsprintf(szTempBuf, TEXT("%d"), iResId);
	if (!W32::WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*x, y, wd, ht DIMENSIONS*/
	if (!PrintDimensions(x, y, wd, ht))
		return FALSE; // error - ABORT
	//attributes are ignored at this time (would require conversion from Installer to Windows and masking of Installer specific)
	// valid picture controls are CheckBox, PushButton, and RadioButtons
	if (0 != _tcscmp(resType, szMsiGroupBox))
	{
		if (attrib & msidbControlAttributesBitmap)
		{
			// control with bitmap picture -- want to prevent localization of picture property names
			/*,<tab>BS_BITMAP*/
			if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			wsprintf(szTempBuf, TEXT("BS_BITMAP"));
			if (!W32::WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten,0))
				m_cWriteFileErr++;
		}
		else if (attrib & msidbControlAttributesIcon)
		{
			// control with icon picture
			/*<tab>BS_ICON*/
			if(!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
				m_cWriteFileErr++;
			wsprintf(szTempBuf, TEXT("BS_BITMAP"));
			if (!W32::WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten,0))
				m_cWriteFileErr++;
		}
	}
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// return success
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGenerateRC::WriteWin32Ctrl
BOOL CGenerateRC::WriteWin32Ctrl(int iResId, const TCHAR* szClass, TCHAR* szCtrlText, TCHAR* szAttrib, int x, int y, int wd, int ht, int attrib)
{
	// Format for StdWinCtrl is
	//   CONTROL<tab>"str",<tab>RESID,<tab>class,<tab>attrib,<tab>x,<tab>y,<tab>wd,<tab>ht[[,<tab> STYLE ]]

	TCHAR szTempBuf[64];
	DWORD dwWritten;
	/*CONTROL*/
	if (!W32::WriteFile(m_hFile, resControl, _tcsclen(resControl)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>"str",*/
	if (!W32::WriteFile(m_hFile, szTab, sizeof(szTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	// escape chars in str
	TCHAR* szEscText = EscapeSlashAndQuoteForRC(szCtrlText);
	if (_tcsclen(szEscText) > iMaxResStrLen)
	{
		_tprintf(TEXT("!! >> STR TOO LONG FOR RC FILE >> CONTROL ID:%d\n"), iResId);
		_tcscpy(szEscText, strOverLimit);
	}
	if (!W32::WriteFile(m_hFile, szEscText, _tcslen(szEscText)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (szEscText)
		delete szEscText;
	if (!W32::WriteFile(m_hFile, szQuotes, sizeof(szQuotes)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>RESId,*/
	wsprintf(szTempBuf, TEXT("%d"), iResId);
	if (!W32::WriteFile(m_hFile, szTempBuf, _tcslen(szTempBuf)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>class,*/
	if (!W32::WriteFile(m_hFile, szClass, _tcslen(szClass)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*<tab>attrib,*/
	if (!W32::WriteFile(m_hFile, szAttrib, _tcslen(szAttrib)*sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	if (!W32::WriteFile(m_hFile, szCommaTab, sizeof(szCommaTab)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;
	/*x, y, wd, ht DIMENSIONS*/
	if (!PrintDimensions(x, y, wd, ht))
		return FALSE; // error - ABORT
	//attributes are ignored at this time (would require conversion from Installer to Windows and masking of Installer specific)
	if (!W32::WriteFile(m_hFile, szCRLF, sizeof(szCRLF)-sizeof(TCHAR), &dwWritten, 0))
		m_cWriteFileErr++;

	// return success
	return TRUE;
}


//_______________________________________________________________________________________
//
// CIMPORTRES CLASS IMPLEMENTATION
//_______________________________________________________________________________________



/////////////////////////////////////////////////////////////////////////////
// CImportRes::~CImportRes
// --  Handles destruction of necessary objects.
// --  Commits database if no errors
CImportRes::~CImportRes()
{
	UINT iStat;
	if (m_hDatabase)
	{
		// only commit database if no errors
		if (!m_fError)
		{
			if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseCommit(m_hDatabase)))
				_tprintf(TEXT("!! DATABASE COMMIT FAILED. Error = %d\n"), iStat);
		}
		else
			_tprintf(TEXT("NO CHANGES SAVED TO DATABASE DUE TO ERROR\n"));
		MSI::MsiCloseHandle(m_hDatabase);
	}
	if (m_hControl)
		MSI::MsiCloseHandle(m_hControl);
	if (m_hDialog)
		MSI::MsiCloseHandle(m_hDialog);
	if (m_hRadioButton)
		MSI::MsiCloseHandle(m_hRadioButton);
	if (m_hInst)
		W32::FreeLibrary(m_hInst);

}

/////////////////////////////////////////////////////////////////////////////
// Notes:
// 1.)We will only update vcenter, hcenter, width, height and title
//         of Dialog.
//
// 2.)We will only update x, y, width, height, and text of Control.
// 3.)We will only update width, height, and text of RadioButton.
//       RadioButtons can be used multiply in different dialogs and multiple
//       RadioButtonGroups using same properties can be wired on the same dialog
//       Plus, RadioButtons are local to the GroupBox that contains them therefore
//       it would require maintaining state data of the GroupBox's X and Y dimensions

//////////////////////////////////////////////////////////////////////////////
// VerifyDatabaseCodepage
UINT CImportRes::VerifyDatabaseCodepage()
{
	UINT iStat;
	// only output from language neutral database
	TCHAR szTempPath[MAX_PATH];
	W32::GetTempPath(MAX_PATH, szTempPath);
	// export _ForceCodepage table so can verify codepage
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseExport(m_hDatabase, TEXT("_ForceCodepage"), szTempPath, szCodepageExport)))
	{
		_tprintf(TEXT("LOG_ERROR>> MsiDatabaseExport(_ForceCodepage)\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}
	// open _ForceCodepage.idt to read it
	TCHAR szFullPath[MAX_PATH + 32];
	wsprintf(szFullPath, TEXT("%s%s"), szTempPath, szCodepageExport);
	HANDLE hFile = W32::CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
	if (hFile == NULL)
	{
		_tprintf(TEXT("LOG_ERROR>> W32::OpenFile(_ForceCodepage.idt)\n"));
		return m_fError = TRUE, iStat; // error - ABORT
	}
	// read file for information
	DWORD dwSize = W32::GetFileSize(hFile, NULL);
	if (0xFFFFFFFF == dwSize)
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	char* szBuf = new char[dwSize+1];
	DWORD dwRead;
	if (!W32::ReadFile(hFile, (LPVOID)szBuf, dwSize, &dwRead, NULL))
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	// parse buffer
	// format should be : blank line, blank line, "codepage<tab>_ForceCodepage"
	assert(dwRead != 0);
	char* pch = szBuf;
	int cBlankLines = 0;
	while (dwRead && cBlankLines != 2)
	{
		if (*pch == '\n')
			cBlankLines++;
		pch++;
		dwRead--;
	}
	if (!dwRead || cBlankLines != 2)
	{
		_tprintf(TEXT("LOG_ERROR>> Invalid ForceCodepage idt format\n"));
		return m_fError = TRUE, ERROR_FUNCTION_FAILED;
	}
	// codepage is next
	char* pchCodepage = pch;
	while (dwRead && *pch != ' ' && *pch != '\t')
	{
		pch++;
		dwRead--;
	}
	assert(dwRead);
	*pch = '\0';
	// convert codepage to int
	UINT uiCodepage = strtoul(pchCodepage, NULL, 10);
	if (uiCodepage != 0 && uiCodepage != g_uiCodePage) // 0 is language neutral
	{
		_tprintf(TEXT("LOG_ERROR>> DATABASE IS NOT LANGUAGE NEUTRAL OR OF SAME CODEPAGE AS RESOURCE STRINGS. CANNOT IMPORT\n"));
		_tprintf(TEXT("LOG_ERROR>> DATABASE CODEPAGE= %d\n"), uiCodepage);
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
	}
	if (!W32::CloseHandle(hFile))
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::ImportDialog
UINT CImportRes::ImportDialog(TCHAR* szDialog)
{
	UINT iStat = Initialize();
	if (ERROR_SUCCESS != iStat)
		return m_fError = TRUE, iStat; // error - ABORT

	if (ERROR_SUCCESS != (iStat = ImportDlgInit()))
		return m_fError = TRUE, iStat; // error - ABORT

	// convert dialog name to resource identifier (all upper case)
	_tcsupr(szDialog);

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN SEARCH FOR DIALOG <%s>...\n"), szDialog);
#endif

	// load dialog
	if (!LoadDialog(m_hInst, RT_DIALOG, szDialog))
	{
		_tprintf(TEXT("LOG_ERROR>> UNABLE LOAD DIALOG: %s\n"), szDialog);
		return ERROR_FUNCTION_FAILED; // fatal error state set in LoadDialog
	}

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::ImportDlgInit
UINT CImportRes::ImportDlgInit()
{
	// open up view on Dialog table
	UINT iStat;
	if (!m_hDialog)
	{
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlDialogImport, &m_hDialog)))
			return m_fError = TRUE, iStat; // error - ABORT
	}
	// open up view on Control table
	if (!m_hControl)
	{
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlControlImport, &m_hControl)))
		{
			if (ERROR_BAD_QUERY_SYNTAX != iStat)
				return m_fError = TRUE, iStat; // error - ABORT
		}
	}
	// open up view on RadioButton table
	if (!m_hRadioButton)
	{
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlRadioButtonImport, &m_hRadioButton)))
		{
			if (ERROR_BAD_QUERY_SYNTAX != iStat)
				return ERROR_SUCCESS; // they just don't have a radiobutton table
			else
				return m_fError = TRUE, iStat; // error - ABORT
		}
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
// CImportRes::Initialize
UINT CImportRes::Initialize()
{
	// attempt to load the DLL in memory
	if (!m_hInst)
	{
		m_hInst = W32::LoadLibrary(m_szDLLFile);
		if (NULL == m_hInst)
		{
			_tprintf(TEXT("LOG_ERROR>> Unable to load DLL '%s'\n"), m_szDLLFile);
			return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT
		}
	}

	// open up database in TRANSACT mode so we can update
	if (!m_hDatabase)
	{
		assert(m_szOrigDb);
		// open up existing database in transacted mode, or specify a new database for creation
		UINT iStat;
		if (ERROR_SUCCESS != (iStat = MSI::MsiOpenDatabase(m_szOrigDb, m_szDatabase ? m_szDatabase : MSIDBOPEN_TRANSACT, &m_hDatabase)))
		{
			_tprintf(TEXT("LOG_ERROR>> Unable to open database '%s'\n"), m_szOrigDb);
			return m_fError = TRUE, iStat; // error - ABORT
		}
		_tprintf(TEXT("LOG>> Database opened from-->%s, Database saving to-->%s\n"),m_szOrigDb, m_szDatabase ? m_szDatabase : m_szOrigDb);
	}
	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::ImportStrings
UINT CImportRes::ImportStrings()
{
	UINT iStat = Initialize();
	if (ERROR_SUCCESS != iStat)
		return m_fError = TRUE, iStat; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN STRING RESOURCE ENUMERATION...\n"));
#endif

	// enumerate through string resources
	BOOL fOK = W32::EnumResourceNames(m_hInst, RT_STRING, EnumStringCallback, (long)this);
	if (!fOK)
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...END STRING RESOURCE ENUMERATION...\n"));
#endif

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::ImportDialogs
UINT CImportRes::ImportDialogs()
{
	UINT iStat = Initialize();
	if (ERROR_SUCCESS != iStat)
		return m_fError = TRUE, iStat; // error - ABORT
	if (ERROR_SUCCESS != (iStat = ImportDlgInit()))
		return m_fError = TRUE, iStat; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...BEGIN DIALOG RESOURCE ENUMERATION...\n"));
#endif

	// enumerate through dialog resources
	BOOL fOK = W32::EnumResourceNames(m_hInst, RT_DIALOG, EnumDialogCallback, (long)this);
	if (!fOK)
		return m_fError = TRUE, ERROR_FUNCTION_FAILED; // error - ABORT

#ifdef DEBUG
	_tprintf(TEXT("LOG>>...END DIALOG RESOURCE ENUMERATION...\n"));
#endif

	return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::LoadString
BOOL CImportRes::LoadString(HINSTANCE hModule, const TCHAR* szType, TCHAR* szStringName)
{
	PMSIHANDLE hViewStrId = 0;
	PMSIHANDLE hRecStrId = 0;
	UINT iStat;
	if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlStringInstallerName, &hViewStrId)))
	{
		_tprintf(TEXT("LOG_ERROR>> _RESStrings table is missing from database.\n"));
		return m_fError = TRUE, FALSE;
	}

	TCHAR sql[3000];
	DWORD dwSqlSize = sizeof(sql)/sizeof(TCHAR);
	int iFirst = (int(szStringName) - 1) * 16;
	TCHAR rgchBuffer[512];
	DWORD cchBuffer = sizeof(rgchBuffer)/sizeof(TCHAR);
	for (int i = 0; i < 16; i++) 
	{
		int cchWritten = W32::LoadString(hModule, iFirst + i, rgchBuffer, cchBuffer);
		if (cchWritten == 0)
			continue; // null string

		if (_tcscmp(rgchBuffer, strOverLimit) == 0)
			continue; // string greater than limit, leave alone

		// use id of string to find table, column, and row it belongs to
		PMSIHANDLE hRecExec = MSI::MsiCreateRecord(1);
		MSI::MsiRecordSetInteger(hRecExec, 1, iFirst + i);
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewStrId, hRecExec)))
			return m_fError = TRUE, FALSE;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewFetch(hViewStrId, &hRecStrId)))
			return m_fError = TRUE, FALSE;


		// we now have the table and column and row
		// want to SELECT `column` from `table` WHERE row matches
		DWORD dwLen = 0;
		MSI::MsiRecordGetString(hRecStrId, 1, TEXT(""), &dwLen);
		TCHAR* szTable = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecStrId, 1, szTable, &dwLen)))
			return m_fError = TRUE, FALSE;
		dwLen = 0;
		MSI::MsiRecordGetString(hRecStrId, 2, TEXT(""), &dwLen);
		TCHAR* szColumn = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecStrId, 2, szColumn, &dwLen)))
			return m_fError = TRUE, FALSE;
		dwLen = 0;
		MSI::MsiRecordGetString(hRecStrId, 3, TEXT(""), &dwLen);
		TCHAR* szKey = new TCHAR[++dwLen];
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecStrId, 3, szKey, &dwLen)))
			return m_fError = TRUE, FALSE;

		assert(szTable && szColumn && szKey);
		_stprintf(sql, sqlStringImport, szColumn, szTable);

		// need to determine how big to make WHERE clause, i.e. # of primary keys
		PMSIHANDLE hRecPrimaryKeys = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseGetPrimaryKeys(m_hDatabase, szTable, &hRecPrimaryKeys)))
			return m_fError = TRUE, FALSE;
		int cKeys = MSI::MsiRecordGetFieldCount(hRecPrimaryKeys);

		// determine number of keys in "szKey" by counting # of ':'
		TCHAR* pch = szKey;
		int cKeyFromTable = 1;
		while (pch != 0 && *pch != '\0')
		{
			if (*pch++ == ':')
				cKeyFromTable++;
		}

		assert(cKeyFromTable == cKeys);

		// need to get column types
		TCHAR sqlTemp[255] = {0};
		_stprintf(sqlTemp, sqlStrTemp, szTable);
		PMSIHANDLE hViewTemp = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sqlTemp, &hViewTemp)))
			return m_fError = TRUE, FALSE;
		PMSIHANDLE hRecColInfo = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewGetColumnInfo(hViewTemp, MSICOLINFO_TYPES, &hRecColInfo)))
			return m_fError = TRUE, FALSE;

		// for each primary key, add to WHERE clause
		TCHAR szColType[10];
		DWORD cchColType = sizeof(szColType)/sizeof(TCHAR);
		for (int iKey = 1; iKey <= cKeys; iKey++)
		{
			DWORD dwLenKey = 0;
			MSI::MsiRecordGetString(hRecPrimaryKeys, iKey, TEXT(""), &dwLenKey);
			TCHAR* szPrimaryKeyCol = new TCHAR[++dwLenKey];
			if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecPrimaryKeys, iKey, szPrimaryKeyCol, &dwLenKey)))
				return m_fError = TRUE, FALSE;

			if (ERROR_SUCCESS != (iStat = MSI::MsiRecordGetString(hRecColInfo, iKey, szColType, &cchColType)))
				return m_fError = TRUE, FALSE;
			assert(szColType && szPrimaryKeyCol);

			cchColType = sizeof(szColType)/sizeof(TCHAR); // reset

			TCHAR* szKeyValue;
			if (iKey == 1)
				szKeyValue = _tcstok(szKey, szTokenSeps);
			else
				szKeyValue = _tcstok(NULL, szTokenSeps);
			assert(szKeyValue);
			// make sure buffer can hold what we are adding
			// we add <space>AND<space>Col=Val
			int iAdd = _tcsclen(TEXT(" AND ")) + _tcsclen(sql) + _tcsclen(TEXT("='")) +_tcsclen(TEXT("'")) + _tcsclen(szKeyValue);
			assert(dwSqlSize > iAdd);
			if (iKey != 1)
				lstrcat(sql, TEXT(" AND "));
			lstrcat(sql, szPrimaryKeyCol);
			if ((*szColType | 0x20) == 'i') // integer
			{
				lstrcat(sql, TEXT("="));
				lstrcat(sql, szKeyValue);
			}
			else if ((*szColType | 0x20) == 's' || (*szColType | 0x20) == 'l')
			{
				// string constants must be enclosed in 'str'
				lstrcat(sql, TEXT("='"));
				lstrcat(sql, szKeyValue);
				lstrcat(sql, TEXT("'"));
			}
			else
				assert(0); // unexpected column type
			if (szPrimaryKeyCol)
				delete [] szPrimaryKeyCol;
		}

		// now grab row from table
		PMSIHANDLE hViewRow = 0;
		PMSIHANDLE hRecRow = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiDatabaseOpenView(m_hDatabase, sql, &hViewRow)))
			return m_fError = TRUE, FALSE;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewExecute(hViewRow, 0)))
			return m_fError = TRUE, FALSE;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewFetch(hViewRow, &hRecRow)))
		{
			_tprintf(TEXT("LOG_ERROR>> ROW: %s is Missing From Table: %s\n"), szKey, szTable);
			return m_fError = TRUE, FALSE;
		}

		// update string with localized string
		if (ERROR_SUCCESS != (iStat = MSI::MsiRecordSetString(hRecRow, 1, rgchBuffer)))
			return m_fError = TRUE, FALSE;

		// update row
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(hViewRow, MSIMODIFY_UPDATE, hRecRow)))
			return m_fError = TRUE, FALSE;

		// clean-up
		if (szTable)
			delete [] szTable;
		if (szColumn)
			delete [] szColumn;
		if (szKey)
			delete [] szKey;
	}//For block of 16 string table strings

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CImportRes::LoadDialog
BOOL CImportRes::LoadDialog(HINSTANCE hModule, const TCHAR* szType, TCHAR* szDialog)
{
	// Find dialog resource into memory
	HRSRC hrsrc = W32::FindResource(hModule, szDialog, szType);
	if (hrsrc == NULL)
	{
		_tprintf(TEXT("LOG_ERROR>> DIALOG RESOURCE: %s NOT FOUND!\n"));
		// not set error state here we could be attempting to load individual dlg resources and we want to continue
		return FALSE;
	}

	// Load resource
	HGLOBAL hResource = W32::LoadResource(hModule, hrsrc);
	if (hResource == NULL)
		return m_fError = TRUE, FALSE; // error - ABORT

	// Create stream object to read from resource in memory
	CDialogStream DialogRes(W32::LockResource(hResource));

	////////////////////////////////////////////////////////////////
	//                  Dialog Information                        //
	//                                                            //
	// stored as DLGTEMPLATEEX (should not have DLGTEMPLATE)      //
			/*	typedef struct {  
				WORD      dlgVer; 
				WORD      signature; 
				DWORD     helpID; 
				DWORD     exStyle; 
				DWORD     style; 
				WORD      cDlgItems; 
				short     x; 
				short     y; 
				short     cx; 
				short     cy; 
				sz_Or_Ord menu; 
				sz_Or_Ord windowClass; 
				WCHAR     title[titleLen]; 
			// The following members exist only if the style member is 
			// set to DS_SETFONT or DS_SHELLFONT.
				short     pointsize; 
				short     weight; 
				short     italic; 
				WCHAR     typeface[stringLen];  
			} DLGTEMPLATEEX; */
	////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////
	// DLGTEMPLATE structure does not have dlgVer, signature, helpID,
	//             weight, or italic members
	//

	/* dlgVer */
	int iDlgVer = DialogRes.GetInt16();
	BOOL fOldVersion = FALSE;
	if (iDlgVer != 1)
	{
		// we have the old style -- DLGTEMPLATE + DLGITEMTEMPLATE
		fOldVersion = TRUE;
		DialogRes.Undo16();
	}
	if (!fOldVersion)
	{
		/* signature */
		DialogRes.GetInt16();
		/* helpID */
		DialogRes.GetInt32();
	}
	/* Extended Style + Style */
	int iDlgStyle = DialogRes.GetInt32() | DialogRes.GetInt32();
	/* Number of Controls on Dialog */
	int iNumCtrl  = DialogRes.GetInt16();
	/* X-coord (maps to HCentering value) */
	int iDlgXDim  = DialogRes.GetInt16();
	/* Y-coord (maps to VCentering value) */
	int iDlgYDim  = DialogRes.GetInt16();
	/* width */
	int iDlgWdDim = DialogRes.GetInt16();
	/* height */
	int iDlgHtDim = DialogRes.GetInt16();
	/* menu, aligned on WORD boundary */
	DialogRes.Align16();
	int iDlgMenu = DialogRes.GetInt16();
	if (iDlgMenu == 0xFFFF)
		DialogRes.GetInt16(); // ordinal menu value
	else if (iDlgMenu != 0x0000)
	{
		TCHAR* szMenu = DialogRes.GetStr();
		if (szMenu)
			delete [] szMenu;
	}
	/* class, aligned on WORD boundary */
	DialogRes.Align16();
	int iDlgClass = DialogRes.GetInt16();
	if (iDlgClass == 0xFFFF)
		DialogRes.GetInt16(); // ordinal window class value
	else if (iDlgClass != 0x0000)
	{
		TCHAR* szClass = DialogRes.GetStr();
		if (szClass)
			delete [] szClass;
	}
	/* title, aligned on WORD boundary */
	DialogRes.Align16();
	TCHAR* szDlgTitle = DialogRes.GetStr();
	/* font */
	if (iDlgStyle & DS_SETFONT)
	{
		/* font point size */
		int iDlgPtSize = DialogRes.GetInt16();
		if (!fOldVersion)
		{
			/* font weight */
			int iDlgFontWt = DialogRes.GetInt16();
			/* font italic */
			int iDlgFontItalic = DialogRes.GetInt16();
		}
		/* font typeface, aligned on WORD boundary */
		DialogRes.Align16();
		TCHAR* szFont = DialogRes.GetStr();
		if (szFont)
			delete [] szFont;
	}

#ifdef DEBUG
	_tprintf(TEXT("LOG>> DIALOG '%s' with '%d' controls at x=%d,y=%d,wd=%d,ht=%d. Title = \"%s\"\n"),
				szDialog,iNumCtrl,iDlgXDim,iDlgYDim,iDlgWdDim,iDlgHtDim,szDlgTitle);
#endif

	/* find dialog in Dialog table, if fail, we ignore */
	//UNSUPPORTED: additional dialogs

	// first find match to dialog in _RESDialogs table
	PMSIHANDLE hViewFindDlgInstlrName = 0;
	PMSIHANDLE hRecDlgInstlrName = 0;
	PMSIHANDLE hRecDlgRESName = MSI::MsiCreateRecord(1);
	assert(hRecDlgRESName);
	UINT iStat;
	if (ERROR_SUCCESS != MSI::MsiRecordSetString(hRecDlgRESName, 1, szDialog))
		return m_fError = TRUE, TRUE;
	if (ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, sqlDialogInstallerName, &hViewFindDlgInstlrName))
	{
		_tprintf(TEXT("LOG_ERROR>> _RESDialogs table is missing from database.\n"));
		return m_fError = TRUE, TRUE;
	}
	if (ERROR_SUCCESS != MSI::MsiViewExecute(hViewFindDlgInstlrName, hRecDlgRESName))
		return m_fError = TRUE, TRUE;
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewFetch(hViewFindDlgInstlrName, &hRecDlgInstlrName)))
	{
		// probably a new dialog
		_tprintf(TEXT("ALERT!, new dialog '%s' added. Unsupported feature!\n"), szDialog);
		return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing through enumeration
	}

	// execute query for search for dialog in Dialog table
	if (ERROR_SUCCESS != MSI::MsiViewExecute(m_hDialog, hRecDlgInstlrName))
		return m_fError = TRUE, TRUE;

	// fetch dialog for update
	PMSIHANDLE hRecDlg = 0;
	if (ERROR_SUCCESS != (iStat = MSI::MsiViewFetch(m_hDialog, &hRecDlg)))
	{
		assert(iStat == ERROR_NO_MORE_ITEMS);
		// could be ERROR_NO_MORE_ITEMS -- someone removed the dialog
		_tprintf(TEXT("LOG_ERROR>> Dialog '%s' not found in database '%s'. New Dialogs are not supported.\n"), szDialog, m_szDatabase);
		return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
	}

	// update dialog
	if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecDlg, idiHCentering, iDlgXDim))
		return m_fError = TRUE, TRUE;
	if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecDlg, idiVCentering, iDlgYDim))
		return m_fError = TRUE, TRUE;
	if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecDlg, idiWidth, iDlgWdDim))
		return m_fError = TRUE, TRUE;
	if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecDlg, idiHeight, iDlgHtDim))
		return m_fError = TRUE, TRUE;
	if (_tcscmp(strOverLimit, szDlgTitle) != 0) // don't update if "!! STR OVER LIMIT !!"
	{
		if (ERROR_SUCCESS != MSI::MsiRecordSetString(hRecDlg, idiTitle, szDlgTitle))
			return m_fError = TRUE, TRUE;
	}

	if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(m_hDialog, MSIMODIFY_UPDATE, hRecDlg)))
	{
		_tprintf(TEXT("LOG_ERROR>>Failed to update Dialog '%s'.\n"), szDialog);
		return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue with other Dialogs
	}

	///////////////////////////////////////////////////////////////////////
	//                  Control Information                              //
	//                                                                   //
	// stored as DLGITEMTEMPLATEEX (should not have DLGITEMTEMPLATE)     //
	/*	typedef struct { 
			DWORD  helpID; 
			DWORD  exStyle; 
			DWORD  style; 
			short  x; 
			short  y; 
			short  cx; 
			short  cy; 
			WORD   id; 
			sz_Or_Ord windowClass; 
			sz_Or_Ord title; 
			WORD   extraCount; 
		} DLGITEMTEMPLATEEX; */
	/////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////
	// DLGITEMTEMPLATE does not have helpID
	//
	if (iNumCtrl > 0 && !m_hControl)
	{
		_tprintf(TEXT("LOG_ERROR>> Unable to update controls.  Control table does not exist\n"));
		return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
	}
	PMSIHANDLE hViewCtrlInstallerName = 0;
	PMSIHANDLE hRecCtrl = 0;
	PMSIHANDLE hRecRadioButton = MSI::MsiCreateRecord(2);
	PMSIHANDLE hRecCtrlResId = MSI::MsiCreateRecord(1);
	assert(hRecCtrlResId);
	if (ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, sqlControlInstallerName, &hViewCtrlInstallerName))
	{
		_tprintf(TEXT("LOG_ERROR>> _RESControls table is missing from database\n"));
		return m_fError = TRUE, TRUE;
	}
	bool fRadioButton = false;
	// cycle through the controls
	for (int i = 1; i <= iNumCtrl; i++)
	{
		/* DLGITEMTEMPLATEEX is alligned on a DWORD boundary */
		DialogRes.Align32(); 

		fRadioButton = false;

		if (!fOldVersion)
		{
			/* helpID */
			DialogRes.GetInt32();
		}
		/* exStyle | style */
		int iCtrlAttrib = DialogRes.GetInt32() | DialogRes.GetInt32();
		/* x */
		int iCtrlXDim = DialogRes.GetInt16();
		/* y */
		int iCtrlYDim = DialogRes.GetInt16();
		/* cx */
		int iCtrlWdDim = DialogRes.GetInt16();
		/* cy */
		int iCtrlHtDim = DialogRes.GetInt16();
		/* id */
		int iCtrlId = DialogRes.GetInt16();
		/* windowClass -- aligned on word boundary*/
		if (!fOldVersion)
			DialogRes.GetInt16(); //!! don't appear to be aligned on word boundary, instead have extra 16 though ??
		else
			DialogRes.Align16();
		TCHAR* szCtrlType = 0;
		int iWndwClass = DialogRes.GetInt16();
		if (iWndwClass == 0xFFFF)
		{
			// pre-defined window class
			short iCtrlWindowClass = DialogRes.GetInt16();
			switch (iCtrlWindowClass)
			{
			case 0x0080: // button
				if (iCtrlAttrib & BS_RADIOBUTTON)
					fRadioButton = true;
				break;
			case 0x0081: // edit
				break;
			case 0x0082: // static
				break;
			case 0x0083: // list box
				break;
			case 0x0084: // scroll bar
				break;
			case 0x0085: // combo box
				break;
			default: assert(0);
				break;
			}
		}
		else
		{
			// custom window class, stored as str
			DialogRes.Undo16();
			szCtrlType = DialogRes.GetStr();
		}
		/* title -- aligned on word boundary*/
		DialogRes.Align16();
		TCHAR* szCtrlText = 0;
		if (DialogRes.GetInt16() == 0xFFFF)
		{
			// ordinal
			DialogRes.GetInt16();
		}
		else
		{
			// str title
			DialogRes.Undo16();
			szCtrlText = DialogRes.GetStr();
		}
		/* extra count */
		int iCtrlCreationData = DialogRes.GetInt16();
		if (iCtrlCreationData > 0)
		{
			DialogRes.Align16(); // data begins at next WORD boundary
			DialogRes.Move(iCtrlCreationData);
		}

		// find control's real name (for use with Installer)
		if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecCtrlResId, 1, iCtrlId))
			return m_fError = TRUE, TRUE;
		if (ERROR_SUCCESS != MSI::MsiViewExecute(hViewCtrlInstallerName, hRecCtrlResId))
			return m_fError = TRUE, TRUE;

		// fetch control's real name
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewFetch(hViewCtrlInstallerName, &hRecCtrl)))
		{
			if (ERROR_NO_MORE_ITEMS == iStat)
			{
				// new control, unsupported feature
				_tprintf(TEXT("LOG_ERROR>>\t Control with ID '%d' not found. New Controls are not supported.\n"), iCtrlId);
				return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
			}
			assert(ERROR_SUCCESS != iStat);
		}

		DWORD dwName = 0;
		MSI::MsiRecordGetString(hRecCtrl, 2, TEXT(""), &dwName);
		TCHAR* szCtrlName = new TCHAR[++dwName];
		if (ERROR_SUCCESS != MSI::MsiRecordGetString(hRecCtrl, 2, szCtrlName, &dwName))
			return m_fError = TRUE, TRUE;
#ifdef DEBUG
		_tprintf(TEXT("LOG>>\tCONTROL '%d' ('%s') at x=%d,y=%d,wd=%d,ht=%d. Text = \"%s\"\n"),
			iCtrlId,szCtrlName,iCtrlXDim,iCtrlYDim,iCtrlWdDim,iCtrlHtDim,szCtrlText);
#endif

		// fetch control's info for update
		// for radiobuttons, we have to get it from the radiobutton table
		// we also have to parse the szCtrlName string to get out the property and order keys used in the radiobutton table
		// assumes that radiobuttons follow group:property:order syntax
		if (fRadioButton && !_tcschr(szCtrlName, ':'))
			fRadioButton = false; // not really a radiobutton, just the group encapsulating them

		PMSIHANDLE hRecRBExec = 0;
		if (fRadioButton)
		{
			if (!m_hRadioButton)
			{
				_tprintf(TEXT("LOG_ERROR>> RadioButtons found, but no RadioButton table exists in the database\n"));
				return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
			}
			// parse name RadioButtonGroup:Property:Order
			TCHAR* szRBGroup = _tcstok(szCtrlName, szTokenSeps);
			assert(szRBGroup);
			TCHAR* szRBProperty = _tcstok(NULL, szTokenSeps);
			assert(szRBProperty);
			TCHAR* szRBOrder = _tcstok(NULL, szTokenSeps);
			assert(szRBOrder);
			int iRBOrder = _ttoi(szRBOrder);
#ifdef DEBUG
			_tprintf(TEXT("LOG>> RadioButton belongs to RBGroup: %s, Property: %s, and has Order=%d"), szRBGroup, szRBProperty, iRBOrder);
#endif
			hRecRBExec = MSI::MsiCreateRecord(2);
			if (ERROR_SUCCESS != MSI::MsiRecordSetString(hRecRBExec, 1, szRBProperty))
				return m_fError = TRUE, TRUE;
			if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecRBExec, 2, iRBOrder))
				return m_fError = TRUE, TRUE;
		}
		if (ERROR_SUCCESS != MSI::MsiViewExecute(fRadioButton ? m_hRadioButton : m_hControl, fRadioButton ? hRecRBExec : hRecCtrl))
			return m_fError = TRUE, TRUE;
		PMSIHANDLE hRecCtrlUpdate = 0;
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewFetch(fRadioButton ? m_hRadioButton : m_hControl, &hRecCtrlUpdate)))
		{
			if (ERROR_NO_MORE_ITEMS == iStat)
			{
				// control has been removed from database
				_tprintf(TEXT("LOG_ERROR>>\t Control with ID '%d' not found in database.\n"), iCtrlId);
				return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue processing
			}
			assert(ERROR_SUCCESS != iStat);
		}

		// update info
		if (!fRadioButton)
		{
			if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecCtrlUpdate, iciX, iCtrlXDim))
				return m_fError = TRUE, TRUE;
			if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecCtrlUpdate, iciY, iCtrlYDim))
				return m_fError = TRUE, TRUE;
		}
		if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecCtrlUpdate, fRadioButton ? irbiWidth : iciWidth, iCtrlWdDim))
			return m_fError = TRUE, TRUE;
		if (ERROR_SUCCESS != MSI::MsiRecordSetInteger(hRecCtrlUpdate, fRadioButton ? irbiHeight : iciHeight, iCtrlHtDim))
			return m_fError = TRUE, TRUE;
		if (0 != _tcscmp(strOverLimit, szCtrlText)) // don't update if "!! STR OVER LIMIT !!"
		{
			if (ERROR_SUCCESS != MSI::MsiRecordSetString(hRecCtrlUpdate, fRadioButton ? irbiText : iciText, szCtrlText))
				return m_fError = TRUE, TRUE;
		}
		if (ERROR_SUCCESS != (iStat = MSI::MsiViewModify(fRadioButton ? m_hRadioButton : m_hControl, MSIMODIFY_UPDATE, hRecCtrlUpdate)))
		{
			_tprintf(TEXT("LOG_ERROR>>Failed to update Control '%d'.\n"), iCtrlId);
			return m_fError = TRUE, TRUE; // error - ABORT, but TRUE to continue with other Dialogs
		}

		if (szCtrlType)
			delete [] szCtrlType;
		if (szCtrlText)
			delete [] szCtrlText;
		if (ERROR_SUCCESS != MSI::MsiViewClose(hViewCtrlInstallerName)) // for re-execute
			return m_fError = TRUE, TRUE;
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
// CImportRes::SetCodePage
BOOL CImportRes::SetCodePage(WORD wLang)
{
	// if we have already set the codepage, we don't need to do it again
	if (m_fSetCodepage)
		return TRUE;

	DWORD dwLocale = MAKELCID(wLang, SORT_DEFAULT);
	TCHAR szLocaleBuf[7]; // from MSDN, max # char allowed is 6
	int cch = W32::GetLocaleInfo(dwLocale, LOCALE_IDEFAULTANSICODEPAGE, szLocaleBuf, sizeof(szLocaleBuf)/sizeof(TCHAR));
	assert(cch != 0);

	// GetLocaleInfo always returns information in text format
	// Numeric data is written in decimal format
	// Expect numeric data because ask for CodePage...need to convert to int
	TCHAR* szStop;
	g_uiCodePage = _tcstoul(szLocaleBuf, &szStop, 0);

	//verify database's codepage
	// database's codepage must either be language NEUTRAL or match g_uiCodepage
	if (ERROR_SUCCESS != VerifyDatabaseCodepage())
		return m_fError = TRUE, FALSE;

	// verify codepage is available on system
	// A code page is considered valid only if it is installed in the system. 
	if (!IsValidCodePage(g_uiCodePage))
		return m_fError = TRUE, FALSE; // codepage not valid for this system

	// set codepage in database using _ForceCodepage table
	// find temp directory
	TCHAR szTempPath[MAX_PATH];
	W32::GetTempPath(MAX_PATH, szTempPath);

	// create full path (TEMP directory already has backslash)
	TCHAR szFileFullPath[2*MAX_PATH + 2];
	wsprintf(szFileFullPath, TEXT("%s%s"), szTempPath, szCodepageFile);
	DWORD dwWritten;
	HANDLE hFile = W32::CreateFile(szFileFullPath, GENERIC_WRITE, FILE_SHARE_WRITE, 0, CREATE_ALWAYS, 0, 0);
	if (!hFile)
	{
		_tprintf(TEXT("!! Unable to set codepage of database.\n"));
		return m_fError = TRUE, FALSE;
	}

	/*********************************
	 FORMAT FOR FORCING CODEPAGE
	**********************************/
	// blank line
	// blank line
	// codepage<tab>_ForceCodepage
	TCHAR szCodepage[MAX_PATH];
	DWORD dw = wsprintf(szCodepage, TEXT("\r\n\r\n%s\t%s\r\n"), szLocaleBuf, szForceCodepage);
#ifdef UNICODE
	assert(_tcsclen(szCodepage) + 1 < MAX_PATH/2);
	char szBuf[MAX_PATH];
	if (!W32::WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, szCodepage, _tcsclen(szCodepage), szBuf, MAX_PATH, NULL, NULL))
		return m_fError = TRUE, FALSE;
	if (!WriteFile(hFile, szBuf, strlen(szBuf), &dwWritten, 0))
		return m_fError = TRUE, FALSE;
#else
	if (!WriteFile(hFile, szCodepage, dw, &dwWritten, 0))
		return m_fError = TRUE, FALSE;
#endif
	if (!W32::CloseHandle(hFile))
		return m_fError = TRUE, FALSE;

	// set codepage of database
	UINT iStat = MSI::MsiDatabaseImport(m_hDatabase, szTempPath, szCodepageFile);
	if (iStat != ERROR_SUCCESS)
	{
		_tprintf(TEXT("!! Unable to set codepage of database. Error = %d\n"), iStat);
		return m_fError = TRUE, FALSE;
	}
	
	// attempt to delete the file we created for clean-up
//	if (!DeleteFile(szCodepageFile))
//		return m_fError = TRUE, FALSE;

	// update status flage
	m_fSetCodepage = TRUE;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// EnumDialogCallback 
BOOL __stdcall EnumDialogCallback(HINSTANCE hModule, const TCHAR* szType, TCHAR* szDialogName, long lParam)
{
	// determine codepage required.  steps, enumerate languages in resource file (better be no more than two)
	// possibilities are NEUTRAL (non-localized) + other lang

	((CImportRes*)lParam)->SetFoundLang(FALSE); // init to FALSE
	if (!W32::EnumResourceLanguages(hModule, szType, szDialogName, EnumLanguageCallback, lParam))
		return FALSE;
	
#ifdef DEBUG
	_tprintf(TEXT("LOG>> DIALOG: '%s' FOUND\n"),szDialogName);
#endif

	BOOL fOK = ((CImportRes*)lParam)->LoadDialog(hModule, szType, szDialogName);
	if (!fOK)
	{
		// error occured
		((CImportRes*)lParam)->SetErrorState(TRUE);
		return FALSE;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// EnumStringCallback
BOOL __stdcall EnumStringCallback(HINSTANCE hModule, const TCHAR* szType, TCHAR* szName, long lParam)
{
	((CImportRes*)lParam)->SetFoundLang(FALSE); // init to FALSE

	// determine codepage required.  steps, enumerate languages in resource file (better be no more than two)
	// possibilities are NEUTRAL (non-localized) + other lang
	if (!W32::EnumResourceLanguages(hModule, szType, szName, EnumLanguageCallback, lParam))
		return FALSE;


	BOOL fOK = ((CImportRes*)lParam)->LoadString(hModule, szType, szName);
	if (!fOK)
	{
		// error occured
		((CImportRes*)lParam)->SetErrorState(TRUE);
		return FALSE;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// EnumLanguageCallback
BOOL __stdcall EnumLanguageCallback(HINSTANCE hModule, const TCHAR* szType, const TCHAR* szName, WORD wIDLanguage, long lParam)
{
	/*************************************************************************************
	RESTRICTIONS:
	1.) ONLY 1 language per resource
	2.) UP To 2 languages per resource file (but 1 must be LANG_NEUTRAL)
	3.) On Win9x we must be on a system matching the required codepage
	4.) We should only be able to update a language neutral database or
	    a database set with the required code page
	5.) Database can only have one code page (Although _SummaryInformation stream
	    can have a code page different from database as _SummaryInformation is considered
		to be different
	**************************************************************************************/
	
	if (((CImportRes*)lParam)->WasLanguagePreviouslyFound())
	{
		// ERROR -- more than 1 language per dialog
		_tprintf(TEXT("!! STRING RESOURCE IS IN MORE THAN ONE LANGUAGE IN RESOURCE FILE\n"));
		((CImportRes*)lParam)->SetErrorState(TRUE);
		return FALSE;
	}

	// if languages match we are good to go
	if (g_wLangId != wIDLanguage)
	{
		// languages don't match
		// 2 valid scenarios

		// valid SCENARIO 1: g_wLangId is NEUTRAL, wIDLanguage new language
		// valid SCENARIO 2: g_wLangId is language, wIDLanguage is NEUTRAL
		// all other scenarios invalid
		if (g_wLangId == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
		{
			// set codepage, update g_uiCodePage
			if (!((CImportRes*)lParam)->SetCodePage(wIDLanguage))
				return ((CImportRes*)lParam)->SetErrorState(TRUE), FALSE;
			g_wLangId = wIDLanguage;
		}
		else if (wIDLanguage != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
		{
			// invalid, 2 different languages, neither one NEUTRAL
			_tprintf(TEXT("!! Resource file contains more than one language. Not Supported. Lang1 = %d, Lang2 = %d\n"), g_wLangId, wIDLanguage);
			return ((CImportRes*)lParam)->SetErrorState(TRUE), FALSE;
		}
	}
	
	((CImportRes*)lParam)->SetFoundLang(TRUE); // language found for resource
	return TRUE;
}

//_______________________________________________________________________________________
//
// CDIALOGSTREAM CLASS IMPLEMENTATION
//_______________________________________________________________________________________

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetInt16 -- returns a 16 bit integer, moves internal ptr 16
short CDialogStream::GetInt16()
{
	short i = *(unsigned short*)m_pch;
	m_pch += sizeof(unsigned short);
	return i;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetInt32 -- returns a 32 bit integer, moves internal ptr 32
int CDialogStream::GetInt32()
{
	int i = *(int*)m_pch;
	m_pch += sizeof(int);
	return i;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetInt8 -- returns a 8 bit integer, moves internal ptr 8
int CDialogStream::GetInt8()
{
	int i = *(unsigned char*)m_pch;
	m_pch += sizeof(unsigned char);
	return i;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::GetStr -- returns a null terminated str from memory.
//   Handles DBCS, Unicode str storage.  Moves ptr length of str.
//   Resource strings stored as unicode
TCHAR* CDialogStream::GetStr()
{
	TCHAR* sz;
#ifdef UNICODE
	int cchwide = lstrlenW((wchar_t*)m_pch);
	sz = new TCHAR[cchwide + 1];
	lstrcpyW(sz, (wchar_t*)m_pch);
#else
	// what codepage to use to translate?
	int cb = W32::WideCharToMultiByte(CP_ACP, 0, (wchar_t*)m_pch, -1, 0, 0, 0, 0);
	int cchwide = lstrlenW((wchar_t*)m_pch);
	sz = new TCHAR[cb+1];
	BOOL fUsedDefault;
	W32::WideCharToMultiByte(CP_ACP, 0, (wchar_t*)m_pch, -1, sz, cb, 0, &fUsedDefault);
#endif // UNICODE
	
	m_pch += 2*(cchwide+1);
	return sz;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::Align32-- moves pointer to DWORD boundary
BOOL CDialogStream::Align32()
{
	m_pch = (char*)(int(m_pch) + 3 & ~ 3);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::Align16-- moves pointer to WORD boundary
BOOL CDialogStream::Align16()
{
	m_pch = (char*)(int(m_pch) + 1 & ~ 1);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::Undo16 -- moves ptr back 16
BOOL CDialogStream::Undo16()
{
	m_pch -= sizeof(unsigned short);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogStream::Move -- moves pointer cbBytes
BOOL CDialogStream::Move(int cbBytes)
{
	m_pch += cbBytes;
	return TRUE;
}

CDialogStream::CDialogStream(HGLOBAL hResource)
	: m_pch((char*)hResource)
{
	// Constructor
}

CDialogStream::~CDialogStream()
{
	// Destructor
}


//__________________________________________________________________________________________
//
// MAIN + HELPER FUNCTIONS
//__________________________________________________________________________________________

///////////////////////////////////////////////////////////
// usage
void Usage()
{
	_tprintf(
			TEXT("MSILOC.EXE -- Copyright (C) Microsoft Corporation, 2000-2001.  All rights reserved\n")
			TEXT("\t*Generates a resource file from the UI in the installation package\n")
			TEXT("\t*Imports a localized resource DLL into an installation package\n")
			TEXT("\n")
			TEXT("SYNTAX -->EXPORT MSI TO RC (creates a resource file):\n")
			TEXT("  msiloc -e {database} {option 1}{option 2}...\n")
			TEXT("SYNTAX -->IMPORT (RES)DLL TO MSI:\n")
			TEXT("  msiloc -i {database} {resource DLL} {option 1}{option 2}...\n")
			TEXT("OPTIONS:\n")
			TEXT("    -d * all dialogs\n")
			TEXT("    -d {Dialog1} specific dialog\n")
			TEXT("    -s {Table Column} specific column of strings (EXPORT ONLY)\n")
			TEXT("    -s * * all strings (IMPORT ONLY)\n")
			TEXT("    -x option to not export binary data (bitmaps, icons, jpegs) (EXPORT ONLY)\n")
			TEXT("    -c {database} option to save to a new database\n")
			TEXT("\n")
			TEXT("CREATING A .RES FILE:\n")
			TEXT("    rc.exe {resource file}\n")
			TEXT("CREATING A .DLL FILE:\n")
			TEXT("    link.exe /DLL /NOENTRY /NODEFAULTLIB /MACHINE:iX86\n")
			TEXT("         /OUT:{resource DLL} {compiled res file}\n")
			);
}

///////////////////////////////////////////////////////////
// SkipWhiteSpace
TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
	TCHAR ch;
	for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
		;
	return ch;
}

///////////////////////////////////////////////////////////
// SkipValue
BOOL SkipValue(TCHAR*& rpch)
{
	TCHAR ch = *rpch;
	if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
		return FALSE;   // no value present

	TCHAR *pchSwitchInUnbalancedQuotes = NULL;

	for (; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++)
	{       
		if (*rpch == TEXT('"'))
		{
			rpch++; // for '"'

			for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
			{
				if ((ch == TEXT('/') || ch == TEXT('-')) && (NULL == pchSwitchInUnbalancedQuotes))
				{
					pchSwitchInUnbalancedQuotes = rpch;
				}
			}
                    ;
            ch = *(++rpch);
            break;
		}
	}
	if (ch != 0)
	{
		*rpch++ = 0;
	}
	else
	{
		if (pchSwitchInUnbalancedQuotes)
			rpch=pchSwitchInUnbalancedQuotes;
	}
	return TRUE;
}

///////////////////////////////////////////////////////////
// Error
void Error(TCHAR* szMsg)
{
	_tprintf(TEXT("MSILOC ERROR: %s\n"), szMsg);
	throw 1;
}

///////////////////////////////////////////////////////////
// ErrorIf
void ErrorIf(BOOL fError, TCHAR* szMsg, BOOL fThrow)
{
	if (fError)
	{
		_tprintf(TEXT("MSILOC ERROR: %s\n"), szMsg);
		if (fThrow)
			throw 1;
	}
}

///////////////////////////////////////////////////////////
// _tmain
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{	
	// WE WANT UNICODE ON NT/Windows2000
	// ?? ANSI on WIN9x

	try
	{
		TCHAR* szCmdLine = W32::GetCommandLine();
		TCHAR* pch = szCmdLine;
		SkipValue(pch); // skip module name
		TCHAR chCmdNext;

		TCHAR* rgszTables[MAX_STRINGS];
		TCHAR* rgszColumns[MAX_STRINGS];
		TCHAR* rgszDialogs[MAX_DIALOGS];
		TCHAR* szDb = 0;
		TCHAR* szRESDLL = 0;
		TCHAR* szSaveDatabase = 0;
		int cStr = 0;
		int cDlg = 0;
		int iMode = 0;
		while ((chCmdNext = SkipWhiteSpace(pch)) != 0)
		{
			if (chCmdNext == TEXT('/') || chCmdNext == TEXT('-'))
			{
				TCHAR* szCmdOption = pch++;
				TCHAR chOption = (TCHAR)(*pch++ | 0x20);
				chCmdNext = SkipWhiteSpace(pch);
				TCHAR* szCmdData = pch;
				switch (chOption)
				{
				case TEXT('i'):
					iMode |= iIMPORT_RES;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = I)\n"));
					szDb = szCmdData;
					szCmdData = pch;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = I)\n"));
					szRESDLL = szCmdData;
					break;
				case TEXT('e'):
					iMode |= iEXPORT_MSI;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = E)\n"));
					szDb = szCmdData;
					break;
				case TEXT('d'):
					iMode |= iDIALOGS;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = D)\n"));
					if (cDlg == MAX_DIALOGS)
						Error(TEXT("Too Many Dialogs On Command Line\n"));
					rgszDialogs[cDlg++] = szCmdData;
					break;
				case TEXT('s'):
					iMode |= iSTRINGS;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = S)\n"));
					if (cStr == MAX_STRINGS)
						Error(TEXT("Too Many Table:Column Pairs On Command Line\n"));
					rgszTables[cStr] = szCmdData;
					szCmdData = pch;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = S)\n"));
					rgszColumns[cStr++] = szCmdData;
					break;
				case TEXT('x'):
					iMode |= iSKIP_BINARY;
					break;
				case TEXT('c'):
					iMode |= iCREATE_NEW_DB;
					if (!SkipValue(pch))
						Error(TEXT("Missing Option Data (option = C)\n"));
					szSaveDatabase = szCmdData;
					break;
				case TEXT('?'):
					Usage();
					return 0;
				default:
					Usage();
					return 1;
				}
			}
			else
			{
				Usage();
				return 1;
			}
		}

		// must specify either EXPORT or IMPORT, but not both
		if (iMode == 0 || (iMode & (iEXPORT_MSI | iIMPORT_RES)) == (iEXPORT_MSI | iIMPORT_RES) ||
			(iMode & ~(iEXPORT_MSI | iIMPORT_RES)) == 0)
		{
			Usage();
			throw 1;
		}

		if ((iMode & iCREATE_NEW_DB) && !szDb)
		{
			Usage();
			throw 1;
		}

		if ((iMode & iEXPORT_MSI) && szDb)
		{
			// export MSI to RESOURCE file
			CGenerateRC genRC(szDb, (iMode & iCREATE_NEW_DB) ? szSaveDatabase : NULL);
			if (iMode & iDIALOGS)
			{
				// export DIALOGS
				BOOL fBinary = (iMode & iSKIP_BINARY) ? FALSE : TRUE;
				if (1 == cDlg && 0 == _tcscmp(TEXT("*"), rgszDialogs[0]))
				{
					// export all dialogs
					ErrorIf(ERROR_SUCCESS != genRC.OutputDialogs(fBinary), TEXT("Failed to Export Dialogs To Resource File"), true);
				}
				else
				{
					// export specified dialogs only
					// we'll try every dialog listed so we won't through the error
					for (int i = 0; i < cDlg; i++)
						ErrorIf(ERROR_SUCCESS != genRC.OutputDialog(rgszDialogs[i], fBinary), TEXT("Failed to Export Dialog To Resource File"), false);
					ErrorIf(genRC.IsInErrorState(), TEXT("EXPORT failed"), true);
				}
			}
			if (iMode & iSTRINGS)
			{
				// export STRINGS
				if (1 == cStr && 0 == _tcscmp(TEXT("*"), rgszTables[0]) && 0 == _tcscmp(TEXT("*"), rgszColumns[0]))
				{
					// export all strings
					// NOT SUPPORTED
					_tprintf(TEXT("EXPORT ALL STRINGS OPTION is not supported\n"));
					Usage();
					throw 1;
				}
				for (int i = 0; i < cStr; i++)
					ErrorIf(ERROR_SUCCESS != genRC.OutputString(rgszTables[i], rgszColumns[i]), TEXT("Failed to Export Strings"), false);
				ErrorIf(genRC.IsInErrorState(), TEXT("EXPORT STRINGS failed"), true);
			}
		}
		else if ((iMode & iIMPORT_RES) && szDb && szRESDLL)
		{
			// import RESOURCE DLL into MSI
			CImportRes importRes(szDb, (iMode & iCREATE_NEW_DB) ? szSaveDatabase  : NULL, szRESDLL);
			if (iMode & iDIALOGS)
			{
				// import DIALOGS
				if (1 == cDlg && 0 == _tcscmp(TEXT("*"), rgszDialogs[0]))
				{
					// import all dialogs
					ErrorIf(ERROR_SUCCESS != importRes.ImportDialogs(), TEXT("Failed to Import Dialogs Into Database"), true);
				}
				else
				{
					// import specified dialogs only
					// we'll try every dialog listed so we won't through the error
					for (int i = 0; i < cDlg; i++)
						ErrorIf(ERROR_SUCCESS != importRes.ImportDialog(rgszDialogs[i]), TEXT("Failed to Import Dialog Into Database"), false);
					ErrorIf(importRes.IsInErrorState(), TEXT("IMPORT failed"), true);
				}
			}
			if (iMode & iSTRINGS)
			{
				// import STRINGS
				if (1 == cStr && 0 == _tcscmp(TEXT("*"), rgszTables[0]) && 0 == _tcscmp(TEXT("*"), rgszColumns[0]))
				{
					// import all strings
					ErrorIf(importRes.ImportStrings(), TEXT("IMPORT STRINGS failed"), true);
				}
				else
				{
					// import specific strings only
					// UNSUPPORTED option
					_tprintf(TEXT("IMPORT SPECIFIC STRINGS option is not supported\n"));
					Usage();
					throw 1;
				}
			}
		}
		else
		{
			Usage();
			throw 1;
		}
		return 0;
	}
	catch (int i)
	{
		i;
		return 1;
	}
	catch (...)
	{
		_tprintf(TEXT("\n MSILOC: unhandled exception.\n"));
		return 2;
	}

}	// end of main

#else // RC_INVOKED, end of source code, start of resources
// resource definition go here
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimig\buffer.h ===
//____________________________________________________________________________
//
// CTempBuffer<class T, int C>   // T is array type, C is element count
// 
// Temporary buffer object for variable size stack buffer allocations
// Template arguments are the type and the stack array size.
// The size may be reset at construction or later to any other size.
// If the size is larger that the stack allocation, new will be called.
// When the object goes out of scope or if its size is changed,
// any memory allocated by new will be freed.
// Function arguments may be typed as CTempBufferRef<class T>&
//  to avoid knowledge of the allocated size of the buffer object.
// CTempBuffer<T,C> will be implicitly converted when passed to such a function.
//____________________________________________________________________________

template <class T> class CTempBufferRef;  // for passing CTempBuffer as unsized ref

template <class T, int C> class CTempBuffer
{
 public:
	CTempBuffer() {m_cT = C; m_pT = m_rgT;}
	CTempBuffer(int cT) {m_pT = (m_cT = cT) > C ? new T[cT] : m_rgT;}
  ~CTempBuffer() {if (m_cT > C) delete m_pT;}
	operator T*()  {return  m_pT;}  // returns pointer
	operator T&()  {return *m_pT;}  // returns reference
	int  GetSize() {return  m_cT;}  // returns last requested size
	void SetSize(int cT) {if (m_cT > C) delete[] m_pT; m_pT = (m_cT=cT) > C ? new T[cT] : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > C ? new T[cT] : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
	}
	operator CTempBufferRef<T>&() {m_cC = C; return *(CTempBufferRef<T>*)this;}
	T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64		//--merced: additional operators for int64
	T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
 protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	T*  m_pT;     // current buffer pointer
	int m_cT;     // reqested buffer size, allocated if > C
	int m_cC;     // size of local buffer, set only by conversion to CTempBufferRef 
	T   m_rgT[C]; // local buffer, must be final member data
};

template <class T> class CTempBufferRef : public CTempBuffer<T,1>
{
 public:
	void SetSize(int cT) {if (m_cT > m_cC) delete[] m_pT; m_pT = (m_cT=cT) > m_cC ? new T[cT] : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > m_cC ? new T[cT] : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
	}
 private:
	CTempBufferRef(); // cannot be constructed
	~CTempBufferRef(); // ensure use as a reference
};

//____________________________________________________________________________
//
// CAPITempBuffer class is mirrored on the CTempBuffer except that it uses GlobalAlloca
// and GlobalFree in place of new and delete. We should try combining these 2 in the future
//____________________________________________________________________________


template <class T> class CAPITempBufferRef;

template <class T, int C> class CAPITempBufferStatic
{
 public:
	CAPITempBufferStatic() {m_cT = C; m_pT = m_rgT;}
	CAPITempBufferStatic(int cT) {m_pT = (m_cT = cT) > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
	void Destroy() {if (m_cT > C) {GlobalFree(m_pT); m_pT = m_rgT; m_cT = C;}}
	operator T*()  {return  m_pT;}  // returns pointer
	operator T&()  {return *m_pT;}  // returns reference
	int  GetSize() {return  m_cT;}  // returns last requested size
	void SetSize(int cT) {if (m_cT > C) GlobalFree(m_pT); m_pT = (m_cT=cT) > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) GlobalFree(m_pT); m_pT = pT; m_cT = cT;
	}
	operator CAPITempBufferRef<T>&() {m_cC = C; return *(CAPITempBufferRef<T>*)this;}
	T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64	//--merced: additional operators for int64
	T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
	
 protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	T*  m_pT;     // current buffer pointer
	int m_cT;     // reqested buffer size, allocated if > C
	int m_cC;     // size of local buffer, set only by conversion to CAPITempBufferRef 
	T   m_rgT[C]; // local buffer, must be final member data
};

template <class T, int C> class CAPITempBuffer
{
 public:
	CAPITempBuffer() {m_cT = C; m_pT = m_rgT;}
	CAPITempBuffer(int cT) {m_pT = (m_cT = cT) > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
  ~CAPITempBuffer() {if (m_cT > C) GlobalFree(m_pT);}
	operator T*()  {return  m_pT;}  // returns pointer
	operator T&()  {return *m_pT;}  // returns reference
	int  GetSize() {return  m_cT;}  // returns last requested size
	void SetSize(int cT) {if (m_cT > C) GlobalFree(m_pT); m_pT = (m_cT=cT) > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > C ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) GlobalFree(m_pT); m_pT = pT; m_cT = cT;
	}
	operator CAPITempBufferRef<T>&() {m_cC = C; return *(CAPITempBufferRef<T>*)this;}
	T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64		//--merced: additional operators for int64
	T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
	T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
 protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	T*  m_pT;     // current buffer pointer
	int m_cT;     // reqested buffer size, allocated if > C
	int m_cC;     // size of local buffer, set only by conversion to CAPITempBufferRef 
	T   m_rgT[C]; // local buffer, must be final member data
};

template <class T> class CAPITempBufferRef : public CAPITempBuffer<T,1>
{
 public:
	void SetSize(int cT) {if (m_cT > m_cC) delete[] m_pT; m_pT = (m_cT=cT) > m_cC ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;}
	void Resize(int cT) { 
		T* pT = cT > m_cC ? (T*)GlobalAlloc(GMEM_FIXED, sizeof(T)*cT) : m_rgT;
		if(m_pT != pT)
			for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
		if(m_pT != m_rgT) GlobalFree(m_pT); m_pT = pT; m_cT = cT;
	}
 private:
	CAPITempBufferRef(); // cannot be constructed
	~CAPITempBufferRef(); // ensure use as a reference
};



//____________________________________________________________________________
//
// CConvertString -- does appropriate ANSI/UNICODE string conversion for
// function arguments. Wrap string arguments that might require conversion 
// (ANSI->UNICODE) or (UNICODE->ANSI). The compiler will optimize away the 
// case where conversion is not required.
//
// Beware: For efficiency this class does *not* copy the string to be converted.
//____________________________________________________________________________

const int cchConversionBuf = 255;

class CConvertString
{
public:
	CConvertString(const char* szParam);
	CConvertString(const WCHAR* szParam);
	operator const char*()
	{
		if (!m_szw)
			return m_sza;
		else
		{
			int cchParam = lstrlenW(m_szw);
			if (cchParam > cchConversionBuf)
				m_rgchAnsiBuf.SetSize(cchParam+1);

			*m_rgchAnsiBuf = 0;
			int iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, m_rgchAnsiBuf, 
							 		  m_rgchAnsiBuf.GetSize(), 0, 0);
			
			if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
			{
				iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, 0, 0, 0, 0);
				if (iRet)
				{
					m_rgchAnsiBuf.SetSize(iRet);
					*m_rgchAnsiBuf = 0;
					iRet = WideCharToMultiByte(CP_ACP, 0, m_szw, -1, m_rgchAnsiBuf, 
								  m_rgchAnsiBuf.GetSize(), 0, 0);
				}
				//Assert(iRet != 0);
			}

			return m_rgchAnsiBuf;
		}
	}


		
	operator const WCHAR*()
	{
		if (!m_sza)
			return m_szw;
		else
		{
			int cchParam = lstrlenA(m_sza);
			if (cchParam > cchConversionBuf)
				m_rgchWideBuf.SetSize(cchParam+1);

			*m_rgchWideBuf = 0;
			int iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, m_rgchWideBuf, m_rgchWideBuf.GetSize());
			if ((0 == iRet) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
			{
				iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, 0, 0);
				if (iRet)
				{
  					m_rgchWideBuf.SetSize(iRet);
					*m_rgchWideBuf = 0;
					iRet = MultiByteToWideChar(CP_ACP, 0, m_sza, -1, m_rgchWideBuf, m_rgchWideBuf.GetSize());
				}
				//Assert(iRet != 0);
			}


			return m_rgchWideBuf;
		}
	}

protected:
	void* operator new(size_t) {return 0;} // restrict use to temporary objects
	CTempBuffer<char, cchConversionBuf+1> m_rgchAnsiBuf;
	CTempBuffer<WCHAR, cchConversionBuf+1> m_rgchWideBuf;
	const char* m_sza;
	const WCHAR* m_szw;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimig\cachpack.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       cachpack.cpp
//
//--------------------------------------------------------------------------

#include "_msimig.h"

#define szMsiLocalPackagesKey       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages")
#define szMsiUninstallProductsKey   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define szLocalPackageValueName     TEXT("LocalPackage")

class ChKey
{
 // Class to handle clean up of opened registry keys.

 public:
	ChKey(HKEY hKey) { m_hKey = hKey;}
	~ChKey() { if (m_hKey) RegCloseKey(m_hKey);}
	operator HKEY() { return m_hKey; }
	HKEY* operator &() { return &m_hKey;}
 private:
	operator =(HKEY);
	HKEY m_hKey;
};

DWORD CopyAndRegisterPackage(const TCHAR* szProductKey, const TCHAR* szProductCode, const TCHAR* szUserSID, 
									  const TCHAR* szUserName, const TCHAR* szPackagePath)
{
	// szUserName  = name, or blank for machine

		
	UINT uiResult = ERROR_SUCCESS;
	// first, open writable key to new cached package registration
	ChKey hProductLocalPackagesW(0);

	// if running as local system, and package is on a network path, all we can do is munge
	// the sourcelist, and hope everything works.

	if (g_hInstall && g_fRunningAsLocalSystem && IsNetworkPath(szPackagePath))
	{
		uiResult = (g_pfnMsiSourceListAddSource)(szProductCode, szUserName, 0, szPackagePath);
		return uiResult;
	}

	// otherwise it's someplace we can get to, 
	// check to make sure that it's really the right package.
	MSIHANDLE hSummaryInfo = NULL;
	if (ERROR_SUCCESS == (uiResult = (g_pfnMsiGetSummaryInformation)(NULL, szPackagePath, 0, &hSummaryInfo)))
	{
		UINT uiDataType = 0;
		TCHAR szPackageCode[40] = TEXT("");
		DWORD cchPackageCode = sizeof(szPackageCode);
		int iValue = 0;
		FILETIME ftValue;
		if (ERROR_SUCCESS == (uiResult = (g_pfnMsiSummaryInfoGetProperty)(hSummaryInfo, PID_REVNUMBER, &uiDataType, &iValue, &ftValue, szPackageCode, &cchPackageCode)))
		{
			(g_pfnMsiCloseHandle)(hSummaryInfo);
			TCHAR szSourceProductCode[40] = TEXT("");
			if (ERROR_SUCCESS == (uiResult = (g_pfnMsiGetProductCodeFromPackageCode)(szPackageCode, szSourceProductCode)))
			{
				if (0 == lstrcmpi(szSourceProductCode, szProductCode))
				{
					OutputString(INSTALLMESSAGE_INFO, TEXT("Source package product code matches migration product code.\r\n"));
				}
				else
				{
					OutputString(INSTALLMESSAGE_INFO, TEXT("Source package does not match product code for migration.\r\n\tSource package code: '%s'\r\n"), szSourceProductCode);
					return 1;
				}
			}
			else
			{
				OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot find product code for package code '%s'\r\n"), szPackageCode);
				return uiResult;
			}

		}
		else
		{
			(g_pfnMsiCloseHandle)(hSummaryInfo);
			OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot read package code from summary information for '%s'\r\n"), szPackagePath);
			return uiResult;
		}
	}
	else
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot read package code from package '%s'\r\n"), szPackagePath);
		return (DWORD) uiResult;
	}

	
	// copy and register it into place.
	LONG lRes = W32::RegCreateKey(HKEY_LOCAL_MACHINE,
								  szProductKey,
								  &hProductLocalPackagesW);

	if(lRes != ERROR_SUCCESS)
	{
		DWORD dwError = GetLastError();
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot access configuration data.  Product: %s\r\n\tResult: 0x%X, Error 0x%X\r\n"), szProductCode, lRes, dwError);
		MsiError(INSTALLMESSAGE_ERROR, 1401 /*create key*/, szProductKey, dwError);
		return dwError;
	}

	// now, generate a temporary file name in the %windows%\installer directory
	CAPITempBuffer<TCHAR, MAX_PATH> rgchInstallerDir;
	CAPITempBuffer<TCHAR, MAX_PATH> rgchTempFilePath;
	CAPITempBuffer<TCHAR, MAX_PATH> rgchUrlTempPath;
	
	uiResult = W32::GetWindowsDirectory(rgchInstallerDir, rgchInstallerDir.GetSize());
	if(0 == uiResult)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot GetWindowsDirectory\r\n"));
		return (DWORD)uiResult;
	}
	
	lstrcat(rgchInstallerDir, TEXT("\\"));
	lstrcat(rgchInstallerDir, TEXT("Installer"));
	
	uiResult = MyGetTempFileName(rgchInstallerDir, 0, TEXT("MSI"), rgchTempFilePath);

	if(uiResult != ERROR_SUCCESS)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot create a temporary file name.\r\n"));
		return (DWORD)uiResult;
	}
	
	BOOL fRes = FALSE;
	if (IsURL(szPackagePath))
	{
		bool fURL = false;
		uiResult = DownloadUrlFile(szPackagePath, rgchUrlTempPath, fURL);
		
		if (ERROR_SUCCESS == uiResult)
		{
			fRes = W32::CopyFile(rgchUrlTempPath, rgchTempFilePath, FALSE);
		}
	}
	else
	{
		fRes = W32::CopyFile(szPackagePath, rgchTempFilePath, FALSE);
	}

	if(fRes == FALSE)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Could not copy package to cache.\r\n"));
		return ERROR_INSTALL_FAILURE;
	}

	// now, register new path

	TCHAR szSIDName[cchMaxSID + sizeof(szManagedText) + 1] = TEXT("");
	if (g_fPackageElevated && (0 /*user*/ == g_iAssignmentType))
	{
		wsprintf(szSIDName, TEXT("%s%s"), szUserSID, szManagedText);
		OutputString(INSTALLMESSAGE_INFO, TEXT("Product is per-user managed.\r\n"));
	}
	else
	{
		lstrcpy(szSIDName, szUserSID);
	}

	lRes = W32::RegSetValueEx(hProductLocalPackagesW,
									  szSIDName, 
									  0,
									  REG_SZ,
									  (const BYTE*)(TCHAR*)rgchTempFilePath,
									  (lstrlen(rgchTempFilePath)+1) * sizeof(TCHAR));

	return lRes;

}

DWORD ResolveSourcePackagePath(HINSTANCE hMsiLib, const TCHAR* szProductCode,
							   CAPITempBufferRef<TCHAR>& rgchSourcePackageFullPath)
{
	// attempt to resolve the path for this user/product's source .msi package

	// the sourcepath is determined by calling MsiOpenProduct, then MsiDoAction(ResolveSource)
	// the packagename is retrieved with MsiGetProductInfo
	// the packagecode is then verified ???????

	// cannot be run from inside a custom action
	if(!hMsiLib || g_hInstall)
	{
		return ERROR_INSTALL_FAILURE;
	}

	PFnMsiSetInternalUI pfnMsiSetInternalUI;
	pfnMsiSetInternalUI = (PFnMsiSetInternalUI) W32::GetProcAddress(hMsiLib, MSIAPI_MSISETINTERNALUI);

	PFnMsiOpenProduct pfnMsiOpenProduct;
	pfnMsiOpenProduct = (PFnMsiOpenProduct) W32::GetProcAddress(hMsiLib, MSIAPI_MSIOPENPRODUCT);

	PFnMsiDoAction pfnMsiDoAction;
	pfnMsiDoAction = (PFnMsiDoAction) W32::GetProcAddress(hMsiLib, MSIAPI_MSIDOACTION);

	if (!g_pfnMsiGetProperty)
	g_pfnMsiGetProperty = (PFnMsiGetProperty) W32::GetProcAddress(hMsiLib, MSIAPI_MSIGETPROPERTY);

	if(!pfnMsiSetInternalUI ||
	   !pfnMsiOpenProduct ||
	   !pfnMsiDoAction ||
	   !g_pfnMsiGetProperty ||
	   !g_pfnMsiCloseHandle)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot get entry points from MSI.DLL.\r\n"));
		return ERROR_INSTALL_FAILURE; 
	}
		
	
	MSIHANDLE hProduct = 0;
	CAPITempBuffer<TCHAR, MAX_PATH> rgchSourceDir;
	CAPITempBuffer<TCHAR, MAX_PATH> rgchPackageName;

	UINT uiRes = ERROR_SUCCESS;
	
	INSTALLUILEVEL UILevel = (pfnMsiSetInternalUI)(INSTALLUILEVEL_NONE, 0);
	
	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = (pfnMsiOpenProduct)(szProductCode, &hProduct);
	}
	else
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot open product '%s'.\r\n"), szProductCode);
	}

	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = (pfnMsiDoAction)(hProduct, TEXT("CostInitialize"));
	}

	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = (pfnMsiDoAction)(hProduct, TEXT("ResolveSource"));
	}

	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = MyMsiGetProperty(g_pfnMsiGetProperty, hProduct, TEXT("SourceDir"), rgchSourceDir);
	}

	if(uiRes == ERROR_SUCCESS)
	{
		uiRes = MyMsiGetProductInfo(g_pfnMsiGetProductInfo, szProductCode,
											 TEXT("PackageName") /* no INSTALLPROPERTY_PACKAGENAME in 1.2*/, rgchPackageName);
	}

	if(uiRes == ERROR_SUCCESS)
	{
		int cchSourceDir = lstrlen(rgchSourceDir);
		int cchPackageName = lstrlen(rgchPackageName);

		int cchSourcePackageFullPath = cchSourceDir + cchPackageName + 2;

		if(rgchSourcePackageFullPath.GetSize() < cchSourcePackageFullPath)
			rgchSourcePackageFullPath.SetSize(cchSourcePackageFullPath);

		bool fURL = IsURL(rgchSourceDir);
		TCHAR* szSeparator = (fURL) ? TEXT("/") : TEXT("\\");

		lstrcpy(rgchSourcePackageFullPath, rgchSourceDir);
		if ((!cchSourceDir) || ((*szSeparator) != rgchSourcePackageFullPath[cchSourceDir-1]))
		{
			lstrcpy(&(rgchSourcePackageFullPath[cchSourceDir]), szSeparator);
			cchSourceDir++;
		}
		lstrcpy(&(rgchSourcePackageFullPath[cchSourceDir]), rgchPackageName);
	}

	if(hProduct)
	{
		(g_pfnMsiCloseHandle)(hProduct);
	}

	if(uiRes == ERROR_SUCCESS)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s'\r\n\tSourceDir: '%s'\r\n\tPackageName: '%s'\r\n"),
					szProductCode, (const TCHAR*) rgchSourceDir, (const TCHAR*) rgchPackageName);
	}
	
	(pfnMsiSetInternalUI)(UILevel, 0);

	return uiRes;

}

bool LoadAndCheckMsi(DWORD &dwResult)
// return false if nothing more to do.
// ERROR_SUCCESS == dwResult indicates "success or nothing to do."
{
	dwResult = ERROR_INSTALL_FAILURE;

	if(!g_hLib)
	{
		g_hLib = LoadLibrary(MSI_DLL);
		if (!g_hLib)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Unable to load %s. Migration cannot be performed. Exiting..."), MSI_DLL);
			MsiError(INSTALLMESSAGE_ERROR, 1708 /*install failed*/);
			return false;
		}
	}

	// Specification step 1: if msi.dll is less than version 1.1, don't perform migration
	PFnDllGetVersion pfnDllGetVersion;
	pfnDllGetVersion = (PFnDllGetVersion) W32::GetProcAddress(g_hLib,	MSIAPI_DLLGETVERSION);

	DLLVERSIONINFO verinfo;
	memset(&verinfo,0,sizeof(verinfo));
	verinfo.cbSize = sizeof(DLLVERSIONINFO);

	HRESULT hRes = (pfnDllGetVersion)(&verinfo);

	if(hRes != NOERROR)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Failed to determine version of '%s'.  '%s' call failed with error '0x%X'\r\n"),
				 MSI_DLL, MSIAPI_DLLGETVERSION, hRes);
		MsiError(INSTALLMESSAGE_ERROR, 1708 /*install failed*/);
		return false;
	}

	DebugOutputString(INSTALLMESSAGE_INFO, TEXT("Loaded '%s', version %d.%d.%d\r\n"),
			 MSI_DLL, verinfo.dwMajorVersion, verinfo.dwMinorVersion, verinfo.dwBuildNumber);

	if(verinfo.dwMajorVersion < 1 || (verinfo.dwMajorVersion == 1 && verinfo.dwMinorVersion < 10))
	{
		dwResult = ERROR_SUCCESS;
		OutputString(INSTALLMESSAGE_INFO, TEXT("%s version 1.10 or greater required to perform migration.  Exiting..."), MSI_DLL);
		return false;
	}

	// Specification step 3: if on Win9X, do nothing
	if(g_fWin9X)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("1.0 cached package migration not necessary on Win9X.  Exiting...\r\n"));
		dwResult = ERROR_SUCCESS;
		return false;
	}

	return true;
}


DWORD Migrate10CachedPackages(const TCHAR* szProductCode, const TCHAR* szTargetUser, const TCHAR* szAlternativePackage, const migEnum migOptions)
{
	// TargetUser values:  blank - means current user
	//                     machine
	//                     user name

	DWORD dwResult = ERROR_SUCCESS;
	if (!LoadAndCheckMsi(dwResult))
	{
		return dwResult;
	}

	// Specification step 2: if msi.dll contains migration api, call it.  this must be first because we can't assume
	//         what work should be done (for example: we can't assume this migration never needs
	//         to happen on Win9X)
	PFnMsiMigrate10CachedPackages pfnMsiMigrate10CachedPackages;
	pfnMsiMigrate10CachedPackages = (PFnMsiMigrate10CachedPackages) W32::GetProcAddress(g_hLib,
																						MSIAPI_MSIMIGRATE10CACHEDPACKAGES);

	if(pfnMsiMigrate10CachedPackages)
	{
		return (pfnMsiMigrate10CachedPackages)(szProductCode, szTargetUser, szAlternativePackage, migOptions);
	}
	else
	{
		// else continue, older .msi, perform migration ourselves
		OutputString(INSTALLMESSAGE_INFO, TEXT("This version of %s does not have built-in migration support.\r\n\tMigration will be performed by this tool.\r\n"),
				MSI_DLL);
	}

	if (ERROR_SUCCESS != (g_pfnMsiIsProductElevated)(szProductCode, &g_fPackageElevated))
	{
		// don't trust the return value unless we get success back.
		// unknown product is the same as not being elevated.
		g_fPackageElevated = FALSE;
		OutputString(INSTALLMESSAGE_INFO, TEXT("Could not query elevation state for product.\r\n\tAssuming non-elevated.\r\n"));
	}
	else
	{
		// find out what kind of assignment type
		if (g_fPackageElevated)
		{
			TCHAR szValue[sizeof(DWORD)+1] = TEXT("");  // this should be just an integer.
			DWORD cchValue = sizeof(DWORD);
			if (ERROR_SUCCESS == (g_pfnMsiGetProductInfo)(szProductCode, INSTALLPROPERTY_ASSIGNMENTTYPE, szValue, &cchValue))
			{
				g_iAssignmentType = _ttoi(szValue);
				switch(g_iAssignmentType)
				{
					case AssignmentUser:
						OutputString(INSTALLMESSAGE_INFO, TEXT("Package is user assigned.\r\n"));
						break;
					case AssignmentMachine:
						OutputString(INSTALLMESSAGE_INFO, TEXT("Package is machine assigned.\r\n"));
						break;
					default:
						OutputString(INSTALLMESSAGE_INFO, TEXT("Package is elevated, but with an unknown assignment type.\r\n"));
						g_fPackageElevated = false;
						g_iAssignmentType = 0;
						break;
				}
			}
		}
		else
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Package is not elevated.\r\n"));
		}
	}

	bool fMachine     = false; // re-cache for machine.
	TCHAR szUserName[256] = TEXT("");
	TCHAR rgchSID[cchMaxSID] = TEXT("");

	if (g_fPackageElevated && (AssignmentMachine == g_iAssignmentType))
	{
		fMachine = true;
		wsprintf(szUserName, TEXT("machine"));

		if (szTargetUser && *szTargetUser && (0 != lstrcmpi(TEXT("machine"), szTargetUser)))
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Per-user migration not allowed for per-machine applications.\r\nExiting migration.\r\n"));
			return 1;
		}
		
		lstrcpy(rgchSID, szLocalSystemSID);
	}	

	if (!fMachine)
	{
		if (szTargetUser && (0 == lstrcmpi(TEXT("machine"), szTargetUser)))
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Per-machine migration not allowed for per-user applications.\r\nExiting migration.\r\n"));
			return 1;
		}

		char pbBinarySID[cbMaxSID] = "";
		if (ERROR_SUCCESS != GetUserStringSID(szTargetUser, rgchSID, pbBinarySID))
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Failed to obtain SID for '%s'.  Exiting...\r\n"), szUserName);
			MsiError(INSTALLMESSAGE_ERROR, 2910 /* cannot find SID */);
			return 1;
		}

		TCHAR szCurrentDomain[256];
		DWORD cchCurrentDomain = 256;
		SID_NAME_USE snu;
		if (szTargetUser && *szTargetUser)
		{
			lstrcpy(szUserName, szTargetUser);
		}
		else
		{
			TCHAR szUserPart[256] = TEXT("");
			DWORD cchUserPart = 256;

			BOOL fLookup = LookupAccountSid(NULL, pbBinarySID, szUserPart, &cchUserPart, szCurrentDomain, &cchCurrentDomain, &snu);
			wsprintf(szUserName, TEXT("%s\\%s"), szCurrentDomain, szUserPart);
		}	

	}
	OutputString(INSTALLMESSAGE_INFO, TEXT("Performing migration for:\r\n\tUser: '%s'\r\n\tUser SID: '%s'.\r\n"), szUserName, rgchSID);
	
	// munge the product code variants we'll need.
	TCHAR rgchPackedProductCode[cchGUIDPacked+1];
	if(!PackGUID(szProductCode, rgchPackedProductCode, ipgPacked))
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("User '%s': product code '%s' is invalid.\r\n"), szUserName, szProductCode);
		MsiError(INSTALLMESSAGE_ERROR, 1701 /* invalid product code */, szProductCode, 0);
		return 1;  //!! caller should continue if migrating ALL products, fail if only migrating this product
	}

	OutputString(INSTALLMESSAGE_INFO, TEXT("DEBUG: packed product code: '%s'.\r\n"),
				rgchPackedProductCode);

	// Specification step 4: find 1.0 and 1.1 cached package registration for this product/user
	//         if 1.1 cached package migration exists, do nothing

	// check 1.0 registration
	ChKey hUninstallKeyR = 0;
	TCHAR rgchUninstallKey[sizeof(szMsiLocalPackagesKey) + 1 + cchGUID + 1];
	CAPITempBuffer<TCHAR, MAX_PATH> rgch10RegisteredPackagePath;
	rgch10RegisteredPackagePath[0] = NULL;
	DWORD cch10RegisteredPackagePath = MAX_PATH;

	wsprintf(rgchUninstallKey, TEXT("%s\\%s"), szMsiUninstallProductsKey, szProductCode);
	LONG lRes = W32::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
										rgchUninstallKey,
										0,
										KEY_READ,
										&hUninstallKeyR);

	if (ERROR_SUCCESS == lRes)
	{
	
		// check for appropriate user entry
		// this routine does resizing automagically
		DWORD dwType = 0;
		lRes = MyRegQueryValueEx(hUninstallKeyR,
										 TEXT("LocalPackage"),
										 0,
										 &dwType,
										 rgch10RegisteredPackagePath,
										 &cch10RegisteredPackagePath);
		if (ERROR_SUCCESS == lRes)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Found old 1.0 cached package at: %s\r\n"), rgch10RegisteredPackagePath);
		}
		else
		{
			// nothing to do
			OutputString(INSTALLMESSAGE_INFO, TEXT("Found uninstall key, but no old 1.0 cached package registered.\r\n"));
		}
	}
	else
	{
		// nothing to do
		OutputString(INSTALLMESSAGE_INFO, TEXT("Could not find product registration for this package.\r\n\tNo migration necessary.\r\n"));
		return 0;
	}
	
	// check 1.1 registration
	TCHAR rgchLocalPackagesProductKey[sizeof(szMsiLocalPackagesKey) + 1 + cchGUIDPacked + 1];
	wsprintf(rgchLocalPackagesProductKey, TEXT("%s\\%s"), szMsiLocalPackagesKey, rgchPackedProductCode);

	ChKey hProductLocalPackagesR = 0;
	lRes = W32::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
								  rgchLocalPackagesProductKey,
								  0,
								  KEY_READ,
								  &hProductLocalPackagesR);

	if(lRes == ERROR_SUCCESS)
	{
		CAPITempBuffer<TCHAR, MAX_PATH> rgch11RegisteredPackagePath;
		DWORD cch11RegisteredPackagePath = MAX_PATH;

		// check for appropriate user entry
		// this routine does resizing automagically
		DWORD dwType = 0;

		{
			TCHAR szSIDName[cchMaxSID + sizeof(szManagedText) + 1] = TEXT("");
			if (g_fPackageElevated && (AssignmentUser == g_iAssignmentType))
			{
				wsprintf(szSIDName, TEXT("%s%s"), rgchSID, szManagedText);
				OutputString(INSTALLMESSAGE_INFO, TEXT("Product is per-user managed.\r\n"));
			}
			else
			{
				lstrcpy(szSIDName, rgchSID);
			}

			lRes = MyRegQueryValueEx(hProductLocalPackagesR,
											 szSIDName,
											 0,
											 &dwType,
											 rgch11RegisteredPackagePath,
											 &cch11RegisteredPackagePath);

		}

		if(lRes == ERROR_SUCCESS && dwType == REG_SZ)
		{
			// check if file exists, if not, treat as if package isn't cached
			DWORD dwAttrib = W32::GetFileAttributes(rgch11RegisteredPackagePath);
			if(dwAttrib != 0xFFFFFFFF)
			{
				// file exists
				OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s'\r\n\tCached package registered under new location, and does exist\r\n\t\t('%s').\r\n\tUser '%s': No migration necessary\r\n"),
							szProductCode,
							(const TCHAR*) rgch11RegisteredPackagePath,
							szUserName);
				return ERROR_SUCCESS;
			}
		}
	}

	// if we got here, cached package is either not registered in new location, or does not exist
	// either way, migration is necessary
	OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s', User '%s':\r\n\tCached package missing or not registered in new location.\r\n\tPerforming migration...\r\n"),
				szProductCode,
				szUserName);
	
	// Specification step 7: if "trust old packages" policy is set (or override is set), 
	// and old package exists, register old package
	// This is the most "preferable" step since everything is already on the machine. 

	int iTrustOldPackages = (migOptions & migMsiTrust10PackagePolicyOverride) ? 2 : 0;

	if (0 == iTrustOldPackages)
	{
		ChKey hPolicyKeyR = 0;
		lRes = W32::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
									  TEXT("Software\\Policies\\Microsoft\\Windows\\Installer"),
									  0,
									  KEY_READ,
									  &hPolicyKeyR);

		if (ERROR_SUCCESS != lRes)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Cannot open machine policy key.  Assuming policy not set.\r\n"));
		}
		else
		{
			DWORD dwType = 0;
			DWORD dwValue = 0;
			DWORD cbValue = sizeof(DWORD);

			lRes = W32::RegQueryValueEx(hPolicyKeyR,
									szMsiPolicyTrust10CachedPackages,
									NULL, 
									&dwType,
									(byte*) &dwValue,
									&cbValue);

			if ((ERROR_SUCCESS == lRes) &&
					(REG_DWORD == dwType) &&
					(0 < dwValue))
			{
				//!! Do we need to check the owner of the key to make sure we really trust it?
				if (1 == dwValue)
				{
					if (!g_fPackageElevated)
					{
						OutputString(INSTALLMESSAGE_INFO, TEXT("Policy: trust unmanaged 1.0 packages.\r\n"));
						iTrustOldPackages = 1;
					}
				}
				else if (2 == dwValue)
				{
					OutputString(INSTALLMESSAGE_INFO, TEXT("Policy: trust all old 1.0 packages.\r\n"));
					iTrustOldPackages = 2;
				}
				else
				{
					OutputString(INSTALLMESSAGE_INFO, TEXT("Unknown policy value for Trust10CachedPackages: '%d' - defaulting to untrusted.\r\n"), dwValue);
				}
			}
		}
	}

	DWORD dwRes = ERROR_SUCCESS;
	if (iTrustOldPackages && (!(szAlternativePackage && *szAlternativePackage)) && (*rgch10RegisteredPackagePath))
	{
		// try and find the old one - if available copy and register it.  Otherwise, we'll have to go
		// after other copies.

		if (migOptions & migMsiTrust10PackagePolicyOverride)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Command line settings allow trust of old packages.  Attemping to find one.\r\n"));
		}
		else
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Policy settings allow trust of old packages.  Attempting to find one.\r\n"));
		}

		OutputString(INSTALLMESSAGE_INFO, TEXT("Using 1.0 package to re-cache.\r\n"));
		dwRes = CopyAndRegisterPackage(rgchLocalPackagesProductKey, szProductCode, rgchSID, 
													(fMachine) ? NULL : szUserName, rgch10RegisteredPackagePath);
		if (ERROR_SUCCESS != dwRes)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Failed to migrate from trusted 1.0 cached package.  Trying other options.\r\n\tPackage: '%s'\r\n\tTrying other methods.\r\n"), rgch10RegisteredPackagePath);
		}
		else 
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Successfully re-cached from trusted old package.\r\n"));
			return ERROR_SUCCESS;
		}
	}

	// Specification step 6: if package path passed on cmd line, copy and register that package
	if(szAlternativePackage && *szAlternativePackage)
	{
		// if running as local system *and* the package path is on the network, just register the path.
		// if someplace accessible, copy it in.
		dwRes = CopyAndRegisterPackage(rgchLocalPackagesProductKey, szProductCode, rgchSID, 
													(fMachine) ? NULL : szUserName, szAlternativePackage);

		if(ERROR_SUCCESS == dwRes)
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s', User '%s':\r\n\tcached alternative package '%s'\r\n\tMigration successful\r\n"),
						szProductCode, szUserName, szAlternativePackage);
			return ERROR_SUCCESS;
		}
		else
		{
			OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s', User '%s':\r\n\tcan not be cached from %s.\r\n\tRerun the migration tool with either a new source,\r\n\tor no source specified to automatically locate one.\r\n"),
						szProductCode, szUserName, szAlternativePackage);
			MsiError(INSTALLMESSAGE_ERROR, 1906 /*failed to cache DB*/, szAlternativePackage, 0);
			return 1;
		}
		
	}

	// Specification step 5: resolve source for this product in a non-obtrusive way
	//         if source is available, copy and register package
	//         This is the last resort, and the most expensive.

	CAPITempBuffer<TCHAR, MAX_PATH> rgchSourcePackagePath;
	rgchSourcePackagePath[0] = 0;

	// don't do this from within a custom action.
	if(!g_hInstall)
	{
		// it is redundant to this for the current user - if we could resolve the source
		// path, they wouldn't need to migrate.
		dwRes = ResolveSourcePackagePath(g_hLib, szProductCode, rgchSourcePackagePath);

		if(ERROR_SUCCESS == dwRes)
		{
			dwRes = CopyAndRegisterPackage(rgchLocalPackagesProductKey, szProductCode, rgchSID, 
														(fMachine) ? NULL : szUserName, rgchSourcePackagePath);
		
			if(ERROR_SUCCESS == dwRes)
			{
				OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s'\r\n\tUser '%s':\r\n\tCached source package '%s'\r\n\tMigration successful.\r\n\t"),
							szProductCode, szUserName, (const TCHAR*) rgchSourcePackagePath);
				return ERROR_SUCCESS;
			}
		}
		else
		{
				OutputString(INSTALLMESSAGE_INFO, TEXT("Product '%s'\r\n\tUser '%s':\r\n\tCannot locate source.  Error: 0x%x.\r\n\tMigration failed.\r\n\t"),
							szProductCode, szUserName, dwRes);
				MsiError(INSTALLMESSAGE_ERROR, 1906, szProductCode /* no valid source*/, ERROR_FILE_NOT_FOUND);
		}

		// nothing else to try now.
	}


	OutputString(INSTALLMESSAGE_INFO, TEXT("Could not migrate product.\r\n"));
	MsiError(INSTALLMESSAGE_ERROR, 1906, szProductCode /* no valid source*/, ERROR_FILE_NOT_FOUND);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimig\migutil.cpp ===
#include "_msimig.h"
#include "urlmon.h"
#include "wininet.h"
//#include "..\..\inc\vertrust.h"

//____________________________________________________________________________
//
// GUID compression routines
//
//   A SQUID (SQuished UID) is a compacted form of a GUID that takes
//   only 20 characters instead of the usual 38. Only standard ASCII characters
//   are used, to allow use as registry keys. The following are never used:
//     (space)
//     (0x7F)
//     :  (colon, used as delimeter by shell for shortcut information
//     ;  (semicolon)
//     \  (illegal for use in registry key)
//     /  (forward slash)
//     "  (double quote)
//     #  (illegal for registry value as first character)
//     >  (greater than, output redirector)
//     <  (less than, input redirector)
//     |  (pipe)
//____________________________________________________________________________

// GUID <--> SQUID transform helper buffers
const unsigned char rgEncodeSQUID[85+1] = "!$%&'()*+,-.0123456789=?@"
										  "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "[]^_`"
										  "abcdefghijklmnopqrstuvwxyz" "{}~";

const unsigned char rgDecodeSQUID[95] =
{  0,85,85,1,2,3,4,5,6,7,8,9,10,11,85,12,13,14,15,16,17,18,19,20,21,85,85,85,22,85,23,24,
// !  "  # $ % & ' ( ) * + ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  @
  25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,85,52,53,54,55,
// A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `
  56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,85,83,84,85};
// a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^ 0x7F

const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
									   21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 

const unsigned char rgOrderDash[4] = {9, 14, 19, 24};

bool PackGUID(const TCHAR* szGUID, TCHAR* szSQUID, ipgEnum ipg)
{ 
	int cchTemp = 0;
	while (cchTemp < cchGUID)		// check if string is atleast cchGUID chars long,
		if (!(szGUID[cchTemp++]))		// can't use lstrlen as string doesn't HAVE to be null-terminated.
			return false;

	if (szGUID[0] != '{' || szGUID[cchGUID-1] != '}')
		return false;
	const unsigned char* pch = rgOrderGUID;
	switch (ipg)
	{
	case ipgFull:
		lstrcpyn(szSQUID, szGUID, cchGUID+1);
		return true;
	case ipgPacked:
		while (pch < rgOrderGUID + sizeof(rgOrderGUID))
			*szSQUID++ = szGUID[*pch++];
		*szSQUID = 0;
		return true;
	case ipgCompressed:
	{
		int cl = 4;
		while (cl--)
		{
			unsigned int iTotal = 0;
			int cch = 8;  // 8 hex chars to 32-bit word
			while (cch--)
			{
				unsigned int ch = szGUID[pch[cch]] - '0'; // go from low order to high
				if (ch > 9)  // hex char (or error)
				{
					ch = (ch - 7) & ~0x20;
					if (ch > 15)
						return false;
				}
				iTotal = iTotal * 16 + ch;
			}
			pch += 8;
			cch = 5;  // 32-bit char to 5 text chars
			while (cch--)
			{
				*szSQUID++ = rgEncodeSQUID[iTotal%85];
				iTotal /= 85;
			}
		}
		*szSQUID = 0;  // null terminate
		return true;
	}
	default:
		return false;
	} // end switch
}

bool UnpackGUID(const TCHAR* szSQUID, TCHAR* szGUID, ipgEnum ipg)
{ 
	const unsigned char* pch;
	switch (ipg)
	{
	case ipgFull:
		lstrcpyn(szGUID, szSQUID, cchGUID+1);
		return true;
	case ipgPacked:
	{
		pch = rgOrderGUID;
		while (pch < rgOrderGUID + sizeof(rgOrderGUID))
			if (*szSQUID)
				szGUID[*pch++] = *szSQUID++;
			else              // unexpected end of string
				return false;
		break;
	}
	case ipgCompressed:
	{
		pch = rgOrderGUID;
#ifdef DEBUG //!! should not be here for performance reasons, onus is on caller to insure buffer is sized properly
		int cchTemp = 0;
		while (cchTemp < cchGUIDCompressed)     // check if string is atleast cchGUIDCompressed chars long,
			if (!(szSQUID[cchTemp++]))          // can't use lstrlen as string doesn't HAVE to be null-terminated.
				return false;
#endif
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return false;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				szGUID[*pch++] = (TCHAR)ch;
				iTotal >>= 4;
			}
		}
		break;
	}
	case ipgPartial:
	{
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return false;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				*szGUID++ = (TCHAR)ch;
				iTotal >>= 4;
			}
		}
		*szGUID = 0;
		return true;
	}
	default:
		return false;
	} // end switch
	pch = rgOrderDash;
	while (pch < rgOrderDash + sizeof(rgOrderDash))
		szGUID[*pch++] = '-';
	szGUID[0]         = '{';
	szGUID[cchGUID-1] = '}';
	szGUID[cchGUID]   = 0;
	return true;
}


DWORD GetCurrentUserToken(HANDLE &hToken)
/*----------------------------------------------------------------------------
Returns the user's thread token if possible; otherwise obtains the user's
process token.
------------------------------------------------------------------------------*/
{
	DWORD dwRes = ERROR_SUCCESS;

	if (!W32::OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
	{
		// if the thread has no access token then use the process's access token
		dwRes = GetLastError();
		if (ERROR_NO_TOKEN == dwRes)
		{
			dwRes = ERROR_SUCCESS;
			if (!W32::OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
				dwRes = GetLastError();
		}
	}
	return dwRes;
}


#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

void GetStringSID(PISID pSID, TCHAR* szSID)
// Converts a binary SID into its string form (S-n-...). 
// szSID should be of length cchMaxSID
{
	TCHAR Buffer[cchMaxSID];
	
   wsprintf(Buffer, TEXT("S-%u-"), (USHORT)pSID->Revision);

	lstrcpy(szSID, Buffer);

	if (  (pSID->IdentifierAuthority.Value[0] != 0)  ||
			(pSID->IdentifierAuthority.Value[1] != 0)     )
	{
		wsprintf(Buffer, TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
					 (USHORT)pSID->IdentifierAuthority.Value[0],
					 (USHORT)pSID->IdentifierAuthority.Value[1],
                    (USHORT)pSID->IdentifierAuthority.Value[2],
                    (USHORT)pSID->IdentifierAuthority.Value[3],
                    (USHORT)pSID->IdentifierAuthority.Value[4],
                    (USHORT)pSID->IdentifierAuthority.Value[5] );
		lstrcat(szSID, Buffer);

    } else {

        ULONG Tmp = (ULONG)pSID->IdentifierAuthority.Value[5]          +
              (ULONG)(pSID->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(pSID->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(pSID->IdentifierAuthority.Value[2] << 24);
        wsprintf(Buffer, TEXT("%lu"), Tmp);
		lstrcat(szSID, Buffer);
    }

    for (int i=0;i<pSID->SubAuthorityCount ;i++ ) {
        wsprintf(Buffer, TEXT("-%lu"), pSID->SubAuthority[i]);
		lstrcat(szSID, Buffer);
    }
}

DWORD GetCurrentUserBinarySID(char* rgSID)
{
	HANDLE hToken;
	DWORD dwRes = GetCurrentUserToken(hToken);
	if(dwRes != ERROR_SUCCESS)
		return dwRes;

	UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
	ULONG ReturnLength;

	BOOL f = W32::GetTokenInformation(hToken,
												TokenUser,
												TokenInformation,
												sizeof(TokenInformation),
												&ReturnLength);

	if(f == FALSE)
	{
		return GetLastError();
	}

	PISID iSid = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;
	if (W32::CopySid(cbMaxSID, rgSID, iSid))
		return ERROR_SUCCESS;
	else
		return GetLastError();
}

DWORD GetOtherUserBinarySID(const TCHAR* szUserName, char* rgSID)
{
	TCHAR        szDomain[MAX_PATH+1];
	DWORD        cbDomain = MAX_PATH; 

	DWORD dwSID = cbMaxSID;
	SID_NAME_USE snu;

	BOOL fRes = W32::LookupAccountName(0,
												  szUserName,
												  rgSID,
												  &dwSID,
												  szDomain,
												  &cbDomain,
												  &snu);

	if(fRes == FALSE)
		return GetLastError();
	else
		return ERROR_SUCCESS;
}


DWORD GetUserBinarySID(const TCHAR* szUserName, char* rgSID)
// get the (binary form of the) SID for the specified user
{
	if(szUserName && *szUserName)
	{
		return GetOtherUserBinarySID(szUserName, rgSID);
	}
	else
	{
		return GetCurrentUserBinarySID(rgSID);
	}
}

DWORD GetUserStringSID(const TCHAR* szUser, TCHAR* szSID, char* pbBinarySID)
// get string form of SID for current user
{
	if(g_fWin9X)
	{
		_tprintf(TEXT("GetUserSID called on Win9X\r\n"));
		return ERROR_INVALID_FUNCTION;
	}

	char rgchSID[cbMaxSID];
	char* pchSID = (pbBinarySID) ? pbBinarySID : rgchSID;

	DWORD dwRet = GetUserBinarySID(szUser, pchSID);
	if(dwRet == ERROR_SUCCESS)
	{
		GetStringSID((PISID)pchSID, szSID);
	}
	return dwRet;
}


LONG MyRegQueryValueEx(HKEY hKey,
							  const TCHAR* lpValueName,
							  LPDWORD /*lpReserved*/,
							  LPDWORD lpType,
							  CAPITempBufferRef<TCHAR>& rgchBuf,
							  LPDWORD lpcbBuf)
{
	DWORD cbBuf = rgchBuf.GetSize() * sizeof(TCHAR);
	LONG lResult = RegQueryValueEx(hKey, lpValueName, 0,
		lpType, (LPBYTE)&rgchBuf[0], &cbBuf);

	if (ERROR_MORE_DATA == lResult)
	{
		rgchBuf.SetSize(cbBuf/sizeof(TCHAR));
		lResult = RegQueryValueEx(hKey, lpValueName, 0,
			lpType, (LPBYTE)&rgchBuf[0], &cbBuf);
	}

	if (lpcbBuf)
		*lpcbBuf = cbBuf;

	return lResult;
}


UINT MyMsiGetProperty(PFnMsiGetProperty pfn,
							 MSIHANDLE hProduct,
							 const TCHAR* szProperty,
							 CAPITempBufferRef<TCHAR>& rgchBuffer)
{
	DWORD cchBuf = rgchBuffer.GetSize();
	
	UINT uiRes = (pfn)(hProduct, szProperty, rgchBuffer, &cchBuf);

	if(uiRes == ERROR_MORE_DATA)
	{
		rgchBuffer.Resize(cchBuf);
		uiRes = (pfn)(hProduct, szProperty, rgchBuffer, &cchBuf);
	}

	return uiRes;
}


UINT MyMsiGetProductInfo(PFnMsiGetProductInfo pfn,
								 const TCHAR* szProductCode,
								 const TCHAR* szProperty,
								 CAPITempBufferRef<TCHAR>& rgchBuffer)
{
	DWORD cchBuf = rgchBuffer.GetSize();
	
	UINT uiRes = (pfn)(szProductCode, szProperty, rgchBuffer, &cchBuf);

	if(uiRes == ERROR_MORE_DATA)
	{
		rgchBuffer.Resize(cchBuf);
		uiRes = (pfn)(szProductCode, szProperty, rgchBuffer, &cchBuf);
	}

	return uiRes;
}

bool IsURL(const TCHAR* szPath)
{
	bool bResult = false;		// assume it's not a URL

	// if it starts with http:
	if (0 == _tcsnicmp(szPath, TEXT("http:"), 5))
		bResult = true;
	else if (0 == _tcsnicmp(szPath, TEXT("ftp:"), 4))
		bResult = true;
	else if (0 == _tcsnicmp(szPath, TEXT("file:"), 5))
		bResult = true;
	return bResult;
}

TCHAR ExtractDriveLetter(const TCHAR *szPath)
/*-------------------------------------------------------------------------
Given a path returns the valid drive letter if one exists in the path, 
otherwise returns 0.
---------------------------------------------------------------------------*/
{
	TCHAR *pchColon, chDrive;

	pchColon = CharNext(szPath);
	if (*pchColon != ':')
		return 0;

	chDrive = *szPath;
	if ( (chDrive >= 'A') && (chDrive <= 'Z') )
		0;
	else if ( (chDrive >= 'a') && (chDrive <= 'z'))
		chDrive = char(chDrive + ('A' - 'a'));
	else
		chDrive = 0;
	
	return chDrive;
}

bool IsNetworkPath(const TCHAR* szPath)
{
	TCHAR chDrive;
	unsigned int uiResult;
	
	// URL
	if (IsURL(szPath))
		return true;

	// UNC
	if (0 == _tcsncmp(szPath, TEXT("\\"), 2))
		return true;

	// Drive letter, that might be mapped
	if ((chDrive = ExtractDriveLetter(szPath)) != 0)    // Check for DRIVE:[\PATH]
	{
		TCHAR szPath[] = TEXT("A:\\");

		szPath[0] = chDrive;
		
		// first, try without impersonating
		uiResult = W32::GetDriveType(szPath);
		if (uiResult == DRIVE_UNKNOWN || uiResult == DRIVE_NO_ROOT_DIR)
		{
			// failure, just return remote
			return true;
		}
		return (DRIVE_REMOTE == uiResult) ? true : false;
	}

	// something we don't recognize at all - assume it's a wacky network type.  
	return true;
}

bool FFileExists(const TCHAR* szFullFilePath, DWORD& dwError)
{
	bool fExists = false;
	dwError = 0;

	DWORD iAttribs = W32::GetFileAttributes(szFullFilePath);
	if ((iAttribs == 0xFFFFFFFF))
	{
		dwError = W32::GetLastError();
		if (ERROR_FILE_NOT_FOUND == dwError)
		{
			dwError = 0;
		}
		// failure - don't know if file exists or not.  caller should check dwError
	}
	else if (!(iAttribs & FILE_ATTRIBUTE_DIRECTORY))
	{
		fExists = true;
	}

	return fExists;
}



UINT MyGetTempFileName(const TCHAR* szDir, const TCHAR* szPrefix, const TCHAR* szExtension,
							  CAPITempBufferRef<TCHAR>& rgchTempFilePath)
{
	// it is assumed szDir does not end with a '\\'
	
	int cchDir = lstrlen(szDir);
	
	int cchTempFilePath = cchDir + 15; // 13 for filename, 1 for '\\', 1 for NULL
	if(rgchTempFilePath.GetSize() < cchTempFilePath)
		rgchTempFilePath.SetSize(cchTempFilePath);

	// need a different extension - create our own name
	TCHAR rgchExtension[5] = {TEXT(".tmp")};

	if(szExtension && *szExtension)
		lstrcpyn(rgchExtension+1, szExtension, 4 /* 3 + null */);

	int cchPrefix = szPrefix ? lstrlen(szPrefix) : 0;
	
	if(cchPrefix > 8)
		cchPrefix = 8; // use only first 8 chars of prefix
	
	int cDigits = 8-cchPrefix; // number of hex digits to use in file name

	static bool fInitialized = false;
	static unsigned int uiUniqueStart;

	// Might be a chance for two threads to get in here, we're not going to be worried
	// about that. It would get intialized twice
	if (!fInitialized)
	{
		uiUniqueStart = W32::GetTickCount();
		fInitialized = true;
	}
	unsigned int uiUniqueId = uiUniqueStart++;
	
	if(cchPrefix)
		uiUniqueId &= ((1 << 4*cDigits) - 1);
	
	unsigned int cPerms = cDigits == 8 ? ~0 : (1 << 4*cDigits) -1; // number of possible file names to try ( minus 1 )
	
	bool fCreatedFile = false;
	DWORD dwError = ERROR_SUCCESS;

	for(unsigned int i = 0; i <= cPerms; i++)
	{
		TCHAR rgchFileName [9];
		if(szPrefix)
			lstrcpyn(rgchFileName, szPrefix, cchPrefix);
		if(cDigits)
			wsprintf(rgchFileName+cchPrefix,TEXT("%x"),uiUniqueId);

		lstrcpy(rgchTempFilePath, szDir);
		rgchTempFilePath[cchDir] = '\\';
		lstrcpy(&(rgchTempFilePath[cchDir+1]), rgchFileName);
		lstrcat(&(rgchTempFilePath[cchDir+1+lstrlen(rgchFileName)]), rgchExtension);

		DWORD dwTemp = ERROR_SUCCESS;
		if((FFileExists(rgchTempFilePath, dwTemp) == false) && dwTemp == ERROR_SUCCESS)
		{
			// found a name that isn't already taken - create file as a placeholder for name
			HANDLE hFile = W32::CreateFile(rgchTempFilePath, GENERIC_WRITE, FILE_SHARE_READ, 0,
													  CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);

			if(hFile == INVALID_HANDLE_VALUE)
				dwError = GetLastError();
			else
			{
				dwError = 0;
				fCreatedFile = true;
			}

			CloseHandle(hFile);

			if(dwError != ERROR_FILE_EXISTS) // could have failed because file was created under us
				break; // if file creation failed for any other reason,
						 // assume we can't create any file in this folder
		}

		// increment number portion of name - if it currently equals cPerms, it is time to
		// wrap number around to 0
		uiUniqueStart++;
		if(uiUniqueId == cPerms)
			uiUniqueId = 0;
		else
			uiUniqueId++;
	}

	if(fCreatedFile == false)
	{
		if(dwError == 0)
			dwError = ERROR_FILE_EXISTS; // default error - only used if we exhausted all file names
												 // and looped to the end
	}
	else
	{
		dwError = ERROR_SUCCESS;
	}

	return dwError;
}
int MsiError(INSTALLMESSAGE eMessageType, int iError)
{
	return MsiError(eMessageType, iError, NULL, 0);
}

int MsiError(INSTALLMESSAGE eMessageType, int iError, const TCHAR* szString, int iInt)
{
	int iStatus = 0;
	if (g_hInstall && g_recOutput)
	{			
		(g_pfnMsiRecordClearData)();
		(g_pfnMsiRecordSetString)(g_recOutput, 0, NULL);
		(g_pfnMsiRecordSetInteger)(g_recOutput, 1, iError);
		if (szString)
		{
			(g_pfnMsiRecordSetString)(g_recOutput, 2, szString);
			(g_pfnMsiRecordSetInteger)(g_recOutput, 3, iInt);
		}
		iStatus = (g_pfnMsiProcessMessage)(g_hInstall, eMessageType, g_recOutput);
	}

	return iStatus;

}

int OutputString(INSTALLMESSAGE eMessageType, const TCHAR *fmt, ...)
{
	int iStatus = 0;

	TCHAR szOutput[2048] = TEXT("");

	va_list va;
	va_start(va, fmt);
	
	if (!g_fQuiet)
	{
		_stprintf(szOutput, TEXT("MSIMIG: "));
		_vstprintf(szOutput+8, fmt, va);

		if (g_hInstall && g_recOutput)
		{
			(g_pfnMsiRecordSetString)(g_recOutput, 0, szOutput);
			iStatus = (g_pfnMsiProcessMessage)(g_hInstall, eMessageType, g_recOutput);
		}
		else
		{
		


			iStatus = _tprintf(szOutput);
		}
	}

	va_end(va);

	return iStatus;

}


DWORD GetUserSID(HANDLE hToken, char* rgSID)
// get the (binary form of the) SID for the user specified by hToken
{
	UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
	ULONG ReturnLength;

	BOOL f = W32::GetTokenInformation(hToken,
												TokenUser,
												TokenInformation,
												sizeof(TokenInformation),
												&ReturnLength);

	if(f == FALSE)
	{
		DWORD dwRet = GetLastError();
		OutputString(INSTALLMESSAGE_INFO, TEXT("GetTokenInformation failed with error %d"), dwRet);
		MsiError(INSTALLMESSAGE_ERROR, 1708 /* install failed*/);
		return dwRet;
	}

	PISID iSid = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;
	if (W32::CopySid(cbMaxSID, rgSID, iSid))
		return ERROR_SUCCESS;
	else
		return GetLastError();
}

bool IsLocalSystemToken(HANDLE hToken)
{

	TCHAR szCurrentStringSID[cchMaxSID];
	char  rgchCurrentSID[cbMaxSID];
	if ((hToken == 0) || (ERROR_SUCCESS != GetUserSID(hToken, rgchCurrentSID)))
		return false;

	GetStringSID((PISID)rgchCurrentSID, szCurrentStringSID);
	return 0 == lstrcmp(szLocalSystemSID, szCurrentStringSID);
}


bool RunningAsLocalSystem()
{
	static int iRet = -1;

	if(iRet != -1)
		return (iRet != 0);
	{
		iRet = 0;
		HANDLE hTokenImpersonate = INVALID_HANDLE_VALUE;
		if(W32::OpenThreadToken(W32::GetCurrentThread(), TOKEN_IMPERSONATE , TRUE, &hTokenImpersonate))
			W32::SetThreadToken(0, 0); // stop impersonation

		HANDLE hToken;

		if (W32::OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
		{
			bool fIsLocalSystem = IsLocalSystemToken(hToken);
			W32::CloseHandle(hToken);

			if (fIsLocalSystem)
				iRet = 1;
		}
		if(hTokenImpersonate != INVALID_HANDLE_VALUE)
		{
			W32::SetThreadToken(0, hTokenImpersonate); // start impersonation
			W32::CloseHandle(hTokenImpersonate);
		}
		return (iRet != 0);
	}
}

BOOL MsiCanonicalizeUrl(
	LPCTSTR lpszUrl, 
	OUT LPTSTR lpszBuffer, 
	IN OUT LPDWORD lpdwBufferLength, 
	IN DWORD dwFlags)
{
	if (IsURL(lpszUrl))
	{
		int cchUrl = lstrlen(lpszUrl);

		// leave room for trailing null
		if ((cchUrl+1) * sizeof(TCHAR) > *lpdwBufferLength)
		{
			W32::SetLastError(ERROR_INSUFFICIENT_BUFFER);
			*lpdwBufferLength = ((cchUrl+1) * sizeof(TCHAR));
			return FALSE;
		}

		// don't include NULL in outbound length
		*lpdwBufferLength = cchUrl*sizeof(TCHAR);
		memcpy(lpszBuffer, lpszUrl, *lpdwBufferLength);

		// null terminate the string
		lpszBuffer[cchUrl] = 0; 
			 
		// swap all the back slashes to forward slashes.
		TCHAR* pchOutbound = lpszBuffer;
		while (*pchOutbound)
		{
			if (TCHAR('\\') == *pchOutbound)
				*pchOutbound = TCHAR('/');
			pchOutbound++;
		}

		W32::SetLastError(0);
		return TRUE;
	}
	else
	{
		W32::SetLastError(ERROR_INTERNET_INVALID_URL);
		return FALSE;
	}
}

DWORD DownloadUrlFile(const TCHAR* szPotentialURL, CAPITempBufferRef<TCHAR>& rgchPackagePath, bool& fURL)
{
	DWORD iStat = ERROR_SUCCESS;
	CAPITempBuffer<TCHAR, MAX_PATH + 1> rgchURL;
	DWORD cchURL = MAX_PATH + 1;
	fURL = true;

	if (!MsiCanonicalizeUrl(szPotentialURL, rgchURL, &cchURL, NULL))
	{
		DWORD dwLastError = W32::GetLastError();
		if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
		{
			rgchURL.SetSize(cchURL);
			if (MsiCanonicalizeUrl(szPotentialURL, rgchURL, &cchURL, NULL))
				dwLastError = 0;
		}
		else
		{
			fURL = false;
		}
	}

	if (fURL)
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Package path is a URL. Downloading package.\r\n"));
		// Cache the database locally, and run from that.

		// The returned path is a local path.  Max path should adequately cover it.
		static HINSTANCE hURLMONLib = W32::LoadLibrary(TEXT("urlmon.dll"));

		if (!hURLMONLib) 
			return E_FAIL;

		// URLMON occasionally hangs during FreeLibrary, so make it static
		// and not unload it.

		static PFnURLDownloadToCacheFile pfnURLDownloadToCacheFile = 
			(PFnURLDownloadToCacheFile) W32::GetProcAddress(hURLMONLib, URLMONAPI_URLDownloadToCacheFile);
		if (!pfnURLDownloadToCacheFile)
			return E_FAIL;

		DWORD dwBufLength = rgchPackagePath.GetSize();

		HRESULT hResult = (pfnURLDownloadToCacheFile)(NULL, rgchURL, rgchPackagePath,  
																		 dwBufLength, 0, NULL);

		if (ERROR_SUCCESS != hResult)
		{
			rgchPackagePath[0] = NULL;

			if (E_ABORT == hResult)
				iStat = ERROR_INSTALL_USEREXIT;
			else
			{
				if (E_OUTOFMEMORY == hResult)
					W32::SetLastError(ERROR_INSUFFICIENT_BUFFER);
				iStat = ERROR_FILE_NOT_FOUND;
			}
		}
		
	}
	return iStat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimsg\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimig\sources.inc ===
TARGETNAME=MsiMig
!INCLUDE ..\..\..\MsiMake.inc

SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0


TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\OLE32.lib

USE_MSVCRT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimsg\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimsg\sources.inc ===
!INCLUDE ..\..\..\MsiMake.inc
TARGETNAME=
SOURCES=
TARGETTYPE=NOTARGET
NTTARGETFILE0=MsiMsgAll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimig\_msimig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       _msimig.h
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <tchar.h>  

// resource string ids
#define IDS_Usage               1

#ifndef RC_INVOKED    // start of source code

#include "buffer.h"
#include "msi.h"
#include <wininet.h>
#include <urlmon.h>

extern bool g_fWin9X;
extern bool g_fQuiet;
extern BOOL g_fPackageElevated;
extern int  g_iAssignmentType;

#define W32

#define MSI_DLL TEXT("msi.dll")
extern HINSTANCE g_hLib;
extern MSIHANDLE g_hInstall;
extern MSIHANDLE g_recOutput;

#define PID_REVNUMBER 9

#define URLMON_DLL TEXT("urlmon.dll")

#define szMsiPolicyKey   TEXT("Software\\Policies\\Microsoft\\Windows\\Installer")
#define szMsiPolicyTrust10CachedPackages  TEXT("Trust1.0CachedPackages")

#define szLocalSystemSID TEXT("S-1-5-18")

#define szManagedText TEXT("(Managed)")

typedef enum migEnum
{
	
	
	migQuiet                                 = 1 << 0,
	migMsiTrust10PackagePolicyOverride       = 1 << 1,
	migCustomActionUserPass                  = 1 << 2,
	migCustomActionSecurePass                = 1 << 3,
};

DWORD Migrate10CachedPackages(const TCHAR* szProductCode,
									  const TCHAR* szUser,
									  const TCHAR* szAlternativePackage,
									  const migEnum migOptions);


#ifndef DLLVER_PLATFORM_NT
typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT
typedef interface IBindStatusCallback IBindStatusCallback;
#endif

// assignment types - note that these do not follow iaaAppAssignment
enum eAppAssignment {
	AssignmentUser = 0,
	AssignmentMachine = 1
};

const int cchGUID                     = 38;
const int cchGUIDPacked               = 32;
const int cchGUIDCompressed           = 20;
const int cchMaxSID                   = 256;

enum ipgEnum
{
	ipgFull       = 0,  // no compression
	ipgPacked     = 1,  // remove punctuation and reorder low byte first
	ipgCompressed = 2,  // max text compression, can't use in reg keys or value names
	ipgPartial    = 3,  // partial translation, between ipgCompressed and ipgPacked
};

bool PackGUID(const TCHAR* szGUID, TCHAR* szSQUID, ipgEnum ipg);
bool UnpackGUID(const TCHAR* szSQUID, TCHAR* szGUID, ipgEnum ipg);


const int cbMaxSID                    = sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD);
DWORD GetUserStringSID(const TCHAR* szUser, TCHAR* szSID, char* pbBinarySID /*can be NULL*/);
bool RunningAsLocalSystem();


LONG MyRegQueryValueEx(HKEY hKey,
							  const TCHAR* lpValueName,
							  LPDWORD /*lpReserved*/,
							  LPDWORD lpType,
							  CAPITempBufferRef<TCHAR>& rgchBuf,
							  LPDWORD lpcbBuf);

#ifdef UNICODE
#define W_A "W"
#else
#define W_A "A"
#endif

#define MSIAPI_DLLGETVERSION     "DllGetVersion"
typedef UINT (__stdcall *PFnDllGetVersion)(DLLVERSIONINFO *pdvi);

#define MSIAPI_MSISETINTERNALUI  "MsiSetInternalUI"
typedef INSTALLUILEVEL (__stdcall *PFnMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND* phWnd);

#define MSIAPI_MSIOPENPRODUCT    "MsiOpenProduct" ## W_A
typedef UINT (__stdcall *PFnMsiOpenProduct)(const TCHAR* szProductCode, MSIHANDLE *phProduct);

#define MSIAPI_MSIDOACTION       "MsiDoAction" ## W_A
typedef UINT (__stdcall *PFnMsiDoAction)(MSIHANDLE hProduct, const TCHAR* szAction);

#define MSIAPI_MSIGETPROPERTY    "MsiGetProperty" ## W_A
typedef UINT (__stdcall *PFnMsiGetProperty)(MSIHANDLE hProduct,
														  const TCHAR* szProperty,
														  TCHAR* szValueBuf,
														  DWORD* pcchValueBuf);

#define MSIAPI_MSICLOSEHANDLE    "MsiCloseHandle"
typedef UINT (__stdcall *PFnMsiCloseHandle)(MSIHANDLE hProduct);

#define MSIAPI_MSICREATERECORD   "MsiCreateRecord"
typedef MSIHANDLE (__stdcall *PFnMsiCreateRecord)(unsigned int cParams);

#define MSIAPI_MSIRECORDSETSTRING   "MsiRecordSetString" ## W_A
typedef MSIHANDLE (__stdcall *PFnMsiRecordSetString)(MSIHANDLE hRecord, unsigned int iField, LPCTSTR szValue);

#define MSIAPI_MSIRECORDSETINTEGER  "MsiRecordSetInteger"
typedef MSIHANDLE (__stdcall *PFnMsiRecordSetInteger)(MSIHANDLE hRecord, unsigned int iField, int iValue);

#define MSIAPI_MSIRECORDCLEARDATA  "MsiRecordClearData"
typedef MSIHANDLE (__stdcall *PFnMsiRecordClearData)();


#define MSIAPI_MSIPROCESSMESSAGE "MsiProcessMessage"
typedef UINT (__stdcall *PFnMsiProcessMessage)(MSIHANDLE hInstall,
																INSTALLMESSAGE eMessageType, 
																MSIHANDLE hRecord);

#define MSIAPI_MSISOURCELISTADDSOURCE "MsiSourceListAddSource" ## W_A
typedef UINT (__stdcall *PFnMsiSourceListAddSource)(LPCTSTR szProduct,		// product code
																	LPCTSTR szUserName,		// user name or NULL
																	DWORD dwReserved,			// reserved, must be 0
																	LPCTSTR szSource);			// pointer

#define MSIAPI_MSIGETPRODUCTINFO "MsiGetProductInfo" ## W_A
typedef UINT (__stdcall *PFnMsiGetProductInfo)(LPCTSTR szProduct,	// product code
															LPCTSTR szProperty,  // product property
															LPTSTR lpValueBuf,   // buffer to return property value
															DWORD *pcchValueBuf);// buffer character count,

#define MSIAPI_MSIGETSUMMARYINFORMATION "MsiGetSummaryInformation" ## W_A
typedef UINT (__stdcall *PFnMsiGetSummaryInformation)(MSIHANDLE hDatabase,       // database handle
															  LPCTSTR szDatabasePath,    // path to database
															  UINT uiUpdateCount,        // maximum number of updated values, 0
																								  //  to open read-only
															  MSIHANDLE *phSummaryInfo);   // location to return summary information
																								  //  handle

#define MSIAPI_MSISUMMARYINFOGETPROPERTY "MsiSummaryInfoGetProperty" ## W_A
typedef UINT (__stdcall *PFnMsiSummaryInfoGetProperty)(MSIHANDLE hSummaryInfo,   // summary info handle
																		UINT uiProperty,          // property
																		UINT *puiDataType,        // property type
																		INT *piValue,             // value
																		FILETIME *pftValue,       // file time
																		LPCTSTR szValueBuf,       // value buffer
																		DWORD *pcchValueBuf);       // buffer size

// private APIs
#define MSIAPI_MSIISPRODUCTELEVATED "MsiIsProductElevated" ## W_A
typedef UINT (__stdcall *PFnMsiIsProductElevated)(LPCTSTR szProduct,		// product code
																	BOOL *pfElevated);

#define MSIAPI_MSIGETPRODUCTCODEFROMPACKAGECODE "MsiGetProductCodeFromPackageCode" ## W_A
typedef UINT (__stdcall *PFnMsiGetProductCodeFromPackageCode)(LPCTSTR szPackageCode, // package code
																LPTSTR szProductCode);  // a buffer of size 39 to recieve product code

#define MSIAPI_MSIMIGRATE10CACHEDPACKAGES    "Migrate10CachedPackages" ## W_A
typedef UINT (__stdcall *PFnMsiMigrate10CachedPackages)(const TCHAR* szProductCode,
														const TCHAR* szUser,
														const TCHAR* szAlternativePackage,
														const migEnum migOptions);


// external APIs
#define URLMONAPI_URLDownloadToCacheFile    "URLDownloadToCacheFile" ## W_A
typedef HRESULT (__stdcall *PFnURLDownloadToCacheFile)(LPUNKNOWN lpUnkcaller,
											 LPCTSTR szURL,
											 LPTSTR szFileName,
											 DWORD dwBufLength,
											 DWORD dwReserved,
											 IBindStatusCallback *pBSC);



extern PFnMsiCreateRecord                     g_pfnMsiCreateRecord;
extern PFnMsiProcessMessage                   g_pfnMsiProcessMessage;
extern PFnMsiRecordSetString                  g_pfnMsiRecordSetString;
extern PFnMsiRecordSetInteger                 g_pfnMsiRecordSetInteger;
extern PFnMsiRecordClearData                  g_pfnMsiRecordClearData;
extern PFnMsiCloseHandle                      g_pfnMsiCloseHandle;
extern PFnMsiGetProperty                      g_pfnMsiGetProperty;
extern PFnMsiSourceListAddSource              g_pfnMsiSourceListAddSource;
extern PFnMsiIsProductElevated                g_pfnMsiIsProductElevated;
extern PFnMsiGetProductInfo                   g_pfnMsiGetProductInfo;
extern PFnMsiGetProductCodeFromPackageCode    g_pfnMsiGetProductCodeFromPackageCode;
extern PFnMsiGetSummaryInformation            g_pfnMsiGetSummaryInformation;
extern PFnMsiSummaryInfoGetProperty           g_pfnMsiSummaryInfoGetProperty;

extern bool                                   g_fRunningAsLocalSystem;


UINT MyMsiGetProperty(PFnMsiGetProperty pfn,
							 MSIHANDLE hProduct,
							 const TCHAR* szProperty,
							 CAPITempBufferRef<TCHAR>& rgchBuffer);

UINT MyMsiGetProductInfo(PFnMsiGetProductInfo pfn,
								 const TCHAR* szProductCode,
								 const TCHAR* szProperty,
								 CAPITempBufferRef<TCHAR>& rgchBuffer);

bool IsURL(const TCHAR* szPath);
bool IsNetworkPath(const TCHAR* szPath);

DWORD DownloadUrlFile(const TCHAR* szPotentialURL, CAPITempBufferRef<TCHAR>& rgchPackagePath, bool& fURL);

UINT MyGetTempFileName(const TCHAR* szDir, const TCHAR* szPrefix, const TCHAR* szExtension,
							  CAPITempBufferRef<TCHAR>& rgchTempFilePath);

int OutputString(INSTALLMESSAGE eMessageType, const TCHAR *fmt, ...);

int MsiError(INSTALLMESSAGE eMessageType, int iError);
int MsiError(INSTALLMESSAGE eMessageType, int iError, const TCHAR* szString, int iInt);


#ifdef DEBUG
#define DebugOutputString OutputString
#else
#define DebugOutputString
#endif


#endif //RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimsp\msimsp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msimsp.h
//
//--------------------------------------------------------------------------

#include <windows.h>

// resource string ids
#define IDS_Usage               1
#define IDS_CreatePatchError    2
#define IDS_Success             3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimig\msimig.cpp ===
//LINKLIBS = shell32.lib msvcrt.lib
//#POSTBUILDSTEP = -1$(TOOLSBIN)\imagecfg.exe -h 1 $@ */

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       msimig.cpp
//
//--------------------------------------------------------------------------


#define WINDOWS_LEAN_AND_MEAN  // faster compile

#include "_msimig.h"

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

bool                      g_fWin9X                    = false;
bool                      g_fQuiet                    = false;
bool                      g_fRunningAsLocalSystem     = false; // can only be true in Custom Action.
BOOL                      g_fPackageElevated          = FALSE;
int                       g_iAssignmentType           = -1; // only set if fPackageElevated

MSIHANDLE                            g_hInstall                             = NULL;
MSIHANDLE                            g_recOutput                            = NULL;
HINSTANCE                            g_hLib                                 = NULL;
PFnMsiCreateRecord                   g_pfnMsiCreateRecord                   = NULL;
PFnMsiProcessMessage                 g_pfnMsiProcessMessage                 = NULL;
PFnMsiRecordSetString                g_pfnMsiRecordSetString                = NULL;
PFnMsiRecordSetInteger               g_pfnMsiRecordSetInteger               = NULL;
PFnMsiRecordClearData                g_pfnMsiRecordClearData                = NULL;
PFnMsiCloseHandle                    g_pfnMsiCloseHandle                    = NULL;
PFnMsiGetProperty                    g_pfnMsiGetProperty                    = NULL;
PFnMsiSourceListAddSource            g_pfnMsiSourceListAddSource            = NULL;
PFnMsiIsProductElevated              g_pfnMsiIsProductElevated              = NULL;
PFnMsiGetProductInfo                 g_pfnMsiGetProductInfo                 = NULL;
PFnMsiGetSummaryInformation          g_pfnMsiGetSummaryInformation          = NULL;
PFnMsiSummaryInfoGetProperty         g_pfnMsiSummaryInfoGetProperty         = NULL;
PFnMsiGetProductCodeFromPackageCode  g_pfnMsiGetProductCodeFromPackageCode  = NULL;



//_____________________________________________________________________________________________________
//
// command line parsing functions
//_____________________________________________________________________________________________________


TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
	TCHAR ch;
	for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
		;
	return ch;
}

BOOL SkipValue(TCHAR*& rpch)
{
	TCHAR ch = *rpch;
	if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
		return FALSE;   // no value present

	TCHAR *pchSwitchInUnbalancedQuotes = NULL;

	for (; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++)
	{       
		if (*rpch == TEXT('"'))
		{
			rpch++; // for '"'

			for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
			{
				if ((ch == TEXT('/') || ch == TEXT('-')) && (NULL == pchSwitchInUnbalancedQuotes))
				{
					pchSwitchInUnbalancedQuotes = rpch;
				}
			}
                    ;
            ch = *(++rpch);
            break;
		}
	}
	if (ch != 0)
	{
		*rpch++ = 0;
	}
	else
	{
		if (pchSwitchInUnbalancedQuotes)
			rpch=pchSwitchInUnbalancedQuotes;
	}
	return TRUE;
}

//______________________________________________________________________________________________
//
// RemoveQuotes function to strip surrounding quotation marks
//     "c:\temp\my files\testdb.msi" becomes c:\temp\my files\testdb.msi
//
//	Also acts as a string copy routine.
//______________________________________________________________________________________________

void RemoveQuotes(const TCHAR* szOriginal, TCHAR* sz)
{
	const TCHAR* pch = szOriginal;
	if (*pch == TEXT('"'))
		pch++;
	int iLen = _tcsclen(pch);
	for (int i = 0; i < iLen; i++, pch++)
		sz[i] = *pch;

	pch = szOriginal;
	if (*(pch + iLen) == TEXT('"'))
			sz[iLen-1] = TEXT('\0');
}


//________________________________________________________________________________
//
// Error handling and Display functions:
//________________________________________________________________________________

void DisplayErrorCore(const TCHAR* szError, int cb)
{
	cb;
	OutputString(INSTALLMESSAGE_INFO, szError);
	
/*	if (g_hStdOut)  // output redirected, suppress UI (unless output error)
	{
		// _stprintf returns char count, WriteFile wants byte count
		DWORD cbWritten;
		if (WriteFile(g_hStdOut, szError, cb*sizeof(TCHAR), &cbWritten, 0))
			return;
	}
//	::MessageBox(0, szError, TEXT("MsiMsp"), MB_OK);
*/
}

void DisplayUsage()
{
	TCHAR szMsgBuf[1024];
	// this will fail when called as a custom action
	if(0 == W32::LoadString(GetModuleHandle(0), IDS_Usage, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)))
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("Failed to load error string.\r\n"));
		return;
	}

	TCHAR szOutBuf[1124];
	int cbOut = 0;
	cbOut = _stprintf(szOutBuf, TEXT("%s\r\n"), szMsgBuf);

	DisplayErrorCore(szOutBuf, cbOut);

}

void DisplayError(UINT iErrorStringID, int iErrorParam)
{
	TCHAR szMsgBuf[1024];
	if(0 == W32::LoadString(0, iErrorStringID, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)))
		return;

	TCHAR szOutBuf[1124];
	int cbOut = _stprintf(szOutBuf, TEXT("%s: 0x%X\r\n"), szMsgBuf, iErrorParam);

	DisplayErrorCore(szOutBuf, cbOut);
}

//_____________________________________________________________________________________________________
//
// Migration Actions
//_____________________________________________________________________________________________________


//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

int SharedEntry(const TCHAR* szCmdLine)
{

	OutputString(INSTALLMESSAGE_INFO, TEXT("Command line: %s\r\n"), szCmdLine);
	OSVERSIONINFO osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	W32::GetVersionEx(&osviVersion); // fails only if size set wrong
	if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		g_fWin9X = true;


	TCHAR szUser[1024]         = {0};
	TCHAR szProductCode[1024]  = {0};
	TCHAR szPackagePath[2048]  = {0};
	migEnum migOptions = migEnum(0);

	// Parse command line
	TCHAR chCmdNext;
	TCHAR* pchCmdLine = (TCHAR*) szCmdLine;
	SkipValue(pchCmdLine);   // skip over module name

	// check for empty command line.  at least one option is required
	chCmdNext = SkipWhiteSpace(pchCmdLine);
	if(chCmdNext == 0)
	{
		DisplayUsage();
		return 1;
	}

	do
	{
		if (chCmdNext == TEXT('/') || chCmdNext == TEXT('-'))
		{
			TCHAR szBuffer[MAX_PATH] = {0};
			TCHAR* szCmdOption = pchCmdLine++;  // save for error msg
			TCHAR chOption = (TCHAR)(*pchCmdLine++ | 0x20);
			chCmdNext = SkipWhiteSpace(pchCmdLine);
			TCHAR* szCmdData = pchCmdLine;  // save start of data
			switch(chOption)
			{
			case TEXT('u'):
				if (!SkipValue(pchCmdLine))
				{
					DisplayUsage();
					return 1;
				}
				RemoveQuotes(szCmdData, szUser);
				break;
			case TEXT('p'):
				if (!SkipValue(pchCmdLine))
				{
					DisplayUsage();
					return 1;
				}
				RemoveQuotes(szCmdData, szProductCode);
				break;
			case TEXT('m'):
				if (!SkipValue(pchCmdLine))
					DisplayUsage();
				RemoveQuotes(szCmdData, szPackagePath);
				break;
			case TEXT('a'):
				break;
			case TEXT('f'):
				migOptions = migEnum(migOptions | migMsiTrust10PackagePolicyOverride);
				break;
			case TEXT('q'):
				migOptions = migEnum(migOptions | migQuiet);
				g_fQuiet = true;
				break;
			case TEXT('?'):
				DisplayUsage();
				return 0;
				break;
			default:
				DisplayUsage();
				return 1;
				break;
			};
		}
		else
		{
			DisplayUsage();
			return 1;
		}
	} while ((chCmdNext = SkipWhiteSpace(pchCmdLine)) != 0);

	
	if (!g_hLib)
		g_hLib = LoadLibrary(MSI_DLL);

	if (!g_hLib)
		return ERROR_INSTALL_FAILURE;

	g_pfnMsiSourceListAddSource           = (PFnMsiSourceListAddSource)            W32::GetProcAddress(g_hLib, MSIAPI_MSISOURCELISTADDSOURCE);
   g_pfnMsiIsProductElevated             = (PFnMsiIsProductElevated)              W32::GetProcAddress(g_hLib, MSIAPI_MSIISPRODUCTELEVATED);
   g_pfnMsiGetProductInfo                = (PFnMsiGetProductInfo)                 W32::GetProcAddress(g_hLib, MSIAPI_MSIGETPRODUCTINFO);
	g_pfnMsiGetProductCodeFromPackageCode = (PFnMsiGetProductCodeFromPackageCode)  W32::GetProcAddress(g_hLib, MSIAPI_MSIGETPRODUCTCODEFROMPACKAGECODE);
	g_pfnMsiSummaryInfoGetProperty        = (PFnMsiSummaryInfoGetProperty)         W32::GetProcAddress(g_hLib, MSIAPI_MSISUMMARYINFOGETPROPERTY);
	g_pfnMsiGetSummaryInformation         = (PFnMsiGetSummaryInformation)          W32::GetProcAddress(g_hLib, MSIAPI_MSIGETSUMMARYINFORMATION);
	g_pfnMsiCloseHandle                   = (PFnMsiCloseHandle)                    W32::GetProcAddress(g_hLib, MSIAPI_MSICLOSEHANDLE);


	if (!g_pfnMsiGetProperty)
		g_pfnMsiGetProperty                = (PFnMsiGetProperty)                    W32::GetProcAddress(g_hLib, MSIAPI_MSIGETPROPERTY);

	if (!(g_pfnMsiGetProperty &&
			g_pfnMsiSourceListAddSource &&
			g_pfnMsiIsProductElevated &&
			g_pfnMsiGetProductInfo &&
			g_pfnMsiGetProductCodeFromPackageCode &&
			g_pfnMsiGetSummaryInformation &&
			g_pfnMsiSummaryInfoGetProperty &&
			g_pfnMsiGetProperty)) 
	{
		OutputString(INSTALLMESSAGE_INFO, TEXT("This version of the MSI.DLL does not support migration.\r\n"));
		return ERROR_INSTALL_FAILURE;
	}
	
	int iReturn = Migrate10CachedPackages(szProductCode, szUser, szPackagePath, migOptions);



	if (g_hLib) 
		FreeLibrary(g_hLib);

	return iReturn;
}

extern "C" int __stdcall CustomActionEntry(MSIHANDLE hInstall)
{
	//MessageBox(NULL, TEXT("MsiMig"), TEXT("MsiMig"), MB_OK);

	g_hInstall = hInstall;

	// cannot run as local system except in custom action.
	g_fRunningAsLocalSystem = RunningAsLocalSystem();

	TCHAR szCommandLine[2048] = TEXT("");
	DWORD cchCommandLine = 2048;

	if (!g_hLib)
		g_hLib = LoadLibrary(MSI_DLL); // closed in SharedEntry
	if (!g_hLib)
		return ERROR_INSTALL_FAILURE;

	// custom action only entry points
	g_pfnMsiCreateRecord        = (PFnMsiCreateRecord)         W32::GetProcAddress(g_hLib, MSIAPI_MSICREATERECORD);
	g_pfnMsiProcessMessage      = (PFnMsiProcessMessage)       W32::GetProcAddress(g_hLib, MSIAPI_MSIPROCESSMESSAGE);
	g_pfnMsiRecordSetString     = (PFnMsiRecordSetString)      W32::GetProcAddress(g_hLib, MSIAPI_MSIRECORDSETSTRING);
	g_pfnMsiRecordSetInteger    = (PFnMsiRecordSetInteger)     W32::GetProcAddress(g_hLib, MSIAPI_MSIRECORDSETINTEGER);
	g_pfnMsiRecordClearData     = (PFnMsiRecordClearData)      W32::GetProcAddress(g_hLib, MSIAPI_MSIRECORDCLEARDATA);
	g_pfnMsiGetProperty         = (PFnMsiGetProperty)          W32::GetProcAddress(g_hLib, MSIAPI_MSIGETPROPERTY);

	if (!(g_pfnMsiCreateRecord && 
			g_pfnMsiProcessMessage && 
			g_pfnMsiRecordSetString &&
			g_pfnMsiRecordSetInteger &&
			g_pfnMsiRecordClearData))
		return ERROR_INSTALL_FAILURE;

	(g_pfnMsiGetProperty)(g_hInstall, TEXT("CustomActionData"), szCommandLine, &cchCommandLine);

	// create a record large enough for any error - but only in custom actions.
	g_recOutput = (g_pfnMsiCreateRecord)(5);
	if (!g_recOutput)
		return ERROR_INSTALL_FAILURE;
	
	int iReturn = SharedEntry(szCommandLine);
	
	if (g_recOutput)
		g_pfnMsiCloseHandle(g_recOutput);

	return iReturn;
}

extern "C" int __cdecl _tmain(int /*argc*/, TCHAR* /*argv[]*/)
{
		return SharedEntry(GetCommandLine());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimsp\sources.inc ===
TARGETNAME=MsiMsp
SYNCHRONIZE_DRAIN=1
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_WINENTRY)

USE_LIBCMT=1

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(BUILD_DIR)\patchwiz.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);..;$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR);..\..\patchwiz

SOURCES=..\msimsp.cpp \
	..\msimsp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\cleanup.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cleanup.cpp
//
//--------------------------------------------------------------------------

#include "msiregmv.h"

const TCHAR szOldInstallerKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer");

const TCHAR szComponentsSubKey[] = TEXT("Components");
const TCHAR szFeaturesSubKey[] = TEXT("Features");
const TCHAR szLocalPackagesSubKey[] = TEXT("LocalPackages");
const TCHAR szPatchesSubKey[] = TEXT("Patches");
const TCHAR szProductsSubKey[] = TEXT("Products");
const TCHAR szUserDataSubKey[] = TEXT("UserData");

bool DeleteRegKeyAndSubKeys(HKEY hKey, const TCHAR *szSubKey)
{
	// open the subkey
	HKEY hSubKey;
	DWORD dwResult = ERROR_SUCCESS;
	dwResult = RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);
	if (dwResult == ERROR_ACCESS_DENIED)
	{
		AcquireTakeOwnershipPriv();

		if (ERROR_SUCCESS == RegOpenKeyEx(hKey, szSubKey, 0, WRITE_OWNER, &hSubKey))
		{
			char *pSD;
			GetSecureSecurityDescriptor(&pSD);
			dwResult = RegSetKeySecurity(hSubKey, OWNER_SECURITY_INFORMATION, pSD);
			RegCloseKey(hSubKey);
			if (ERROR_SUCCESS == (dwResult = RegOpenKeyEx(hKey, szSubKey, 0, WRITE_DAC, &hSubKey)))
			{
				dwResult = RegSetKeySecurity(hSubKey, DACL_SECURITY_INFORMATION, pSD);
			}
			RegCloseKey(hSubKey);
		}
		dwResult = RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);
	}
	if (ERROR_SUCCESS != dwResult)
	{
		if (dwResult == ERROR_FILE_NOT_FOUND)
			return true;
		DEBUGMSG2("Error: Unable to open %s subkey for delete. Error: %d", szSubKey, dwResult);
 		return false;
	}

   	DWORD cchMaxKeyLen = 0;
	DWORD cSubKeys = 0;
    if (ERROR_SUCCESS != (RegQueryInfoKey(hSubKey, NULL, NULL, 0, 
						  &cSubKeys, &cchMaxKeyLen, NULL, NULL, NULL, NULL, NULL, NULL)))
	{
		DEBUGMSG2("Error: Unable to query %s subkey for delete. Error: %d", szSubKey, dwResult);
		RegCloseKey(hSubKey);
		return false;
	}

	if (cSubKeys > 0)
	{
		// on NT, RegQueryInfoKey does not include terminating null when reporting subkey lingth.
		TCHAR *szKey = new TCHAR[++cchMaxKeyLen];
		if (!szKey) 
		{
			DEBUGMSG("Error: Out of memory.");
			RegCloseKey(hSubKey);
			return false;
		}

		DWORD dwIndex=0;
		while (1)
		{
			DWORD cchLen = cchMaxKeyLen;
			LONG lResult = RegEnumKeyEx(hSubKey, dwIndex++, szKey, 
										&cchLen, 0, NULL, NULL, NULL);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Error: Unable to enumerate subkeys of %s for delete. Error: %d", szSubKey, dwResult);
				RegCloseKey(hSubKey);
				delete[] szKey;
				return false;
			}
	 
			if (!DeleteRegKeyAndSubKeys(hSubKey, szKey))
			{
				RegCloseKey(hSubKey);
				delete[] szKey;
				return false;
			}
			else
			{
				// every time we delete a reg key, we're forced to restart the 
				// enumeration or we'll miss keys.
				dwIndex = 0;
			}
		}
		delete[] szKey;
	}
	RegCloseKey(hSubKey);
	dwResult = RegDeleteKey(hKey, szSubKey);

	return true;
}



/////////////////////////
// Read component information from the Installer\Components key and places the Product,
// Component, Path, and Permanent bit into the temporary table for later query.
// returns ERROR_SUCCESS, ERROR_OUTOFMEMORY or ERROR_FUNCTION_FAILED
void CleanupOnSuccess(MSIHANDLE hDatabase)
{
	// create query for files that should be cleaned up on success . If this fails
	// we'll just orphan the files
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT `File` FROM `CleanupFile` WHERE `OnSuccess`=1"), &hCleanUpTable) &&
		ERROR_SUCCESS == MsiViewExecute(hCleanUpTable, 0))
	{
		PMSIHANDLE hFileRec;
		while (ERROR_SUCCESS == MsiViewFetch(hCleanUpTable, &hFileRec))
		{
			TCHAR rgchFile[MAX_PATH];
			DWORD cchFile = MAX_PATH;
			if (ERROR_SUCCESS == MsiRecordGetString(hFileRec, 1, rgchFile, &cchFile))
			{
				DEBUGMSG1("Deleting File: %s", rgchFile);
				DeleteFile(rgchFile);
			}
		}
	}

	// create query for directories that should be cleaned up on success . If this fails
	// we'll just orphan the directory
    if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT `File` FROM `CleanupFile` WHERE `OnSuccess`>1 ORDER BY `OnSuccess`"), &hCleanUpTable) &&
		ERROR_SUCCESS == MsiViewExecute(hCleanUpTable, 0))
	{
		PMSIHANDLE hFileRec;
		while (ERROR_SUCCESS == MsiViewFetch(hCleanUpTable, &hFileRec))
		{
			TCHAR rgchFile[MAX_PATH];
			DWORD cchFile = MAX_PATH;
			if (ERROR_SUCCESS == MsiRecordGetString(hFileRec, 1, rgchFile, &cchFile))
			{
				DEBUGMSG1("Removing directory: %s", rgchFile);
				RemoveDirectory(rgchFile);
			}
		}
	}

	// delete data
	DWORD dwResult; 
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldInstallerKey, 0, KEY_ALL_ACCESS, &hKey))
	{
		DeleteRegKeyAndSubKeys(hKey, szComponentsSubKey);
		DeleteRegKeyAndSubKeys(hKey, szFeaturesSubKey);
		DeleteRegKeyAndSubKeys(hKey, szLocalPackagesSubKey);
		DeleteRegKeyAndSubKeys(hKey, szPatchesSubKey);

		// its unbelievable, but admins don't always have access to the feature usage key
		{
		}

		DeleteRegKeyAndSubKeys(hKey, szProductsSubKey);

		RegCloseKey(hKey);
	}
}


void CleanupOnFailure(MSIHANDLE hDatabase)
{
	// create query for files that should be cleaned up on failure . If this fails
	// we'll just orphan the files
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT `File` FROM `CleanupFile` WHERE `OnSuccess`=0"), &hCleanUpTable) &&
		ERROR_SUCCESS == MsiViewExecute(hCleanUpTable, 0))
	{
		PMSIHANDLE hFileRec;
		while (ERROR_SUCCESS == MsiViewFetch(hCleanUpTable, &hFileRec))
		{
			TCHAR rgchFile[MAX_PATH];
			DWORD cchFile = MAX_PATH;
			if (ERROR_SUCCESS == MsiRecordGetString(hFileRec, 1, rgchFile, &cchFile))
			{
				DeleteFile(rgchFile);
			}
		}
	}

	// delete data
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldInstallerKey, 0, KEY_ALL_ACCESS, &hKey))
	{
		DeleteRegKeyAndSubKeys(hKey, szUserDataSubKey);

		RegCloseKey(hKey);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimsp\msimsp.cpp ===
//________________________________________________________________________________
//
// Required headers, #defines
//________________________________________________________________________________

#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#include "patchwiz.h"
#include "msimsp.h"

#include <stdio.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE

#define W32
#define MSI
#define PATCHWIZ


//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

HINSTANCE g_hInst;
HANDLE g_hStdOut;


//________________________________________________________________________________
//
// Function prototypes
//________________________________________________________________________________

void DisplayError(UINT iErrorStringID, const TCHAR* szErrorParam);
void DisplayError(UINT iErrorStringID, int iErrorParam);
void DisplayErrorCore(const TCHAR* szError, int cb);
void ErrorExit(UINT iError, UINT iErrorStringID, const TCHAR* szErrorParam);
void ErrorExit(UINT iError, UINT iErrorStringID, int iErrorParam);
void IfErrorExit(bool fError, UINT iErrorStringID, const TCHAR* szErrorParam);
BOOL SkipValue(TCHAR*& rpch);
TCHAR SkipWhiteSpace(TCHAR*& rpch);
void RemoveQuotes(const TCHAR* szOriginal, TCHAR* sz);

UINT CreatePatch(TCHAR* szPcpPath, TCHAR* szMspPath, TCHAR* szLogFile, TCHAR* szTempFolder,
					  BOOL fRemoveTempFolderIfPresent);


//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __stdcall _tWinMain(HINSTANCE hInst, HINSTANCE/*hPrev*/, TCHAR* szCmdLine, int/*show*/)
{
	// set up globals
	g_hInst = hInst;
	
	g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE || ::GetFileType(g_hStdOut) == 0)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped

	// Parse command line
	TCHAR szPcp[MAX_PATH]         = {0};
	TCHAR szMsp[MAX_PATH]         = {0};
	TCHAR szLog[MAX_PATH]         = {0};
	TCHAR szTempFolder[MAX_PATH]  = {0};
	BOOL  fCleanTempFolder        = TRUE;
	BOOL  fSuccessDialog          = FALSE;
	
	TCHAR chCmdNext;
	TCHAR* pchCmdLine = szCmdLine;
	SkipValue(pchCmdLine);   // skip over module name
	while ((chCmdNext = SkipWhiteSpace(pchCmdLine)) != 0)
	{
		if (chCmdNext == TEXT('/') || chCmdNext == TEXT('-'))
		{
			TCHAR szBuffer[MAX_PATH] = {0};
			TCHAR* szCmdOption = pchCmdLine++;  // save for error msg
			TCHAR chOption = (TCHAR)(*pchCmdLine++ | 0x20);
			chCmdNext = SkipWhiteSpace(pchCmdLine);
			TCHAR* szCmdData = pchCmdLine;  // save start of data
			switch(chOption)
			{
			case TEXT('s'):
				if (!SkipValue(pchCmdLine))
					ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				RemoveQuotes(szCmdData, szPcp);
				break;
			case TEXT('p'):
				if (!SkipValue(pchCmdLine))
					ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				RemoveQuotes(szCmdData, szMsp);
				break;
			case TEXT('l'):
				if (!SkipValue(pchCmdLine))
					ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				RemoveQuotes(szCmdData, szLog);
				break;
			case TEXT('f'):
				if (!SkipValue(pchCmdLine))
					ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				RemoveQuotes(szCmdData, szTempFolder);
				break;
			case TEXT('k'):
				fCleanTempFolder = FALSE;
				break;
			case TEXT('d'):
				fSuccessDialog = TRUE;
				break;
			case TEXT('?'):
				ErrorExit(0, IDS_Usage, (const TCHAR*)0);
				break;
			default:
				ErrorExit(1, IDS_Usage, (const TCHAR*)0);
				break;
			};
		}
		else
		{
			ErrorExit(1, IDS_Usage, (const TCHAR*)0);
		}
	} // while (command line tokens exist)

	// check for required arguments
	if(!*szPcp || !*szMsp)
		ErrorExit(1, IDS_Usage, (const TCHAR*)0);
	
	UINT uiRet = CreatePatch(szPcp, szMsp, szLog, szTempFolder, fCleanTempFolder);
	if(uiRet != ERROR_SUCCESS)
		ErrorExit(1, IDS_CreatePatchError, uiRet);
	else if(fSuccessDialog)
		DisplayError(IDS_Success, szMsp);

	return 0;
}

//_____________________________________________________________________________________________________
//
// command line parsing functions
//_____________________________________________________________________________________________________

TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
	TCHAR ch;
	for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
		;
	return ch;
}

BOOL SkipValue(TCHAR*& rpch)
{
	TCHAR ch = *rpch;
	if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
		return FALSE;   // no value present

	TCHAR *pchSwitchInUnbalancedQuotes = NULL;

	for (; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++)
	{       
		if (*rpch == TEXT('"'))
		{
			rpch++; // for '"'

			for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
			{
				if ((ch == TEXT('/') || ch == TEXT('-')) && (NULL == pchSwitchInUnbalancedQuotes))
				{
					pchSwitchInUnbalancedQuotes = rpch;
				}
			}
                    ;
            ch = *(++rpch);
            break;
		}
	}
	if (ch != 0)
	{
		*rpch++ = 0;
	}
	else
	{
		if (pchSwitchInUnbalancedQuotes)
			rpch=pchSwitchInUnbalancedQuotes;
	}
	return TRUE;
}

//______________________________________________________________________________________________
//
// RemoveQuotes function to strip surrounding quotation marks
//     "c:\temp\my files\testdb.msi" becomes c:\temp\my files\testdb.msi
//
//	Also acts as a string copy routine.
//______________________________________________________________________________________________

void RemoveQuotes(const TCHAR* szOriginal, TCHAR* sz)
{
	const TCHAR* pch = szOriginal;
	if (*pch == TEXT('"'))
		pch++;
	int iLen = _tcsclen(pch);
	for (int i = 0; i < iLen; i++, pch++)
		sz[i] = *pch;

	pch = szOriginal;
	if (*(pch + iLen) == TEXT('"'))
			sz[iLen-1] = TEXT('\0');
}


UINT CreatePatch(TCHAR* szPcpPath, TCHAR* szMspPath, TCHAR* szLogFile, TCHAR* szTempFolder,
					  BOOL fRemoveTempFolderIfPresent)
{
	return PATCHWIZ::UiCreatePatchPackage(szPcpPath, szMspPath, szLogFile, 0, szTempFolder, fRemoveTempFolderIfPresent);
}

//________________________________________________________________________________
//
// Error handling and Display functions:
//________________________________________________________________________________

void DisplayError(UINT iErrorStringID, const TCHAR* szErrorParam)
{
	TCHAR szMsgBuf[1024];
	if(0 == W32::LoadString(g_hInst, iErrorStringID, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)))
		return;

	TCHAR szOutBuf[1124];
	int cbOut = 0;
	if(szErrorParam)
		cbOut = _stprintf(szOutBuf, TEXT("%s: %s\r\n"), szMsgBuf, szErrorParam);
	else
		cbOut = _stprintf(szOutBuf, TEXT("%s\r\n"), szMsgBuf);

	DisplayErrorCore(szOutBuf, cbOut);
}

void DisplayError(UINT iErrorStringID, int iErrorParam)
{
	TCHAR szMsgBuf[1024];
	if(0 == W32::LoadString(g_hInst, iErrorStringID, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR)))
		return;

	TCHAR szOutBuf[1124];
	int cbOut = _stprintf(szOutBuf, TEXT("%s: 0x%X\r\n"), szMsgBuf, iErrorParam);

	DisplayErrorCore(szOutBuf, cbOut);
}

void DisplayErrorCore(const TCHAR* szError, int cb)
{
	if (g_hStdOut)  // output redirected, suppress UI (unless output error)
	{
		// _stprintf returns char count, WriteFile wants byte count
		DWORD cbWritten;
		if (WriteFile(g_hStdOut, szError, cb*sizeof(TCHAR), &cbWritten, 0))
			return;
	}
	::MessageBox(0, szError, TEXT("MsiMsp"), MB_OK);
}


void ErrorExit(UINT iExitCode, UINT iErrorStringID, const TCHAR* szErrorParam)
{
	DisplayError(iErrorStringID, szErrorParam);
	W32::ExitProcess(iExitCode);
}

void ErrorExit(UINT iExitCode, UINT iErrorStringID, int iErrorParam)
{
	DisplayError(iErrorStringID, iErrorParam);
	W32::ExitProcess(iExitCode);
}

void IfErrorExit(bool fError, UINT iExitCode, UINT iErrorStringID, const TCHAR* szErrorParam)
{
	if(fError)
		ErrorExit(iExitCode, iErrorStringID, szErrorParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msimsg\make.inc ===
!INCLUDE ..\..\..\MsiMake.inc


MSG_DIR=$(SRC_DIR)\MsiTools\MsiMsg
MSG_OBJDIR=$(MSG_DIR)\$(MSI_SUBDIR)\$(O)

MsiMsgAll:$(BUILD_DIR)\msimsg.dll \
        $(BUILD_DIR)\MsiError.msg


$(BUILD_DIR)\MsiError.msg : $(MSG_OBJDIR)\MsiError.mc
        mc -h $(BUILD_DIR) -r $(MSG_OBJDIR) $(MSG_OBJDIR)\MsiError.mc
        rc -Fo$(MSG_OBJDIR)\MsiError.res -i $(INC_DIR) $(MSG_OBJDIR)\MsiError.rc
        $(LINK_NAME) -out:$@ /machine:$(MACHINE_TYPE) /DLL /NOENTRY $(MSG_OBJDIR)\MsiError.res

$(MSG_OBJDIR)\MsiError.mc: $(MSI_BUILDTOOLS_DIR)\genmsier.prl
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsier.prl $(SDK_INC_PATH)\msi.h $@
        
$(BUILD_DIR)\msimsg.dll: $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.* $(MSI_INTLDATA_DIR)\ActionTe.* $(INC_DIR)\version.h $(RES_OBJDIR)\msi.rcv
        @if exist $(MSG_OBJDIR)\err???.rc del $(MSG_OBJDIR)\err???.rc
        @if exist $(MSG_OBJDIR)\act???.rc del $(MSG_OBJDIR)\act???.rc

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ARA $(MSG_OBJDIR)\errara.rc 1 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ARA $(MSG_OBJDIR)\actara.rc 1 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.CAT $(MSG_OBJDIR)\errcat.rc 3 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.CAT $(MSG_OBJDIR)\actcat.rc 3 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.CHS $(MSG_OBJDIR)\errchs.rc 4 2
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.CHS $(MSG_OBJDIR)\actchs.rc 4 2

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.CHT $(MSG_OBJDIR)\errcht.rc 4 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.CHT $(MSG_OBJDIR)\actcht.rc 4 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.CSY $(MSG_OBJDIR)\errcsy.rc 5 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.CSY $(MSG_OBJDIR)\actcsy.rc 5 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.DAN $(MSG_OBJDIR)\errdan.rc 6 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.DAN $(MSG_OBJDIR)\actdan.rc 6 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.DEU $(MSG_OBJDIR)\errdeu.rc 7 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.DEU $(MSG_OBJDIR)\actdeu.rc 7 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ELL $(MSG_OBJDIR)\errell.rc 8 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ELL $(MSG_OBJDIR)\actell.rc 8 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ENU $(MSG_OBJDIR)\errenu.rc 9 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ENU $(MSG_OBJDIR)\actenu.rc 9 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ESN $(MSG_OBJDIR)\erresn.rc A 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ESN $(MSG_OBJDIR)\actesn.rc A 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.EUQ $(MSG_OBJDIR)\erreuq.rc 2D 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.EUQ $(MSG_OBJDIR)\acteuq.rc 2D 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.FIN $(MSG_OBJDIR)\errfin.rc B 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.FIN $(MSG_OBJDIR)\actfin.rc B 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.FRA $(MSG_OBJDIR)\errfra.rc C 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.FRA $(MSG_OBJDIR)\actfra.rc C 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.HEB $(MSG_OBJDIR)\errheb.rc D 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.HEB $(MSG_OBJDIR)\actheb.rc D 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.HRV $(MSG_OBJDIR)\errhrv.rc 1A 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.HRV $(MSG_OBJDIR)\acthrv.rc 1A 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.HUN $(MSG_OBJDIR)\errhun.rc E 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.HUN $(MSG_OBJDIR)\acthun.rc E 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ITA $(MSG_OBJDIR)\errita.rc 10 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ITA $(MSG_OBJDIR)\actita.rc 10 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.JPN $(MSG_OBJDIR)\errjpn.rc 11 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.JPN $(MSG_OBJDIR)\actjpn.rc 11 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.KOR $(MSG_OBJDIR)\errkor.rc 12 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.KOR $(MSG_OBJDIR)\actkor.rc 12 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.NLD $(MSG_OBJDIR)\errnld.rc 13 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.NLD $(MSG_OBJDIR)\actnld.rc 13 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.NOR $(MSG_OBJDIR)\errnor.rc 14 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.NOR $(MSG_OBJDIR)\actnor.rc 14 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.PLK $(MSG_OBJDIR)\errplk.rc 15 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.PLK $(MSG_OBJDIR)\actplk.rc 15 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.PTB $(MSG_OBJDIR)\errptb.rc 16 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.PTB $(MSG_OBJDIR)\actptb.rc 16 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.PTG $(MSG_OBJDIR)\errptg.rc 16 2
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.PTG $(MSG_OBJDIR)\actptg.rc 16 2

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.ROM $(MSG_OBJDIR)\errrom.rc 18 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.ROM $(MSG_OBJDIR)\actrom.rc 18 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.RUS $(MSG_OBJDIR)\errrus.rc 19 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.RUS $(MSG_OBJDIR)\actrus.rc 19 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.SKY $(MSG_OBJDIR)\errsky.rc 1B 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.SKY $(MSG_OBJDIR)\actsky.rc 1B 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.SLV $(MSG_OBJDIR)\errslv.rc 24 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.SLV $(MSG_OBJDIR)\actslv.rc 24 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.SVE $(MSG_OBJDIR)\errsve.rc 1D 0
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.SVE $(MSG_OBJDIR)\actsve.rc 1D 0

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.THA $(MSG_OBJDIR)\errtha.rc 1E 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.THA $(MSG_OBJDIR)\acttha.rc 1E 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.TRK $(MSG_OBJDIR)\errtrk.rc 1F 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.TRK $(MSG_OBJDIR)\acttrk.rc 1F 1

        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\Error.VIT $(MSG_OBJDIR)\errvit.rc 2A 1
        $(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genmsgrc.prl $(MSI_INTLDATA_DIR)\ActionTe.VIT $(MSG_OBJDIR)\actvit.rc 2A 1

        @if exist $(MSG_OBJDIR)\msimsg.rc del $(MSG_OBJDIR)\msimsg.rc
        copy $(MSG_DIR)\msimsg.rc + $(MSG_OBJDIR)\err???.rc + $(MSG_OBJDIR)\act???.rc $(MSG_OBJDIR)\msimsg.rc /b
        @del $(MSG_OBJDIR)\err???.rc
        @del $(MSG_OBJDIR)\act???.rc

        rc $(C_DEFINES) /I$(SDK_INC_PATH) /I$(INC_DIR) /I$(RES_OBJDIR) $(MSG_OBJDIR)\msimsg.rc

        $(LINK_NAME) $(MSG_OBJDIR)\msimsg.res /machine:$(MACHINE_TYPE) /DLL /NOENTRY /OUT:$(BUILD_DIR)\msimsg.dll
        @del $(MSG_OBJDIR)\msimsg.res
!if "$(MSI_BUILD_UNICODE)"=="1"      
        $(BINPLACE_CMD)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\migsecur.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       migsecur.cpp
//
//--------------------------------------------------------------------------

#include "msiregmv.h"

PSID g_AdminSID = NULL;
PSID g_SystemSID = NULL;

DWORD GetAdminSID(PSID* pSID)
{
    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
	if (!g_AdminSID)
	{
		if (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &g_AdminSID))
			return GetLastError();
	}
	*pSID = g_AdminSID;
    return ERROR_SUCCESS;
}

DWORD GetLocalSystemSID(PSID* pSID)
{
	*pSID = NULL;
    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
	if (!g_SystemSID)
	{
        if (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(g_SystemSID)))
            return GetLastError();
    }
    *pSID = g_SystemSID;
    return ERROR_SUCCESS;
}


////
// FIsOwnerSystemOrAdmin -- return whether owner sid is a LocalSystem
// sid or Admin sid
bool FIsOwnerSystemOrAdmin(PSECURITY_DESCRIPTOR rgchSD)
{
	if (g_fWin9X)
		return true;

    // grab owner SID from the security descriptor
    DWORD dwRet;
    PSID psidOwner;
    BOOL fDefaulted;
    if (!GetSecurityDescriptorOwner(rgchSD, &psidOwner, &fDefaulted))
    {
        // ** some form of error handling
        return false;
    }

    // if there is no SD owner, return false
    if (!psidOwner)
        return false;

    // compare SID to system & admin
    PSID psidLocalSystem;
    if (ERROR_SUCCESS != (dwRet = GetLocalSystemSID(&psidLocalSystem)))
    {
        // ** some form of error handling
		return false;    
	}

    if (!EqualSid(psidOwner, psidLocalSystem))
    {
        // not owned by system, (continue by checking Admin)
        PSID psidAdmin;
        if (ERROR_SUCCESS != (dwRet = GetAdminSID(&psidAdmin)))
        {
            // ** some form of error handling
			return false;
        }

        // check for admin ownership
        if (!EqualSid(psidOwner, psidAdmin))
		{
			// don't TRUST! neither admin or system
            return false; 
		}
    }
    return true;
}

bool FIsKeyLocalSystemOrAdminOwned(HKEY hKey)
{
	if (g_fWin9X)
		return true;

	// reading just the owner doesn't take very much space
	DWORD cbSD = 64;
    unsigned char *pchSD = new unsigned char[cbSD];
	if (!pchSD)
		return false;

    LONG dwRet = RegGetKeySecurity(hKey, OWNER_SECURITY_INFORMATION, (PSECURITY_DESCRIPTOR)pchSD, &cbSD);
    if (ERROR_SUCCESS != dwRet)
    {
        if (ERROR_INSUFFICIENT_BUFFER == dwRet)
        {
            delete[] pchSD;
			pchSD = new unsigned char[cbSD];
			if (!pchSD)
				return false;
            dwRet = RegGetKeySecurity(hKey, OWNER_SECURITY_INFORMATION, (PSECURITY_DESCRIPTOR)pchSD, &cbSD);
        }

        if (ERROR_SUCCESS != dwRet)
        {
			delete[] pchSD;
            return false;
        }
    }

    bool fRet = FIsOwnerSystemOrAdmin(pchSD);
	delete[] pchSD;
	return fRet;
}


void GetStringSID(PISID pSID, TCHAR* szSID)
// Converts a binary SID into its string form (S-n-...). 
// szSID should be of length cchMaxSID
{
	TCHAR Buffer[cchMaxSID];
	
	wsprintf(Buffer, TEXT("S-%u-"), pSID->Revision);

	lstrcpy(szSID, Buffer);

	if ((pSID->IdentifierAuthority.Value[0] != 0) ||
		(pSID->IdentifierAuthority.Value[1] != 0))
	{
		wsprintf(Buffer, TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
					(USHORT)pSID->IdentifierAuthority.Value[0],
					(USHORT)pSID->IdentifierAuthority.Value[1],
                    (USHORT)pSID->IdentifierAuthority.Value[2],
                    (USHORT)pSID->IdentifierAuthority.Value[3],
                    (USHORT)pSID->IdentifierAuthority.Value[4],
                    (USHORT)pSID->IdentifierAuthority.Value[5] );
		lstrcat(szSID, Buffer);
	}
	else
	{
        ULONG Tmp = (ULONG)pSID->IdentifierAuthority.Value[5]          +
              (ULONG)(pSID->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(pSID->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(pSID->IdentifierAuthority.Value[2] << 24);
        wsprintf(Buffer, TEXT("%lu"), Tmp);
		lstrcat(szSID, Buffer);
    }

    for (int i=0;i<pSID->SubAuthorityCount ;i++ ) {
        wsprintf(Buffer, TEXT("-%lu"), pSID->SubAuthority[i]);
		lstrcat(szSID, Buffer);
    }
}

DWORD GetToken(HANDLE* hToken)
{
	DWORD dwResult = ERROR_SUCCESS;
	if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, hToken))
	{
		// if the thread has no access token then use the process's access token
    	if (ERROR_NO_TOKEN == (dwResult = GetLastError()))
		{
			dwResult = ERROR_SUCCESS;
			if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, hToken))
				dwResult = GetLastError();
		}
	}
	return dwResult;
}

// retrieves the binary form of the current user SID. Caller is responsible for
// releasing *rgSID
DWORD GetCurrentUserSID(unsigned char** rgSID)
{
#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

	HANDLE hToken;
	*rgSID = NULL;

	if (ERROR_SUCCESS != GetToken(&hToken))
		return ERROR_FUNCTION_FAILED;

	unsigned char TokenUserInfo[SIZE_OF_TOKEN_INFORMATION];
	DWORD ReturnLength = 0;;
	BOOL fRes = GetTokenInformation(hToken, TokenUser, reinterpret_cast<void *>(&TokenUserInfo),
									sizeof(TokenUserInfo), &ReturnLength);

	CloseHandle(hToken);

	if(fRes == FALSE)
	{
		DWORD dwRet = GetLastError();
		return dwRet;
	}

	PISID piSid = (PISID)((PTOKEN_USER)TokenUserInfo)->User.Sid;
	if (IsValidSid(piSid))
	{
		DWORD cbSid = GetLengthSid(piSid);
		*rgSID = new unsigned char[cbSid];
		if (!*rgSID)
			return ERROR_FUNCTION_FAILED;

		if (CopySid(cbSid, *rgSID, piSid))
			return ERROR_SUCCESS;
		else
		{
			delete[] *rgSID;
			*rgSID = NULL;
			return GetLastError();
		}
	}
	return ERROR_FUNCTION_FAILED;
}

DWORD GetCurrentUserStringSID(TCHAR* szSID)
// get string form of SID for current user: caller does NOT need to impersonate
{
	if (!szSID)
		return ERROR_FUNCTION_FAILED;

	if (g_fWin9X)
	{
		lstrcpy(szSID, szCommonUserSID);
		return ERROR_SUCCESS;
	}

	unsigned char* pSID = NULL;
	DWORD dwRet = ERROR_SUCCESS;

	if (ERROR_SUCCESS == (dwRet = GetCurrentUserSID(&pSID)))
	{
		if (pSID)
		{
			GetStringSID(reinterpret_cast<SID*>(pSID), szSID);
			delete[] pSID;
		}
		else
			dwRet = ERROR_FUNCTION_FAILED;
	}
	return dwRet;
}



////
// Returns true if the process is a system process. Caches result.
bool RunningAsLocalSystem()
{
	static int iRet = -1;

	if(iRet != -1)
		return (iRet != 0);
	
	unsigned char *pSID = NULL;
	if (ERROR_SUCCESS == GetCurrentUserSID(&pSID))
	{
		if (pSID)
		{
			PSID pSystemSID = NULL;
			if (ERROR_SUCCESS != GetLocalSystemSID(&pSystemSID))
				return false;
	
			if (pSystemSID)
			{
				iRet = 0;
				if (EqualSid(pSID, pSystemSID))
					iRet = 1;
				delete[] pSID;
				return (iRet != 0);
			}
			delete[] pSID;
		}
	}
	return false;
}


enum sdSecurityDescriptor
{
    sdEveryoneUpdate,
    sdSecure,
};

DWORD GetSecurityDescriptor(char* rgchStaticSD, DWORD& cbStaticSD, sdSecurityDescriptor sdType)
{
    class CSIDPointer
    {
     public:
        CSIDPointer(SID* pi) : m_pi(pi){}
        ~CSIDPointer() {if (m_pi) FreeSid(m_pi);} // release ref count at destruction
        operator SID*() {return m_pi;}     // returns pointer, no ref count change
        SID** operator &() {if (m_pi) { FreeSid(m_pi); m_pi=NULL; } return &m_pi;}
     private:
        SID* m_pi;
    };

    struct Security
    {
        CSIDPointer pSID;
        DWORD dwAccessMask;
        Security() : pSID(0), dwAccessMask(0) {}
    } rgchSecurity[3];

    int cSecurity = 0;

    // Initialize the SIDs we'll need

    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;

    const SID* psidOwner;
    const SID* psidGroup = 0;

    switch (sdType)
    {
        case sdSecure:
        {
            if ((!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID))) ||
                 (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
                 (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
            {
                return GetLastError();
            }
			// if not running as system, system can't be the owner of the object. 
            psidOwner = rgchSecurity[RunningAsLocalSystem() ? 0 : 2].pSID;
            rgchSecurity[0].dwAccessMask = GENERIC_ALL;
            rgchSecurity[1].dwAccessMask = GENERIC_READ|GENERIC_EXECUTE|READ_CONTROL|SYNCHRONIZE; //?? Is this correct?
            rgchSecurity[2].dwAccessMask = GENERIC_ALL;
            cSecurity = 3;
            break;
        }
		case sdEveryoneUpdate:
		{
			if (((!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[0].pSID)))) ||
			   (!AllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[1].pSID))) ||
               (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(rgchSecurity[2].pSID))))
			{
				return GetLastError();
			}
			// if not running as system, system can't be the owner of the object. 
			psidOwner = rgchSecurity[RunningAsLocalSystem() ? 1 : 2].pSID;
			rgchSecurity[0].dwAccessMask = (STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL) & ~(WRITE_DAC|WRITE_OWNER|DELETE);			
			rgchSecurity[1].dwAccessMask = GENERIC_ALL;
			rgchSecurity[2].dwAccessMask = GENERIC_ALL;
			cSecurity = 3;
			break;
		}
    }

    // Initialize our ACL

    const int cbAce = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD); // subtract ACE.SidStart from the size
    int cbAcl = sizeof (ACL);

    for (int c=0; c < cSecurity; c++)
        cbAcl += (GetLengthSid(rgchSecurity[c].pSID) + cbAce);

    char *rgchACL = new char[cbAcl];
    
    if (!InitializeAcl ((ACL*)rgchACL, cbAcl, ACL_REVISION))
	{
		delete[] rgchACL;
        return GetLastError();
	}

    // Add an access-allowed ACE for each of our SIDs

    for (c=0; c < cSecurity; c++)
    {
        if (!AddAccessAllowedAce((ACL*)rgchACL, ACL_REVISION, rgchSecurity[c].dwAccessMask, rgchSecurity[c].pSID))
		{
			delete[] rgchACL;
            return GetLastError();
		}

        ACCESS_ALLOWED_ACE* pAce;
        if (!GetAce((ACL*)(char*)rgchACL, c, (void**)&pAce))
		{
			delete[] rgchACL;
            return GetLastError();
		}

        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE;
    }

    // Initialize our security descriptor,throw the ACL into it, and set the owner
    SECURITY_DESCRIPTOR sd;

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ||
        (!SetSecurityDescriptorDacl(&sd, TRUE, (ACL*)rgchACL, FALSE)) ||
        (!SetSecurityDescriptorOwner(&sd, (PSID)psidOwner, FALSE)) ||
        (psidGroup && !SetSecurityDescriptorGroup(&sd, (PSID)psidGroup, FALSE)))
    {
		delete[] rgchACL;
        return GetLastError();
    }

    DWORD cbSD = GetSecurityDescriptorLength(&sd);
    if (cbStaticSD < cbSD)
    {
		delete[] rgchACL;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    MakeSelfRelativeSD(&sd, (char*)rgchStaticSD, &cbSD);
	delete[] rgchACL;

    return ERROR_SUCCESS;
}


DWORD GetSecureSecurityDescriptor(char** pSecurityDescriptor)
{
	if (g_fWin9X)
	{
		*pSecurityDescriptor = NULL;
		return ERROR_SUCCESS;
	}
    static bool fDescriptorSet = false;
    static char rgchStaticSD[256];
    DWORD cbStaticSD = sizeof(rgchStaticSD);

    DWORD dwRet = ERROR_SUCCESS;

    if (!fDescriptorSet)
    {
        if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchStaticSD, cbStaticSD, sdSecure)))
            return dwRet;

        fDescriptorSet = true;
    }

    *pSecurityDescriptor = rgchStaticSD;
    return ERROR_SUCCESS;
}


DWORD GetEveryoneUpdateSecurityDescriptor(char** pSecurityDescriptor)
{
	if (g_fWin9X)
	{
		*pSecurityDescriptor = NULL;
		return ERROR_SUCCESS;
	}

    static bool fDescriptorSet = false;
    static char rgchStaticSD[256];
    DWORD cbStaticSD = sizeof(rgchStaticSD);

    DWORD dwRet = ERROR_SUCCESS;

    if (!fDescriptorSet)
    {
        if (ERROR_SUCCESS != (dwRet = GetSecurityDescriptor(rgchStaticSD, cbStaticSD, sdEveryoneUpdate)))
            return dwRet;

        fDescriptorSet = true;
    }

    *pSecurityDescriptor = rgchStaticSD;
    return ERROR_SUCCESS;
}


////
// temp file name generation algorithm is based on code from MsiPath object.
DWORD GenerateSecureTempFile(TCHAR* szDirectory, const TCHAR rgchExtension[5], 
							 SECURITY_ATTRIBUTES *pSA, TCHAR rgchFileName[13], HANDLE &hFile)
{
	int cDigits = 8; // number of hex digits to use in file name
	static bool fInitialized = false;
	static unsigned int uiUniqueStart;
	// Might be a chance for two threads to get in here, we're not going to be worried
	// about that. It would get intialized twice
	if (!fInitialized)
	{
		uiUniqueStart = GetTickCount();
		fInitialized = true;
	}

	hFile = INVALID_HANDLE_VALUE;
		
	unsigned int uiUniqueId = uiUniqueStart++;
	unsigned int cPerms = 0xFFFFFFFF; // number of possible file names to try (-1)
	
	for(unsigned int i = 0; i <= cPerms; i++)
	{
		wsprintf(rgchFileName,TEXT("%x"),uiUniqueId);
		lstrcat(rgchFileName, rgchExtension);

		TCHAR rgchBuffer[MAX_PATH];
		lstrcpy(rgchBuffer, szDirectory);
		lstrcat(rgchBuffer, rgchFileName);

		DWORD iError = 0;
		if (INVALID_HANDLE_VALUE == (hFile = CreateFile(rgchBuffer, GENERIC_WRITE, FILE_SHARE_READ, 
									pSA, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0)))
		{
			iError = GetLastError();

			if(iError != ERROR_ALREADY_EXISTS)
				break;
		}
		else
			break;

		// increment number portion of name - if it currently equals cPerms, it is time to
		// wrap number around to 0
		uiUniqueStart++;
		if(uiUniqueId == cPerms)
			uiUniqueId = 0;
		else
			uiUniqueId++;
	}

		
	if(hFile == INVALID_HANDLE_VALUE)
	{
		return ERROR_FUNCTION_FAILED;
 	}
	
	return ERROR_SUCCESS;
}


BOOL CopyOpenedFile(HANDLE hSourceFile, HANDLE hDestFile)
{
	const int cbCopyBufferSize = 32*1024;
	static unsigned char rgbCopyBuffer[cbCopyBufferSize];

	for(;;)
	{
		unsigned long cbToCopy = cbCopyBufferSize;

		DWORD cbRead = 0;
		if (!ReadFile(hSourceFile, rgbCopyBuffer, cbToCopy, &cbRead, 0))
			return FALSE; 
		
		if (cbRead)
		{
			DWORD cbWritten;
			if (!WriteFile(hDestFile, rgbCopyBuffer, cbRead, &cbWritten, 0))
				return FALSE;

			if (cbWritten != cbRead)
				return FALSE;
		}
		else 
			break;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Creates a reg key with a secure ACL and verifies that any existing key
// is trusted (by checking Admin or System ownership). If it is not 
// trusted, the key and all subkeys are replaced with a new secure
// empty key.
DWORD CreateSecureRegKey(HKEY hParent, LPCTSTR szNewKey, SECURITY_ATTRIBUTES *sa, HKEY* hResKey)
{
	DWORD dwDisposition = 0;
	DWORD dwResult = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (dwResult = RegCreateKeyEx(hParent, szNewKey, 0, NULL, 0, KEY_ALL_ACCESS, (g_fWin9X ? NULL : sa), hResKey, &dwDisposition)))
	{
		DEBUGMSG2("Error: Unable to create secure key %s. Result: %d.", szNewKey, dwResult);
		return dwResult;
	}

	if (dwDisposition == REG_OPENED_EXISTING_KEY)
	{
		// ACL on this key must be system or admin or it can't be trusted
		if (!FIsKeyLocalSystemOrAdminOwned(*hResKey))
		{
			DEBUGMSG1("Existing key %s not owned by Admin or System. Deleting.", szNewKey);

			RegCloseKey(*hResKey);
			if (!DeleteRegKeyAndSubKeys(hParent, szNewKey))
			{
				DEBUGMSG2("Error: Unable to delete insecure key %s. Result: %d.", szNewKey, dwResult);
				return ERROR_FUNCTION_FAILED;
			}

			if (ERROR_SUCCESS != (dwResult = RegCreateKeyEx(hParent, szNewKey, 0, NULL, 0, KEY_ALL_ACCESS, sa, hResKey, NULL)))
			{
				DEBUGMSG2("Error: Unable to create secure key %s. Result: %d.", szNewKey, dwResult);
				return dwResult;
			}
		}
	}
	return ERROR_SUCCESS;
}

////
// Token privilege functions

bool AcquireTokenPriv(LPCTSTR szPrivName)
{
	bool fAcquired = false;
	HANDLE hToken;
	TOKEN_PRIVILEGES tkp;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
	{
		// the the LUID for the shutdown privilege
		if (LookupPrivilegeValue(0, szPrivName, &tkp.Privileges[0].Luid))
		{
			tkp.PrivilegeCount = 1; // one privilege to set
			tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

			AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) 0, 0);
			fAcquired = true;
		}
		CloseHandle(hToken);
	}
	return fAcquired;
}

void AcquireTakeOwnershipPriv()
{
	if (g_fWin9X)
		return;

	static bool fAcquired = false;

	if (fAcquired)
		return;

	fAcquired = AcquireTokenPriv(SE_TAKE_OWNERSHIP_NAME);
}

void AcquireBackupPriv()
{
	if (g_fWin9X)
		return;
	
	static bool fAcquired = false;

	if (fAcquired)
		return;

	fAcquired = AcquireTokenPriv(SE_BACKUP_NAME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\migutil.cpp ===
#include <windows.h>
#include <tchar.h>
#include "msiregmv.h"

////
// Check that the string is actually a packed GUID and convert it to uppercase
bool CanonicalizeAndVerifyPackedGuid(LPTSTR szString)
{
	TCHAR *szCur = szString;
	for (int i=0; i < cchGUIDPacked; i++, szString++)
	{
		TCHAR chCur = *szString;
		if (chCur = 0)
			return false;
		if (chCur >= TEXT('0') && chCur <= TEXT('9'))
			continue;
		if (chCur >= TEXT('A') && chCur <= TEXT('F'))
			continue;
		if (chCur >= TEXT('a') && chCur <= TEXT('f'))
		{
			*szString = _toupper(chCur);
			continue;
		};
	}
	return (*szString == 0);
}

///////////////////////////////////////////////////////////////////////
// the following PackGUID and UnpackGUID are based on MSI functions
// in msinst, except these functions only create Packed GUIDs, not
// SQUIDs.
const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
									   21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 
const unsigned char rgOrderDash[4] = {9, 14, 19, 24};

bool PackGUID(const TCHAR* szGUID, TCHAR rgchPackedGUID[cchGUIDPacked+1])
{ 
	int cchTemp = 0;
	while (cchTemp < cchGUID)		// check if string is atleast cchGUID chars long,
		if (!(szGUID[cchTemp++]))		// can't use lstrlen as string doesn't HAVE to be null-terminated.
			return false;

	if (szGUID[0] != '{' || szGUID[cchGUID-1] != '}')
		return false;
	const unsigned char* pch = rgOrderGUID;

	int cChar = 0;
	while (pch < rgOrderGUID + sizeof(rgOrderGUID))
		rgchPackedGUID[cChar++] = szGUID[*pch++];
	rgchPackedGUID[cChar] = 0;
	return true;
}

bool UnpackGUID(const TCHAR rgchPackedGUID[cchGUIDPacked+1], TCHAR* szGUID)
{ 
	const unsigned char* pch;
	pch = rgOrderGUID;
	int i = 0;
	while (pch < rgOrderGUID + sizeof(rgOrderGUID))
		if (rgchPackedGUID[i])
			szGUID[*pch++] = rgchPackedGUID[i++];
		else              // unexpected end of string
			return false;
	pch = rgOrderDash;
	while (pch < rgOrderDash + sizeof(rgOrderDash))
		szGUID[*pch++] = '-';
	szGUID[0]         = '{';
	szGUID[cchGUID-1] = '}';
	szGUID[cchGUID]   = 0;
	return true;
}


///////////////////////////////////////////////////////////////////////
// checks the OS version to see if we're on Win9X for use during 
// migration information
bool CheckWinVersion() 
{
	g_fWin9X = false;
	OSVERSIONINFOA osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	if (!::GetVersionExA(&osviVersion))
	{
		return false;
	}
	if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		g_fWin9X = true;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\sources.inc ===
TARGETNAME=msiregmv
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=winmain

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS= \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE

USE_MSVCRT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR)

SOURCES= \
	..\msiregmv.cpp \
        ..\readcnfg.cpp \
        ..\writecfg.cpp \
        ..\migsecur.cpp \
        ..\cleanup.cpp \
        ..\migutil.cpp \
        ..\patch.cpp \
	..\msiregmv.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\patch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       patch.cpp
//
//--------------------------------------------------------------------------

#include "msiregmv.h"

////
// cached patch information
const TCHAR szOldPatchesKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches");
const TCHAR szOldPatchesSubKeyName[] = TEXT("Patches");
const TCHAR szOldPatchListValueName[] = TEXT("Patches");
const TCHAR szOldLocalPatchValueName[] = TEXT("LocalPackage");
const TCHAR szNewLocalPatchValueName[] = TEXT("LocalPackage");
const TCHAR szPatchExtension[] = TEXT(".msp");
const TCHAR szNewMigratedPatchesValueName[] = TEXT("MigratedPatches");

#define PID_TEMPLATE      7  // string


///////////////////////////////////////////////////////////////////////
// Reads patch application data from the provided old-format product
// key and inserts User/Product/Patch tuples into the PatchApply table
// Returns ERROR_SUCCESS, ERROR_FUNCTION_FAILED, ERROR_OUTOFMEMORY;
DWORD AddProductPatchesToPatchList(MSIHANDLE hDatabase, HKEY hProductListKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged)
{
	DWORD dwResult = ERROR_SUCCESS;

	HKEY hOldProductKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hProductListKey, rgchProduct, 
								   0, KEY_ENUMERATE_SUB_KEYS, &hOldProductKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no product key.
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG2("Error: Failed to open product key for product %s. Result: %d.", rgchProduct, dwResult);
			return ERROR_FUNCTION_FAILED;
		}
		return ERROR_SUCCESS;
	}

	// open the "patches" subkey under the old product registration. 
	HKEY hOldPatchesKey;
	dwResult = RegOpenKeyEx(hOldProductKey, szOldPatchesSubKeyName, 0, KEY_QUERY_VALUE, &hOldPatchesKey);
	RegCloseKey(hOldProductKey);
	if (ERROR_SUCCESS != dwResult)
	{
		// if the reason that this failed is that the key doesn't exist, no patches.		
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG2("Error: Failed to open local patches key for product %s. Result: %d.", rgchProduct, dwResult);
			return ERROR_FUNCTION_FAILED;
		}
		return ERROR_SUCCESS;
	}
			
	// query for a value with name=Patches
	DWORD cchPatchList = MEMORY_DEBUG(MAX_PATH);
	TCHAR *szPatchList = new TCHAR[cchPatchList];
	if (!szPatchList)
	{
		DEBUGMSG("Error: Out of memory.");
		RegCloseKey(hOldPatchesKey);
		return ERROR_OUTOFMEMORY;
	}

	// Patches value is arbitrary length REG_MULT_SZ containing patch codes.
	DWORD cbPatchList = cchPatchList*sizeof(TCHAR);
	if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hOldPatchesKey, szOldPatchListValueName, 0, NULL, reinterpret_cast<unsigned char*>(szPatchList), &cbPatchList)))
	{
		delete[] szPatchList;
		szPatchList = new TCHAR[cbPatchList/sizeof(TCHAR)];
		if (!szPatchList)
		{
			DEBUGMSG("Error: Out of memory.");
			RegCloseKey(hOldPatchesKey);
			return ERROR_OUTOFMEMORY;
		}
		dwResult = RegQueryValueEx(hOldPatchesKey, szOldPatchListValueName, 0, NULL, reinterpret_cast<unsigned char*>(szPatchList), &cbPatchList);
	}
	RegCloseKey(hOldPatchesKey);

	if (ERROR_SUCCESS == dwResult)
	{
		PMSIHANDLE hPatchView;
		if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `PatchApply`"), &hPatchView)) ||
			ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchView, 0)))
		{
			DEBUGMSG3("Error: Unable to create Patch insertion Query for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
			RegCloseKey(hOldPatchesKey);
			return ERROR_FUNCTION_FAILED;
		}

		PMSIHANDLE hInsertRec = MsiCreateRecord(4);
		MsiRecordSetString(hInsertRec, 1, szUser);
		MsiRecordSetString(hInsertRec, 2, rgchProduct);
		MsiRecordSetInteger(hInsertRec, 4, 1);

    	// loop through all patches in the patch list
		TCHAR* szNextPatch = szPatchList;
		while (szNextPatch && *szNextPatch)
		{
			TCHAR *szPatch = szNextPatch;

			// '\0' is never a valid lead byte, so no DBCS concerns here.
			while (*szNextPatch)
				szNextPatch++;
				
			// increment szNextPatch to the first character of the new patch.
			szNextPatch++;

			// check if the product is a valid guid
			if (!CanonicalizeAndVerifyPackedGuid(szPatch))
			{
				// patch code is not a valid packed GUID, skip to the next product
				DEBUGMSG3("Warning: Found invalid patch code %s for user %s, product %s. Skipping.", szPatch, szUser, rgchProduct);
				dwResult = ERROR_SUCCESS;
				continue;
			}

			MsiRecordSetString(hInsertRec, 3, szPatch);
			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hPatchView, MSIMODIFY_INSERT, hInsertRec)))
			{
				DEBUGMSG4("Warning: Failed to insert patch %s for user %s, product %s. Result: %d", szPatch, szUser, rgchProduct, dwResult);
				dwResult = ERROR_FUNCTION_FAILED;
				break;
			}
		}
	}
	else if (dwResult != ERROR_FILE_NOT_FOUND)
	{
		DEBUGMSG3("Error: Could not retrieve patch information for user %s, product %s. Result: %d. ", szUser, rgchProduct, dwResult);
	}
	else
		dwResult = ERROR_SUCCESS;

	delete[] szPatchList;
	return dwResult;
}


///////////////////////////////////////////////////////////////////////
// Given a patch code and user makes a copy of the cached patches for
// that user and registers the filenames under the per-user patch key. 
// Returns one of ERROR_SUCCESS and ERROR_OUTOFMEMORY. Does NOT return
// ERROR_FUNCTION_FAILED, as all patches are recachable from source.
DWORD MigrateUserPatches(MSIHANDLE hDatabase, LPCTSTR szUser, HKEY hNewPatchesKey, bool fCopyCachedPatches)
{	
	DWORD dwResult = ERROR_SUCCESS;

	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);
	MsiRecordSetString(hQueryRec, 1, szUser);

	// open query on the PatchApply table, which mapps users to products to patch codes
	PMSIHANDLE hPatchView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Patch` FROM `PatchApply` WHERE `User`=?"), &hPatchView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchView, hQueryRec)))
	{
		DEBUGMSG2("Warning: Unable to create Patch Query for user %s. Result: %d.", szUser, dwResult);
		return ERROR_SUCCESS;;
	}

	// open the old localpatch registry key containing cached patch filenames
	HKEY hOldLocalPatchKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldPatchesKeyName, 0, KEY_ENUMERATE_SUB_KEYS, &hOldLocalPatchKey)))
	{
		// if the reason that this failed is that the key doesn't exist, patch is missing. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Warning: Failed to open old patches key. Result: %d.", dwResult);
		}
		return ERROR_SUCCESS;
	}

	// create insert query for files that should be cleaned up on failure or success. If this fails
	// we'll just orphan a file if migration fails.
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `CleanupFile`"), &hCleanUpTable))
		dwResult = MsiViewExecute(hCleanUpTable, 0);

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// retrieve the installer directory for new cached files
	TCHAR rgchInstallerDir[MAX_PATH];
	GetWindowsDirectory(rgchInstallerDir, MAX_PATH);
	lstrcat(rgchInstallerDir, szInstallerDir);

	int iBasePathEnd = lstrlen(rgchInstallerDir);

	// create new full-path to patch
	TCHAR rgchPatchFullPath[MAX_PATH];
	lstrcpy(rgchPatchFullPath, rgchInstallerDir);

	// loop through the PatchApply table, retrieving patch codes relevant to this
	// user.
	PMSIHANDLE hPatch;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPatchView, &hPatch)))
	{
		// get the patch code from the result record
		TCHAR rgchPatchCode[cchGUIDPacked+1];
		DWORD cchPatchCode = cchGUIDPacked+1;
		if (ERROR_SUCCESS != MsiRecordGetString(hPatch, 1, rgchPatchCode, &cchPatchCode))
		{
			DEBUGMSG1("Warning: Unable to retrieve patch code for migration. Result: %d. Skipping.", dwResult);
			continue;
		}
    				
		NOTEMSG1("Migrating patch %s.", rgchPatchCode);

		// open the old patch key
		HKEY hOldPatchKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hOldLocalPatchKey, rgchPatchCode, 0, KEY_QUERY_VALUE, &hOldPatchKey)))
		{
			// if the reason that this failed is that the key doesn't exist, patch is missing.
			if (ERROR_FILE_NOT_FOUND != dwResult)
			{
				DEBUGMSG1("Warning: Failed to open local patch key. Result: %d.", dwResult);
			}
			continue;
		}

		// read the cache patch location
		DWORD cchFileName = MEMORY_DEBUG(MAX_PATH);
		TCHAR *szFileName = new TCHAR[cchFileName];
		DWORD cbFileName = cchFileName*sizeof(TCHAR);
		if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hOldPatchKey, szOldLocalPatchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szFileName), &cbFileName)))
		{
			delete[] szFileName;
			szFileName = new TCHAR[cbFileName/sizeof(TCHAR)];
			dwResult = RegQueryValueEx(hOldPatchKey, szOldLocalPatchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szFileName), &cbFileName);
		}
		RegCloseKey(hOldPatchKey);
		if (dwResult != ERROR_SUCCESS)
		{
			DEBUGMSG2("Warning: Failed to retrieve cached path for path %s. Result: %d.", rgchPatchCode, dwResult);
			continue;
		}


		// check for existance of cached patch and open the file
		HANDLE hSourceFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
		DWORD dwLastError = GetLastError();

		if(hSourceFile == INVALID_HANDLE_VALUE)
		{
			delete[] szFileName;
			if (dwLastError != ERROR_FILE_NOT_FOUND)
			{
				DEBUGMSG3("Warning: Unable to open cached patch %s for user %s. Result: %d.", rgchPatchCode, szUser, dwResult);
				continue;
			}
			else
				// patch is missing. No big deal.
				continue;
		}
	
		// create the new patch key under the per-user "Patches" key
		HKEY hPatchKey;
		if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hNewPatchesKey, rgchPatchCode, &sa, &hPatchKey)))
		{
			DEBUGMSG3("Warning: Unable to create new patch key for user %s, patch %s. Result: %d.", szUser, rgchPatchCode, dwResult);
			delete[] szFileName;
			continue;
		}

		// if we are supposed to copy the patch file, generate a temp name. Otherwise just register
		// the existing path
		TCHAR* szNewPatchFile = 0;
		if (fCopyCachedPatches)
		{
			// generated patch names are 8.3
			TCHAR rgchPatchFile[13];
			HANDLE hDestFile = INVALID_HANDLE_VALUE;
			GenerateSecureTempFile(rgchInstallerDir, szPatchExtension, &sa, rgchPatchFile, hDestFile);
	
			if (!CopyOpenedFile(hSourceFile, hDestFile))
			{
				DEBUGMSG2("Warning: Unable to copy cached patch %s for user %s.", rgchPatchCode, szUser);
			}
	
			CloseHandle(hSourceFile);
			CloseHandle(hDestFile);
	
			// add the new patch to the "delete on failure" list.
			lstrcpy(&rgchPatchFullPath[iBasePathEnd], rgchPatchFile);
			PMSIHANDLE hFileRec = MsiCreateRecord(2);
			MsiRecordSetString(hFileRec, 1, rgchPatchFullPath);
			MsiRecordSetInteger(hFileRec, 2, 0);
			MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);

			szNewPatchFile = rgchPatchFullPath;
		}
		else
			szNewPatchFile = szFileName;

		// set the new patch value
		if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hPatchKey, szNewLocalPatchValueName, 0, REG_SZ, 
				reinterpret_cast<unsigned char*>(szNewPatchFile), (lstrlen(szNewPatchFile)+1)*sizeof(TCHAR))))
		{
			DEBUGMSG3("Warning: Unable to create new LocalPackage value for user %s, patch %s. Result: %d.", szUser, szNewPatchFile, dwResult);
		}
		RegCloseKey(hPatchKey);

		delete[] szFileName;
	}

	RegCloseKey(hOldLocalPatchKey);

	return ERROR_SUCCESS;
}




///////////////////////////////////////////////////////////////////////
// Given a product code and user, checks for any "guessed" patch
// applications and registers the list of applicable patches under
// the InstallProperties key so they can be removed on uninstall. 
// Returns ERROR_SUCCESS or ERROR_OUTOFMEMORY. Doen NOT return
// ERROR_FUNCTION_FAILED, as failure merely orphans a patch until
// another product using the patch is installed.
DWORD MigrateUnknownProductPatches(MSIHANDLE hDatabase, HKEY hProductKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1])
{	
	DWORD dwResult = ERROR_SUCCESS;

	PMSIHANDLE hQueryRec = ::MsiCreateRecord(2);
	MsiRecordSetString(hQueryRec, 1, szUser);
	MsiRecordSetString(hQueryRec, 2, rgchProduct);

	// open query on the PatchApply table, which mapps users to products to patch codes. Search
	// for "guessed" application of a patch.
	PMSIHANDLE hPatchView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Patch` FROM `PatchApply` WHERE `User`=? AND `Product`=? AND `Known`=0"), &hPatchView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchView, hQueryRec)))
	{
		DEBUGMSG2("Warning: Unable to create Patch Query for user %s. Result: %d.", szUser, dwResult);
		return ERROR_SUCCESS;;
	}

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// query for at least one patch applied to this product that was a guess.
    PMSIHANDLE hPatch;
	if (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPatchView, &hPatch)))
	{
		PMSIHANDLE hGuessedPatchView;
		if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Patch` FROM `PatchApply` WHERE `User`=? AND `Product`=?"), &hGuessedPatchView)) ||
			ERROR_SUCCESS != (dwResult = MsiViewExecute(hGuessedPatchView, hQueryRec)))
		{
			DEBUGMSG2("Warning: Unable to create Patch Query for user %s. Result: %d.", szUser, dwResult);
			return ERROR_SUCCESS;;
		}

		// allocate initial buffer for patch list
		DWORD cchPatchList = 1;
		TCHAR *szPatchList = new TCHAR[cchPatchList];
		if (!szPatchList)
		{
			DEBUGMSG("Error: Out of memory.");
			return ERROR_OUTOFMEMORY;
		}
		DWORD cchNextPatchStart = 0;
		*szPatchList = 0;

		// loop through the PatchApply table, retrieving patch codes relevant to this
		// product that are guesses.
		while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hGuessedPatchView, &hPatch)))
		{
			// get the patch code from the result record
			TCHAR rgchPatchCode[cchGUIDPacked+1];
			DWORD cchPatchCode = cchGUIDPacked+1;
			if (ERROR_SUCCESS != MsiRecordGetString(hPatch, 1, rgchPatchCode, &cchPatchCode))
			{
				DEBUGMSG3("Warning: Unable to retrieve patch code for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
				continue;
			}

			// expand the patch list to hold the new patch
			TCHAR *szTempList = new TCHAR[cchPatchList+cchGUIDPacked+1];
			if (!szTempList)
			{
				delete[] szPatchList;
				DEBUGMSG("Error: Out of memory.");
				return ERROR_OUTOFMEMORY;
			}

			// copy the data over. Can contain embedded '\0' characters.
			for (DWORD i=0; i < cchPatchList; i++)
				szTempList[i] = szPatchList[i];
			
			delete[] szPatchList;
			cchPatchList += cchGUIDPacked+1;
			szPatchList = szTempList;

			// copy the new patch to the end of the list and ensure the double
			// '\0' exists at the end.
			lstrcpy(szPatchList+cchNextPatchStart, rgchPatchCode);
			cchNextPatchStart += cchGUIDPacked+1;
			*(szPatchList+cchNextPatchStart)='\0';
		}
	
		// if no patches were retrieved, the next patch is the beginning of the string. 
		// No need to write the MigratedPatches.
		if (cchNextPatchStart != 0)
		{
			// create the new InstallProperties key under the per-user "Patches" key
			HKEY hPropertiesKey;
			if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hProductKey, szNewInstallPropertiesSubKeyName, &sa, &hPropertiesKey)))
			{
				DEBUGMSG3("Unable to create new InstallProperties key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
			}
			else
			{
				// set the new patch value.
				DWORD cbPatchList = cchPatchList*sizeof(TCHAR);
				if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hPropertiesKey, szNewMigratedPatchesValueName, 0, REG_MULTI_SZ, 
						reinterpret_cast<unsigned char*>(szPatchList), cbPatchList)))
				{
					DEBUGMSG3("Unable to create new MigratedPatches value for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
				}
			}
			RegCloseKey(hPropertiesKey);
		}
		delete[] szPatchList;
	}

	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Reads the PatchUnknownApply table for patches that might (or might
// not) apply to non-managed products and inserts a row 
// in the PatchApply table for each potential application of 
// a patch (excluding the current user). Returns ERROR_SUCCESS, 
// ERROR_FUNCTION_FAILED, ERROR_OUTOFMEMORY
DWORD AddPerUserPossiblePatchesToPatchList(MSIHANDLE hDatabase)
{
	// read the Product table for products installed per user to
	// a different user
	PMSIHANDLE hProductView;
	PMSIHANDLE hQueryRec = MsiCreateRecord(1);
	TCHAR szSID[cchMaxSID];

	// if we can't retrieve the current users string SID, we'll just accidentally migrate
	// a few patches that we shouldn't. 
	DWORD dwResult = GetCurrentUserStringSID(szSID);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG("Warning: Unable to retrieve current user SID during patch migration.");
	}

	// create product selection query
	MsiRecordSetString(hQueryRec, 1, szSID);
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product`, `User`, 0, 0 FROM `Products` WHERE `Managed`=0 AND `User`<>?"), &hProductView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hProductView, hQueryRec)))
	{
		DEBUGMSG1("Error: Unable to create patch product query. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create patch selection query
	PMSIHANDLE hPatchUnknownView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Patch` FROM `PatchUnknownApply` WHERE `Product`=?"), &hPatchUnknownView)))
	{
		DEBUGMSG1("Error: Unable to create patch application query. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create insertion query. Columns selected in non-standard order to match product query above.
	PMSIHANDLE hPatchInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product`, `User`, `Patch`, `Known`  FROM `PatchApply`"), &hPatchInsertView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchInsertView, 0)))
	{
		DEBUGMSG1("Error: Unable to create Patch insertion Query. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hProduct;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hProductView, &hProduct)))
	{
		MsiViewExecute(hPatchUnknownView, hProduct);

		PMSIHANDLE hPatch;
		while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPatchUnknownView, &hPatch)))
		{
			TCHAR rgchPatch[cchGUIDPacked+1];
			DWORD cchPatch = cchGUIDPacked+1;
			MsiRecordGetString(hPatch, 1, rgchPatch, &cchPatch);
			MsiRecordSetString(hProduct, 3, rgchPatch);
			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hPatchInsertView, MSIMODIFY_INSERT, hProduct)))
			{
				DEBUGMSG2("Warning: Could not insert patch %s via assumed application. Result %d", rgchPatch, dwResult);
				continue;
			}
		}
	}
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Opens the old-style Patches key, reads the path to each cached
// patch, and opens the patch to get the ProductCodes that the patch
// applies to from the SummaryInfo. Inserts a row for each patch/product
// mapping into the PatchUnknownApply table. Returns ERROR_SUCCESS or
// ERROR_OUTOFMEMORY. Does not return ERROR_FUNCTION_FAILED, since
// failure to read this information only results in a lost patch.
DWORD ScanCachedPatchesForProducts(MSIHANDLE hDatabase)
{
	DWORD dwResult = ERROR_SUCCESS;

	// create old patch cache directory
	TCHAR rgchInstallerDir[MAX_PATH];
	GetWindowsDirectory(rgchInstallerDir, MAX_PATH);
	lstrcat(rgchInstallerDir, szInstallerDir);

	int iBasePathEnd = lstrlen(rgchInstallerDir);


	// create the PatchUnknownApply table.
	PMSIHANDLE hTableView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `PatchUnknownApply` (`Patch` CHAR(32) NOT NULL, `Product` CHAR(32) NOT NULL PRIMARY KEY `Patch`,`Product`)"), &hTableView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hTableView, 0)))
	{
		DEBUGMSG1("Error: Unable to create PatchUnknownApply table. Error %d", dwResult);
		return ERROR_SUCCESS;
	}

	// open the old patch key
	HKEY hOldPatchKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldPatchesKeyName, 0, KEY_ENUMERATE_SUB_KEYS, &hOldPatchKey)))
	{
		// if the reason that this failed is that the key doesn't exist, there are no patches
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Failed to open local patch key. Result: %d.", dwResult);
		}
		return ERROR_SUCCESS;
	}

	// create insert query for files that should be cleaned up on success. If this fails
	// we'll just orphan a file if migration fails.
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `CleanupFile`"), &hCleanUpTable))
		dwResult = MsiViewExecute(hCleanUpTable, 0);

	// open insert query on PatchUnknownApply
	PMSIHANDLE hPatchView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `PatchUnknownApply`"), &hPatchView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchView, 0)))
	{
		DEBUGMSG1("Error: Unable to create PatchUnknownApply insertion query. Result: %d.", dwResult);
		RegCloseKey(hOldPatchKey);
		return ERROR_SUCCESS;
	}

	PMSIHANDLE hInsertRec = MsiCreateRecord(2);

	// enumerate all cached patches
	DWORD dwKeyIndex = 0;
	while (1)
	{
		DWORD cchPatchCode = cchGUIDPacked+1;
		TCHAR rgchPatchCode[cchGUIDPacked+1];
		LONG lResult = RegEnumKeyEx(hOldPatchKey, dwKeyIndex++, rgchPatchCode, 
									&cchPatchCode, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// value is not a valid patch Id, skip it
			DEBUGMSG("Warning: Detected too-long pach code. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: Could not enumerate patches. Result: %l.", lResult);
			break;
		}

		// have a patch code, open its subkey.
		HKEY hPerPatchKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hOldPatchKey, rgchPatchCode, 0, KEY_QUERY_VALUE, &hPerPatchKey)))
		{
			if (ERROR_FILE_NOT_FOUND != dwResult)
			{
				DEBUGMSG2("Error: Failed to open patch key for %s. Result: %d. Skipping.", rgchPatchCode, dwResult);
			}
			continue;
		}
		else
		{
			MsiRecordSetString(hInsertRec, 1, rgchPatchCode);

			// read the cache patch location
			DWORD cchFileName = MEMORY_DEBUG(MAX_PATH);
			TCHAR *szFileName = new TCHAR[cchFileName];
			if (!szFileName)
			{
				DEBUGMSG("Error: Out of memory.");
				RegCloseKey(hPerPatchKey);
				RegCloseKey(hOldPatchKey);
				return ERROR_SUCCESS;
			}
			DWORD cbFileName = cchFileName*sizeof(TCHAR);
			if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hPerPatchKey, szOldLocalPatchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szFileName), &cbFileName)))
			{
				delete[] szFileName;
				szFileName = new TCHAR[cbFileName/sizeof(TCHAR)];
				if (!szFileName)
				{
					DEBUGMSG("Error: Out of memory.");
					RegCloseKey(hPerPatchKey);
					RegCloseKey(hOldPatchKey);
					return ERROR_SUCCESS;
				}
				dwResult = RegQueryValueEx(hPerPatchKey, szOldLocalPatchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szFileName), &cbFileName);
			}
			RegCloseKey(hPerPatchKey);
   			if (ERROR_SUCCESS != dwResult)
			{
				// if the LocalPackage value is missing, this is not an error, there
				// is simply no cached patch.
				if (ERROR_FILE_NOT_FOUND != dwResult)
				{
					DEBUGMSG2("Warning: Failed to retrieve local patch path for patch %s. Result %d. Skipping.", rgchPatchCode, dwResult);
				}
				continue;
			}

			// add the new transform to the "delete on success" list.
			PMSIHANDLE hFileRec = MsiCreateRecord(2);
			MsiRecordSetString(hFileRec, 1, szFileName);
			MsiRecordSetInteger(hFileRec, 2, 1);
			MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);


			// get the summaryinfo stream from the patch
			PMSIHANDLE hSummary;
            dwResult = MsiGetSummaryInformation(0, szFileName, 0, &hSummary);
			delete[] szFileName;

			if (ERROR_SUCCESS == dwResult)
			{
				// retrieve the list of product codes from the patch summaryinfo
				DWORD cchProductList = MEMORY_DEBUG(MAX_PATH);
				TCHAR *szProductList = new TCHAR[cchProductList];
				if (!szProductList)
				{
					DEBUGMSG("Error: Out of memory.");
					RegCloseKey(hOldPatchKey);
					return ERROR_SUCCESS;
				}
				if (ERROR_MORE_DATA == (dwResult = MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, NULL, NULL, NULL, szProductList, &cchProductList)))
				{
					delete[] szProductList;
					szProductList = new TCHAR[++cchProductList];
					if (!szProductList)
					{
						DEBUGMSG("Error: Out of memory.");
						RegCloseKey(hOldPatchKey);
						return ERROR_SUCCESS;
					}
					dwResult = MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, NULL, NULL, NULL, szProductList, &cchProductList);
				}

				if (ERROR_SUCCESS != dwResult)
				{
					delete[] szProductList;
					DEBUGMSG2("Warning: Unable to retrieve product list from cached patch %s. Result: %d. Skipping.", rgchPatchCode, dwResult);
					continue;
				}

				// loop through the product list, searching for semicolon delimiters
				TCHAR *szNextProduct = szProductList;
				while (szNextProduct && *szNextProduct)
				{
					TCHAR *szProduct = szNextProduct;

					// string should be all product codes (no DBCS). If there is
					// DBCS, its an invalid patch code anyway
					while (*szNextProduct && *szNextProduct != TEXT(';'))
						szNextProduct++;

					// if reached the null terminator, don't increment past it. But if
					// reached a semicolon, increment the next product pointer to the 
					// beginning of the actual product code.
					if (*szNextProduct)
						*(szNextProduct++)='\0';

					TCHAR rgchProduct[cchGUIDPacked+1];
					if (!PackGUID(szProduct, rgchProduct))
					{
						DEBUGMSG2("Warning: Invalid product code %s found in application list of patch %s. Skipping.", szProduct, rgchPatchCode);
						continue;
					}

					MsiRecordSetString(hInsertRec, 2, rgchProduct);

					if (ERROR_SUCCESS != (dwResult = MsiViewModify(hPatchView, MSIMODIFY_INSERT, hInsertRec)))
					{
						DEBUGMSG3("Warning: Failed to insert potential patch application for patch %s, product %s. Result: %d", rgchPatchCode, szProduct, dwResult);
						continue;
					}
				}
			
				delete[] szProductList;
			}
			// MSIHANDLES for SummaryInfo goes out of scope here
		}
	}

	RegCloseKey(hOldPatchKey);
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\msiregmv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msiregmv.h
//
//--------------------------------------------------------------------------

#pragma once
#include <windows.h>
#include <tchar.h>
#include "msiquery.h"

												  
// based off on values from winnt.h
const int cbMaxSID                   = sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD);
const int cchMaxSID                  = 256;
const int cchGUIDPacked = 32;
const int cchGUID = 38;

////
// miscellaneous functions
bool CanonicalizeAndVerifyPackedGuid(LPTSTR szString);
bool PackGUID(const TCHAR* szGUID, TCHAR rgchPackedGUID[cchGUIDPacked+1]);
bool UnpackGUID(const TCHAR rgchPackedGUID[cchGUIDPacked+1], TCHAR* szGUID);
bool CheckWinVersion();

////
// security functions
bool FIsKeyLocalSystemOrAdminOwned(HKEY hKey);
DWORD GetCurrentUserStringSID(TCHAR* szSID);
DWORD GetSecureSecurityDescriptor(char** pSecurityDescriptor);
DWORD GetEveryoneUpdateSecurityDescriptor(char** pSecurityDescriptor);

DWORD GenerateSecureTempFile(TCHAR* szDirectory, const TCHAR rgchExtension[5], 
							 SECURITY_ATTRIBUTES *pSA, TCHAR rgchFilename[13], HANDLE &hFile);

bool DeleteRegKeyAndSubKeys(HKEY hKey, const TCHAR *szSubKey);
BOOL CopyOpenedFile(HANDLE hSourceFile, HANDLE hDestFile);
DWORD CreateSecureRegKey(HKEY hParent, LPCTSTR szNewKey, SECURITY_ATTRIBUTES *sa, HKEY* hResKey);
void AcquireTakeOwnershipPriv();
void AcquireBackupPriv();


// enum for managed attribute
enum eManagedType
{
	emtNonManaged = 0,
	emtUserManaged = 1,
	emtMachineManaged = 2,
};

////
// debug information
void DebugOut(bool fDebugOut, LPCTSTR str, ...);

#ifdef DEBUG
#define DEBUGMSG(x) DebugOut(true, TEXT(x))
#define DEBUGMSG1(x,a) DebugOut(true, TEXT(x),a)
#define DEBUGMSG2(x,a,b) DebugOut(true, TEXT(x),a,b)
#define DEBUGMSG3(x,a,b,c) DebugOut(true, TEXT(x),a,b,c)
#define DEBUGMSG4(x,a,b,c,d) DebugOut(true, TEXT(x),a,b,c,d)

// basically just printf, but can easily be changed to write to 
// debug output by passing "true". Used for "notification" 
// messages that shouldn't be part of debug spooge.
#define NOTEMSG(x) DebugOut(false, TEXT(x))
#define NOTEMSG1(x,a) DebugOut(false, TEXT(x),a)

// all resizable buffers start out at this size in debug builds.
// set this to a small number to force reallocations
#define MEMORY_DEBUG(x) 10

#else
#define DEBUGMSG(x)
#define DEBUGMSG1(x,a)
#define DEBUGMSG2(x,a,b)
#define DEBUGMSG3(x,a,b,c)
#define DEBUGMSG4(x,a,b,c,d)
#define NOTEMSG(x)
#define NOTEMSG1(x,a)

#define MEMORY_DEBUG(x) x
#endif

DWORD ReadProductRegistrationDataIntoDatabase(TCHAR* szDatabase, MSIHANDLE& hDatabase, bool fReadHKCUAsSystem);
DWORD WriteProductRegistrationDataFromDatabase(MSIHANDLE hDatabase, bool fMigrateSharedDLL, bool fMigratePatches);
DWORD UpdateSharedDLLRefCounts(MSIHANDLE hDatabase);
DWORD ReadComponentRegistrationDataIntoDatabase(MSIHANDLE hDatabase);
DWORD MigrateUserOnlyComponentData(MSIHANDLE hDatabase);

extern bool g_fWin9X;

////
// cached data functions
DWORD MigrateCachedDataFromWin9X(MSIHANDLE hDatabase, HKEY hUserHKCUKey, HKEY hUserDataKey, LPCTSTR szUser);


////
// patch functions
DWORD AddProductPatchesToPatchList(MSIHANDLE hDatabase, HKEY hProductListKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged);
DWORD MigrateUnknownProductPatches(MSIHANDLE hDatabase, HKEY hProductKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1]);
DWORD MigrateUserPatches(MSIHANDLE hDatabase, LPCTSTR szUser, HKEY hNewPatchesKey, bool fCopyCachedPatches);
DWORD ScanCachedPatchesForProducts(MSIHANDLE hDatabase);
DWORD AddPerUserPossiblePatchesToPatchList(MSIHANDLE hDatabase);


////
// cleanup functions
void CleanupOnFailure(MSIHANDLE hDatabase);
void CleanupOnSuccess(MSIHANDLE hDatabase);


const TCHAR szLocalSystemSID[] = TEXT("S-1-5-18");
const TCHAR szCommonUserSID[] = TEXT("CommonUser");

const TCHAR szLocalPackagesKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages");

const TCHAR szManagedPackageKeyEnd[] = TEXT("(Managed)");
const DWORD cchManagedPackageKeyEnd = sizeof(szManagedPackageKeyEnd)/sizeof(TCHAR);


////
// product source registry keys
const TCHAR szPerMachineInstallKeyName[] = TEXT("Software\\Classes\\Installer\\Products");
const TCHAR szPerUserInstallKeyName[] = TEXT("Software\\Microsoft\\Installer\\Products");
const TCHAR szPerUserManagedInstallKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed");
const TCHAR szPerUserManagedInstallSubKeyName[] = TEXT("\\Installer\\Products");
const int cchPerUserManagedInstallKeyName = sizeof(szPerUserManagedInstallKeyName)/sizeof(TCHAR);
const DWORD cchPerUserManagedInstallSubKeyName = sizeof(szPerUserManagedInstallSubKeyName)/sizeof(TCHAR);
const TCHAR szNewProductSubKeyName[] = TEXT("Products");


////
// some generic paths used in multiple places
const TCHAR szNewInstallPropertiesSubKeyName[] = TEXT("InstallProperties");
const TCHAR szInstallerDir[] = TEXT("\\Installer\\");
const TCHAR szNewPatchesSubKeyName[] = TEXT("Patches");
const TCHAR szTransformsValueName[] = TEXT("Transforms");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\readcnfg.cpp ===
#include "msiregmv.h"

const TCHAR szSecureSubKeyName[] = TEXT("Secure");

////
// feature-usage registration information
const TCHAR szOldFeatureUsageKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Products");
const TCHAR szOldFeatureUsageValueName[] = TEXT("Usage");

////
// component registration information
const TCHAR szOldComponentKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components");


////
// feature-component registration information
const TCHAR szOldFeatureComponentKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Features");


bool g_fCommonUserIsSystemSID = false;

/////////////////////////
// Read component information from the Installer\Components key and places the Product,
// Component, Path, and Permanent bit into the temporary table for later query.
// returns ERROR_SUCCESS, ERROR_OUTOFMEMORY or ERROR_FUNCTION_FAILED
DWORD ReadComponentRegistrationDataIntoDatabase(MSIHANDLE hDatabase) 
{					 
	DEBUGMSG("Reading existing component registration data.");
	DWORD dwResult = ERROR_SUCCESS;

	// create the component table.
	PMSIHANDLE hView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `Component` (`Product` CHAR(32), `Component` CHAR(32) NOT NULL, `Path` CHAR(0), `SecondaryPath` CHAR(0) PRIMARY KEY `Product`, `Component`, `Path`)"), &hView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hView, 0)))
	{
		DEBUGMSG1("Error: Unable to create Component table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create SharedDLL table
	PMSIHANDLE hSharedDLLView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `SharedDLL` (`Path` CHAR(0) NOT NULL, `OldRefCount` INTEGER, `NewRefCount` INTEGER PRIMARY KEY `Path`)"), &hSharedDLLView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hSharedDLLView, 0)))
	{
		DEBUGMSG1("Error: Unable to create SharedDLL table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// open the old per-machine Installer\Components key for read.
	HKEY hComponentListKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldComponentKeyName,
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, 
												  &hComponentListKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open old per-machine component key. Result: %d. ", dwResult);
			return ERROR_FUNCTION_FAILED;
		}
		else
		{
			DEBUGMSG("No old per-machine component key. No components to migrate.");
			return ERROR_SUCCESS;
		}
	}

	////
	// check the ACL on the key to ensure that it is trustworthy.
	if (!g_fWin9X && !FIsKeyLocalSystemOrAdminOwned(hComponentListKey))
	{
		DEBUGMSG("Warning: Skipping old per-machine component key, key is not owned by Admin or System.");
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	////
	// open query for insert into table
	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `Component`"), &hInsertView)) ||
	    ERROR_SUCCESS != (dwResult = MsiViewExecute(hInsertView, 0)))
	{
		DEBUGMSG1("Error: Unable to create insert query on Component table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	////
	// open query for insert into SharedDLL Table
	PMSIHANDLE hRefCountInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `SharedDLL`"), &hRefCountInsertView)) ||
	    ERROR_SUCCESS != (dwResult = MsiViewExecute(hRefCountInsertView, 0)))
	{
		DEBUGMSG1("Error: Unable to create insert query on SharedDLL table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	////
	// open query for update of SharedDLL Table
	PMSIHANDLE hRefCountUpdateView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `OldRefCount` FROM `SharedDLL` WHERE `Path`=?"), &hRefCountUpdateView)))
	{
		DEBUGMSG1("Error: Unable to create update query on SharedDLL table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	DWORD dwIndex=0;
	PMSIHANDLE hInsertRec = ::MsiCreateRecord(5);
    while (1)
	{
		TCHAR rgchComponent[cchGUIDPacked+1];
		DWORD cchComponent = cchGUIDPacked+1;

		//// 
		// retrieve the next component subkey name
		LONG lResult = RegEnumKeyEx(hComponentListKey, dwIndex++, rgchComponent, 
									&cchComponent, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid GUID, skip to the next component key
			DEBUGMSG("Warning: Detected too-long component key. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: RegEnumKeyEx on per-machine component key returned %l.", lResult);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}
	 
		////
		// check if the component is a valid guid
		if ((cchComponent != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchComponent))
		{
			// key is not a valid GUID, skip to the next key
			DEBUGMSG1("Warning: Detected invalid component key: %s. Skipping.", rgchComponent);
			continue;
		}

		// store the component code in the record for later insertion
		MsiRecordSetString(hInsertRec, 2, rgchComponent);

		// open the subkey
		HKEY hComponentKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hComponentListKey, rgchComponent, 
										  0, KEY_QUERY_VALUE, &hComponentKey)))
		{
			DEBUGMSG2("Error: Could not open old per-machine component key for %s. Result: %d. Skipping component.", rgchComponent, dwResult);
			return ERROR_FUNCTION_FAILED;
		}

		DWORD cchMaxValueLen = 0;
		DWORD cValues = 0;
        if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hComponentKey, NULL, NULL, 0, 
											 NULL, NULL, NULL, &cValues, NULL, 
											 &cchMaxValueLen, NULL, NULL)))
		{
			DEBUGMSG2("Error: Could not retrieve key information for old per-machine component key %s. Result: %d. Skipping component.", rgchComponent, dwResult);
			RegCloseKey(hComponentKey);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}

		// if no products, skip
		if (cValues == 0)
		{
			RegCloseKey(hComponentKey);
			continue;
		}

		// allocate memory to grab the path from the registry
		TCHAR *szValue = new TCHAR[cchMaxValueLen];
		if (!szValue)
		{
			DEBUGMSG("Error: out of memory.");
			RegCloseKey(hComponentListKey);
			RegCloseKey(hComponentKey);
			return ERROR_OUTOFMEMORY;
		}
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;

		DWORD dwValueIndex = 0;
		while (1)
		{
			cchProduct = cchGUIDPacked+1;
			DWORD cbValue = cchMaxValueLen*sizeof(TCHAR);
			DWORD dwType = 0;
			LONG lResult = RegEnumValue(hComponentKey, dwValueIndex++, rgchProduct, 
										&cchProduct, 0, &dwType, reinterpret_cast<unsigned char*>(szValue), &cbValue);
			if (lResult == ERROR_MORE_DATA)
			{
				// value is not a valid ProductId, skip to the next ProductId
				DEBUGMSG1("Warning: Detected too-long product value for component %s. Skipping.", rgchComponent);
				continue;
			}
			else if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Error: Could not enumerate products for old per-machine component %s. Result: %d.", rgchComponent, dwResult);
				RegCloseKey(hComponentKey);
				RegCloseKey(hComponentListKey);
				delete[] szValue;
				return ERROR_FUNCTION_FAILED;
			}

			// if not reg-sz or reg-multi-sz, not a valid path registration
			if (dwType != REG_SZ && dwType != REG_MULTI_SZ)
			{
				DEBUGMSG1("Warning: Non-string registry value for component %s. Skipping.", rgchComponent);
				continue;
			}

			////
			// check if the product is a valid guid
			if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
			{
				// key is not a valid GUID, skip it
				DEBUGMSG2("Warning: Invalid product value %s for component %s. Skipping.", rgchProduct, rgchComponent);
				continue;
			}

			TCHAR *szSecondaryKeyPath = NULL;
			if (dwType == REG_MULTI_SZ)
			{
				// for MULTI_SZ the secondary keypath begins one NULL after the end
				// of the primary keypath
				szSecondaryKeyPath = szValue + lstrlen(szValue)+1;
			}

			////
			// check for sharedDLL information. If the paths differ in case, it 
			// doesn't matter too much because the update algorithm can handle
			// updating the same key twice with two different deltas. Must do
			// this before trashing szValue for dummy permanent product IDs.

			// Future: if ANSI builds, can we have DBCS drive letters?
			if (szValue[0] != '\0' && szValue[1] == TEXT('?'))
			{
				PMSIHANDLE hSharedDLLRec = MsiCreateRecord(3);
				MsiRecordSetString(hSharedDLLRec, 1, szValue);
				MsiRecordSetInteger(hSharedDLLRec, 2, 1);
				MsiRecordSetInteger(hSharedDLLRec, 3, 0);

				if (ERROR_SUCCESS != MsiViewModify(hRefCountInsertView, MSIMODIFY_INSERT, hSharedDLLRec))
				{
					// record might already exist
					if (ERROR_SUCCESS != (dwResult = MsiViewExecute(hRefCountUpdateView, hSharedDLLRec)) ||
						ERROR_SUCCESS != (dwResult = MsiViewFetch(hRefCountUpdateView, &hSharedDLLRec)))
					{
						DEBUGMSG3("Error: Unable to insert SharedDLL data for component %s, product %s into SharedDLL table. Error %d", rgchComponent, rgchProduct, dwResult);
						delete[] szValue;
						RegCloseKey(hComponentKey);
						RegCloseKey(hComponentListKey);
						return ERROR_FUNCTION_FAILED;
					}

					// increment the existing old SharedDLL cont for this path
					MsiRecordSetInteger(hSharedDLLRec, 1, MsiRecordGetInteger(hSharedDLLRec, 1)+1);
					if (ERROR_SUCCESS != (dwResult = MsiViewModify(hRefCountUpdateView, MSIMODIFY_UPDATE, hSharedDLLRec)))
					{
						DEBUGMSG3("Error: Unable to insert SharedDLL data for component %s, product %s into SharedDLL table. Error %d", rgchComponent, rgchProduct, dwResult);
						delete[] szValue;
						RegCloseKey(hComponentKey);
						RegCloseKey(hComponentListKey);
						return ERROR_FUNCTION_FAILED;
					}
				}
			}

			// if the productId is actually a GUID <= 255, its a dummy product 
			// for permanent components. the actual GUID is uninteresting and is set to NULL
			if (CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT, 0, rgchProduct, 30, TEXT("000000000000000000000000000000"), 30))
			{
				rgchProduct[0] = TEXT('\0');
			}

			MsiRecordSetString(hInsertRec, 1, rgchProduct);
			MsiRecordSetString(hInsertRec, 3, szValue);
			MsiRecordSetString(hInsertRec, 4, szSecondaryKeyPath);
			MsiRecordSetString(hInsertRec, 5, 0);

			if (ERROR_SUCCESS != (dwResult != MsiViewModify(hInsertView, MSIMODIFY_INSERT, hInsertRec)))
			{
				DEBUGMSG3("Error: Unable to insert data for component %s, product %s into Component table. Error %d", rgchComponent, rgchProduct, dwResult);
				delete[] szValue;
				RegCloseKey(hComponentKey);
				RegCloseKey(hComponentListKey);
				return ERROR_FUNCTION_FAILED;
			}

		}

		// cleanup memory
		delete[] szValue;
		szValue = NULL;

		RegCloseKey(hComponentKey);
	}
	RegCloseKey(hComponentListKey);

	return ERROR_SUCCESS;
}
					 

/////////////////
// reads the feature-component mappings from the registry into the FeatureComponent 
// table of the temporary database. Returns ERROR_SUCCESS, ERROR_FUNCTION_FAILED, or
// ERROR_OUT_OF_MEMORY
DWORD ReadFeatureRegistrationDataIntoDatabase(MSIHANDLE hDatabase) 
{					 
	DEBUGMSG("Reading existing feature registration data.");

	PMSIHANDLE hView;
	DWORD dwResult = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `FeatureComponent` (`Product` CHAR(32) NOT NULL, `Feature` CHAR(0) NOT NULL, `Components` CHAR(0) PRIMARY KEY `Product`, `Feature`)"), &hView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hView, 0)))
	{
		DEBUGMSG1("Error: Unable to create FeatureComponent table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	HKEY hFeatureListKey;
 	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldFeatureComponentKeyName,
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, 
												  &hFeatureListKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open old per-machine feature key. Result: %d. ", dwResult);
			return ERROR_FUNCTION_FAILED;
		}
		else
		{
			DEBUGMSG("No old per-machine feature key. No products to migrate.");
			return ERROR_SUCCESS;
		}
	}

	////
	// check the ACL on the key to ensure that it is trustworthy.
	if (!g_fWin9X && !FIsKeyLocalSystemOrAdminOwned(hFeatureListKey))
	{
		DEBUGMSG("Warning: Skipping old per-machine feature key, key is not owned by Admin or System.");
		RegCloseKey(hFeatureListKey);
		return ERROR_FUNCTION_FAILED;
	}

	////
	// open query for insert into table
	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `FeatureComponent`"), &hInsertView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hInsertView, 0)))
	{
		DEBUGMSG1("Error: Unable to create insert query for FeatureComponent table. Error %d", dwResult);
		RegCloseKey(hFeatureListKey);
		return ERROR_FUNCTION_FAILED;
	}

	DWORD dwIndex=0;
	PMSIHANDLE hInsertRec = ::MsiCreateRecord(3);
    while (1)
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;

		//// 
		// retrieve the next product subkey name
		LONG lResult = RegEnumKeyEx(hFeatureListKey, dwIndex++, rgchProduct, 
									&cchProduct, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid GUID, skip to the next product key
			DEBUGMSG("Warning: Detected too-long product value. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: RegEnumKeyEx on old feature key returned %l.", lResult);
			RegCloseKey(hFeatureListKey);
			return ERROR_FUNCTION_FAILED;
		}
	 
		////
		// check if the product is a valid guid
		if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
		{
			// key is not a valid GUID, skip to the next key. Warn if not "Secure" key.
			if (lstrcmpi(rgchProduct, szSecureSubKeyName))
			{
				DEBUGMSG1("Warning: Detected non-product subkey %s. Skipping.", rgchProduct);
			}
			continue;
		}

		// store the product code in the record for later insertion
		MsiRecordSetString(hInsertRec, 1, rgchProduct);

		// open the subkey
		HKEY hProductKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hFeatureListKey, rgchProduct, 
										  0, KEY_QUERY_VALUE, &hProductKey)))
		{
			DEBUGMSG2("Error: Could not open old feature key for product %s. Result: %d.", rgchProduct, dwResult);
			RegCloseKey(hFeatureListKey);
			return ERROR_FUNCTION_FAILED;
		}

		DWORD cbMaxValueLen = 0;
        DWORD cchMaxNameLen = 0;
		DWORD cValues = 0;
		if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hProductKey, NULL, NULL, 0, 
											 NULL, NULL, NULL, &cValues, &cchMaxNameLen, 
											 &cbMaxValueLen, NULL, NULL)))
		{
			DEBUGMSG2("Error: Could not retrieve key information for old feature key for product %s. Result: %d. ", rgchProduct, dwResult);
			RegCloseKey(hProductKey);
			RegCloseKey(hFeatureListKey);
			return ERROR_FUNCTION_FAILED;
		}

		// if no features, skip subkey
		if (cValues == 0)
		{
			RegCloseKey(hProductKey);
			continue;
		}

		TCHAR *szValue = new TCHAR[cbMaxValueLen/sizeof(TCHAR)];
		if (!szValue)
		{
			DEBUGMSG("Error: out of memory.");
			RegCloseKey(hProductKey);
			RegCloseKey(hFeatureListKey);
			return ERROR_OUTOFMEMORY;
		}

		// QueryInfoKey length does not include terminating '\0' for value names.
		TCHAR *szName = new TCHAR[++cchMaxNameLen];
		if (!szName)
		{
			DEBUGMSG("Error: out of memory.");
			RegCloseKey(hProductKey);
			RegCloseKey(hFeatureListKey);
			delete[] szValue;
			return ERROR_OUTOFMEMORY;
		}

		// enumerate through all feature values for this product
		DWORD dwValueIndex = 0;
		while (1)
		{
			DWORD cbValue = cbMaxValueLen;
			DWORD cchValueName = cchMaxNameLen;
			LONG lResult = RegEnumValue(hProductKey, dwValueIndex++, szName, 
										&cchValueName, 0, NULL, reinterpret_cast<unsigned char*>(szValue), &cbValue);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Error: Could not enumerate features for product %s. Result: %d.", rgchProduct, dwResult);
				RegCloseKey(hProductKey);
				RegCloseKey(hFeatureListKey);
				delete[] szValue;
				delete[] szName;
				return ERROR_FUNCTION_FAILED;
			}

			MsiRecordSetString(hInsertRec, 2, szName);
			MsiRecordSetString(hInsertRec, 3, szValue);

			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hInsertView, MSIMODIFY_INSERT, hInsertRec)))
			{
				DEBUGMSG3("Error: could not insert feature data for product %s, feature %s. Result: %d", rgchProduct, szName, dwResult);
				RegCloseKey(hProductKey);
				RegCloseKey(hFeatureListKey);
				delete[] szValue;
				delete[] szName;
				return ERROR_FUNCTION_FAILED;
			}
		}

		// cleanup memory
		delete[] szValue;
		delete[] szName;
		szValue = NULL;
		szName = NULL;
	
		RegCloseKey(hProductKey);
	}
	RegCloseKey(hFeatureListKey);

	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// reads the feature usage information from the registry into the FeatureUsage 
// table of the temporary database. Returns ERROR_SUCCESS or ERROR_OUTOFMEMORY.
// does not return ERROR_FUNCTION_FAILED, as feature usage data is useless anyway.
DWORD ReadFeatureUsageDataIntoDatabase(MSIHANDLE hDatabase) 
{					 
	DEBUGMSG("Reading existing feature usage data.");

	PMSIHANDLE hView;
	DWORD dwResult = ERROR_SUCCESS;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `FeatureUsage` (`Product` CHAR(32) NOT NULL, `Feature` CHAR(0) NOT NULL, `Usage` LONG PRIMARY KEY `Product`, `Feature`)"), &hView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hView, 0)))
	{
		DEBUGMSG1("Error: Unable to create FeatureUsage table. Error %d", dwResult);
		return ERROR_SUCCESS;
	}

	HKEY hFeatureListKey;
 	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldFeatureUsageKeyName,
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, 
												  &hFeatureListKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open old feature usage key. Result: %d. ", dwResult);
		}
		else
		{
			DEBUGMSG("No old feature usage key to migrate.");
		}
		return ERROR_SUCCESS;
	}

	////
	// check the ACL on the key to ensure that it is trustworthy.
	if (!g_fWin9X && !FIsKeyLocalSystemOrAdminOwned(hFeatureListKey))
	{
		DEBUGMSG("Skipping old feature usage key, key is not owned by Admin or System.");
		RegCloseKey(hFeatureListKey);
		return ERROR_SUCCESS;
	}

	////
	// open query for insert into table
	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `FeatureUsage`"), &hInsertView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hInsertView, 0)))
	{
		RegCloseKey(hFeatureListKey);
		DEBUGMSG1("Error: Unable to create insert query for FeatureUsage table. Error %d", dwResult);
		return ERROR_SUCCESS;
	}


	DWORD dwIndex=0;
	PMSIHANDLE hInsertRec = ::MsiCreateRecord(3);
    while (1)
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;

		//// 
		// retrieve the next product subkey name
		LONG lResult = RegEnumKeyEx(hFeatureListKey, dwIndex++, rgchProduct, 
									&cchProduct, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid GUID, skip to the next product key
			DEBUGMSG("Warning: Detected too-long product value. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: RegEnumKeyEx on old feature usage key returned %l.", lResult);
			RegCloseKey(hFeatureListKey);
			return ERROR_SUCCESS;
		}
	 
		////
		// check if the product is a valid guid
		if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
		{
			// key is not a valid GUID, skip to the next key
			if (lstrcmpi(rgchProduct, szSecureSubKeyName))
			{
				DEBUGMSG1("Warning: Detected non-product subkey %s. Skipping.", rgchProduct);
			}
			continue;
		}

		// store the product code in the record for later insertion
		MsiRecordSetString(hInsertRec, 1, rgchProduct);

		// open the subkey. Although we don't actually query any values, retrieving key info (longest subkey, etc)
		// requires KEY_QUERY_VALUE access.
		HKEY hProductKey;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hFeatureListKey, rgchProduct, 
										  0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hProductKey)))
		{
			DEBUGMSG2("Error: Could not open old feature usage key for %s. Result: %d. Skipping", rgchProduct, dwResult);
			continue;
		}

		DWORD cchMaxKeyLen = 0;
		DWORD cSubKeys = 0;
		if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hProductKey, NULL, NULL, 0, 
											 &cSubKeys, &cchMaxKeyLen, NULL, NULL, NULL, 
											 NULL, NULL, NULL)))
		{
			RegCloseKey(hProductKey);
			DEBUGMSG2("Error: Could not retrieve key information for old feature usage key for %s. Result: %d. ", rgchProduct, dwResult);
			continue;
		}

		if (cSubKeys == 0)
		{
			RegCloseKey(hProductKey);
			continue;
		}

		TCHAR *szFeature = new TCHAR[++cchMaxKeyLen];
		if (!szFeature)
		{
			DEBUGMSG("Error: Out of memory");
			RegCloseKey(hFeatureListKey);
			return ERROR_OUTOFMEMORY;
		}

		DWORD dwKeyIndex = 0;
		while (1)
		{
			DWORD cchKeyName = cchMaxKeyLen;
			DWORD dwFeatureUsage = 0;
			DWORD cbValue = sizeof(dwFeatureUsage);
			LONG lResult = RegEnumKeyEx(hProductKey, dwKeyIndex++, szFeature, &cchKeyName, 0, NULL, NULL, NULL);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Error: Could not enumerate feature usage for product %s. Result: %d.", rgchProduct, dwResult);
				break;
			}

			HKEY hFeatureKey;
			if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hProductKey, szFeature, 0, KEY_QUERY_VALUE, &hFeatureKey)))
			{
				DEBUGMSG3("Error: Could not open old feature usage key for %s, %s. Result: %d. ", rgchProduct, szFeature, dwResult);
				continue;
			}

			if (ERROR_SUCCESS != (dwResult = RegQueryValueEx(hFeatureKey, szOldFeatureUsageValueName, 0, NULL, reinterpret_cast<unsigned char*>(&dwFeatureUsage), &cbValue)))
			{
				RegCloseKey(hFeatureKey);
				if (dwResult != ERROR_FILE_NOT_FOUND)
				{
					DEBUGMSG3("Error: Could not retrieve usage information for old %s, %s. Result: %d. ", rgchProduct, szFeature, dwResult);
				}
				continue;
				
			}
			RegCloseKey(hFeatureKey);

			MsiRecordSetString(hInsertRec, 2, szFeature);
			MsiRecordSetInteger(hInsertRec, 3, dwFeatureUsage);

			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hInsertView, MSIMODIFY_INSERT, hInsertRec)))
			{
				DEBUGMSG3("Error: could not insert feature usage data for product %s, feature %s. Result: %d", rgchProduct, szFeature, dwResult);
			}
		}

		// cleanup memory
		delete[] szFeature;
		szFeature = NULL;
	
		RegCloseKey(hProductKey);
	}
	RegCloseKey(hFeatureListKey);

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Reads the provided product-list registry key and adds the product and patch 
// to the temporary database. Returns one of ERROR_SUCCESS, ERROR_FUNCTION_FAILED,
// or ERROR_OUTOFMEMORY
DWORD ReadProductInstallKey(MSIHANDLE hDatabase, HKEY hKey, LPCTSTR szSID, MSIHANDLE hInsertView, eManagedType eManaged)
{
    PMSIHANDLE hInsertRec = MsiCreateRecord(3);
	MsiRecordSetString(hInsertRec, 1, szSID);
	MsiRecordSetInteger(hInsertRec, 3, eManaged);
	
	// Add all products to the list. 
	DWORD dwIndex=0;
	while (1)
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;
		
		// retrieve the next product subkey name
		LONG lResult = RegEnumKeyEx(hKey, dwIndex++, rgchProduct, 
								 &cchProduct, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid packed GUID, skip to the next product
			DEBUGMSG("Warning: Detected too-long product value. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG2("Error: Could not enumerate product subkeys for %s. Result: %l. ", szSID, lResult);
			return ERROR_FUNCTION_FAILED;
		}
		
		////
		// check if the product is a valid guid
		if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
		{
			// key is not a valid packed GUID, skip to the next product
			DEBUGMSG2("Warning: Key %s for user %s is not a valid product. Skipping.", rgchProduct, szSID);
			continue;
		}
		
		// store the product code in the record
		MsiRecordSetString(hInsertRec, 2, rgchProduct);

		// most likely failure is that the product is already added for this user by another
		// install type.
		MsiViewModify(hInsertView, MSIMODIFY_INSERT, hInsertRec);

		DWORD dwResult = ERROR_SUCCESS;
		if (ERROR_SUCCESS != (dwResult = AddProductPatchesToPatchList(hDatabase, hKey, szSID, rgchProduct, eManaged)))
			return dwResult;
	}
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Reads HKCU registry key for per user installs for the current user 
// and adds them to the database. Returns ERROR_SUCCESS, 
// ERROR_FUNCTION_FAILED, or ERROR_OUTOFMEMORY
DWORD ReadLocalPackagesKey(HKEY hKey, MSIHANDLE hInsertView)
{
    PMSIHANDLE hInsertRec = MsiCreateRecord(3);
	TCHAR rgchProduct[cchGUIDPacked+1];

	// enumerate each product key under the LocalPackages key
	DWORD dwIndex = 0;
	while(1)
	{
		// retrieve the next product subkey name
		DWORD cchProduct = cchGUIDPacked+1;
		LONG lResult = RegEnumKeyEx(hKey, dwIndex++, rgchProduct, 
								 &cchProduct, 0, NULL, NULL, NULL);
		if (lResult == ERROR_MORE_DATA)
		{
			// key is not a valid packed GUID, skip to the next product
			DEBUGMSG("Warning: Detected too-long product value. Skipping.");
			continue;
		}
		else if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG1("Error: Could not enumerate product subkeys for LocalPackages Key. Result: %l. ", lResult);
			return ERROR_FUNCTION_FAILED;
		}
		
		////
		// check if the product is a valid guid
		if ((cchProduct != cchGUIDPacked) || !CanonicalizeAndVerifyPackedGuid(rgchProduct))
		{
			// key is not a valid packed GUID, skip to the next product
			DEBUGMSG1("Warning: Key %s for LocalPackages is not a valid product. Skipping.", rgchProduct);
			continue;
		}
		
		// store the product code in the record
		MsiRecordSetString(hInsertRec, 2, rgchProduct);

    	// open the subkey
		HKEY hProductKey;
		DWORD dwResult = ERROR_SUCCESS;
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hKey, rgchProduct, 
										  0, KEY_QUERY_VALUE, &hProductKey)))
		{
			DEBUGMSG2("Error: Could not open old localpackages key for %s. Result: %d. ", rgchProduct, dwResult);
			return ERROR_FUNCTION_FAILED;
		}

		DWORD cchMaxValueNameLen = 0;
		DWORD cValues = 0;
        if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hProductKey, NULL, NULL, 0, 
											 NULL, NULL, NULL, &cValues, &cchMaxValueNameLen, 
											 NULL, NULL, NULL)))
		{
			DEBUGMSG2("Error: Could not retrieve key information for localpackages key %s. Result: %d. ", rgchProduct, dwResult);
			RegCloseKey(hProductKey);
			return ERROR_FUNCTION_FAILED;
		}

		// if no values, skip
		if (cValues == 0)
		{
			RegCloseKey(hProductKey);
			continue;
		}

		TCHAR *szName = new TCHAR[++cchMaxValueNameLen];
		if (!szName)
		{
			DEBUGMSG("Error: Out of memory");
			RegCloseKey(hProductKey);
			return ERROR_OUTOFMEMORY;
		}

		DWORD dwValueIndex = 0;
		while (1)
		{
			DWORD cchName = cchMaxValueNameLen;
			LONG lResult = RegEnumValue(hProductKey, dwValueIndex++, szName, 
										&cchName, 0, NULL, NULL, NULL);
			if (lResult == ERROR_NO_MORE_ITEMS)
			{
				break;
			}
			else if (lResult != ERROR_SUCCESS)
			{
				DEBUGMSG2("Could not enumerate users for product %s. Result: %d.", rgchProduct, lResult);
				delete[] szName;
				RegCloseKey(hProductKey);
				return ERROR_FUNCTION_FAILED;
			}
 
			// asume non-managed product.
			eManagedType eManaged = emtNonManaged;

			// if the SID is the machine SID, its a managed app.
			if (0 == lstrcmp(szName, szLocalSystemSID))
			{
				eManaged = emtMachineManaged;
			}
			else
			{
				// check if the name ends in "(Managed)" and strip it if it does, setting
				// the managed flag as appropriate
				int cchCount = lstrlen(szName) - cchManagedPackageKeyEnd + 1;
				if (cchCount > 0 && (0 == lstrcmp(szName + cchCount, szManagedPackageKeyEnd)))
				{
					eManaged = emtUserManaged;
					*(szName+cchCount) = 0;
				}
				else
					eManaged = emtNonManaged;
			}

			MsiRecordSetInteger(hInsertRec, 3, eManaged);
			MsiRecordSetString(hInsertRec, 1, szName);

			// most common failure is that the product already exists. All other
			// failures should be ignored.
			MsiViewModify(hInsertView, MSIMODIFY_MERGE, hInsertRec);
		}
		RegCloseKey(hProductKey);
		delete[] szName;
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// build a mapping from product to user based on all available
// information, including explicit product registration information
// stored in Managed hives, per-user installs under HKCU, and cached
// package identification under the LocalPackages key. This will not
// catch per-user non-managed installs for the non-current user if the
// package was never successfully recached by 1.1.
DWORD BuildUserProductMapping(MSIHANDLE hDatabase, bool fReadHKCUAsSystem)
{
	DEBUGMSG("Reading product install information.");
	DWORD dwResult = ERROR_SUCCESS;

	PMSIHANDLE hView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `Products` (`User` CHAR(0) NOT NULL, `Product` CHAR(32) NOT NULL, `Managed` INTEGER PRIMARY KEY `User`, `Product`)"), &hView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hView, 0)))
	{
		DEBUGMSG1("Error: Unable to create Products table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hPatchTable;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `PatchApply` (`User` CHAR(0) NOT NULL, `Product` CHAR(32) NOT NULL, `Patch` CHAR(32) NOT NULL, `Known` INTEGER PRIMARY KEY `User`, `Product`, `Patch`)"), &hPatchTable)) ||
	ERROR_SUCCESS != (dwResult = MsiViewExecute(hPatchTable, 0)))
	{
		DEBUGMSG1("Error: Unable to create PatchApply table. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hInsertView;
	if (ERROR_SUCCESS != MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `Products`"), &hInsertView))
	{
		DEBUGMSG1("Error: Unable to create insert query for Products table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// user to product mappings come from four locations:
	// 1. Per-Machine installed apps
	// 2. Installer\Managed for per-user managed apps
	// 3. HKCU for the current user non-managed
	// 4. CachedPackage List
	HKEY hKey = 0;

	////
	// 1. Per-Machine installed apps. On Win9X upgrades these are per-machine
	if (ERROR_SUCCESS == (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerMachineInstallKeyName, 
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey)))
	{
		// ACL on this key does matter
		if (FIsKeyLocalSystemOrAdminOwned(hKey))
		{
			if (ERROR_SUCCESS != (dwResult = ReadProductInstallKey(hDatabase, hKey, szLocalSystemSID, hInsertView, emtMachineManaged)))
			{
				RegCloseKey(hKey);
				return dwResult;
			}
		}
		else
		{
			DEBUGMSG("Warning: Skipping per-machine installer key, key is not owned by Admin or System.");
		}
		
		RegCloseKey(hKey);
	}
	else
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So we can
		// continue. Otherwise failure.
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open per-machine installer key. Result: %d.", dwResult);
			return ERROR_FUNCTION_FAILED;
		}
	}


	////
	// 2. Installer\Managed for per-user managed apps, but not on Win9X
	if (!g_fWin9X)
	{
		// Although we don't actually query any values, retrieving key info (longest subkey, etc)
		// requires KEY_QUERY_VALUE access.
		if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerUserManagedInstallKeyName, 
													  0, READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hKey)))
		{
			// if the reason that this failed is that the key doesn't exist, no products are installed.
			// This is not a catastrophic failure.
			if (ERROR_FILE_NOT_FOUND != dwResult)
			{
				DEBUGMSG1("Error: Failed to open per-user managed key. Result: %d.", dwResult);
				return ERROR_FUNCTION_FAILED;
			}
		}
		else
		{
			// ACL on this key does matter. If its not owned by LocalSystem or Admins, the
			// information can't be trusted.
			if (!g_fWin9X && FIsKeyLocalSystemOrAdminOwned(hKey))
			{
				// enumerate each user SID under the Managed key
				DWORD cchMaxKeyLen = 0;
				DWORD cSubKeys = 0;
				if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hKey, NULL, NULL, 0, &cSubKeys, 
													 &cchMaxKeyLen, NULL, NULL, NULL, 
													 NULL, NULL, NULL)))
				{
					DEBUGMSG1("Error: Could not retrieve key information for per-user managed. Result: %d. ", dwResult);
					return ERROR_FUNCTION_FAILED;
				}
				else if (cSubKeys)
				{
					// on NT, cchMaxKeyLen does not include terminating NULL for the
					// longest subkey name.
					cchMaxKeyLen++;
					TCHAR *szUser = new TCHAR[cchMaxKeyLen];
					if (!szUser)
					{
						DEBUGMSG("Error: Out of memory");
						RegCloseKey(hKey);
						return ERROR_OUTOFMEMORY;
					}
					
					// the user key name is the user SID plus Installer\Products
					TCHAR *szUserKey = new TCHAR[cchMaxKeyLen+sizeof(szPerUserManagedInstallSubKeyName)];
					if (!szUserKey)
					{
						DEBUGMSG("Error: Out of memory");
						RegCloseKey(hKey);
						delete[] szUser;
						return ERROR_OUTOFMEMORY;
					}
					
					DWORD dwKeyIndex = 0;
					while (1)
					{
						DWORD cchUser = cchMaxKeyLen;
						LONG lResult = RegEnumKeyEx(hKey, dwKeyIndex++, szUser, 
													&cchUser, 0, NULL, NULL, NULL);
						if (lResult == ERROR_NO_MORE_ITEMS)
						{
							break;
						}
						else if (lResult != ERROR_SUCCESS)
						{
							DEBUGMSG1("Error: Could not enumerate users for per-user managed key. Result: %l.", lResult);
							RegCloseKey(hKey);
							delete[] szUser;
							delete[] szUserKey;
							return ERROR_FUNCTION_FAILED;
						}
			
						// have a user SID
						HKEY hPerUserKey;
						lstrcpy(szUserKey, szUser);
						lstrcat(szUserKey, szPerUserManagedInstallSubKeyName);
						if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hKey, szUserKey, 0, KEY_ENUMERATE_SUB_KEYS, &hPerUserKey)))
						{
							// if the reason that this failed is that the key doesn't exist, no products are installed.
							// this is not a catastrophic failure.
							if (ERROR_FILE_NOT_FOUND != dwResult)
							{
								DEBUGMSG2("Error: Failed to open per-user managed key for %s. Result: %d.", szUser, dwResult);
								delete[] szUser;
								delete[] szUserKey;
								RegCloseKey(hKey);
								return ERROR_FUNCTION_FAILED;
							}
						}
						else
						{
							dwResult = ReadProductInstallKey(hDatabase, hPerUserKey, szUser, hInsertView, emtUserManaged);
							if (ERROR_SUCCESS != dwResult)
							{
								delete[] szUser;
								delete[] szUserKey;
								RegCloseKey(hKey);
								return dwResult;
							}
						}
					}
					delete[] szUser;
					delete[] szUserKey;
				}
			}
			else
			{
				DEBUGMSG("Warning: Skipping per-user managed installer key, key is not owned by Admin or System.");
			}
			RegCloseKey(hKey);
		}
	}

	////
	// 3. HKCU for the current user non-managed. Read on Win9X 
	// only if profiles are not enabled (so HKCU is actually per-machine)
	if (!g_fWin9X || fReadHKCUAsSystem)
	{
		TCHAR szSID[cchMaxSID];
		if (fReadHKCUAsSystem)
		{
			lstrcpy(szSID, szLocalSystemSID);
		}
		else
		{
			dwResult = GetCurrentUserStringSID(szSID);
			if (ERROR_SUCCESS != dwResult)
			{
				DEBUGMSG1("Unable to retrieve current user SID string. Result: %d.", dwResult);
				RegCloseKey(hKey);
				return ERROR_FUNCTION_FAILED;
			}
		}

		if (g_fWin9X || lstrcmp(szSID, szLocalSystemSID))
		{
			if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_CURRENT_USER, szPerUserInstallKeyName, 0, KEY_ENUMERATE_SUB_KEYS, &hKey)))
			{
				// if the key could not be opened because it was not present, no products
				// are installed per-user. This is not a catastrophic failure.
				if (ERROR_FILE_NOT_FOUND != dwResult)
				{
					DEBUGMSG1("Error: Failed to open per-user managed key. Result: %d.", dwResult);
					return ERROR_FUNCTION_FAILED;
				}
			}
			else
			{
				// ACL on this key does not matter
				dwResult = ReadProductInstallKey(hDatabase, hKey, szSID, hInsertView, emtNonManaged);
				RegCloseKey(hKey);
		
				if (ERROR_SUCCESS != dwResult)
					return dwResult;
			}
		}
		else
		{
			DEBUGMSG("Running as system. No HKCU products to detect.");
		}
	}


	////
	// 4. Cached Package List
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szLocalPackagesKeyName, 
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Failed to open local packages key. Result: %d.", dwResult);
			return ERROR_FUNCTION_FAILED;
		}
   	}
	else
	{
		// ACL on this key does matter
		if (g_fWin9X || FIsKeyLocalSystemOrAdminOwned(hKey))
		{
			dwResult = ReadLocalPackagesKey(hKey, hInsertView);
			if (ERROR_SUCCESS != dwResult)
			{
				RegCloseKey(hKey);
				return dwResult;
			}
		}
		else
  		{
			DEBUGMSG("Skipping localpackages key, key is not owned by Admin or System.");
		}

		RegCloseKey(hKey);
	}
	
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Read all configuration informaiton into the specificied database
// path, including component registration, product install state, 
// patches, transforms, and feature-component mappings. Does not
// write anything into the registry.
DWORD ReadProductRegistrationDataIntoDatabase(TCHAR* szDatabase, MSIHANDLE& hDatabase, bool fReadHKCUAsSystem)
{
	DWORD dwResult = ERROR_SUCCESS;

	if (!CheckWinVersion())
		return ERROR_FUNCTION_FAILED;

	// try to open the database for read/write
	if (ERROR_SUCCESS != MsiOpenDatabase(szDatabase, MSIDBOPEN_CREATE, &hDatabase))
		return ERROR_FUNCTION_FAILED;

	// create a table to hold files that should be cleaned up on failure or success
	PMSIHANDLE hCleanUpTable;
	if (ERROR_SUCCESS == (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("CREATE TABLE `CleanupFile` (`File` CHAR(0) NOT NULL, `OnSuccess` INTEGER PRIMARY KEY `File`)"), &hCleanUpTable)))
		dwResult = MsiViewExecute(hCleanUpTable, 0);

	// Read Component path registration data into the database and compute original
	// MSI-based SharedDLL reference counts.
	if (ERROR_SUCCESS == dwResult)
		dwResult = ReadComponentRegistrationDataIntoDatabase(hDatabase);

	// Read FeatureComponent data into the database
	if (ERROR_SUCCESS == dwResult)
		dwResult = ReadFeatureRegistrationDataIntoDatabase(hDatabase);
		
	// It doesn't matter if feature usage data gets migrated completely or not
	if (ERROR_SUCCESS == dwResult)
		ReadFeatureUsageDataIntoDatabase(hDatabase);

	// UserProduct mappings determine which users have products installed
	if (ERROR_SUCCESS == dwResult)
		dwResult = BuildUserProductMapping(hDatabase, fReadHKCUAsSystem);

	// tickles all cached patches to determine what potential products they
	// could be applied to. This info is used to migrate non-managed per-user
	// installs.
	if (ERROR_SUCCESS == dwResult)
		dwResult = ScanCachedPatchesForProducts(hDatabase);

	// cross-references per-user non-managed installs with patch data from 
	// above. Creates a list of patches that could be applied to each
	// per-user install.
	if (ERROR_SUCCESS == dwResult)
		dwResult = AddPerUserPossiblePatchesToPatchList(hDatabase);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\msiregmv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msiregmv.cpp
//
//--------------------------------------------------------------------------

#include "msiregmv.h"
#include <objbase.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h"


extern bool g_fWin9X = true;

////
// general registry paths
const TCHAR szOldInstallerKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer");


////
// Win9X migration information
const TCHAR szWin9XDummyPath[] = TEXT("Win9X");

///////////////////////////////////////////////////////////////////////
// new/delete overloads to use system heaps
void * operator new(size_t cb)
{
	return HeapAlloc(GetProcessHeap(), 0, cb);
}

void operator delete(void *pv)
{
	if (pv == 0)
			return;
	HeapFree(GetProcessHeap(), 0, pv);
}

void DebugOut(bool fDebugOut, LPCTSTR str, ...)
{
	TCHAR strbuf[1024];
	HANDLE hStdOut;
	int cb;
	va_list list; 
	va_start(list, str); 
	wvsprintf(strbuf, str, list);
	va_end(list);
	lstrcat(strbuf, TEXT("\r\n"));
	if (fDebugOut)
		OutputDebugString(strbuf);
	
	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hStdOut && hStdOut != INVALID_HANDLE_VALUE)
	{
#ifdef UNICODE
	    char ansibuf[1024];
	    cb = WideCharToMultiByte(CP_ACP, 0, strbuf, lstrlen(strbuf), ansibuf, 1024, NULL, NULL);
	    if (cb)
	    {
			DWORD dwWritten = 0;
			WriteFile(hStdOut, ansibuf, lstrlen(strbuf), &dwWritten, NULL);
	    }
#else
		DWORD dwWritten = 0;
		WriteFile(hStdOut, strbuf, lstrlen(strbuf), &dwWritten, NULL);
#endif
	}
}

///////////////////////////////////////////////////////////////////////
// 
void MakeRegEmergencyBackup()
{
	AcquireBackupPriv();
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldInstallerKeyName, 0, KEY_READ, &hKey))
	{
		SECURITY_ATTRIBUTES sa;
		sa.nLength        = sizeof(sa);
		sa.bInheritHandle = FALSE;
		if (!g_fWin9X)
			GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

		TCHAR rgchBackupFile[MAX_PATH];
		GetWindowsDirectory(rgchBackupFile, MAX_PATH);
		lstrcat(rgchBackupFile, TEXT("\\msireg.bak"));

		RegSaveKey(hKey, rgchBackupFile, (g_fWin9X ? NULL : &sa));
		RegCloseKey(hKey);
	}
}


#ifdef UNICODE
void MigrationPerMachine();
#endif // UNICODE

///////////////////////////////////////////////////////////////////////
// MsiRegMv.Exe - migrates Darwin 1.0/1.1 registration data into
// Darwin 1.5 format. Moves registration data and copies cached files
// as necessary.
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	PMSIHANDLE hDatabase;

	bool fSaveDB = false;
	bool fMakeBackup = false;
	bool fCleanup = true;
	int iExplicitFile = -1;

	NOTEMSG("MSI 2.0 Migration Utility.");
	NOTEMSG("Copyright (c) 2000 Microsoft Corp.");
	NOTEMSG("");

	if (!CheckWinVersion())
	{
		NOTEMSG("Unable to determine platform type.");
		return -1;
	}

	// do some simple command line processing. Ship builds do not have command line options
	int argc = 0;
	LPTSTR argv[255];
#ifdef DEBUG
	LPTSTR szCommandLine = GetCommandLine();
	while (*szCommandLine)
	{
		argv[argc++] = szCommandLine;

		if (*(szCommandLine++) == TEXT('\"'))
		{
			while (*szCommandLine && (*szCommandLine != TEXT('\"')))
				szCommandLine++;
		}
		else
		{
			while (*szCommandLine && *szCommandLine != TEXT(' '))
				szCommandLine++;
		}
		if (*szCommandLine)
		{
			*(szCommandLine++) = 0;
			while (*szCommandLine && *szCommandLine == TEXT(' '))
				szCommandLine++;
		}
		if (argc == 255)
			break;
	}

	for (int i=1; i < argc; i++)
	{
		if (0 == lstrcmpi(TEXT("-savedb"), argv[i]))
		{
			fSaveDB = true;
		}
		else if (0 == lstrcmpi(TEXT("-noclean"), argv[i]))
		{
			fCleanup = false;
		}
    		else if (0 == lstrcmpi(TEXT("-preclean"), argv[i]))
		{
			CleanupOnFailure(hDatabase);
		}
    		else if (0 == lstrcmpi(TEXT("-backup"), argv[i]))
		{
			fMakeBackup = true;
		}
		else if (0 == lstrcmpi(TEXT("-database"), argv[i]) && i < argc-1)
		{
			iExplicitFile = ++i;
		}
		else
		{
			NOTEMSG("Syntax:");
			NOTEMSG("   -savedb            (to not delete database on exit)");
			NOTEMSG("   -backup            (to make a backup of the registry)");
			NOTEMSG("   -noclean           (to not clean up unused registration)");
			NOTEMSG("   -preclean          (to delete new keys before migrating)");
			NOTEMSG("   -database <file>   (to specify a database file name)");
			return -1;
		}
	}
#endif

	// if called during NT setup, do NOT perform any migration if upgrading from Win9X.
	// This can be detected by looking for our Installer key. In a Win9X upgrade, the key
	// won't exist yet. (And if it doesn't exist, there's no point in doing any migration
	// anyway.)
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0, KEY_QUERY_VALUE, &hKey))
	{
		DWORD dwData;
		DWORD cbDataSize = sizeof(dwData);
		if ((ERROR_SUCCESS == RegQueryValueEx(hKey, TEXT("SystemSetupInProgress"), 0, NULL, reinterpret_cast<unsigned char *>(&dwData), &cbDataSize)) &&
			(dwData == 1))
		{
			HKEY hInstallerKey = 0;
			if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldInstallerKeyName, 0, KEY_QUERY_VALUE, &hInstallerKey))
			{
				RegCloseKey(hKey);
				return 0;
			}
			RegCloseKey(hInstallerKey);
		}
		RegCloseKey(hKey);
	}
	

	if (fMakeBackup)
		MakeRegEmergencyBackup();

	DWORD dwResult = ERROR_SUCCESS;

	// get a temp path for the migration database
	DWORD cchTempPath = MAX_PATH;
	TCHAR szTempPath[MAX_PATH];
	::GetTempPath(cchTempPath, szTempPath);

	// get a temp filename for the migration database
	TCHAR szTempFilename[MAX_PATH] = TEXT("");
	if (iExplicitFile != -1)
	{
		lstrcpy(szTempFilename, szTempPath);
		lstrcat(szTempFilename, argv[iExplicitFile]);
	}
	else
	{
		UINT iResult = ::GetTempFileName(szTempPath, _T("MSI"), 0, szTempFilename);
	}

	// read all existing product registration data into the temporary database. In debug
	// builds or in multi-phase migration (Win9X upgrades for example), this database can
	// be saved at any point (it contains the complete state of migration). But normally
	// the database is only temporary for msiregmv.
	if (ERROR_SUCCESS != ReadProductRegistrationDataIntoDatabase(szTempFilename, *&hDatabase, /*fReadHKCUAsSystem=*/false))
		return ERROR_FUNCTION_FAILED;

	// write the data back into the registry in the new format
	if (ERROR_SUCCESS != WriteProductRegistrationDataFromDatabase(hDatabase, /*fMigrateSharedDLL=*/true, /*fMigratePatches=*/true))
		return ERROR_FUNCTION_FAILED;

	// finall cleanup/commit of all changes
	if (ERROR_SUCCESS == dwResult)
	{
    	if (fCleanup)
			CleanupOnSuccess(hDatabase);
	}
	else
	{
		// remove all newly migrated data and files
		if (fCleanup)
			CleanupOnFailure(hDatabase);
	}

 	if (fSaveDB)
	{
		DEBUGMSG1("Saved Database is: %s.", szTempFilename);
		::MsiDatabaseCommit(hDatabase);
	}
	
#ifdef UNICODE
	// Hack to fix bug 487742. See function definition for more comments.
	MigrationPerMachine();
#endif // UNICODE

    return 0;
}


#ifdef UNICODE

// Hack to fix bug 487742. When migrating MSI configuration data from win9x to
// NT, permachine installed application cached package location is not migrated,
// so here we try to migrate it after fact.

const TCHAR szSystemUserProductList[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\S-1-5-18\\Products");
const TCHAR szPerMachineInstallKey[] = TEXT("Software\\Classes\\Installer\\Products");
const TCHAR szInstallProperties[] = TEXT("InstallProperties");
const TCHAR szLocalPackageValueName[] = TEXT("LocalPackage");
const TCHAR szUninstallKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
const TCHAR szPackageExtension[] = TEXT(".msi");
const TCHAR szLocalPackage[] = TEXT("LocalPackage");

void MigrationPerMachine()
{
    HKEY    hNewProductKey = NULL;
    HKEY    hOldProductKey = NULL;
    HKEY    hUninstallKey = NULL;
    HKEY    hUninstallProductKey = NULL;
    HKEY    hInstallProperties = NULL;
    TCHAR   szProductCodePacked[cchGUIDPacked + 1];
    DWORD   dwProductCodePacked = cchGUIDPacked + 1;
    TCHAR   szProductCodeUnpacked[cchGUID + 1];
    TCHAR   szProductGUIDInstallProperties[MAX_PATH];	
    SECURITY_ATTRIBUTES sa;


    // Get the security descriptor
    sa.nLength        = sizeof(sa);
    sa.bInheritHandle = FALSE;
    GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));
    
    // Open the destination key.
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSystemUserProductList, 0, KEY_ALL_ACCESS, &hNewProductKey) != ERROR_SUCCESS)
    {
	goto Exit;
    }

    // Open the per-machine install key.
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerMachineInstallKey, 0, KEY_ALL_ACCESS, &hOldProductKey) != ERROR_SUCCESS)
    {
	goto Exit;
    }

    // ACL on this key matters.
    if(!FIsKeyLocalSystemOrAdminOwned(hOldProductKey))
    {
	goto Exit;
    }
    
    // enumerate through all installed products for the current user
    DWORD   dwIndex = 0;
    while(RegEnumKeyEx(hOldProductKey, dwIndex, szProductCodePacked, &dwProductCodePacked, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
    {
	TCHAR	szCachedPackage[MAX_PATH + 1] = TEXT("");
	DWORD	dwCachedPackage = MAX_PATH + 1;

	dwIndex++;
	dwProductCodePacked = cchGUIDPacked + 1;

	// Open the InstallProperties key under the UserData location.
	wsprintf(szProductGUIDInstallProperties, TEXT("%s\\%s"), szProductCodePacked, szInstallProperties);
	if(RegOpenKeyEx(hNewProductKey, szProductGUIDInstallProperties, 0, KEY_ALL_ACCESS, &hInstallProperties) != ERROR_SUCCESS)
	{
	    goto Exit;
	}

	// Check if the LocalPackage value already exists.
	if(RegQueryValueEx(hInstallProperties, szLocalPackageValueName, NULL, NULL, (LPBYTE)szCachedPackage, &dwCachedPackage) == ERROR_SUCCESS)
	{
	    // LocalPackage value already exist, move on to the next product.
	    RegCloseKey(hInstallProperties);
	    hInstallProperties = NULL;
	    continue;
	}
	dwCachedPackage = MAX_PATH + 1;

	// Open the uninstall key where the cached package location is stored.
	if(hUninstallKey == NULL)
	{
	    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szUninstallKey, 0, KEY_READ, &hUninstallKey) != ERROR_SUCCESS)
	    {
		goto Exit;
	    }
	}

	// GUIDs under the Uninstall key are not packed.
	if(!UnpackGUID(szProductCodePacked, szProductCodeUnpacked))
	{
	    goto Exit;
	}
	
	// Open the product key under the uninstall key.
	if(RegOpenKeyEx(hUninstallKey, szProductCodeUnpacked, 0, KEY_READ, &hUninstallProductKey) != ERROR_SUCCESS)
	{
	    goto Exit;
	}

	// ACL on this key matters.
	if(!FIsKeyLocalSystemOrAdminOwned(hUninstallProductKey))
	{
	    goto Exit;
	}
	
	// Query the cached package path.
	if(RegQueryValueEx(hUninstallProductKey, szLocalPackageValueName, 0, NULL, (LPBYTE)szCachedPackage, &dwCachedPackage) != ERROR_SUCCESS)
	{
	    goto Exit;
	}

	RegCloseKey(hUninstallProductKey);
	hUninstallProductKey = NULL;

	// Open the cached package
	HANDLE	hSourceFile = CreateFile(szCachedPackage, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	if(hSourceFile == INVALID_HANDLE_VALUE)
	{
	    // The path doesn't exist. Skip to the next product.
	    RegCloseKey(hInstallProperties);
	    hInstallProperties = NULL;
	    continue;
	}

	// Generate new name for the secure cached package.
	TCHAR	szNewPath[MAX_PATH];
	TCHAR	szNewFileName[13];

	GetWindowsDirectory(szNewPath, MAX_PATH);
	lstrcat(szNewPath, szInstallerDir);

	HANDLE	hDestFile = INVALID_HANDLE_VALUE;
	GenerateSecureTempFile(szNewPath, szPackageExtension, &sa, szNewFileName, hDestFile);

	if(!CopyOpenedFile(hSourceFile, hDestFile))
	{
	    // Skip to the next product.
	    CloseHandle(hSourceFile);
	    CloseHandle(hDestFile);
	    RegCloseKey(hInstallProperties);
	    hInstallProperties = NULL;
	    continue;
	}

	CloseHandle(hSourceFile);
	CloseHandle(hDestFile);

	// Add the cached package information to the UserData location.
	lstrcat(szNewPath, szNewFileName);
	if(RegSetValueEx(hInstallProperties, szLocalPackage, 0, REG_SZ, (const BYTE*)szNewPath, (lstrlen(szNewPath) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS)
	{
	    CloseHandle(hSourceFile);
	    CloseHandle(hDestFile);
	    goto Exit;
	}
	
	RegCloseKey(hInstallProperties);
	hInstallProperties = NULL;
    }

Exit:

    if(hNewProductKey != NULL)
    {
	RegCloseKey(hNewProductKey);
    }
    if(hOldProductKey != NULL)
    {
	RegCloseKey(hOldProductKey);
    }
    if(hUninstallKey != NULL)
    {
	RegCloseKey(hUninstallKey);
    }
    if(hUninstallProductKey != NULL)
    {
	RegCloseKey(hUninstallProductKey);
    }
    if(hInstallProperties != NULL)
    {
	RegCloseKey(hInstallProperties);
    }

    return;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msishort\sources.inc ===
TARGETNAME=msishort
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=LIBRARY
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\OLE32.lib

USE_MSVCRT=1

DLLDEF=..\msishort.def

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msishort.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\hashinc.cpp ===
#include "hash.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msiregmv\writecfg.cpp ===
#include <windows.h>
#include <tchar.h>

#include "msiregmv.h"

const TCHAR szNewComponentSubKeyName[] = TEXT("Components");
const TCHAR szNewFeaturesSubKeyName[] = TEXT("Features");
const TCHAR szNewFeatureUsageSubKeyName[] = TEXT("Usage");
const TCHAR szNewBaseUserKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData");

////
// cached package registration information
const TCHAR szNewLocalPackagesValueName[] = TEXT("LocalPackage");
const TCHAR szNewLocalPackagesManagedValueName[] = TEXT("ManagedLocalPackage");
const TCHAR szPackageExtension[] = TEXT(".msi");

////
// cached transform information
const TCHAR szSecureTransformsDir[] = TEXT("\\SecureTransforms\\");
const TCHAR szNewTransformsSubKeyName[] = TEXT("Transforms");
const TCHAR szTransformExtension[] = TEXT(".mst");

////
// Shared DLL information
const TCHAR szSharedDLLKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs");

////
// uninstall information
const TCHAR szOldUninstallKeyName[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall");



///////////////////////////////////////////////////////////////////////
// Given a record containing <Path, Component, AlternatePath>, a 
// registry key, and a productcode, creates \Component!Product=Path
// registry value. Returns ERROR_SUCCESS, ERROR_OUTOFMEMORY, 
// ERROR_FUNCTION_FAILED. szUser is just for logging.
DWORD WriteComponentData(HKEY hComponentListKey, MSIHANDLE hComponentRec, TCHAR rgchProduct[cchGUIDPacked+1], LPCTSTR szUser, MSIHANDLE hRefCountUpdateView)
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	TCHAR rgchComponent[cchGUIDPacked+1];
	DWORD cchComponent = cchGUIDPacked+1;
	MsiRecordGetString(hComponentRec, 2, rgchComponent, &cchComponent);
	
	DWORD cchPathBuf = MEMORY_DEBUG(MAX_PATH);
	TCHAR *szPath = new TCHAR[cchPathBuf];
	if (!szPath)
	{
		DEBUGMSG("Error: Out of memory");
		return ERROR_OUTOFMEMORY;
	}
	
	DWORD dwType = REG_SZ;
	DWORD cchPath = cchPathBuf;
	if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hComponentRec, 1, szPath, &cchPath)))
	{
		delete[] szPath;
		cchPathBuf = ++cchPath;
		szPath = new TCHAR[cchPathBuf];
		if (!szPath)
		{
			DEBUGMSG("Error: Out of memory");
			return ERROR_OUTOFMEMORY;
		}
		dwResult = MsiRecordGetString(hComponentRec, 1, szPath, &cchPath);
	}
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG4("Error: Unable to retrive component path for user %s, component %s, product %s. Result: %d.", szUser, rgchComponent, rgchProduct, dwResult);
		return ERROR_SUCCESS;
	}

	// if the third coulmn is not null, there is a secondary keypath (used for detecting HKCR components
	// for per-user installs)		
	if (!::MsiRecordIsNull(hComponentRec, 3))
	{
		// secondary keypaths require a MULT_SZ value type
		dwType = REG_MULTI_SZ;

		// retrieve the secondary keypath into the same buffer as the primary, but separated by
		// a NULL character.
		DWORD cchSecondaryPath = cchPathBuf-cchPath-1;
		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hComponentRec, 3, szPath+cchPath+1, &cchSecondaryPath)))
		{
			// must have space for 3 nulls, (1 in middle, two at end)
			cchPathBuf = cchPath+1+cchSecondaryPath+2;
			TCHAR *szNewPath = new TCHAR[cchPathBuf];
			if (!szNewPath)
			{
				delete[] szPath;
				DEBUGMSG("Error: Out of memory");
				return ERROR_OUTOFMEMORY;
			}

			lstrcpyn(szNewPath, szPath, cchPath+1);
			delete[] szPath;
			szPath = szNewPath;
			DWORD cchSecondaryPath = cchPathBuf-cchPath-1;
			dwResult = MsiRecordGetString(hComponentRec, 3, szPath+cchPath+1, &cchSecondaryPath);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG4("Error: Unable to retrive secondary component path for user %s, component %s, product %s. Result: %d.", szUser, rgchComponent, rgchProduct, dwResult);
			delete[] szPath;
			return ERROR_FUNCTION_FAILED;
		}

		// add extra null for double terminating null at the end. And ensure
		// cchPath includes the new string and extra null.
		cchPath = cchPath+1 + cchSecondaryPath;
		*(szPath+cchPath+1) = 0;
	}

	// create the component key
	HKEY hComponentKey;
	if (ERROR_SUCCESS != (dwResult = RegCreateKeyEx(hComponentListKey, rgchComponent, 0, NULL, 0, KEY_ALL_ACCESS, &sa, &hComponentKey, NULL)))
	{
		DEBUGMSG3("Error: Unable to create new component key for user %s, component %s. Result: %d.", szUser, rgchComponent, dwResult);
		delete[] szPath;
		return ERROR_FUNCTION_FAILED;
	}

	dwResult = RegSetValueEx(hComponentKey, rgchProduct, 0, dwType, reinterpret_cast<unsigned char*>(szPath), (cchPath+1)*sizeof(TCHAR));
	RegCloseKey(hComponentKey);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG4("Error: Unable to create new component path value for user %s, component %s, product %s. Result: %d.", szUser, rgchComponent, rgchProduct, dwResult);
		delete[] szPath;
		return ERROR_FUNCTION_FAILED;
	}

	if (szPath[0] != TEXT('\0') && szPath[1] == TEXT('?'))
	{
		PMSIHANDLE hSharedDLLRec;
		if (ERROR_SUCCESS != (dwResult = MsiViewExecute(hRefCountUpdateView, hComponentRec)) ||
			ERROR_SUCCESS != (dwResult = MsiViewFetch(hRefCountUpdateView, &hSharedDLLRec)))
		{
			DEBUGMSG3("Error: Unable to retrieve SharedDLL data for user %s, product %s in SharedDLL table. Error %d", szUser, rgchProduct, dwResult);
			delete[] szPath;
			return ERROR_FUNCTION_FAILED;
		}
		else
		{	
			// increment the existing old SharedDLL cont for this path
			MsiRecordSetInteger(hSharedDLLRec, 1, MsiRecordGetInteger(hSharedDLLRec, 1)+1);
			if (ERROR_SUCCESS != (dwResult = MsiViewModify(hRefCountUpdateView, MSIMODIFY_UPDATE, hSharedDLLRec)))
			{
				DEBUGMSG3("Error: Unable to update SharedDLL data for user %s, product %s into SharedDLL table. Error %d", szUser, rgchProduct, dwResult);
				delete[] szPath;
				return ERROR_FUNCTION_FAILED;
			}
		}
	}

	return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
// Migrates user Component Path data by quering the Component and Product
// tables for products installed by szUser and components that belong
// to those products. Uses a temporary Marking column because native
// MSI joins do not scale well to large tables.
DWORD MigrateUserComponentData(MSIHANDLE hDatabase, HKEY hUserDataKey, LPCTSTR szUser)
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	////
	// create the "Component" key underneath the UserData key
	HKEY hComponentListKey;
	DWORD dwDisposition = 0;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewComponentSubKeyName, &sa, &hComponentListKey)))
	{
		DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}																				

	////
	// mark the component table with all components of interest based on products this user has installed
	PMSIHANDLE hAddColumnView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("ALTER TABLE `Component` ADD `_Mark` INT TEMPORARY"), &hAddColumnView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hAddColumnView, 0)))
	{
		DEBUGMSG2("Error: Unable to create marking column in Component table for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	// put the user SID into a temporary record for query mapping
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);							 
	MsiRecordSetString(hQueryRec, 1, szUser);
 																			 
	PMSIHANDLE hProductView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product` FROM `Products` WHERE `User`=?"), &hProductView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hProductView, hQueryRec)))
	{
		DEBUGMSG2("Error: Unable to create product query for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hMarkView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("UPDATE `Component` SET `_Mark`=1 WHERE `Product`=?"), &hMarkView)))
	{
		DEBUGMSG2("Error: Unable to create marking query for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hProductRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hProductView, &hProductRec)))
	{
		if (ERROR_SUCCESS != MsiViewExecute(hMarkView, hProductRec))
		{
			DEBUGMSG2("Error: Unable to execute marking query for user %s. Result: %d.", szUser, dwResult);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG2("Error: Unable to mark all product components for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}
	
	// all components of interest have been maked in the _Mark column. Selected out of order so
	// SharedDLL queries can use fetched record in the execute call.
	PMSIHANDLE hComponentView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Path`, `Component`, `SecondaryPath`, `Product` FROM `Component` WHERE `_Mark`=1"), &hComponentView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hComponentView, 0)))
	{
   		DEBUGMSG2("Error: Unable to create Component query for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}
	
   	////
	// open query for update of SharedDLL Table
	PMSIHANDLE hRefCountUpdateView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `NewRefCount` FROM `SharedDLL` WHERE `Path`=?"), &hRefCountUpdateView)))
	{
		DEBUGMSG1("Error: Unable to create update query on SharedDLL table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	// loop through all installed components
	PMSIHANDLE hComponentRec;
 	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hComponentView, &hComponentRec)))
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;
		MsiRecordGetString(hComponentRec, 4, rgchProduct, &cchProduct);

		if (ERROR_SUCCESS != (dwResult = WriteComponentData(hComponentListKey, hComponentRec, rgchProduct, szUser, hRefCountUpdateView)))
		{
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG2("Error: Unable to retrieve all component paths for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}
	RegCloseKey(hComponentListKey);
	return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
// Migrates permanent Component data by quering the Component
// tables for NULL products. Returns ERROR_FUNCTION_FAILED or ERROR_SUCCESS
DWORD MigratePermanentComponentData(MSIHANDLE hDatabase, HKEY hUserDataKey)
{
	DWORD dwResult = ERROR_SUCCESS;
	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create the "Component" key underneath the UserData key
	HKEY hComponentListKey;
	DWORD dwDisposition = 0;

	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewComponentSubKeyName, &sa, &hComponentListKey)))
	{
		DEBUGMSG1("Error: Unable to create new component. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}																				
  	
	////
	// open query for update of SharedDLL Table
	PMSIHANDLE hRefCountUpdateView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `NewRefCount` FROM `SharedDLL` WHERE `Path`=?"), &hRefCountUpdateView)))
	{
		DEBUGMSG1("Error: Unable to create update query on SharedDLL table. Error %d", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	// open query for distinct component IDs.
	PMSIHANDLE hPermanentComponentView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT DISTINCT `Component` FROM `Component` WHERE `Product` IS NULL"), &hPermanentComponentView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hPermanentComponentView, 0)))
	{
		DEBUGMSG1("Error: Unable to create permanent component query. Result: %d.", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

   	// open query to select all paths of a specific component that are marked permanent.
	PMSIHANDLE hPermanentView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT DISTINCT `Path`, `Component`, `SecondaryPath`, 0 FROM `Component` WHERE `Product` IS NULL AND `Component`=?"), &hPermanentView)))
	{
   		DEBUGMSG1("Error: Unable to create Permanent Component path query. Result: %d.", dwResult);
		RegCloseKey(hComponentListKey);
		return ERROR_FUNCTION_FAILED;
	}

	TCHAR rgchProduct[cchGUIDPacked+1] = TEXT("00000000000000000000000000000000");

	// next check for all components marked "permanent' under any path
	PMSIHANDLE hComponentRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPermanentComponentView, &hComponentRec)))
	{
		if (ERROR_SUCCESS != (dwResult = MsiViewExecute(hPermanentView, hComponentRec)))
		{
			DEBUGMSG1("Error: Unable to execute Permanent Component query. Result: %d.", dwResult);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}

		// start with all-0s product GUID, and increment the last two chars
		// in HEX for each unique path.
		int iPermanent = 0;
		PMSIHANDLE hPermanentRec;
		while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hPermanentView, &hPermanentRec)))
		{
			wsprintf(&rgchProduct[cchGUIDPacked-2], TEXT("%0.2X"), iPermanent);
			MsiRecordSetString(hPermanentRec, 4, rgchProduct);
		
			if (ERROR_SUCCESS != (dwResult = WriteComponentData(hComponentListKey, hPermanentRec, rgchProduct, szLocalSystemSID, hRefCountUpdateView)))
			{
				RegCloseKey(hComponentListKey);
				return ERROR_FUNCTION_FAILED;
			}
			iPermanent++;
		}
		if (ERROR_NO_MORE_ITEMS != dwResult)
		{
			DEBUGMSG1("Error: Unable to retrieve all permanent component paths. Result: %d.", dwResult);
			RegCloseKey(hComponentListKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// Reads FeatureComponent registration data from the temporary
// database for the specified user and product, then writes the
// data under the provided product key in the new format. Returns
// ERROR_SUCCESS, ERROR_FUNCTION_FAILED, ERROR_OUTOFMEMORY
DWORD MigrateProductFeatureData(MSIHANDLE hDatabase, HKEY hProductKey, TCHAR* szUser, TCHAR rgchProduct[cchGUIDPacked+1])
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create the "Features" key under the Products
	HKEY hFeatureKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hProductKey, szNewFeaturesSubKeyName, &sa, &hFeatureKey)))
	{
		DEBUGMSG3("Error: Unable to create new Features key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
	
	// query for all feature data beloning to this product
	PMSIHANDLE hFeatureView;
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);
	MsiRecordSetString(hQueryRec, 1, rgchProduct);

	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Feature`, `Components` FROM `FeatureComponent` WHERE `Product`=?"), &hFeatureView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hFeatureView, hQueryRec)))
	{
		DEBUGMSG3("Error: Unable to query FeatureComponent table for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		RegCloseKey(hFeatureKey);
		return ERROR_FUNCTION_FAILED;
	}

	DWORD cchNameBuf = MEMORY_DEBUG(72);
	TCHAR *szName = new TCHAR[cchNameBuf];
	if (!szName)
	{
		DEBUGMSG("Error: Out of memory");
		RegCloseKey(hFeatureKey);
		return ERROR_OUTOFMEMORY;
	}

	DWORD cchValueBuf = MEMORY_DEBUG(128);
	TCHAR *szValue = new TCHAR[cchValueBuf];
	if (!szValue)
	{
		DEBUGMSG("Error: Out of memory");
		RegCloseKey(hFeatureKey);
		delete[] szName;
		return ERROR_OUTOFMEMORY;
	}

	PMSIHANDLE hFeatureRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hFeatureView, &hFeatureRec)))
	{
		DWORD cchName = cchNameBuf;
		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hFeatureRec, 1, szName, &cchName)))
		{
			delete[] szName;
			cchNameBuf = ++cchName;
			szName = new TCHAR[cchNameBuf];
			if (!szName)
			{
				DEBUGMSG("Error: Out of memory");
				delete[] szValue;
				RegCloseKey(hFeatureKey);
				return ERROR_OUTOFMEMORY;
			}
			dwResult = MsiRecordGetString(hFeatureRec, 1, szName, &cchName);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG3("Warning: Unable to retrieve feature name for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
			delete[] szValue;
			delete[] szName;
			RegCloseKey(hFeatureKey);
			return ERROR_FUNCTION_FAILED;
		}

		DWORD cchValue = cchValueBuf;
		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hFeatureRec, 2, szValue, &cchValue)))
		{
			delete[] szValue;
			cchValueBuf = ++cchValue;
			szValue = new TCHAR[cchValueBuf];
			if (!szName)
			{
				DEBUGMSG("Error: Out of memory");
				delete[] szName;
				RegCloseKey(hFeatureKey);
				return ERROR_OUTOFMEMORY;
			}
			dwResult = MsiRecordGetString(hFeatureRec, 2, szValue, &cchValue);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG4("Warning: Unable to retrieve feature components for user %s, product %s, Feature %s. Result: %d.", szUser, rgchProduct, szName, dwResult);
			delete[] szValue;
			delete[] szName;
			RegCloseKey(hFeatureKey);
			return ERROR_FUNCTION_FAILED;
		}

		// create the component key
        if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hFeatureKey, szName, 0, REG_SZ, reinterpret_cast<unsigned char*>(szValue), (cchValue+1)*sizeof(TCHAR))))
		{
			DEBUGMSG4("Warning: Unable to create new feature value for user %s, product %s, feature %s. Result: %d.", szUser, rgchProduct, szName, dwResult);
			delete[] szValue;
			delete[] szName;
			RegCloseKey(hFeatureKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG3("Warning: Unable to retrieve all feature information for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		delete[] szValue;
		delete[] szName;
		RegCloseKey(hFeatureKey);
		return ERROR_FUNCTION_FAILED;
	}
	delete[] szName;
	delete[] szValue;
	RegCloseKey(hFeatureKey);
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Reads Feature Usage Data data from the temporary
// database for the specified user and product, then writes the
// data under the provided product key in the new format. Returns
// ERROR_SUCCESS, ERROR_OUTOFMEMORY. Does not return ERROR_FUNCTION_FAILED
// because feature usage data is not required in 1.5.
DWORD MigrateProductFeatureUsageData(MSIHANDLE hDatabase, HKEY hProductKey, TCHAR* szUser, TCHAR rgchProduct[cchGUIDPacked+1])
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetEveryoneUpdateSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create the "Features" key under the Products
	HKEY hFeatureKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hProductKey, szNewFeatureUsageSubKeyName, &sa, &hFeatureKey)))
	{
		DEBUGMSG3("Unable to create new feature usage key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		return ERROR_SUCCESS;
	}
	
	// query for all feature data belonging to this product
	PMSIHANDLE hFeatureView;
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);
	MsiRecordSetString(hQueryRec, 1, rgchProduct);

	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Feature`, `Usage` FROM `FeatureUsage` WHERE `Product`=?"), &hFeatureView)) ||
		ERROR_SUCCESS != (dwResult = MsiViewExecute(hFeatureView, hQueryRec)))
	{
		DEBUGMSG3("Error: Unable to query FeatureUsage table for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		RegCloseKey(hFeatureKey);
		return ERROR_SUCCESS;
	}

	DWORD dwUsage;
	DWORD cchNameBuf = MEMORY_DEBUG(72);
	TCHAR *szName = new TCHAR[cchNameBuf];
	if (!szName)
	{
		DEBUGMSG("Error: Out of memory");
		RegCloseKey(hFeatureKey);
		return ERROR_OUTOFMEMORY;
	}

	PMSIHANDLE hFeatureRec;
    while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hFeatureView, &hFeatureRec)))
	{
		DWORD cchName = cchNameBuf;
		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hFeatureRec, 1, szName, &cchName)))
		{
			delete[] szName;
			cchNameBuf = ++cchName;
			szName = new TCHAR[cchNameBuf];
			if (!szName)
			{
				DEBUGMSG("Error: Out of memory");
				RegCloseKey(hFeatureKey);
				return ERROR_OUTOFMEMORY;
			}
			dwResult = MsiRecordGetString(hFeatureRec, 1, szName, &cchName);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG4("Warning: Unable to retrieve feature usage data for user %s, product %s, feature %s. Result: %d.", szUser, rgchProduct, szName, dwResult);
			continue;
		}

		dwUsage = ::MsiRecordGetInteger(hFeatureRec, 2);

		// create the feature usage value key
        if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hFeatureKey, szName, 0, REG_DWORD, reinterpret_cast<unsigned char*>(&dwUsage), sizeof(dwUsage))))
		{
			DEBUGMSG4("Warning: Unable to create new feature usage value for user %s, product %s, feature %s. Result: %d.", szUser, rgchProduct, szName, dwResult);
		}
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG3("Warning: Unable to retrieve all feature usage information for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
	}

	delete[] szName;
	RegCloseKey(hFeatureKey);
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Given a product code, makes a copy of the cached local package
// and registers the path under the per-user product attributes key.
// Returns one of ERROR_SUCCESS and ERROR_OUTOFMEMORY. Does NOT return
// ERROR_FUNCTION_FAILED, as all cached packages are trivially
// recachable.
DWORD MigrateCachedPackage(MSIHANDLE hDatabase, HKEY hProductKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged, bool fCopyCachedPackage)
{
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// open the existing localpackage key 
	HKEY hKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szLocalPackagesKeyName, 
												  0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no packages are cached. 
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Warning: Failed to open local packages key. Result: %d.", dwResult);
		}
		return ERROR_SUCCESS;
   	}
	else
	{
		// ACL on this key does matter
		if (!FIsKeyLocalSystemOrAdminOwned(hKey))
  		{
			DEBUGMSG("Warning: Skipping localpackages key, key is not owned by Admin or System.");
			RegCloseKey(hKey);
			return ERROR_SUCCESS;
		}
		else
		{
			// open the product key 
			HKEY hOldProductKey;
			if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(hKey, rgchProduct, 0, KEY_QUERY_VALUE, &hOldProductKey)))
			{
				RegCloseKey(hKey);

				// if the reason that this failed is that the key doesn't exist, the product is not installed or
				// has no localpackage. 
				if (ERROR_FILE_NOT_FOUND != dwResult)
				{
					DEBUGMSG2("Error: Failed to open local packages key for %s. Result: %d.", rgchProduct, dwResult);
				}
				return ERROR_SUCCESS;
			}

			// query for a value with name=UserSID or UserSID(Managed)
			TCHAR *szValueName = const_cast<TCHAR*>(szUser);
			if (eManaged == emtUserManaged)
			{
				szValueName = new TCHAR[lstrlen(szUser)+cchManagedPackageKeyEnd+1];
				if (!szValueName)
				{
					RegCloseKey(hKey);
					DEBUGMSG("Error: Out of memory.");
					return ERROR_OUTOFMEMORY;
				}
				lstrcpy(szValueName, szUser);
				lstrcat(szValueName, szManagedPackageKeyEnd);
			}

			DWORD cchPath = MEMORY_DEBUG(MAX_PATH);
			TCHAR *szPath = new TCHAR[cchPath];
			DWORD cbPath = cchPath*sizeof(TCHAR);
			if (!szPath)
			{
				RegCloseKey(hKey);
				delete[] szValueName;
				DEBUGMSG("Error: Out of memory.");
				return ERROR_OUTOFMEMORY;
			}
			if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hOldProductKey, szValueName, 0, NULL, reinterpret_cast<unsigned char*>(szPath), &cbPath)))
			{
				delete[] szPath;
				szPath = new TCHAR[cbPath/sizeof(TCHAR)];
				if (!szPath)
				{
					RegCloseKey(hKey);
					delete[] szValueName;
					DEBUGMSG("Error: Out of memory.");
					return ERROR_OUTOFMEMORY;
				}
				dwResult = RegQueryValueEx(hOldProductKey, szValueName, 0, NULL, reinterpret_cast<unsigned char*>(szPath), &cbPath);
			}

			if (ERROR_SUCCESS != dwResult)
			{
				if (ERROR_FILE_NOT_FOUND != dwResult)
				{
					DEBUGMSG3("Warning: Unable to retrieve cached package path for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);								
				}
			}
			else
			{
				// create the "InstallProperties" key under the new Products key
				HKEY hPropertyKey;
				if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hProductKey, szNewInstallPropertiesSubKeyName, &sa, &hPropertyKey)))
				{
					DEBUGMSG3("Warning: Unable to create new InstallProperties key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
				}
				else
				{
					TCHAR rgchPackageFullPath[MAX_PATH] = TEXT("");
					TCHAR *szWritePath = szPath;

					if (fCopyCachedPackage && cbPath && szPath && *szPath)
					{
						// check for existance of cached package and open the file
						HANDLE hSourceFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
						DWORD dwLastError = GetLastError();
						
						if(hSourceFile == INVALID_HANDLE_VALUE)
						{
							if (dwLastError != ERROR_FILE_NOT_FOUND)
							{
								DEBUGMSG4("Warning: Unable to open cached package %s for user %s, product %s. Result: %d.", szPath, szUser, rgchProduct, dwResult);
							}
						}
						else
						{
							// create insert query for files that should be cleaned up on failure or success. If this fails
							// we'll just orphan a file if migration fails.
							PMSIHANDLE hCleanUpTable;
							if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `CleanupFile`"), &hCleanUpTable))
								dwResult = MsiViewExecute(hCleanUpTable, 0);
							
							// add the old package to the "delete on success" list. This may exist
							// already due to migration by other users
							PMSIHANDLE hFileRec = MsiCreateRecord(2);
							MsiRecordSetString(hFileRec, 1, szPath);
							MsiRecordSetInteger(hFileRec, 2, 1);
							MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);
		
							// get installer directory for target path
							GetWindowsDirectory(rgchPackageFullPath, MAX_PATH);
							lstrcat(rgchPackageFullPath, szInstallerDir);

							// copy the file from source to Generated destination file. generated package names are 8.3
							TCHAR rgchPackageFile[13];
							HANDLE hDestFile = INVALID_HANDLE_VALUE;
							GenerateSecureTempFile(rgchPackageFullPath, szPackageExtension, &sa, rgchPackageFile, hDestFile);
				
							if (!CopyOpenedFile(hSourceFile, hDestFile))
							{
								DEBUGMSG3("Warning: Unable to copy Transform for user %s, product %s, Transform %s.", szUser, rgchProduct, szPath);
							}
		
							CloseHandle(hSourceFile);
							CloseHandle(hDestFile);
				
							// add the new transform to the "delete on failure" list.
							lstrcat(rgchPackageFullPath, rgchPackageFile);
							hFileRec = MsiCreateRecord(2);
							MsiRecordSetString(hFileRec, 1, rgchPackageFullPath);
							MsiRecordSetInteger(hFileRec, 2, 0);
							MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);

							// ensure that we write the new path
							szWritePath = rgchPackageFullPath;
						}
					}
					
					// set the new localpackages value
					if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hPropertyKey, (eManaged == emtUserManaged) ? 
							szNewLocalPackagesManagedValueName : szNewLocalPackagesValueName, 0, REG_SZ, 
							reinterpret_cast<unsigned char*>(szWritePath), (lstrlen(szWritePath)+1)*sizeof(TCHAR))))
					{
						DEBUGMSG3("Warning: Unable to create new LocalPackage value for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
    				}
					RegCloseKey(hPropertyKey);
				}
			}

			delete[] szPath;
			if (eManaged == emtUserManaged)
			{
				delete[] szValueName;
			}
			RegCloseKey(hOldProductKey);
		}
		RegCloseKey(hKey);
	}

    return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Given a product code and key makes a copy of any secure cached 
// transforms for the product and registers the filename mapping under
// the per-product transforms key. Returns one of ERROR_SUCCESS and 
// ERROR_OUTOFMEMORY. Does NOT return ERROR_FUNCTION_FAILED, as all
// transforms are recachable from source, so nothing here
// is catastrophic.
DWORD MigrateSecureCachedTransforms(MSIHANDLE hDatabase, HKEY hOldProductKey, HKEY hNewProductKey, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged)
{
	DWORD dwResult = ERROR_SUCCESS;

	// query for a value with name=Transforms
	DWORD cchTransformList = MEMORY_DEBUG(MAX_PATH);
	TCHAR *szTransformList = new TCHAR[cchTransformList];
	if (!szTransformList)
	{
		DEBUGMSG("Error: Out of memory.");
		return ERROR_OUTOFMEMORY;
	}
	DWORD cbTransformList = cchTransformList*sizeof(TCHAR);

	// retrieve the "Transforms" value, which is a semicolon delimited list of transforms
	// to apply
	if (ERROR_MORE_DATA == (dwResult = RegQueryValueEx(hOldProductKey, szTransformsValueName, 0, NULL, reinterpret_cast<unsigned char*>(szTransformList), &cbTransformList)))
	{
		delete[] szTransformList;
		szTransformList = new TCHAR[cbTransformList/sizeof(TCHAR)];
		if (!szTransformList)
		{
			DEBUGMSG("Error: Out of memory.");
			return ERROR_OUTOFMEMORY;
		}
		dwResult = RegQueryValueEx(hOldProductKey, szTransformsValueName, 0, NULL, reinterpret_cast<unsigned char*>(szTransformList), &cbTransformList);
	}

	if (ERROR_SUCCESS == dwResult)
	{
		// create insert query for files that should be cleaned up on failure or success. If this fails
		// we'll just orphan a file if migration fails.
		PMSIHANDLE hCleanUpTable;
		if (ERROR_SUCCESS == MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `CleanupFile`"), &hCleanUpTable))
			MsiViewExecute(hCleanUpTable, 0);

		// get security descriptor for new Transforms Key
		SECURITY_ATTRIBUTES sa;
		sa.nLength        = sizeof(sa);
		sa.bInheritHandle = FALSE;
		GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));
		
		// create the "Transforms" key under the new Product key
		HKEY hTransformsKey;
		if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hNewProductKey, szNewTransformsSubKeyName, &sa, &hTransformsKey)))
		{
			DEBUGMSG3("Error: Unable to create new Transforms key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		}
		else
		{
			// verify that its secure transforms
			if (*szTransformList==TEXT('@') || *szTransformList==TEXT('|'))
			{
				// get installer directory
				TCHAR rgchInstallerDir[MAX_PATH];
				GetWindowsDirectory(rgchInstallerDir, MAX_PATH);
				lstrcat(rgchInstallerDir, szInstallerDir);
				int iInstallerPathEnd = lstrlen(rgchInstallerDir);
	
				// create new full-path to transforms
				TCHAR rgchTransformFullPath[MAX_PATH];
				lstrcpy(rgchTransformFullPath, rgchInstallerDir);
	
				// create old secure transforms directory
				TCHAR rgchFullPath[MAX_PATH];
				lstrcpy(rgchFullPath, rgchInstallerDir);
				TCHAR rgchGUID[cchGUID+1];
	
				// subdirectory from installer dir is unpacked produccode GUID
				UnpackGUID(rgchProduct, rgchGUID);
				lstrcat(rgchFullPath, rgchGUID);
				
				// add the old product dir to the "delete on success" list
				// the directory will not be deleted if it is not empty.
				// (if it has icons, etc)
				PMSIHANDLE hFileRec = MsiCreateRecord(2);
				MsiRecordSetString(hFileRec, 1, rgchFullPath);
				MsiRecordSetInteger(hFileRec, 2, 3);
				MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);			
				
				// subdirectory under the product is "SecureTransforms"
				lstrcat(rgchFullPath, szSecureTransformsDir);
				int iBasePathEnd = lstrlen(rgchFullPath);
				
				// add the old transforms dir to the "delete on success" list
				// the directory will not be deleted if it is not empty.
				// (if it has icons, etc)
				MsiRecordSetString(hFileRec, 1, rgchFullPath);
				MsiRecordSetInteger(hFileRec, 2, 2);
				MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);			

				// move past the initial "secure" character before parsing list.
				TCHAR *szNextTransform = szTransformList+1;

				while (szNextTransform && *szNextTransform)
				{
					TCHAR *szTransform = szNextTransform;

					// use CharNext/ExA to handle DBCS directory and file names
					while (*szNextTransform && *szNextTransform != TEXT(';'))
#ifdef UNICODE
						szNextTransform = CharNext(szNextTransform);
#else
						szNextTransform = CharNextExA(0, szNextTransform, 0);
#endif
					
					// if reached the null terminator, don't increment past it. But if
					// reached a semicolon, increment the next transform pointer to the 
					// beginning of the actual transform path.
					if (*szNextTransform)
						*(szNextTransform++)='\0';

					// if the transform name begins with ':', its embedded in the package and
					// is not cached
					if (*szTransform==TEXT(':'))
						continue;
					
					// search for a backslash to see if this is a secure full-path transform
					TCHAR *szTransformFilename=szNextTransform;
					do
					{
#ifdef UNICODE
						szTransformFilename = CharPrev(szTransform, szTransformFilename);
#else
						szTransformFilename = CharPrevExA(0, szTransform, szTransformFilename, 0);
#endif
						if (*szTransformFilename == '\\')
						{
							szTransformFilename++;
							break;
						}
					}
					while (szTransformFilename != szTransform);

					// check for existance of cached transform and open the file
					lstrcpy(&rgchFullPath[iBasePathEnd], szTransformFilename);
					
					HANDLE hSourceFile = CreateFile(rgchFullPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
					
					DWORD dwLastError = GetLastError();
					
					if(hSourceFile == INVALID_HANDLE_VALUE)
					{
					if (dwLastError != ERROR_FILE_NOT_FOUND)
					{
						DEBUGMSG4("Warning: Unable to open cached transform %s for user %s, product %s. Result: %d.", szTransform, szUser, rgchProduct, dwResult);
						continue;
					}
					else
						// transform is missing. No big deal.
						continue;
					}

					// add the old transform to the "delete on success" list.
					MsiRecordSetString(hFileRec, 1, rgchFullPath);
					MsiRecordSetInteger(hFileRec, 2, 1);
					MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);

					// copy the file from source to Generated destination file. generated transform names are 8.3
					TCHAR rgchTransformFile[13];
					HANDLE hDestFile = INVALID_HANDLE_VALUE;
					GenerateSecureTempFile(rgchInstallerDir, szTransformExtension, &sa, rgchTransformFile, hDestFile);
		
					if (!CopyOpenedFile(hSourceFile, hDestFile))
					{
						DEBUGMSG3("Warning: Unable to copy Transform for user %s, product %s, Transform %s.", szUser, rgchProduct, szTransform);
						continue;
					}

					CloseHandle(hSourceFile);
					CloseHandle(hDestFile);
		
					// add the new transform to the "delete on failure" list.
					lstrcpy(&rgchTransformFullPath[iInstallerPathEnd], rgchTransformFile);
					hFileRec = MsiCreateRecord(2);
					MsiRecordSetString(hFileRec, 1, rgchTransformFullPath);
					MsiRecordSetInteger(hFileRec, 2, 0);
					MsiViewModify(hCleanUpTable, MSIMODIFY_MERGE, hFileRec);

					// set the new transform mapping value
					if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hTransformsKey, szTransform, 0, REG_SZ, 
							reinterpret_cast<unsigned char*>(rgchTransformFile), (lstrlen(rgchTransformFile)+1)*sizeof(TCHAR))))
					{
						DEBUGMSG4("Warning: Unable to create new Transform value for user %s, product %s, Transform %s. Result: %d.", szUser, rgchProduct, szTransform, dwResult);
					}
				}
			}
			RegCloseKey(hTransformsKey);
		}
	}
	else if (dwResult != ERROR_FILE_NOT_FOUND)
	{
		DEBUGMSG3("Warning: Could not retrieve transform information for user %s, product %s. Result: %d. ", szUser, rgchProduct, dwResult);
	}

	delete[] szTransformList;
	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// Given a product code, user, and managed state, opens the old product
// key. Returns ERROR_SUCCESS if opened, ERROR_NO_DATA if no such
// product, ERROR_FUNCTION_FAILED, or ERROR_OUTOFMEMORY;
DWORD OpenOldProductKey(eManagedType eManaged, LPCTSTR szUser, TCHAR rgchProduct[cchGUIDPacked+1], HKEY hHKCUKey, HKEY *hOldProductKey)
{
	DWORD dwResult = ERROR_SUCCESS;
	bool fACLMatters = false;
	
	HKEY hKey;
	switch (eManaged)
	{
	case emtNonManaged:
	{
		dwResult = RegOpenKeyEx(hHKCUKey ? hHKCUKey : HKEY_CURRENT_USER, szPerUserInstallKeyName, 0, KEY_ENUMERATE_SUB_KEYS, &hKey);
		fACLMatters = false;
		break;
	}
	case emtUserManaged:
	{
		HKEY hUserKey;
		TCHAR *szUserKey = new TCHAR[cchPerUserManagedInstallKeyName+lstrlen(szUser)+cchPerUserManagedInstallSubKeyName+1];
  		if (!szUserKey)
		{
			DEBUGMSG("Error: Out of memory.");
			return ERROR_OUTOFMEMORY;
		}

		lstrcpy(szUserKey, szPerUserManagedInstallKeyName);
		lstrcat(szUserKey, szUser);
		lstrcat(szUserKey, szPerUserManagedInstallSubKeyName);

		dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szUserKey, 0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey);
		fACLMatters = true;

		delete[] szUserKey;
	}
	case emtMachineManaged:
	{
		dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPerMachineInstallKeyName, 0, READ_CONTROL | KEY_ENUMERATE_SUB_KEYS, &hKey);
		fACLMatters = true;
		break;
	}
	default:
	{
		DEBUGMSG("Error: Invalid Managed type in OpenOldProductKey.");
		dwResult = ERROR_FUNCTION_FAILED;
		break;
	}
	}

	if (ERROR_SUCCESS != dwResult)
	{
		// if the reason that this failed is that the key doesn't exist, product is missing. So "no data'
		if (ERROR_FILE_NOT_FOUND == dwResult)
			return ERROR_NO_DATA;
		
		DEBUGMSG2("Error: Failed to open product key for %s. Result: %d.", rgchProduct, dwResult);
		return ERROR_FUNCTION_FAILED;		
	}
	else
	{
		// if concerned about the ACL on the key, check now
		if (fACLMatters && !FIsKeyLocalSystemOrAdminOwned(hKey))
		{
			RegCloseKey(hKey);
			DEBUGMSG1("Error: Product key for %s exists but is not owned by system or admin. Ignoring.", rgchProduct);
			return ERROR_NO_DATA;
		}
	
		// open the product key 
		dwResult = RegOpenKeyEx(hKey, rgchProduct, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, hOldProductKey);
		RegCloseKey(hKey);
		if (ERROR_SUCCESS != dwResult)
		{		
			// if the reason that this failed is that the key doesn't exist, the product is not installed
			if (ERROR_FILE_NOT_FOUND != dwResult)
			{
				DEBUGMSG2("Error: Failed to open product key for %s. Result: %d.", rgchProduct, dwResult);
				return ERROR_FUNCTION_FAILED;
			}
			return ERROR_NO_DATA;
		}
	}
	return ERROR_SUCCESS;
}



///////////////////////////////////////////////////////////////////////
// Given a user name and product code, migrates the ARP information
// from the Uninstall key to the per-user InstallProperties
// key for the product. Excludes the LocalPackage value, but otherwise
// has no understanding of the values moved. Returns ERROR_SUCCESS, 
// ERROR_FUNCTION_FAILED, or ERROR_OUTOFMEMORY.
DWORD MigrateUninstallInformation(MSIHANDLE hDatabase, HKEY hNewProductKey, TCHAR* szUser, TCHAR rgchProduct[cchGUIDPacked+1])
{
	DWORD dwResult = ERROR_SUCCESS;

	// open the old Uninstall key
	HKEY hUninstallKey;
	if (ERROR_SUCCESS != (dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldUninstallKeyName,
												  0, KEY_ENUMERATE_SUB_KEYS, &hUninstallKey)))
	{
		// if the reason that this failed is that the key doesn't exist, no products are installed. So return success
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG1("Error: Could not open old uninstall key. Result: %d. ", dwResult);
			return ERROR_SUCCESS;
		}
		return ERROR_SUCCESS;
	}

	// unpack product code to load Uninstall key
	TCHAR rgchGUID[cchGUID+1];
	UnpackGUID(rgchProduct, rgchGUID);

	// open the unpacked-GUID subkey of the product key.
	HKEY hOldPropertyKey;
	dwResult = RegOpenKeyEx(hUninstallKey, rgchGUID, 0, KEY_QUERY_VALUE, &hOldPropertyKey);
	RegCloseKey(hUninstallKey);
	if (ERROR_SUCCESS != dwResult)
	{
		// if the reason that this failed is that the key doesn't exist, the product is not installed.
		if (ERROR_FILE_NOT_FOUND != dwResult)
		{
			DEBUGMSG2("Error: Could not open old uninstall key for product %s. Result: %d. ", rgchProduct, dwResult);
			return ERROR_SUCCESS;
		}
		return ERROR_SUCCESS;
	}

	// query the old uninstall key for information
	DWORD cValues;
	DWORD cchMaxValueNameLen;
	DWORD cbMaxValueLen;
	if (ERROR_SUCCESS != (dwResult = RegQueryInfoKey(hOldPropertyKey, NULL, NULL, 0, 
										 NULL, NULL, NULL, &cValues, &cchMaxValueNameLen, 
										 &cbMaxValueLen, NULL, NULL)))
	{
		DEBUGMSG2("Error: Could not retrieve key information for uninstall key of product %s. Result: %d. Skipping component.", rgchProduct, dwResult);
		RegCloseKey(hOldPropertyKey);
		return ERROR_SUCCESS;
	}

	if (cValues == 0)
	{
		RegCloseKey(hOldPropertyKey);
		return ERROR_SUCCESS;
	}

	// allocate memory to grab the name and value from the uninstall key
	TCHAR *szName = new TCHAR[++cchMaxValueNameLen];
	if (!szName)
	{
		DEBUGMSG("Error: out of memory.");
		RegCloseKey(hOldPropertyKey);
		return ERROR_OUTOFMEMORY;
	}

	unsigned char *pValue = new unsigned char[cbMaxValueLen];
	if (!pValue)
	{
		delete[] szName;
		DEBUGMSG("Error: out of memory.");
		RegCloseKey(hOldPropertyKey);
		return ERROR_OUTOFMEMORY;
	}


	// grab SD for new InstallProperties key.
	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// open the InstallPropertiesKey under the Product Key
	HKEY hNewPropertyKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hNewProductKey, szNewInstallPropertiesSubKeyName, &sa, &hNewPropertyKey)))
	{
		delete[] szName;
		delete[] pValue;
		DEBUGMSG3("Warning: Unable to create new InstallProperties key for user %s, product %s. Result: %d.", szUser, rgchProduct, dwResult);
		RegCloseKey(hOldPropertyKey);
		return ERROR_FUNCTION_FAILED;
	}

	// loop through all values under the Uninstall key.
	DWORD dwValueIndex = 0;
	while (1)
	{
		DWORD cchName = cchMaxValueNameLen;
		DWORD cbValue = cbMaxValueLen;
		DWORD dwType = 0;
		LONG lResult = RegEnumValue(hOldPropertyKey, dwValueIndex++, szName, &cchName,
									0, &dwType, reinterpret_cast<unsigned char*>(pValue), &cbValue);
		if (lResult == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			DEBUGMSG2("Error: Could not enumerate product properties for %s. Result: %d.", rgchProduct, lResult);
			break;
		}

		// if this is the LocalPackage value written by Darwin 1.0, do NOT migrate the key
		// since it would overwrite the new package registration.
		if (0 == lstrcmpi(szName, szNewLocalPackagesValueName))
			continue;

		// create the feature usage value key
        if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hNewPropertyKey, szName, 0, dwType, pValue, cbValue)))
		{
			DEBUGMSG4("Warning: Unable to create new product property %s for user %s, product %s. Result: %d.", szName, szUser, rgchProduct, dwResult);
		}
	}
	delete[] szName;
	delete[] pValue;

	RegCloseKey(hOldPropertyKey);
	RegCloseKey(hNewPropertyKey);
	return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Given a product code, user, managed state, and registry handle to
// the userdata key, migrates all product information from the
// database and the old registry. This includes FeatureComponent data, 
// Feature Usage data, cached packages, and cached transforms. For
// non-managed installs, it also generates the MigratedPatches value
// under InstallProperties. No patches are migrated. Returns
// ERROR_SUCCESS, ERROR_OUTOFMEMORY, ERROR_FUNCTION_FAILED.
DWORD MigrateProduct(MSIHANDLE hDatabase, HKEY hUserDataKey, TCHAR* szUser, TCHAR rgchProduct[cchGUIDPacked+1], eManagedType eManaged, bool fMigrateCachedFiles)
{
	NOTEMSG1("Migrating product %s.", rgchProduct);

	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));
	
	////
	// create the "Products" key underneath the UserData key
	HKEY hProductListKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewProductSubKeyName, &sa, &hProductListKey)))
	{
		DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create the <productcode> key under the Products
	HKEY hProductKey;
	dwResult = CreateSecureRegKey(hProductListKey, rgchProduct, &sa, &hProductKey);
	RegCloseKey(hProductListKey);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
	
	dwResult = MigrateProductFeatureData(hDatabase, hProductKey, szUser, rgchProduct);
	if (ERROR_SUCCESS != dwResult)
	{
		RegCloseKey(hProductKey);
		return dwResult;
	}

	dwResult = MigrateProductFeatureUsageData(hDatabase, hProductKey, szUser, rgchProduct);
	if (ERROR_SUCCESS != dwResult)
	{
		RegCloseKey(hProductKey);
		return dwResult;
	}

	dwResult = MigrateCachedPackage(hDatabase, hProductKey, szUser, rgchProduct, eManaged, /*fCopyCachedPackage=*/false);
	if (ERROR_SUCCESS != dwResult)
	{
		RegCloseKey(hProductKey);
		return dwResult;
	}

	dwResult = MigrateUninstallInformation(hDatabase, hProductKey, szUser, rgchProduct);
	if (ERROR_SUCCESS != dwResult)
	{
		RegCloseKey(hProductKey);
		return dwResult;
	}

	if (eManaged == emtNonManaged)
	{
		dwResult = MigrateUnknownProductPatches(hDatabase, hProductKey, szUser, rgchProduct);
		if (ERROR_SUCCESS != dwResult)
		{
			RegCloseKey(hProductKey);
			return dwResult;
		}
	}

	// open the existing product key to read transform and patch information 
	if (fMigrateCachedFiles)
	{
		HKEY hOldProductKey;
		dwResult = OpenOldProductKey(eManaged, szUser, rgchProduct, 0, &hOldProductKey);
		if (dwResult == ERROR_SUCCESS)
		{
			dwResult = MigrateSecureCachedTransforms(hDatabase, hOldProductKey, hProductKey, szUser, rgchProduct, eManaged);	
		}
		else if (dwResult == ERROR_NO_DATA)
		{
			dwResult = ERROR_SUCCESS;			
		} 
	}

	RegCloseKey(hProductKey);

	return dwResult;
}



///////////////////////////////////////////////////////////////////////
// Given a user SID, migrates all data for that user given that the
// temporary database has been correctly initialized with all
// machine information. Migrates Component Data, Product data, and 
// Patches. Returns ERROR_SUCCESS, ERROR_FUNCTION_FAILED, or
// ERROR_OUTOFMEMORY
DWORD MigrateUser(MSIHANDLE hDatabase, TCHAR* szUser, bool fMigrateCachedFiles)
{
	NOTEMSG1("Migrating user: %s.", szUser);

	////
	// create the new key
	DWORD dwDisposition = 0;
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create "UserData" key
	HKEY hKey;
 	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(HKEY_LOCAL_MACHINE, szNewBaseUserKeyName, &sa, &hKey)))
	{
		DEBUGMSG1("Error: Unable to create new UserData key. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create SID key
	HKEY hUserDataKey;
	dwResult = CreateSecureRegKey(hKey, szUser, &sa, &hUserDataKey);
	RegCloseKey(hKey);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG2("Error: Unable to create new userdata key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;		 
	}

	// migrate component data and set up SharedDLL changes required for this user.
	if (ERROR_SUCCESS != (dwResult = MigrateUserComponentData(hDatabase, hUserDataKey, szUser)))
		return dwResult;

	// open query to retrieve products installed for this user.
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);	
	MsiRecordSetString(hQueryRec, 1, szUser);
	PMSIHANDLE hProductView;
	if (ERROR_SUCCESS != MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product`, `Managed` FROM `Products` WHERE `User`=?"), &hProductView) ||
		ERROR_SUCCESS != MsiViewExecute(hProductView, hQueryRec))
	{
		DEBUGMSG2("Error: Unable to create product query for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
		
	// retrieve all products currently installed for this user.
	PMSIHANDLE hProductRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hProductView, &hProductRec)))
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;
		eManagedType eManaged = static_cast<eManagedType>(::MsiRecordGetInteger(hProductRec, 2));
		MsiRecordGetString(hProductRec, 1, rgchProduct, &cchProduct);
		
		// migrate product information
		if (ERROR_SUCCESS != (dwResult = MigrateProduct(hDatabase, hUserDataKey, szUser, rgchProduct, eManaged, fMigrateCachedFiles)))
		{
			DEBUGMSG3("Error: Unable to migrate product %s for user %s. Result: %d.", rgchProduct, szUser, dwResult);
			RegCloseKey(hUserDataKey);
			return ERROR_FUNCTION_FAILED;
		}
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG2("Error: Unable to retrieve all products for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hUserDataKey);
		return ERROR_FUNCTION_FAILED;
	}


	////
	// create the "Patches" key underneath the UserData key
	HKEY hPatchListKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewPatchesSubKeyName, &sa, &hPatchListKey)))
	{
		DEBUGMSG2("Error: Unable to create new Patches key for user %s. Result: %d.", szUser, dwResult);
		RegCloseKey(hUserDataKey);
		return ERROR_FUNCTION_FAILED;
	}
	else
	{
		// migrate all patches for this user
		dwResult = MigrateUserPatches(hDatabase, szUser, hPatchListKey, fMigrateCachedFiles);
		RegCloseKey(hPatchListKey);
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG2("Error: Unable to create new Patches key for user %s. Result: %d.", szUser, dwResult);
			RegCloseKey(hUserDataKey);
			return ERROR_FUNCTION_FAILED;
		}
	}

	// if this is the system, also migrate permanent components
	if (0 == lstrcmp(szUser, szLocalSystemSID))
	{
		if (ERROR_SUCCESS != (dwResult = MigratePermanentComponentData(hDatabase, hUserDataKey)))
		{
			RegCloseKey(hUserDataKey);
			return dwResult;
		}
	}

	RegCloseKey(hUserDataKey);
	return ERROR_SUCCESS;
}


DWORD UpdateSharedDLLRefCounts(MSIHANDLE hDatabase)
{
	DEBUGMSG("Updating SharedDLL reference counts.");
	DWORD dwResult = ERROR_SUCCESS;
	
	////
	// open query for insert into SharedDLL Table
	PMSIHANDLE hRefCountView;
	if (ERROR_SUCCESS != (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT * FROM `SharedDLL`"), &hRefCountView)) ||
	    ERROR_SUCCESS != (dwResult = MsiViewExecute(hRefCountView, 0)))
	{
		DEBUGMSG1("Error: Unable to create query on SharedDLL table. Error %d", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// open the SharedDLLRegistryKey. If the key doesn't exist, create it.
	HKEY hSharedDLLKey;
	if (ERROR_SUCCESS != (dwResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szSharedDLLKeyName, 0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hSharedDLLKey, NULL)))
	{
		DEBUGMSG1("Error: Failed to create SharedDLL key. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	PMSIHANDLE hRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hRefCountView, &hRec)))
	{
		int iOldCount= MsiRecordGetInteger(hRec, 2);
		int iNewCount= MsiRecordGetInteger(hRec, 3);

		// if the old count is the same as the new count, no need to tweak
		if (iOldCount == iNewCount)
			continue;
		
		DWORD cchFileName = MEMORY_DEBUG(MAX_PATH);
		TCHAR *szFileName = new TCHAR[cchFileName];
  		if (!szFileName)
		{
			DEBUGMSG("Error: Out of memory.");
			RegCloseKey(hSharedDLLKey);
			return ERROR_OUTOFMEMORY;
		}

		if (ERROR_MORE_DATA == (dwResult = MsiRecordGetString(hRec, 1, szFileName, &cchFileName)))
		{
			delete[] szFileName;
			szFileName = new TCHAR[++cchFileName];
			if (!szFileName)
			{
				DEBUGMSG("Error: Out of memory");
				RegCloseKey(hSharedDLLKey);
				return ERROR_OUTOFMEMORY;
			}
			dwResult = MsiRecordGetString(hRec, 1, szFileName, &cchFileName);
		}
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG1("Error: Unable to retrive SharedDLL path. Result: %d.", dwResult);
			continue;
		}

		// convert the filename from <drive>?<path> back to <drive>:<path> format
		// before querying the registry
		szFileName[1] = TEXT(':');

		int iRegCount = 0;
		DWORD cbCount = sizeof(iRegCount);
		if (ERROR_SUCCESS != (dwResult = RegQueryValueEx(hSharedDLLKey, szFileName, 0, NULL, reinterpret_cast<unsigned char *>(&iRegCount), &cbCount)))
		{
			// if the value doesn't exist, the registry count is 0. We should set the count
			// to what it should be.
			if (dwResult != ERROR_FILE_NOT_FOUND)
			{
				DEBUGMSG2("Error: Failed to retrieve existing SharedDLL count for %s. Result: %d.", szFileName, dwResult);
				continue;
			}
		}

		// if the number of refcounts in the registry is less than the number of refcounts we can
		// account for
		int iNewRegCount = iRegCount + (iNewCount - iOldCount);

		// if something really bizarre is happening and we actually have fewer refcounts than
		// we did before, and it would drop us below the number of refcounts that we can account
		// for once migration is complete, set the refcount to the new count to ensure that
        // the file doesn't go away until all users uninstall
		if (iNewCount != 0 && iNewRegCount < iNewCount)
			iNewRegCount = iNewCount;

		// if the new regcount is less than 0, it should be 0
		if (iNewRegCount < 0)
			iNewRegCount = 0;
   	
		// if MSI can account for 0 refcounts, and the new count would be less than 0, it means
		// existing refcounts can't be accounted for. Delete the refcounts.
		// all of the existing registry counts are 
		if (iNewCount == 0 && iNewRegCount <= 0)
		{
			if (ERROR_SUCCESS != (dwResult = RegDeleteValue(hSharedDLLKey, szFileName)))
			{
				DEBUGMSG2("Error: Failed set new SharedDLL count for %s. Result: %d.", szFileName, dwResult);
				continue;
			}		
		}
		else
		{
			if (ERROR_SUCCESS != (dwResult = RegSetValueEx(hSharedDLLKey, szFileName, 0, REG_DWORD, reinterpret_cast<unsigned char *>(&iNewRegCount), sizeof(iNewRegCount))))
			{
				DEBUGMSG2("Error: Failed set new SharedDLL count for %s. Result: %d.", szFileName, dwResult);
				continue;
			}
		} 
	}
	if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		DEBUGMSG1("Error: Failed set all SharedDLL counts. Result: %d.", dwResult);
	}

	RegCloseKey(hSharedDLLKey);
	return ERROR_SUCCESS;
}

DWORD WriteProductRegistrationDataFromDatabase(MSIHANDLE hDatabase, bool fMigrateSharedDLL, bool fMigratePatches)
{
	DWORD dwResult = ERROR_SUCCESS;

	// query for distinct users on the machine
 	PMSIHANDLE hUserView;
	if (ERROR_SUCCESS == dwResult)
	{
		if (ERROR_SUCCESS == (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT DISTINCT `User` FROM `Products`"), &hUserView)) &&
			ERROR_SUCCESS == (dwResult = MsiViewExecute(hUserView, 0)))
		{
			// default SID size is 256
			PMSIHANDLE hRec;
			DWORD cchUserSID = MEMORY_DEBUG(256);
			TCHAR* szUserSID = new TCHAR[cchUserSID];
			if (!szUserSID)
				dwResult = ERROR_OUTOFMEMORY;
							
			// loop across all users
			while (ERROR_SUCCESS == dwResult)
			{
				if (ERROR_SUCCESS != (dwResult = MsiViewFetch(hUserView, &hRec)))
					break;
			
				// retrieve the user SID
				DWORD cchTempSID = cchUserSID;
				dwResult = MsiRecordGetString(hRec, 1, szUserSID, &cchTempSID);
				if (ERROR_MORE_DATA == dwResult)
				{
					delete[] szUserSID;
					cchUserSID = ++cchUserSID;
					szUserSID = new TCHAR[++cchTempSID];
					if (!szUserSID)
					{
						dwResult = ERROR_OUTOFMEMORY;
						break;
					}
	
					dwResult = MsiRecordGetString(hRec, 1, szUserSID, &cchTempSID);
				}
				if (ERROR_SUCCESS != dwResult)
					break;
		
				// migrate all user information
				dwResult = MigrateUser(hDatabase, szUserSID, fMigratePatches);
			}
			delete[] szUserSID;
			szUserSID = NULL;
		}
	}
	if (ERROR_NO_MORE_ITEMS == dwResult)
		dwResult = ERROR_SUCCESS;

	if (ERROR_SUCCESS == dwResult && fMigrateSharedDLL)
		dwResult = UpdateSharedDLLRefCounts(hDatabase);

	return dwResult;
}




///////////////////////////////////////////////////////////////////////
// Given a user SID, migrates all cached package data for that user, 
// given that the temporary database has been correctly initialized 
// with all machine information. Migrates cached packages and cached
// transforms. Returns ERROR_SUCCESS, ERROR_FUNCTION_FAILED, or
// ERROR_OUTOFMEMORY
DWORD MigrateCachedDataFromWin9X(MSIHANDLE hDatabase, HKEY hUserHKCUKey, HKEY hUserDataKey, LPCTSTR szUser)
{
	NOTEMSG1("Migrating user: %s.", szUser);

	////
	// create the new key
	DWORD dwDisposition = 0;
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));


	// open query to retrieve products installed for this user.
	PMSIHANDLE hQueryRec = ::MsiCreateRecord(1);	
	MsiRecordSetString(hQueryRec, 1, szUser);
	PMSIHANDLE hProductView;
	if (ERROR_SUCCESS != MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Product`, `Managed` FROM `Products` WHERE `User`=?"), &hProductView) ||
		ERROR_SUCCESS != MsiViewExecute(hProductView, hQueryRec))
	{
		DEBUGMSG2("Error: Unable to create product query for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
	
	////
	// create the "Products" key underneath the UserData key
	HKEY hProductListKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(hUserDataKey, szNewProductSubKeyName, &sa, &hProductListKey)))
	{
		DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
		return ERROR_FUNCTION_FAILED;
	}
		
	// retrieve all products currently installed for this user.
	PMSIHANDLE hProductRec;
	while (ERROR_SUCCESS == (dwResult = MsiViewFetch(hProductView, &hProductRec)))
	{
		TCHAR rgchProduct[cchGUIDPacked+1];
		DWORD cchProduct = cchGUIDPacked+1;
		eManagedType eManaged = static_cast<eManagedType>(::MsiRecordGetInteger(hProductRec, 2));
		MsiRecordGetString(hProductRec, 1, rgchProduct, &cchProduct);
		
		// create the <productcode> key under the Products
		HKEY hProductKey;
		dwResult = CreateSecureRegKey(hProductListKey, rgchProduct, &sa, &hProductKey);
		if (ERROR_SUCCESS != dwResult)
		{
			DEBUGMSG2("Error: Unable to create new component key for user %s. Result: %d.", szUser, dwResult);
			continue;
		}

		// migrate cached packages
		MigrateCachedPackage(hDatabase, hProductKey, szUser, rgchProduct, eManaged, /*fCopyCachedPackage=*/true);

		// write the "MigratedPatches" key to assist in proper cleanup with the product is uninstalled
		MigrateUnknownProductPatches(hDatabase, hProductKey, szUser, rgchProduct);

		// open the existing product key to read transform information 
		HKEY hOldProductKey;
		dwResult = OpenOldProductKey(eManaged, szUser, rgchProduct, hUserHKCUKey, &hOldProductKey);
		if (dwResult == ERROR_SUCCESS)
		{
			MigrateSecureCachedTransforms(hDatabase, hOldProductKey, hProductKey, szUser, rgchProduct, eManaged);	
			RegCloseKey(hOldProductKey);
		}
		else if (dwResult == ERROR_NO_DATA)
		{
			dwResult = ERROR_SUCCESS;			
		} 
	}
	RegCloseKey(hProductListKey);

	////
	// create the "Patches" key underneath the UserData key
	HKEY hPatchListKey;
	if (ERROR_SUCCESS == (dwResult = CreateSecureRegKey(hUserDataKey, szNewPatchesSubKeyName, &sa, &hPatchListKey)))
	{
		// migrate all patches for this user
		MigrateUserPatches(hDatabase, szUser, hPatchListKey, /*fCopyCachedPatches=*/true);
		RegCloseKey(hPatchListKey);
	}

	return ERROR_SUCCESS;
}

DWORD MigrateSingleUserOnlyComponentData(MSIHANDLE hDatabase, LPCTSTR szUserSID)
{
	////
	// create the new key
	DWORD dwDisposition = 0;
	DWORD dwResult = ERROR_SUCCESS;

	SECURITY_ATTRIBUTES sa;
	sa.nLength        = sizeof(sa);
	sa.bInheritHandle = FALSE;
	GetSecureSecurityDescriptor(reinterpret_cast<char**>(&sa.lpSecurityDescriptor));

	// create "UserData" key
	HKEY hKey;
	if (ERROR_SUCCESS != (dwResult = CreateSecureRegKey(HKEY_LOCAL_MACHINE, szNewBaseUserKeyName, &sa, &hKey)))
	{
		DEBUGMSG1("Error: Unable to create new UserData key. Result: %d.", dwResult);
		return ERROR_FUNCTION_FAILED;
	}

	// create SID key
	HKEY hUserDataKey;
	dwResult = CreateSecureRegKey(hKey, szUserSID, &sa, &hUserDataKey);
	RegCloseKey(hKey);
	if (ERROR_SUCCESS != dwResult)
	{
		DEBUGMSG2("Error: Unable to create new userdata key for user %s. Result: %d.", szUserSID, dwResult);
		return ERROR_FUNCTION_FAILED;		 
	}

	// migrate component data and set up SharedDLL changes required for this user.
	if (ERROR_SUCCESS != (dwResult = MigrateUserComponentData(hDatabase, hUserDataKey, szUserSID)))
		return dwResult;

	// if this is the system, also migrate permanent components
	if (0 == lstrcmp(szUserSID, szLocalSystemSID))
	{
		if (ERROR_SUCCESS != (dwResult = MigratePermanentComponentData(hDatabase, hUserDataKey)))
		{
			RegCloseKey(hUserDataKey);
			return dwResult;
		}
	}

	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Writes all component registration paths (including permanent
// components) for all users and updates database SharedDLL counts.
// Does not write any other user data. 
DWORD MigrateUserOnlyComponentData(MSIHANDLE hDatabase)
{
	DWORD dwResult = ERROR_SUCCESS;
	bool fMigratedSystem = false;

	// query for distinct users on the machine
 	PMSIHANDLE hUserView;
	if (ERROR_SUCCESS == dwResult)
	{
		if (ERROR_SUCCESS == (dwResult = MsiDatabaseOpenView(hDatabase, TEXT("SELECT DISTINCT `User` FROM `Products`"), &hUserView)) &&
			ERROR_SUCCESS == (dwResult = MsiViewExecute(hUserView, 0)))
		{
			// default SID size is 256
			PMSIHANDLE hRec;
			DWORD cchUserSID = MEMORY_DEBUG(256);
			TCHAR* szUserSID = new TCHAR[cchUserSID];
			if (!szUserSID)
				dwResult = ERROR_OUTOFMEMORY;
							
			// loop across all users
			while (ERROR_SUCCESS == dwResult)
			{
				if (ERROR_SUCCESS != (dwResult = MsiViewFetch(hUserView, &hRec)))
					break;
			
				// retrieve the user SID
				DWORD cchTempSID = cchUserSID;
				dwResult = MsiRecordGetString(hRec, 1, szUserSID, &cchTempSID);
				if (ERROR_MORE_DATA == dwResult)
				{
					delete[] szUserSID;
					cchUserSID = ++cchUserSID;
					szUserSID = new TCHAR[++cchTempSID];
					if (!szUserSID)
					{
						dwResult = ERROR_OUTOFMEMORY;
						break;
					}
	
					dwResult = MsiRecordGetString(hRec, 1, szUserSID, &cchTempSID);
				}
				if (ERROR_SUCCESS != dwResult)
					break;
		
				// on failure just move on to the next user
	 			MigrateSingleUserOnlyComponentData(hDatabase, szUserSID);
				if (0 == lstrcmp(szUserSID, szLocalSystemSID))
					fMigratedSystem = true;

			}
			delete[] szUserSID;
			szUserSID = NULL;
			if (ERROR_NO_MORE_ITEMS == dwResult)
				dwResult = ERROR_SUCCESS;
		}

		// always migrate the system account so that permanent components
		// are registered correctly
		if (!fMigratedSystem)
			MigrateSingleUserOnlyComponentData(hDatabase, szLocalSystemSID);
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msishort\msishort.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <setupapi.h>
#include <assert.h>
#include <limits.h>
#include "shlobj.h"
#include "shlwapi.h"
#include "msi.h"

bool g_fWin9X = false;
int g_iMajorVersion = 0;
int g_iMinorVersion = 0;
int g_iBuildNumber = 0;


// API names used in GetProcAddress
#define MSIGETSHORTCUTTARGET  "MsiGetShortcutTargetA"
#define DLLGETVERSION         "DllGetVersion"

#define MSGUID(iid) {iid,0,0,{0xC0,0,0,0,0,0,0,0x46}}


// from shlobjp.h

// NT4 Console Server included shell32\shlink.h to get structure
// definitions and mimicked shell32\shlink.c to understand the
// stream format so our stream format is fixed forever. This is
// not bad since it was designed with extension in mind. We need
// to publish (as privately as possible) the file format and
// structures needed to read the file format.
//
// The stream format is a SHELL_LINK_DATA followed by
//   if SLDF_HAS_ID_LIST an ILSaveToStream followed by
//   if SLDF_HAS_LINK_INFO a LINKINFO followed by
//   if SLDF_HAS_NAME a STREAMSTRING followed by
//   if SLDF_RELPATH a STREAMSTRING followed by
//   if SLDF_WORKINGDIR a STREAMSTRING followed by
//   if SLDF_HAS_ARGS a STREAMSTRING followed by
//   if SLDF_HAS_ICON_LOCATION a STREAMSTRING followed by
//   SHWriteDataBlockList list of signature blocks
//
// Where a STREAMSTRING is a USHORT count of characters
// followed by that many (SLDF_UNICODE ? WIDE : ANSI) characters.
//
typedef struct {        // sld
    DWORD       cbSize;                 // signature for this data structure
    CLSID       clsid;                  // our GUID
    DWORD       dwFlags;                // SHELL_LINK_DATA_FLAGS enumeration

    DWORD       dwFileAttributes;
    FILETIME    ftCreationTime;
    FILETIME    ftLastAccessTime;
    FILETIME    ftLastWriteTime;
    DWORD       nFileSizeLow;

    int         iIcon;
    int         iShowCmd;
    WORD        wHotkey;
    WORD        wUnused;
    DWORD       dwRes1;
    DWORD       dwRes2;
} SHELL_LINK_DATA, *LPSHELL_LINK_DATA;


#define WIN
#define OLE32

// defines for guid separators
#define chComponentGUIDSeparatorToken    '>'
#define chGUIDAbsentToken                '<'
#define chGUIDCOMToCOMPlusInteropToken   '|'

enum ipgEnum
{
	ipgFull       = 0,  // no compression
	ipgPacked     = 1,  // remove punctuation and reorder low byte first
	ipgCompressed = 2,  // max text compression, can't use in reg keys or value names
	ipgPartial    = 3,  // partial translation, between ipgCompressed and ipgPacked
//  ipgMapped     = 4,  // pack as mapped token (not implemented)
	ipgTrimmed    = 5,  // remove punctuation only - don't reorder
};

const int cchMaxFeatureName           = MAX_FEATURE_CHARS;
const int cchGUID                     = 38;
const int cchGUIDCompressed           = 20;  // used in descriptors only
const int cchComponentId              = cchGUID;
const int cchComponentIdCompressed    = cchGUIDCompressed;
const int cchProductCode              = cchGUID;
const int cchProductCodeCompressed    = cchGUIDCompressed;

const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
									   21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 

const unsigned char rgTrimGUID[32]  = {1,2,3,4,5,6,7,8, 10,11,12,13, 15,16,17,18,
									   20,21, 22,23, 25,26, 27,28, 29,30, 31,32, 33,34, 35,36}; 

const unsigned char rgOrderDash[4] = {9, 14, 19, 24};

const unsigned char rgDecodeSQUID[95] =
{  0,85,85,1,2,3,4,5,6,7,8,9,10,11,85,12,13,14,15,16,17,18,19,20,21,85,85,85,22,85,23,24,
// !  "  # $ % & ' ( ) * + ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  @
  25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,85,52,53,54,55,
// A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  `
  56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,85,83,84,85};
// a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^ 0x7F

typedef HRESULT (__stdcall *LPDLLGETVERSION)(DLLVERSIONINFO *);
typedef UINT (WINAPI *pfnMsiGetShortcutTargetA)(
	LPCSTR    szShortcutPath,    // full file path for the shortcut
	LPSTR     szProductCode,     // returned product code   - GUID
	LPSTR     szFeatureId,       // returned Feature Id.
	LPSTR     szComponentCode);  // returned component code - GUID


/*****************************************************
*
*  Functions I've copied from Src\Engine\Msinst.cpp
*
*****************************************************/


UINT DoCoInitialize()
{
	HRESULT hRes = OLE32::CoInitialize(0);  // we're statically linked into OLE32.DLL

	if (SUCCEEDED(hRes))
	{
		return hRes;
	}
	else if (RPC_E_CHANGED_MODE == hRes)
	{
		//?? Is this OK to ignore? 

		// ignore -- OLE has been initialized with COINIT_MULTITHREADED
	}
	else
	{
		return ERROR_INSTALL_FAILURE;
	}

	return E_FAIL;
}


bool UnpackGUID(const char* szSQUID, char* szGUID, ipgEnum ipg)
{ 
	const unsigned char* pch;
	switch (ipg)
	{
	case ipgFull:
		lstrcpynA(szGUID, szSQUID, cchGUID+1);
		return true;
	case ipgPacked:
	{
		pch = rgOrderGUID;
		while (pch < rgOrderGUID + sizeof(rgOrderGUID))
			if (*szSQUID)
				szGUID[*pch++] = *szSQUID++;
			else              // unexpected end of string
				return false;
		break;
	}
	case ipgTrimmed:
	{
		pch = rgTrimGUID;
		while (pch < rgTrimGUID + sizeof(rgTrimGUID))
			if (*szSQUID)
				szGUID[*pch++] = *szSQUID++;
			else              // unexpected end of string
				return false;
		break;
	}
	case ipgCompressed:
	{
		pch = rgOrderGUID;
#ifdef DEBUG //!! should not be here for performance reasons, onus is on caller to insure buffer is sized properly
		int cchTemp = 0;
		while (cchTemp < cchGUIDCompressed)     // check if string is atleast cchGUIDCompressed chars long,
			if (!(szSQUID[cchTemp++]))          // can't use lstrlen as string doesn't HAVE to be null-terminated.
				return false;
#endif
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return false;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				szGUID[*pch++] = (char)ch;
				iTotal >>= 4;
			}
		}
		break;
	}
	case ipgPartial:
	{
		for (int il = 0; il < 4; il++)
		{
			int cch = 5;
			unsigned int iTotal = 0;
			while (cch--)
			{
				unsigned int iNew = szSQUID[cch] - '!';
				if (iNew >= sizeof(rgDecodeSQUID) || (iNew = rgDecodeSQUID[iNew]) == 85)
					return false;   // illegal character
				iTotal = iTotal * 85 + iNew;
			}
			szSQUID += 5;
			for (int ich = 0; ich < 8; ich++)
			{
				int ch = (iTotal & 15) + '0';
				if (ch > '9')
					ch += 'A' - ('9' + 1);
				*szGUID++ = (char)ch;
				iTotal >>= 4;
			}
		}
		*szGUID = 0;
		return true;
	}
	default:
		return false;
	} // end switch
	pch = rgOrderDash;
	while (pch < rgOrderDash + sizeof(rgOrderDash))
		szGUID[*pch++] = '-';
	szGUID[0]         = '{';
	szGUID[cchGUID-1] = '}';
	szGUID[cchGUID]   = 0;
	return true;
}


BOOL DecomposeDescriptor(
							const char* szDescriptor,
							char* szProductCode,
							char* szFeatureId,
							char* szComponentCode,
							DWORD* pcchArgsOffset,	
							DWORD* pcchArgs = 0,
							bool* pfComClassicInteropForAssembly = 0
							)

/*----------------------------------------------------------------------------
Decomposes a descriptor plus optional args into its constituent parts. 

Arguments:
	szDescriptor:  the descriptor optionally followed by arguments
	szProductCode: a buffer of size cchGUID+1 to contain the descriptor's
						product code. May be NULL if not desired.
	szFeatureId:   a buffer of size cchMaxFeatureName+1 to contain the
						descriptor's feature ID. May be NULL if not desired.
	szComponentCode: a buffer of size cchGUID+1 to contain the
						  descriptor's component code. May be NULL if not desired.
	pcchArgsOffset: Will contain the character offset to the args. May be NULL
						 if not desired.
Returns:
	TRUE - Success
	FALSE - szDescriptor was of invalid form
------------------------------------------------------------------------------*/
{
	assert(szDescriptor);

	const char* pchDescriptor = szDescriptor;
	int cchDescriptor          = lstrlenA(pchDescriptor);
	int cchDescriptorRemaining = cchDescriptor;

	if (cchDescriptorRemaining < cchProductCodeCompressed) // minimum size of a descriptor
		return FALSE;

	char szProductCodeLocal[cchProductCode + 1];
	char szFeatureIdLocal[cchMaxFeatureName + 1];
	bool fComClassicInteropForAssembly = false;


	// we need these values locally for optimised descriptors
	if (!szProductCode)
		szProductCode = szProductCodeLocal; 
	if (!szFeatureId)
		szFeatureId = szFeatureIdLocal;
	if(!pfComClassicInteropForAssembly)
		pfComClassicInteropForAssembly = &fComClassicInteropForAssembly;
	char* pszCurr = szFeatureId;

	if(*pchDescriptor == chGUIDCOMToCOMPlusInteropToken)
	{
		pchDescriptor++;
		*pfComClassicInteropForAssembly = true;
	}
	else
	{
		*pfComClassicInteropForAssembly = false;
	}

	// unpack the product code
	if (!UnpackGUID(pchDescriptor, szProductCode, ipgCompressed))
		return FALSE;

	pchDescriptor += cchProductCodeCompressed;
	cchDescriptorRemaining -= cchProductCodeCompressed;

	int cchFeatureRemaining = cchMaxFeatureName;

	// look for the feature
	while ((*pchDescriptor != chComponentGUIDSeparatorToken) && (*pchDescriptor != chGUIDAbsentToken))
	{
		// have we exceeded the maximum feature size
		if(!cchFeatureRemaining--)
			return FALSE; 

		*pszCurr++ = *pchDescriptor;

		pchDescriptor++;
		// have we reached the end without encountering either 
		// the chComponentGUIDSeparatorToken or the chGUIDAbsentToken
		if(--cchDescriptorRemaining == 0)
			return FALSE; 
	}

	if(pchDescriptor - szDescriptor == (*pfComClassicInteropForAssembly == false ? cchProductCodeCompressed : cchProductCodeCompressed + 1))// we do not have the feature
	{
		if(MsiEnumFeaturesA(szProductCode, 0, szFeatureId, 0) != ERROR_SUCCESS)
			return FALSE;
		char szFeatureIdTmp[cchMaxFeatureName + 1];
		if(MsiEnumFeaturesA(szProductCode, 1, szFeatureIdTmp, 0) != ERROR_NO_MORE_ITEMS) //?? product was supposed to have only one feature
			return FALSE;
	}
	else
		*pszCurr = 0;
	
	cchDescriptorRemaining--; // for the chComponentGUIDSeparatorToken or the chGUIDAbsentToken
	if (*pchDescriptor++ == chComponentGUIDSeparatorToken)// we do have the component id
	{
		// do we have enough characters left for a Compressed guid
		if (cchDescriptorRemaining < cchComponentIdCompressed)
			return FALSE;

		if (szComponentCode)
		{
			if (!UnpackGUID(pchDescriptor, szComponentCode, ipgCompressed))
				return FALSE;
		}

		pchDescriptor  += cchComponentIdCompressed;
		cchDescriptorRemaining  -= cchComponentIdCompressed;
	}
	else
	{
		// we do not have a component id
		assert(*(pchDescriptor - 1) == chGUIDAbsentToken);

		if (szComponentCode) // we need to get component code			
			*szComponentCode = 0; // initialize to null since we were not able to get the component here
	}

	if (pcchArgsOffset)
	{
		assert((pchDescriptor - szDescriptor) <= UINT_MAX);			//--merced: 64-bit ptr subtraction may lead to values too big for *pcchArgsOffset
		*pcchArgsOffset = (DWORD)(pchDescriptor - szDescriptor);

		if (pcchArgs)
		{
			*pcchArgs = cchDescriptor - *pcchArgsOffset;
		}
	}

	return TRUE;
}


/*****************************************************
*
*  Functions I've copied from Src\Engine\Services.cpp
*
*****************************************************/


IUnknown* CreateCOMInterface(const CLSID& clsId)
{
	HRESULT hres;
	IUnknown* piunk;

	//!! currently assumes static linking, later change to "LoadLibrary"

//	if(fFalse == m_fCoInitialized)
//	{
//		hres = OLE32::CoInitialize(0);
//		if(FAILED(hres))
//		{
//			return 0;
//		}
//		m_fCoInitialized = fTrue;
//	}

	const int iidUnknown          = 0x00000L;
	#define GUID_IID_IUnknown     MSGUID(iidUnknown)
	const GUID IID_IUnknown = GUID_IID_IUnknown;
	hres = OLE32::CoCreateInstance(clsId,  /* eugend: we're statically linked into OLE32 */
							0,
							CLSCTX_INPROC_SERVER,
							IID_IUnknown,
							(void**)&piunk);
	if (SUCCEEDED(hres))
		return piunk;
	else
		return 0;
}


enum iddSupport{
        iddOLE      = 0,
        iddShell    = 1, // smart shell
};

// Are Darwin Descriptors supported?
bool IsDarwinDescriptorSupported(iddSupport iddType)
{
	static int fRetDD    = -1;
	static int fRetShell = -1;
	if(iddType == iddOLE)
	{
		if(fRetDD == -1) // we have not evaluated as yet
		{
			fRetDD = FALSE; // initialize to false
			// the logic to determine if we can create Darwin Descriptor shortcuts
			if((g_fWin9X == false) && (g_iMajorVersion >= 5))
			{
				// we are on NT 5.0 or greater, we have GPT support
				fRetDD = TRUE;
			}
			else
			{
				// check for the correct entry point that indicates that we have DD support
				HINSTANCE hLib;
				FARPROC pEntry;
				const char rgchGPTSupportEntryDll[] = "OLE32.DLL";
				const char rgchGPTSupportEntry[] = "CoGetClassInfo";
				if((hLib = WIN::LoadLibraryEx(rgchGPTSupportEntryDll, 0, DONT_RESOLVE_DLL_REFERENCES)) != 0)
				{
					if((pEntry = WIN::GetProcAddress(hLib, rgchGPTSupportEntry)) != 0)
					{
						// we have detected the magic entry point, we have GPT support
						fRetDD = TRUE;
					}
					WIN::FreeLibrary(hLib);
				}
			}
		}
		return fRetDD ? true : false;
	}
	else if(iddType == iddShell)
	{
		if(fRetShell == -1) // we have not evaluated as yet
		{
			fRetShell = FALSE;
			HMODULE hShell = WIN::LoadLibraryEx("SHELL32", 0, DONT_RESOLVE_DLL_REFERENCES);
			if ( hShell )
			{
				// SHELL32 detected. Determine version.
				DLLVERSIONINFO VersionInfo;
				memset(&VersionInfo, 0, sizeof(VersionInfo));
				VersionInfo.cbSize = sizeof(DLLVERSIONINFO);
				LPDLLGETVERSION pfVersion = (LPDLLGETVERSION)WIN::GetProcAddress(hShell, DLLGETVERSION);
				if ( pfVersion && (*pfVersion)(&VersionInfo) == ERROR_SUCCESS &&
					  ((VersionInfo.dwMajorVersion > 4) ||
						(VersionInfo.dwMajorVersion == 4 && VersionInfo.dwMinorVersion > 72) ||
						(VersionInfo.dwMajorVersion == 4 && VersionInfo.dwMinorVersion == 72 && VersionInfo.dwBuildNumber >= 3110)))
				{
					 fRetShell = TRUE;
				}
				WIN::FreeLibrary(hShell);
			}
		}
		return fRetShell ? true : false;
	}
	else
	{
		assert(0);// this should never happen
		return false;
	}
}


/*****************************************************
*
*  Functions I've added (eugend)
*
*****************************************************/


UINT LoadMsiAndAPI(HMODULE& hMSI, pfnMsiGetShortcutTargetA& pfAPI)
{
	UINT uResult = ERROR_SUCCESS;
	LPDLLGETVERSION pfVersion = NULL;

	pfAPI = NULL;
	if ( hMSI )
	{
		return ERROR_FUNCTION_FAILED;
//		assert(0);
//		WIN::FreeLibrary(hMSI);
	}
	hMSI = WIN::LoadLibrary("MSI");
	if ( !hMSI )
		return ERROR_NOT_INSTALLED;

	// MSI detected. Get the API.
	pfAPI = (pfnMsiGetShortcutTargetA)WIN::GetProcAddress(hMSI, MSIGETSHORTCUTTARGET);
	if ( !pfAPI )
	{
		// this is possible since MsiGetShortcutTarget API is not implemented in Darwin < 1.1
		uResult = ERROR_CALL_NOT_IMPLEMENTED;
		goto Return;
	}

	// Determine version.
	pfVersion = (LPDLLGETVERSION)::GetProcAddress(hMSI, DLLGETVERSION);
	if ( !pfVersion )
	{
		uResult = ERROR_CALL_NOT_IMPLEMENTED;
		goto Return;
	}
	DLLVERSIONINFO VersionInfo;
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.cbSize = sizeof(DLLVERSIONINFO);
	if ( (*pfVersion)(&VersionInfo) != NOERROR )
	{
		uResult = ERROR_FUNCTION_FAILED;
		goto Return;
	}
	g_iMajorVersion = VersionInfo.dwMajorVersion;
	g_iMinorVersion = VersionInfo.dwMinorVersion;
	g_iBuildNumber = VersionInfo.dwBuildNumber;

Return:
	if ( uResult != ERROR_SUCCESS )
		WIN::FreeLibrary(hMSI);
	return uResult;
}


void CheckOSVersion()
{
	OSVERSIONINFO osviVersion;
	memset(&osviVersion, 0, sizeof(osviVersion));
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	WIN::GetVersionEx(&osviVersion);	// fails only if size set wrong

	if ( osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT )
		g_fWin9X = false;
	else
		g_fWin9X = true;
}

//  Provides a fix to MsiGetShortcutTarget API for ANSI Windows Installer version <= 1.2


UINT DoGetMsiShortcutTarget(LPCSTR szShortcutPath, LPSTR szProductCode, LPSTR szFeatureId, LPSTR szComponentCode);

extern "C"
UINT WINAPI GetMsiShortcutTargetA(
											LPCSTR    szShortcutPath,		// full file path for the shortcut
											LPSTR     szProductCode,		// returned product code   - GUID
											LPSTR     szFeatureId,			// returned Feature Id.
											LPSTR     szComponentCode)	// returned component code - GUID
{
	return DoGetMsiShortcutTarget(szShortcutPath, szProductCode,
											szFeatureId, szComponentCode);
}

LONG MultiByteToWCHAR(LPCSTR pszAString, LPWSTR pszWString)
{
	// converts char string to Unicode  pszWString can be null, in which case returns success.
	if ( !pszWString )
		return ERROR_SUCCESS;

	int cch = MultiByteToWideChar(CP_ACP, 0, pszAString, -1, 0, 0);
	int iRes = MultiByteToWideChar(CP_ACP, 0, pszAString, -1, pszWString, cch);
	return iRes == cch ? ERROR_SUCCESS : WIN::GetLastError();
}

extern "C"
UINT WINAPI GetMsiShortcutTargetW(
											LPCWSTR    szShortcutPath,	  // full file path for the shortcut
											LPWSTR     szProductCode,	  // returned product code   - GUID
											LPWSTR     szFeatureId,		  // returned Feature Id.
											LPWSTR     szComponentCode)	  // returned component code - GUID
{
	char rgchProductCode[cchProductCode+1] = {NULL};
	char rgchFeatureId[cchMaxFeatureName+1] = {NULL};
	char rgchComponentCode[cchComponentId+1] = {NULL};
	int cch = WideCharToMultiByte(CP_ACP, 0, szShortcutPath, -1, 0, 0, 0, 0);
	char* pszShortcutPath = new char[cch];
	if ( !pszShortcutPath )
		return ERROR_NOT_ENOUGH_MEMORY;
	else
		*pszShortcutPath = 0;
	WideCharToMultiByte(CP_ACP, 0, szShortcutPath, -1, pszShortcutPath, cch, 0, 0);

	UINT uResult = DoGetMsiShortcutTarget(pszShortcutPath, rgchProductCode,
													  rgchFeatureId, rgchComponentCode);
	if ( uResult == ERROR_SUCCESS )
		uResult = MultiByteToWCHAR(rgchProductCode, szProductCode);
	if ( uResult == ERROR_SUCCESS )
		uResult = MultiByteToWCHAR(rgchFeatureId, szFeatureId);
	if ( uResult == ERROR_SUCCESS )
		uResult = MultiByteToWCHAR(rgchComponentCode, szComponentCode);

	delete [] pszShortcutPath;
	return uResult;
}

UINT DoGetMsiShortcutTarget(LPCSTR szShortcutPath, LPSTR szProductCode,
									 LPSTR szFeatureId, LPSTR szComponentCode)
{
	if ( !szShortcutPath )
		return ERROR_INVALID_PARAMETER;
	
	UINT uResult = ERROR_SUCCESS;
	IShellLinkDataList* psdl=0;
	IPersistFile* ppf=0;
	HANDLE hFile = 0;
	bool fOLEInitialized = false;
	HMODULE hMSI = 0;
	pfnMsiGetShortcutTargetA pfAPI = NULL;
	const GUID IID_IShellLinkDataList =  
		{0x45e2b4ae, 0xb1c3, 0x11d0, {0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1}};
	const int clsidShellLink = 0x00021401L;
	#define GUID_CLSID_ShellLink MSGUID(clsidShellLink)
	const GUID CLSID_ShellLink = GUID_CLSID_ShellLink;

	uResult = LoadMsiAndAPI(hMSI, pfAPI);
	if ( uResult != ERROR_SUCCESS )
		goto Return;

	CheckOSVersion();

	bool fCallMsiAPI;
	if ( !g_fWin9X )
		// UNICODE MSI.DLL is OK, so it's safe to call directly the API.
		fCallMsiAPI = true;
	else if ( (g_iMajorVersion >= 1) &&
				 (g_iMinorVersion > 20 || 
				  (g_iMinorVersion == 20 && g_iBuildNumber >= 1710)) )
		// we're on Win9x.  The bug was fixed in build 1710
		// so that it is OK to call the API directly.
		fCallMsiAPI = true;
	else
		fCallMsiAPI	= false;

	if(!IsDarwinDescriptorSupported(iddOLE) && !IsDarwinDescriptorSupported(iddShell))
	{
		uResult = E_NOTIMPL;
		goto Return;
	}

	if ( fCallMsiAPI )
	{
		uResult = (*pfAPI)(szShortcutPath, szProductCode, szFeatureId, szComponentCode);
		goto Return;
	}

	// the fixed up code in GetShortcutTarget.  I've commented out stuff that seemed
	// unnecessary.

//!! eugend: moved up a bit
//	if(!IsDarwinDescriptorSupported(iddOLE) && !IsDarwinDescriptorSupported(iddShell))
//		return fFalse;


//!! eugend: moved to top of function
//	if ( ! szShortcutTarget )
//		return fFalse;

//!! eugend: is it possible to elevate/impersonate at this point?
	// impersonate if shortcut is on a network path and we are a service
//	Bool fImpersonate = (g_scServerContext == scService) && (GetImpersonationFromPath(szShortcutTarget) == fTrue) ? fTrue : fFalse;

	uResult = DoCoInitialize();  // this is from MSINST.CPP's MsiGetShortcutTarget
	if ( SUCCEEDED(uResult) )
		fOLEInitialized = true;
	else
		goto Return;
	
	IUnknown *piunk;
	piunk = CreateCOMInterface(CLSID_ShellLink);
	if(piunk == 0)
	{
		uResult = ERROR_FUNCTION_FAILED;
		goto Return;
	}

	HRESULT hres;
	hres = piunk->QueryInterface(IID_IShellLinkDataList, (void **) &psdl);
	piunk->Release();
	if ((FAILED(hres)) || (psdl == 0))
	{
		// IID_IShellLinkDataList not supported try munging through the file itself
		// Try to open the file

//		if(fImpersonate)
//			AssertNonZero(StartImpersonating());
		/*CHandle*/ hFile = CreateFileA(szShortcutPath,
												GENERIC_READ,
												FILE_SHARE_READ,
												NULL,
												OPEN_EXISTING,
												FILE_ATTRIBUTE_NORMAL,
												NULL);

		DWORD dwLastError = GetLastError();
//		if(fImpersonate)
//			StopImpersonating();

		if(hFile == INVALID_HANDLE_VALUE) // unable to open the link file
		{
			uResult = ERROR_FUNCTION_FAILED;
			goto Return;
		}

		SHELL_LINK_DATA sld;
		memset(&sld, 0, sizeof(sld));
		DWORD cbSize=0;

		// Now, read out data...
		DWORD dwNumberOfBytesRead;
		if(!WIN::ReadFile(hFile,(LPVOID)&sld,sizeof(sld),&dwNumberOfBytesRead,0) ||
			sizeof(sld) != dwNumberOfBytesRead) // could not read the shortcut info
		{
			uResult = ERROR_FUNCTION_FAILED;
			goto Return;
		}

		// check to see if the link has a pidl
		if(sld.dwFlags & SLDF_HAS_ID_LIST)
		{
			// Read the size of the IDLIST
			USHORT cbSize1;
			if (!WIN::ReadFile(hFile, (LPVOID)&cbSize1, sizeof(cbSize1), &dwNumberOfBytesRead, 0) ||
				sizeof(cbSize1) != dwNumberOfBytesRead)// could not read the shortcut info
			{
				uResult = ERROR_FUNCTION_FAILED;
				goto Return;
			}

			WIN::SetFilePointer(hFile, cbSize1, 0, FILE_CURRENT);
		}

		// check to see if we have a linkinfo pointer
		if(sld.dwFlags & SLDF_HAS_LINK_INFO)
		{
			// the linkinfo pointer is just a DWORD
			if(!WIN::ReadFile(hFile,(LPVOID)&cbSize,sizeof(cbSize),&dwNumberOfBytesRead,0) ||
				sizeof(cbSize) != dwNumberOfBytesRead) // could not read the shortcut info
			{
				uResult = ERROR_FUNCTION_FAILED;
				goto Return;
			}

			// do we need to advance any further than just a dword?
			if (cbSize >= sizeof(DWORD))
			{
				cbSize -= sizeof(DWORD);
				WIN::SetFilePointer(hFile, cbSize, 0, FILE_CURRENT);
			}
		}

		// is this a unicode link?
		int bUnicode = (sld.dwFlags & SLDF_UNICODE);

		// skip all the string info in the links
		static const unsigned int rgdwFlags[] = {SLDF_HAS_NAME, SLDF_HAS_RELPATH, SLDF_HAS_WORKINGDIR, SLDF_HAS_ARGS, SLDF_HAS_ICONLOCATION, 0};
		for(int cchIndex = 0; rgdwFlags[cchIndex]; cchIndex++)
		{
			if(sld.dwFlags & rgdwFlags[cchIndex])
			{
				USHORT cch;

				// get the size
				if(!WIN::ReadFile(hFile, (LPVOID)&cch, sizeof(cch), &dwNumberOfBytesRead,0) ||
					sizeof(cch) != dwNumberOfBytesRead) // could not read the shortcut info
				{
					uResult = ERROR_FUNCTION_FAILED;
					goto Return;
				}

				// skip over the string
				WIN::SetFilePointer(hFile, cch * (bUnicode ? sizeof(WCHAR) : sizeof(char)), 0, FILE_CURRENT);
			}
		}

		// Read in extra data sections
		EXP_DARWIN_LINK expDarwin;
		for(;;)
		{
			DATABLOCK_HEADER dbh;
			memset(&dbh, 0, sizeof(dbh));

			// read in the datablock header
			if(!WIN::ReadFile(hFile, (LPVOID)&dbh, sizeof(dbh), &dwNumberOfBytesRead,0) ||
				sizeof(dbh) != dwNumberOfBytesRead) // could not read the shortcut info
			{
				uResult = ERROR_FUNCTION_FAILED;
				goto Return;
			}

			// check to see if we have DARWIN extra data
			if (dbh.dwSignature == EXP_DARWIN_ID_SIG)
			{
				// we do, so read the rest of the darwin info
				if(!WIN::ReadFile(hFile, (LPVOID)((char*)&expDarwin + sizeof(dbh)), sizeof(expDarwin) - sizeof(dbh), &dwNumberOfBytesRead, 0) ||
				sizeof(expDarwin) - sizeof(dbh) != dwNumberOfBytesRead)// could not read the shortcut info
				{
					uResult = ERROR_FUNCTION_FAILED;
					goto Return;
				}
				break;// we found the darwin descriptor

			}
			else
			{
				// this is some other extra-data blob, skip it and go on
				WIN::SetFilePointer(hFile, dbh.cbSize - sizeof(dbh), 0, FILE_CURRENT);
			}
		}
		uResult = DecomposeDescriptor(
//#ifdef UNICODE
//							expDarwin.szwDarwinID,
//#else
							expDarwin.szDarwinID,
//#endif
							szProductCode,
							szFeatureId,
							szComponentCode,
							0,
							0,
							0) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
	}
	else
	{
		const int iidPersistFile      = 0x0010BL;
		#define GUID_IID_IPersistFile MSGUID(iidPersistFile)
		const GUID IID_IPersistFile = GUID_IID_IPersistFile;
		hres = psdl->QueryInterface(IID_IPersistFile, (void **) &ppf);
		if ((FAILED(hres)) || (ppf == 0))
		{
			uResult = hres;
			goto Return;
		}
	
/*
		if(fImpersonate)
			AssertNonZero(StartImpersonating());
#ifndef UNICODE
*/			
	
/*
		// called from MsiGetShortcutTarget -- cannot use CTempBuffer.
		CAPITempBuffer<WCHAR, MAX_PATH> wsz; // Buffer for unicode string
		wsz.SetSize(lstrlen(szShortcutTarget) + 1);
		MultiByteToWideChar(CP_ACP, 0, szShortcutTarget, -1, wsz, wsz.GetSize());
		hres = ppf->Load(wsz, STGM_READ);
*/
		// same code as above, rewritten not to use CAPITempBuffer
		int cch = lstrlenA(szShortcutPath);
		WCHAR* pszShortcutPath = new WCHAR[cch+1];
		if ( !pszShortcutPath )
		{
			uResult = ERROR_NOT_ENOUGH_MEMORY;
			goto Return;
		}
		MultiByteToWideChar(CP_ACP, 0, szShortcutPath, -1, pszShortcutPath, cch+1);
		hres = ppf->Load(pszShortcutPath, STGM_READ);
		delete [] pszShortcutPath;
/*
#else
		hres = ppf->Load(szShortcutPath, STGM_READ);
#endif
		if(fImpersonate)
			StopImpersonating();
*/		
		if (FAILED(hres))
		{
			uResult = hres;
			goto Return;
		}
	
		EXP_DARWIN_LINK* pexpDarwin = 0;
	
		hres = psdl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
		if (FAILED(hres) || (pexpDarwin == 0))
		{
			uResult = ERROR_FUNCTION_FAILED;
			goto Return;
		}
	
		uResult = DecomposeDescriptor(
//	#ifdef UNICODE
//								pexpDarwin->szwDarwinID,
//	#else
								pexpDarwin->szDarwinID,
//	#endif
								szProductCode,
								szFeatureId,
								szComponentCode,
								0,
								0,
								0) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
	
		LocalFree(pexpDarwin);
	}

Return:
	if (hMSI)
		WIN::FreeLibrary(hMSI);
	if (hFile)
		WIN::CloseHandle(hFile);
	if (psdl)
		psdl->Release();
	if (ppf)
		ppf->Release();
	if (fOLEInitialized)
		OLE32::CoUninitialize();

	return uResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\initmsi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       initmsi.h
//
//--------------------------------------------------------------------------

#ifndef INITMSI_H
#define INITMSI_H

#include "msispyu.h"

// exposed functions

// initialises MSI values for Msispy
BOOL fInitMSI(HINSTANCE *hResourceInstance);

// creates a new process to handle the help file
//	loads the appropriate help file based on user-LCID
BOOL fHandleHelp(HINSTANCE hResourceInstance);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\initmsi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       initmsi.cpp
//
//--------------------------------------------------------------------------

// initmsi.cpp: MSI initialisation functions for msispy
#include "initmsi.h"
#include "resource.h"
#include "propshts.h"
#include "stdio.h"

// hard-coded component GUIDs and feature Names
#ifdef _X86_  // INTEL
        TCHAR   g_szEXEComponentCode[MAX_GUID+1]        = TEXT("{5CB2D5F3-19DD-11d1-9A9D-006097C4E489}");
        TCHAR   g_szDLLComponentCode[MAX_GUID+1]        = TEXT("{5CB2D5F2-19DD-11d1-9A9D-006097C4E489}");
#elif defined(_IA64_)
        TCHAR   g_szEXEComponentCode[MAX_GUID+1]        = TEXT("{DF0235A7-1FE5-4BE4-BD52-790051AD696C}");
        TCHAR   g_szDLLComponentCode[MAX_GUID+1]        = TEXT("{BE8ABF49-DF0D-42E7-9F51-CACE44E9126B}");
#elif defined(_AMD64_)
//
// ****** fixfix ****** need to assign guids
//

        TCHAR   g_szEXEComponentCode[MAX_GUID+1]        = TEXT("{DF0235A7-1FE5-4BE4-BD52-790051AD696C}");
        TCHAR   g_szDLLComponentCode[MAX_GUID+1]        = TEXT("{BE8ABF49-DF0D-42E7-9F51-CACE44E9126B}");
#else
#error "No Target Architecture"
#endif  // end of if INTEL

        TCHAR   g_szIntlDLLComponentCode[MAX_GUID+1]= TEXT("{B62B2CE0-1A98-11d1-9A9E-006097C4E489}");

TCHAR   g_szHelpComponentCode[MAX_GUID+1]       = TEXT("{1F7586D0-20B1-11d1-9AB3-006097C4E489}"); 
TCHAR   g_szMyProductCode[MAX_GUID+1]           = TEXT("");             // will be obtained at runtime
TCHAR   g_szDLLFeatureName[]                            = TEXT("SystemInterface");
TCHAR   g_szEXEFeatureName[]                            = TEXT("UserInterface");
TCHAR   g_szDefaultQualifier[]                          = TEXT("0");
LCID    g_lcidCurrentLocale;
TCHAR   g_szHelpFilePath[MAX_PATH+1]            = TEXT("");             

extern  MSISPYSTRUCT    g_spyGlobalData;

// This message is displayed if the (localised) resource DLL could not be loaded. 
// This string will always appear in English regardless of the User/System LCID.

#define ERRORMESSAGE_UNABLETOLOADDLL            TEXT("Msispy was unable to load the resource file.\nComponent Code: %s\nError Code: %d")
#define ERRORCAPTION_UNABLETOLOADDLL            TEXT("Msispy: Fatal Error")


// -------------------------------------------------------------------------------------------
// FindComponent()
//      Locates and provides the required component calling MsiProvideQualifiedComponent,
//      using the global LCID (g_lcidCurrentLocale) as the qualifier. If that fails, it
//      tries just the primary lang-ID of g_lcidCurrentLocale. If that fails as well,
//      it tries the default qualifier (g_szDefaultQualifier). Finally if this fails as
//      well it returns the error code of this attempt, else it returns ERROR_SUCCESS
// The path to the component is returned in szPath

UINT FindComponent(
          LPCTSTR       szComponentCode,                // GUID of the component to Provide
          LPTSTR        szPath,                                 //      Buffer for returned path
          DWORD         *pcchPath                               //      size of buffer
          ) 
{
        DWORD   cchPathInitial = *pcchPath;
        lstrcpy(szPath, TEXT(""));                      // set [out] variable to known value

        TCHAR   szQualifier[MAX_PATH+1];
        UINT    iResult;
        for (UINT iCount = 0; 3 > iCount ; iCount++) 
        {
                switch (iCount) 
                {
                case 0: 
                        //      Try the full Language ID
                        wsprintf(szQualifier, TEXT("%4.4x"), LANGIDFROMLCID(g_lcidCurrentLocale));
                        break;

                case 1:
                        // Full language ID failed, try primary Language ID
                        wsprintf(szQualifier, TEXT("%2.2x"), PRIMARYLANGID(LANGIDFROMLCID(g_lcidCurrentLocale)));
                        break;
                        
                case 2:
                        // language IDs failed, try the default qualifier
                        lstrcpy(szQualifier, g_szDefaultQualifier);
                        break;
                }

                *pcchPath = cchPathInitial;
                iResult = MsiProvideQualifiedComponent(szComponentCode, szQualifier, 0, szPath, pcchPath);

                switch (iResult) 
                {
                        case ERROR_SUCCESS:
                        case ERROR_INSTALL_USEREXIT:
                        case ERROR_INSTALL_FAILURE:
                                return iResult;
                }
        }

        // ProvideQualifiedComponent failed 
        return iResult;
}


// -------------------------------------------------------------------------------------------
// fInitMSI()
//      Function to fault in resource DLL and initialise MSI related items
//      Returns TRUE if the MSI initialisation succeeded, FALSE if there 
//      was a fatal error.
//      When the function returns, hResourceInstance points to the hInstance 
//      of the resource DLL if the DLL was loaded successfully

BOOL fInitMSI(HINSTANCE *hResourceInstance) 
{

        // set [out] variable to known value
        *hResourceInstance = 0;

        g_lcidCurrentLocale = GetUserDefaultLCID();
        // Get the product-code of the product using this component.
        // The product-code is not hard-coded in because a component may be
        // shared by multiple products.
        MsiGetProductCode(g_szEXEComponentCode, g_szMyProductCode);

        TCHAR   szIntlDLLPath[MAX_PATH+1];
        DWORD   cchIntlDLLPath = MAX_PATH+1;
        UINT    iResult;
        
        // Try finding the resource DLL- if unsuccessful, inform user and exit
        if (ERROR_SUCCESS != (iResult = FindComponent(g_szIntlDLLComponentCode, szIntlDLLPath, &cchIntlDLLPath)))
        {
                TCHAR   szErrorMessage[MAX_MESSAGE+1];
                wsprintf(szErrorMessage, ERRORMESSAGE_UNABLETOLOADDLL, g_szIntlDLLComponentCode, iResult);

                TCHAR   szErrorCaption[MAX_HEADER+1];
                wsprintf(szErrorCaption, ERRORCAPTION_UNABLETOLOADDLL);

                MessageBox(NULL, szErrorMessage, szErrorCaption, MB_ICONSTOP|MB_OK);
                return FALSE;
        }


        // Load the international DLL
        *hResourceInstance = W32::LoadLibrary(szIntlDLLPath);

        
        // Check if the SystemInterface feature is available for use. If not,
        // call SwitchMode to gray out features that depend on it and inform
        // user.
        // Note that we'll SwitchMode only if the feature was _never_ installed;
        //  if the feature is installed and busted, we'll attempt to re-install 
        //  it when needed.
        if (MsiQueryFeatureState(g_szMyProductCode, g_szDLLFeatureName) == INSTALLSTATE_UNKNOWN) 
        {
                // Switch to Degraded Mode [grays out features that depend on SystemInterface feature]
                SwitchMode(MODE_DEGRADED);

                TCHAR   szRestrMsg[MAX_MESSAGE+1];
                LoadString(*hResourceInstance, IDS_STARTUP_RESTRICTED_MESSAGE, szRestrMsg, MAX_MESSAGE+1);

                TCHAR   szRestrCaption[MAX_HEADER+1];
                LoadString(*hResourceInstance, IDS_STARTUP_RESTRICTED_CAPTION, szRestrCaption, MAX_HEADER+1);

                // Inform user that Msispy is now in "Restricted Mode"
                MessageBox(NULL, szRestrMsg, szRestrCaption, MB_OK|MB_ICONEXCLAMATION);
        }
        else 
                SwitchMode(MODE_NORMAL);


        // Prepare to use the UserInterface feature: check its current state and increase usage count.
        if (ERROR_SUCCESS != MsiProvideComponent(g_szMyProductCode, g_szEXEFeatureName, g_szEXEComponentCode, 
                INSTALLMODE_EXISTING, NULL, NULL))
                if (ERROR_SUCCESS != MsiProvideComponent(g_szMyProductCode, g_szEXEFeatureName, g_szEXEComponentCode, 
                        INSTALLMODE_DEFAULT,  NULL, NULL))
                        return FALSE;

#if 0
        INSTALLSTATE iEXEFeatureState = MsiUseFeature(g_szMyProductCode, g_szEXEFeatureName);

        // If feature is not currently usable, try fixing it
        switch (iEXEFeatureState) 
        {
//      case INSTALLSTATE_DEFAULT:              // no longer used as a returned state
        case INSTALLSTATE_LOCAL:
        case INSTALLSTATE_SOURCE:

                // feature is installed and usable
                return TRUE;

        case INSTALLSTATE_ABSENT:

                // feature isn't installed, try installing it
                if (MsiConfigureFeature(g_szMyProductCode, g_szEXEFeatureName, INSTALLSTATE_LOCAL) != ERROR_SUCCESS)
                        return FALSE;                   // installation failed
                break;

        default:
 
                // feature is busted- try fixing it
                if (MsiReinstallFeature(g_szMyProductCode, g_szEXEFeatureName, 
                        REINSTALLMODE_FILEEQUALVERSION
                        + REINSTALLMODE_MACHINEDATA 
                        + REINSTALLMODE_USERDATA
                        + REINSTALLMODE_SHORTCUT) != ERROR_SUCCESS)
                        return FALSE;                   // we couldn't fix it
                break;
        }
#endif
        return TRUE;
}


// -------------------------------------------------------------------------------------------
// fHandleHelp()
//  Creates a new process to bring up the help
//      Uses FindComponent to load the appropriate help file (based on g_lcidCurrentLocale)

BOOL fHandleHelp(HINSTANCE hResourceInstance) 
{
        DWORD   cchHelpFilePath                         = MAX_PATH+1;
        UINT    iResult                                         = 0;

        if (ERROR_SUCCESS != (iResult = FindComponent(g_szHelpComponentCode, g_szHelpFilePath, &cchHelpFilePath))) 
        {
                // we couldn't find the help file
                TCHAR szErrorMsg[MAX_MESSAGE+1];
                TCHAR szErrorCpn[MAX_HEADER+1];
                LoadString(hResourceInstance, IDS_HELP_FAILED_MESSAGE, szErrorMsg, MAX_MESSAGE+1);
                LoadString(hResourceInstance, IDS_HELP_FAILED_CAPTION, szErrorCpn, MAX_HEADER+1);

                MessageBox(NULL, szErrorMsg, szErrorCpn, MB_OK|MB_ICONEXCLAMATION);
                return FALSE;
        }

        // MsiUseFeature(g_szMyProductCode, g_szHelpFeatureName);

        // Launch WinHelp to handle help
        return WinHelp(g_spyGlobalData.hwndParent, g_szHelpFilePath, HELP_FINDER, 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\msispy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       msispy.h
//
//--------------------------------------------------------------------------

// msispy.h

const int	NUM_WINDOWS			=  3;

#define	SPLITTER_BAR_WIDTH_DEFAULT	  2
#define	FEATUREDIALOG_DIVIDER		155
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\msispyu.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       msispyu.h
//
//--------------------------------------------------------------------------

#ifndef MSISPYU_H
#define MSISPYU_H


#include "windows.h"
#include <tchar.h>
#include "msiquery.h"
#include "assert.h"
#include "spydspid.h"
//#define EXPORT	extern "C" __declspec (dllexport)
#define EXPORT

#define MAX_COMPONENT_CHARS	100
#define MAX_PRODUCT_CHARS	100
#define MAX_ATTRIB_CHARS	30
#define MAX_STATUS_CHARS	100
#define MAX_FEATURE_TITLE_CHARS	100
#define	MAX_GUID			39

#define ERROR_UNKNOWN				ERROR_UNKNOWN_PROPERTY
#define	MSI
#define W32
#define OLE
#define	ERROR_						ERROR_UNKNOWN_PROPERTY

#define	INSTALLPROPERTY_STATE		TEXT("State")
#define	INSTALLPROPERTY_PRODUCTCODE	TEXT("ProductCode")
#define	INSTALLPROPERTY_USERNAME	TEXT("UserName")
#define	INSTALLPROPERTY_USERORGNAME	TEXT("UserOrgName")
#define	INSTALLPROPERTY_PRODUCTID	TEXT("ProductId")

#define FEATUREPROPERTY_NAME		TEXT("Feature")
#define	FEATUREPROPERTY_PARENT		TEXT("Feature_Parent")
#define FEATUREPROPERTY_TITLE		TEXT("Title")
#define FEATUREPROPERTY_DESC		TEXT("Description")
#define	FEATUREPROPERTY_DISPLAY		TEXT("Display")
#define FEATUREPROPERTY_LEVEL		TEXT("Level")
#define FEATUREPROPERTY_DIRCONF		TEXT("Directory_")
#define FEATUREPROPERTY_RUNFRMSRC	TEXT("Attributes")
#define	FEATUREPROPERTY_STATE		TEXT("State")
#define	FEATUREPROPERTY_DATE		TEXT("LastUsed")
#define	FEATUREPROPERTY_COUNT		TEXT("UsageCount")

#define COMPONENTPROPERTY_NAME		TEXT("Name")
#define COMPONENTPROPERTY_PATH		TEXT("Path")
#define COMPONENTPROPERTY_STATE		TEXT("State")
#define COMPONENTPROPERTY_GUID		TEXT("GUID")

#define FILEPROPERTY_TITLE			TEXT("FileTitle")
#define FILEPROPERTY_COMPONENT		TEXT("Component_")
#define	FILEPROPERTY_NAME			TEXT("FileName")
#define	FILEPROPERTY_SIZE			TEXT("FileSize")
#define	FILEPROPERTY_VERSION		TEXT("Version")
#define	FILEPROPERTY_LANGUAGE		TEXT("Language")
#define	FILEPROPERTY_ATTRIBUTES		TEXT("Attributes")
#define	FILEPROPERTY_SEQUENCE		TEXT("Sequence")
#define	FILEPROPERTY_ACTUALSIZE		TEXT("FileActualSize")
#define	FILEPROPERTY_CREATIONTIME	TEXT("FileCreated")
#define	FILEPROPERTY_LASTWRITETIME	TEXT("FileModified")
#define	FILEPROPERTY_LASTACCESSTIME	TEXT("FileAccessed")
#define	FILEPROPERTY_STATUS			TEXT("FileStatus")

#define	FILESTATUS_OKAY				TEXT("Okay")
#define	FILESTATUS_FILENOTFOUND		TEXT("File Not Found")
#define	FILESTATUS_DIFFSIZE			TEXT("File Size Different")

const int cchProductCode = 38;
const int cchGUID = 38;

typedef UINT			(WINAPI *T_MsivEnumProducts)(const DWORD dwProductIndex, LPTSTR lpProductBuf);
typedef UINT			(WINAPI *T_MsivEnumFeatures)(LPCTSTR szProduct, const DWORD iFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf);
typedef UINT			(WINAPI *T_MsivEnumComponents)(const DWORD iComponentIndex, LPTSTR lpComponentBuf);
typedef UINT			(WINAPI *T_MsivEnumComponentsFromProduct)(LPCTSTR szProductCode, const DWORD iComponentIndex, LPTSTR lpComponentBuf);
typedef UINT			(WINAPI *T_MsivEnumComponentsFromFeature)(LPCTSTR szProduct, LPCTSTR szFeature, const DWORD iComponentIndex, LPTSTR lpComponentBuf, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf);
typedef UINT			(WINAPI *T_MsivGetComponentName)(LPCTSTR szComponentId, LPTSTR lpComponentName, LPDWORD cchComponentName);
typedef UINT			(WINAPI *T_MsivGetProductInfo)(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef UINT			(WINAPI *T_MsivGetFeatureInfo)(LPCTSTR szProduct, LPCTSTR szFeature, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef UINT			(WINAPI *T_MsivOpenDatabase)(LPCTSTR szDatabase);
typedef UINT			(WINAPI *T_MsivCloseDatabase)();
typedef UINT			(WINAPI *T_MsivGetDatabaseName)(LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef UINT			(WINAPI *T_MsivSaveProfile)(LPCTSTR szFileName);
typedef UINT			(WINAPI *T_MsivLoadProfile)(LPTSTR szFileName);
typedef UINT			(WINAPI *T_MsivCloseProfile)();
typedef UINT			(WINAPI *T_MsivGetProfileName)(LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef UINT			(WINAPI *T_MsivGetFeatureUsage)(LPCTSTR szProduct, LPCTSTR szFeature, LPDWORD pdwUseCount, LPWORD pwDateUsed);
typedef UINT			(WINAPI *T_MsivEnumClients)(LPCTSTR szComponent, DWORD iProductIndex, LPTSTR lpProductBuf);
typedef UINT			(WINAPI *T_MsivGetProfileInfo)(UINT iIndex, LPTSTR szValue, LPDWORD pcchCount);
typedef UINT			(WINAPI *T_MsivEnumFilesFromComponent)(LPCTSTR szComponentid, DWORD iFileIndex, LPTSTR lpValueBuf, LPDWORD pcchCount);
typedef UINT			(WINAPI *T_MsivGetFileInfo)(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef INSTALLSTATE	(WINAPI *T_MsivQueryProductState)(LPCTSTR szProduct);
typedef INSTALLSTATE	(WINAPI *T_MsivQueryFeatureState)(LPCTSTR szProduct, LPCTSTR szFeature);
typedef INSTALLSTATE	(WINAPI *T_MsivLocateComponent)(LPCTSTR szComponentId,LPTSTR lpPathBuf, LPDWORD pcchBuf);
typedef INSTALLSTATE	(WINAPI *T_MsivGetComponentPath)(LPCTSTR szProductCode,LPCTSTR szComponentId,LPTSTR lpPathBuf, LPDWORD pcchBuf);
typedef USERINFOSTATE	(WINAPI *T_MsivGetUserInfo)(LPCTSTR szProduct, LPTSTR lpUserNameBuf, LPDWORD pcchUserNameBuf, LPTSTR lpOrgNameBuf, LPDWORD pcchOrgNameBuf, LPTSTR lpSerialBuf, LPDWORD pcchSerialBuf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\sources.inc ===
TARGETNAME=MsiSpy
!INCLUDE ..\..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=$(MSI_WINENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\comctl32.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1

INCLUDES=$(MSI_SPYRES_DIR);$(MSI_SPYINC_DIR);$(INC_DIR);$(HELP_DIR);$(RES_OBJDIR);$(ADMIN_INC_PATH)

SOURCES=..\msispy.cpp \
	..\hashinc.cpp \
	..\propshts.cpp \
	..\ui.cpp \
	..\initmsi.cpp \
	..\msispy.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\msispy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msispy.cpp
//
//--------------------------------------------------------------------------


// #includes
#include "msispyu.h"
#include "propshts.h"
#include "ui.h"
#include "msispy.h"
#include "assert.h"
#include "initmsi.h"
#include "objbase.h"

// externs
extern	DATASOURCETYPE	g_iDataSource;						// propshts.cpp
extern	TCHAR			g_szNullString[MAX_NULLSTRING+1];	// propshts.cpp
extern  TCHAR			g_szHelpFilePath[MAX_PATH+1];		// initmsi.cpp


// other globals
MODE			g_modeCurrent;						// <propshts.h> restricted/normal/diagnostic 
MSISPYSTRUCT	g_spyGlobalData;					// <propshts.h> window handles, hInstance etc

// the splitter bar between the list-view and tree-view windows
RECT			g_rectSplitterBar;					
HDC				g_hdcSplitterBar		= NULL;
INT				g_xSplitterBarWidth		= SPLITTER_BAR_WIDTH_DEFAULT;


extern INT_PTR CALLBACK About(HWND hDlg, UINT message, UINT_PTR wParam,	LONG_PTR lParam);


//----------------------------------------------------------------------
// SwapTreeViewWindows()
//	Swaps the old and current tree-view handles. Used after refresh operations
//	when the hidden tree-view window is (updated and) brought to the foreground
//	and the visible window is hidden

void SwapTreeViewWindows() {

	HWND hwndTempHandle				= g_spyGlobalData.hwndTreeView;
	g_spyGlobalData.hwndTreeView	= g_spyGlobalData.hwndTreeViewOld;
	g_spyGlobalData.hwndTreeViewOld	= hwndTempHandle;

}

 

//----------------------------------------------------------------------
// CreateUI
//	Calls functions to create the msispy windows- 
//		two identical treeview windows, one on top of the other (swapped 
//		during refresh) to display products and features,
//		one list view window to display components, and
//		a status bar with two parts
//	Also initialises the global variables
//	Returns TRUE if successful, FALSE otherwise

BOOL CreateUI() {

	InitCommonControls();


	g_spyGlobalData.hPreviousUILevel = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);



	g_xSplitterBarWidth = GetSystemMetrics(SM_CXEDGE);
	if (!g_xSplitterBarWidth)
		g_xSplitterBarWidth = SPLITTER_BAR_WIDTH_DEFAULT;

	RECT  rectClientWindow;
	GetClientRect(g_spyGlobalData.hwndParent, &rectClientWindow);

	UINT iTreeViewWidth			= (rectClientWindow.right - rectClientWindow.left) /3;
	g_rectSplitterBar.top		= rectClientWindow.top;
	g_rectSplitterBar.bottom	= rectClientWindow.bottom - rectClientWindow.top - STATUS_BAR_HEIGHT;
	g_rectSplitterBar.left		= iTreeViewWidth;
	g_rectSplitterBar.right		= iTreeViewWidth + g_xSplitterBarWidth;

	// initalise global variables
	g_spyGlobalData.iSelectedComponent	= -1;
	g_spyGlobalData.itTreeViewSelected	= ITEMTYPE_NONE;
	g_spyGlobalData.fRefreshInProgress	= FALSE;
	g_iDataSource						= DS_NONE;
	g_modeCurrent						= MODE_NORMAL;	

	// first, create the status window.
	g_spyGlobalData.hwndStatusBar = CreateStatusWindow( 
		WS_CHILD | WS_BORDER | WS_VISIBLE,	// window styles
		g_szNullString,						// default window text
		g_spyGlobalData.hwndParent,			// parent window
		IDW_STATUS);							// ID

	if (!g_spyGlobalData.hwndStatusBar)
		return FALSE;


	// set the status bar to have two parts.
	INT rgiStatusBarParts[2];
	rgiStatusBarParts[0] = (rectClientWindow.right - rectClientWindow.left) /3;
	rgiStatusBarParts[1] = -1;
	SendMessage(g_spyGlobalData.hwndStatusBar, SB_SETPARTS, (WPARAM)2, (LPARAM)&rgiStatusBarParts);

	// set the text for the status bar
	ChangeSBText(g_spyGlobalData.hwndStatusBar, -1);

	// create the list-view window
	if (!(g_spyGlobalData.hwndListView = CreateListView(g_spyGlobalData.hwndParent, 
							g_spyGlobalData.hInstance, 
							(rectClientWindow.right - g_rectSplitterBar.left -2))))
		return FALSE;

	// create the tree-view windows
	if (!(g_spyGlobalData.hwndTreeView = CreateTreeView(g_spyGlobalData.hwndParent, 
							g_spyGlobalData.hInstance,
							&g_spyGlobalData.hwndTreeViewOld, 
							iTreeViewWidth, 
							rectClientWindow.bottom - rectClientWindow.top - STATUS_BAR_HEIGHT))) 
		return FALSE;

	// all's well
	return TRUE;
}


//----------------------------------------------------------------------
// ResizeWindows
//	Resizes the windows, called on a WM_SIZE message
//	Returns TRUE if successful, FALSE otherwise

BOOL ResizeWindows() {

	RECT rectClientWindow;

	// get the client area of the parent window.
	GetClientRect(g_spyGlobalData.hwndParent, &rectClientWindow);

	// reposition the status bar
	MoveWindow(g_spyGlobalData.hwndStatusBar,
				  0,
				  rectClientWindow.bottom - STATUS_BAR_HEIGHT,
				  rectClientWindow.right - rectClientWindow.left,
				  STATUS_BAR_HEIGHT,
				  TRUE);

	// set the status bar to have two parts.
	INT rgiStatusBarParts[2];
	rgiStatusBarParts[0] = g_rectSplitterBar.left - g_xSplitterBarWidth;
	rgiStatusBarParts[1] = -1;

	SendMessage(g_spyGlobalData.hwndStatusBar, SB_SETPARTS, (WPARAM)2, (LPARAM)&rgiStatusBarParts);


	// reposition the tree-views
	MoveWindow(g_spyGlobalData.hwndTreeView,
				  0,
				  0,
				  g_rectSplitterBar.left - g_xSplitterBarWidth,
				  rectClientWindow.bottom - rectClientWindow.top - STATUS_BAR_HEIGHT,
				  TRUE);

	MoveWindow(g_spyGlobalData.hwndTreeViewOld,
				  0,
				  0,
				  g_rectSplitterBar.left - g_xSplitterBarWidth,
				  rectClientWindow.bottom - rectClientWindow.top - STATUS_BAR_HEIGHT,
				  TRUE);

	// reposition the list-view
	MoveWindow(g_spyGlobalData.hwndListView,
				  g_rectSplitterBar.left,
				  0,
				  rectClientWindow.right - g_rectSplitterBar.left,
				  rectClientWindow.bottom - rectClientWindow.top - STATUS_BAR_HEIGHT,
				  TRUE);

	return TRUE;
}


//----------------------------------------------------------------------
// MsgLButtonDown
//	Handles left-mouse clicks on the splitter (the only exposed part of
//	the main window)- marks the initial position and draws the bar

LRESULT MsgLButtonDown(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) { 

	#define xPos ((int)(short)LOWORD(lparam))

	SetCapture(hwnd);
	GetClientRect(hwnd, &g_rectSplitterBar);

	// Calculate initial position
	g_rectSplitterBar.left = min(max(50, xPos - g_xSplitterBarWidth/2), g_rectSplitterBar.right - 50) + 1;

	// Get a DC (also used as a flag indicating we have capture)
	if (g_hdcSplitterBar)
		ReleaseDC(hwnd, g_hdcSplitterBar);

	g_hdcSplitterBar = GetDC(hwnd);

    // Draw splitter bar in initial position
	PatBlt(g_hdcSplitterBar, 
		g_rectSplitterBar.left, 
		0, 
		g_xSplitterBarWidth, 
		g_rectSplitterBar.bottom - g_rectSplitterBar.top - STATUS_BAR_HEIGHT, 
		DSTINVERT);

	return 0;

	UNREFERENCED_PARAMETER(wparam);
	UNREFERENCED_PARAMETER(uMessage);

}

//----------------------------------------------------------------------
// MsgMouseMove
//	Handles mouse-move messages when the left-mouse button is down on the 
//	splitter bar. Redraws the splitter bar as the mouse moves

LRESULT MsgMouseMove(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) {

	#define xPos ((int)(short)LOWORD(lparam))

	if (g_hdcSplitterBar) {

		// Erase previous bar
		PatBlt(g_hdcSplitterBar, 
			g_rectSplitterBar.left, 
			0, 
			g_xSplitterBarWidth,
			g_rectSplitterBar.bottom - g_rectSplitterBar.top - STATUS_BAR_HEIGHT,
			DSTINVERT);

		// Calculate new position
		g_rectSplitterBar.left = min(max(50, xPos - g_xSplitterBarWidth/2), g_rectSplitterBar.right - 50) + 1;

		// Draw bar in new position
		PatBlt(g_hdcSplitterBar,
			g_rectSplitterBar.left,
			0,
			g_xSplitterBarWidth,
			g_rectSplitterBar.bottom - g_rectSplitterBar.top - STATUS_BAR_HEIGHT,
			DSTINVERT);

	}

	return 0;

	UNREFERENCED_PARAMETER(wparam);
	UNREFERENCED_PARAMETER(uMessage);
	UNREFERENCED_PARAMETER(hwnd);
}


//----------------------------------------------------------------------
// MsgLButtonUp
//	Handles left-mouse button up messages on the splitter (the only exposed part of
//	the main window)- marks the final position and draws the bar

LRESULT MsgLButtonUp(HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam) {

	#define xPos ((int)(short)LOWORD(lparam))

	if (g_hdcSplitterBar) {

		// Erase previous bar
		PatBlt(g_hdcSplitterBar, 
			g_rectSplitterBar.left,
			0, 
			g_xSplitterBarWidth,
			g_rectSplitterBar.bottom - g_rectSplitterBar.top - STATUS_BAR_HEIGHT,
			DSTINVERT);

		// Calculate new position
		g_rectSplitterBar.left = min(max(50, xPos - g_xSplitterBarWidth/2), g_rectSplitterBar.right - 50) + 1;

		// Clean up
		ReleaseCapture();
		ReleaseDC(hwnd, g_hdcSplitterBar);
		g_hdcSplitterBar = NULL;
		
		g_rectSplitterBar.left -= g_xSplitterBarWidth/2;

		//	redraw windows at new position

		// status bar first
		if (g_spyGlobalData.hwndStatusBar) {
			int rgiStatusBarParts[2] = { g_rectSplitterBar.left, -1 };
			SendMessage(g_spyGlobalData.hwndStatusBar, SB_SETPARTS, (WPARAM)2, (LPARAM)&rgiStatusBarParts);
		}

		// now shown tree-view
		if (g_spyGlobalData.hwndTreeView)
			SetWindowPos(g_spyGlobalData.hwndTreeView,
						NULL,
						0, 0,
						g_rectSplitterBar.left,
						g_rectSplitterBar.bottom - g_rectSplitterBar.top - STATUS_BAR_HEIGHT,
						SWP_NOZORDER);

		// now hidden tree view
		if (g_spyGlobalData.hwndTreeViewOld)
			SetWindowPos(g_spyGlobalData.hwndTreeViewOld,
						NULL,
						0, 0,
						g_rectSplitterBar.left,
						g_rectSplitterBar.bottom - g_rectSplitterBar.top - STATUS_BAR_HEIGHT,
						SWP_NOZORDER);

		g_rectSplitterBar.left += g_xSplitterBarWidth;

		// now list view
		if (g_spyGlobalData.hwndListView)
			SetWindowPos(g_spyGlobalData.hwndListView,
						NULL,
						g_rectSplitterBar.left, 0,
						g_rectSplitterBar.right - g_rectSplitterBar.left,
						g_rectSplitterBar.bottom - g_rectSplitterBar.top - STATUS_BAR_HEIGHT,
						SWP_NOZORDER);
	}

	return 0;

	UNREFERENCED_PARAMETER(wparam);
	UNREFERENCED_PARAMETER(uMessage);
}


//----------------------------------------------------------------------
// HandlePaint
//	Handles the paint messages for the main window
//	Since the main window is not exposed (except the splitter bar)
//	we do not have to do anything.

VOID APIENTRY HandlePaint (HWND hwnd) {
//	HDC         hdc;
	PAINTSTRUCT ps;

//	hdc = 
	BeginPaint (hwnd, (LPPAINTSTRUCT)&ps);
	EndPaint(hwnd, (LPPAINTSTRUCT)&ps);
}



//----------------------------------------------------------------------
// ListViewPopupMenu
//	Brings up and handles the List-View pop-up menu
//	If the component is broken, the menu option to re-install component is enabled
//	else, it is disabled.

VOID APIENTRY ListViewPopupMenu (HWND hwndParent, LPARAM lParam) {

	if (g_spyGlobalData.iSelectedComponent > -1) {				// something's selected

		HMENU hMenu = LoadMenu(g_spyGlobalData.hResourceInstance, MAKEINTRESOURCE(IDR_LVPOPMENU));
		if (!hMenu)
			return;

		// "properties" option
		HMENU hMenuTrackPopup = GetSubMenu(hMenu, 0);

		// re-install option should only appear if reg/installed DB is in use
		if (g_iDataSource == DS_REGISTRY || g_iDataSource == DS_INSTALLEDDB) {

			MENUITEMINFO	hMenuItem;
			hMenuItem.cbSize =  sizeof (hMenuItem);
			hMenuItem.fMask  =  MIIM_TYPE;
			hMenuItem.fType  =  MFT_SEPARATOR;
			InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

			// see if component is broken- enable or disable re-install option accordingly
			// get the component info out of the list control
			ComponentInfoStruct *pCompInfo;
			LVITEM lviGet;
			lviGet.iItem	= g_spyGlobalData.iSelectedComponent;
			lviGet.iSubItem = 0;
			lviGet.mask		= LVIF_PARAM;
			ListView_GetItem(g_spyGlobalData.hwndListView, &lviGet);

			pCompInfo = (ComponentInfoStruct*)lviGet.lParam;

			TCHAR	szComponentName[MAX_COMPONENT_CHARS+1];
			DWORD	cchComponentName = MAX_COMPONENT_CHARS+1;

			// get component name and state
			MSISPYU::MsivGetComponentName(pCompInfo->szComponentId, szComponentName, &cchComponentName);
			UINT iState = MSISPYU::MsivGetComponentPath(pCompInfo->szProductCode, pCompInfo->szComponentId, NULL, NULL);
			hMenuItem.fState = (iState == INSTALLSTATE_SOURCE) ? MFS_GRAYED:MFS_ENABLED;

			TCHAR	szReinstallText[MAX_HEADER+1];
			LoadString(g_spyGlobalData.hResourceInstance, IDS_C_REINSTALL, szReinstallText, MAX_HEADER+1);

			TCHAR	szMenuOut[MAX_COMPONENT_CHARS+MAX_HEADER+5];
			wsprintf(szMenuOut, szReinstallText, szComponentName);

			hMenuItem.cbSize	 =  sizeof (hMenuItem);
			hMenuItem.fMask		 =  MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
			hMenuItem.fType		 =  MFT_STRING;
			hMenuItem.wID		 =  IDM_C_REINSTALL;
			hMenuItem.dwItemData =  IDM_C_REINSTALL;
			hMenuItem.dwTypeData =  szMenuOut;
			hMenuItem.cch		 =  MAX_COMPONENT_CHARS + MAX_HEADER + 5; 

			InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);
		}

		// track the menu
		TrackPopupMenu(hMenuTrackPopup, 
			TPM_LEFTALIGN | TPM_RIGHTBUTTON,
			LOWORD(lParam), HIWORD(lParam),
			0, hwndParent, NULL);

		DestroyMenu(hMenu);

	}

}



//----------------------------------------------------------------------
// TreeViewPopupMenu
//	Brings up and handles the tree-view pop-up menu
//	The menu choices depend on what is in use- it varies for different DataSources
//	(registry/installedDB/uninstalledDB/profile), and on what has been selected
//	(root/product/feature)

VOID APIENTRY TreeViewPopupMenu (HWND hwndParent, LPARAM lParam) {

	// get the product name
	TCHAR	szProductName[MAX_PRODUCT_CHARS+1];
	DWORD	cchCount = MAX_PRODUCT_CHARS+1;
	MSISPYU::MsivGetProductInfo(g_spyGlobalData.szProductCode, INSTALLPROPERTY_PRODUCTNAME, szProductName, &cchCount);

	// create the menus
	HMENU hMenu, hMenuTrackPopup;
	hMenu = LoadMenu (g_spyGlobalData.hResourceInstance, MAKEINTRESOURCE(IDR_TVPOPMENU));
	if (!hMenu)
		return;
	hMenuTrackPopup = GetSubMenu(hMenu, 0);

	TCHAR			szMenuOut[MAX_FEATURE_CHARS+MAX_HEADER+5];
	MENUITEMINFO	hMenuItem;


	if (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_FEATURE || g_spyGlobalData.itTreeViewSelected == ITEMTYPE_PRODUCT) {
		// product or feature is selected

		if (g_spyGlobalData.szFeatureCode) {
			// selection is a feature

			hMenuItem.cbSize = sizeof (hMenuItem);
			hMenuItem.fMask  = MIIM_TYPE;
			hMenuItem.fType  = MFT_SEPARATOR;
			InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

			switch (g_iDataSource) {
			case DS_UNINSTALLEDDB:		// un-installed DB: choices: "install"

				TCHAR	szInstallText[MAX_HEADER+1];
				LoadString(g_spyGlobalData.hResourceInstance, IDS_PF_INSTALL, szInstallText, MAX_HEADER+1);

/*				TCHAR	szAdvertiseText[MAX_HEADER+1];
				LoadString(g_spyGlobalData.hResourceInstance, IDS_PF_ADVERTISE, szAdvertiseText, MAX_HEADER+1);

				// advertise
				wsprintf(szMenuOut, szAdvertiseText, szProductName);
				hMenuItem.cbSize	 = sizeof (hMenuItem);
				hMenuItem.fMask		 = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
				hMenuItem.fType		 = MFT_STRING;
				hMenuItem.fState	 = MFS_ENABLED;
				hMenuItem.wID		 = IDM_P_ADVERTISE;
				hMenuItem.dwItemData = IDM_P_ADVERTISE;
				hMenuItem.dwTypeData = szMenuOut;
				hMenuItem.cch		 = MAX_FEATURE_CHARS+MAX_HEADER+5;
				InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);
*/
				// install
				wsprintf(szMenuOut, szInstallText, szProductName);
				hMenuItem.cbSize	 = sizeof (hMenuItem);
				hMenuItem.fMask		 = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
				hMenuItem.fType		 = MFT_STRING;
				hMenuItem.fState	 = MFS_ENABLED;
				hMenuItem.wID		 = IDM_PF_CONFIGURE;
				hMenuItem.dwItemData = IDM_PF_CONFIGURE;
				hMenuItem.dwTypeData = szMenuOut;
				hMenuItem.cch		 = MAX_FEATURE_CHARS+MAX_HEADER+5;
				InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

				break;

			case DS_REGISTRY:		// fall-thru: behaviour is the same for installed DB and registry
			case DS_INSTALLEDDB:	// choices: "re-install, re-configure, un-install"			  

				BOOL	fAdvertised;
				BOOL	fAbsent;

				fAdvertised =  (
					((g_spyGlobalData.itTreeViewSelected == ITEMTYPE_FEATURE)
					    && (MSISPYU::MsivQueryFeatureState(g_spyGlobalData.szProductCode, g_spyGlobalData.szFeatureCode) == INSTALLSTATE_ADVERTISED))
				 || (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_PRODUCT	
					    && (MSISPYU::MsivQueryProductState(g_spyGlobalData.szProductCode) == INSTALLSTATE_ADVERTISED)));

				fAbsent =  (
					((g_spyGlobalData.itTreeViewSelected == ITEMTYPE_FEATURE) 
						&& (MSISPYU::MsivQueryFeatureState(g_spyGlobalData.szProductCode, g_spyGlobalData.szFeatureCode) == INSTALLSTATE_ABSENT))
				 ||	((g_spyGlobalData.itTreeViewSelected == ITEMTYPE_PRODUCT) 
						&& (MSISPYU::MsivQueryProductState(g_spyGlobalData.szProductCode) == INSTALLSTATE_ABSENT)));


				TCHAR	szReinstallText[MAX_HEADER+1];
				LoadString(g_spyGlobalData.hResourceInstance, IDS_PF_REINSTALL, szReinstallText, MAX_HEADER+1);

				TCHAR	szConfigureText[MAX_HEADER+1];
				LoadString(g_spyGlobalData.hResourceInstance, (fAdvertised||fAbsent)?IDS_PF_INSTALL:IDS_PF_CONFIGURE, szConfigureText, MAX_HEADER+1);

				TCHAR	szUninstallText[MAX_HEADER+1];
				LoadString(g_spyGlobalData.hResourceInstance, IDS_PF_UNINSTALL, szUninstallText, MAX_HEADER+1);

				// un-install
				wsprintf(szMenuOut, szUninstallText, g_spyGlobalData.szFeatureTitle);
				hMenuItem.cbSize	 = sizeof (hMenuItem);
				hMenuItem.fMask		 = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
				hMenuItem.fType		 = MFT_STRING;
				hMenuItem.fState	 = ((g_spyGlobalData.itTreeViewSelected == ITEMTYPE_FEATURE) && fAbsent)?MFS_GRAYED:MFS_ENABLED;
				hMenuItem.wID		 = IDM_PF_UNINSTALL;
				hMenuItem.dwItemData = IDM_PF_UNINSTALL;
				hMenuItem.dwTypeData = szMenuOut;
				hMenuItem.cch		 = MAX_FEATURE_CHARS+MAX_HEADER+5;
				InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

				// re-install
				wsprintf(szMenuOut, szReinstallText, g_spyGlobalData.szFeatureTitle);
				hMenuItem.cbSize	 = sizeof (hMenuItem);
				hMenuItem.fMask		 = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
				hMenuItem.fType		 = MFT_STRING;
				hMenuItem.fState	 = (fAdvertised||fAbsent)? MFS_GRAYED:MFS_ENABLED;
				hMenuItem.wID		 = IDM_PF_REINSTALL;
				hMenuItem.dwItemData = IDM_PF_REINSTALL;
				hMenuItem.dwTypeData = szMenuOut;
				hMenuItem.cch		 = MAX_FEATURE_CHARS+MAX_HEADER+5;
				InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

				// configure
				wsprintf(szMenuOut, szConfigureText, g_spyGlobalData.szFeatureTitle);
				hMenuItem.cbSize	 = sizeof (hMenuItem);
				hMenuItem.fMask		 = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
				hMenuItem.fType		 = MFT_STRING;
				hMenuItem.fState	 = MFS_ENABLED;
				hMenuItem.wID		 = IDM_PF_CONFIGURE;
				hMenuItem.dwItemData = IDM_PF_CONFIGURE;
				hMenuItem.dwTypeData = szMenuOut;
				hMenuItem.cch		 = MAX_FEATURE_CHARS+MAX_HEADER+5;
				InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

				break;

			case DS_PROFILE:				// profile, choices: "restore profile"

				LoadString(g_spyGlobalData.hResourceInstance, IDS_RESTORE_SS, szMenuOut, MAX_HEADER+1);

				// restore
				hMenuItem.cbSize	 = sizeof (hMenuItem);
				hMenuItem.fMask		 = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
				hMenuItem.fType		 = MFT_STRING;
				hMenuItem.fState	 = MFS_ENABLED;
				hMenuItem.wID		 = IDS_RESTORE_SS;
				hMenuItem.dwItemData = IDS_RESTORE_SS;
				hMenuItem.dwTypeData = szMenuOut;
				hMenuItem.cch		 = MAX_FEATURE_CHARS+MAX_HEADER+5;
				InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

				break;

			default:
				DestroyMenu(hMenu);
				return;
				break;
				
			}
		}
	}
	else if (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_ROOT) {
		// root is selected

		switch (g_iDataSource) {
		case DS_PROFILE:		// profile- choice: "restore profile"

			hMenuItem.cbSize = sizeof (hMenuItem);
			hMenuItem.fMask  =  MIIM_TYPE;
			hMenuItem.fType  = MFT_SEPARATOR;
			InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

			// restore
			LoadString(g_spyGlobalData.hResourceInstance, IDS_RESTORE_SS, szMenuOut, MAX_HEADER+1);
			hMenuItem.cbSize	 = sizeof (hMenuItem);
			hMenuItem.fMask		 = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
			hMenuItem.fType		 = MFT_STRING;
			hMenuItem.fState	 = MFS_ENABLED;
			hMenuItem.wID		 = IDM_FL_RESTORE_STATE;
			hMenuItem.dwItemData = IDM_FL_RESTORE_STATE;
			hMenuItem.dwTypeData = szMenuOut;
			hMenuItem.cch		 = MAX_FEATURE_CHARS+MAX_HEADER+5;
			InsertMenuItem(hMenuTrackPopup, 0, TRUE, &hMenuItem);

			break;

		case DS_UNINSTALLEDDB:	// no choices for these
		case DS_INSTALLEDDB:
			break;

		default:
			DestroyMenu(hMenu);
			return;

			break;
		}
	}
			
	TrackPopupMenu(hMenuTrackPopup, 
		TPM_LEFTALIGN | TPM_RIGHTBUTTON,
		LOWORD(lParam), HIWORD(lParam),
		0, hwndParent, NULL);


	DestroyMenu(hMenu);


}

//----------------------------------------------------------------------
// HandleFeatureReinstall
//	Brings up and handles the product/feature re-installation dialogue box
//	Returns 0 (user hit cancel) or a value between 1 and 10 (different re-
//	installation modes)


INT_PTR CALLBACK HandleFeatureReinstall(
        HWND hDlg,
        UINT message,
        UINT wParam,
        LONG lParam
		) {

	static RECT rectDialogBox;

	static BOOL fShowAdvanced	 = FALSE;
	static BOOL fOldShowAdvanced = FALSE;
	static INT	iReturnValue	 = 1;				//--todo '1'??
	static INT	iOldReturnValue	 = 1;

    switch (message){

	case WM_INITDIALOG: 

		GetWindowRect(hDlg, &rectDialogBox);

		TCHAR	szAdvanced[MAX_HEADER+1];
		CheckRadioButton(hDlg, IDC_PF_RI_FILEVERIFY, IDC_PF_RI_FILEVERIFY+10, IDC_PF_RI_FILEVERIFY+iReturnValue-1);

		if (fShowAdvanced) {
			LoadString(g_spyGlobalData.hResourceInstance, IDS_PF_RI_ADVANCED, szAdvanced, MAX_HEADER+1); 
			
			SetWindowPos(hDlg, 
				HWND_TOPMOST, 
				rectDialogBox.left, rectDialogBox.top, 
				(rectDialogBox.right -rectDialogBox.left),
				(rectDialogBox.bottom-rectDialogBox.top),
				SWP_NOMOVE);

			SetDlgItemText(hDlg, IDC_PF_RI_ADVANCED, szAdvanced);
		}
		else {
			LoadString(g_spyGlobalData.hResourceInstance, IDS_PF_RI_NOADVANCED, szAdvanced, MAX_HEADER+1); 

			SetWindowPos(hDlg, 
				HWND_TOPMOST,
				rectDialogBox.left, rectDialogBox.top,
				(rectDialogBox.right - rectDialogBox.left),
				FEATUREDIALOG_DIVIDER,
				SWP_NOMOVE);

			SetDlgItemText(hDlg, IDC_PF_RI_ADVANCED, szAdvanced);
		}

		if (iReturnValue < 4) 
			EnableWindow(GetDlgItem(hDlg, IDC_PF_RI_ADVANCED), TRUE);
		else
			EnableWindow(GetDlgItem(hDlg, IDC_PF_RI_ADVANCED), FALSE);

		return(TRUE);
	
	
	case WM_COMMAND:

		// LOWORD added for portability
		switch (LOWORD(wParam)) {

		case IDOK:
			iOldReturnValue	 = iReturnValue;
			fOldShowAdvanced = fShowAdvanced;
			EndDialog(hDlg,iReturnValue);

			return TRUE;
			break;

		case IDCANCEL:
			iReturnValue	 = iOldReturnValue;
			fShowAdvanced	 = fOldShowAdvanced;
			EndDialog(hDlg,0);

			return TRUE;
			break;

//!!optimise
			// set return value to user's selection
		case IDC_PF_RI_FILEVERIFY:		iReturnValue = 1;	break;
		case IDC_PF_RI_FILEMISSING:		iReturnValue = 2;	break;
		case IDC_PF_RI_FILEREPLACE:		iReturnValue = 3;	break;
		case IDC_PF_RI_FILEOLDER:		iReturnValue = 4;	break;
		case IDC_PF_RI_FILEEQUAL:		iReturnValue = 5;	break;
		case IDC_PF_RI_FILEEXACT:		iReturnValue = 6;	break;
		case IDC_PF_RI_USERDATA:		iReturnValue = 7;	break;
		case IDC_PF_RI_MACHINEDATA:		iReturnValue = 8;	break;
		case IDC_PF_RI_SHORTCUT:		iReturnValue = 9;	break;
		case IDC_PF_RI_ADVERTISE:		iReturnValue = 10;	break;

		case IDC_PF_RI_ADVANCED:

			if (fShowAdvanced) {
				
				SetWindowPos(hDlg,
					HWND_TOPMOST, 
					rectDialogBox.left,	rectDialogBox.top,
					(rectDialogBox.right - rectDialogBox.left),
					FEATUREDIALOG_DIVIDER,
					SWP_NOMOVE);

				fShowAdvanced = FALSE;
				LoadString(g_spyGlobalData.hResourceInstance, IDS_PF_RI_NOADVANCED, szAdvanced, MAX_HEADER+1); 

				SetDlgItemText(hDlg, IDC_PF_RI_ADVANCED, szAdvanced);
			}
			else {
				
				SetWindowPos(hDlg,
					HWND_TOPMOST,
					rectDialogBox.left, rectDialogBox.top,
					(rectDialogBox.right - rectDialogBox.left),
					(rectDialogBox.bottom-rectDialogBox.top),
					SWP_NOMOVE);

				fShowAdvanced = TRUE;
				LoadString(g_spyGlobalData.hResourceInstance, IDS_PF_RI_ADVANCED, szAdvanced, MAX_HEADER+1); 

				SetDlgItemText(hDlg, IDC_PF_RI_ADVANCED, szAdvanced);
			}
			break;
		}


		if (iReturnValue <4) 
			EnableWindow(GetDlgItem(hDlg, IDC_PF_RI_ADVANCED), TRUE);
		else
			EnableWindow(GetDlgItem(hDlg, IDC_PF_RI_ADVANCED), FALSE);

		break;
	}

	return FALSE;

	UNREFERENCED_PARAMETER(lParam);
}

//----------------------------------------------------------------------
// HandleFeatureReconfigure
//	Brings up and handles the feature re-configuration dialogue box
//	Returns 0 (user hit cancel) or a value between 1 and 5 (different re-
//	configure modes)

INT_PTR CALLBACK HandleFeatureReconfigure(
        HWND hDlg,
        UINT message,
        UINT wParam,
        LONG lParam) {

	static INT_PTR iReturnValue = 0;						//--todo '0'?

    switch (message){

	case WM_INITDIALOG:
		
		CheckRadioButton(hDlg, IDC_F_RC_DEFAULT, IDC_F_RC_DEFAULT, IDC_F_RC_DEFAULT);
		iReturnValue = 3;
		return(TRUE);
	
	case WM_COMMAND:
		
		switch (LOWORD(wParam)) {

		case IDOK:
			EndDialog(hDlg, iReturnValue);
			return TRUE;
			break;
			
		case IDCANCEL:
			EndDialog(hDlg, 0);
			return TRUE;
			break;
//!!optimise
		case IDC_F_RC_LOCAL:	 iReturnValue = 1;	break;
		case IDC_F_RC_SOURCE:	 iReturnValue = 2;	break;
		case IDC_F_RC_DEFAULT:	 iReturnValue = 3;	break;
		case IDC_F_RC_UNCACHE:	 iReturnValue = 4;	break;
 		case IDC_F_RC_ADVERTISE: iReturnValue = 5;	break;
		}

		break;
	}

	return FALSE;

	UNREFERENCED_PARAMETER(lParam);
}


//----------------------------------------------------------------------
// HandleProductReconfigure
//	Brings up and handles the product re-configuration dialogue box
//	Returns 0 (user hit cancel) or a two digit number
//	with the first digit (0-4) representing the reconfigure mode
//	and the second digit (1-3) representing the reconfigure level


INT_PTR CALLBACK HandleProductReconfigure(
        HWND hDlg,
        UINT message,
        UINT wParam,
        LONG lParam) {

	static INT_PTR iReturnValue = 0, iReturnValue2 = 0;				//--todo '0'?

    switch (message){

	case WM_INITDIALOG:

		CheckRadioButton(hDlg, IDC_P_RC_TYPICAL, IDC_P_RC_TYPICAL, IDC_P_RC_TYPICAL);
		iReturnValue = 2;
		CheckRadioButton(hDlg, IDC_P_RC_DEFAULT, IDC_P_RC_DEFAULT, IDC_P_RC_DEFAULT);
		iReturnValue2 = 0;

		return TRUE;
	
	case WM_COMMAND:
		// LOWORD added for portability
		switch (LOWORD(wParam)) {

		case IDOK:
			EndDialog(hDlg, ((iReturnValue2*10)+(iReturnValue)));
			return TRUE;
			break;

		case IDCANCEL:
			EndDialog(hDlg, 0);
			return TRUE;
			break;
//!!optimise
		case IDC_P_RC_MINIMUM:		iReturnValue  = 1;	break;
		case IDC_P_RC_TYPICAL:		iReturnValue  = 2;	break;
		case IDC_P_RC_COMPLETE:		iReturnValue  = 3;	break;
		case IDC_P_RC_DEFAULT:		iReturnValue2 = 0;	break;
		case IDC_P_RC_LOCAL:		iReturnValue2 = 1;	break;
		case IDC_P_RC_SOURCE:		iReturnValue2 = 2;	break;
		case IDC_P_RC_ADVERTISE:	iReturnValue2 = 3;	break;
		case IDC_P_RC_UNCACHE:		iReturnValue2 = 4;	break;
		}
		break;
    }

    return FALSE;

	UNREFERENCED_PARAMETER(lParam);
}


//--todo:cb
void InitialiseProfile(LPTSTR szProfile = NULL) {

	if ((!szProfile) || (MSISPYU::MsivLoadProfile(szProfile) == ERROR_SUCCESS)) {
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_RESTORE_STATE, MF_ENABLED);
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_CHECK_DIFFERENCES, MF_ENABLED);
		g_iDataSource=DS_PROFILE;

		ClearList(g_spyGlobalData.hwndListView);
		lstrcpy(g_spyGlobalData.szFeatureCode,  g_szNullString);
		lstrcpy(g_spyGlobalData.szFeatureTitle, g_szNullString);
		g_spyGlobalData.iComponentCount		= 0;
		g_spyGlobalData.iSelectedComponent	= -1;
		g_spyGlobalData.itTreeViewSelected	= ITEMTYPE_ROOT;
		ListProducts(g_spyGlobalData.hwndTreeView, g_spyGlobalData.hwndTreeViewOld);
		SwapTreeViewWindows();

		// set the text for the status bar
		ChangeSBText(g_spyGlobalData.hwndStatusBar, -1);
	}
	else {
		TCHAR	szErr1Msg[MAX_MESSAGE+1];
		LoadString(g_spyGlobalData.hResourceInstance, IDS_UNABLE_TO_FIND_SS_MESSAGE, szErr1Msg, MAX_MESSAGE+1);

		TCHAR	szErr2Msg[MAX_MESSAGE+1];
		LoadString(g_spyGlobalData.hResourceInstance, IDS_PLEASE_CHECK_PATH_MESSAGE, szErr2Msg, MAX_MESSAGE+1);

		TCHAR	szErrCaption[MAX_HEADER+1];
		LoadString(g_spyGlobalData.hResourceInstance, IDS_UNABLE_TO_FIND_SS_CAPTION, szErrCaption, MAX_HEADER+1);

		TCHAR	szErrorOut[MAX_MESSAGE*2 + MAX_PATH +1];
		wsprintf(szErrorOut, szErr1Msg, szProfile, szErr2Msg);
		MessageBox(NULL, szErrorOut, szErrCaption, MB_OK|MB_ICONEXCLAMATION);
	}
}

//----------------------------------------------------------------------
// MsiSpyWndProc
//	Window Procedure for msispy- handles WM messages sent to msispy

LRESULT CALLBACK MsiSpyWndProc(
		HWND    hwnd,
		UINT    message,
		WPARAM  wParam,
		LPARAM  lParam
		) {

    switch (message){

	case WM_SIZE:
		ResizeWindows();
		break;

	case WM_SYSCOMMAND:
		// Show the About ... dialog 
		if (wParam == IDW_ABOUT) {
			DialogBox (g_spyGlobalData.hResourceInstance,
				MAKEINTRESOURCE(IDD_ABOUT),
				g_spyGlobalData.hwndParent,
				About);
			break;
		}
		else
			return DefWindowProc (hwnd, message, wParam, lParam);

	case WM_COMMAND:
		// LOWORD added for portability
		switch (LOWORD(wParam)) {
		case IDM_FL_EXIT:
			DestroyWindow (hwnd);
			break;

		case IDM_HLP_ABOUT:
			// Bring up the About.. dialog box
			DialogBox (g_spyGlobalData.hResourceInstance,
				MAKEINTRESOURCE(IDD_ABOUT),
				g_spyGlobalData.hwndParent,
				About);
			break;

		case IDM_HLP_INDEX:
			if (fHandleHelp(g_spyGlobalData.hResourceInstance))
				SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
			break;

		case IDM_FL_OPEN_MSI_PACKAGE:
			// open database
			if (HandleOpen(g_spyGlobalData.hwndParent, g_spyGlobalData.hInstance)== ERROR_SUCCESS) {
				EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_RESTORE_STATE, MF_GRAYED);
				EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_CHECK_DIFFERENCES, MF_GRAYED);

				if (isProductInstalled())
					g_iDataSource = DS_INSTALLEDDB;
				else
					g_iDataSource = DS_UNINSTALLEDDB;

				ClearList(g_spyGlobalData.hwndListView);

				wsprintf(g_spyGlobalData.szFeatureCode,g_szNullString);
				g_spyGlobalData.iComponentCount		= 0;
				g_spyGlobalData.itTreeViewSelected	= ITEMTYPE_ROOT;
				
				ListProducts(g_spyGlobalData.hwndTreeView, g_spyGlobalData.hwndTreeViewOld);
				SwapTreeViewWindows();

				// set the text for the status bar
				ChangeSBText(g_spyGlobalData.hwndStatusBar, -1);
			}
			break;
			
		case IDM_FL_OPEN_LOCAL_SYS:
			// use registry
			EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_RESTORE_STATE, MF_GRAYED);
			EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_CHECK_DIFFERENCES, MF_GRAYED);
			g_iDataSource = DS_REGISTRY;
			ClearList(g_spyGlobalData.hwndListView);
			g_spyGlobalData.iComponentCount=0;
			MSISPYU::MsivCloseDatabase();
			MSISPYU::MsivCloseProfile();
			ListProducts(g_spyGlobalData.hwndTreeView, g_spyGlobalData.hwndTreeViewOld);
			SwapTreeViewWindows();
			ChangeSBText(g_spyGlobalData.hwndStatusBar, -1);
			break;

		case IDM_FL_SAVE_CURRENT_STATE:
			// save profile
			if (g_iDataSource != DS_NONE)
				HandleSaveProfile(g_spyGlobalData.hwndParent, g_spyGlobalData.hInstance);
			break;

		case IDM_FL_CHECK_DIFFERENCES:
			if (g_iDataSource == DS_PROFILE)
				HandleSaveProfile(g_spyGlobalData.hwndParent, g_spyGlobalData.hInstance, TRUE);
			break;

		case IDM_FL_RESTORE_STATE:
			// restore loaded profile
			RestoreProfile();
			break;

		case IDM_FL_LOAD_SAVED_STATE:
			// load profile
			if (HandleLoadProfile(g_spyGlobalData.hwndParent, g_spyGlobalData.hInstance) == ERROR_SUCCESS) 
					InitialiseProfile();
			break;

		case IDM_VW_REFRESH:
			// refresh display
			if (g_spyGlobalData.itTreeViewSelected != ITEMTYPE_NONE) {
				
				g_spyGlobalData.iComponentCount = 0;
				
				ListProducts(g_spyGlobalData.hwndTreeView, g_spyGlobalData.hwndTreeViewOld, TRUE, 
					g_spyGlobalData.szFeatureCode, &g_spyGlobalData.fRefreshInProgress);
				
				UpdateListView(g_spyGlobalData.hwndListView,	g_spyGlobalData.szProductCode, 
					g_spyGlobalData.szFeatureCode, &g_spyGlobalData.iComponentCount, 
					(g_spyGlobalData.itTreeViewSelected==ITEMTYPE_PRODUCT || g_spyGlobalData.itTreeViewSelected==ITEMTYPE_ROOT));
				
				SwapTreeViewWindows();

				ChangeSBText(g_spyGlobalData.hwndStatusBar, g_spyGlobalData.iComponentCount, g_spyGlobalData.szFeatureTitle, 
					(g_spyGlobalData.itTreeViewSelected==ITEMTYPE_PRODUCT?MSISPYU::MsivQueryProductState(g_spyGlobalData.szProductCode):
				
				MSISPYU::MsivQueryFeatureState(g_spyGlobalData.szProductCode, g_spyGlobalData.szFeatureCode)),
					(g_spyGlobalData.itTreeViewSelected==ITEMTYPE_PRODUCT));
	
				if (g_iDataSource == DS_INSTALLEDDB || g_iDataSource == DS_UNINSTALLEDDB)

					if (isProductInstalled())
						g_iDataSource = DS_INSTALLEDDB;
					else
						g_iDataSource = DS_UNINSTALLEDDB;

			}
			break;

		case IDM_VW_PREFERENCES: {
			HandlePreferences(g_spyGlobalData.hwndParent);
			break;
		}

		case IDM_C_REINSTALL:
			// re-install component (from the pop-up menu)

			if (g_spyGlobalData.iSelectedComponent > -1) {

				MsiSetInternalUI(g_spyGlobalData.hPreviousUILevel, NULL);

				TCHAR	szComponentId[MAX_GUID+1];
				ListView_GetItemText(g_spyGlobalData.hwndListView, g_spyGlobalData.iSelectedComponent, 
					3, szComponentId, MAX_GUID+1);

				if (ReinstallComponent(g_spyGlobalData.szProductCode, 
						g_spyGlobalData.szFeatureCode, 
						szComponentId, 
						(g_spyGlobalData.itTreeViewSelected == ITEMTYPE_PRODUCT || g_spyGlobalData.itTreeViewSelected==ITEMTYPE_ROOT)))
					SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);

				MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);


			}
			break;

		case IDM_PF_REINSTALL: {
			// re-install feature (from the pop-up menu)

			INT_PTR iFeatureReinstallLevel =
				DialogBox(g_spyGlobalData.hResourceInstance,
					MAKEINTRESOURCE(IDD_PF_REINSTALL),
					g_spyGlobalData.hwndParent,
					(DLGPROC) HandleFeatureReinstall);

			if (iFeatureReinstallLevel) {
				MsiSetInternalUI(g_spyGlobalData.hPreviousUILevel, NULL);
				if (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_FEATURE) {
					if (ReinstallFeature(g_spyGlobalData.szProductCode, g_spyGlobalData.szFeatureCode, iFeatureReinstallLevel-1)) 
						SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
				}					
				else {
					if (ReinstallProduct(g_spyGlobalData.szProductCode, iFeatureReinstallLevel-1)) 
						SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
				}
				MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
			}
			break;

		}

		case IDM_PF_CONFIGURE: 
			// configure feature (from the pop-up menu)

			INT_PTR iFeatureReconfigureLevel;
			MsiSetInternalUI(g_spyGlobalData.hPreviousUILevel, NULL);

			if (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_FEATURE) {
				iFeatureReconfigureLevel =  DialogBox (g_spyGlobalData.hResourceInstance,
				MAKEINTRESOURCE(IDD_F_CONFIGURE),
				g_spyGlobalData.hwndParent,
				(DLGPROC) HandleFeatureReconfigure);

				if (iFeatureReconfigureLevel) {
					if (ConfigureFeature(g_spyGlobalData.szProductCode, g_spyGlobalData.szFeatureCode, (int)iFeatureReconfigureLevel))
						SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
				}
			}
			else { 

				iFeatureReconfigureLevel =  DialogBox (g_spyGlobalData.hResourceInstance,
					MAKEINTRESOURCE(IDD_P_CONFIGURE),
					g_spyGlobalData.hwndParent,
					(DLGPROC) HandleProductReconfigure);
		
				if (iFeatureReconfigureLevel) 
				{
					// iFeatureReconfigureLevel is in "int" range, so cast OK
					if (ConfigureProduct(g_spyGlobalData.szProductCode, static_cast<int>(iFeatureReconfigureLevel)))
						SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
				}
			}
			MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

			break;

		case IDM_PF_UNINSTALL:
			// un-install feature (from the pop-up menu)
			MsiSetInternalUI(g_spyGlobalData.hPreviousUILevel, NULL);

			if (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_FEATURE) {
				if (ConfigureFeature(g_spyGlobalData.szProductCode, g_spyGlobalData.szFeatureCode, 0))
					lstrcpy(g_spyGlobalData.szFeatureCode, g_szNullString);
					lstrcpy(g_spyGlobalData.szFeatureTitle, g_szNullString);
					SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
			}					
			else {
				if (ConfigureProduct(g_spyGlobalData.szProductCode, 0))  {
					lstrcpy(g_spyGlobalData.szFeatureCode, g_szNullString);
					lstrcpy(g_spyGlobalData.szFeatureTitle, g_szNullString);
					SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
					g_iDataSource = (g_iDataSource==DS_INSTALLEDDB?DS_UNINSTALLEDDB:g_iDataSource);
				}
			}
			MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
			break;

		case IDM_P_INSTALL:
			// install product (from the pop-up menu, uninstalled DB is in use)
			MsiSetInternalUI(g_spyGlobalData.hPreviousUILevel, NULL);

			if (g_iDataSource == DS_UNINSTALLEDDB) {
				TCHAR	szDatabaseName[MAX_PATH+1];
				DWORD	cchDatabaseName = MAX_PATH+1;
				MSISPYU::MsivGetDatabaseName(szDatabaseName, &cchDatabaseName);
				g_iDataSource = (!MsiInstallProduct(szDatabaseName, NULL)?DS_INSTALLEDDB:DS_UNINSTALLEDDB);
			}

			SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
			MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
			break;

		case IDM_P_ADVERTISE:
			// advertise product (from the pop-up menu, uninstalled DB is in use)

			if (g_iDataSource == DS_UNINSTALLEDDB) {
				TCHAR	szDatabaseName[MAX_PATH+1];
				DWORD	cchDatabaseName = MAX_PATH+1;
				MSISPYU::MsivGetDatabaseName(szDatabaseName, &cchDatabaseName);

				MsiSetInternalUI(g_spyGlobalData.hPreviousUILevel, NULL);
				MsiAdvertiseProduct(szDatabaseName, NULL, NULL, 1033);				//--todo
				MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
				if (isProductInstalled())
					g_iDataSource = DS_INSTALLEDDB;
				else
					g_iDataSource = DS_UNINSTALLEDDB;

				SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);

//				g_iDataSource = (!MsiAdvertiseProduct(szDatabaseName, NULL, NULL, 1033)
//					?DS_INSTALLEDDB:DS_UNINSTALLEDDB);

			}
			break;

		case IDM_C_SHOW_PROPERTIES:
			// component properties (from the pop-up menu)

			if (g_spyGlobalData.iSelectedComponent > -1) {
 				ShowComponentProp(g_spyGlobalData.hwndListView, g_spyGlobalData.hResourceInstance, g_spyGlobalData.iSelectedComponent);
			}
			break;



		case IDM_PF_SHOW_PROPERTIES:
			// feature properties (from the pop-up menu)

			if (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_ROOT) {
				switch (g_iDataSource) {
				case DS_REGISTRY:
					break;
				case DS_UNINSTALLEDDB:	//fall-thru
				case DS_INSTALLEDDB:
					ShowDatabaseProperty(g_spyGlobalData.hResourceInstance, g_spyGlobalData.hwndParent);
					break;
				case DS_PROFILE:
					ShowProfileProperty(g_spyGlobalData.hResourceInstance, g_spyGlobalData.hwndParent);
					break;
				}

			}
			else if (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_PRODUCT)
				ShowProductProp(g_spyGlobalData.szProductCode, g_spyGlobalData.hResourceInstance, g_spyGlobalData.hwndParent);
			else if (g_spyGlobalData.itTreeViewSelected == ITEMTYPE_FEATURE)
				ShowFeatureProp(g_spyGlobalData.szProductCode, g_spyGlobalData.szFeatureCode, 
					g_spyGlobalData.hResourceInstance, g_spyGlobalData.hwndParent);
			break;
		}
		break;

	case WM_NOTIFY:
		// notify messages- call the appropriate notify handlers

		if (!g_spyGlobalData.fRefreshInProgress) {
			if (TV_NotifyHandler(lParam, g_spyGlobalData.hwndTreeView, g_spyGlobalData.szProductCode,
				g_spyGlobalData.szFeatureCode, g_spyGlobalData.szFeatureTitle, &g_spyGlobalData.itTreeViewSelected)) {
				g_spyGlobalData.iSelectedComponent = -1;	

				UpdateListView(g_spyGlobalData.hwndListView,	g_spyGlobalData.szProductCode, 
					g_spyGlobalData.szFeatureCode, &g_spyGlobalData.iComponentCount, 
					(g_spyGlobalData.itTreeViewSelected == ITEMTYPE_PRODUCT || g_spyGlobalData.itTreeViewSelected == ITEMTYPE_ROOT));

				// update the status bar text
				ChangeSBText(g_spyGlobalData.hwndStatusBar, g_spyGlobalData.iComponentCount, g_spyGlobalData.szFeatureTitle, 
					(g_spyGlobalData.itTreeViewSelected == ITEMTYPE_PRODUCT ? 
						MSISPYU::MsivQueryProductState(g_spyGlobalData.szProductCode)
					:	MSISPYU::MsivQueryFeatureState(g_spyGlobalData.szProductCode, g_spyGlobalData.szFeatureCode)),
														(g_spyGlobalData.itTreeViewSelected == ITEMTYPE_PRODUCT));
			}

			LV_NotifyHandler(g_spyGlobalData.hwndTreeView, g_spyGlobalData.hwndListView, lParam, &g_spyGlobalData.iSelectedComponent);
		}
		break;

	
	case WM_MOUSEMOVE:
		// mouse move messages- handle this to move splitter bar
		MsgMouseMove(g_spyGlobalData.hwndParent, WM_MOUSEMOVE, wParam, lParam);
		break;

    case WM_LBUTTONDOWN:
		MsgLButtonDown(g_spyGlobalData.hwndParent, WM_LBUTTONDOWN, wParam, lParam);
		break;

    case WM_LBUTTONUP:
		MsgLButtonUp(g_spyGlobalData.hwndParent, WM_LBUTTONUP, wParam, lParam);
		break;
	
	case WM_PAINT:
		HandlePaint (hwnd);
		break;

	case WM_DESTROY:
		W32::WinHelp(g_spyGlobalData.hwndParent, g_szHelpFilePath, HELP_QUIT, 0);
		if (hwnd == g_spyGlobalData.hwndParent)
			PostQuitMessage (0);
		break;

	case WM_CONTEXTMENU:
		if ((HWND)wParam == g_spyGlobalData.hwndListView)
			ListViewPopupMenu(g_spyGlobalData.hwndParent, lParam);
		else if ((HWND)wParam == g_spyGlobalData.hwndTreeView)
			TreeViewPopupMenu(g_spyGlobalData.hwndParent, lParam);
		break;

	default:
		return DefWindowProc(hwnd, message, wParam, lParam);

    }
    return 0;
}

//----------------------------------------------------------------------
// InitMsiSpy
//	Initialisation function to register the app class

BOOL InitMsiSpy(
		HINSTANCE  hInstance
		) {

    WNDCLASSEX    wc;  


	TCHAR szClassName[MAX_HEADER+1];
	LoadString(g_spyGlobalData.hResourceInstance, IDS_CLASSNAME, szClassName, MAX_HEADER+1);

    wc.cbSize         = sizeof(WNDCLASSEX);
    wc.style          = 0;
    wc.lpfnWndProc    = (WNDPROC) MsiSpyWndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;
    wc.hInstance      = hInstance;
    wc.hIcon          = LoadIcon (g_spyGlobalData.hResourceInstance, MAKEINTRESOURCE(IDI_MSISPY));
    wc.hCursor        = LoadCursor (g_spyGlobalData.hResourceInstance, MAKEINTRESOURCE(IDC_SPLIT));
    wc.hbrBackground  = (HBRUSH) (COLOR_WINDOW + 1);
    wc.lpszMenuName   = NULL;
    wc.lpszClassName  = szClassName;
    wc.hIconSm        = NULL;

    if (!RegisterClassEx(&wc)) {
		DWORD err = GetLastError();
        return FALSE;
	}
    return TRUE;
}

// skips whitespace at the beginning of the buffer passed in
BOOL SkipWhiteSpace(LPTSTR *lpBuffer) {
	while ((**lpBuffer) == ' ') 
#ifdef UNICODE
		(*lpBuffer)++;
#else
		*lpBuffer = CharNext(*lpBuffer);
#endif

	return (**lpBuffer == '\0');
}

// skips appname at the beginning of the buffer passed in
BOOL SkipAppName(LPTSTR *lpBuffer) {
	SkipWhiteSpace(lpBuffer);

	// handle appname enclosed in quotes
	if (**lpBuffer == '"')
	{
		(*lpBuffer)++; // for "
		while (((**lpBuffer) != '\0') && ((**lpBuffer) != '"'))
		{
	#ifdef UNICODE
			(*lpBuffer)++;
	#else
			*lpBuffer = CharNext(*lpBuffer);
	#endif
		}
		if ((**lpBuffer) == '"')
			(*lpBuffer)++; // for "
	}
	else
	{
		while (((**lpBuffer) != '\0') && ((**lpBuffer) != ' '))
	#ifdef UNICODE
			(*lpBuffer)++;
	#else
			*lpBuffer = CharNext(*lpBuffer);
	#endif
	}

	return SkipWhiteSpace(lpBuffer);
}



//--todo:cb
// extracts one or two (if szFile2 is passed in) filenames from szCmdLine
BOOL ExtractFileNames(
		LPTSTR	szCmdLine,
		LPTSTR	szFile1,
		LPTSTR	szFile2 = NULL
		) {

	// file 1:
	if (SkipWhiteSpace(&szCmdLine))
		return FALSE;

	TCHAR	szTemp[MAX_PATH+1];
	UINT	iOffSet				= (szCmdLine[0] == '"')?1:0;
	TCHAR	chTermChar			= iOffSet?'"':' ';
	UINT	iCount				= 1;

	while ((szCmdLine[iCount]!= chTermChar) && (szCmdLine[iCount] != '\0'))
		iCount++;
	lstrcpyn(szTemp, szCmdLine, (++iCount)+iOffSet);

	// if not full path, add current directory
	if ((szTemp[1+iOffSet] == TEXT(':')) || (szTemp[0+iOffSet] == TEXT('\\')) 
		|| ((szTemp[1+iOffSet] == TEXT('\\')) && (szTemp[0+iOffSet] == TEXT('\\'))))
		lstrcpy(szFile1, szTemp);
	else {
		TCHAR szDirectory[MAX_PATH+1];
		::GetCurrentDirectory(MAX_PATH+1, szDirectory);
		wsprintf(szFile1, iOffSet?TEXT("\"%s\\%s"):TEXT("%s\\%s"), szDirectory, &szTemp[iOffSet]);
	}

	
	if (!szFile2)
		return TRUE;

	// file 2:
	szCmdLine = &szCmdLine[iCount];
	if (SkipWhiteSpace(&szCmdLine))
		return FALSE;

	iOffSet				= (szCmdLine[0] == '"')?1:0;
	chTermChar			= iOffSet?'"':' ';
	iCount				= 1;

	while ((szCmdLine[iCount]!= chTermChar) && (szCmdLine[iCount] != '\0'))
		iCount++;
	lstrcpyn(szTemp, szCmdLine, ((++iCount)+((chTermChar == '"')?1:0)));

	// if not full path, add current directory
	if ((szTemp[1+iOffSet] == TEXT(':')) || (szTemp[0+iOffSet] == TEXT('\\')) 
		|| ((szTemp[1+iOffSet] == TEXT('\\')) && (szTemp[0+iOffSet] == TEXT('\\'))))
		lstrcpy(szFile2, szTemp);
	else {
		TCHAR szDirectory[MAX_PATH+1];
		::GetCurrentDirectory(MAX_PATH+1, szDirectory);
		wsprintf(szFile2, iOffSet?TEXT("\"%s\\%s"):TEXT("%s\\%s"), szDirectory, &szTemp[iOffSet]);
	}

	return (iCount>1);
}


// check if lpCmdline has a valid option, if not display help dialog
//	returns 0 if lpCmdLine began with "/",
//	1 otherwise (must be a profile name)
int HandleCmdLine(LPTSTR lpCmdLine) {

	BOOL fOkay=TRUE;
	TCHAR	szProfile[MAX_PATH+1];
	TCHAR	szDiffFile[MAX_PATH+1];
	TCHAR	szErrorLine1[MAX_MESSAGE+1];
	TCHAR	szErrorMsg[MAX_MESSAGE+MAX_PATH+1];
	TCHAR	szHelpMsg[MAX_MESSAGE+1];
	TCHAR	szHelpCaption[MAX_HEADER+1];


	if ((lpCmdLine[0] == '/') || (lpCmdLine[0] == '-')) {
		switch (lpCmdLine[1]) {
		case 'd' :
		case 'D' : 
			if (!ExtractFileNames(&lpCmdLine[2], szProfile, szDiffFile))
				fOkay = FALSE;
			else 

				if (MSISPYU::MsivLoadProfile(szProfile)== ERROR_SUCCESS)
					CheckDiff(szDiffFile);
				else {
					LoadString(g_spyGlobalData.hResourceInstance, IDS_ERRORCHKDIFF_MESSAGE1, szErrorLine1, MAX_MESSAGE+1);
					LoadString(g_spyGlobalData.hResourceInstance, IDS_ERRORCHKDIFF_MESSAGE2, szHelpMsg, MAX_MESSAGE+1);
					LoadString(g_spyGlobalData.hResourceInstance, IDS_ERRORCHKDIFF_CAPTION, szHelpCaption, MAX_HEADER+1);
					wsprintf(szErrorMsg, szErrorLine1, szProfile, szHelpMsg);
					MessageBox(NULL, szErrorMsg, szHelpCaption, MB_OK);
				}
				break;

		case 's':
		case 'S':
			if (!ExtractFileNames(&lpCmdLine[2], szProfile))
				fOkay = FALSE;
			else
				MSISPYU::MsivSaveProfile(szProfile);
		
			break;

		case 'r':
		case 'R':
			if (!ExtractFileNames(&lpCmdLine[2], szProfile))
				fOkay = FALSE;
			else
				if (MSISPYU::MsivLoadProfile(szProfile)== ERROR_SUCCESS)
					RestoreProfile(FALSE);
				else {
					LoadString(g_spyGlobalData.hResourceInstance, IDS_ERRORRESTORING_MESSAGE1, szErrorLine1, MAX_MESSAGE+1);
//					LoadString(g_spyGlobalData.hResourceInstance, IDS_ERRORRESTORING_MESSAGE2, szHelpMsg, MAX_MESSAGE+1);
					LoadString(g_spyGlobalData.hResourceInstance, IDS_ERRORRESTORING_CAPTION, szHelpCaption, MAX_HEADER+1);
					wsprintf(szErrorMsg, szErrorLine1, szProfile);
					MessageBox(NULL, szErrorMsg, szHelpCaption, MB_OK);
				}
			break;


		default:
			fOkay=FALSE;
			break;
		}
	}
	else
		return 1;


	if (!fOkay) {
		LoadString(g_spyGlobalData.hResourceInstance, IDS_COMMANDLINEHELP_MESSAGE, szHelpMsg, MAX_MESSAGE+1);
		LoadString(g_spyGlobalData.hResourceInstance, IDS_COMMANDLINEHELP_CAPTION, szHelpCaption, MAX_HEADER+1);
		MessageBox(NULL, szHelpMsg, szHelpCaption, MB_OK);
	}

	return 0;
}




BOOL CreateNewUI(
	HINSTANCE hPrevInstance,
	int nCmdShow,
	RECT *rWindow = NULL
	) {
    // Register main window class if this is the first instance of the app. 


	TCHAR	szAppName[MAX_HEADER+1];
	LoadString(g_spyGlobalData.hResourceInstance, IDS_APPNAME, szAppName, MAX_HEADER+1);

	TCHAR	szClassName[MAX_HEADER+1];
	LoadString(g_spyGlobalData.hResourceInstance, IDS_CLASSNAME, szClassName, MAX_HEADER+1);

    // Create the app. window 
    g_spyGlobalData.hwndParent = CreateWindowEx (WS_EX_CONTROLPARENT,
						 szClassName,
                         szAppName,
                         WS_OVERLAPPEDWINDOW,
                         (rWindow?rWindow->left:CW_USEDEFAULT),
                         (rWindow?rWindow->top:CW_USEDEFAULT),
                         (rWindow?(rWindow->right-rWindow->left):CW_USEDEFAULT),
                         (rWindow?(rWindow->bottom-rWindow->top):CW_USEDEFAULT),
                         (HWND) NULL,
                         (HMENU) LoadMenu(g_spyGlobalData.hResourceInstance, MAKEINTRESOURCE(IDR_MSISPYMENU)),
                         g_spyGlobalData.hInstance,
                         (LPTSTR) NULL);


	if (!g_spyGlobalData.hwndParent)
		return FALSE;

 	if (!CreateUI())
		return FALSE;
/* 7-15-98
// !!! temporary to get profling disabled for ISV release 04/10/1998
// gray out the menu items
	EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_LOADPROF, MF_GRAYED);
	EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_SAVEPROF, MF_GRAYED);
	EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_RESTOREPROF, MF_GRAYED);
	EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_CHECKDIFF, MF_GRAYED);
// !!! end 
*/
	ShowWindow (g_spyGlobalData.hwndParent, nCmdShow);
    UpdateWindow (g_spyGlobalData.hwndParent);
	return TRUE;
}


//----------------------------------------------------------------------
// WinMain
//	entry-point for msispy
//	creates the windows, sets up message loop

extern "C" int __stdcall _tWinMain(
    HINSTANCE	hInstance,
    HINSTANCE	hPrevInstance,
    LPSTR		rgchCmdLine,
    int			nCmdShow
    )
{


	MSG msg;
    g_spyGlobalData.hInstance = hInstance;

	LPTSTR	lpCmdLine = GetCommandLine();

	if (!fInitMSI(&g_spyGlobalData.hResourceInstance))
		return -1;

	assert(g_spyGlobalData.hResourceInstance != 0);
 	LoadString(g_spyGlobalData.hResourceInstance, IDS_NULLSTRING, g_szNullString, MAX_NULLSTRING+1);

	InitUIControls(hInstance, g_spyGlobalData.hResourceInstance);

	if (!SkipAppName(&lpCmdLine)) {		 // handle command line if it exists
		if (!HandleCmdLine(lpCmdLine)) {
			MSI::MsiCloseAllHandles();

			OLE::CoUninitialize();
			W32::ExitProcess(1);
			return 0;
		}
	}

	SkipWhiteSpace(&lpCmdLine);

	TCHAR	szFatalErrMsg[MAX_MESSAGE+1];
	LoadString(g_spyGlobalData.hResourceInstance, IDS_FATALINITERRMSG, szFatalErrMsg, MAX_MESSAGE+1);

	TCHAR	szFatalErrCaption[MAX_HEADER+1];
	LoadString(g_spyGlobalData.hResourceInstance, IDS_FATALERRCAPTION, szFatalErrCaption, MAX_HEADER+1);

	// Register main window class if this is the first instance of the app. 
    if (!hPrevInstance)
		if (!InitMsiSpy(g_spyGlobalData.hInstance)) {
			MessageBox (NULL, szFatalErrMsg, szFatalErrCaption, MB_OK|MB_ICONSTOP);
			return -1;
		}

	if (!CreateNewUI(hPrevInstance, nCmdShow)){
		MessageBox (NULL, szFatalErrMsg, szFatalErrCaption, MB_OK|MB_ICONSTOP);
		return -1;
	}

	if (lstrcmp(lpCmdLine, TEXT(""))) {
		TCHAR	szFileName[MAX_PATH+1];
		ExtractFileNames(lpCmdLine, szFileName);
		InitialiseProfile(szFileName);
	}

	g_spyGlobalData.hAcceleratorTable = LoadAccelerators(g_spyGlobalData.hResourceInstance, MAKEINTRESOURCE(IDR_ACCEL));
	while (GetMessage (&msg, NULL, 0, 0) >0) { 
		if (!TranslateAccelerator(g_spyGlobalData.hwndParent, g_spyGlobalData.hAcceleratorTable, &msg)) {
			TranslateMessage (&msg);
			DispatchMessage (&msg);
		}
	}
	MsiSetInternalUI(g_spyGlobalData.hPreviousUILevel, NULL);

	return (int) msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\propshts.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000

//
//  File:       propshts.h
//
//--------------------------------------------------------------------------



#ifndef PROPSHTS_H
#include <commctrl.h>
#include "spyres.h"
#include "msi.h"
#include "msip.h"

#ifndef _WIN64
#define INT_PTR int
#define UINT_PTR UINT
#define LONG_PTR LONG
#endif

const UINT			ERRORD	= ERROR_UNKNOWN;
const INSTALLSTATE	ERRORE	= INSTALLSTATE_ABSENT;
const USERINFOSTATE	ERRORF	= USERINFOSTATE_UNKNOWN;

#define W32
#define MSISPYU




//#ifdef LINKDYNAMIC

#if 1
extern T_MsivEnumProducts				MsivEnumProducts;
extern T_MsivEnumFeatures				MsivEnumFeatures;
extern T_MsivEnumComponentsFromFeature	MsivEnumComponentsFromFeature;
extern T_MsivEnumComponents				MsivEnumComponents;
extern T_MsivGetComponentName			MsivGetComponentName;
extern T_MsivGetProductInfo				MsivGetProductInfo;
extern T_MsivGetFeatureInfo				MsivGetFeatureInfo;
extern T_MsivOpenDatabase				MsivOpenDatabase;
extern T_MsivCloseDatabase				MsivCloseDatabase;
extern T_MsivGetDatabaseName			MsivGetDatabaseName;
extern T_MsivEnumComponentsFromProduct	MsivEnumComponentsFromProduct;
extern T_MsivSaveProfile				MsivSaveProfile;
extern T_MsivLoadProfile				MsivLoadProfile;
extern T_MsivCloseProfile				MsivCloseProfile;
extern T_MsivGetProfileName				MsivGetProfileName;
extern T_MsivGetFeatureUsage			MsivGetFeatureUsage;
extern T_MsivEnumClients				MsivEnumClients;
extern T_MsivGetProfileInfo				MsivGetProfileInfo;
extern T_MsivEnumFilesFromComponent		MsivEnumFilesFromComponent;
extern T_MsivGetFileInfo				MsivGetFileInfo;
extern T_MsivQueryProductState			MsivQueryProductState;
extern T_MsivQueryFeatureState			MsivQueryFeatureState;
extern T_MsivLocateComponent			MsivLocateComponent;
extern T_MsivGetComponentPath			MsivGetComponentPath;
extern T_MsivGetUserInfo				MsivGetUserInfo;
#endif

const int	CX_BITMAP			= 16;
const int	CY_BITMAP			= 16;
const int	NUM_LISTVIEWICONS	=  5;


const int	MAX_FILTER			= 1024;
const int	MAX_MESSAGE			= 1024;
const int	MAX_HEADER			=  256;
const int	MAX_EXT				=   10;
const int	MAX_DEFAULTTEXT		=    5;
const int	MAX_NULLSTRING		=    5;

const int	LVICON_COMPONENT		=  0;
const int	LVICON_BROKENCOMPONENT	=  1;
const int	LVICON_FILE				=  2;
const int	LVICON_BROKENFILE		=  3;
const int	LVICON_ABSENTCOMPONENT	=  4;



typedef enum tagMODE {
	MODE_NORMAL			= 0,
	MODE_DIAGNOSTIC		= 1,
	MODE_RESTRICTED		= 2,
	MODE_DEGRADED		= 3
}	MODE;


typedef enum tagDATASOURCETYPE {
	DS_NONE				=	0,
	DS_REGISTRY			=	1,
	DS_UNINSTALLEDDB	=	2,
	DS_INSTALLEDDB		=	3,
	DS_PROFILE			=	4
}	DATASOURCETYPE;

typedef enum tagITEMTYPE {
	ITEMTYPE_NONE		=	0,
	ITEMTYPE_COMPONENT	=	1,
	ITEMTYPE_FEATURE	=	2,
	ITEMTYPE_PRODUCT	=	3,
	ITEMTYPE_ROOT		=	4
}	ITEMTYPE;






typedef struct tagMSISPYSTRUCT
{
    HINSTANCE	hInstance;				// current instance
	HINSTANCE	hResourceInstance;		// instance of resource dll
    HWND		hwndParent;				// handle of the main window
    HWND		hwndStatusBar;			// handle of the status window
    HWND		hwndListView;			// handle of the list view window
    HWND		hwndTreeView;			// handle of the tree view window
    HWND		hwndTreeViewOld;		// handle of the second tree view window (for refresh)

	INT			iSelectedComponent;		// index of selected component in list-view	(-1 if none)
    INT			iComponentCount;		// number of components in list-view

	INSTALLUILEVEL hPreviousUILevel;	
	HACCEL		hAcceleratorTable;
	TCHAR		szProductCode[MAX_PATH+1];
	TCHAR		szFeatureTitle[MAX_PATH+1];
	TCHAR		szFeatureCode[MAX_PATH+1];	
	ITEMTYPE	itTreeViewSelected;		// none/pdt/ftr/root [/cmp]
	BOOL		fRefreshInProgress;

} MSISPYSTRUCT;






typedef struct _MSIPackageInfoStruct 
{
	TCHAR	rgszInfo[21][MAX_PATH+1];
} MSIPackageInfoStruct;


typedef struct _ProductInfoStruct1 
{
	TCHAR	szProductName[MAX_PRODUCT_CHARS+1];
	TCHAR	szProductVer[MAX_ATTRIB_CHARS+1];
	TCHAR	szPublisher[MAX_PRODUCT_CHARS+1];
	TCHAR	szProductCode[MAX_GUID+1];
	TCHAR	szLocalPackage[MAX_PATH+1];
	TCHAR	szProductUserName[100];
	TCHAR	szProductUserComp[100];
	TCHAR	szProductId[MAX_GUID+1];
	TCHAR	szStatus[MAX_STATUS_CHARS+1];
} ProductInfoStruct1;


typedef struct _ProductInfoStruct2
{
	TCHAR	szProductName[MAX_PRODUCT_CHARS+1];
	TCHAR	szHelpURL[MAX_PATH+1];
	TCHAR	szInfoURL[MAX_PATH+1];
	TCHAR	szUpdateURL[MAX_PATH+1];
	TCHAR	szHelpPhone[30];
	TCHAR	szInstallDate[MAX_GUID+1];
	TCHAR	szInstallSrc[MAX_PATH+1];
	TCHAR	szInstallLoc[MAX_PATH+1];
	TCHAR	szLanguage[100];
} ProductInfoStruct2;

typedef struct _FeatureInfoStruct 
{
		TCHAR	szProductCode[MAX_GUID+1];
		TCHAR	szFeatureName[MAX_FEATURE_CHARS+1];
		TCHAR	szFeatureTitle[MAX_PATH+1];
		TCHAR	szFeaturePar[MAX_FEATURE_CHARS+1];
		TCHAR	szFeatureDesc[MAX_PATH+1];
		DWORD	iUseCount;
		TCHAR	szDateUsed[30];
		TCHAR	szStatus[MAX_STATUS_CHARS+1];
} FeatureInfoStruct;


typedef struct _ComponentInfoStruct 
{
		TCHAR szProductCode[MAX_GUID+1];
		TCHAR szComponentId[MAX_GUID+1];
		TCHAR szComponentName[MAX_COMPONENT_CHARS+1];
		TCHAR szComponentStatus[MAX_STATUS_CHARS+1];
		TCHAR szComponentPath[MAX_PATH+1];
} ComponentInfoStruct;


typedef struct _FileInfoStruct 
{
	TCHAR		szProductCode[MAX_GUID+1];
	TCHAR		szComponentId[MAX_GUID+1];
	TCHAR		szComponentName[MAX_PATH+1];
	TCHAR		szTitle[MAX_PATH+1];
	TCHAR		szLocation[MAX_PATH+1];
	TCHAR		szExpectedSize[30];
	TCHAR		szActualSize[30];
	SYSTEMTIME	stCreated;
	SYSTEMTIME	stLastModified;
	SYSTEMTIME	stLastAccessed;
} FileInfoStruct;


BOOL APIENTRY About(
		HWND hDlg,
		UINT message,
		UINT wParam,
		LONG lParam
		);


void ShowComponentProp(
		HWND		hwndListView, 
		HINSTANCE	hInst,
		int			iItemIndex
		);

void ShowFeatureProp(
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName,
		HINSTANCE hInst,
		HWND	hwndParent
		);

void ShowProductProp(
		LPCTSTR	szProductCode,
		HINSTANCE hInst,
		HWND	hwndParent
		);

void ShowDatabaseProperty(
		HINSTANCE	hInst,
		HWND		hwndParent
		);

void ShowProfileProperty(
		HINSTANCE	hInst,
		HWND		hwndParent
		);


//--todo:cb
void FillInText(
		LPTSTR			lpValueBuf,			// size: MAX_STATUS_CHARS+1
  const	DWORD			cchValueBuf,
  const	INSTALLSTATE	iResult,
  const ITEMTYPE		itType	= ITEMTYPE_COMPONENT
		);

//--todo:cb
void FindBasePath(
		LPTSTR	szFullPath, 
		LPTSTR	lpBasePath
		);

BOOL InitListViewImageLists(
		HWND	hwndListView
		);
	
void SwitchMode(
		MODE	modeNew,
		BOOL	fMessage = FALSE);

BOOL HandlePreferences(
		HWND hwndParent
		);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\ui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ui.cpp
//
//--------------------------------------------------------------------------


#include "msispyu.h"
#include "propshts.h"
#include "ui.h"
#include "hash.h"
#include <commdlg.h> // OPENFILE dlg

// globals
extern TCHAR			g_szNullString[MAX_NULLSTRING+1];
extern HINSTANCE		g_hResourceInst;
extern DATASOURCETYPE	g_iDataSource;
extern MODE				g_modeCurrent;
extern MSISPYSTRUCT		g_spyGlobalData;

#define TRYEFFICIENT

//----------------------------------------------------------------------
// InitTreeViewImageLists
//	Adds the image (icon) list to a tree view window

BOOL InitTreeViewImageLists(
		HWND		hwndTreeView, 
		HINSTANCE	hInst
		) { 

	HIMAGELIST hImL;	// handle of image list 
	HICON hIcon;		// handle of icon

	// create the image list. 
	if ((hImL = ImageList_Create(CX_BITMAP, CY_BITMAP, 
		ILC_MASK|ILC_COLOR, NUM_TREEVIEWICONS, 0)) == NULL)
		return FALSE; 

	// add the bitmaps
	for (int iCount = TVICON_ROOT; iCount <= TVICON_BROKENFEATURE; iCount++) {
		hIcon= LoadIcon (g_hResourceInst, MAKEINTRESOURCE(IDI_COMPUTER+iCount));
		ImageList_AddIcon(hImL, hIcon); 
		DeleteObject(hIcon); 
	}

	// fail if not all of the images were added. 
	if (ImageList_GetImageCount(hImL) < NUM_TREEVIEWICONS)
		return FALSE; 


	// associate the image list with the tree-view control. 
	TreeView_SetImageList(hwndTreeView, hImL, TVSIL_NORMAL); 

	return TRUE; 
} 


//----------------------------------------------------------------------
// CreateTreeView
//	Creates identical tree view windows, one over the other
//	At any time, only one of these windows is visible. The two windows are
//	used for Refresh operations- the hidden window is first updated with
//	the new contents and then made visible

HWND CreateTreeView(
		HWND		hwndParent, 
		HINSTANCE	hInst,
		HWND		*hwndOld,
		UINT		cx,
		UINT		cy
		) {

	HWND hwndTree;					// handle to the tree view created
	RECT rcl;						// rectangle for setting size of window

	GetClientRect(hwndParent, &rcl);

	// create the tree view to cover left cx,cy of the screen.
	hwndTree = CreateWindowEx(WS_EX_CLIENTEDGE, 
			WC_TREEVIEW,
			g_szNullString,
			WS_VISIBLE | WS_CHILD | TVS_HASLINES | TVS_DISABLEDRAGDROP | WS_TABSTOP |
			TVS_HASBUTTONS | TVS_LINESATROOT | TVS_SHOWSELALWAYS | WS_BORDER,
			0, 0,
			cx, cy,
			hwndParent,
			(HMENU) IDW_TREEVIEW,
			hInst,
			NULL);

	// add image-list
	if (hwndTree != NULL)
		InitTreeViewImageLists(hwndTree, hInst);

	// create a second window identical to the first, needed for refesh
	*hwndOld = CreateWindowEx(WS_EX_CLIENTEDGE, 
			WC_TREEVIEW,
			g_szNullString,
			WS_VISIBLE | WS_CHILD | TVS_HASLINES | TVS_DISABLEDRAGDROP | WS_TABSTOP |
			TVS_HASBUTTONS | TVS_LINESATROOT | TVS_SHOWSELALWAYS | WS_BORDER,
			0, 0,
			cx, cy,
			hwndParent,
			(HMENU) IDW_TREEVIEW,
			hInst,
			NULL);

	if (*hwndOld != NULL)
		InitTreeViewImageLists(*hwndOld, hInst);
	else
		hwndTree =NULL;

	return hwndTree;
}


//----------------------------------------------------------------------
// CreateListView
//	Creates the list view to display the component list and adds in the
//	image list for the window

HWND CreateListView(
		HWND		hwndParent, 
		HINSTANCE	hInst,
		UINT		iWidth
		) {

	HWND	hwndList;		// handle of list view to be created (returned)
	RECT	rcl;			// rectangle for setting size of window
	LV_COLUMN lvColumn;     // list view column structure

	// Get parent window's size and determine base of column-width for lv cols
	GetClientRect(hwndParent, &rcl);

    // Create the list view window, of width iWidth
    // and account for the status bar.
	hwndList = CreateWindowEx(WS_EX_CLIENTEDGE,
		WC_LISTVIEW,								// list view class
		g_szNullString,								// no default text
		WS_VISIBLE | WS_CHILD | LVS_REPORT | WS_TABSTOP |
		LVS_SINGLESEL | WS_HSCROLL | WS_VSCROLL |WS_BORDER ,
		0, rcl.top, 
		iWidth+2, rcl.bottom - rcl.top,
		hwndParent,
		(HMENU) IDW_LISTVIEW,
		hInst,
		NULL );

	if (!hwndList) 
		return NULL;

	// members of the column structure
	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvColumn.fmt = LVCFMT_LEFT;					// left-align column

	// create the column header
	TCHAR szCompNameHdr[MAX_HEADER+1];
	TCHAR szCompStatusHdr[MAX_HEADER+1];
	TCHAR szCompPathHdr[MAX_HEADER+1];
	TCHAR szCompIdHdr[MAX_HEADER+1];

	LoadString(g_hResourceInst, IDS_C_NAME_HEADER, szCompNameHdr, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_C_STATUS_HEADER, szCompStatusHdr, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_C_PATH_HEADER, szCompPathHdr, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_C_GUID_HEADER, szCompIdHdr, MAX_HEADER+1);

	// Add first column: component names
    lvColumn.cx			= ((iWidth * 7)/ 32);			// width of column in pixels
	lvColumn.pszText	= szCompNameHdr;				// column header title
	lvColumn.iSubItem	= 0;							// column position (index)
	ListView_InsertColumn(hwndList, 0, &lvColumn);

	// Add second column: status of components
    lvColumn.cx			= ((iWidth * 7)/ 32);			// width of column in pixels
	lvColumn.pszText	= szCompStatusHdr;
	lvColumn.iSubItem	= 1;
	ListView_InsertColumn(hwndList, 1, &lvColumn);

	// Add third column: path of components
    lvColumn.cx			= ((iWidth * 12)/ 32) -1;		// width of column in pixels
	lvColumn.pszText	= szCompPathHdr;
	lvColumn.iSubItem	= 2;
	ListView_InsertColumn(hwndList, 2, &lvColumn);

	// Add fourth column: component guid
    lvColumn.cx			= ((iWidth * 15)/32) -1;		// width of column in pixels
	lvColumn.pszText	= szCompIdHdr;
	lvColumn.iSubItem	= 3;
	ListView_InsertColumn(hwndList, 3, &lvColumn);

	// add the image-list  
	if (hwndList != NULL) 
		InitListViewImageLists(hwndList);

	return hwndList; 

}


//----------------------------------------------------------------------
// MakeBold
//	Displays the product name in bold for the product code passed in
//	Used to show all the clients of a (selected) component in bold-
//	(by calls to MsivEnumClients and MakeBold for each)

void MakeBold(
		HWND	hwndTreeView,
		LPCTSTR	szProductCode
		) {

	HTREEITEM	hCurrent = TreeView_GetRoot(hwndTreeView);
	hCurrent = TreeView_GetChild(hwndTreeView, hCurrent);

	// go thru all the products till the reqd product is found
	while (hCurrent!=NULL) {

		TV_ITEM tviCurrent;
		tviCurrent.hItem = hCurrent;
		tviCurrent.mask = TVIF_PARAM;
		TreeView_GetItem(hwndTreeView, &tviCurrent);

		if (!lstrcmp((TCHAR *)tviCurrent.lParam, szProductCode)) {
			// we found the required product

			tviCurrent.stateMask = TVIS_BOLD;
			tviCurrent.state = TVIS_BOLD;
			tviCurrent.mask = TVIF_STATE;
			TreeView_SetItem(hwndTreeView, &tviCurrent);
			return;
		} 
		hCurrent = TreeView_GetNextSibling(hwndTreeView, hCurrent);
	}
}


//----------------------------------------------------------------------
// ClearBold
//	Changes all the displayed products to normal font, cancelling
//	out the effect of MakeBold

void ClearBold(
		HWND	hwndTreeView
		) {

	HTREEITEM	hCurrent = TreeView_GetRoot(hwndTreeView);
	hCurrent = TreeView_GetChild(hwndTreeView, hCurrent);

	while (hCurrent!=NULL) {

		TV_ITEM tviCurrent;
		tviCurrent.hItem = hCurrent;
		tviCurrent.mask = TVIF_PARAM;
		TreeView_GetItem(hwndTreeView, &tviCurrent);

		tviCurrent.stateMask = TVIS_BOLD;
		tviCurrent.state = NULL;
		tviCurrent.mask = TVIF_STATE;
		TreeView_SetItem(hwndTreeView, &tviCurrent);

		hCurrent = TreeView_GetNextSibling(hwndTreeView, hCurrent);
	}
}
		
//----------------------------------------------------------------------
// Expand
//	Given two tree windows, it expands all the items in the second
//	that were expanded in the first
//	Retains the characteristics of each item
//	Used for refresh
//	BUG: uses position, not unique ID. TODO.

void Expand(
		HWND		hwndTreeView, 
		HWND		hwndTreeViewNew,
		HTREEITEM	hOld, 
		HTREEITEM	hNew
		) {

	HTREEITEM hNextOld = NULL;
	HTREEITEM hNextNew = NULL;

	TV_ITEM tviOld;
	tviOld.hItem = hOld;
	tviOld.state=NULL;
	tviOld.stateMask = TVIS_EXPANDED|TVIS_SELECTED|TVIS_BOLD;
	tviOld.mask = TVIF_STATE|TVIF_PARAM;

	TreeView_GetItem(hwndTreeView, &tviOld);

	if (tviOld.state & TVIS_EXPANDED)
		TreeView_Expand(hwndTreeViewNew, hNew, TVE_EXPAND);		// set expanded

	if (tviOld.state & TVIS_SELECTED)
		TreeView_Select(hwndTreeViewNew, hNew, TVGN_CARET);		// set selected.

	if (tviOld.state & TVIS_BOLD) {								// set bold
		TV_ITEM tviCurrent;
		tviCurrent.hItem = hNew;
		tviCurrent.stateMask = TVIS_BOLD;
		tviCurrent.state = TVIS_BOLD;
		tviCurrent.mask = TVIF_STATE;
		TreeView_SetItem(hwndTreeViewNew, &tviCurrent);
	}
	
	// recurse down to children
	if (hNextOld = TreeView_GetChild(hwndTreeView, hOld)) {
		hNextNew=TreeView_GetChild(hwndTreeViewNew, hNew);
		Expand(hwndTreeView, hwndTreeViewNew, hNextOld, hNextNew);
	} 
	
	// and siblings
	if (hNextOld = TreeView_GetNextSibling(hwndTreeView, hOld)) {
		hNextNew = TreeView_GetNextSibling(hwndTreeViewNew, hNew);
		Expand(hwndTreeView, hwndTreeViewNew, hNextOld, hNextNew);
		hNew=hNextNew; hOld=hNextOld;
	}
	return;
}


//----------------------------------------------------------------------
// TV_RemoveItems
//	Removes all items in a treeview, and 
//	frees up memory pointed to by (TCHAR *) lParam
//	Used to clear the tree-view

void TV_RemoveItems(
		HWND hwndTreeView, 
		HTREEITEM hCurrent
		) {

	// make sure the item exists
	if (hCurrent) {
		HTREEITEM	hNext=NULL;

		TV_ITEM tviCurr;
		tviCurr.hItem = hCurrent;
		tviCurr.mask = TVIF_PARAM;

		TreeView_GetItem(hwndTreeView, &tviCurr);
		// if lParam exists, free up memory pointed to by it
		if (tviCurr.lParam)
			delete [] (TCHAR *) tviCurr.lParam;

		// find child
		if (hNext=TreeView_GetChild(hwndTreeView, hCurrent))
			TV_RemoveItems(hwndTreeView, hNext) ;
 
		// find next sibling
		if (hNext = TreeView_GetNextSibling(hwndTreeView, hCurrent)) 
			TV_RemoveItems(hwndTreeView, hNext);

		// remove the item
		if (hCurrent)
			TreeView_DeleteItem(hwndTreeView, hCurrent);

	}
}


//----------------------------------------------------------------------
// CheckComponentStatus
//	Returns the installed state of a component
//	Depending on the (global) flag g_modeCurrent, the component status
//	is determined either by just the key file (g_modeCurrent != MODE_DIAGNOSTIC)
//	or the status of all the files of the component (g_modeCurrent == MODE_DIAGNOSTIC);

INSTALLSTATE CheckComponentStatus (
		LPCTSTR	szProductCode,
		LPTSTR	szComponentId,
		LPTSTR	szCompPath		= NULL,		// optional buffer to get keyfile path
		DWORD	*cchPath		= NULL,		// size of szCompPath
		DWORD	cchStatus		= 0,		// size of Status string
		LPTSTR	szStatusString	= NULL // optional buffer to get component status desc
		) {

	BOOL	fOkay						= TRUE;
	TCHAR	szComponentPath[MAX_PATH+1]	= TEXT("");
	DWORD	cchCount					= MAX_PATH+1;

	// get the component status
	INSTALLSTATE iResult = MSI::MsivGetComponentPath(szProductCode, szComponentId, szComponentPath, &cchCount);

	// fill the optional buffers
	if (szStatusString)
		FillInText(szStatusString, cchStatus, iResult);
	if (szCompPath) 
	{
		lstrcpyn(szCompPath, szComponentPath, *cchPath);
		*cchPath = lstrlen(szCompPath);
	}

	// if key-file is broken, return now
	if (iResult != INSTALLSTATE_LOCAL && iResult != INSTALLSTATE_SOURCE)
		return iResult;

	// if key-file is fine, check other files if we are in diagnostic mode
	if (g_modeCurrent == MODE_DIAGNOSTIC) {
			
		WIN32_FIND_DATA	fdFileData;
		UINT	iCount=0;
		TCHAR	szFileTitle[MAX_PATH+1];
		TCHAR	szFileLocation[MAX_PATH+1];
		TCHAR	szBasePath[MAX_PATH+1];
		TCHAR	szFileName[MAX_PATH+1];
		TCHAR	szFileSize[30];
		TCHAR	szActualSize[30];

		if (szComponentPath)
			FindBasePath(szComponentPath, szBasePath);
		else
			lstrcpy(szBasePath, g_szNullString);

		// enumerate all the files of the component
		cchCount=MAX_PATH+1;
		while (fOkay && (ERROR_SUCCESS == MsivEnumFilesFromComponent(szComponentId, iCount++, szFileTitle, &cchCount)))
		{
			// if a profile is in use, read in info directly from it
			if (g_iDataSource == DS_PROFILE) 
			{
				TCHAR	szStatus[10];
				cchCount=10;

				// get the status of the file
				MsivGetFileInfo(szProductCode, szComponentId, szFileTitle,  FILEPROPERTY_STATUS, szStatus, &cchCount);
				if (lstrcmp(szStatus, FILESTATUS_OKAY))
					fOkay=FALSE;

				if (fOkay) 
				{
					// check the file sizes; if expected and actual sizes are different, component is broken
					cchCount=MAX_PATH+1;
					MsivGetFileInfo(szProductCode, szComponentId, szFileTitle, FILEPROPERTY_SIZE, szFileSize, &cchCount);
					MsivGetFileInfo(szProductCode, szComponentId, szFileTitle, FILEPROPERTY_ACTUALSIZE, szActualSize, &cchCount);
					if (lstrcmp(szFileSize, szActualSize))
						fOkay=FALSE;
				}
			} 
			else 
			{				// a database or the registry is in use, 
				// to get the file status, try finding the file and comparing it's size

				// get the file path
				lstrcpy(szFileLocation, szBasePath);
				cchCount=MAX_PATH+1;
				MsivGetFileInfo(szProductCode, szComponentId, szFileTitle, FILEPROPERTY_NAME, szFileName, &cchCount);
				lstrcat(szFileLocation, szFileName);


				// try finding the file; if file is not found component is broken
				if (FindFirstFile(szFileLocation, &fdFileData) == INVALID_HANDLE_VALUE)
					fOkay=FALSE;

				if (fOkay) 
				{
					// check the sizes; if expected and actual sizes are different, component is broken
					cchCount=MAX_PATH+1;
					MsivGetFileInfo(szProductCode, szComponentId, szFileTitle, FILEPROPERTY_SIZE, szFileSize, &cchCount);
					wsprintf(szActualSize, TEXT("%d"), (fdFileData.nFileSizeHigh * MAXDWORD) + fdFileData.nFileSizeLow);
					if (lstrcmp(szFileSize, szActualSize))
						fOkay=FALSE;
				}
			}
			cchCount=MAX_PATH+1;
		}

		if (!fOkay)
			if (szStatusString) 
				LoadString(g_hResourceInst, IDS_IS_SOMEFILESMISSING, szStatusString, cchStatus);
	}

	if (fOkay)
		return iResult;
	else
		return INSTALLSTATE_BROKEN;
			

}


//----------------------------------------------------------------------
// SetFeatureIcons
//	Sets the icons of each feature based on its state
//--todo!e!!!
BOOL SetFeatureIcons(
		HWND		hwndTreeView,
		HTREEITEM	hCurrent,
		LPTSTR		szProductID,
		BOOL		fProduct	= FALSE		// should be true if hCurrent points 
											// to a product (and not a feature)
		) {

	HTREEITEM	hNext = NULL;
	BOOL		fOkay = TRUE;

	TCHAR szFeature[MAX_FEATURE_CHARS+1];

	TV_ITEM tviCurr;
	tviCurr.hItem	= hCurrent;
	tviCurr.mask	= TVIF_PARAM;

	// get the item
	TreeView_GetItem(hwndTreeView, &tviCurr);
	if (tviCurr.lParam)
		lstrcpy(szFeature, (TCHAR *) tviCurr.lParam);
	else
		lstrcpy(szFeature, g_szNullString);

		INSTALLSTATE isFeature;

	// query state
	if (!fProduct) 
	{
		if ((isFeature = MsivQueryFeatureState(szProductID, szFeature)) > INSTALLSTATE_ABSENT)
		{
			int		iCompCount = 0;
			TCHAR	szComponentId[MAX_GUID+1];

			// a feature's state is determined by all its components
			while ((ERROR_SUCCESS == MSISPYU::MsivEnumComponentsFromFeature(szProductID, szFeature, 
				iCompCount++, szComponentId, NULL, NULL)) && fOkay) 
			{
				INSTALLSTATE isComponent = CheckComponentStatus(szProductID, szComponentId);
				if (   (isComponent != INSTALLSTATE_LOCAL) 
					&& (isComponent != INSTALLSTATE_SOURCE)
					&& (isComponent != INSTALLSTATE_NOTUSED))
					fOkay = FALSE;
			}
		}
	}

	// find child (recurse)
	if (hNext=TreeView_GetChild(hwndTreeView, hCurrent)) {
		if (!SetFeatureIcons(hwndTreeView, hNext, szProductID))
			fOkay = FALSE;
	} 

	// set the icon based on the state
	if (!fProduct) {

		fOkay = fOkay && ((isFeature > INSTALLSTATE_BROKEN) || (isFeature != INSTALLSTATE_NOTUSED));

		if (INSTALLSTATE_ABSENT == isFeature) {
			tviCurr.iImage			= TVICON_ABSENTFEATURE;
			tviCurr.iSelectedImage	= TVICON_ABSENTFEATURE;
		} else if (!fOkay) {
			tviCurr.iImage			= TVICON_BROKENFEATURE;
			tviCurr.iSelectedImage	= TVICON_BROKENFEATURE;
		}
		else {
			tviCurr.iImage			= TVICON_FEATURE;
			tviCurr.iSelectedImage	= TVICON_FEATURE;
		}

		tviCurr.mask			= TVIF_IMAGE|TVIF_SELECTEDIMAGE;
		TreeView_SetItem(hwndTreeView, &tviCurr);

		// find next item (recurse)
		if (hNext = TreeView_GetNextSibling(hwndTreeView, hCurrent)) {
			if (!SetFeatureIcons(hwndTreeView, hNext, szProductID))
				fOkay = FALSE;
			hCurrent=hNext;
		}
	}

	return fOkay;
}


//----------------------------------------------------------------------
// ListSubFeatures
//	Recursively adds all the sub-features of a feature to a tree view
//--todo!e!!!

#ifndef TRYEFFICIENT
void ListSubFeatures(
		LPTSTR		szProductID, 
		LPTSTR		szParentF,
		HTREEITEM	hParent,
		HWND		hwndTreeView
		) {

	int iFeatureCount=0;
	TCHAR szFeature[MAX_FEATURE_CHARS+1];
	TCHAR szParent[MAX_FEATURE_CHARS+1];

	// enumerate all the features
	while (MsivEnumFeatures(szProductID, iFeatureCount++, szFeature, szParent)
		== ERROR_SUCCESS) { 

		// and add the ones that have a specified parent
		if ((!lstrcmp(szParent,szParentF))) {// && (MsivQueryFeatureState(szProductID, szFeature) != INSTALLSTATE_ABSENT)) {
			TCHAR *pszFeatureCode = new TCHAR[MAX_FEATURE_CHARS+1];
			assert (pszFeatureCode != NULL);

			if (szFeature)
				lstrcpy(pszFeatureCode, szFeature);
			else
				lstrcpy(pszFeatureCode, g_szNullString);

			// get the required info
			TCHAR	szTitle[MAX_FEATURE_CHARS+1];
			DWORD	cchCount = MAX_FEATURE_CHARS+1;
			if ((g_modeCurrent==MODE_DEGRADED) || (MsivGetFeatureInfo(szProductID, szFeature, FEATUREPROPERTY_NAME, szTitle, &cchCount)
				!= ERROR_SUCCESS))
				lstrcpy(szTitle, szFeature);

			if (MODE_DIAGNOSTIC == h_modeCurrent)
				wsprintf(szTitle, TEXT("%s (%d)"), szTitle, MsivQueryFeatureState(szProductID, szFeature));

			// and add the item
			TV_ITEM sTVitem;
			sTVitem.pszText			= szTitle;
			sTVitem.cchTextMax		= (MAX_FEATURE_TITLE_CHARS+1);
			sTVitem.iImage			= TVICON_FEATURE;
			sTVitem.iSelectedImage	= TVICON_FEATURE;
			sTVitem.lParam			= (LPARAM) pszFeatureCode;
			sTVitem.mask			= TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;

			TV_INSERTSTRUCT hinsTV;
			hinsTV.hParent=hParent;
			hinsTV.hInsertAfter=TVI_SORT;
			hinsTV.item=sTVitem;

			HTREEITEM hChild;
			hChild = TreeView_InsertItem(hwndTreeView, &hinsTV);

			// recursively add the children of the newly added item
			ListSubFeatures(szProductID, szFeature, hChild, hwndTreeView);
		}
	}
}

#else

void ListSubFeatures(
		LPTSTR		szProductID,
		FeatureTable *ft,
		LPTSTR		szParentF,
		HTREEITEM	hParent,
		HWND		hwndTreeView
		) {



	TCHAR	szChild[MAX_FEATURE_CHARS+1];
	DWORD	cbChild = MAX_FEATURE_CHARS + 1;

	while (ERROR_SUCCESS == ft->GetAndRemoveNextChild(szParentF, lstrlen(szParentF)+1, szChild, &cbChild)) {
		// and add the ones that have a specified parent
		TCHAR *pszFeatureCode = new TCHAR[MAX_FEATURE_CHARS+1];
		assert (pszFeatureCode != NULL);

		if (szChild)
				lstrcpy(pszFeatureCode, szChild);
			else
				lstrcpy(pszFeatureCode, g_szNullString);

			// get the required info
			TCHAR	szTitle[MAX_FEATURE_CHARS+1];
			DWORD	cchCount = MAX_FEATURE_CHARS+1;
			if ((g_modeCurrent==MODE_DEGRADED) || (MsivGetFeatureInfo(szProductID, szChild, FEATUREPROPERTY_NAME, szTitle, &cchCount)
				!= ERROR_SUCCESS))
				lstrcpy(szTitle, szChild);

			if (MODE_DIAGNOSTIC == g_modeCurrent)
				wsprintf(szTitle, TEXT("%s (%d)"), szTitle, MsivQueryFeatureState(szProductID, szChild));

			// and add the item
			TV_ITEM sTVitem;
			sTVitem.pszText			= szTitle;
			sTVitem.cchTextMax		= (MAX_FEATURE_TITLE_CHARS+1);
			sTVitem.iImage			= TVICON_FEATURE;
			sTVitem.iSelectedImage	= TVICON_FEATURE;
			sTVitem.lParam			= (LPARAM) pszFeatureCode;
			sTVitem.mask			= TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;

			TV_INSERTSTRUCT hinsTV;
			hinsTV.hParent=hParent;
			hinsTV.hInsertAfter=TVI_SORT;
			hinsTV.item=sTVitem;

			HTREEITEM hChild;
			hChild = TreeView_InsertItem(hwndTreeView, &hinsTV);

			// recursively add the children of the newly added item
			ListSubFeatures(szProductID, ft, szChild, hChild, hwndTreeView);

			cbChild = MAX_FEATURE_CHARS+1;
		}
}


#endif //  ifndef EFFICIENT



//----------------------------------------------------------------------
// GetRootText
//	Fills the buffer with the type and name of the file currently being used
//	If the registry is being used, the buffer will just contain IDS_ROOT
//	from the string table, else it will be of the form 
//	"DATABASE: <FileName>" or "SAVED STATE: <FileName>"

void GetRootText(
		LPTSTR	lpBuffer,
		DWORD	nBufferMax
		) {

	TCHAR	szDataSource[MAX_HEADER+1];
	TCHAR	szFileName[MAX_PATH+1];
	DWORD	cbFileName = MAX_PATH+1;

	switch (g_iDataSource) {

	case DS_REGISTRY:
		LoadString(g_hResourceInst, IDS_TV_ROOT, lpBuffer, nBufferMax);
		return;

	case DS_INSTALLEDDB:
	case DS_UNINSTALLEDDB:
		LoadString(g_hResourceInst, IDS_MSI_PACKAGE, szDataSource, MAX_HEADER+1);
		MsivGetDatabaseName(szFileName, &cbFileName);
		break;

	case DS_PROFILE:
		LoadString(g_hResourceInst, IDS_SAVED_STATE, szDataSource, MAX_HEADER+1);
		MsivGetProfileName(szFileName, &cbFileName);
		break;

	default:
		wsprintf(lpBuffer, g_szNullString);
		return;
	}


	// make sure string will fit in the buffer
	if ((lstrlen(szDataSource) + cbFileName) < nBufferMax)	// will entire string fit?
		wsprintf(lpBuffer, szDataSource, szFileName);
	else if ((DWORD)lstrlen(szDataSource) < nBufferMax)	// will just data source ("database"/"profile") fit?
		wsprintf(lpBuffer, szDataSource, g_szNullString);
	else												// buffer's too small, just put in empty string
		wsprintf(lpBuffer, g_szNullString);

}


//----------------------------------------------------------------------
// ListProducts
//	Lists the products, features and sub-features in heirarchical fashion 
//	in the treeview. The list of products is obtained from MsivEnumProducts
//	For each of the products and features, the icon displayed in front of it
//	depends on its state (okay/broken)

void ListProducts(
		HWND	hwndTreeView,		// original window
		HWND	hwndTreeViewNew,	// window in which new info will be displayed
		BOOL	fRefresh,			// is a refresh operation in progress?
		LPTSTR	szFeatureName,		// if so, feature currently selected
		BOOL	*fRefinProg
		) {


	int		iProdCount=0;
	TCHAR	szProductCode[MAX_GUID+1];

	TCHAR	szFeature[MAX_FEATURE_CHARS+1];
	if (szFeatureName)
		lstrcpy(szFeature, szFeatureName);
	else
		lstrcpy(szFeature, g_szNullString);

	// clear out the old tree
	HTREEITEM	hOldRoot;
	hOldRoot = TreeView_GetRoot(hwndTreeView);
	if (fRefinProg)
		*fRefinProg = TRUE;
	TV_RemoveItems(hwndTreeViewNew, TreeView_GetRoot(hwndTreeViewNew));
	if (fRefinProg)
		*fRefinProg = FALSE;

	// create new tree root
	TCHAR	szTVRoot[MAX_HEADER+1];
	GetRootText(szTVRoot, MAX_HEADER+1);

	TV_ITEM sTVitem;
	sTVitem.pszText			= szTVRoot;
	sTVitem.cchTextMax		= MAX_HEADER+1;
	sTVitem.iImage			= TVICON_ROOT;
	sTVitem.iSelectedImage	= TVICON_ROOT;
	sTVitem.mask			= TVIF_TEXT| TVIF_IMAGE | TVIF_SELECTEDIMAGE;
	
	TV_INSERTSTRUCT hinsTV;
	hinsTV.hParent		= NULL;
	hinsTV.hInsertAfter	= TVI_SORT;
	hinsTV.item			= sTVitem;

	// insert new root
	HTREEITEM hRoot = TreeView_InsertItem(hwndTreeViewNew, &hinsTV);

	// go thru each product, listing its features
	while ((MSI::MsivEnumProducts(iProdCount++, szProductCode)) == ERROR_SUCCESS) {

		TCHAR *pszProduct = new TCHAR[MAX_PRODUCT_CHARS+1];
		if (szProductCode)
			lstrcpy(pszProduct, szProductCode);
		else 
			lstrcpy(pszProduct, g_szNullString);


		TCHAR	szProductName[MAX_PRODUCT_CHARS+1];
		DWORD	cchCount=MAX_PRODUCT_CHARS+1;

		MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, szProductName, &cchCount);

		//		wsprintf(szProductName, TEXT("%s (%d)"), szProductName, MsivQueryProductState(szProductCode));
		// add this product
		TV_ITEM sTVitem;
		sTVitem.pszText			= szProductName;
		sTVitem.cchTextMax		= MAX_PRODUCT_CHARS+1;
		sTVitem.iImage			= TVICON_PRODUCT;
		sTVitem.iSelectedImage	= TVICON_PRODUCT;
		sTVitem.lParam			= (LPARAM) pszProduct;
		sTVitem.mask			= TVIF_TEXT| TVIF_IMAGE | TVIF_SELECTEDIMAGE |TVIF_PARAM;

		TV_INSERTSTRUCT hinsTV;
		hinsTV.hParent			= hRoot;
		hinsTV.hInsertAfter		= TVI_SORT;
		hinsTV.item				= sTVitem;

 		HTREEITEM hParent;
		hParent = TreeView_InsertItem(hwndTreeViewNew, &hinsTV);


#ifdef TRYEFFICIENT
	int iFeatureCount=0;
	TCHAR szFeature[MAX_FEATURE_CHARS+1];
	TCHAR szParent[MAX_FEATURE_CHARS+1];

	FeatureTable ft;
	// enumerate all the features
	while (MsivEnumFeatures(szProductCode, iFeatureCount++, szFeature, szParent)
		== ERROR_SUCCESS)
		ft.AddElement(szParent, lstrlen(szParent)+1, szFeature, lstrlen(szFeature)+1);
	

	ListSubFeatures(szProductCode, &ft, g_szNullString, hParent, hwndTreeViewNew);
#else



		// list all the features of the product
		ListSubFeatures(szProductCode, g_szNullString, hParent, hwndTreeViewNew);

#endif
		
		// and set the icons to reflect the state
		if (!SetFeatureIcons(hwndTreeViewNew, hParent, szProductCode, TRUE)) {
			sTVitem.hItem			= hParent;
			sTVitem.iImage			= TVICON_BROKENPRODUCT;
			sTVitem.iSelectedImage	= TVICON_BROKENPRODUCT;
			sTVitem.mask			= TVIF_IMAGE|TVIF_SELECTEDIMAGE;
			TreeView_SetItem(hwndTreeViewNew, &sTVitem);
		}
		else {
			sTVitem.hItem			= hParent;
			sTVitem.iImage			= TVICON_PRODUCT;
			sTVitem.iSelectedImage	= TVICON_PRODUCT;
			sTVitem.mask			= TVIF_IMAGE|TVIF_SELECTEDIMAGE;
			TreeView_SetItem(hwndTreeViewNew, &sTVitem);
		}

	}

	// if a refresh is in progress, restore the state of each tree-view item
	if (fRefresh) {
		Expand(hwndTreeView, hwndTreeViewNew, hOldRoot, hRoot);
	}

	// bring the new window to the foreground
	ShowWindow(hwndTreeView, SW_HIDE);
	ShowWindow(hwndTreeViewNew, SW_SHOW);
}


//----------------------------------------------------------------------
// TV_NotifyHandler
//	Handles the WM_NOTIFY messages from the tree-view

LRESULT TV_NotifyHandler(
		LPARAM	lParam,
		HWND		hwndTreeView,
		LPTSTR		szProductCode,
		LPTSTR		szFeatureCode,
		LPTSTR		szFeatureName,
		ITEMTYPE	*iSelType
		) {

	NM_TREEVIEW * pnmtv = (NM_TREEVIEW *) lParam;
	HTREEITEM hItem;

	switch (pnmtv->hdr.code) {

	case TVN_SELCHANGING:
	// selection has changed, get the name of the new item selected
	// needed to update the components of the feature in the list view

		TV_ITEM tvi;
		TV_ITEM tviNew;
		tviNew			= pnmtv->itemNew;
		hItem			= tviNew.hItem;

		//	get the new item
		tvi.hItem		= hItem;
		tvi.mask		= TVIF_PARAM | TVIF_IMAGE | TVIF_TEXT;
		tvi.pszText		= szFeatureName;
		tvi.cchTextMax	= MAX_FEATURE_CHARS+1;
		TreeView_GetItem(hwndTreeView, &tvi);

		if (tvi.lParam) 
			lstrcpy(szFeatureCode, (TCHAR *) tvi.lParam);
		else 
			lstrcpy(szFeatureCode, g_szNullString);


		// determine what type of item is selected-
		//	product, feature or root
		HTREEITEM hItem1;
		HTREEITEM hItem2;
		HTREEITEM hItem3;
		HTREEITEM hItem4;

		hItem1 = tviNew.hItem;
		hItem2 = NULL;
		hItem3 = NULL;
		hItem4 = NULL;

		// recursively go up the tree, and see when we hit the root
		//	if we're already at the root, seltype is ROOT
		//	if we hit the root after going up one level, seltype is PRODUCT
		//	if we go up more than one level before hitting the root, seltype is FEATURE

		while (hItem1 != NULL) {
			hItem4 = hItem3;
			hItem3 = hItem2;
			hItem2 = hItem1;
			hItem1 = TreeView_GetParent(hwndTreeView, hItem1);
		}

		// when we finally hit the root, 
		//	hItem3 points to the product (hItem1 is NULL, hItem2 is ROOT, hItem3 is PRODUCT)
		//	so we can read in the product-code from the lParam of hItem3 into szProductCode
		//	if we were already at the root, hItem3 is NULL, hence szProductCode should be empty


		TV_ITEM		tvi2;

		if (hItem3) {
			tvi2.hItem	= hItem3;
			tvi2.mask	= TVIF_IMAGE | TVIF_PARAM;
			TreeView_GetItem(hwndTreeView, &tvi2);
		}
		else
			tvi2.lParam = NULL;

		if (tvi2.lParam)
			lstrcpy (szProductCode, (TCHAR *) tvi2.lParam);
		else
			lstrcpy(szProductCode, g_szNullString);

		// determine what type of item is selected, as described above
		if (hItem3) 
			if (hItem4)
				*iSelType = ITEMTYPE_FEATURE;
			else
				*iSelType = ITEMTYPE_PRODUCT;
		else
			*iSelType = ITEMTYPE_ROOT;
		
		// make selected product bold (parent product, if a feature is selected;
		//	none, if root is selected)
		if (MODE_DIAGNOSTIC == g_modeCurrent) 
		{
			ClearBold(hwndTreeView);
			MakeBold(hwndTreeView, szProductCode);
		}
		return 1;
		break;

	default:
		break;
	}

	return 0L;
}


//----------------------------------------------------------------------
// FileCompareProc
//	Callback to compare specified columns of the component-list window
//	Called when user clicks on the column header of the list to sort by those columns
//	lParamSort contains information about the columns to compare-
//	if lParamSort >100, column to sort = lParamSort-100, DESCENDING
//	if lParamSort <100, column to sort = lParamSort, ASCENDING

int CALLBACK ListViewCompareProc(
		LPARAM lParam1, 
		LPARAM lParam2, 
		LPARAM lParamSort
		) {

	ComponentInfoStruct *pInfo1	= (ComponentInfoStruct *)lParam1;
	ComponentInfoStruct *pInfo2	= (ComponentInfoStruct *)lParam2;
	LPTSTR lpStr1, lpStr2;
	int iResult				= 0;
	BOOL fRev				= FALSE;

	// check sort order- ascending (lParamSort < 100) or descending (lParamSort >= 100)
	if (lParamSort >=100) {
		fRev=TRUE;
		lParamSort -=100;
	}


	if (pInfo1 && pInfo2) {
		switch (lParamSort) {
		case 0:				// sort by component names
			lpStr1 = pInfo1->szComponentName;
			lpStr2 = pInfo2->szComponentName;
			iResult = lstrcmpi(lpStr1, lpStr2);
			break;

		case 1:				// sort by component status
			lpStr1 = pInfo1->szComponentStatus;
			lpStr2 = pInfo2->szComponentStatus;
			iResult = lstrcmpi(lpStr1, lpStr2);
			break;

		case 2:				// sort by component locations
			lpStr1 = pInfo1->szComponentPath;
			lpStr2 = pInfo2->szComponentPath;
			iResult = lstrcmpi(lpStr1, lpStr2);
			break;

		case 3:				// sprt by component GUID
			lpStr1 = pInfo1->szComponentId;
			lpStr2 = pInfo2->szComponentId;
			iResult = lstrcmpi(lpStr1, lpStr2);
			break;

		default:
			iResult = 0;
			break;

		}

	}

	// if sort is in descending order, invert iResult
	if (fRev)
		iResult=0-iResult;

	return(iResult);
}


//----------------------------------------------------------------------
// LV_NotifyHandler
//	Handles the WM_NOTIFY messages from the list-view

LRESULT LV_NotifyHandler(
		HWND	hwndTreeView,
		HWND	hwndListView,
		LPARAM	lParam,
		int		*iSelectedItem
		) {

	LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
	NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
	static int iCurrentSort=0;

	switch(pLvdi->hdr.code) {
	case LVN_ITEMCHANGED:
		// selection has changed, get new item selected
		if  (pNm->uNewState & LVIS_SELECTED)
					*iSelectedItem = pNm->iItem;

		TCHAR	szComponentId[MAX_GUID+1];
		TCHAR	szProductCode[MAX_GUID+1];
		UINT	iCount;

		// clear out the bolded products, 
		ClearBold(hwndTreeView);

		// and display all client products of newly selected component in bold
		iCount=0;
		ListView_GetItemText(hwndListView, *iSelectedItem, 3, szComponentId, MAX_GUID+1);
		while (MsivEnumClients(szComponentId, iCount++, szProductCode) == ERROR_SUCCESS)
			MakeBold (hwndTreeView, szProductCode);

		return 1;
		break;

	case LVN_COLUMNCLICK:
		// user clicked on the column header- sort by that column
		UINT	iTemp;
		// is it already sorted by this column? if so, reverse sort order
		if ((iCurrentSort==pNm->iSubItem) && (iCurrentSort < 100))
			iTemp=100;
		else
			iTemp=0;
		iCurrentSort=pNm->iSubItem + iTemp;

		// call the sort function
		ListView_SortItems( pNm->hdr.hwndFrom,
							ListViewCompareProc,
							(LPARAM)((iTemp)+(pNm->iSubItem)));
		break;

	default:
			break;
	}
	return 0L;

}


//----------------------------------------------------------------------
// ClearList
//	Removes all items in the listview, and 
//	frees up memory pointed to by (ComponentInfoStruct *) lParam
//	Used to clear the list-view

void ClearList(HWND hwndList) {

	int iCount = 0;
	LV_ITEM	lvItem;
	lvItem.iItem = iCount++;
	lvItem.iSubItem=0;
	lvItem.mask=LVIF_PARAM;

	// get each row in the list
	while (ListView_GetItem(hwndList, &lvItem)) {

		// if lParam exists, typecast and delete memory it points to
		if (lvItem.lParam)
			delete (ComponentInfoStruct *) lvItem.lParam;

		// prepare to fetch next row in list
		lvItem.iItem = iCount++;
		lvItem.iSubItem=0;
		lvItem.mask=LVIF_PARAM;
	}

	ListView_DeleteAllItems(hwndList);
}


//----------------------------------------------------------------------
// UpdateListView
//	displays components of the given feature (szFeatureName) in the list-view window

BOOL UpdateListView(
		HWND	hwndListView,
		LPCTSTR	szProduct,
		LPCTSTR	szFeatureName,
		int		*iNumCmps,
		BOOL	fProduct
		) {

	int		iCompCount = 0;
	int		iListRowCount = 0;
	TCHAR	szComponentId[MAX_GUID+1];
	// clear the list
	ClearList(hwndListView);


	switch (g_spyGlobalData.itTreeViewSelected) 
	{
	case ITEMTYPE_ROOT:	
		iListRowCount = -1;
		break;

	case ITEMTYPE_PRODUCT:
		{
			// list components of the product
			while (ERROR_SUCCESS == MSI::MsivEnumComponentsFromProduct(szProduct, iCompCount++, szComponentId))
			{
				if (INSTALLSTATE_NOTUSED != MsivGetComponentPath(szProduct, szComponentId, NULL, NULL)) 
				{
					TCHAR	szComponentName[MAX_COMPONENT_CHARS+1];
					DWORD	cchComponentName = MAX_COMPONENT_CHARS+1;
					MsivGetComponentName(szComponentId, szComponentName, &cchComponentName);


					LV_ITEM	lvItem;
					TCHAR szComponentStatus[MAX_STATUS_CHARS+1];
					TCHAR szComponentPath[MAX_PATH+1];
					DWORD cchComponentPath = MAX_PATH+1;

					switch (CheckComponentStatus(szProduct, szComponentId, szComponentPath, 
						&cchComponentPath, MAX_STATUS_CHARS+1, szComponentStatus))
					{
						case INSTALLSTATE_LOCAL:		// fall-thru
						case INSTALLSTATE_SOURCE:		// fall-thru
						case INSTALLSTATE_ADVERTISED:	
							lvItem.iImage=LVICON_COMPONENT;
							break;
						case INSTALLSTATE_ABSENT:
							lvItem.iImage=LVICON_ABSENTCOMPONENT;
							break;
						default:
							lvItem.iImage=LVICON_BROKENCOMPONENT;
							break;
					}

					// create new lvitem for the component
					lvItem.iItem		= iCompCount-1;
					lvItem.iSubItem		= 0;
					lvItem.pszText		= szComponentName;
					lvItem.cchTextMax	= lstrlen(szComponentName);

					// fill up the ComponentInfoStruct pointed to by lParam
					ComponentInfoStruct *pCompInfo =  new ComponentInfoStruct;
					lstrcpy(pCompInfo->szProductCode, szProduct);
					lstrcpy(pCompInfo->szComponentId, szComponentId);
					lstrcpy(pCompInfo->szComponentName, szComponentName);
					lstrcpy(pCompInfo->szComponentStatus, szComponentStatus);
					lstrcpy(pCompInfo->szComponentPath, szComponentPath);

					lvItem.lParam	= (LPARAM) pCompInfo;
					lvItem.mask		= LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;

					iListRowCount++;
					// add the component and display its properties
					ListView_InsertItem(hwndListView, &lvItem);
					ListView_SetItemText(hwndListView, iListRowCount-1, 1, szComponentStatus);
					ListView_SetItemText(hwndListView, iListRowCount-1, 2, szComponentPath);
					ListView_SetItemText(hwndListView, iListRowCount-1, 3, szComponentId);
				}
			}
			break;
		}

	case ITEMTYPE_FEATURE:
		{
		while (ERROR_SUCCESS == MSI::MsivEnumComponentsFromFeature(szProduct, szFeatureName, iCompCount++, szComponentId, NULL, NULL))
		{
			if (INSTALLSTATE_NOTUSED != MsivGetComponentPath(szProduct, szComponentId, NULL, NULL)) 
			{

				TCHAR	szComponentName[MAX_COMPONENT_CHARS+1];
				DWORD	cchComponentName = MAX_COMPONENT_CHARS+1;
				MsivGetComponentName(szComponentId, szComponentName, &cchComponentName);

				// create new lvitem for the component
				LV_ITEM	lvItem;
				lvItem.iItem		= iCompCount-1;
				lvItem.iSubItem		= 0;
				lvItem.pszText		= szComponentName;
				lvItem.cchTextMax	= lstrlen(szComponentName);
				lvItem.iImage		= LVICON_COMPONENT;

				TCHAR	szComponentStatus[MAX_STATUS_CHARS+1];
				TCHAR	szComponentPath[MAX_PATH+1];
				DWORD	cchComponentPath = MAX_PATH+1;

				switch (CheckComponentStatus(szProduct, szComponentId, szComponentPath, 
					&cchComponentPath, MAX_STATUS_CHARS+1, szComponentStatus))
				{
					case INSTALLSTATE_LOCAL:
					case INSTALLSTATE_SOURCE:
						lvItem.iImage=LVICON_COMPONENT;
						break;
					case INSTALLSTATE_ABSENT:
						lvItem.iImage=LVICON_ABSENTCOMPONENT;
						break;
					default:
						lvItem.iImage=LVICON_BROKENCOMPONENT;
						break;
				}

				// fill up the ComponentInfoStruct pointed to by lParam
				ComponentInfoStruct *pCompInfo =  new ComponentInfoStruct;
				lstrcpy(pCompInfo->szProductCode, szProduct);
				lstrcpy(pCompInfo->szComponentId, szComponentId);
				lstrcpy(pCompInfo->szComponentName, szComponentName);
				lstrcpy(pCompInfo->szComponentStatus, szComponentStatus);
				lstrcpy(pCompInfo->szComponentPath, szComponentPath);

				lvItem.lParam	= (LPARAM) pCompInfo;
				lvItem.mask		= LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;

				iListRowCount++;
				// add the component and display its properties
				ListView_InsertItem(hwndListView, &lvItem);
				ListView_SetItemText(hwndListView, iListRowCount-1, 1, szComponentStatus);
				ListView_SetItemText(hwndListView, iListRowCount-1, 2, szComponentPath);
				ListView_SetItemText(hwndListView, iListRowCount-1, 3, szComponentId);
			}

		}
	}
		}
	*iNumCmps = iListRowCount;
	return TRUE;
}


// zeros out a string ...
void ZeroOut(
		LPTSTR szString, 
		DWORD	cchCount) {
#ifdef UNICODE
	memset(szString, 0, cchCount*2);
#else	//ANSI
	memset(szString, 0, cchCount);
#endif	// UNICODE


//	for (DWORD iCount = 0; iCount< cchCount; iCount++)
//		szString[iCount]= '\0';

} 



//----------------------------------------------------------------------
// HandleOpen
//	Opens a database file after asking user for the file name using a 
//	win32 common dialogue box. Returns ERROR_SUCCESS if successful, ERROR_UNKNOWN if
//	user hit cancel, or the error that occured while trying to open the file
//	if file is invalid

UINT HandleOpen(
		HWND		hwndParent,
		HINSTANCE	hInst
		) {

	TCHAR	szFile[MAX_PATH+1];
	TCHAR	szFileTitle[MAX_PATH+1];


	TCHAR	szFilter[MAX_FILTER+1];
	ZeroOut(szFilter, MAX_FILTER+1);
	LoadString(g_hResourceInst, IDS_MSI_OPEN_FILTER, szFilter, MAX_FILTER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_MSI_OPEN_CAPTION, szCaption, MAX_HEADER+1);

	TCHAR	szExtn[MAX_EXT+1];
	LoadString(g_hResourceInst, IDS_MSI_OPEN_DEFAULT_EXTN, szExtn, MAX_EXT+1);

	lstrcpy(szFile, g_szNullString);
	lstrcpy(szFileTitle, g_szNullString);

	// struct to be used with the Win32 Common Dialogue Boxes
	OPENFILENAME sOpenFileName;
	sOpenFileName.lStructSize = sizeof(OPENFILENAME);
	sOpenFileName.hwndOwner = hwndParent;
	sOpenFileName.hInstance = (HINSTANCE) hInst;
	sOpenFileName.lpstrFilter = szFilter;
	sOpenFileName.lpstrCustomFilter = (LPTSTR) NULL;
	sOpenFileName.nMaxCustFilter = 0L;
	sOpenFileName.nFilterIndex = 1L;
	sOpenFileName.lpstrFile = szFile;
	sOpenFileName.nMaxFile = sizeof(szFile);
	sOpenFileName.lpstrFileTitle= szFileTitle;
	sOpenFileName.nMaxFileTitle = sizeof(szFileTitle); 
	sOpenFileName.lpstrInitialDir = NULL;
	sOpenFileName.lpstrTitle = szCaption;
	sOpenFileName.Flags = OFN_FILEMUSTEXIST| OFN_HIDEREADONLY;
	sOpenFileName.nFileOffset = 0; 
	sOpenFileName.nFileExtension = 0; 
	sOpenFileName.lpstrDefExt=szExtn; 
	sOpenFileName.lCustData = 0;

	// Call the common dialogue box to ask user for filename
	UINT iResult = ERROR_UNKNOWN;
	if (GetOpenFileName(&sOpenFileName)) 
		// user hit okay- try openning the file
		if ((iResult=MsivOpenDatabase(sOpenFileName.lpstrFile))!=ERROR_SUCCESS) {
			// file user specified is not a valid database file

			TCHAR	szErrorCaption[MAX_HEADER+1];
			LoadString(g_hResourceInst, IDS_MSI_OPEN_ERROR_CAPTION, szErrorCaption, MAX_HEADER+1);

			TCHAR	szErrorMsg[MAX_MESSAGE+1];
			LoadString(g_hResourceInst, IDS_MSI_OPEN_ERROR_MESSAGE, szErrorMsg, MAX_MESSAGE+1);

			TCHAR	szErrorMsg2[MAX_MESSAGE+MAX_PATH+1];
			wsprintf(szErrorMsg2, szErrorMsg, sOpenFileName.lpstrFile);

			MessageBox(NULL, szErrorMsg2, szErrorCaption, MB_ICONSTOP | MB_OK);
		}
	
	return iResult;

}

//----------------------------------------------------------------------
// ChangeSBText (HINSTANCE, HWND, int)
//	Changes the text in the status bar to reflect the currently selected item.

VOID ChangeSBText(
		HWND			hwndStatus, 
		int				iNumComp, 
		LPTSTR			szFeatureName,
		INSTALLSTATE	iState,
		BOOL			fProduct) 
{

    TCHAR	szText[MAX_FEATURE_CHARS+MAX_HEADER+5];
	TCHAR	szLeftText[MAX_HEADER+1];
	TCHAR	szRightText[MAX_HEADER+1];

	// no product or feature selected
    if ((iNumComp == -1) || (!lstrcmp(szFeatureName, TEXT("")))) 
	{

		LoadString(g_hResourceInst, IDS_SB_NOTHING_SELECTED, szLeftText, MAX_HEADER+1);
		SendMessage(hwndStatus, SB_SETTEXT, 0, (LPARAM) szLeftText);
		
		LoadString(g_hResourceInst, IDS_SB_NO_COMPONENTS, szRightText, MAX_HEADER+1);
	    SendMessage(hwndStatus, SB_SETTEXT, 1, (LPARAM) szRightText);
	}
    else 
		if (iNumComp == 1) 
		{
			// feature has one component- singular
			LoadString(g_hResourceInst, IDS_SB_PF_SELECTED, szLeftText, MAX_HEADER+1);

			TCHAR	szStatusString[MAX_STATUS_CHARS+1];
			DWORD	cchStatus = MAX_STATUS_CHARS+1;
			FillInText(szStatusString, cchStatus, iState, fProduct?ITEMTYPE_PRODUCT:ITEMTYPE_FEATURE);

			wsprintf(szText, TEXT("%s (%s)"), szFeatureName, szStatusString); //szLeftText);
			SendMessage(hwndStatus, SB_SETTEXT, 0, (LPARAM) szText);

			LoadString(g_hResourceInst, IDS_SB_ONE_COMPONENT, szRightText, MAX_HEADER+1);
			SendMessage(hwndStatus, SB_SETTEXT, 1, (LPARAM) szRightText);
		}
		else 
		{
			// feature has many components- plural
			LoadString(g_hResourceInst, IDS_SB_PF_SELECTED, szLeftText, MAX_HEADER+1);

			TCHAR	szStatusString[MAX_STATUS_CHARS+1];
			DWORD	cchStatus = MAX_STATUS_CHARS+1;
			FillInText(szStatusString, cchStatus, iState, fProduct?ITEMTYPE_PRODUCT:ITEMTYPE_FEATURE);

			wsprintf(szText, TEXT("%s (%s)"), szFeatureName, szStatusString); //szLeftText);
		    SendMessage(hwndStatus, SB_SETTEXT, 0, (LPARAM) szText);

			TCHAR	szText2[MAX_FEATURE_CHARS+MAX_HEADER+5];
			LoadString(g_hResourceInst, IDS_SB_MANY_COMPONENTS, szText, MAX_HEADER+1);
		    wsprintf(szText2, szText, iNumComp);
		    SendMessage(hwndStatus, SB_SETTEXT, 1, (LPARAM) szText2) ;
		}

}

//----------------------------------------------------------------------
// ChangeSBText (HWND, LPCTSTR, LPCTSTR)
//	Displays given string in the status bar

VOID ChangeSBText(
		HWND	hwndStatus, 
		LPCTSTR	szNewText,
		LPCTSTR	szNewText2) 
{
	SendMessage(hwndStatus, SB_SETTEXT, 0, (LPARAM) szNewText);
	if (szNewText2)

		SendMessage(hwndStatus, SB_SETTEXT, 1, (LPARAM) szNewText2);
	else
		SendMessage(hwndStatus, SB_SETTEXT, 1, (LPARAM) g_szNullString);

} 


//----------------------------------------------------------------------
// ReinstallComponent
//	Reinstalls specified component by calling MsiProvideComponent
//	If a product is selected, all features using the component are reinstalled

BOOL ReinstallComponent(
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName,
		LPCTSTR	szComponentId,
		BOOL	fProduct)
{

	if (fProduct) {
	// if product is selected, re-install all features dependant on the component

		TCHAR szProductId[MAX_GUID+1];

		// If productcode is blank, enumerate first client of the component and use
		//	that product as the owner
		if (!lstrcmp(szProductCode, TEXT("")))
			MsivEnumClients(szComponentId, 0, szProductId);
		else
			lstrcpy(szProductId, szProductCode);


		int iFeatureCount=0;
		TCHAR szFeature[MAX_FEATURE_CHARS+1];
		TCHAR szParent[MAX_FEATURE_CHARS+1];

		// enumerate all the features of the product
		while (MsivEnumFeatures(szProductId, iFeatureCount++, szFeature, szParent)
			== ERROR_SUCCESS) {

			if (MsivQueryFeatureState(szProductId, szFeature) != INSTALLSTATE_ABSENT) {
				BOOL	fProceed=FALSE;
				int		iCompCount=0;
				TCHAR	szComponentCode[MAX_GUID+1];

				// enumerate all the components of the feature-
				//	if the selected component is present, reinstall this feature
				while (((MSI::MsivEnumComponentsFromFeature(szProductId, szFeature, 
					iCompCount++, szComponentCode, NULL, NULL)) == ERROR_SUCCESS) && (!fProceed)) {

					if (!lstrcmp(szComponentId, szComponentCode)) {
						MSI::MsiProvideComponent(szProductId, szFeature, szComponentCode, 0, NULL, NULL);
						fProceed=TRUE;
					}
				}
			}
		}
	}
	else
		// feature is selected, just reinstall selected feature
		MSI::MsiProvideComponent(szProductCode, szFeatureName, szComponentId, 0, NULL, NULL);
	return TRUE;
}


//----------------------------------------------------------------------
// ReinstallFeature
//	Reinstalls the selected feature based on the selected mode by calling MsiReinstallFeature
BOOL ReinstallFeature(
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName, 
		INT_PTR	iInstallMode
		) {

	UINT	iResult;

	switch (iInstallMode) {
	case 0:	
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, 
			REINSTALLMODE_FILEVERIFY+REINSTALLMODE_FILEMISSING);
		break;
	case 1:
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_FILEMISSING);
		break;
	case 2:
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_FILEREPLACE);
		break;
	case 3:
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_FILEOLDERVERSION);
		break;
	case 4:
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_FILEEQUALVERSION);
		break;
	case 5:
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_FILEEXACT);
		break;
	case 6:
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_USERDATA);
		break;
	case 7:
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_MACHINEDATA);
		break;
	case 8:
		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_SHORTCUT);
		break;
	case 9:
//		iResult = MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_ADVERTISE);
		break;
	default:
		return FALSE;
		break;

	}

	// if the feature could not be reinstalled directly try reinstalling all the components of the feature
	//	by calling MsiProvideComponent
	TCHAR	szComponentId[MAX_GUID+1];
	if	(iResult!=ERROR_SUCCESS)
		if (MsivEnumComponentsFromFeature(szProductCode, szFeatureName, 0, szComponentId, NULL, NULL)==ERROR_SUCCESS)
			MSI::MsiProvideComponent(szProductCode, szFeatureName, szComponentId, 0, NULL, NULL);


	return TRUE;
}


//----------------------------------------------------------------------
// ReinstallProduct
//	Reinstalls the selected product based on the selected mode by calling MsiReinstallProduct

BOOL ReinstallProduct(
		LPTSTR	szProductCode,
		INT_PTR	iInstallLev 
		) {

	switch (iInstallLev) {
	case 0:	
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_FILEVERIFY+REINSTALLMODE_FILEMISSING);
		break;
	case 1:
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_FILEMISSING);
		break;
	case 2:
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_FILEREPLACE);
		break;
	case 3:
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_FILEOLDERVERSION);
		break;
	case 4:
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_FILEEQUALVERSION);
		break;
	case 5:
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_FILEEXACT);
		break;
	case 6:
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_USERDATA);
		break;
	case 7:
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_MACHINEDATA);
		break;
	case 8:
		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_SHORTCUT);
		break;
	case 9:
//		MSI::MsiReinstallProduct(szProductCode, REINSTALLMODE_ADVERTISE);
		break;
	default:
		return FALSE;
		break;
	}
	return TRUE;
}


//----------------------------------------------------------------------
// ConfigureFeature
//	Configures the selected feature based on the selected mode by calling MsiConfigureFeature

BOOL ConfigureFeature(
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName, 
		INT_PTR	iInstallLev
		) {

	switch (iInstallLev) {
	case 0:
		MSI::MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_ABSENT);
		break;
	case 1:	
//		MSI::MsiUseFeature(szProductCode, szFeatureName);
		MSI::MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_LOCAL);
		break;
	case 2:
		MSI::MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_SOURCE);
		break;
	case 3:
		MSI::MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_DEFAULT);
		break;
	case 4:
//		MSI::MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_FREECACHE);
		break;
	case 5:
 		MSI::MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_ADVERTISED);
 		break;
	}
//	MSI::MsiReinstallFeature(szProductCode, szFeatureName, REINSTALLMODE_SHORTCUT);
	return TRUE;
}


//----------------------------------------------------------------------
// ConfigureProduct
//	Configures the selected product based on the selected state and level by calling MsiConfigureProduct
//	iInstallLev should be two digits. The first digit should contain the install state, 
//	the second digit should contain the install level

BOOL ConfigureProduct(
		LPTSTR	szProductCode,
		int		iInstallLev 
		) {

	INSTALLSTATE	iState;
	INSTALLLEVEL	iLevel;

	if (!iInstallLev) {
		MSI::MsiConfigureProduct(szProductCode, INSTALLLEVEL_MINIMUM, INSTALLSTATE_ABSENT);
		return TRUE;
	}

	switch (iInstallLev/10) {
	case 0:
		iState=INSTALLSTATE_DEFAULT;
		break;
	case 1:
		iState=INSTALLSTATE_LOCAL;
		break;
	case 2:
		iState=INSTALLSTATE_SOURCE;
		break;
	case 3:
		iState=INSTALLSTATE_ADVERTISED;
		break;
	default:
		iState=INSTALLSTATE_DEFAULT;
		break;
	}

	switch (iInstallLev%10) {
	case 1:	
		iLevel = INSTALLLEVEL_MINIMUM;

		break;
	case 2:
		iLevel = INSTALLLEVEL_DEFAULT;
		break;
	case 3:
		iLevel = INSTALLLEVEL_MAXIMUM;
		break;
	}

	if (DS_UNINSTALLEDDB == g_iDataSource)
	{
		TCHAR szPropertyString[MAX_PATH+1];
		wsprintf(szPropertyString, TEXT("INSTALLLEVEL=%d %s"), iLevel, iState == INSTALLSTATE_LOCAL? TEXT("ADDLOCAL=All")
			: iState == INSTALLSTATE_SOURCE ? TEXT("ADDLOCAL=All") 
			: iState == INSTALLSTATE_ADVERTISED ? TEXT("ADVERTISE=All") 
			: TEXT(""));
		TCHAR szFileName[MAX_PATH+1];
		DWORD cchFileName = MAX_PATH+1;
		MsivGetDatabaseName(szFileName, &cchFileName);
		MSI::MsiInstallProduct(szFileName, szPropertyString);
	}
	else
		MSI::MsiConfigureProduct(szProductCode, INSTALLLEVEL_MINIMUM, iState);
	return TRUE;
}



//----------------------------------------------------------------------
// HandleSaveProfile
//	Saves a snapshot of the displayed information into a profile after asking
//	user for the file name using a  win32 common dialogue box.
//	Uses MsivSaveProfile to save the profile

void HandleSaveProfile(
		HWND		hwndParent,
		HINSTANCE	hInst,
		BOOL		fDiff
		) {

	TCHAR	szFile[MAX_PATH+1];
	TCHAR	szFileTitle[MAX_PATH+1];

	TCHAR	szFilter[MAX_FILTER+1];
	ZeroOut(szFilter, MAX_FILTER+1);
	LoadString(g_hResourceInst, fDiff?IDS_CHKDIFF_SAVE_FILTER:IDS_SS_SAVE_FILTER, szFilter, MAX_FILTER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, fDiff?IDS_CHKDIFF_SAVE_CAPTION:IDS_SS_SAVE_CAPTION, szCaption, MAX_HEADER+1);

	TCHAR	szExtn[MAX_EXT+1];
	LoadString(g_hResourceInst, fDiff?IDS_CHKDIFF_SAVE_DEFAULT_EXTN:IDS_SS_SAVE_DEFAULT_EXTN, szExtn, MAX_EXT+1);

	lstrcpy(szFile, g_szNullString);
	lstrcpy(szFileTitle, g_szNullString);

	// struct to be used with the Win32 Common Dialogue Boxes
	OPENFILENAME sOpenFileName;
	sOpenFileName.lStructSize		= sizeof(OPENFILENAME);
	sOpenFileName.hwndOwner			= hwndParent;
	sOpenFileName.hInstance			= (HINSTANCE) hInst;
	sOpenFileName.lpstrFilter		= szFilter;
	sOpenFileName.lpstrCustomFilter	= (LPTSTR) NULL;
	sOpenFileName.nMaxCustFilter	= 0L;
	sOpenFileName.nFilterIndex		= 1L;
	sOpenFileName.lpstrFile			= szFile;
	sOpenFileName.nMaxFile			= sizeof(szFile);
	sOpenFileName.lpstrFileTitle	= szFileTitle;
	sOpenFileName.nMaxFileTitle		= sizeof(szFileTitle); 
	sOpenFileName.lpstrInitialDir	= NULL;
	sOpenFileName.lpstrTitle		= szCaption;
	sOpenFileName.Flags				= OFN_OVERWRITEPROMPT| OFN_HIDEREADONLY;
	sOpenFileName.nFileOffset		= 0; 
	sOpenFileName.nFileExtension	= 0; 
	sOpenFileName.lpstrDefExt		= szExtn; 
	sOpenFileName.lCustData			= 0;

	// call the common dialogue box to ask user for filename
	UINT iResult = ERROR_UNKNOWN;
	if (GetSaveFileName(&sOpenFileName)) {
		DeleteFile(sOpenFileName.lpstrFile);
		if (fDiff)
			CheckDiff(sOpenFileName.lpstrFile);
		else
			MsivSaveProfile(sOpenFileName.lpstrFile);
	}

}


//----------------------------------------------------------------------
// HandleLoadProfile
//	Opens a profile after asking user for the file name using a 
//	win32 common dialogue box. Returns ERROR_SUCCESS if successful, ERROR_UNKNOWN if
//	user hit cancel, or the error that occured while trying to open the file
//	if file is invalid

UINT HandleLoadProfile(
		HWND		hwndParent,
		HINSTANCE	hInst
		) {


	TCHAR	szFile[MAX_PATH+1];
	TCHAR	szFileTitle[MAX_PATH+1];

	TCHAR	szFilter[MAX_FILTER+1];
	ZeroOut(szFilter, MAX_FILTER+1);
	LoadString(g_hResourceInst, IDS_SS_OPEN_FILTER, szFilter, MAX_FILTER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_SS_OPEN_CAPTION, szCaption, MAX_HEADER+1);

	TCHAR	szExtn[MAX_EXT+1];
	LoadString(g_hResourceInst, IDS_SS_OPEN_DEFAULT_EXTN, szExtn, MAX_EXT+1);

	lstrcpy(szFile, g_szNullString);
	lstrcpy(szFileTitle, g_szNullString);

	// struct to be used with the Win32 Common Dialogue Boxes
	OPENFILENAME sOpenFileName;
	sOpenFileName.lStructSize		= sizeof(OPENFILENAME);
	sOpenFileName.hwndOwner			= hwndParent;
	sOpenFileName.hInstance			= (HINSTANCE) hInst;
	sOpenFileName.lpstrFilter		= szFilter;
	sOpenFileName.lpstrCustomFilter	= (LPTSTR) NULL;
	sOpenFileName.nMaxCustFilter	= 0L;
	sOpenFileName.nFilterIndex		= 1L;
	sOpenFileName.lpstrFile			= szFile;
	sOpenFileName.nMaxFile			= sizeof(szFile);
	sOpenFileName.lpstrFileTitle	= szFileTitle;
	sOpenFileName.nMaxFileTitle		= sizeof(szFileTitle); 
	sOpenFileName.lpstrInitialDir	= NULL;
	sOpenFileName.lpstrTitle		= szCaption;
	sOpenFileName.Flags				= OFN_FILEMUSTEXIST| OFN_HIDEREADONLY;
	sOpenFileName.nFileOffset		= 0; 
	sOpenFileName.nFileExtension	= 0; 
	sOpenFileName.lpstrDefExt		= szExtn; 
	sOpenFileName.lCustData			= 0;

	// call the common dialogue box to ask user for filename
	UINT iResult = ERROR_UNKNOWN;
	if (GetOpenFileName(&sOpenFileName)) {
		MsivCloseDatabase();
		iResult = MsivLoadProfile(sOpenFileName.lpstrFile);
	}

	return iResult;
}


void ChangeUnknownToAbsent(INSTALLSTATE *iState) {
	if ((*iState != INSTALLSTATE_ADVERTISED)
//		&& (*iState != INSTALLSTATE_DEFAULT)		// no longer used as a returned state
		&& (*iState != INSTALLSTATE_LOCAL)
		&& (*iState != INSTALLSTATE_SOURCE))
		*iState = INSTALLSTATE_ABSENT;
}




void FillInErrorMsg(
		LPTSTR			szErrOut,
		LPTSTR			szErrCaption,
		LPCTSTR			szItem,
  const	BOOL			fProduct,
  const	INSTALLSTATE	iProfileState,
  const	INSTALLSTATE	iCurrentState
		) {


	TCHAR	szErrMsg1[MAX_MESSAGE+MAX_FEATURE_CHARS+1];
	TCHAR	szErrMsg2[MAX_MESSAGE+(MAX_STATUS_CHARS*2)+1];

	LoadString(g_hResourceInst, fProduct?IDS_P_ERROR_RESTORING_LN1:IDS_F_ERROR_RESTORING_LN1, szErrMsg1, MAX_MESSAGE+1);
	LoadString(g_hResourceInst, IDS_PFC_ERROR_RESTORING_LN2, szErrMsg2, MAX_MESSAGE+1);

	TCHAR	szProfileState[MAX_STATUS_CHARS+1];
	FillInText(szProfileState, MAX_STATUS_CHARS+1, iProfileState, fProduct?ITEMTYPE_PRODUCT:ITEMTYPE_FEATURE);

	TCHAR	szCurrentState[MAX_STATUS_CHARS+1];
	FillInText(szCurrentState, MAX_STATUS_CHARS+1, iCurrentState, fProduct?ITEMTYPE_PRODUCT:ITEMTYPE_FEATURE);

	MessageBox(NULL, szItem, szProfileState, NULL);
	wsprintf(szErrMsg1, szErrMsg1, szItem);
	wsprintf(szErrMsg2, szErrMsg2, szProfileState, szCurrentState);
	wsprintf(szErrOut, szErrMsg1, szErrMsg2);

}

//----------------------------------------------------------------------
// RestoreProfile
//	Restores the currently open profile
//	It goes thru the profile, and attempts to re-install/re-configure the
//	products to the state they were in when the profile was saved.
//	If a feature was broken when the profile is saved, it is not touched.
//	TODO: cleanup this function

void RestoreProfile(
		BOOL	fQuiet
		) {

//			if (MessageBox(NULL, TEXT("This feature has not been fully tested or optimised yet.\n\
//Do you dare to proceed?"), TEXT("Debug Message"), MB_ICONEXCLAMATION|MB_YESNO)==IDNO)
//return;


	TCHAR	szProductCode[MAX_GUID+1]	= TEXT("");
	TCHAR	szSource[MAX_PATH+1]		= TEXT("");
	UINT	iProductCount				= 0;
	TCHAR	szErrOut[MAX_MESSAGE*5+MAX_FEATURE_CHARS+MAX_STATUS_CHARS*2+1];
	TCHAR	szErrCaption[MAX_HEADER+1];

	// go thru each product
	while (MsivEnumProducts(iProductCount++, szProductCode) == ERROR_SUCCESS) {

		// get original install packet location into szSource.
		DWORD	cchCount					= MAX_PRODUCT_CHARS+1;
		TCHAR	szSourceFile[MAX_PATH+20]	= TEXT("");
		WIN32_FIND_DATA	fdFileData;

		MsivGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLSOURCE, szSource, &cchCount);
		wsprintf(szSourceFile, TEXT("%s*.msi"), szSource);
		FindFirstFile(szSourceFile, &fdFileData);
		wsprintf(szSourceFile, TEXT("%s%s"), szSource, fdFileData.cFileName);


		TCHAR	szProductName[MAX_PRODUCT_CHARS+1];
		cchCount = MAX_PRODUCT_CHARS+1;
		MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, szProductName, &cchCount);


		INSTALLSTATE iProfileState = MsivQueryProductState(szProductCode);
		INSTALLSTATE iCurrentState = MsiQueryProductState(szProductCode);


		ChangeUnknownToAbsent(&iProfileState);

		if (iProfileState !=  iCurrentState) {
			if (MsiConfigureProduct(szProductCode, INSTALLLEVEL_MINIMUM, iProfileState) 
				!= ERROR_SUCCESS) {
				if (MsiInstallProduct(szSourceFile, NULL) != ERROR_SUCCESS) {
					if (fQuiet)
						continue;
					else {

						FillInErrorMsg(szErrOut, szErrCaption, szProductName, TRUE, iProfileState, iCurrentState);
						switch (MessageBox(NULL, szErrOut, szErrCaption, MB_ABORTRETRYIGNORE|MB_ICONWARNING)) {
						case IDABORT:						return;		break;
						case IDRETRY:	iProductCount--;	continue;	break;
						case IDIGNORE:						continue;	break;
						}
					}
				} 
				else
					MsiConfigureProduct(szProductCode, INSTALLLEVEL_MINIMUM, iProfileState);
			}
		}

		UINT	iFeatureCount=0;
		TCHAR	szFeature[MAX_FEATURE_CHARS+1];
		TCHAR	szParent[MAX_FEATURE_CHARS+1];

		while (MsivEnumFeatures(szProductCode, iFeatureCount++, szFeature, szParent) == ERROR_SUCCESS) {
			iProfileState = MsivQueryFeatureState(szProductCode, szFeature);
			iCurrentState = MsiQueryFeatureState(szProductCode,  szFeature);
			ChangeUnknownToAbsent(&iProfileState);

			UINT iResult = ERROR_SUCCESS;

//			wsprintf(szSBText, TEXT("Feature: %s\nProf State: %d\nCurr State: %d"), szFeature, iProfileState, iCurrentState);
//			MessageBox(NULL, szSBText, NULL, MB_OK);

			if (iProfileState !=  iCurrentState)
					 iResult = MsiConfigureFeature(szProductCode, szFeature, iProfileState);

			if (iResult != ERROR_SUCCESS) {
				if (MsiReinstallFeature(szProductCode, szFeature, REINSTALLMODE_FILEMISSING)
					!= ERROR_SUCCESS) {
					if (!fQuiet) {
						FillInErrorMsg(szErrOut, szErrCaption, szFeature, FALSE, iProfileState, iCurrentState);
						switch (MessageBox(NULL, szErrOut, szErrCaption, MB_ABORTRETRYIGNORE|MB_ICONWARNING)) {
						case IDABORT:	return;				break;
						case IDRETRY:	iFeatureCount--;	break;
						case IDIGNORE:						break;
						}
					}
				}
				else
					MsiConfigureFeature(szProductCode, szFeature, iProfileState);

			}
		}
	}


	iProductCount =0;
	while (MsiEnumProducts(iProductCount++, szProductCode) == ERROR_SUCCESS) {

		// get original install packet location into szSource.
		DWORD	cchCount					= MAX_PRODUCT_CHARS+1;
		TCHAR	szSourceFile[MAX_PATH+20]	= TEXT("");
		WIN32_FIND_DATA	fdFileData;

		MsiGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLSOURCE, szSource, &cchCount);
		wsprintf(szSourceFile, TEXT("%s*.msi"), szSource);
		FindFirstFile(szSourceFile, &fdFileData);
		wsprintf(szSourceFile, TEXT("%s%s"), szSource, fdFileData.cFileName);


		TCHAR	szProductName[MAX_PRODUCT_CHARS+1];
		cchCount = MAX_PRODUCT_CHARS+1;
		MsiGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLEDPRODUCTNAME, szProductName, &cchCount);


		INSTALLSTATE iProfileState = MsivQueryProductState(szProductCode);
		INSTALLSTATE iCurrentState = MsiQueryProductState(szProductCode);
		ChangeUnknownToAbsent(&iProfileState);


		if (iProfileState !=  iCurrentState) {
			if (MsiConfigureProduct(szProductCode, INSTALLLEVEL_MINIMUM, iProfileState) 
				!= ERROR_SUCCESS) {
				if (MsiInstallProduct(szSourceFile, NULL) != ERROR_SUCCESS) {
					if (fQuiet)
						continue;
					else {
						FillInErrorMsg(szErrOut, szErrCaption, szProductName, TRUE, iProfileState, iCurrentState);
						switch (MessageBox(NULL, szErrOut, szErrCaption, MB_ABORTRETRYIGNORE|MB_ICONWARNING)) {
						case IDABORT:						return;		break;
						case IDRETRY:	iProductCount--;	continue;	break;
						case IDIGNORE:						continue;	break;
						}
					}
				}
				else
					MsiConfigureProduct(szProductCode, INSTALLLEVEL_MINIMUM, iProfileState);
			}
		}

		UINT	iFeatureCount=0;
		TCHAR	szFeature[MAX_FEATURE_CHARS+1];
		TCHAR	szParent[MAX_FEATURE_CHARS+1];

		while (MsiEnumFeatures(szProductCode, iFeatureCount++, szFeature, szParent) == ERROR_SUCCESS) {
			iProfileState = MsivQueryFeatureState(szProductCode, szFeature);
			iCurrentState = MsiQueryFeatureState(szProductCode,  szFeature);
			ChangeUnknownToAbsent(&iProfileState);

			UINT iResult = ERROR_SUCCESS;

//			wsprintf(szSBText, TEXT("Feature: %s\nProf State: %d\nCurr State: %d"), szFeature, iProfileState, iCurrentState);
//			MessageBox(NULL, szSBText, NULL, MB_OK);

			if (iProfileState !=  iCurrentState)
					 iResult = MsiConfigureFeature(szProductCode, szFeature, iProfileState);

			if (iResult != ERROR_SUCCESS) {
				if (MsiReinstallFeature(szProductCode, szFeature, REINSTALLMODE_FILEMISSING)
					!= ERROR_SUCCESS) {
					if (!fQuiet) {
						FillInErrorMsg(szErrOut, szErrCaption, szFeature, FALSE, iProfileState, iCurrentState);
						switch (MessageBox(NULL, szErrOut, szErrCaption, MB_ABORTRETRYIGNORE|MB_ICONWARNING)) {
						case IDABORT:	return;				break;
						case IDRETRY:	iFeatureCount--;	break;
						case IDIGNORE:						break;
						}
					}
				}
				else
					MsiConfigureFeature(szProductCode, szFeature, iProfileState);
			}
		}
	}
}


//----------------------------------------------------------------------
// isProductInstalled
//	when a database is in use, this checks if the product described by the
//	database is installed on the local system.
//	used to determine DS_INSTALLEDDB or DS_UNINSTALLEDDB

BOOL isProductInstalled() {
	TCHAR	szProductCode[MAX_PRODUCT_CHARS+1];
	MsivEnumProducts(0, szProductCode);

	INSTALLSTATE iState = MsiQueryProductState(szProductCode);
	return ((iState == INSTALLSTATE_LOCAL)
		||	(iState == INSTALLSTATE_SOURCE)
		||  (iState == INSTALLSTATE_DEFAULT)
		||  (iState == INSTALLSTATE_ADVERTISED));
}

BOOL isProductInstalled(LPCTSTR	szProductCode) {

	INSTALLSTATE iState = MsiQueryProductState(szProductCode);
	return ((iState == INSTALLSTATE_LOCAL)
		||	(iState == INSTALLSTATE_SOURCE)
		||  (iState == INSTALLSTATE_DEFAULT)
		||  (iState == INSTALLSTATE_ADVERTISED));
}



// NOLOCALISE: text below should not be localised.
void CheckDiff(
		LPCTSTR	szFileName
		) {

//			if (MessageBox(NULL, TEXT("This feature has not been fully tested or optimised yet.\n\
//Do you dare to proceed?"), TEXT("Debug Message"), MB_ICONEXCLAMATION|MB_YESNO)==IDNO)
//return;



	TCHAR	szTemp[300];
	BOOL fFirst = TRUE;
	DWORD	cchSize;

	HANDLE hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);




	TCHAR	szProductCode[MAX_GUID+1]	= TEXT("");
	UINT	iProductCount				= 0;

	// go thru each product
	while (MsivEnumProducts(iProductCount++, szProductCode) == ERROR_SUCCESS) {

		DWORD	cchCount = MAX_PRODUCT_CHARS+1;
		TCHAR	szProductName[MAX_PRODUCT_CHARS+1];
		MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, szProductName, &cchCount);

		INSTALLSTATE iProfileState = MsivQueryProductState(szProductCode);
		INSTALLSTATE iCurrentState = MsiQueryProductState(szProductCode);

		TCHAR	szProfileState[MAX_STATUS_CHARS+1];
		TCHAR	szCurrentState[MAX_STATUS_CHARS+1];

		if (iProfileState !=  iCurrentState) {
			if (fFirst) {
				wsprintf(szTemp, TEXT("Product Code                       \tProduct\tFeatureName\tState in Profile\tCurrent State\r\n"));
				WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
				fFirst = FALSE;
			}

			FillInText(szProfileState, MAX_STATUS_CHARS+1, iProfileState, ITEMTYPE_PRODUCT);
			FillInText(szCurrentState, MAX_STATUS_CHARS+1, iCurrentState, ITEMTYPE_PRODUCT);

			wsprintf(szTemp, TEXT("\r\n%s\t%s\t---\t%s (%d)\t%s (%d)\r\n"), szProductCode, szProductName, szProfileState, iProfileState, 
				szCurrentState, iCurrentState);
			WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
		}
			
		UINT	iFeatureCount=0;
		TCHAR	szFeature[MAX_FEATURE_CHARS+1];
		TCHAR	szParent[MAX_FEATURE_CHARS+1];

		while (MsivEnumFeatures(szProductCode, iFeatureCount++, szFeature, szParent) == ERROR_SUCCESS) {
			iProfileState = MsivQueryFeatureState(szProductCode, szFeature);
			iCurrentState = MsiQueryFeatureState(szProductCode,  szFeature);

			if (iProfileState !=  iCurrentState) {
				if (fFirst) {
					wsprintf(szTemp, TEXT("Product Code                       \tProduct\tFeatureName\tState in Profile\tCurrent State\r\n"));
					WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
					fFirst = FALSE;
				}
				FillInText(szProfileState, MAX_STATUS_CHARS+1, iProfileState, ITEMTYPE_FEATURE);
				FillInText(szCurrentState, MAX_STATUS_CHARS+1, iCurrentState, ITEMTYPE_FEATURE);

				wsprintf(szTemp, TEXT("%s\t%s\t%s\t%s (%d)\t%s (%d)\r\n"), szProductCode, szProductName, szFeature, szProfileState, 
					iProfileState, szCurrentState, iCurrentState);
				WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);

			}

		}
	}

	iProductCount = 0;

	while (MsiEnumProducts(iProductCount++, szProductCode) == ERROR_SUCCESS) {

		DWORD	cchCount = MAX_PRODUCT_CHARS+1;
		TCHAR	szProductName[MAX_PRODUCT_CHARS+1];

		MsiGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, szProductName, &cchCount);

		INSTALLSTATE iProfileState = MsivQueryProductState(szProductCode);
		INSTALLSTATE iCurrentState = MsiQueryProductState(szProductCode);

		TCHAR	szProfileState[MAX_STATUS_CHARS+1];
		TCHAR	szCurrentState[MAX_STATUS_CHARS+1];

		if (iProfileState == INSTALLSTATE_UNKNOWN) {
			if (fFirst) {
				wsprintf(szTemp, TEXT("Product Code                       \tProduct\tFeatureName\tState in Profile\tCurrent State\r\n"));
				WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
				fFirst = FALSE;
			}
			FillInText(szProfileState, MAX_STATUS_CHARS+1, iProfileState, ITEMTYPE_PRODUCT);
			FillInText(szCurrentState, MAX_STATUS_CHARS+1, iCurrentState, ITEMTYPE_PRODUCT);

			wsprintf(szTemp, TEXT("%s\t%s\t---          \t%s (%d)\t%s (%d)\r\n"), szProductCode, szProductName, szProfileState, iProfileState, 
				szCurrentState, iCurrentState);
			WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
		}
	}			


	TCHAR	szComponentId[MAX_GUID+1]	= TEXT("");
	UINT	iComponentCount				= 0;

	fFirst = TRUE;
	while (MsivEnumComponents(iComponentCount++, szComponentId) == ERROR_SUCCESS) {

		DWORD	cchCount = MAX_PRODUCT_CHARS+1;
		TCHAR	szComponentName[MAX_PRODUCT_CHARS+1];
		MsivGetComponentName(szComponentId, szComponentName, &cchCount);


		TCHAR	szProfCompPath[MAX_PATH+1];
		TCHAR	szCurrCompPath[MAX_PATH+1];

		cchCount = MAX_PATH+1;
		INSTALLSTATE iProfileState = MsivLocateComponent(szComponentId, szProfCompPath, &cchCount);

		cchCount = MAX_PATH+1;
		INSTALLSTATE iCurrentState =  MsiLocateComponent(szComponentId, szCurrCompPath, &cchCount);

		if ((iProfileState != iCurrentState) || (lstrcmp(szProfCompPath, szCurrCompPath))) {
			if (fFirst) {
				wsprintf(szTemp, TEXT("\r\n\r\nComponent GUID                   \tComponentName\tState in Profile\tCurrent State\tPath in Profile\tCurrent Path\r\n"));
				WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
				fFirst = FALSE;
			}
			TCHAR	szProfileState[MAX_STATUS_CHARS+1];
			TCHAR	szCurrentState[MAX_STATUS_CHARS+1];
			FillInText(szProfileState, MAX_STATUS_CHARS+1, iProfileState);
			FillInText(szCurrentState, MAX_STATUS_CHARS+1, iCurrentState);

			if (iCurrentState == INSTALLSTATE_UNKNOWN)
				lstrcpy(szCurrCompPath, TEXT("<UNKNOWN>"));
			wsprintf(szTemp, TEXT("%s\t%s\t%s (%d)\t%s (%d)\t%s\t%s\r\n"), szComponentId, szComponentName,
				szProfileState, iProfileState, szCurrentState, iCurrentState, szProfCompPath, szCurrCompPath);
			WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
		}
	}			



	while (MsiEnumComponents(iComponentCount++, szComponentId) == ERROR_SUCCESS) {

		DWORD	cchCount = MAX_PRODUCT_CHARS+1;
		TCHAR	szComponentName[MAX_PRODUCT_CHARS+1];
		MsivGetComponentName(szComponentId, szComponentName, &cchCount);


		TCHAR	szProfCompPath[MAX_PATH+1];
		TCHAR	szCurrCompPath[MAX_PATH+1];

		cchCount = MAX_PATH+1;
		INSTALLSTATE iProfileState = MsivLocateComponent(szComponentId, szProfCompPath, &cchCount);

		cchCount = MAX_PATH+1;
		INSTALLSTATE iCurrentState =  MsiLocateComponent(szComponentId, szCurrCompPath, &cchCount);

		TCHAR	szProfileState[MAX_STATUS_CHARS+1];
		TCHAR	szCurrentState[MAX_STATUS_CHARS+1];

		if (iProfileState == INSTALLSTATE_UNKNOWN) {
			if (fFirst) {
				wsprintf(szTemp, TEXT("\r\n\r\nComponent GUID                   \tComponentName\tState in Profile\tCurrent State\tPath in Profile\tCurrent Path\r\n"));
				WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
				fFirst = FALSE;
			}
			FillInText(szProfileState, MAX_STATUS_CHARS+1, iProfileState);
			FillInText(szCurrentState, MAX_STATUS_CHARS+1, iCurrentState);

			wsprintf(szTemp, TEXT("%s\t%s\t%s (%d)\t%s (%d)\t%s\t%s\r\n"), szComponentId, szComponentName,
				szProfileState, iProfileState, szCurrentState, iCurrentState, szProfCompPath, szCurrCompPath);
			WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
		}
	}			


	wsprintf(szTemp, TEXT("\r\nDone.\r\n\r\n"));

	if (!fFirst)
		WriteFile(hFile, szTemp, (lstrlen(szTemp)+1) * sizeof(TCHAR), &cchSize, NULL);
	CloseHandle(hFile);

}
// endNOLOCALISE

//----------------------------------------------------------------------
//----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispyu.dll\msispyu.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       msispyu.h
//
//--------------------------------------------------------------------------

#ifndef MSISPYU_H
#define MSISPYU_H


#include "windows.h"
#include <tchar.h>
#include "msiquery.h"
#include "assert.h"
#include "spydspid.h"
//#define EXPORT	extern "C" __declspec (dllexport)
#define EXPORT

#define MAX_COMPONENT_CHARS	100
#define MAX_PRODUCT_CHARS	100
#define MAX_ATTRIB_CHARS	30
#define MAX_STATUS_CHARS	100
#define MAX_FEATURE_TITLE_CHARS	100
#define	MAX_GUID			39

#define ERROR_UNKNOWN				ERROR_UNKNOWN_PROPERTY
#define	MSI
#define W32
#define OLE
#define	ERROR_						ERROR_UNKNOWN_PROPERTY

#define	INSTALLPROPERTY_STATE		TEXT("State")
#define	INSTALLPROPERTY_PRODUCTCODE	TEXT("ProductCode")
#define	INSTALLPROPERTY_USERNAME	TEXT("UserName")
#define	INSTALLPROPERTY_USERORGNAME	TEXT("UserOrgName")
#define	INSTALLPROPERTY_PRODUCTID	TEXT("ProductId")

#define FEATUREPROPERTY_NAME		TEXT("Feature")
#define	FEATUREPROPERTY_PARENT		TEXT("Feature_Parent")
#define FEATUREPROPERTY_TITLE		TEXT("Title")
#define FEATUREPROPERTY_DESC		TEXT("Description")
#define	FEATUREPROPERTY_DISPLAY		TEXT("Display")
#define FEATUREPROPERTY_LEVEL		TEXT("Level")
#define FEATUREPROPERTY_DIRCONF		TEXT("Directory_")
#define FEATUREPROPERTY_RUNFRMSRC	TEXT("Attributes")
#define	FEATUREPROPERTY_STATE		TEXT("State")
#define	FEATUREPROPERTY_DATE		TEXT("LastUsed")
#define	FEATUREPROPERTY_COUNT		TEXT("UsageCount")

#define COMPONENTPROPERTY_NAME		TEXT("Name")
#define COMPONENTPROPERTY_PATH		TEXT("Path")
#define COMPONENTPROPERTY_STATE		TEXT("State")
#define COMPONENTPROPERTY_GUID		TEXT("GUID")

#define FILEPROPERTY_TITLE			TEXT("FileTitle")
#define FILEPROPERTY_COMPONENT		TEXT("Component_")
#define	FILEPROPERTY_NAME			TEXT("FileName")
#define	FILEPROPERTY_SIZE			TEXT("FileSize")
#define	FILEPROPERTY_VERSION		TEXT("Version")
#define	FILEPROPERTY_LANGUAGE		TEXT("Language")
#define	FILEPROPERTY_ATTRIBUTES		TEXT("Attributes")
#define	FILEPROPERTY_SEQUENCE		TEXT("Sequence")
#define	FILEPROPERTY_ACTUALSIZE		TEXT("FileActualSize")
#define	FILEPROPERTY_CREATIONTIME	TEXT("FileCreated")
#define	FILEPROPERTY_LASTWRITETIME	TEXT("FileModified")
#define	FILEPROPERTY_LASTACCESSTIME	TEXT("FileAccessed")
#define	FILEPROPERTY_STATUS			TEXT("FileStatus")

#define	FILESTATUS_OKAY				TEXT("Okay")
#define	FILESTATUS_FILENOTFOUND		TEXT("File Not Found")
#define	FILESTATUS_DIFFSIZE			TEXT("File Size Different")

const int cchProductCode = 38;
const int cchGUID = 38;

typedef UINT			(WINAPI *T_MsivEnumProducts)(const DWORD dwProductIndex, LPTSTR lpProductBuf);
typedef UINT			(WINAPI *T_MsivEnumFeatures)(LPCTSTR szProduct, const DWORD iFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf);
typedef UINT			(WINAPI *T_MsivEnumComponents)(const DWORD iComponentIndex, LPTSTR lpComponentBuf);
typedef UINT			(WINAPI *T_MsivEnumComponentsFromProduct)(LPCTSTR szProductCode, const DWORD iComponentIndex, LPTSTR lpComponentBuf);
typedef UINT			(WINAPI *T_MsivEnumComponentsFromFeature)(LPCTSTR szProduct, LPCTSTR szFeature, const DWORD iComponentIndex, LPTSTR lpComponentBuf, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf);
typedef UINT			(WINAPI *T_MsivGetComponentName)(LPCTSTR szComponentId, LPTSTR lpComponentName, LPDWORD cchComponentName);
typedef UINT			(WINAPI *T_MsivGetProductInfo)(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef UINT			(WINAPI *T_MsivGetFeatureInfo)(LPCTSTR szProduct, LPCTSTR szFeature, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef UINT			(WINAPI *T_MsivOpenDatabase)(LPCTSTR szDatabase);
typedef UINT			(WINAPI *T_MsivCloseDatabase)();
typedef UINT			(WINAPI *T_MsivGetDatabaseName)(LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef UINT			(WINAPI *T_MsivSaveProfile)(LPCTSTR szFileName);
typedef UINT			(WINAPI *T_MsivLoadProfile)(LPTSTR szFileName);
typedef UINT			(WINAPI *T_MsivCloseProfile)();
typedef UINT			(WINAPI *T_MsivGetProfileName)(LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef UINT			(WINAPI *T_MsivGetFeatureUsage)(LPCTSTR szProduct, LPCTSTR szFeature, LPDWORD pdwUseCount, LPWORD pwDateUsed);
typedef UINT			(WINAPI *T_MsivEnumClients)(LPCTSTR szComponent, DWORD iProductIndex, LPTSTR lpProductBuf);
typedef UINT			(WINAPI *T_MsivGetProfileInfo)(UINT iIndex, LPTSTR szValue, LPDWORD pcchCount);
typedef UINT			(WINAPI *T_MsivEnumFilesFromComponent)(LPCTSTR szComponentid, DWORD iFileIndex, LPTSTR lpValueBuf, LPDWORD pcchCount);
typedef UINT			(WINAPI *T_MsivGetFileInfo)(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
typedef INSTALLSTATE	(WINAPI *T_MsivQueryProductState)(LPCTSTR szProduct);
typedef INSTALLSTATE	(WINAPI *T_MsivQueryFeatureState)(LPCTSTR szProduct, LPCTSTR szFeature);
typedef INSTALLSTATE	(WINAPI *T_MsivLocateComponent)(LPCTSTR szComponentId,LPTSTR lpPathBuf, LPDWORD pcchBuf);
typedef INSTALLSTATE	(WINAPI *T_MsivGetComponentPath)(LPCTSTR szProductCode,LPCTSTR szComponentId,LPTSTR lpPathBuf, LPDWORD pcchBuf);
typedef USERINFOSTATE	(WINAPI *T_MsivGetUserInfo)(LPCTSTR szProduct, LPTSTR lpUserNameBuf, LPDWORD pcchUserNameBuf, LPTSTR lpOrgNameBuf, LPDWORD pcchOrgNameBuf, LPTSTR lpSerialBuf, LPDWORD pcchSerialBuf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispyu.dll\hashinc.cpp ===
#include "hash.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\propshts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       propshts.cpp
//
//--------------------------------------------------------------------------

// propshts.cpp: functions to display the property sheets

#include "msispyu.h"
#include "propshts.h"
#include "hash.h"
#include "stdio.h"
#include <wtypes.h>
#include <stdlib.h> // for atoi

//!! Need to fix warnings and remove pragma
#pragma warning(disable : 4242) // conversion from int to unsigned short

// globals
HINSTANCE		g_hInstance						= NULL;
HINSTANCE		g_hResourceInst					= NULL;
TCHAR			g_szNullString[MAX_NULLSTRING+1]	= TEXT("");
DATASOURCETYPE	g_iDataSource					= DS_NONE;
HashTable		g_htCompTable;
BOOL			g_fReloadDll;

//extern	BOOL fReload;
extern MSISPYSTRUCT	g_spyGlobalData;
extern TCHAR	g_szMyProductCode[MAX_GUID+1];
extern TCHAR	g_szDLLComponentCode[MAX_GUID+1];
extern TCHAR	g_szDLLFeatureName[MAX_FEATURE_CHARS+1];
extern LCID		g_lcidCurrentLocale;
extern TCHAR	g_szIntlDLLComponentCode[MAX_GUID+1];
extern MODE		g_modeCurrent;

BOOL CreateNewUI(
	HINSTANCE hPrevInstance,
	int nCmdShow,
	RECT *rwindow = NULL
	);

UINT FindComponent(
	  LPCTSTR	szComponentCode,
	  LPTSTR	szPath, 
	  DWORD		*pcchPath
	  );

//HandleMessages();

void SwitchMode(MODE modeNew, BOOL fMessage) {
	g_modeCurrent = modeNew;
	// gray out stuff from menu ...
	if ((g_modeCurrent == MODE_RESTRICTED) || (g_modeCurrent == MODE_DEGRADED)) {
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_OPEN_MSI_PACKAGE, MF_GRAYED);
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_LOAD_SAVED_STATE, MF_GRAYED);
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_SAVE_CURRENT_STATE, MF_GRAYED);
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_RESTORE_STATE, MF_GRAYED);
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_CHECK_DIFFERENCES, MF_GRAYED);

		if (fMessage) {
			TCHAR	szRestrMsg[MAX_MESSAGE+1];
			LoadString(g_spyGlobalData.hResourceInstance, IDS_SWITCH_TO_RESTRICTED_MESSAGE, szRestrMsg, MAX_MESSAGE+1);

			TCHAR	szRestrCaption[MAX_HEADER+1];
			LoadString(g_spyGlobalData.hResourceInstance, IDS_SWITCH_TO_RESTRICTED_CAPTION, szRestrCaption, MAX_HEADER+1);

			MessageBox(NULL, szRestrMsg, szRestrCaption, MB_OK|MB_ICONEXCLAMATION);
		}

	} else {
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_OPEN_MSI_PACKAGE, MF_ENABLED);

// !!! temporary to get profling disabled for ISV release 04/10/1998
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_LOAD_SAVED_STATE, MF_ENABLED);
		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_SAVE_CURRENT_STATE, MF_ENABLED);
//		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_LOAD_SAVED_STATEF, MF_GRAYED);
//		EnableMenuItem(GetMenu(g_spyGlobalData.hwndParent), IDM_FL_SAVE_CURRENT_STATE, MF_GRAYED);
// !!! end
	}

	SendMessage(g_spyGlobalData.hwndParent, WM_COMMAND, IDM_VW_REFRESH, 0);
}

UINT WINAPI L_MsivEnumProducts(const DWORD iProductIndex, LPTSTR lpProductBuf) {
	return MsiEnumProducts(iProductIndex, lpProductBuf);
}

UINT WINAPI L_MsivEnumFeatures(LPCTSTR szProduct, const DWORD iFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf) {
	return MsiEnumFeatures(szProduct, iFeatureIndex, lpFeatureBuf, lpParentBuf);
}

UINT WINAPI L_MsivEnumComponentsFromFeature(LPCTSTR szProduct, LPCTSTR szFeature, const DWORD iComponentIndex, LPTSTR lpComponentBuf, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf) {
	return ERRORD;
}

UINT WINAPI L_MsivEnumComponents(const DWORD iComponentIndex, LPTSTR lpComponentBuf) {
	return MsiEnumComponents(iComponentIndex, lpComponentBuf);
}

UINT WINAPI L_MsivGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentName, DWORD *cchComponentName) {
	return MsivGetComponentName ? (*MsivGetComponentName)(szComponentId, lpComponentName, cchComponentName) : ERRORD;
}

UINT WINAPI L_MsivGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	return MsiGetProductInfo(szProduct, szAttribute, lpValueBuf, pcchValueBuf);
}

UINT WINAPI L_MsivGetFeatureInfo(LPCTSTR szProduct, LPCTSTR szFeature, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	return ERRORD;
}

UINT WINAPI L_MsivOpenDatabase(LPCTSTR szDatabase) {
	return ERRORD;
}

UINT WINAPI L_MsivCloseDatabase() {
	return ERRORD;
}

UINT WINAPI L_MsivGetDatabaseName(LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	return ERRORD;
}

UINT WINAPI L_MsivEnumComponentsFromProduct(LPCTSTR szProductCode, const DWORD iComponentIndex, LPTSTR lpComponentBuf) {
	return ERRORD;
}

UINT WINAPI L_MsivSaveProfile(LPCTSTR szFileName) {
	return ERRORD;
}

UINT WINAPI L_MsivLoadProfile(LPTSTR szFileName) {
	return ERRORD;
}

UINT WINAPI L_MsivCloseProfile() {
	return ERRORD;
}

UINT WINAPI L_MsivGetProfileName(LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	return ERRORD;
}

UINT WINAPI L_MsivGetFeatureUsage(LPCTSTR szProduct, LPCTSTR szFeature, DWORD *pdwUseCount, WORD *pwDateUsed) {
	return MsiGetFeatureUsage(szProduct, szFeature, pdwUseCount, pwDateUsed);
}

UINT WINAPI L_MsivEnumClients(LPCTSTR szComponent, DWORD iProductIndex, LPTSTR lpProductBuf) {
	return MsiEnumClients(szComponent, iProductIndex, lpProductBuf);
}

UINT WINAPI L_MsivGetProfileInfo(UINT iIndex, LPTSTR szValue, DWORD *pcchCount) {
	return ERRORD;
}

UINT WINAPI L_MsivEnumFilesFromComponent(LPCTSTR szComponentid, DWORD iFileIndex, LPTSTR lpValueBuf, DWORD *pcchCount) {
	return ERRORD;
}

UINT WINAPI L_MsivGetFileInfo(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	return ERRORD;
}

INSTALLSTATE WINAPI L_MsivQueryProductState(LPCTSTR szProduct) {
	return MsiQueryProductState(szProduct);
}

INSTALLSTATE WINAPI L_MsivQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature) {
	return MsiQueryFeatureState(szProduct, szFeature);
}

INSTALLSTATE WINAPI L_MsivLocateComponent(LPCTSTR szComponentId, LPTSTR lpPathBuf, DWORD *pcchBuf) {
	//return MsiLocateComponent(szComponentId, lpPathBuf, pcchBuf);
	assert(0);
	return MsiLocateComponent(szComponentId, lpPathBuf, pcchBuf);
}

INSTALLSTATE WINAPI L_MsivGetComponentPath(LPCTSTR szProductCode, LPCTSTR szComponentId, LPTSTR lpPathBuf, DWORD *pcchBuf) {
	return MsiGetComponentPath(szProductCode, szComponentId, lpPathBuf, pcchBuf);
}

USERINFOSTATE WINAPI L_MsivGetUserInfo(LPCTSTR szProduct, LPTSTR lpUserNameBuf, DWORD *pcchUserNameBuf, 
												LPTSTR lpOrgNameBuf, DWORD *pcchOrgNameBuf, LPTSTR lpSerialBuf, DWORD *pcchSerialBuf) {
	return MsiGetUserInfo(szProduct, lpUserNameBuf, pcchUserNameBuf, lpOrgNameBuf, pcchOrgNameBuf, lpSerialBuf, pcchSerialBuf);
}


UINT			WINAPI F_MsivEnumProducts(const DWORD iProductIndex, LPTSTR lpProductBuf);
UINT			WINAPI F_MsivEnumFeatures(LPCTSTR szProduct, const DWORD iFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf);
UINT			WINAPI F_MsivEnumComponentsFromFeature(LPCTSTR szProduct, LPCTSTR szFeature, const DWORD iComponentIndex, LPTSTR lpComponentBuf, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf);
UINT			WINAPI F_MsivEnumComponents(const DWORD iComponentIndex, LPTSTR lpComponentBuf);
UINT			WINAPI F_MsivGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentName, DWORD *cchComponentName);
UINT			WINAPI F_MsivGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf);
UINT			WINAPI F_MsivGetFeatureInfo(LPCTSTR szProduct, LPCTSTR szFeature, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf);
UINT			WINAPI F_MsivOpenDatabase(LPCTSTR szDatabase);
UINT			WINAPI F_MsivCloseDatabase();
UINT			WINAPI F_MsivGetDatabaseName(LPTSTR lpValueBuf, DWORD *pcchValueBuf);
UINT			WINAPI F_MsivEnumComponentsFromProduct(LPCTSTR szProductCode, const DWORD iComponentIndex, LPTSTR lpComponentBuf);
UINT			WINAPI F_MsivSaveProfile(LPCTSTR szFileName);
UINT			WINAPI F_MsivLoadProfile(LPTSTR szFileName);
UINT			WINAPI F_MsivCloseProfile();
UINT			WINAPI F_MsivGetProfileName(LPTSTR lpValueBuf, DWORD *pcchValueBuf);
UINT			WINAPI F_MsivGetFeatureUsage(LPCTSTR szProduct, LPCTSTR szFeature, DWORD *pdwUseCount, WORD *pwDateUsed);
UINT			WINAPI F_MsivEnumClients(LPCTSTR szComponent, DWORD iProductIndex, LPTSTR lpProductBuf);
UINT			WINAPI F_MsivGetProfileInfo(UINT iIndex, LPTSTR szValue, DWORD *pcchCount);
UINT			WINAPI F_MsivEnumFilesFromComponent(LPCTSTR szComponentid, DWORD iFileIndex, LPTSTR lpValueBuf, DWORD *pcchCount);
UINT			WINAPI F_MsivGetFileInfo(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf);
INSTALLSTATE	WINAPI F_MsivQueryProductState(LPCTSTR szProduct);
INSTALLSTATE	WINAPI F_MsivQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature);
INSTALLSTATE	WINAPI F_MsivLocateComponent(LPCTSTR szComponentId,LPTSTR lpPathBuf, DWORD *pcchBuf);
INSTALLSTATE	WINAPI F_MsivGetComponentPath(LPCTSTR szProductCode,LPCTSTR szComponentId,LPTSTR lpPathBuf, DWORD *pcchBuf);
USERINFOSTATE	WINAPI F_MsivGetUserInfo(LPCTSTR szProduct, LPTSTR lpUserNameBuf, DWORD *pcchUserNameBuf, LPTSTR lpOrgNameBuf, DWORD *pcchOrgNameBuf, LPTSTR lpSerialBuf, DWORD *pcchSerialBuf);

T_MsivEnumProducts				MsivEnumProducts				= F_MsivEnumProducts;
T_MsivEnumFeatures				MsivEnumFeatures				= F_MsivEnumFeatures;
T_MsivEnumComponentsFromFeature	MsivEnumComponentsFromFeature	= F_MsivEnumComponentsFromFeature;
T_MsivEnumComponents			MsivEnumComponents				= F_MsivEnumComponents;
T_MsivGetComponentName			MsivGetComponentName			= F_MsivGetComponentName;
T_MsivGetProductInfo			MsivGetProductInfo				= F_MsivGetProductInfo;
T_MsivGetFeatureInfo			MsivGetFeatureInfo				= F_MsivGetFeatureInfo;
T_MsivOpenDatabase				MsivOpenDatabase				= F_MsivOpenDatabase;
T_MsivCloseDatabase				MsivCloseDatabase				= F_MsivCloseDatabase;
T_MsivGetDatabaseName			MsivGetDatabaseName				= F_MsivGetDatabaseName;
T_MsivEnumComponentsFromProduct	MsivEnumComponentsFromProduct	= F_MsivEnumComponentsFromProduct;
T_MsivSaveProfile				MsivSaveProfile					= F_MsivSaveProfile;
T_MsivLoadProfile				MsivLoadProfile					= F_MsivLoadProfile;
T_MsivCloseProfile				MsivCloseProfile				= F_MsivCloseProfile;
T_MsivGetProfileName			MsivGetProfileName				= F_MsivGetProfileName;
T_MsivGetFeatureUsage			MsivGetFeatureUsage				= F_MsivGetFeatureUsage;
T_MsivEnumClients				MsivEnumClients					= F_MsivEnumClients;
T_MsivGetProfileInfo			MsivGetProfileInfo				= F_MsivGetProfileInfo;
T_MsivEnumFilesFromComponent	MsivEnumFilesFromComponent		= F_MsivEnumFilesFromComponent;
T_MsivGetFileInfo				MsivGetFileInfo					= F_MsivGetFileInfo;
T_MsivQueryProductState			MsivQueryProductState			= F_MsivQueryProductState;
T_MsivQueryFeatureState			MsivQueryFeatureState			= F_MsivQueryFeatureState;
T_MsivLocateComponent			MsivLocateComponent				= F_MsivLocateComponent;
T_MsivGetComponentPath			MsivGetComponentPath			= F_MsivGetComponentPath;
T_MsivGetUserInfo				MsivGetUserInfo					= F_MsivGetUserInfo;


FARPROC Bind_MSISPYU(const TCHAR* szEntry) {
	static HINSTANCE hInst = 0;

	if (g_fReloadDll) {
		g_fReloadDll = FALSE;
		FreeLibrary(hInst);
		hInst = 0;
	}

	if ((g_modeCurrent!=MODE_DEGRADED) && (hInst == 0)) {

		TCHAR	szDLLPath[MAX_PATH+1];
		DWORD	cchDLLPath = MAX_PATH+1;
		UINT iError;
		if (ERROR_SUCCESS != (iError = MsiProvideComponent(g_szMyProductCode, g_szDLLFeatureName, g_szDLLComponentCode, 
			INSTALLMODE_EXISTING, szDLLPath, &cchDLLPath))) {
			cchDLLPath = MAX_PATH+1;
			if (ERROR_SUCCESS != (iError = MsiProvideComponent(g_szMyProductCode, g_szDLLFeatureName, g_szDLLComponentCode, 
				INSTALLMODE_DEFAULT, szDLLPath, &cchDLLPath)))
				SwitchMode(MODE_DEGRADED, TRUE);
		}

		if (g_modeCurrent!=MODE_DEGRADED) {		
			hInst = W32::LoadLibrary(szDLLPath);
			if (!hInst) SwitchMode(MODE_DEGRADED, TRUE);
		}
#if 0
		// Prepare to use the SystemInterface feature: check its current state and increase usage count.
		INSTALLSTATE iDLLFeatureState = MsiUseFeature(g_szMyProductCode, g_szDLLFeatureName);

		// If feature is not currently usable, try fixing it
		switch (iDLLFeatureState) {
//		case INSTALLSTATE_DEFAULT:			// no loner used as a returned state
		case INSTALLSTATE_LOCAL:
		case INSTALLSTATE_SOURCE:
			break;

		case INSTALLSTATE_ADVERTISED:
		case INSTALLSTATE_ABSENT:
			if (MsiConfigureFeature(g_szMyProductCode, g_szDLLFeatureName, INSTALLSTATE_DEFAULT) != ERROR_SUCCESS)
				SwitchMode(MODE_DEGRADED, TRUE);
			break;

		default:
			if (MsiReinstallFeature(g_szMyProductCode, g_szDLLFeatureName, REINSTALLMODE_FILEEQUALVERSION 
				+ REINSTALLMODE_MACHINEDATA 
				+ REINSTALLMODE_USERDATA
				+ REINSTALLMODE_SHORTCUT) != ERROR_SUCCESS)
				SwitchMode(MODE_DEGRADED, TRUE);
			break;
		}

		if (g_modeCurrent!=MODE_DEGRADED) {		
			TCHAR	szDLLPath[MAX_PATH+1];
			DWORD	cchDLLPath = MAX_PATH+1;
//			MsiLocateComponent(g_szDLLComponentCode, szDLLPath, &cchDLLPath);
			MsiGetComponentPath(g_szMyProductCode, g_szDLLComponentCode, szDLLPath, &cchDLLPath);
			hInst = W32::LoadLibrary(szDLLPath);
			if (!hInst) SwitchMode(MODE_DEGRADED, TRUE);
		}
#endif //0
	}


#ifdef UNICODE
	if (g_modeCurrent!=MODE_DEGRADED) {
		char rgchEntry[MAX_PATH+1];
		WideCharToMultiByte(CP_ACP, NULL, szEntry, -1, rgchEntry, MAX_PATH+1, NULL, NULL);
		return W32::GetProcAddress(hInst, rgchEntry);
	}
	else 
		return 0;
#else
	if (g_modeCurrent!=MODE_DEGRADED)
		return W32::GetProcAddress(hInst, szEntry);
	else
		return 0;
#endif

}


// temp ...
void ReloadDLL() {
	g_fReloadDll = TRUE;
	MsivEnumProducts				= F_MsivEnumProducts;
	MsivEnumFeatures				= F_MsivEnumFeatures;
	MsivEnumComponentsFromFeature	= F_MsivEnumComponentsFromFeature;
	MsivEnumComponents				= F_MsivEnumComponents;
	MsivGetComponentName			= F_MsivGetComponentName;
	MsivGetProductInfo				= F_MsivGetProductInfo;
	MsivGetFeatureInfo				= F_MsivGetFeatureInfo;
	MsivOpenDatabase				= F_MsivOpenDatabase;
	MsivCloseDatabase				= F_MsivCloseDatabase;
	MsivGetDatabaseName				= F_MsivGetDatabaseName;
	MsivEnumComponentsFromProduct	= F_MsivEnumComponentsFromProduct;
	MsivSaveProfile					= F_MsivSaveProfile;
	MsivLoadProfile					= F_MsivLoadProfile;
	MsivCloseProfile				= F_MsivCloseProfile;
	MsivGetProfileName				= F_MsivGetProfileName;
	MsivGetFeatureUsage				= F_MsivGetFeatureUsage;
	MsivEnumClients					= F_MsivEnumClients;
	MsivGetProfileInfo				= F_MsivGetProfileInfo;
	MsivEnumFilesFromComponent		= F_MsivEnumFilesFromComponent;
	MsivGetFileInfo					= F_MsivGetFileInfo;
	MsivQueryProductState			= F_MsivQueryProductState;
	MsivQueryFeatureState			= F_MsivQueryFeatureState;
	MsivLocateComponent				= F_MsivLocateComponent;
	MsivGetComponentPath			= F_MsivGetComponentPath;
	MsivGetUserInfo					= F_MsivGetUserInfo;

}

UINT WINAPI MSISPYU::F_MsivEnumProducts(const DWORD iProductIndex, LPTSTR lpProductBuf) {
	MsivEnumProducts = (T_MsivEnumProducts)Bind_MSISPYU(TEXT("MsivEnumProducts"));
	MsivEnumProducts = (MsivEnumProducts)?MsivEnumProducts:L_MsivEnumProducts;
	assert(MsivEnumProducts != 0);
	return MsivEnumProducts ? (*MsivEnumProducts)(iProductIndex, lpProductBuf) : 0;
}


UINT WINAPI MSISPYU::F_MsivEnumFeatures(LPCTSTR szProduct, const DWORD iFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf) {
	MsivEnumFeatures = (T_MsivEnumFeatures)Bind_MSISPYU(TEXT("MsivEnumFeatures"));
	MsivEnumFeatures = (MsivEnumFeatures)?MsivEnumFeatures:L_MsivEnumFeatures;
	assert(MsivEnumFeatures != 0);
	return MsivEnumFeatures ? (*MsivEnumFeatures)(szProduct, iFeatureIndex, lpFeatureBuf, lpParentBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivEnumComponentsFromFeature(LPCTSTR szProduct, LPCTSTR szFeature, const DWORD iComponentIndex, LPTSTR lpComponentBuf, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf) {
	MsivEnumComponentsFromFeature = (T_MsivEnumComponentsFromFeature)Bind_MSISPYU(TEXT("MsivEnumComponentsFromFeature"));
	MsivEnumComponentsFromFeature = (MsivEnumComponentsFromFeature)?MsivEnumComponentsFromFeature:L_MsivEnumComponentsFromFeature;
	assert(MsivEnumComponentsFromFeature != 0);
	return MsivEnumComponentsFromFeature ? (*MsivEnumComponentsFromFeature)(szProduct, szFeature, iComponentIndex, lpComponentBuf, lpComponentNameBuf, pcchComponentNameBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivEnumComponents(const DWORD iComponentIndex, LPTSTR lpComponentBuf) {
	MsivEnumComponents = (T_MsivEnumComponents)Bind_MSISPYU(TEXT("MsivEnumComponents"));
	MsivEnumComponents = (MsivEnumComponents)?MsivEnumComponents:L_MsivEnumComponents;
	assert(MsivEnumComponents != 0);
	return MsivEnumComponents ? (*MsivEnumComponents)(iComponentIndex, lpComponentBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentName, DWORD *cchComponentName) {
	MsivGetComponentName = (T_MsivGetComponentName)Bind_MSISPYU(TEXT("MsivGetComponentName"));
	MsivGetComponentName = (MsivGetComponentName)?MsivGetComponentName:L_MsivGetComponentName;
	assert(MsivGetComponentName != 0);
	return MsivGetComponentName ? (*MsivGetComponentName)(szComponentId, lpComponentName, cchComponentName) : 0;
}



UINT WINAPI MSISPYU::F_MsivGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	MsivGetProductInfo = (T_MsivGetProductInfo)Bind_MSISPYU(TEXT("MsivGetProductInfo"));
	MsivGetProductInfo = (MsivGetProductInfo)?MsivGetProductInfo:L_MsivGetProductInfo;
	assert(MsivGetProductInfo != 0);
		return MsivGetProductInfo ? (*MsivGetProductInfo)(szProduct, szAttribute, lpValueBuf, pcchValueBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivGetFeatureInfo(LPCTSTR szProduct, LPCTSTR szFeature, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	MsivGetFeatureInfo = (T_MsivGetFeatureInfo)Bind_MSISPYU(TEXT("MsivGetFeatureInfo"));
	MsivGetFeatureInfo = (MsivGetFeatureInfo)?MsivGetFeatureInfo:L_MsivGetFeatureInfo;
	assert(MsivGetFeatureInfo != 0);
	return MsivGetFeatureInfo ? (*MsivGetFeatureInfo)(szProduct, szFeature, szAttribute, lpValueBuf, pcchValueBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivOpenDatabase(LPCTSTR szDatabase) {
	MsivOpenDatabase = (T_MsivOpenDatabase)Bind_MSISPYU(TEXT("MsivOpenDatabase"));
	MsivOpenDatabase = (MsivOpenDatabase)?MsivOpenDatabase:L_MsivOpenDatabase;
	assert(MsivOpenDatabase != 0);
	return MsivOpenDatabase ? (*MsivOpenDatabase)(szDatabase) : 0;
}



UINT WINAPI MSISPYU::F_MsivCloseDatabase() {
	MsivCloseDatabase = (T_MsivCloseDatabase)Bind_MSISPYU(TEXT("MsivCloseDatabase"));
	MsivCloseDatabase = (MsivCloseDatabase)?MsivCloseDatabase:L_MsivCloseDatabase;
	assert(MsivCloseDatabase != 0);
	return MsivCloseDatabase ? (*MsivCloseDatabase)() : 0;
}



UINT WINAPI MSISPYU::F_MsivGetDatabaseName(LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	MsivGetDatabaseName = (T_MsivGetDatabaseName)Bind_MSISPYU(TEXT("MsivGetDatabaseName"));
	MsivGetDatabaseName = (MsivGetDatabaseName)?MsivGetDatabaseName:L_MsivGetDatabaseName;
	assert(MsivGetDatabaseName != 0);
	return MsivGetDatabaseName ? (*MsivGetDatabaseName)(lpValueBuf, pcchValueBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivEnumComponentsFromProduct(LPCTSTR szProductCode, const DWORD iComponentIndex, LPTSTR lpComponentBuf) {
	MsivEnumComponentsFromProduct = (T_MsivEnumComponentsFromProduct)Bind_MSISPYU(TEXT("MsivEnumComponentsFromProduct"));
	MsivEnumComponentsFromProduct = (MsivEnumComponentsFromProduct)?MsivEnumComponentsFromProduct:L_MsivEnumComponentsFromProduct;
	assert(MsivEnumComponentsFromProduct != 0);
	return MsivEnumComponentsFromProduct ? (*MsivEnumComponentsFromProduct)(szProductCode, iComponentIndex, lpComponentBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivSaveProfile(LPCTSTR szFileName) {
	MsivSaveProfile = (T_MsivSaveProfile)Bind_MSISPYU(TEXT("MsivSaveProfile"));
	MsivSaveProfile = (MsivSaveProfile)?MsivSaveProfile:L_MsivSaveProfile;
	assert(MsivSaveProfile != 0);
	return MsivSaveProfile ? (*MsivSaveProfile)(szFileName) : 0;
}



UINT WINAPI MSISPYU::F_MsivLoadProfile(LPTSTR szFileName) {
	MsivLoadProfile = (T_MsivLoadProfile)Bind_MSISPYU(TEXT("MsivLoadProfile"));
	MsivLoadProfile = (MsivLoadProfile)?MsivLoadProfile:L_MsivLoadProfile;
	assert(MsivLoadProfile != 0);
	return MsivLoadProfile ? (*MsivLoadProfile)(szFileName) : 0;
}



UINT WINAPI MSISPYU::F_MsivCloseProfile() {
	MsivCloseProfile = (T_MsivCloseProfile)Bind_MSISPYU(TEXT("MsivCloseProfile"));
	MsivCloseProfile = (MsivCloseProfile)?MsivCloseProfile:L_MsivCloseProfile;
	assert(MsivCloseProfile != 0);
	return MsivCloseProfile ? (*MsivCloseProfile)() : 0;
}



UINT WINAPI MSISPYU::F_MsivGetProfileName(LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	MsivGetProfileName = (T_MsivGetProfileName)Bind_MSISPYU(TEXT("MsivGetProfileName"));
	MsivGetProfileName = (MsivGetProfileName)?MsivGetProfileName:L_MsivGetProfileName;
	assert(MsivGetProfileName != 0);
	return MsivGetProfileName ? (*MsivGetProfileName)(lpValueBuf, pcchValueBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivGetFeatureUsage(LPCTSTR szProduct, LPCTSTR szFeature, DWORD *pdwUseCount, WORD *pwDateUsed) {
	MsivGetFeatureUsage = (T_MsivGetFeatureUsage)Bind_MSISPYU(TEXT("MsivGetFeatureUsage"));
	MsivGetFeatureUsage = (MsivGetFeatureUsage)?MsivGetFeatureUsage:L_MsivGetFeatureUsage;
	assert(MsivGetFeatureUsage != 0);
	return MsivGetFeatureUsage ? (*MsivGetFeatureUsage)(szProduct, szFeature, pdwUseCount, pwDateUsed) : 0;
}



UINT WINAPI MSISPYU::F_MsivEnumClients(LPCTSTR szComponent, DWORD iProductIndex, LPTSTR lpProductBuf) {
	MsivEnumClients = (T_MsivEnumClients)Bind_MSISPYU(TEXT("MsivEnumClients"));
	MsivEnumClients = (MsivEnumClients)?MsivEnumClients:L_MsivEnumClients;
	assert(MsivEnumClients != 0);
	return MsivEnumClients ? (*MsivEnumClients)(szComponent, iProductIndex, lpProductBuf) : 0;
}



UINT WINAPI MSISPYU::F_MsivGetProfileInfo(UINT iIndex, LPTSTR szValue, DWORD *pcchCount) {
	MsivGetProfileInfo = (T_MsivGetProfileInfo)Bind_MSISPYU(TEXT("MsivGetProfileInfo"));
	MsivGetProfileInfo = (MsivGetProfileInfo)?MsivGetProfileInfo:L_MsivGetProfileInfo;
	assert(MsivGetProfileInfo != 0);
	return MsivGetProfileInfo ? (*MsivGetProfileInfo)(iIndex, szValue, pcchCount) : 0;
}

UINT WINAPI MSISPYU::F_MsivEnumFilesFromComponent(LPCTSTR szComponentid, DWORD iFileIndex, LPTSTR lpValueBuf, DWORD *pcchCount) {
	MsivEnumFilesFromComponent = (T_MsivEnumFilesFromComponent)Bind_MSISPYU(TEXT("MsivEnumFilesFromComponent"));
	MsivEnumFilesFromComponent = (MsivEnumFilesFromComponent)?MsivEnumFilesFromComponent:L_MsivEnumFilesFromComponent;
	assert(MsivEnumFilesFromComponent != 0);
	return MsivEnumFilesFromComponent ? (*MsivEnumFilesFromComponent)(szComponentid, iFileIndex, lpValueBuf, pcchCount) : 0;
}



UINT WINAPI MSISPYU::F_MsivGetFileInfo(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, DWORD *pcchValueBuf) {
	MsivGetFileInfo = (T_MsivGetFileInfo)Bind_MSISPYU(TEXT("MsivGetFileInfo"));
	MsivGetFileInfo = (MsivGetFileInfo)?MsivGetFileInfo:L_MsivGetFileInfo;
	assert(MsivGetFileInfo != 0);
	return MsivGetFileInfo ? (*MsivGetFileInfo)(szProductCode, szComponentId, szFileName, szAttribute, lpValueBuf, pcchValueBuf) : 0;
}



INSTALLSTATE WINAPI MSISPYU::F_MsivQueryProductState(LPCTSTR szProduct) {
	MsivQueryProductState = (T_MsivQueryProductState)Bind_MSISPYU(TEXT("MsivQueryProductState"));
	MsivQueryProductState = (MsivQueryProductState)?MsivQueryProductState:L_MsivQueryProductState;
	assert(MsivQueryProductState != 0);
	return MsivQueryProductState ? (*MsivQueryProductState)(szProduct) : ERRORE;
}



INSTALLSTATE WINAPI MSISPYU::F_MsivQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature) {
	MsivQueryFeatureState = (T_MsivQueryFeatureState)Bind_MSISPYU(TEXT("MsivQueryFeatureState"));
	MsivQueryFeatureState = (MsivQueryFeatureState)?MsivQueryFeatureState:L_MsivQueryFeatureState;
	assert(MsivQueryFeatureState != 0);
	return MsivQueryFeatureState ? (*MsivQueryFeatureState)(szProduct, szFeature) : ERRORE;
}



INSTALLSTATE WINAPI MSISPYU::F_MsivLocateComponent(LPCTSTR szComponentId, LPTSTR lpPathBuf, DWORD *pcchBuf) {
	MsivLocateComponent = (T_MsivLocateComponent)Bind_MSISPYU(TEXT("MsivLocateComponent"));
	MsivLocateComponent = (MsivLocateComponent)?MsivLocateComponent:L_MsivLocateComponent;
	assert(MsivLocateComponent != 0);
	return MsivLocateComponent ? (*MsivLocateComponent)(szComponentId, lpPathBuf, pcchBuf) : ERRORE;
}


INSTALLSTATE WINAPI MSISPYU::F_MsivGetComponentPath(LPCTSTR szProductCode, LPCTSTR szComponentId, LPTSTR lpPathBuf, DWORD *pcchBuf) {
	MsivGetComponentPath = (T_MsivGetComponentPath)Bind_MSISPYU(TEXT("MsivGetComponentPath"));
	MsivGetComponentPath = (MsivGetComponentPath)?MsivGetComponentPath:L_MsivGetComponentPath;
	assert(MsivGetComponentPath != 0);
	return MsivGetComponentPath ? (*MsivGetComponentPath)(szProductCode, szComponentId, lpPathBuf, pcchBuf) : ERRORE;
}


USERINFOSTATE WINAPI MSISPYU::F_MsivGetUserInfo(LPCTSTR szProduct, LPTSTR lpUserNameBuf, DWORD *pcchUserNameBuf, 
												LPTSTR lpOrgNameBuf, DWORD *pcchOrgNameBuf, LPTSTR lpSerialBuf, DWORD *pcchSerialBuf) {
	MsivGetUserInfo = (T_MsivGetUserInfo)Bind_MSISPYU(TEXT("MsivGetUserInfo"));
	MsivGetUserInfo = (MsivGetUserInfo)?MsivGetUserInfo:L_MsivGetUserInfo;
	assert(MsivGetUserInfo != 0);
	return MsivGetUserInfo ? (*MsivGetUserInfo)(szProduct, lpUserNameBuf, pcchUserNameBuf, lpOrgNameBuf, pcchOrgNameBuf, lpSerialBuf, pcchSerialBuf) :  ERRORF;
}



//--------------------------------------------------------------------------------------------------
// InitUIControls
//	Initialisations of globals needed for functions in this file
//	This function must be called before any other functions in this file
//	are called
//	Sets the (global) g_hInstance

void InitUIControls(HINSTANCE hInst, HINSTANCE hResourceInstance) {
	g_hInstance = hInst;
	g_hResourceInst = hResourceInstance;
}



//--------------------------------------------------------------------------------------------------
// FillInText
//	Fills in textual description of an INSTALLSTATE, by loading the 
//	appropriate string on to the buffer (from the string resource table)

void FillInText(
		LPTSTR			lpValueBuf,			// size: MAX_STATUS_CHARS+1
  const	DWORD			cchValueBuf,
  const	INSTALLSTATE	iResult,
  const ITEMTYPE		itType
		) {


	if (!lpValueBuf)
		return;

		switch (iResult) {
		case INSTALLSTATE_BADCONFIG:	// configuration data corrupt
			LoadString(g_hResourceInst, IDS_IS_BADCONFIG, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_INCOMPLETE:	// installation suspended or in progress
			LoadString(g_hResourceInst, IDS_IS_INCOMPLETE, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_SOURCEABSENT:	// run from source, source is unavailable
			LoadString(g_hResourceInst, IDS_IS_SOURCEABSENT, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_MOREDATA:		// return buffer overflow
			LoadString(g_hResourceInst, IDS_IS_MOREDATA, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_INVALIDARG:	// invalid function argument
			LoadString(g_hResourceInst, IDS_IS_INVALIDARG, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_UNKNOWN:		// unrecognized product or feature
			switch (itType) {
			case ITEMTYPE_COMPONENT:
					LoadString(g_hResourceInst, IDS_IS_UNKNOWNCOMPONENT, lpValueBuf, cchValueBuf);
					break;
				
			case ITEMTYPE_FEATURE:
					LoadString(g_hResourceInst, IDS_IS_UNKNOWNFEATURE, lpValueBuf, cchValueBuf);
					break;

			case ITEMTYPE_PRODUCT:
					LoadString(g_hResourceInst, IDS_IS_UNKNOWNPRODUCT, lpValueBuf, cchValueBuf);
					break;
			default:
					LoadString(g_hResourceInst, IDS_IS_UNKNOWN, lpValueBuf, cchValueBuf);
					break;

			}
			break;

		case INSTALLSTATE_BROKEN:		// broken
			LoadString(g_hResourceInst, IDS_IS_BROKEN, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_ADVERTISED:	// advertised
			LoadString(g_hResourceInst, IDS_IS_ADVERTISED, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_ABSENT:		// uninstalled
			LoadString(g_hResourceInst, IDS_IS_ABSENT, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_LOCAL:		// installed on local drive
			LoadString(g_hResourceInst, IDS_IS_LOCAL, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_SOURCE:		// run from source, CD or net
			LoadString(g_hResourceInst, IDS_IS_SOURCE, lpValueBuf, cchValueBuf);
			break;

		case INSTALLSTATE_DEFAULT:		// use default, local or source
			LoadString(g_hResourceInst, IDS_IS_DEFAULT, lpValueBuf, cchValueBuf);
			break;

//		case INSTALLSTATE_LOCKCACHE:	// lock source files in client cache 
//			wsprintf(lpValueBuf, TEXT("Lock source files in client cache"));
//			break;

//		case INSTALLSTATE_FREECACHE:	// free source files from client cache 
//			wsprintf(lpValueBuf, TEXT("Free source files from client cache"));
//			break;

		default:						// unknown?
			LoadString(g_hResourceInst, IDS_IS_UNDETERMINED, lpValueBuf, cchValueBuf);
			break;

		}

	return;
}


//--------------------------------------------------------------------------------------------------
// FindBasePath
//	Strips off the filename at the end ofszFullPath to return the directory
//	Used by functions that check files of a component- the filetables
//	contain just the filename, and MsiLocateComponent provides the full
//	path (with the keyfile name at the end). This function chops off the
//	key file name and returns the directory name to which filenames can be
//	concatenated

void FindBasePath(
		LPTSTR	szFullPath, 
		LPTSTR	lpBasePath
		) {

	// make sure parameters passed in are valid
	if ((!szFullPath) || (!lpBasePath))
		return;

	UINT iLength = lstrlen(szFullPath);

	while ((szFullPath[iLength] != '\\') && (iLength>0))
		iLength--;

	lstrcpyn(lpBasePath, szFullPath, iLength+1);
	lstrcat(lpBasePath, TEXT("\\"));

}


//--------------------------------------------------------------------------------------------------
// InitListViewImageLists
//	Adds the image (icon) list to the list view window

BOOL InitListViewImageLists(
		HWND		hwndListView
		) {

	HIMAGELIST hImL;	// handle of image list 
	HICON hIcon;		// handle of icon

	// create the image list. 
	if ((hImL = ImageList_Create(CX_BITMAP, CY_BITMAP, 
		ILC_MASK|ILC_COLOR, NUM_LISTVIEWICONS, 0)) == NULL)
		return FALSE; 

	// add the icons
	for (int iCount = LVICON_COMPONENT; iCount <= LVICON_ABSENTCOMPONENT; iCount++) {
		hIcon = LoadIcon (g_hResourceInst, MAKEINTRESOURCE(IDI_COMPONENT+iCount));
		ImageList_AddIcon(hImL, hIcon); 
		DeleteObject(hIcon); 
	}

	// make sure all icons were added- return False otherwise
	if (ImageList_GetImageCount(hImL) < NUM_LISTVIEWICONS)
		return FALSE; 

	// associate the image list with the list-view control. 
	ListView_SetImageList(hwndListView, hImL, LVSIL_SMALL); 

	return TRUE; 
} 

	
//--------------------------------------------------------------------------------------------------
// InitFileListWindow
//	Creates the columns and column headers for the file-list window

void InitFileListWindow(
		HWND	hwndList
		) {

    DWORD dwStyle = GetWindowLong(hwndList, GWL_STYLE);

    if ((dwStyle & LVS_TYPEMASK) != LVS_REPORT)
        SetWindowLong(hwndList, GWL_STYLE,
           (dwStyle & ~LVS_TYPEMASK)  | WS_BORDER | 
                    WS_TABSTOP | LVS_REPORT | LVS_SINGLESEL | 
					LVS_SORTASCENDING | LVS_NOLABELWRAP |
					LVS_AUTOARRANGE | LVS_EDITLABELS);

	// add the image-list
	InitListViewImageLists(hwndList);

	RECT rcl;
	GetClientRect(hwndList, &rcl);
	UINT iWidth = rcl.right - rcl.left;

	// load the column headers from string table
	TCHAR	szColumnHeader0[MAX_HEADER+1];
	TCHAR	szColumnHeader1[MAX_HEADER+1];
	TCHAR	szColumnHeader2[MAX_HEADER+1];
	TCHAR	szColumnHeader3[MAX_HEADER+1];

	LoadString(g_hResourceInst, IDS_FILELISTHDR_COMPONENT_NAME,  szColumnHeader0, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_FILE_TITLE, szColumnHeader1, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_EXPECTED_SIZE,  szColumnHeader2, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_FILE_PATH,  szColumnHeader3, MAX_HEADER+1);

	// create the columns 
	LV_COLUMN lvColumn;									// list view column structure
	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvColumn.fmt = LVCFMT_LEFT;							// left-align column
    lvColumn.cx = (2*iWidth)/7+2;						// width of column in pixels
	lvColumn.pszText=szColumnHeader0;					// set the column header text
	lvColumn.iSubItem = 0;								// set the column position (index)
	ListView_InsertColumn(hwndList, 0, &lvColumn);		// and finally insert it

	lvColumn.pszText=szColumnHeader1;					// set the column header text
    lvColumn.cx = (2*iWidth)/7-10;						// width of column in pixels
	lvColumn.iSubItem = 1;								// set the column position (index)
	ListView_InsertColumn(hwndList, 1, &lvColumn);		// and finally insert it


	lvColumn.pszText=szColumnHeader2;
 	lvColumn.fmt = LVCFMT_RIGHT;						// right-align column
    lvColumn.cx = iWidth/7+20;
	lvColumn.iSubItem = 2;
	ListView_InsertColumn(hwndList, 2, &lvColumn);

	lvColumn.pszText=szColumnHeader3;
	lvColumn.fmt = LVCFMT_LEFT;							// left-align column
    lvColumn.cx = iWidth/2;
	lvColumn.iSubItem = 3;
	ListView_InsertColumn(hwndList, 3, &lvColumn);

}


//--------------------------------------------------------------------------------------------------
// InitFileVerifyWindow
//	Creates the columns and column headers for the verify-files window

void InitFileVerifyWindow(
		HWND	hwndList
		) {

	RECT rcl;
	GetClientRect(hwndList, &rcl);
	UINT iWidth = rcl.right - rcl.left;

	// load in the column headers from the string table resource
	TCHAR	szColumnHeader0[MAX_HEADER+1];
	TCHAR	szColumnHeader1[MAX_HEADER+1];
	TCHAR	szColumnHeader2[MAX_HEADER+1];
	TCHAR	szColumnHeader3[MAX_HEADER+1];
	TCHAR	szColumnHeader4[MAX_HEADER+1];
	TCHAR	szColumnHeader5[MAX_HEADER+1];
	TCHAR	szColumnHeader6[MAX_HEADER+1];
	TCHAR	szColumnHeader7[MAX_HEADER+1];

	LoadString(g_hResourceInst, IDS_FILELISTHDR_COMPONENT_NAME,		szColumnHeader0, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_FILE_TITLE,	szColumnHeader1, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_FILE_PATH,		szColumnHeader2, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_EXPECTED_SIZE,		szColumnHeader3, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_CURRENT_SIZE,		szColumnHeader4, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_CREATED,	szColumnHeader5, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_LASTWRITE,	szColumnHeader6, MAX_HEADER+1);
	LoadString(g_hResourceInst, IDS_FILELISTHDR_LASTACCESS,	szColumnHeader7, MAX_HEADER+1);


	// create the columns
	LV_COLUMN lvColumn;									// list view column structure
	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvColumn.fmt = LVCFMT_LEFT;							// left-align column
	lvColumn.cx =iWidth/8;								// width of column in pixels
	lvColumn.pszText=szColumnHeader0;					// set the column header text
	lvColumn.iSubItem = 0;								// set the column position (index)
	ListView_InsertColumn(hwndList, 0, &lvColumn);		// and finally insert it

	lvColumn.pszText=szColumnHeader1;
	lvColumn.fmt = LVCFMT_LEFT;							// left-align column
	lvColumn.cx = iWidth/8;
	lvColumn.iSubItem = 1;
	ListView_InsertColumn(hwndList, 1, &lvColumn);


	lvColumn.pszText=szColumnHeader2;
	lvColumn.fmt = LVCFMT_LEFT;							// left-align column
    lvColumn.cx = iWidth/6;
	lvColumn.iSubItem = 2;
	ListView_InsertColumn(hwndList, 2, &lvColumn);

	
	lvColumn.pszText=szColumnHeader3;
	lvColumn.fmt = LVCFMT_RIGHT;						// right-align column
	lvColumn.cx = iWidth/12;
	lvColumn.iSubItem = 3;
	ListView_InsertColumn(hwndList, 3, &lvColumn);

	lvColumn.pszText=szColumnHeader4;
	lvColumn.fmt = LVCFMT_RIGHT;						// right-align column
	lvColumn.cx = iWidth/12 -10;
	lvColumn.iSubItem = 2;
	ListView_InsertColumn(hwndList, 4, &lvColumn);

	lvColumn.pszText=szColumnHeader5;
	lvColumn.fmt = LVCFMT_LEFT;							// left-align column
	lvColumn.cx = iWidth/8;
	lvColumn.iSubItem = 2;
	ListView_InsertColumn(hwndList, 5, &lvColumn);

	lvColumn.pszText=szColumnHeader6;
	lvColumn.fmt = LVCFMT_LEFT;							// left-align column
	lvColumn.cx = iWidth/8;
	lvColumn.iSubItem = 2;
	ListView_InsertColumn(hwndList, 6, &lvColumn);

	lvColumn.pszText=szColumnHeader7;
	lvColumn.fmt = LVCFMT_LEFT;							// left-align column
	lvColumn.cx = iWidth/8;
	lvColumn.iSubItem = 2;
	ListView_InsertColumn(hwndList, 7, &lvColumn);
} 


//--------------------------------------------------------------------------------------------------
// CompareDates
//	Compares two system dates
//	earlier < later

int CompareDates(SYSTEMTIME	st1, SYSTEMTIME st2) {

	TCHAR	szDate1[30];
	TCHAR	szDate2[30];

	wsprintf(szDate1, TEXT("%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d"),
		st1.wYear, st1.wMonth, st1.wDay, 
		st1.wHour, st1.wMinute, st1.wSecond);

	wsprintf(szDate2, TEXT("%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d"),
		st2.wYear, st2.wMonth, st2.wDay, 
		st2.wHour, st2.wMinute, st2.wSecond);

	return lstrcmpi(szDate1, szDate2);

}


//--------------------------------------------------------------------------------------------------
// ClearFileList
//	Deletes the FileInfoStruct pointed to by the lParam of each row in
//	the list window. This function does not actually delete the entries
//	in the list window (Call ListView_DeleteAllItems after this for that)

void ClearFileList(HWND hwndList) {

	int iCount = 0;

	LV_ITEM	lvItem;
	lvItem.iItem	= iCount++;
	lvItem.iSubItem	= 0;
	lvItem.mask		= LVIF_PARAM;

	// get each row in the list
	while (ListView_GetItem(hwndList, &lvItem)) {

		// if lParam exists, typecast and delete memory it points to
		if (lvItem.lParam)
			delete (FileInfoStruct *) lvItem.lParam;

		// prepare to fetch next row in list
		lvItem.iItem	= iCount++;
		lvItem.iSubItem	= 0;
		lvItem.mask		= LVIF_PARAM;
	}
}


//--------------------------------------------------------------------------------------------------
// FileCompareProc
//	Callback to compare specified columns of the file-list and verify-files window
//	Called when user clicks on the column header of the list to sort by those columns
//	lParamSort contains information about the columns to compare-
//	if lParamSort >100, column to sort = lParamSort-100, DESCENDING
//	if lParamSort <100, column to sort = lParamSort, ASCENDING

INT_PTR CALLBACK FileCompareProc(
		LPARAM lParam1, 
		LPARAM lParam2, 
		LPARAM lParamSort
		) {

	FileInfoStruct *pInfo1 = (FileInfoStruct *)lParam1;
	FileInfoStruct *pInfo2 = (FileInfoStruct *)lParam2;
	LPTSTR lpStr1, lpStr2;
	int iResult=0;
	BOOL fRev=FALSE;

	// check sort order- ascending (lParamSort < 100) or descending (lParamSort >= 100)
	if (lParamSort >=100) {
		fRev=TRUE;
		lParamSort -=100;
	}

	if (pInfo1 && pInfo2) {
		switch( lParamSort)	{
			case 0:										// compare component names
				lpStr1 = pInfo1->szComponentName;
				lpStr2 = pInfo2->szComponentName;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

			case 1: 									// compare file titles
				lpStr1 = pInfo1->szTitle;
				lpStr2 = pInfo2->szTitle;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

			case 2: 									// compare file path
				lpStr1 = pInfo1->szLocation;
				lpStr2 = pInfo2->szLocation;
				iResult = lstrcmpi(lpStr1, lpStr2);
			break;

			case 3:   									// compare expected file sizes
				iResult = _ttoi(pInfo1->szExpectedSize)-_ttoi(pInfo2->szExpectedSize);
				break;

			case 4:   									// compare actual file sizes
				iResult = _ttoi(pInfo1->szActualSize)-_ttoi(pInfo2->szActualSize);
				break;

			case 5:   									// compare creation dates
				iResult = CompareDates(pInfo1->stCreated, pInfo2->stCreated);
				break;

			case 6:    									// compare last modification dates
				iResult = CompareDates(pInfo1->stLastModified, pInfo2->stLastModified);
				break;

			case 7:    									// compare last access dates
				iResult = CompareDates(pInfo1->stLastAccessed, pInfo2->stLastAccessed);
				break;

			default:
				iResult = 0;
				break;

		}

	}


	// if sort is in descending order, invert iResult
	if (fRev)
		iResult = 0-iResult;

	return (iResult);
}



//--------------------------------------------------------------------------------------------------
// ListFiles
//	Displays the file information in the listwindow hwndList
//	This is the File-List Window, in the File List tab of the property sheets

void ListFiles(
		HWND	hwndList,
		LPCTSTR	szProductCode,
		LPTSTR	szComponentId,
		LPTSTR	szBasePath,
		UINT	*iTotalFiles,
		UINT	*iTotalSize
		) {

	TCHAR	szFileTitle[MAX_PATH+1];
	TCHAR	szFileName[MAX_PATH+1];
	UINT	iCount=0;
	DWORD	cchCount=MAX_PATH+1;

	(*iTotalSize) = 0;

	// repeat till all files have been displayed
	while (MSISPYU::MsivEnumFilesFromComponent(szComponentId, iCount++, szFileTitle, &cchCount) == ERROR_SUCCESS) {

		FileInfoStruct *pFileInfo = new FileInfoStruct;
		lstrcpy(pFileInfo->szProductCode, szProductCode);
		lstrcpy(pFileInfo->szComponentId, szComponentId);
		lstrcpy(pFileInfo->szTitle, szFileTitle);
		lstrcpy(pFileInfo->szLocation, szBasePath);
	
		cchCount=MAX_COMPONENT_CHARS+1;
		MSISPYU::MsivGetComponentName(szComponentId, pFileInfo->szComponentName, &cchCount);

		// create the list-item
		LV_ITEM	lvItem;
		lvItem.iItem		= 0;
		lvItem.iSubItem		= 0;
		lvItem.iImage		= LVICON_FILE;
		lvItem.pszText		= pFileInfo->szComponentName;
		lvItem.cchTextMax	= lstrlen(pFileInfo->szComponentName);
		lvItem.lParam		= (LPARAM) pFileInfo;
		lvItem.mask			= LVIF_TEXT | LVIF_IMAGE |LVIF_PARAM;

		// add the file title
		int iIndex = ListView_InsertItem(hwndList, &lvItem);
		ListView_SetItemText(hwndList, iIndex, 1, pFileInfo->szTitle);

		// add the file size
		cchCount = sizeof(pFileInfo->szExpectedSize);
//		MSISPYU::MsivGetFileInfo(szComponentId, pFileInfo->szTitle, FILEPROPERTY_SIZE, pFileInfo->szExpectedSize, &cchCount);
		MSISPYU::MsivGetFileInfo(szProductCode, szComponentId, pFileInfo->szTitle, FILEPROPERTY_SIZE, pFileInfo->szExpectedSize, &cchCount);
		ListView_SetItemText(hwndList, iIndex, 2, pFileInfo->szExpectedSize);

		// keep track of total file size
		(*iTotalSize) += _ttoi(pFileInfo->szExpectedSize);

		// add the file location
		cchCount=MAX_PATH+1;
//		MSISPYU::MsivGetFileInfo(szComponentId, pFileInfo->szTitle, FILEPROPERTY_NAME, szFileName, &cchCount);
		MSISPYU::MsivGetFileInfo(szProductCode, szComponentId, pFileInfo->szTitle, FILEPROPERTY_NAME, szFileName, &cchCount);
		lstrcat(pFileInfo->szLocation, szFileName);
		ListView_SetItemText(hwndList, iIndex, 3, pFileInfo->szLocation);


		// if it is the diagnostic mode, check the file status and display the appropriate icon
		// this makes the program slower- and is hence done only in diagnostic mode.
		// the same info can be obtained by clicking "verify files" in the property sheet
		// if msispy is not being used in the diagnostic mode

		if (g_modeCurrent == MODE_DIAGNOSTIC) {
			WIN32_FIND_DATA	fdFileData;
			BOOL			fBroken		= FALSE;

			cchCount = MAX_PATH+1;


			if (g_iDataSource == DS_PROFILE) {					// a profile is in use, get info from it

				TCHAR	szStatus[MAX_STATUS_CHARS+1];
				cchCount = MAX_STATUS_CHARS+1;
//				MSISPYU::MsivGetFileInfo(szComponentId, pFileInfo->szTitle, FILEPROPERTY_STATUS, szStatus, &cchCount);
				MSISPYU::MsivGetFileInfo(szProductCode, szComponentId, pFileInfo->szTitle, FILEPROPERTY_STATUS, szStatus, &cchCount);
				if (lstrcmp(szStatus, FILESTATUS_OKAY))
					fBroken=TRUE;
				
			}
			else {												// a database or the registry is in use

				// try finding the file, if it is not found it is broken
				if (FindFirstFile(pFileInfo->szLocation, &fdFileData) == INVALID_HANDLE_VALUE)
					fBroken=TRUE;
				else {

					// if file is found, check it's size. if size doesn't match expected size, 
					// file is broken
					wsprintf(pFileInfo->szActualSize, TEXT("%d"), (fdFileData.nFileSizeHigh * MAXDWORD) + fdFileData.nFileSizeLow);
					if (lstrcmp(pFileInfo->szExpectedSize, pFileInfo->szActualSize))
						fBroken=TRUE;
				}
			}

			// if file is broken, set the appropriate icon
			if (fBroken) {
				lvItem.iItem=iIndex;
				lvItem.mask=LVIF_IMAGE;
				lvItem.iImage = LVICON_BROKENFILE;
				ListView_SetItem(hwndList, &lvItem);
			}
			
		}

		cchCount=MAX_PATH+1;
	}

	// total number of files 
	*iTotalFiles=iCount-1;
} 


//--------------------------------------------------------------------------------------------------
// StringToDate
//	converts a string containing the time/date to a SYSTEMTIME struct
//	szDateStr must be of the form  "mm-dd-yyyy (hh:mm:ss)"

void StringToDate(
		LPCTSTR		szDateStr,				// must be of the form "mm-dd-yyyy (hh:mm:ss)"
		SYSTEMTIME	*stDate
		) {

	TCHAR	szDate[30];
	lstrcpy (szDate, szDateStr);

	stDate->wMonth = _ttoi(szDate);
	memmove(szDate, szDate+(sizeof(TCHAR)*3), lstrlen(szDate)-(sizeof(TCHAR)*2));		//unicode issue.

	stDate->wDay = _ttoi(szDate);
	memmove(szDate, szDate+(sizeof(TCHAR)*3), lstrlen(szDate)-(sizeof(TCHAR)*2));		//unicode issue.

	stDate->wYear = _ttoi(szDate);
	memmove(szDate, szDate+(sizeof(TCHAR)*6), lstrlen(szDate)-(sizeof(TCHAR)*5));		//unicode issue.

	stDate->wHour = _ttoi(szDate);
	memmove(szDate, szDate+(sizeof(TCHAR)*3), lstrlen(szDate)-(sizeof(TCHAR)*2));		//unicode issue.

	stDate->wMinute = _ttoi(szDate);
	memmove(szDate, szDate+(sizeof(TCHAR)*3), lstrlen(szDate)-(sizeof(TCHAR)*2));		//unicode issue.

	stDate->wSecond = _ttoi(szDate);
	memmove(szDate, szDate+(sizeof(TCHAR)*3), lstrlen(szDate)-(sizeof(TCHAR)*2));		//unicode issue.


}


void DateTimeToString(
  const SYSTEMTIME	*lpDateTime,
		LPTSTR		lpszDateTime,
		DWORD		cchDateTime,
		BOOL		fTime = TRUE
		) {

	TCHAR	szDateTime[MAX_PATH+1];

	GetDateFormat(g_lcidCurrentLocale, NULL, lpDateTime, NULL, szDateTime, MAX_PATH+1);

	if (fTime) {
		TCHAR	szTime[MAX_PATH+1];
		GetTimeFormat(g_lcidCurrentLocale, NULL, lpDateTime, NULL, szTime, MAX_PATH+1);
		lstrcat(szDateTime, TEXT(" ("));
		lstrcat(szDateTime, szTime);
		lstrcat(szDateTime, TEXT(")"));
	}

	lstrcpyn(lpszDateTime, szDateTime, cchDateTime);
}



//--------------------------------------------------------------------------------------------------
// HandleFileVerify
//	Verifies files on the current system and displays it in a pop-up window
//	This is the "Verify-Files" window brought up when the user clicks on the 
//	"Verify Files" button on the FileList tab of the property sheets
//	The hwndList window contains the list of files as created by the ListFiles
//	function above.

void HandleFileVerify(
		HWND	hDlg,
		HWND	hwndList 
		) {

	BOOL			fDone;
	UINT			iIndex;
	DWORD			cchCount;
	WIN32_FIND_DATA	fdFileData;
	RECT			rcl;
	TCHAR			szResultWindowCaption[MAX_HEADER+1];

	// get the metrics to determine the size of the new pop-up window
	hwndList = GetDlgItem(hDlg, IDC_FILELIST);
	GetClientRect(hDlg, &rcl);
	fDone=FALSE;
	iIndex=0;
	cchCount=MAX_PATH+1;

	// create the new pop-up window
	LoadString(g_hResourceInst, IDS_FILEVERIFY_CAPTION, szResultWindowCaption, MAX_MESSAGE+1);
	HWND hwndListNew = CreateWindowEx(WS_EX_CLIENTEDGE,
		WC_LISTVIEW,								// list view class
		szResultWindowCaption,
		WS_POPUP | WS_SIZEBOX | WS_CAPTION |
		WS_VISIBLE |  WS_SYSMENU | LVS_REPORT | 
		LVS_SINGLESEL | WS_HSCROLL | WS_VSCROLL |WS_BORDER ,
		rcl.left+10, rcl.top+50, 
		(rcl.right-rcl.left)*3, rcl.bottom-rcl.top,
		hDlg,
		NULL,
		g_hInstance,
		NULL );

	// make sure the window was created
	if (!hwndListNew)  {
		TCHAR	szErrorMsg[MAX_MESSAGE+1];
		LoadString(g_hResourceInst, IDS_FILELIST_ERROR_MESSAGE, szErrorMsg, MAX_MESSAGE+1);

		TCHAR	szErrorCaption[MAX_HEADER+1];
		LoadString(g_hResourceInst, IDS_FILELIST_ERROR_CAPTION, szErrorCaption, MAX_HEADER+1);

		MessageBox(NULL, szErrorMsg, szErrorCaption, MB_ICONSTOP | MB_OK);
	
		return;
	}

	// add the columns and images to it
	InitFileVerifyWindow(hwndListNew);
	InitListViewImageLists(hwndListNew);
	ShowWindow(hwndListNew, SW_SHOW);

	// repeat until all files in hwndlist have been verified
	while (!fDone) {
		BOOL	fBroken=FALSE;

		FileInfoStruct	*pFileInfo;
		LV_ITEM	lvItem;
		lvItem.iItem	= iIndex;
		lvItem.iSubItem	= 0;
		lvItem.mask		= LVIF_IMAGE | LVIF_PARAM;
			
		if (ListView_GetItem(hwndList, &lvItem)) {

			pFileInfo			= (FileInfoStruct *) lvItem.lParam;
			lvItem.pszText		= pFileInfo->szComponentName;
			lvItem.cchTextMax	= lstrlen(pFileInfo->szComponentName);
			lvItem.iSubItem		= 0;
			lvItem.mask			= LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
			int iIndexNew		= ListView_InsertItem(hwndListNew, &lvItem);

			// set columns 2, 3 and 4 of the verify files window- this is just a
			// copy of the info found in the list-files window
			ListView_SetItemText(hwndListNew, iIndexNew, 1, pFileInfo->szTitle);
			ListView_SetItemText(hwndListNew, iIndexNew, 2, pFileInfo->szLocation);
			ListView_SetItemText(hwndListNew, iIndexNew, 3, pFileInfo->szExpectedSize);

			// verify the file
			if (g_iDataSource == DS_PROFILE) {				// a profile is in use

				// the status of the file displayed is read in from the profile-
				// the status of the file on the current system does not matter
				TCHAR	szStatus[MAX_STATUS_CHARS+1];
				cchCount = MAX_STATUS_CHARS+1;
//				MSISPYU::MsivGetFileInfo(pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_STATUS, szStatus, &cchCount);
// stuck
				MSISPYU::MsivGetFileInfo(pFileInfo->szProductCode, pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_STATUS, szStatus, &cchCount);

				// check if the file is okay
				if (lstrcmp(szStatus, FILESTATUS_OKAY))
					fBroken=TRUE;
		
				if (!lstrcmp(szStatus,  FILESTATUS_FILENOTFOUND)) {

					// file was not found on the system on which the profile was saved
					fBroken=TRUE;
					ListView_SetItemText(hwndListNew, iIndexNew, 5, FILESTATUS_FILENOTFOUND);
				}
				else {

					// file was found- now display the file information (size, creation/modification/access time etc)
					TCHAR	szTempBuffer[MAX_PATH+1];
					DWORD	cchCount= MAX_PATH+1;

					// display actual size
//					MSISPYU::MsivGetFileInfo(pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_ACTUALSIZE, pFileInfo->szActualSize, &cchCount);
					MSISPYU::MsivGetFileInfo(pFileInfo->szProductCode, pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_ACTUALSIZE, pFileInfo->szActualSize, &cchCount);
					ListView_SetItemText(hwndListNew, iIndexNew, 4, pFileInfo->szActualSize);
					if (lstrcmp(pFileInfo->szExpectedSize, pFileInfo->szActualSize))
						fBroken=TRUE;

					// display file creation time
					cchCount= MAX_PATH+1;
//					MSISPYU::MsivGetFileInfo(pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_CREATIONTIME, szTempBuffer, &cchCount);
					MSISPYU::MsivGetFileInfo(pFileInfo->szProductCode, pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_CREATIONTIME, szTempBuffer, &cchCount);
					StringToDate(szTempBuffer, &pFileInfo->stCreated);
					DateTimeToString(&pFileInfo->stCreated, szTempBuffer, MAX_PATH+1);
					ListView_SetItemText(hwndListNew, iIndexNew, 5, szTempBuffer);

					// display last modification time
					cchCount= MAX_PATH+1;
//					MSISPYU::MsivGetFileInfo(pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_LASTWRITETIME, szTempBuffer, &cchCount);
					MSISPYU::MsivGetFileInfo(pFileInfo->szProductCode, pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_LASTWRITETIME, szTempBuffer, &cchCount);
					StringToDate(szTempBuffer, &pFileInfo->stLastModified);
					DateTimeToString(&pFileInfo->stLastModified, szTempBuffer, MAX_PATH+1);
					ListView_SetItemText(hwndListNew, iIndexNew, 6, szTempBuffer);

					// display last access time
					cchCount= MAX_PATH+1;
//					MSISPYU::MsivGetFileInfo(pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_LASTACCESSTIME, szTempBuffer, &cchCount);
					MSISPYU::MsivGetFileInfo(pFileInfo->szProductCode, pFileInfo->szComponentId, pFileInfo->szTitle, FILEPROPERTY_LASTACCESSTIME, szTempBuffer, &cchCount);
					StringToDate(szTempBuffer, &pFileInfo->stLastAccessed);
					DateTimeToString(&pFileInfo->stLastAccessed, szTempBuffer, MAX_PATH+1);
					ListView_SetItemText(hwndListNew, iIndexNew, 7, szTempBuffer);
				}
			}
			else {					// a database or the registry is in use- use current system to verify files

				// try finding the file. If file is not found, it's broken
				if (FindFirstFile(pFileInfo->szLocation, &fdFileData) == INVALID_HANDLE_VALUE) {
					fBroken =  TRUE;
					ListView_SetItemText(hwndListNew, iIndexNew, 5, FILESTATUS_FILENOTFOUND);

				}
				else {

					// file was found- now get the file information (size, creation/modification/access time etc)
					FILETIME	ftLocalTime;

					// display actual size
					wsprintf(pFileInfo->szActualSize, TEXT("%d"), (fdFileData.nFileSizeHigh * MAXDWORD) + fdFileData.nFileSizeLow);
					ListView_SetItemText(hwndListNew, iIndexNew, 4, pFileInfo->szActualSize);
					if (lstrcmp(pFileInfo->szExpectedSize, pFileInfo->szActualSize))
						fBroken=TRUE;

					// display file creation time
					TCHAR	szTempBuffer[30];
					FileTimeToLocalFileTime(&fdFileData.ftCreationTime, &ftLocalTime);
					FileTimeToSystemTime(&ftLocalTime, &pFileInfo->stCreated);
					DateTimeToString(&pFileInfo->stCreated, szTempBuffer, MAX_PATH+1);
					ListView_SetItemText(hwndListNew, iIndexNew, 5, szTempBuffer);

					// display last modification time
					FileTimeToLocalFileTime(&fdFileData.ftLastWriteTime, &ftLocalTime);
					FileTimeToSystemTime(&ftLocalTime, &pFileInfo->stLastModified);
					DateTimeToString(&pFileInfo->stLastModified, szTempBuffer, MAX_PATH+1);
					ListView_SetItemText(hwndListNew, iIndexNew, 6, szTempBuffer);

					// display last access time
					FileTimeToLocalFileTime(&fdFileData.ftLastAccessTime, &ftLocalTime);
					FileTimeToSystemTime(&ftLocalTime, &pFileInfo->stLastAccessed);
					DateTimeToString(&pFileInfo->stLastAccessed, szTempBuffer, MAX_PATH+1);
					ListView_SetItemText(hwndListNew, iIndexNew, 7, szTempBuffer);

				}
			}

			// if file is broken, show the appropriate icon
			if (fBroken) {
					lvItem.iImage = LVICON_BROKENFILE;
					lvItem.iItem=iIndexNew;
					lvItem.mask=LVIF_IMAGE;
					ListView_SetItem(hwndListNew, &lvItem);
			}
		}
		else
			// we finished going thru the files
			fDone=TRUE;
		iIndex++;
	}

}


//----------------------------------------------------------------------
// About
//	Brings up the About Dialogue Box

INT_PTR CALLBACK About(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	switch (message){
	case WM_INITDIALOG: {

		TCHAR	szUserName[MAX_HEADER+1];
		TCHAR	szCompany[MAX_HEADER+1];
		TCHAR	szProductId[MAX_GUID+1];
		TCHAR	szUserProp[(MAX_HEADER*2)+(MAX_GUID)+1];
		DWORD	cchCount1 = MAX_HEADER+1;
		DWORD	cchCount2 = MAX_HEADER+1;
		DWORD	cchCount3 = MAX_GUID+1;

		if (MsiGetUserInfo(g_szMyProductCode, szUserName, &cchCount1, 
			szCompany, &cchCount2, szProductId, &cchCount3)
			==	USERINFOSTATE_PRESENT)
			wsprintf(szUserProp, TEXT("%s\n%s\n%s"), szUserName, szCompany, szProductId);
		else
			lstrcpy(szUserProp, g_szNullString);
		SetDlgItemText(hDlg, IDT_ABT_USERINFO, szUserProp);

		TCHAR szAppName[MAX_HEADER+1], szAppVersion[MAX_HEADER+1], szAppData[MAX_HEADER+1];
		DWORD cchAppName = MAX_HEADER+1;
		DWORD cchAppVersion = MAX_HEADER+1;

		UINT iErrorCode;
		if (ERROR_SUCCESS == MsiGetProductInfo(g_szMyProductCode, INSTALLPROPERTY_PRODUCTNAME, szAppName, &cchAppName))
			if (ERROR_SUCCESS == (iErrorCode = MsiGetProductInfo(g_szMyProductCode, INSTALLPROPERTY_VERSIONSTRING, szAppVersion, &cchAppVersion)))
				wsprintf(szAppData, TEXT("%s (%s)"), szAppName, szAppVersion);
			else
				lstrcpy(szAppData, szAppName);
		else
			LoadString(g_spyGlobalData.hResourceInstance, IDS_APPNAME, szAppData, MAX_HEADER+1);
		SetDlgItemText(hDlg, IDT_ABT_APPNAME, szAppData);

		TCHAR	szCopyRight[MAX_MESSAGE+1];
		LoadString(g_spyGlobalData.hResourceInstance, IDS_COPYRIGHT, szCopyRight, MAX_HEADER+1);
		SetDlgItemText(hDlg, IDT_ABT_COPYRIGHT, szCopyRight);
        return(TRUE);
	}

	case WM_COMMAND:
		// LOWORD added for portability
		switch (LOWORD(wParam)) {
		case IDOK:
			EndDialog(hDlg,0);
			return(TRUE);
		break;
		}
	case WM_CLOSE:
		EndDialog(hDlg,0);
		return(TRUE);
		break; 

	}
	return(FALSE);
	UNREFERENCED_PARAMETER(lParam);
}



//--------------------------------------------------------------------------------------------------
// CompPropProc
//	Callback for page 1 of the property sheet for a component ("General" tab)
//	Sets the text to display current component's properties on the WM_INITDIALOG message

INT_PTR CALLBACK CompPropProc(
		HWND	 hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static ComponentInfoStruct *sInfo;
	static PROPSHEETPAGE * ps;

	switch (message) {
	case WM_INITDIALOG:
		// set the text to the current component's properties ...
		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (ComponentInfoStruct *) ps->lParam;
		SetDlgItemText(hDlg, IDT_C_NAME, sInfo->szComponentName);
		SetDlgItemText(hDlg, IDT_C_GUID, sInfo->szComponentId);
		SetDlgItemText(hDlg, IDT_C_STATUS, sInfo->szComponentStatus);
		SetDlgItemText(hDlg, IDT_C_LOCATION, sInfo->szComponentPath);
		return (TRUE);
		break;
	}
	return FALSE;

	UNREFERENCED_PARAMETER(wParam);
}


//--------------------------------------------------------------------------------------------------
// CompPropProc2
//	Callback for page 2 of the property sheet for a component ("File List" tab)
//	Sets the text to display current component's file-list on the WM_INITDIALOG message
//	It also traps LVN_COLUMNCLICK notification messages to sort by that column
//	and LVN_DELETEALLITEMS to call ClearFileList before deleting the items
//	The WM_COMMAND message is trapped and if the command is IDC_VERIFYFILES
//	it brings up the verify files window

INT_PTR CALLBACK CompPropProc2(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static ComponentInfoStruct	*sInfo;
	static PROPSHEETPAGE	*ps;
	static HWND				hwndList;
	static int				iCurrentSort	=0;
	
	switch (message) {
	case WM_INITDIALOG:

		// set the text to the current component's properties ...
		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (ComponentInfoStruct *) ps->lParam;
		SetDlgItemText(hDlg, IDT_FLIST_PFC_NAME, sInfo->szComponentName);

		// get a handle to the list window, and initialise it 
		hwndList = GetDlgItem(hDlg, IDC_FILELIST);
		InitFileListWindow(hwndList);
		
		UINT	iTotalFiles;
		UINT	iTotalSize;
		TCHAR	szBasePath[MAX_PATH+1];
	
		FindBasePath(sInfo->szComponentPath, szBasePath);

		// list all the files of the component
		ListFiles(hwndList, sInfo->szProductCode, sInfo->szComponentId, szBasePath, 
			&iTotalFiles, &iTotalSize);

		TCHAR	szTemp[MAX_HEADER+20];
		TCHAR	szTemp2[MAX_HEADER+1];
		TCHAR	szTemp3[MAX_HEADER+1];

		TCHAR	szTemp4[MAX_HEADER+1];
		TCHAR	szTemp5[MAX_HEADER+1];

		// display total files
		if (iTotalFiles == 1) 
			// singular- 1 file
			LoadString(g_hResourceInst, IDS_FILE, szTemp2, MAX_HEADER+1);
		else
			// plural- many files
			LoadString(g_hResourceInst, IDS_FILES, szTemp2, MAX_HEADER+1);

		wsprintf(szTemp, szTemp2, iTotalFiles);
		SetDlgItemText(hDlg, IDT_FLIST_TOTALFILES, szTemp);

		// display total filesizes
		if (iTotalSize==1) {
			LoadString(g_hResourceInst, IDS_BYTE, szTemp2, MAX_HEADER+1);
			wsprintf(szTemp, szTemp2, iTotalSize);
		}
		else if (iTotalSize > (1024*1024)) {		// > 1 MB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			LoadString(g_hResourceInst, IDS_MBYTE, szTemp3, MAX_HEADER+1);
			wsprintf(szTemp4, szTemp2, iTotalSize); 
			wsprintf(szTemp5, szTemp3, (int)((float) iTotalSize/ (float)(1024*1024)));
			wsprintf(szTemp, TEXT("%s (%s)"),  szTemp4, szTemp5);
		}
		else if (iTotalSize > 1024) {				// < 1MB, > 1KB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			LoadString(g_hResourceInst, IDS_KBYTE, szTemp3, MAX_HEADER+1);
			wsprintf(szTemp4, szTemp2, iTotalSize); 
			wsprintf(szTemp5, szTemp3, (int)((float) iTotalSize/ (float)1024));
			wsprintf(szTemp, TEXT("%s (%s)"),  szTemp4, szTemp5);
		}
		else {										// < 1KB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			wsprintf(szTemp, szTemp2, iTotalSize);
		}

		SetDlgItemText(hDlg, IDT_FLIST_TOTALSIZE, szTemp);
		return (TRUE);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {

		case IDC_VERIFYFILELIST:
			// user clicked on the "Verify Files" button
			HandleFileVerify(hDlg, hwndList);
			break;

		default:
			break;
		}

		break;

	case WM_NOTIFY:
		LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
		NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;

			switch(pLvdi->hdr.code) {
			case LVN_COLUMNCLICK:
				// user clicked on a column header- sort by it
				UINT	iTemp;
				// is it already sorted by this column? if so, reverse sort order
				if ((iCurrentSort==pNm->iSubItem) && (iCurrentSort < 100))
					iTemp=100;
				else
					iTemp=0;
				iCurrentSort=pNm->iSubItem + iTemp;

				// in the list window, columns 2 and 3 are swapped, account for this
				if ( pNm->hdr.hwndFrom == hwndList)
					if ((pNm->iSubItem) == 2)
						iTemp +=1;
					else if ((pNm->iSubItem) == 3)
						iTemp -=1;

				// call the sort function
				ListView_SortItems( pNm->hdr.hwndFrom,
									FileCompareProc,
									(LPARAM)((iTemp)+(pNm->iSubItem)));
				break;

			case LVN_DELETEALLITEMS:
				// if list-files window is being deleted- release memory pointed to by lParam
				if (pNm->hdr.hwndFrom == hwndList)
					ClearFileList(pNm->hdr.hwndFrom);
				return DefWindowProc (hDlg, message, wParam, lParam);
				break;

			default:
				break;
			}
		
		break;
	}

	return DefWindowProc (hDlg, message, wParam, lParam);
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
}


//--------------------------------------------------------------------------------------------------
// ShowComponentProp
//	Creates the property sheets for a component
//	Page 1: General, Page 2: File List

void ShowComponentProp(
		HWND		hwndListView, 
		HINSTANCE	hInst,
		int			iItemIndex
		) {

/*	old-way
	ComponentInfoStruct sCompInfo;

	// get the component ID and name for the component
	DWORD	cchCount=MAX_GUID+1;
	ListView_GetItemText(hwndListView, iItemIndex, 3, sCompInfo.szComponentId, cchCount);

	cchCount=MAX_COMPONENT_CHARS+1;
	ListView_GetItemText(hwndListView, iItemIndex, 0, sCompInfo.szComponentName, cchCount);
*/
	// get the component info out of the list control
	LVITEM lviGet;
	lviGet.iItem = iItemIndex;
	lviGet.iSubItem = 0;
	lviGet.mask = LVIF_PARAM;
	ListView_GetItem(g_spyGlobalData.hwndListView, &lviGet);

	ComponentInfoStruct* pCompInfo = (ComponentInfoStruct*)lviGet.lParam;

	// get the general info
	DWORD	cchCompLoc=MAX_PATH+1;
//	FillInText(sCompInfo.szComponentStatus, MAX_STATUS_CHARS+1, 
//		MSISPYU::MsivLocateComponent(sCompInfo.szComponentId, sCompInfo.szComponentPath, &cchCompLoc));
	FillInText(pCompInfo->szComponentStatus, MAX_STATUS_CHARS+1, 
		MSISPYU::MsivGetComponentPath(pCompInfo->szProductCode, pCompInfo->szComponentId, pCompInfo->szComponentPath, &cchCompLoc));


	PROPSHEETPAGE psp[2];
    PROPSHEETHEADER psh;

	ZeroMemory(&psp, (sizeof(PROPSHEETPAGE)*2));
	ZeroMemory(&psh, sizeof(PROPSHEETHEADER));

	TCHAR	szHeader[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_C_PROPERTIES_HEADER1, szHeader, MAX_HEADER+1);

	TCHAR	szHeader2[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_C_PROPERTIES_HEADER2, szHeader2, MAX_HEADER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_C_PROPERTIES_CAPTION, szCaption, MAX_HEADER+1);

	// page 1: General
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USETITLE;
    psp[0].hInstance = hInst;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_C_PROPERTIES);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = (DLGPROC) CompPropProc;
    psp[0].pszTitle =szHeader;
//    psp[0].lParam = (LONG_PTR) &sCompInfo;
    psp[0].lParam = (LONG_PTR) pCompInfo;
    
	// page 2: File List
    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USETITLE;
    psp[1].hInstance = hInst;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_PFC_FILELIST);
    psp[1].pszIcon = NULL;
    psp[1].pfnDlgProc = (DLGPROC) CompPropProc2;
    psp[1].pszTitle =szHeader2;
//    psp[1].lParam = (LONG_PTR) &sCompInfo;
    psp[1].lParam = (LONG_PTR) pCompInfo;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndListView;
    psh.hInstance = hInst;
    psh.pszIcon = NULL;
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

	PropertySheet(&psh);

}




//--------------------------------------------------------------------------------------------------
// FeatPropProc
//	Callback for page 1 of the properties dialog box for a feature ("General" tab)
//	Sets the text to display current feature's properties on the WM_INITDIALOG message

INT_PTR CALLBACK FeatPropProc(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static FeatureInfoStruct *sInfo;
	static PROPSHEETPAGE *ps;

	switch (message) {
	case WM_INITDIALOG:

		// set the text to the current feature's properties ...
		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (FeatureInfoStruct *) ps->lParam;

		SetDlgItemText(hDlg, IDT_F_NAME, sInfo->szFeatureName);
		SetDlgItemText(hDlg, IDT_F_TITLE, sInfo->szFeatureTitle);
		SetDlgItemText(hDlg, IDT_F_PARENT, sInfo->szFeaturePar);
		SetDlgItemText(hDlg, IDT_F_DESCRIPTION, sInfo->szFeatureDesc);
		SetDlgItemInt (hDlg, IDT_F_USAGE_COUNT, sInfo->iUseCount, FALSE);
		SetDlgItemText(hDlg, IDT_F_LASTUSED_DATE, sInfo->szDateUsed);
		SetDlgItemText(hDlg, IDT_F_STATUS, sInfo->szStatus);

		return (TRUE);
		break;
	}

	return FALSE;
	UNREFERENCED_PARAMETER(wParam);
}


//--------------------------------------------------------------------------------------------------
// GetComponentList
//	Recursively fills in the (global) hashtable g_htCompTable with components of 
//	the current feature and all its sub-features

void GetComponentList(
		LPCTSTR szProductCode,
		LPCTSTR	szParentF,
		FeatureTable *ft
		) {

	TCHAR	szChild[MAX_FEATURE_CHARS+1];
	DWORD	cbChild = MAX_FEATURE_CHARS + 1;

	// Get the features that have the specified parent
	while (ERROR_SUCCESS == ft->GetAndRemoveNextChild(szParentF, lstrlen(szParentF)+1, szChild, &cbChild)) {
		UINT	iCount=0;
		TCHAR	szComponentId[MAX_GUID+1];
		while (MSISPYU::MsivEnumComponentsFromFeature(szProductCode, szChild, iCount++, szComponentId, NULL, NULL)==ERROR_SUCCESS)
			if (MsivGetComponentPath(szProductCode, szComponentId, NULL, NULL) != INSTALLSTATE_NOTUSED)
	 			g_htCompTable.AddElement(szComponentId, lstrlen(szComponentId)+1);

		// recurse down to its children
		GetComponentList(szProductCode, szChild, ft);
	}			
}


//--------------------------------------------------------------------------------------------------
// HandleFeatureFileList
//	Displays the feature's files in the list window. If fSubFeatures is TRUE, 
//	the files of sub-features are included on the list as well.

void HandleFeatureFileList(
		HWND	hDlg,				
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName,
		BOOL	fSubFeatures			// include files of sub-features?
		) {

	// get a handle to the list window and clear it
	HWND hwndList = GetDlgItem(hDlg, IDC_FILELIST);
	ListView_DeleteAllItems(hwndList);
		
		TCHAR	szComponentId[MAX_GUID+1];
		TCHAR	szComponentName[MAX_COMPONENT_CHARS+1];
		TCHAR	szComponentPath[MAX_PATH+1];
		DWORD	cchCount;

		UINT	iTotalFiles	= 0;
		UINT	iTotalSize	= 0;
		UINT	iCount		= 0;

		UINT	iNumFiles	= 0;
		UINT	iFileSize	= 0;

		// get the components of the feature, and list each of their files
		while (MSISPYU::MsivEnumComponentsFromFeature(szProductCode, szFeatureName, 
			iCount++, szComponentId, NULL, NULL)==ERROR_SUCCESS) {

			cchCount=MAX_PATH+1;
			if (MsivGetComponentPath(szProductCode, szComponentId, szComponentPath, &cchCount) != INSTALLSTATE_NOTUSED) {

				cchCount=MAX_COMPONENT_CHARS+1;
				MSISPYU::MsivGetComponentName(szComponentId, szComponentName, &cchCount);

				TCHAR	szBasePath[MAX_PATH+1];
				FindBasePath(szComponentPath, szBasePath);
				ListFiles(hwndList, szProductCode, szComponentId, szBasePath, &iNumFiles, &iFileSize);

				iTotalFiles+=iNumFiles;
				iTotalSize+= iFileSize;
			}
		}


		// if sub-features are checked, fill in the hashtable with components of
		// the sub-features, and then display files for each component in the list
		// we need to have a hashtable to avoid repeating components as 
		// components may be shared between features
		iNumFiles = 0;
		iFileSize = 0;
		if (fSubFeatures) {

			DWORD iFeatureCount=0;
			TCHAR szFeature[MAX_FEATURE_CHARS+1];
			TCHAR szParent[MAX_FEATURE_CHARS+1];

			FeatureTable ft;
			// enumerate all the features of the current product
			while (MsivEnumFeatures(szProductCode, iFeatureCount++, szFeature, szParent) == ERROR_SUCCESS)
				ft.AddElement(szParent, lstrlen(szParent)+1, szFeature, lstrlen(szFeature)+1);
			
			g_htCompTable.Clear();
			GetComponentList(szProductCode, szFeatureName, &ft);

			ft.Clear();
					
			// list files for each component in the list
			iCount = 0;
			DWORD cbComponentId = MAX_COMPONENT_CHARS+1;
			while (ERROR_SUCCESS == g_htCompTable.EnumElements(iCount++, szComponentId, &cbComponentId)) {
				cchCount=MAX_COMPONENT_CHARS+1;
				MSISPYU::MsivGetComponentName(szComponentId, szComponentName, &cchCount);
				cchCount=MAX_PATH+1;
//				MSISPYU::MsivLocateComponent(szComponentId, szComponentPath, &cchCount);
				MSISPYU::MsivGetComponentPath(szProductCode, szComponentId, szComponentPath, &cchCount);

				UINT	iNumFiles;
				UINT	iFileSize;
				TCHAR	szBasePath[MAX_PATH+1];
				FindBasePath(szComponentPath, szBasePath);
				ListFiles(hwndList, szProductCode, szComponentId, szBasePath,
					&iNumFiles, &iFileSize);

				// keep track of total file size and number of files
				iTotalFiles+=iNumFiles;
				iTotalSize+= iFileSize;
				cbComponentId = MAX_COMPONENT_CHARS+1;

			}
		} 


		TCHAR	szTemp[30];
		TCHAR	szTemp2[MAX_HEADER+1];
		TCHAR	szTemp3[MAX_HEADER+1];
		TCHAR	szTemp4[MAX_HEADER+1];
		TCHAR	szTemp5[MAX_HEADER+1];

		// display total files
		if (iTotalFiles == 1) 
			// singular- 1 file
			LoadString(g_hResourceInst, IDS_FILE, szTemp2, MAX_HEADER+1);
		else
			// plural- many files
			LoadString(g_hResourceInst, IDS_FILES, szTemp2, MAX_HEADER+1);

		wsprintf(szTemp, szTemp2, iTotalFiles);
		SetDlgItemText(hDlg, IDT_FLIST_TOTALFILES, szTemp);

		// display total filesizes
		if (iTotalSize==1) {
			LoadString(g_hResourceInst, IDS_BYTE, szTemp2, MAX_HEADER+1);
			wsprintf(szTemp, szTemp2, iTotalSize);
		}
		else if (iTotalSize > (1024*1024)) {		// > 1 MB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			LoadString(g_hResourceInst, IDS_MBYTE, szTemp3, MAX_HEADER+1);
			wsprintf(szTemp4, szTemp2, iTotalSize); 
			wsprintf(szTemp5, szTemp3, (int)((float) iTotalSize/ (float)(1024*1024)));
			wsprintf(szTemp, TEXT("%s (%s)"),  szTemp4, szTemp5);
		}
		else if (iTotalSize > 1024) {				// < 1MB, > 1KB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			LoadString(g_hResourceInst, IDS_KBYTE, szTemp3, MAX_HEADER+1);
			wsprintf(szTemp4, szTemp2, iTotalSize); 
			wsprintf(szTemp5, szTemp3, (int)((float) iTotalSize/ (float)1024));
			wsprintf(szTemp, TEXT("%s (%s)"),  szTemp4, szTemp5);
		}
		else {										// < 1KB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			wsprintf(szTemp, szTemp2, iTotalSize);
		}

		SetDlgItemText(hDlg, IDT_FLIST_TOTALSIZE, szTemp);
}


//--------------------------------------------------------------------------------------------------
// FeatPropProc2
//	Callback for page 2 of the property sheet for a feature ("File List" tab)
//	Sets the text to display current feature's file-list on the WM_INITDIALOG message
//	It also traps LVN_COLUMNCLICK notification messages to sort by that column
//	and LVN_DELETEALLITEMS to call ClearFileList before deleting the items
//	The WM_COMMAND message is trapped and if the command is IDC_VERIFYFILES
//	it brings up the verify files window

INT_PTR CALLBACK  FeatPropProc2(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static FeatureInfoStruct	*sInfo;
	static PROPSHEETPAGE	*ps;
	static BOOL				fSubfeatures	=FALSE;
	static HWND				hwndList;
	static int				iCurrentSort	=0;

	switch (message) {
	case WM_INITDIALOG:

		// Set the text to the current feature's properties ...
		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (FeatureInfoStruct *) ps->lParam;
		SetDlgItemText(hDlg, IDT_FLIST_PFC_NAME, sInfo->szFeatureName);


		hwndList = GetDlgItem(hDlg, IDC_SUBFEATURES);
		ShowWindow(hwndList, SW_SHOW);

		if (fSubfeatures)
			SendDlgItemMessage(hDlg, IDC_SUBFEATURES, BM_SETCHECK, 1, 0);

		hwndList = GetDlgItem(hDlg, IDC_FILELIST);
		InitFileListWindow(hwndList);
		HandleFeatureFileList(hDlg, sInfo->szProductCode, sInfo->szFeatureName, fSubfeatures);

		return (TRUE);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {

		case IDC_VERIFYFILELIST:
			// user clicked on the "Verify Files" button
			HandleFileVerify(hDlg, hwndList);
			break;

		case IDC_SUBFEATURES:
			// user clicked on the "Include Sub-features" checkbox, toggle it and redraw the list
			fSubfeatures = !fSubfeatures;
			HandleFeatureFileList(hDlg, sInfo->szProductCode, sInfo->szFeatureName, fSubfeatures);
			break;
		}
		break;

	case WM_NOTIFY:
		LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
		NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;

			switch(pLvdi->hdr.code) {
			case LVN_COLUMNCLICK:
				// user clicked on the column header, sort by it
				UINT	iTemp;

				if ((iCurrentSort==pNm->iSubItem) && (iCurrentSort < 100))
					iTemp=100;
				else
					iTemp=0;
				iCurrentSort=pNm->iSubItem + iTemp;

				if ( pNm->hdr.hwndFrom == hwndList)
					if ((pNm->iSubItem) == 2)
						iTemp +=1;
					else if ((pNm->iSubItem) == 3)
						iTemp -=1;
				ListView_SortItems( pNm->hdr.hwndFrom, FileCompareProc, (LPARAM)((iTemp)+(pNm->iSubItem)));
				break;

			case LVN_DELETEALLITEMS:
				// list window is being destroyed- release memory pointed to by lParam
				if (pNm->hdr.hwndFrom == hwndList)
					ClearFileList(pNm->hdr.hwndFrom);
				return DefWindowProc (hDlg, message, wParam, lParam);
				break;

			default:
				break;
			}
		
		break;
	}
	return DefWindowProc (hDlg, message, wParam, lParam);
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
}


//--------------------------------------------------------------------------------------------------
// ShowFeatureProp
//	Creates the property sheets for a feature
//	Page 1: General, Page 2: File List

void ShowFeatureProp(
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName,
		HINSTANCE	hInst,
		HWND	hwndParent
		) {

	FeatureInfoStruct spyFeatureInfo;
	DWORD cchCount=MAX_FEATURE_CHARS+1;
	

	// fill up the FeatureInfoStruct
	TCHAR szDefault[MAX_DEFAULTTEXT+1];
	LoadString(g_hResourceInst, IDS_F_PROPERTIES_DEFAULT, szDefault, MAX_DEFAULTTEXT+1);

	lstrcpy(spyFeatureInfo.szProductCode, szProductCode);

	if (szFeatureName)
		lstrcpy(spyFeatureInfo.szFeatureName, szFeatureName);
	else
		lstrcpy(spyFeatureInfo.szFeatureName, szDefault);

	cchCount = MAX_FEATURE_CHARS+1;
	if (MSISPYU::MsivGetFeatureInfo(szProductCode, szFeatureName, FEATUREPROPERTY_PARENT, 
		spyFeatureInfo.szFeaturePar, &cchCount) != ERROR_SUCCESS)
		lstrcpy(spyFeatureInfo.szFeaturePar, szDefault);

	cchCount = MAX_PATH+1;
	if (MSISPYU::MsivGetFeatureInfo(szProductCode, szFeatureName, FEATUREPROPERTY_TITLE, 
		spyFeatureInfo.szFeatureTitle, &cchCount) != ERROR_SUCCESS)
		lstrcpy(spyFeatureInfo.szFeatureTitle, szDefault);

	cchCount = MAX_PATH+1;
	if (MSISPYU::MsivGetFeatureInfo(szProductCode, szFeatureName, FEATUREPROPERTY_DESC, 
		spyFeatureInfo.szFeatureDesc, &cchCount) != ERROR_SUCCESS)
		lstrcpy(spyFeatureInfo.szFeatureDesc, szDefault);
	

	WORD	wDateUsed;
	

	if (ERROR_SUCCESS != MSISPYU::MsivGetFeatureUsage(szProductCode, szFeatureName, &spyFeatureInfo.iUseCount, &wDateUsed)) 
	{
		wsprintf(spyFeatureInfo.szDateUsed, g_szNullString);
		spyFeatureInfo.iUseCount = 0;
	}
	else 
	{
		SYSTEMTIME	stSystemTime;
		FILETIME	ftFileTime;

		DosDateTimeToFileTime(wDateUsed, NULL, &ftFileTime);
		FileTimeToSystemTime(&ftFileTime, &stSystemTime);
		DateTimeToString(&stSystemTime, spyFeatureInfo.szDateUsed, 30, FALSE);
	}


	FillInText(spyFeatureInfo.szStatus, MAX_STATUS_CHARS+1, MSISPYU::MsivQueryFeatureState(szProductCode, szFeatureName), ITEMTYPE_FEATURE);


	// create the property sheet
	PROPSHEETPAGE psp[2];
    PROPSHEETHEADER psh;
	
	ZeroMemory(&psp, (sizeof(PROPSHEETPAGE)*2));
	ZeroMemory(&psh, sizeof(PROPSHEETHEADER));

	TCHAR	szHeader1[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_F_PROPERTIES_HEADER, szHeader1, MAX_HEADER+1);

	TCHAR	szHeader2[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_FILELISTHDR, szHeader2, MAX_HEADER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_F_PROPERTIES_CAPTION, szCaption, MAX_HEADER+1);

	// page 1: General
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USETITLE;
    psp[0].hInstance = hInst;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_F_PROPERTIES);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = (DLGPROC) FeatPropProc;
    psp[0].pszTitle = szHeader1;
    psp[0].lParam = (LONG_PTR) &spyFeatureInfo;

	// page 2: File List
    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USETITLE;
    psp[1].hInstance = hInst;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_PFC_FILELIST);
    psp[1].pszIcon = NULL;
    psp[1].pfnDlgProc = (DLGPROC) FeatPropProc2;
    psp[1].pszTitle = szHeader2;
    psp[1].lParam = (LONG_PTR) &spyFeatureInfo;

    
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndParent;
    psh.hInstance = hInst;
    psh.pszIcon = NULL;
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

	PropertySheet(&psh);
}


//--------------------------------------------------------------------------------------------------
// ProdPropProc
//	Callback for page 1 of the properties dialog box for a product ("General" tab)
//	Sets the text to display current product's properties on the WM_INITDIALOG message

INT_PTR CALLBACK ProdPropProc(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static ProductInfoStruct1 *sInfo;
	static PROPSHEETPAGE *ps;

	switch (message) {
	case WM_INITDIALOG:

		// Set the text to the current product's properties ...
		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (ProductInfoStruct1 *) ps->lParam;

		SetDlgItemText(hDlg, IDT_P1_NAME, sInfo->szProductName);
		SetDlgItemText(hDlg, IDT_P1_VERSION, sInfo->szProductVer);
		SetDlgItemText(hDlg, IDT_P1_PUBLISHER, sInfo->szPublisher);
		SetDlgItemText(hDlg, IDT_P1_PRODUCTCODE, sInfo->szProductCode);
		SetDlgItemText(hDlg, IDT_P1_LOCALPACKAGE, sInfo->szLocalPackage);;
		SetDlgItemText(hDlg, IDT_P1_USERNAME, sInfo->szProductUserName);
		SetDlgItemText(hDlg, IDT_P1_USERORG, sInfo->szProductUserComp);
		SetDlgItemText(hDlg, IDT_P1_PRODUCT_ID, sInfo->szProductId);
		SetDlgItemText(hDlg, IDT_P1_STATUS, sInfo->szStatus);
		return (TRUE);
		break;
	}

	return FALSE;
	UNREFERENCED_PARAMETER(wParam);
}


//--------------------------------------------------------------------------------------------------
// ProdPropProc2
//	Callback for page 2 of the properties dialog box for a product ("More Info" tab)
//	Sets the text to display current product's properties on the WM_INITDIALOG message

INT_PTR CALLBACK ProdPropProc2(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static ProductInfoStruct2 *sInfo;
	static PROPSHEETPAGE *ps;

	switch (message) {
	case WM_INITDIALOG:
		// Set the text to the current product's properties ...
		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (ProductInfoStruct2 *) ps->lParam;

		SetDlgItemText(hDlg, IDT_P2_NAME, sInfo->szProductName);
		SetDlgItemText(hDlg, IDT_P2_HELPLINK_URL, sInfo->szHelpURL);
		SetDlgItemText(hDlg, IDT_P2_INFO_URL, sInfo->szInfoURL);
		SetDlgItemText(hDlg, IDT_P2_UPDATES_URL, sInfo->szUpdateURL);
		SetDlgItemText(hDlg, IDT_P2_HELPPHONE, sInfo->szHelpPhone);
		SetDlgItemText(hDlg, IDT_P2_INSTALL_DATE, sInfo->szInstallDate);
		SetDlgItemText(hDlg, IDT_P2_INSTALL_SOURCE, sInfo->szInstallSrc);
		SetDlgItemText(hDlg, IDT_P2_INSTALL_TO, sInfo->szInstallLoc);
		SetDlgItemText(hDlg, IDT_P2_LANGUAGE, sInfo->szLanguage);

		return (TRUE);
		break;

	}

	return FALSE;
	UNREFERENCED_PARAMETER(wParam);
}


//--------------------------------------------------------------------------------------------------
// ProdPropProc3
//	Callback for page 3 of the property sheet for a product ("File List" tab)
//	Sets the text to display current product's file-list on the WM_INITDIALOG message
//	It also traps LVN_COLUMNCLICK notification messages to sort by that column
//	and LVN_DELETEALLITEMS to call ClearFileList before deleting the items
//	The WM_COMMAND message is trapped and if the command is IDC_VERIFYFILES
//	it brings up the verify files window

INT_PTR CALLBACK ProdPropProc3(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static ProductInfoStruct1 *sInfo;
	static PROPSHEETPAGE * ps;
	static HWND	hwndList;
	static int iCurrentSort = 0;

	switch (message) {
	case WM_INITDIALOG:
		// Set the text to the current product's properties ...
		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (ProductInfoStruct1 *) ps->lParam;
		SetDlgItemText(hDlg, IDT_FLIST_PFC_NAME, sInfo->szProductName);

		// get a handle to the list window, and initialise it 
		hwndList = GetDlgItem(hDlg, IDC_FILELIST);
		InitFileListWindow(hwndList);
		
		TCHAR	szComponentId[MAX_GUID+1];
		TCHAR	szComponentName[MAX_COMPONENT_CHARS+1];
		TCHAR	szComponentPath[MAX_PATH+1];
		DWORD	cchCount;

		UINT	iCount;
		UINT	iTotalFiles;
		UINT	iTotalSize;

		iCount		= 0;
		iTotalFiles	= 0;
		iTotalSize	= 0;

		// list files for all the components of the product
		while (MSISPYU::MsivEnumComponentsFromProduct(sInfo->szProductCode, iCount++, szComponentId)==ERROR_SUCCESS) {
			if (MsivGetComponentPath(sInfo->szProductCode, szComponentId, NULL, NULL) != INSTALLSTATE_NOTUSED) {

				cchCount=MAX_COMPONENT_CHARS+1;
				MSISPYU::MsivGetComponentName(szComponentId, szComponentName, &cchCount);

				cchCount=MAX_PATH+1;
	//			MSISPYU::MsivLocateComponent(szComponentId, szComponentPath, &cchCount);
				MSISPYU::MsivGetComponentPath(sInfo->szProductCode, szComponentId, szComponentPath, &cchCount);

				UINT	iNumFiles;
				UINT	iFileSize;
				TCHAR	szBasePath[MAX_PATH+1];
				FindBasePath(szComponentPath, szBasePath);
				ListFiles(hwndList, sInfo->szProductCode, szComponentId, szBasePath, &iNumFiles, &iFileSize);

				// keep track of the total number and sizes of files
				iTotalFiles += iNumFiles;
				iTotalSize  += iFileSize;
			}
		}

		TCHAR	szTemp[30];
		TCHAR	szTemp2[MAX_HEADER+1];
		TCHAR	szTemp3[MAX_HEADER+1];

		TCHAR	szTemp4[MAX_HEADER+1];
		TCHAR	szTemp5[MAX_HEADER+1];

		// display total files
		if (iTotalFiles == 1) 
			// singular- 1 file
			LoadString(g_hResourceInst, IDS_FILE, szTemp2, MAX_HEADER+1);
		else
			// plural- many files
			LoadString(g_hResourceInst, IDS_FILES, szTemp2, MAX_HEADER+1);

		wsprintf(szTemp, szTemp2, iTotalFiles);
		SetDlgItemText(hDlg, IDT_FLIST_TOTALFILES, szTemp);

		// display total filesizes
		if (iTotalSize==1) {
			LoadString(g_hResourceInst, IDS_BYTE, szTemp2, MAX_HEADER+1);
			wsprintf(szTemp, szTemp2, iTotalSize);
		}
		else if (iTotalSize > (1024*1024)) {		// > 1 MB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			LoadString(g_hResourceInst, IDS_MBYTE, szTemp3, MAX_HEADER+1);
			wsprintf(szTemp4, szTemp2, iTotalSize); 
			wsprintf(szTemp5, szTemp3, (int)((float) iTotalSize/ (float)(1024*1024)));
			wsprintf(szTemp, TEXT("%s (%s)"),  szTemp4, szTemp5);
		}
		else if (iTotalSize > 1024) {				// < 1MB, > 1KB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			LoadString(g_hResourceInst, IDS_KBYTE, szTemp3, MAX_HEADER+1);
			wsprintf(szTemp4, szTemp2, iTotalSize); 
			wsprintf(szTemp5, szTemp3, (int)((float) iTotalSize/ (float)1024));
			wsprintf(szTemp, TEXT("%s (%s)"),  szTemp4, szTemp5);
		}
		else {										// < 1KB
			LoadString(g_hResourceInst, IDS_BYTES, szTemp2, MAX_HEADER+1);
			wsprintf(szTemp, szTemp2, iTotalSize);
		}

		SetDlgItemText(hDlg, IDT_FLIST_TOTALSIZE, szTemp);
		return (TRUE);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {

		case IDC_VERIFYFILELIST:
			// user clicked on the "Verify Files" button
			HandleFileVerify(hDlg, hwndList);
			break;

		default:
			break;
		}

		break;

	case WM_NOTIFY:
		LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
		NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;

		switch(pLvdi->hdr.code) {
			case LVN_DELETEALLITEMS:
				// if list-files window is being deleted-  release memory pointed to by lParam
				if (pNm->hdr.hwndFrom == hwndList) 
					ClearFileList(pNm->hdr.hwndFrom);
				return 
					DefWindowProc (hDlg, message, wParam, lParam); 
				break;

			case LVN_COLUMNCLICK:
				// user clicked on a column header- sort by it
				UINT	iTemp;
				if ((iCurrentSort==pNm->iSubItem) && (iCurrentSort < 100))
					iTemp=100;
				else
					iTemp=0;
				iCurrentSort=pNm->iSubItem + iTemp;

				if ( pNm->hdr.hwndFrom == hwndList)
					if ((pNm->iSubItem) == 2)
						iTemp +=1;
					else if ((pNm->iSubItem) == 3)
						iTemp -=1;

				ListView_SortItems( pNm->hdr.hwndFrom, FileCompareProc,	(LPARAM)((iTemp)+(pNm->iSubItem)));
				break;

				

			default:
				break;
			}
		
		break;
	}
	return FALSE;
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
}


//--------------------------------------------------------------------------------------------------
// ShowProductProp
//	Creates the property sheets for a product
//	Page 1: General, Page 2: More Info, Page 3: File List

void ShowProductProp(
		LPCTSTR	szProductCode,
		HINSTANCE hInst,
		HWND	hwndParent
		) {

	ProductInfoStruct1	sProdInfo1;
	ProductInfoStruct2	sProdInfo2;

	// get all the required info and fill in the ProductInfoStructs
	TCHAR szDefault[MAX_DEFAULTTEXT+1];
	LoadString(g_hResourceInst, IDS_P_PROPERTIES_DEFAULT, szDefault, MAX_DEFAULTTEXT+1);

	DWORD cchCount = MAX_PRODUCT_CHARS+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, sProdInfo1.szProductName, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo1.szProductName, szDefault);

	cchCount = MAX_ATTRIB_CHARS+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_VERSIONSTRING, sProdInfo1.szProductVer, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo1.szProductVer, szDefault);


	cchCount = MAX_PRODUCT_CHARS+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PUBLISHER, sProdInfo1.szPublisher, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo1.szPublisher, szDefault);

	lstrcpy(sProdInfo1.szProductCode, szProductCode);

	cchCount = MAX_PATH+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_LOCALPACKAGE, sProdInfo1.szLocalPackage, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo1.szLocalPackage, szDefault);



	DWORD	cchCount1=100;
	DWORD	cchCount2=100;
	DWORD	cchCount3=MAX_GUID+1;
	if (MSISPYU::MsivGetUserInfo(szProductCode, sProdInfo1.szProductUserName, &cchCount1, 
		sProdInfo1.szProductUserComp, &cchCount2, sProdInfo1.szProductId, &cchCount3)
		!=	USERINFOSTATE_PRESENT) {
		lstrcpy(sProdInfo1.szProductUserName, szDefault);
		lstrcpy(sProdInfo1.szProductUserComp, szDefault);
		lstrcpy(sProdInfo1.szProductId, szDefault);
	}

	FillInText(sProdInfo1.szStatus, MAX_STATUS_CHARS+1, MSISPYU::MsivQueryProductState(szProductCode), ITEMTYPE_PRODUCT);


	cchCount = MAX_PRODUCT_CHARS+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, sProdInfo2.szProductName, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szProductName, szDefault);

	cchCount = MAX_PATH+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_HELPLINK, sProdInfo2.szHelpURL, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szHelpURL, szDefault);

	cchCount = MAX_PATH+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_URLINFOABOUT, sProdInfo2.szInfoURL, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szInfoURL, szDefault);

	cchCount = MAX_PATH+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_URLUPDATEINFO, sProdInfo2.szUpdateURL, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szUpdateURL, szDefault);

	cchCount = 30;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_HELPTELEPHONE, sProdInfo2.szHelpPhone, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szHelpPhone, szDefault);

	cchCount = 40;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLDATE, sProdInfo2.szInstallDate, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szInstallDate, szDefault);

	cchCount = MAX_PATH+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLSOURCE, sProdInfo2.szInstallSrc, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szInstallSrc, szDefault);

	cchCount = MAX_PATH+1;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLLOCATION, sProdInfo2.szInstallLoc, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szInstallLoc, szDefault);

	TCHAR szLang[10];
	cchCount = 10;
	if (MSISPYU::MsivGetProductInfo(szProductCode, INSTALLPROPERTY_LANGUAGE, szLang, &cchCount)
			!=ERROR_SUCCESS)
			lstrcpy(sProdInfo2.szLanguage, szDefault);
	else {
		cchCount = 100;
		GetLocaleInfo(_ttoi(szLang), LOCALE_SLANGUAGE, sProdInfo2.szLanguage, cchCount);
	}

	
	PROPSHEETPAGE psp[3];
	PROPSHEETHEADER psh;
	ZeroMemory(&psp, (sizeof(PROPSHEETPAGE)*3));
	ZeroMemory(&psh, sizeof(PROPSHEETHEADER));


	TCHAR	szHeader1[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_P_PROPERTIES_HEADER1, szHeader1, MAX_HEADER+1);

	TCHAR	szHeader2[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_P_PROPERTIES_HEADER2, szHeader2, MAX_HEADER+1);

	TCHAR	szHeader3[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_FILELISTHDR, szHeader3, MAX_HEADER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_P_PROPERTIES_CAPTION, szCaption, MAX_HEADER+1);


	// page 1: General
	psp[0].dwSize = sizeof(PROPSHEETPAGE);
	psp[0].dwFlags = PSP_USETITLE;
	psp[0].hInstance = hInst;
	psp[0].pszTemplate = MAKEINTRESOURCE(IDD_P_PROPERTIES1);
	psp[0].pszIcon = NULL;
	psp[0].pfnDlgProc = (DLGPROC) ProdPropProc;
	psp[0].pszTitle = szHeader1;
	psp[0].lParam = (LONG_PTR) &sProdInfo1;

	// page 2: More Info
	psp[1].dwSize = sizeof(PROPSHEETPAGE);
	psp[1].dwFlags = PSP_USETITLE;
	psp[1].hInstance = hInst;
	psp[1].pszTemplate = MAKEINTRESOURCE(IDD_P_PROPERTIES2);
	psp[1].pszIcon = NULL;
	psp[1].pfnDlgProc = (DLGPROC) ProdPropProc2;
	psp[1].pszTitle = szHeader2;
	psp[1].lParam = (LONG_PTR) &sProdInfo2;

	// page 3: File List
	psp[2].dwSize = sizeof(PROPSHEETPAGE);
	psp[2].dwFlags = PSP_USETITLE;
	psp[2].hInstance = hInst;
	psp[2].pszTemplate = MAKEINTRESOURCE(IDD_PFC_FILELIST);
//	psp[2].pszTemplate = MAKEINTRESOURCE(IDD_PRODPROP2);
	psp[2].pszIcon = NULL;
	psp[2].pfnDlgProc = (DLGPROC) ProdPropProc3;
	psp[2].pszTitle = szHeader3;
	psp[2].lParam = (LONG_PTR) &sProdInfo1;


	psh.dwSize = sizeof(PROPSHEETHEADER);
	psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
	psh.hwndParent = hwndParent;
	psh.hInstance = hInst;
	psh.pszIcon = NULL;
	psh.pszCaption = szCaption;
	psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
	psh.ppsp = (LPCPROPSHEETPAGE) &psp;

	PropertySheet(&psh);
}


//--------------------------------------------------------------------------------------------------
// DBPropProc
//	Callback for page 1 of the properties dialog box for a database ("General" tab)
//	Sets the text to display current database properties on the WM_INITDIALOG message

INT_PTR CALLBACK DBPropProc(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static MSIPackageInfoStruct *sInfo;
	static PROPSHEETPAGE *ps;

	switch (message) {
	case WM_INITDIALOG:

		// Set the text to the database properties ...

		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (MSIPackageInfoStruct *) ps->lParam;

		for (int iCount = 0; iCount <21; iCount++) {
			SetDlgItemText(hDlg, IDT_MSI_PROPERTY+iCount, sInfo->rgszInfo[iCount]);

		}
		
		return (TRUE);
		break;
	}

	return FALSE;
	UNREFERENCED_PARAMETER(wParam);
}


//--------------------------------------------------------------------------------------------------
// DBPropProc2
//	Callback for page 2 of the properties dialog box for a database ("General" tab)
//	Sets the text to display current database properties on the WM_INITDIALOG message

INT_PTR CALLBACK DBPropProc2(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static MSIPackageInfoStruct *sInfo;
	static PROPSHEETPAGE *ps;

	switch (message) {
	case WM_INITDIALOG:

		// Set the text to the database properties ...

		ps = (PROPSHEETPAGE *) lParam;
		sInfo = (MSIPackageInfoStruct *) ps->lParam;

		for (int iCount = 0; iCount <21; iCount++) {
			SetDlgItemText(hDlg, IDT_MSI_PROPERTY+iCount, sInfo->rgszInfo[iCount]);

		}
		
		return (TRUE);
		break;
	}

	return FALSE;
	UNREFERENCED_PARAMETER(wParam);
}


//--------------------------------------------------------------------------------------------------
// ShowDatabaseProp
//	Creates the property sheets for a database
//	Page 1: General, Page 2: More Info

void ShowDatabaseProperty(
		HINSTANCE	hInst,
		HWND		hwndParent
		) {

	PMSIHANDLE	hSummaryInfo;
	TCHAR		szDatabaseName[MAX_PATH+1];
	DWORD		cchValue=MAX_PATH+1;
	MSISPYU::MsivGetDatabaseName(szDatabaseName, &cchValue);
	MsiGetSummaryInformation(0, szDatabaseName, 0, &hSummaryInfo);

	UINT		iType;
	INT			iValue;
	FILETIME	ftValue;
	TCHAR		szValue[MAX_PATH+1];
	
	MSIPackageInfoStruct	sDBInfo;

	// get the properties and fill in the MSIPackageInfoStruct
	for (int iCount=0; iCount < 20; iCount++) {

		cchValue=MAX_PATH+1;
		MsiSummaryInfoGetProperty(hSummaryInfo, iCount, &iType, &iValue, &ftValue, szValue, &cchValue);

		switch (iType) {
		case VT_I4:
			wsprintf(szValue, TEXT("%d"), iValue);
			break;

		case VT_FILETIME:
			SYSTEMTIME	stSystemTime;
			FILETIME	ftLocalTime;

			FileTimeToLocalFileTime(&ftValue, &ftLocalTime);
			FileTimeToSystemTime(&ftLocalTime, &stSystemTime);
			DateTimeToString(&stSystemTime, szValue, MAX_PATH+1);

		case VT_LPSTR:
			break;

		case VT_EMPTY:
			lstrcpy(szValue, g_szNullString);
			break;

		default:
			lstrcpy(szValue, g_szNullString);
			break;
		}

		int iTemp=0;
		while (szValue[iTemp++]) 
			if ((szValue[iTemp-1] > '~') || (szValue[iTemp-1] < ' '))
				szValue[iTemp-1] = ',';
		
		lstrcpy(sDBInfo.rgszInfo[iCount], szValue);
	}

	lstrcpy(sDBInfo.rgszInfo[20], szDatabaseName);
	
	PROPSHEETPAGE psp[2];
    PROPSHEETHEADER psh;

	ZeroMemory(&psp, (sizeof(PROPSHEETPAGE)*2));
	ZeroMemory(&psh, sizeof(PROPSHEETHEADER));

	TCHAR	szHeader1[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_MSI_PROPERTIES_HEADER1, szHeader1, MAX_HEADER+1);

	TCHAR	szHeader2[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_MSI_PROPERTIES_HEADER2, szHeader2, MAX_HEADER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_MSI_PROPERTIES_CAPTION, szCaption, MAX_HEADER+1);


	// page 1: General
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USETITLE;
    psp[0].hInstance = hInst;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_MSI_PROPERTIES1);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = (DLGPROC) DBPropProc;
    psp[0].pszTitle = szHeader1;
    psp[0].lParam = (LONG_PTR) &sDBInfo;

	// page 2: More Info
	psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USETITLE;
    psp[1].hInstance = hInst;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_MSI_PROPERTIES2);
    psp[1].pszIcon = NULL;
    psp[1].pfnDlgProc = (DLGPROC) DBPropProc2;
    psp[1].pszTitle = szHeader2;
    psp[1].lParam = (LONG_PTR) &sDBInfo;

    
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndParent;
    psh.hInstance = hInst;
    psh.pszIcon = NULL;
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

	PropertySheet(&psh);
}


//--------------------------------------------------------------------------------------------------
// ProfPropProc
//	Callback for page 1 of the properties dialog box for a profile ("General" tab)
//	Sets the text to display current profile properties on the WM_INITDIALOG message

INT_PTR CALLBACK ProfPropProc(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	switch (message) {
	case WM_INITDIALOG:

		// Set the text to the database properties ...

		UINT	iCount=0;
		TCHAR	szValue[MAX_PATH+1];
		DWORD	cchCount=MAX_PATH+1;
		while (MSISPYU::MsivGetProfileInfo(iCount++, szValue, &cchCount) == ERROR_SUCCESS) {
			SetDlgItemText(hDlg, IDT_SS_PROPERTY+iCount, szValue);
			cchCount = MAX_PATH+1;
		}
		
		return (TRUE);
		break;
	}

	return FALSE;
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
}


//--------------------------------------------------------------------------------------------------
// ShowProfileProp
//	Creates the property sheet for a profile
//	Page 1: General

void ShowProfileProperty(
		HINSTANCE	hInst,
		HWND		hwndParent
		) {

	PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
	ZeroMemory(&psp, sizeof(PROPSHEETPAGE));
	ZeroMemory(&psh, sizeof(PROPSHEETHEADER));

	TCHAR	szHeader[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_SS_PROPERTIES_HEADER, szHeader, MAX_HEADER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_SS_PROPERTIES_CAPTION, szCaption, MAX_HEADER+1);

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = hInst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_SS_PROPERTIES);
    psp.pszIcon = NULL;
    psp.pfnDlgProc = (DLGPROC) ProfPropProc;
    psp.pszTitle =szHeader;
    psp.lParam = NULL;
    
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndParent;
    psh.hInstance = hInst;
    psh.pszIcon = NULL;
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

	PropertySheet(&psh);

}

//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
// CompPropProc
//	Callback for page 1 of the property sheet for a component ("General" tab)
//	Sets the text to display current component's properties on the WM_INITDIALOG message

INT_PTR CALLBACK PreferencesProc(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static PROPSHEETPAGE * ps;
	static MODE	modeNew = g_modeCurrent;

	switch (message) {

	case WM_INITDIALOG: {
		ps = (PROPSHEETPAGE *) lParam;

//		HWND hwnd = GetDlgItem(hDlg, IDC_SAVESETTINGS);
		
		if ((g_modeCurrent) != MODE_DEGRADED)
			CheckRadioButton(hDlg, IDC_MODENORMAL, IDC_MODERESTRICTED, IDC_MODENORMAL+g_modeCurrent);
		else {
			for (UINT iCount = IDC_MODENORMAL; iCount <= IDC_MODERESTRICTED-1; iCount++) {
				EnableWindow(GetDlgItem(hDlg, iCount), FALSE);
			}
			CheckRadioButton(hDlg, IDC_MODENORMAL, IDC_MODERESTRICTED, IDC_MODERESTRICTED);
		}

		TCHAR	szHelpText[MAX_MESSAGE+1];
		LoadString(g_spyGlobalData.hResourceInstance, IDS_MODENORMAL_HELP+g_modeCurrent, szHelpText, MAX_MESSAGE+1); 
		SetDlgItemText(hDlg, IDC_MODEHELP, szHelpText);
		return(TRUE);
		break;
	}

	case WM_COMMAND:
		// LOWORD added for portability
		switch (LOWORD(wParam)) {

			// set return value to user's selection
		case IDC_MODENORMAL: modeNew = MODE_NORMAL; break;
		case IDC_MODEDIAGNOSTIC: modeNew = MODE_DIAGNOSTIC; break;
		case IDC_MODERESTRICTED: modeNew = MODE_RESTRICTED; break;

		}

		if (g_modeCurrent != MODE_DEGRADED) {
			TCHAR	szHelpText[MAX_MESSAGE+1];
			LoadString(g_spyGlobalData.hResourceInstance, IDS_MODENORMAL_HELP+modeNew, szHelpText, MAX_MESSAGE+1); 
			SetDlgItemText(hDlg, IDC_MODEHELP, szHelpText);
		}
		break;

	case WM_NOTIFY: {
		LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
		NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;

		switch(((NMHDR FAR *)lParam)->code) {

		case PSN_APPLY: {
			if (modeNew != g_modeCurrent)
				SwitchMode(modeNew);
#ifdef _WIN64
			SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
#else
			SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
#endif
			return 1;
			break;
		}
		}
		break;
	}
	}
	return(FALSE);
	UNREFERENCED_PARAMETER(lParam);
}


//--------------------------------------------------------------------------------------------------
// CompPropProc2
//	Callback for page 2 of the property sheet for a component ("File List" tab)
//	Sets the text to display current component's file-list on the WM_INITDIALOG message
//	It also traps LVN_COLUMNCLICK notification messages to sort by that column
//	and LVN_DELETEALLITEMS to call ClearFileList before deleting the items
//	The WM_COMMAND message is trapped and if the command is IDC_VERIFYFILES
//	it brings up the verify files window

INT_PTR CALLBACK PreferencesProc2(
		HWND hDlg,
		UINT message,
		UINT_PTR wParam,
		LONG_PTR lParam
		) {

	static HWND				hwndList;
	static PROPSHEETPAGE * ps;
	static UINT iSelectedItem;
	static LCID	lcid = g_lcidCurrentLocale;

	switch (message) {
	case WM_INITDIALOG:{
		ps = (PROPSHEETPAGE *) lParam;

		hwndList = GetDlgItem(hDlg, IDC_SAVESETTINGS);
		EnableWindow(hwndList, FALSE);

		// get a handle to the list window, and initialise it 
		hwndList = GetDlgItem(hDlg, IDC_LANGUAGELIST);
		DWORD dwStyle = GetWindowLong(hwndList, GWL_STYLE);

		if ((dwStyle & LVS_TYPEMASK) != LVS_REPORT)
			SetWindowLong(hwndList, GWL_STYLE,
			   (dwStyle & ~LVS_TYPEMASK)  | WS_BORDER | 
						WS_TABSTOP | LVS_REPORT | LVS_SINGLESEL | 
						LVS_SORTASCENDING | LVS_NOLABELWRAP |
						LVS_AUTOARRANGE | LVS_NOCOLUMNHEADER);

		TCHAR	szQualifier[MAX_PATH+1];
		TCHAR	szLanguage[MAX_PATH+1];
		DWORD	cchQualifier	= MAX_PATH+1;
		UINT	iIndex = 0;

		RECT rcl;
		GetClientRect(hwndList, &rcl);

		LV_COLUMN lvColumn;
		lvColumn.cx = rcl.right - rcl.left;
		lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH;
		lvColumn.fmt = LVCFMT_LEFT;							// left-align column
		lvColumn.iSubItem = 0;								// set the column position (index)
		ListView_InsertColumn(hwndList, 0, &lvColumn);		// and finally insert it

		lvColumn.cx = 0;
		lvColumn.iSubItem = 1;								// set the column position (index)
		ListView_InsertColumn(hwndList, 1, &lvColumn);		// and insert it


		while (ERROR_SUCCESS == 
			MSI::MsiEnumComponentQualifiers(g_szIntlDLLComponentCode,
			iIndex++, szQualifier, &cchQualifier, NULL, NULL))
		{
			if (4==lstrlen(szQualifier)) 
			{
				
				_stscanf(szQualifier, TEXT("%x"), &lcid);
				if (GetLocaleInfo(lcid,	LOCALE_SLANGUAGE, szLanguage, MAX_PATH+1)) {

					// create the list-item
					LV_ITEM	lvItem;
					lvItem.iItem		= 0;
					lvItem.iSubItem		= 0;
					lvItem.pszText		= szLanguage;
					lvItem.cchTextMax	= lstrlen(szLanguage);
					lvItem.mask			= LVIF_TEXT;

					// add the Language name
					UINT iRow = ListView_InsertItem(hwndList, &lvItem);
					ListView_SetItemText(hwndList, iRow, 1, szQualifier);

				}
			}

			cchQualifier	= MAX_PATH+1;
		}

		GetLocaleInfo(g_lcidCurrentLocale, LOCALE_SLANGUAGE, szQualifier, MAX_PATH+1);
		SetDlgItemText(hDlg, IDC_CURRLANGUAGE, szQualifier);
		lcid = g_lcidCurrentLocale;
		return (TRUE);
		break;
	}
	
	case WM_COMMAND:
		break;

	case WM_NOTIFY: {
		LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
		NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;

		switch(((NMHDR FAR *)lParam)->code) {

		case PSN_APPLY: {
			HINSTANCE	hNewResource;
			TCHAR	szIntlDLLPath[MAX_PATH+1];
			DWORD	cchIntlDLLPath = MAX_PATH+1;
			UINT	iResult;

			if (lcid != g_lcidCurrentLocale) {
				LCID lcidOld = g_lcidCurrentLocale;
				g_lcidCurrentLocale = lcid;
				
				if (ERROR_SUCCESS == (iResult = FindComponent(g_szIntlDLLComponentCode, szIntlDLLPath, &cchIntlDLLPath))) 
					if (hNewResource = W32::LoadLibrary(szIntlDLLPath)) {

						RECT rWindow;
						HWND hwndOld = g_spyGlobalData.hwndParent;
						GetWindowRect(hwndOld, &rWindow);
						FreeLibrary(g_spyGlobalData.hResourceInstance);
						g_spyGlobalData.hResourceInstance = hNewResource;
						InitUIControls(g_spyGlobalData.hInstance, g_spyGlobalData.hResourceInstance);
						CreateNewUI(0, SW_SHOW, &rWindow);
						PostMessage(hwndOld, WM_CLOSE, 0, 0);
						
						//fReload = TRUE;
						SwitchMode(g_modeCurrent);
						ReloadDLL();
						g_spyGlobalData.hAcceleratorTable = LoadAccelerators(g_spyGlobalData.hResourceInstance, MAKEINTRESOURCE(IDR_ACCEL));

 					}
					else 
						g_lcidCurrentLocale = lcidOld;
				else
					g_lcidCurrentLocale = lcidOld;
					

			}

#ifdef _WIN64
			SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
#else
			SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
#endif
			return 1;
			break;
		}

		case LVN_ITEMCHANGED: {
			// selection has changed, get new item selected
			if  (pNm->uNewState & LVIS_SELECTED)
						iSelectedItem = pNm->iItem;

			TCHAR  szCurrSelection[MAX_PATH+1];
			ListView_GetItemText(hwndList, iSelectedItem, 0, szCurrSelection, MAX_PATH+1);
			SetDlgItemText(hDlg, IDC_CURRLANGUAGE, szCurrSelection);

			TCHAR	szQualifier[MAX_PATH+1];
			ListView_GetItemText(hwndList, iSelectedItem, 1, szQualifier, MAX_PATH+1);
			_stscanf(szQualifier, TEXT("%x"), &lcid);
#ifdef _WIN64
			SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
#else
			SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
#endif

			return FALSE;
			break;
		}				
		}
		break;
	}
	}

	return DefWindowProc (hDlg, message, wParam, lParam);
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
}



//--------------------------------------------------------------------------------------------------

BOOL HandlePreferences(
		HWND hwndParent
		) {


	PROPSHEETPAGE psp[2];
    PROPSHEETHEADER psh;
	ZeroMemory(&psp, (sizeof(PROPSHEETPAGE)*2));
	ZeroMemory(&psh, sizeof(PROPSHEETHEADER));

	TCHAR	szHeader[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_PREFERENCES_HEADER1, szHeader, MAX_HEADER+1);

	TCHAR	szHeader2[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_PREFERENCES_HEADER2, szHeader2, MAX_HEADER+1);

	TCHAR	szCaption[MAX_HEADER+1];
	LoadString(g_hResourceInst, IDS_PREFERENCES_CAPTION, szCaption, MAX_HEADER+1);

	// page 1: General
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USETITLE;
    psp[0].hInstance = g_hResourceInst;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_PREFERENCES1);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = (DLGPROC) PreferencesProc;
    psp[0].pszTitle =szHeader;
    psp[0].lParam = 0;
    
	// page 2: Language
    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USETITLE;
    psp[1].hInstance = g_hResourceInst;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_PREFERENCES2);
    psp[1].pszIcon = NULL;
    psp[1].pfnDlgProc = (DLGPROC) PreferencesProc2;
    psp[1].pszTitle =szHeader2;
    psp[1].lParam = 0;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hResourceInst;
    psh.pszIcon = NULL;
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

	PropertySheet(&psh);
	DWORD Err= GetLastError();

	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispyu.dll\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispy.exe\ui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ui.h
//
//--------------------------------------------------------------------------


#ifndef UI_H
#define UI_H

const int	NUM_TREEVIEWICONS		=  6;
const int	STATUS_BAR_HEIGHT		= 20;

const int	TVICON_ROOT				=  0;
const int	TVICON_PRODUCT			=  1;
const int	TVICON_BROKENPRODUCT	=  2;
const int	TVICON_FEATURE			=  3;
const int	TVICON_ABSENTFEATURE	=  4;
const int	TVICON_BROKENFEATURE	=  5;

/*
typedef enum tagSELECTYPE {
	SEL_FEAT	= 2,
	SEL_PROD	= 1,
	SEL_ROOT	= 0,
	SEL_UNINIT	= -1
} SELECTYPE;
*/



void InitUIControls(HINSTANCE hInst, HINSTANCE hResourceInst);

BOOL InitTreeViewImageLists(
		HWND		hwndTreeView, 
		HINSTANCE	hInstance
		);

HWND CreateTreeView(
		HWND		hwndParent, 
		HINSTANCE	hInst,
		HWND		*hwndOld,
		UINT		cx,
		UINT		cy
		);


HWND CreateListView(
		HWND		hwndParent, 
		HINSTANCE	hInst,
		UINT		iWidth
		);

void Expand(
		HWND		hwndTreeView, 
		HTREEITEM	hOld, 
		HTREEITEM	hNew, 
		LPTSTR		szFeature
		);

void ListSubFeatures(
		LPTSTR		szProductID, 
		LPTSTR		szParentF,
		HTREEITEM	hParent,
		HWND		hwndTreeView
		);
		
void ListProducts(
		HWND	hwndTreeView, 
		HWND	hwndTreeViewNew,		
		BOOL	fRefresh=FALSE,
		LPTSTR	szFeatureName=NULL,
		BOOL	*fRefinProg=NULL
		);

LRESULT TV_NotifyHandler(
		LPARAM		lParam,
		HWND		hwndTreeView,
		LPTSTR		szProductCode,
		LPTSTR		szFeatureName,
		LPTSTR		szFeatureCode,
		ITEMTYPE	*iSelType
		);

LRESULT LV_NotifyHandler(
		HWND	hwndTreeView,
		HWND	hwndListView,
		LPARAM	lParam,
		int		*iSelectedItem
		);

void ClearList(HWND hwndList);

BOOL UpdateListView(
		HWND	hwndListView,
		LPCTSTR	szProduct,
		LPCTSTR	szFeatureName,
		int		*iNumCmps,
		BOOL	fProduct
		);


UINT HandleOpen(
		HWND		hwndParent,
		HINSTANCE	hInst
		);

VOID ChangeSBText(
		HWND			hwndStatus, 
		int				iNumComp, 
		LPTSTR			szFeatureName	= NULL,
		INSTALLSTATE	iState			= INSTALLSTATE_UNKNOWN,
		BOOL			fProduct		= FALSE
		);


VOID ChangeSBText(
		HWND	hwndStatus, 
		LPCTSTR	szNewText,
		LPCTSTR	szNewText2 = NULL
		);

BOOL ReinstallComponent(
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName,
		LPCTSTR	szComponentId,
		BOOL	fProduct=FALSE
		);

BOOL ReinstallFeature(
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName, 
		INT_PTR	iInstallLev 
		);

BOOL ReinstallProduct(
		LPTSTR	szProductCode,
		INT_PTR	iInstallLev 
		);


BOOL ConfigureProduct(
		LPTSTR	szProductCode,
		int	iInstallLev 
		);

BOOL ConfigureFeature(
		LPCTSTR	szProductCode,
		LPCTSTR	szFeatureName, 
		INT_PTR	iInstallLev
		);


void HandleSaveProfile(
		HWND		hwndParent,
		HINSTANCE	hInst,
		BOOL		fLog = FALSE
		);

UINT HandleLoadProfile(
		HWND		hwndParent,
		HINSTANCE	hInst
		);

void RestoreProfile(BOOL fQuiet=FALSE);

void CheckDiff(LPCTSTR szFileName);

BOOL isProductInstalled();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyara.dll\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyara.dll\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyara.dll\make.inc ===
AraResAll: $(O)\araAll.res

$(O)\araAll.res: $(O)\spyara.res ..\uiara.res
	copy /b $(O)\spyara.res + ..\uiara.res /b $@

$(O)\spyara.res: ..\spyara.rc
	rc $(C_DEFINES) -d_RC32 -Fo$@ -i $(INC_DIR) -i $(SDK_INC_PATH) -i $(RES_OBJDIR) -dNEUTRAL_SUBLANGUAGE ..\spyara.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispyu.dll\sources.inc ===
TARGETNAME=MsiSpyu
!INCLUDE ..\..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK
TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib

USE_NATIVE_EH=1
USE_LIBCMT=1
IDL_TYPE=OLE
MIDL_UUIDDIR=$(O)
MIDL_TLBDIR=$(O)
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\MsiSpyu.def

INCLUDES=$(MSI_SPYINC_DIR);$(0);$(INC_DIR);$(HELP_DIR);$(RES_OBJDIR)

SOURCES=..\msispyu.idl \
	..\msispyu.cpp \
	..\hashinc.cpp \
	..\msispyu.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spydeu.dll\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spydeu.dll\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spydeu.dll\make.inc ===
DeuResAll: $(O)\deuAll.res

$(O)\deuAll.res: $(O)\spydeu.res ..\uideu.res
	copy /b $(O)\spydeu.res + ..\uideu.res /b $@

$(O)\spydeu.res: ..\spydeu.rc
	rc $(C_DEFINES) -Fo$@ -i $(INC_DIR) -i $(SDK_INC_PATH) -i $(RES_OBJDIR) ..\spydeu.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\msispyu.dll\msispyu.cpp ===
#if 0		// makefile definitions
MODULENAME = msispyu
#UNICODE = 1
DESCRIPTION = Automation for MSI API functions
FILEVERSION = MSI
ADDCPP = hash
AUTOMATION = 1
INCLUDE = $(INCLUDE);..\HELP
ENTRY1 = MsivEnumProducts,MsivEnumFeatures,MsivEnumComponentsFromFeature,MsivEnumComponents,MsivGetComponentName,MsivGetProductInfo,MsivGetFeatureInfo,MsivOpenDatabase
ENTRY2 = MsivCloseDatabase,MsivGetDatabaseName,MsivEnumComponentsFromProduct,MsivSaveProfile,MsivLoadProfile,MsivCloseProfile,MsivGetProfileName,MsivGetFeatureUsage
ENTRY3 = MsivEnumClients,MsivGetProfileInfo,MsivEnumFilesFromComponent,MsivGetFileInfo,MsivQueryProductState,MsivQueryFeatureState,MsivLocateComponent,MsivGetComponentPath,MsivGetUserInfo
ENTRY = DllMain,MsivCloseDatabase,MsivCloseProfile,MsivEnumProducts,$(ENTRY1),$(ENTRY2),$(ENTRY3)
DEPEND = hash.h,msispyu.h,spydspid.h
!include "..\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif		// end of makefile definitions

//!! Fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       msispyu.cpp
//
//--------------------------------------------------------------------------

#ifndef __MKTYPLIB__    // source code, not ODL
#include <windows.h>

#ifndef RC_INVOKED    // start of source code
#include <olectl.h>   // SELFREG_E_*
#include <tchar.h>
#include "msiquery.h"
#include "version.h"

// msispyu.cpp --> msispyu.dll
#include "msispyu.h"
#include "hash.h"
#if 1 //!! remove the following when OTOOLS supports "objsafe.h"
//DEFINE_GUID(IID_IObjectSafety, 0xcb5bdc81, 0x93c1, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
const GUID IID_IObjectSafety = {0xcb5bdc81L,0x93c1,0x11cf,{0x8f,0x20,0x00,0x80,0x5f,0x2c,0xd0,0x64}};
class IObjectSafety : public IUnknown
{
 public:
	virtual HRESULT __stdcall GetInterfaceSafetyOptions(const IID& riid, DWORD* pdwSupportedOptions, DWORD* pdwEnabledOptions) = 0;
	virtual HRESULT __stdcall SetInterfaceSafetyOptions(const IID& riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions) = 0;
};
#define INTERFACESAFE_FOR_UNTRUSTED_CALLER 0x00000001 // Caller of interface may be untrusted
#define INTERFACESAFE_FOR_UNTRUSTED_DATA   0x00000002 // Data passed into interface may be untrusted
#endif //!! end remove OTOOLS-compatibility section

namespace OLEAUT32  // wrapper functions to bind on first call
{
typedef BSTR    (WINAPI *T_SysAllocString)(const OLECHAR* sz);
typedef BSTR    (WINAPI *T_SysAllocStringLen)(const OLECHAR* sz, UINT cch);
typedef UINT    (WINAPI *T_SysStringLen)(const OLECHAR* sz);
typedef void    (WINAPI *T_SysFreeString)(const OLECHAR* sz);
typedef HRESULT (WINAPI *T_VariantClear)(VARIANTARG * pvarg);
typedef HRESULT (WINAPI *T_VariantChangeType)(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt);
typedef HRESULT (WINAPI *T_LoadTypeLib)(const OLECHAR  *szFile, ITypeLib ** pptlib);
typedef HRESULT (WINAPI *T_RegisterTypeLib)(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir);
typedef HRESULT (WINAPI *T_UnRegisterTypeLib)(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind);
typedef INT     (WINAPI *T_SystemTimeToVariantTime)(LPSYSTEMTIME lpSystemTime, double *pvtime);
typedef INT     (WINAPI *T_VariantTimeToSystemTime)(double vtime, LPSYSTEMTIME lpSystemTime);

BSTR    WINAPI F_SysAllocString(const OLECHAR* sz);
BSTR    WINAPI F_SysAllocStringLen(const OLECHAR* sz, UINT cch);
UINT    WINAPI F_SysStringLen(const OLECHAR* sz);
void    WINAPI F_SysFreeString(const OLECHAR* sz);
HRESULT WINAPI F_VariantClear(VARIANTARG * pvarg);
HRESULT WINAPI F_VariantChangeType(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt);
HRESULT WINAPI F_LoadTypeLib(const OLECHAR  *szFile, ITypeLib ** pptlib);
HRESULT WINAPI F_RegisterTypeLib(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir);
HRESULT WINAPI F_UnRegisterTypeLib(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind);
INT     WINAPI F_SystemTimeToVariantTime(LPSYSTEMTIME lpSystemTime, double *pvtime);
INT     WINAPI F_VariantTimeToSystemTime(double vtime, LPSYSTEMTIME lpSystemTime);

T_SysAllocString            SysAllocString           = F_SysAllocString;
T_SysAllocStringLen         SysAllocStringLen        = F_SysAllocStringLen;
T_SysStringLen              SysStringLen             = F_SysStringLen;
T_SysFreeString             SysFreeString            = F_SysFreeString;
T_VariantClear              VariantClear             = F_VariantClear;
T_VariantChangeType         VariantChangeType        = F_VariantChangeType;
T_LoadTypeLib               LoadTypeLib              = F_LoadTypeLib;
T_RegisterTypeLib           RegisterTypeLib          = F_RegisterTypeLib;
T_UnRegisterTypeLib         UnRegisterTypeLib        = F_UnRegisterTypeLib;
T_SystemTimeToVariantTime   SystemTimeToVariantTime  = F_SystemTimeToVariantTime;
T_VariantTimeToSystemTime   VariantTimeToSystemTime  = F_VariantTimeToSystemTime;
} // end namespace OLEAUT32

namespace OLE32  // wrapper functions to bind on first call
{
typedef BOOL (WINAPI *T_FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
typedef BOOL (WINAPI *T_SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);

BOOL WINAPI F_FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
BOOL WINAPI F_SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);

T_FileTimeToSystemTime FileTimeToSystemTime = F_FileTimeToSystemTime;
T_SystemTimeToFileTime SystemTimeToFileTime = F_SystemTimeToFileTime;
} // end namespace OLE32

// GUID assignments for API automation classes, reserved from MSI group 21-2F
const int iidMsispyTypeLib       = 0xC1121L;
const int iidMsispy              = 0xC1122L;
const int iidMsispyDatabase      = 0xC1123L;
const int iidMsispyProfile       = 0xC1124L;
const int iidMsispyRegistry      = 0xC1125L;

const int iidUnknown            = 0x00000L;
const int iidClassFactory       = 0x00001L;
const int iidDispatch           = 0x20400L;
const int iidTypeInfo           = 0x20401L;
const int iidEnumVARIANT        = 0x20404L;

#define MSGUID(iid) {iid,0,0,{0xC0,0,0,0,0,0,0,0x46}}

const GUID IID_IMsispyTypeLib      = MSGUID(iidMsispyTypeLib);
const GUID IID_IMsispy		       = MSGUID(iidMsispy);
const GUID IID_IMsispyDatabase     = MSGUID(iidMsispyDatabase);
const GUID IID_IMsispyProfile      = MSGUID(iidMsispyProfile);
const GUID IID_IMsispyRegistry     = MSGUID(iidMsispyRegistry);

const GUID IID_IUnknown           = MSGUID(iidUnknown);
const GUID IID_IClassFactory      = MSGUID(iidClassFactory);
const GUID IID_IDispatch          = MSGUID(iidDispatch);
const GUID IID_IEnumVARIANT       = MSGUID(iidEnumVARIANT);

#define ERROR_SOURCE_NAME L"Msispy"

// Boolean definition, eventually will use compiler bool when available
enum Bool
{
	fFalse,
	fTrue
};


#define BLANK(X) X[0] = 0


class CSpyBase {		// all functions are pure virtual

public:
	virtual UINT WINAPI MsicEnumProducts(
	  const	DWORD	dwProductIndex,	// 0-based index into registered products
			LPTSTR	lpProductBuf	// buffer of char count: cchGUID+1 (size of string GUID)
			) = 0;

	virtual UINT WINAPI MsicEnumFeatures(
			LPCTSTR	szProduct,
	  const	DWORD	dwFeatureIndex,	// 0-based index into published features
			LPTSTR	lpFeatureBuf,	// feature name buffer,   size=MAX_FEATURE_CHARS+1
			LPTSTR	lpParentBuf		// parent feature buffer, size=MAX_FEATURE_CHARS+1
			) = 0;

	virtual UINT WINAPI MsicEnumComponentsFromFeature(
			LPCTSTR	szProduct, 
			LPCTSTR	szFeature, 
	  const DWORD	dwComponentIndex, 
			LPTSTR	lpComponentBuf,			// component GUID buffer, size = cchGUID + 1
			LPTSTR	lpComponentNameBuf,		// component name buffer, NULL if not required
			LPDWORD	pcchComponentNameBuf	// size of component name buffer, can be NULL only if lpComponentNameBuf is NULL
			) = 0;

	virtual UINT WINAPI MsicEnumComponents(
	  const	DWORD	dwComponentIndex,		// 0-based index into installed components
			LPTSTR	lpComponentBuf			// buffer of char count: cchGUID + 1 (size of string GUID)
			) = 0;

	virtual UINT WINAPI MsicGetComponentName(
			LPCTSTR	szComponentId,
			LPTSTR	lpComponentName,
			LPDWORD	cchComponentName
			) = 0;		// To fix

	virtual UINT WINAPI MsicGetProductInfo(
			LPCTSTR	szProduct,		// product code, string GUID, or descriptor
			LPCTSTR	szAttribute,	// attribute name, case-sensitive
			LPTSTR	lpValueBuf,		// returned value
			LPDWORD	pcchValueBuf	// in/out buffer character count
			) = 0;

	virtual UINT WINAPI MsicGetFeatureInfo(
 			LPCTSTR	szProduct,		// product code, string GUID, or descriptor
			LPCTSTR	szFeature,		// feature name
			LPCTSTR	szAttribute,	// attribute name, case-sensitive
			LPTSTR	lpValueBuf,		// returned value
			LPDWORD	pcchValueBuf	// in/out buffer character count
			) = 0;

	virtual INSTALLSTATE WINAPI MsicQueryProductState(
			LPCTSTR  szProduct
			) = 0;

	virtual INSTALLSTATE WINAPI MsicQueryFeatureState(
			LPCTSTR	szProduct,
			LPCTSTR	szFeature
			) = 0;

	virtual INSTALLSTATE WINAPI MsicLocateComponent(
			LPCTSTR	szComponentId,	// component Id, string GUID
			LPTSTR	lpPathBuf,		// returned path
			LPDWORD	pcchBuf		// in/out buffer character count
 			) = 0;

	virtual INSTALLSTATE WINAPI MsicGetComponentPath(
			LPCTSTR szProductId,	// product Id, string GUID
			LPCTSTR szComponentId,	// component Id, string GUID
			LPTSTR lpPathBuf,		// returned path
			LPDWORD	pcchBuf			// in/out buffer character count
			) = 0;
	
	virtual UINT WINAPI MsicEnumComponentsFromProduct(
			LPCTSTR	szProductCode,
	  const	DWORD	dwComponentIndex, // 0-based index into installed components
			LPTSTR	lpComponentBuf	 // buffer of char count: cchGUID+1 (size of string GUID)
			) = 0;

	virtual UINT WINAPI MsicGetFeatureUsage(
			LPCTSTR	szProduct,			// product code
			LPCTSTR	szFeature,			// feature ID
			LPDWORD	pdwUseCount,		// returned use count
			LPWORD	pwDateUsed			// last date used (DOS date format)
			) = 0;

	virtual USERINFOSTATE WINAPI MsicGetUserInfo(
			LPCTSTR	szProduct,			// product code, string GUID
			LPTSTR	lpUserNameBuf,		// return user name           
			LPDWORD	pcchUserNameBuf,	// in/out buffer character count
			LPTSTR	lpOrgNameBuf,		// return company name           
			LPDWORD	pcchOrgNameBuf,	// in/out buffer character count
			LPTSTR	lpSerialBuf,		// return product serial number
			LPDWORD	pcchSerialBuf		// in/out buffer character count
			) = 0;
	
	virtual UINT WINAPI MsicEnumClients(
			LPCTSTR	szComponent,
	  const DWORD	dwProductIndex,	// 0-based index into client products
			LPTSTR	lpProductBuf	// buffer of char count: cchGUID+1 (size of string GUID)
			) = 0;
	
	virtual UINT WINAPI MsicEnumFilesFromComponent(
			LPCTSTR	szComponentid,
			DWORD	dwFileIndex,
			LPTSTR	lpValueBuf,
			LPDWORD	pcchCount
			) = 0;

	virtual UINT WINAPI MsicGetFileInfo(
			LPCTSTR szProductCode,		// product code, string GUID
			LPCTSTR	szComponentId,		// component id, string GUID
			LPCTSTR	szFileName,			// file's name in table
			LPCTSTR	szAttribute,		// attribute in table
			LPTSTR	lpValueBuf,			// path to file
			LPDWORD	pcchValueBuf		// buffer of char count
			) = 0;
};




class CSpyDatabase : public CSpyBase {
public:		// implemented CSpyBase  Functions

	CSpyDatabase();
	~CSpyDatabase();
	UINT WINAPI MsicEnumProducts(const DWORD dwProductIndex, LPTSTR	lpProductBuf);
	UINT WINAPI MsicEnumFeatures(LPCTSTR szProduct, const DWORD dwFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf);
	UINT WINAPI MsicEnumComponents(const DWORD dwComponentIndex, LPTSTR lpComponentBuf);
	UINT WINAPI MsicEnumComponentsFromProduct(LPCTSTR szProductCode, const DWORD dwComponentIndex, LPTSTR lpComponentBuf);
	UINT WINAPI MsicEnumComponentsFromFeature(LPCTSTR szProduct, LPCTSTR szFeature, const DWORD dwComponentIndex, LPTSTR lpComponentBuf, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf);
	UINT WINAPI MsicGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentName, LPDWORD cchComponentName); // To fix
	UINT WINAPI MsicGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	UINT WINAPI MsicGetFeatureInfo(LPCTSTR szProduct, LPCTSTR szFeature, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	INSTALLSTATE WINAPI MsicQueryProductState(LPCTSTR szProduct);
	INSTALLSTATE WINAPI MsicQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature);
	INSTALLSTATE WINAPI MsicLocateComponent(LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf);
	INSTALLSTATE WINAPI MsicGetComponentPath(LPCTSTR szProductId, LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf);
	UINT WINAPI MsicGetFeatureUsage(LPCTSTR szProduct, LPCTSTR szFeature, LPDWORD pdwUseCount, WORD *pwDateUsed);
	USERINFOSTATE WINAPI MsicGetUserInfo(LPCTSTR szProduct, LPTSTR lpUserNameBuf, LPDWORD pcchUserNameBuf, LPTSTR lpOrgNameBuf, LPDWORD pcchOrgNameBuf, LPTSTR lpSerialBuf, LPDWORD pcchSerialBuf);
	UINT WINAPI MsicEnumClients(LPCTSTR szComponent, const DWORD dwProductIndex, LPTSTR lpProductBuf); 
	UINT WINAPI MsicEnumFilesFromComponent(LPCTSTR szComponentid, DWORD dwFileIndex, LPTSTR lpValueBuf, LPDWORD pcchCount);
	UINT WINAPI MsicGetFileInfo(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);

public:
	UINT WINAPI MsicOpenDatabase(LPCTSTR szDatabase);
	UINT WINAPI MsicOpenProduct(LPCTSTR szProductCode);
	UINT WINAPI MsicCloseDatabase();
	UINT WINAPI MsicGetDatabaseName(LPTSTR lpValueBuf, LPDWORD pcchValueBuf);

private:
	PMSIHANDLE	m_hDatabase;
	TCHAR		m_szNullString[2];
	TCHAR		m_szDatabaseName[MAX_PATH+1];
	TCHAR		m_szProductCode[MAX_GUID+1];
};



class CSpyProfile : public CSpyBase 
{

public:		// implemented CSpyBase functions
	CSpyProfile();
	~CSpyProfile();
	UINT WINAPI MsicEnumProducts(const DWORD dwProductIndex, LPTSTR	lpProductBuf);
	UINT WINAPI MsicEnumFeatures(LPCTSTR szProduct, const DWORD dwFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf);
	UINT WINAPI MsicEnumComponentsFromFeature(LPCTSTR szProduct, LPCTSTR szFeature, const DWORD dwComponentIndex, LPTSTR lpComponentBuf, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf);
	UINT WINAPI MsicEnumComponents(const DWORD dwComponentIndex, LPTSTR lpComponentBuf);
	UINT WINAPI MsicGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentName, LPDWORD cchComponentName); // To fix
	UINT WINAPI MsicGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	UINT WINAPI MsicGetFeatureInfo(LPCTSTR szProduct, LPCTSTR szFeature, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	UINT WINAPI MsicEnumComponentsFromProduct(LPCTSTR szProductCode, const DWORD dwComponentIndex, LPTSTR lpComponentBuf);
	UINT WINAPI MsicGetFeatureUsage(LPCTSTR szProduct, LPCTSTR szFeature, LPDWORD pdwUseCount, WORD *pwDateUsed);
	UINT WINAPI MsicEnumClients(LPCTSTR szComponent, const DWORD dwProductIndex, LPTSTR lpProductBuf); 
	UINT WINAPI MsicEnumFilesFromComponent(LPCTSTR szComponentid, DWORD dwFileIndex, LPTSTR lpValueBuf, LPDWORD pcchCount);
	UINT WINAPI MsicGetFileInfo(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	INSTALLSTATE WINAPI MsicQueryProductState(LPCTSTR szProduct);
	INSTALLSTATE WINAPI MsicQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature);
	INSTALLSTATE WINAPI MsicLocateComponent(LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf);
	INSTALLSTATE WINAPI MsicGetComponentPath(LPCTSTR szProductId, LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf);
	USERINFOSTATE WINAPI MsicGetUserInfo(LPCTSTR szProduct, LPTSTR lpUserNameBuf, LPDWORD pcchUserNameBuf, LPTSTR lpOrgNameBuf, LPDWORD pcchOrgNameBuf, LPTSTR lpSerialBuf, LPDWORD pcchSerialBuf);

public:
	UINT WINAPI MsicSaveProfile(LPCTSTR szFileName);
	UINT WINAPI MsicLoadProfile(LPCTSTR szFileName);
	UINT WINAPI MsicCloseProfile();
	UINT WINAPI MsicGetProfileName(LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	UINT WINAPI MsicGetProfileInfo(UINT iIndex, LPTSTR szValue, LPDWORD pcchCount);

private:
	void WINAPI FillInComponents();
	BOOL WINAPI	FindProductIndex(LPCTSTR szReqdProductCode);
	BOOL WINAPI	FindFeatureIndex(LPCTSTR szTargetFeature);
	BOOL WINAPI	FindComponentIndex(LPCTSTR szReqdComponentGUID);

private:
	TCHAR		m_szProfileName[MAX_PATH+1];
	TCHAR		m_szDefaultText[6];
	int			m_iCurrentProduct;
	int			m_iCurrentFeature;
	int			m_iCurrentComponent;
	TCHAR		m_szNullString[2];
	HashTable	m_hashTable;
	HANDLE		m_hfProfile;

};



class CSpyRegistry : public CSpyBase 
{

public:		// implemented CSpyBase  Functions
	CSpyRegistry();
	~CSpyRegistry();
	UINT WINAPI MsicEnumProducts(const DWORD dwProductIndex, LPTSTR	lpProductBuf);
	UINT WINAPI MsicEnumFeatures(LPCTSTR szProduct, const DWORD dwFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf);
	UINT WINAPI MsicEnumComponentsFromFeature(LPCTSTR szProduct, LPCTSTR szFeature, const DWORD dwComponentIndex, LPTSTR lpComponentBuf, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf);
	UINT WINAPI MsicEnumComponents(const DWORD dwComponentIndex, LPTSTR lpComponentBuf);
	UINT WINAPI MsicGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentName, LPDWORD cchComponentName); // To fix
	UINT WINAPI MsicGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	UINT WINAPI MsicGetFeatureInfo(LPCTSTR szProduct, LPCTSTR szFeature, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	UINT WINAPI MsicEnumComponentsFromProduct(LPCTSTR szProductCode, const DWORD dwComponentIndex, LPTSTR lpComponentBuf);
	UINT WINAPI MsicGetFeatureUsage(LPCTSTR szProduct, LPCTSTR szFeature, LPDWORD pdwUseCount, WORD *pwDateUsed);
	UINT WINAPI MsicEnumClients(LPCTSTR szComponent, const DWORD dwProductIndex, LPTSTR lpProductBuf); 
	UINT WINAPI MsicEnumFilesFromComponent(LPCTSTR szComponentid, DWORD dwFileIndex, LPTSTR lpValueBuf, LPDWORD pcchCount);
	UINT WINAPI MsicGetFileInfo(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf);
	INSTALLSTATE WINAPI MsicQueryProductState(LPCTSTR szProduct);
	INSTALLSTATE WINAPI MsicQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature);
	INSTALLSTATE WINAPI MsicLocateComponent(LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf);
	INSTALLSTATE WINAPI MsicGetComponentPath(LPCTSTR szProductId, LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf);
	USERINFOSTATE WINAPI MsicGetUserInfo(LPCTSTR szProduct, LPTSTR lpUserNameBuf, LPDWORD pcchUserNameBuf, LPTSTR lpOrgNameBuf, 
		LPDWORD pcchOrgNameBuf, LPTSTR lpSerialBuf, LPDWORD pcchSerialBuf);

private:
	UINT WINAPI OpenTempDB(LPCTSTR szProductID);

private:

	CSpyDatabase m_spydb;
	TCHAR		m_szLocalProductCode[cchGUID+1];
	TCHAR		m_szNullString[2];

};


typedef enum tagDATASOURCE {
	DS_NONE				=	0,
	DS_REGISTRY			=	1,
	DS_DATABASE			=	2,
	DS_PROFILE			=	3
}	DATASOURCE;


// globals
const	TCHAR		g_szEmptyString[]					= TEXT("");
DATASOURCE	g_iDataSource	=	DS_REGISTRY;
CSpyDatabase	cDatabase;
CSpyProfile		cProfile;
CSpyRegistry	cRegistry;

/*
// entry point
int WINAPI DllMain (
		HINSTANCE	hInstance,
		DWORD		fdwReason,
		PVOID		pvReserved
		) 
{
		return TRUE;
}
*/

// ____________________________________________________________________________
//
//	Public Functions (C-style wrapper functions)
// ____________________________________________________________________________

// ---------------------------------------------------------------------
// Functions to iterate registered products, features, and components.
// They accept a 0-based index into the enumeration.
// These functions model those in msi.h- and provide the same functionality
// for databases as well.
// ---------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
// MsivEnumProducts:
//	Enumerates the registered products, either installed or advertised
//	If a database is open, only one product (described by the database)
//	is enumerated

EXPORT UINT WINAPI MsivEnumProducts(
  const DWORD		dwProductIndex,	// 0-based index into registered products
		LPTSTR		lpProductBuf	// buffer of char count: cchGUID+1 (size of string GUID)
		) { 
	if (!lpProductBuf)
		return ERROR_INVALID_PARAMETER;
	
	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicEnumProducts(dwProductIndex, lpProductBuf);

	case DS_PROFILE:
			return cProfile.MsicEnumProducts(dwProductIndex, lpProductBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicEnumProducts(dwProductIndex, lpProductBuf);
	
	default:
		return ERROR_;
	}
}

//--------------------------------------------------------------------------------------------------
// MsivEnumFeatures:
//	Enumerate the advertised features for a given product. If a database
//	is open, product code passed in must be same as current product or NULL
//	If parent is not required, supplying NULL will improve performance.

EXPORT UINT WINAPI MsivEnumFeatures(
		LPCTSTR	szProduct,
  const	DWORD	dwFeatureIndex,	// 0-based index into published features
		LPTSTR	lpFeatureBuf,	// feature name buffer,   size=MAX_FEATURE_CHARS+1
		LPTSTR	lpParentBuf		// parent feature buffer, size=MAX_FEATURE_CHARS+1
		) {

	if (!lpFeatureBuf)
		return ERROR_INVALID_PARAMETER;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicEnumFeatures(szProduct, dwFeatureIndex, lpFeatureBuf, lpParentBuf);

	case DS_PROFILE:
			return cProfile.MsicEnumFeatures(szProduct, dwFeatureIndex, lpFeatureBuf, lpParentBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicEnumFeatures(szProduct, dwFeatureIndex, lpFeatureBuf, lpParentBuf);
	
	default:
		return ERROR_;
	}
}


//--------------------------------------------------------------------------------------------------
// MsivEnumComponentsFromFeature:
//	Enumerate the components for a given feature of a product. If a 
//	database is open, product code passed in must be same as current 
//	product or NULL

EXPORT UINT WINAPI MsivEnumComponentsFromFeature(
		LPCTSTR	szProduct,			// product code
		LPCTSTR	szFeature,			// feature ID
  const	DWORD	dwComponentIndex,	// 0-based index into components
		LPTSTR	lpComponentBuf,		// component Id buffer,   size = cchGUID+1
		LPTSTR	lpComponentNameBuf,
		LPDWORD pcchComponentNameBuf
		) {

	if (!lpComponentBuf)
		return ERROR_INVALID_PARAMETER;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicEnumComponentsFromFeature(szProduct, szFeature, dwComponentIndex, lpComponentBuf, lpComponentNameBuf, pcchComponentNameBuf);

	case DS_PROFILE:
			return cProfile.MsicEnumComponentsFromFeature(szProduct, szFeature, dwComponentIndex, lpComponentBuf, lpComponentNameBuf, pcchComponentNameBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicEnumComponentsFromFeature(szProduct, szFeature, dwComponentIndex, lpComponentBuf, lpComponentNameBuf, pcchComponentNameBuf);
	
	default:
		return ERROR_;
	}
}


//--------------------------------------------------------------------------------------------------
// MsivEnumComponents:
//	Enumerates the installed components for all products
//	If a database is open, this enumerates all components for current 
//	product only.

EXPORT UINT WINAPI MsivEnumComponents(
  const	DWORD	dwComponentIndex, // 0-based index into installed components
		LPTSTR	lpComponentBuf	 // buffer of char count: cchGUID+1 (size of string GUID)
		) {

	if (!lpComponentBuf)
		return ERROR_INVALID_PARAMETER;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicEnumComponents(dwComponentIndex, lpComponentBuf);

	case DS_PROFILE:
			return cProfile.MsicEnumComponents(dwComponentIndex, lpComponentBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicEnumComponents(dwComponentIndex, lpComponentBuf);
	
	default:
		return ERROR_;
	}
}


//--------------------------------------------------------------------------------------------------
// MsivEnumComponentsFromProduct
//	Enumerates all the components of a product
//	If a database is open, product code passed in must be same as current 
//	product
//
//	This function is not really required, since calls to MsivEnumFeatures
//	and MsivEnumComponentsFromFeature will essentially return the same info
//	However the overhead in using this is much lower

EXPORT UINT WINAPI MsivEnumComponentsFromProduct(
		LPCTSTR	szProductCode,
  const	DWORD	dwComponentIndex, // 0-based index into installed components
		LPTSTR	lpComponentBuf	 // buffer of char count: cchGUID+1 (size of string GUID)
		) {


	if (!lpComponentBuf)
		return ERROR_INVALID_PARAMETER;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicEnumComponentsFromProduct(szProductCode, dwComponentIndex, lpComponentBuf);

	case DS_PROFILE:
			return cProfile.MsicEnumComponentsFromProduct(szProductCode, dwComponentIndex, lpComponentBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicEnumComponentsFromProduct(szProductCode, dwComponentIndex, lpComponentBuf);
	
	default:
		return ERROR_;
	}
}

// _________________________________________________________________________________________________

//--------------------------------------------------------------------------------------------------
// MsivGetProductInfo:
//	Returns product info.
//	For a list of valid attributes, check msi.h (INSTALLPROPERTY_*)
//	If a database is in use, additional attributes- entries in the Property 
//	table- are valid, and not all the attrributes in msi.h are valid since
//	some of them do not have matches in the database table. If this is 
//	the case, ERROR_NO_DATA is returned.

EXPORT UINT WINAPI MsivGetProductInfo(
		LPCTSTR	szProduct,		// product code, string GUID, or descriptor
		LPCTSTR	szAttribute,	// attribute name, case-sensitive
		LPTSTR	lpValueBuf,		// returned value
		LPDWORD	pcchValueBuf	// in/out buffer character count
		) {
	
//	MSIHANDLE	hLocalDB=NULL;
//	UINT		iFailCode=0;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicGetProductInfo(szProduct, szAttribute, lpValueBuf, pcchValueBuf);

	case DS_PROFILE:
			return cProfile.MsicGetProductInfo(szProduct, szAttribute, lpValueBuf, pcchValueBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicGetProductInfo(szProduct, szAttribute, lpValueBuf, pcchValueBuf);
	
	default:
		return ERROR_;
	}
}


//--------------------------------------------------------------------------------------------------
// MsivGetFeatureInfo:
//	Returns feature info.
//	For a list of valid attributes, check up msispyu.h (FEATUREPROPERTY_*)
//	If a database is in use, the info is obtained from the Feature table.
//	If the registry is in use, the database for the product to which the
//	feature belongs is opened and the info is obtained from the Feature
//	table in it.
//	If a profile is in use, info is obtained directly from it

EXPORT UINT WINAPI MsivGetFeatureInfo(
 		LPCTSTR	szProduct,		// product code, string GUID, or descriptor
		LPCTSTR	szFeature,		// feature name
		LPCTSTR	szAttribute,	// attribute name, case-sensitive
		LPTSTR	lpValueBuf,		// returned value
		LPDWORD	pcchValueBuf	// in/out buffer character count
		) {


//	MSIHANDLE	hLocalDB=NULL;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicGetFeatureInfo(szProduct, szFeature, szAttribute, lpValueBuf, pcchValueBuf);

	case DS_PROFILE:
			return cProfile.MsicGetFeatureInfo(szProduct, szFeature, szAttribute, lpValueBuf, pcchValueBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicGetFeatureInfo(szProduct, szFeature, szAttribute, lpValueBuf, pcchValueBuf);
	
	default:
		return ERROR_;
	}
}

//--------------------------------------------------------------------------------------------------
// MsivGetComponentName:
//	Returns the name of the component, given the componentID
//	If a database is open, the value is obtained from the component table
//	If the registry, the corresponding database is opened, and the 
//	the required value is extracted from the component table
//	If a profile is in use the info is just read in from it

EXPORT UINT WINAPI MsivGetComponentName(
		LPCTSTR	szComponentId,
		LPTSTR	lpComponentName,
		LPDWORD	pcchComponentName
		) {


	if ((!lpComponentName) || (!pcchComponentName) || (*pcchComponentName<1) )
		return ERROR_INVALID_PARAMETER;

	BLANK(lpComponentName);

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicGetComponentName(szComponentId, lpComponentName, pcchComponentName);

	case DS_PROFILE:
			return cProfile.MsicGetComponentName(szComponentId, lpComponentName, pcchComponentName);

	case DS_REGISTRY: 
			return cRegistry.MsicGetComponentName(szComponentId, lpComponentName, pcchComponentName);
	
	default:
		return ERROR_;
	}
}	


//--------------------------------------------------------------------------------------------------
// MsivGetFeatureUsage
//	Returns the usage count and last use date for a feature
//	If the registry or a database is being used, the returned info is
//	from MsiGetFeatureUsage, the corresponding MSI function
//	If a profile is used, the info is read in from the profile

EXPORT UINT WINAPI MsivGetFeatureUsage(
		LPCTSTR	szProduct,			// product code
		LPCTSTR	szFeature,			// feature ID
		LPDWORD	pdwUseCount,		// returned use count
		LPWORD  pwDateUsed			// last date used (DOS date format)
		) {

	if ((!pdwUseCount) || (!pwDateUsed))
		return ERROR_INVALID_PARAMETER;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicGetFeatureUsage(szProduct, szFeature, pdwUseCount, pwDateUsed);

	case DS_PROFILE:
			return cProfile.MsicGetFeatureUsage(szProduct, szFeature, pdwUseCount, pwDateUsed);

	case DS_REGISTRY: 
			return cRegistry.MsicGetFeatureUsage(szProduct, szFeature, pdwUseCount, pwDateUsed);
	
	default:
		return ERROR_;
	}

}


//--------------------------------------------------------------------------------------------------
// MsivGetUserInfo
//	Returns the registration info about the user, product
//	If the registry or a database is being used, the returned info is
//	from MsiGetUserInfo, the corresponding MSI function
//	If a profile is used, the info is read in from the profile

EXPORT USERINFOSTATE WINAPI MsivGetUserInfo(
		LPCTSTR	szProduct,			// product code, string GUID
		LPTSTR	lpUserNameBuf,		// return user name           
		LPDWORD	pcchUserNameBuf,	// in/out buffer character count
		LPTSTR	lpOrgNameBuf,		// return company name           
		LPDWORD	pcchOrgNameBuf,	// in/out buffer character count
		LPTSTR	lpSerialBuf,		// return product serial number
		LPDWORD	pcchSerialBuf		// in/out buffer character count
		){

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicGetUserInfo(szProduct, lpUserNameBuf, pcchUserNameBuf, 
				lpOrgNameBuf, pcchOrgNameBuf, lpSerialBuf, pcchSerialBuf);

	case DS_PROFILE:
			return cProfile.MsicGetUserInfo(szProduct, lpUserNameBuf, pcchUserNameBuf, 
				lpOrgNameBuf, pcchOrgNameBuf, lpSerialBuf, pcchSerialBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicGetUserInfo(szProduct, lpUserNameBuf, pcchUserNameBuf,
				lpOrgNameBuf, pcchOrgNameBuf, lpSerialBuf, pcchSerialBuf);
	
	default:
		return USERINFOSTATE_UNKNOWN;
	}
}



// _________________________________________________________________________________________________



//--------------------------------------------------------------------------------------------------
// MsiQueryProductState
//	Returns the installed state of the product-
//	If a database is in use, the status of each component is checked, and
//	if all are okay, DEFAULT is returned. If any is broken, ABSENT is returned
//	If a profile is in use, the info is read in directly from it

EXPORT INSTALLSTATE WINAPI MsivQueryProductState(
		LPCTSTR  szProduct
		) {

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicQueryProductState(szProduct);

	case DS_PROFILE:
			return cProfile.MsicQueryProductState(szProduct);

	case DS_REGISTRY: 
			return cRegistry.MsicQueryProductState(szProduct);
	
	default:
		return INSTALLSTATE_UNKNOWN;
	}
}


//--------------------------------------------------------------------------------------------------
// MsiQueryFeatureState
//	Returns the installed state of a feature.
//	If a database is in use, the 'RunFromSource' of the feature is checked. 
//	If it is 0, LOCAL is returned else SOURCE is returned
//	If a profile is in use, the info is read in directly from it

EXPORT INSTALLSTATE WINAPI MsivQueryFeatureState(
		LPCTSTR	szProduct,
		LPCTSTR	szFeature
		) {

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicQueryFeatureState(szProduct, szFeature);

	case DS_PROFILE:
			return cProfile.MsicQueryFeatureState(szProduct, szFeature);

	case DS_REGISTRY: 
			return cRegistry.MsicQueryFeatureState(szProduct, szFeature);
	
	default:
		return INSTALLSTATE_UNKNOWN;
	}
}


//--------------------------------------------------------------------------------------------------
// MsivLocateComponent
//	Returns installation state of and full path to an installed component
//	If a database or the registry is in use, MsiLocateComponent is called
//	If a profile is in use, the info is read in directly from it

EXPORT INSTALLSTATE WINAPI MsivLocateComponent (
		LPCTSTR	szComponentId,	// component Id, string GUID
		LPTSTR	lpPathBuf,		// returned path
		LPDWORD	pcchBuf		// in/out buffer character count
 		) {
	if (lpPathBuf)
		wsprintf(lpPathBuf, g_szEmptyString);					// clear out the buffer

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicLocateComponent(szComponentId, lpPathBuf, pcchBuf);

	case DS_PROFILE:
			return cProfile.MsicLocateComponent(szComponentId, lpPathBuf, pcchBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicLocateComponent(szComponentId, lpPathBuf, pcchBuf);
	
	default:
		return INSTALLSTATE_UNKNOWN;
	}
}


//--------------------------------------------------------------------------------------------------
// MsivGetComponentPath
//	Returns installation state of and full path to an installed component
//	If a database or the registry is in use, MsiGetComponentPath is called
//	If a profile is in use, the info is read in directly from it

EXPORT INSTALLSTATE WINAPI MsivGetComponentPath(
		LPCTSTR szProductCode,	// product code, string GUID
		LPCTSTR	szComponentId,	// component Id, string GUID
		LPTSTR	lpPathBuf,		// returned path
		LPDWORD	pcchBuf		// in/out buffer character count
 		) {
	if (lpPathBuf)
		wsprintf(lpPathBuf, g_szEmptyString);					// clear out the buffer

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicGetComponentPath(szProductCode, szComponentId, lpPathBuf, pcchBuf);

	case DS_PROFILE:
			return cProfile.MsicGetComponentPath(szProductCode, szComponentId, lpPathBuf, pcchBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicGetComponentPath(szProductCode, szComponentId, lpPathBuf, pcchBuf);
	
	default:
		return INSTALLSTATE_UNKNOWN;
	}
}


// _________________________________________________________________________________________________

//--------------------------------------------------------------------------------------------------
// Functions to handle Databases
//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
// MsivOpenDatabase
//	Opens a Database. If the call to open database is successful, all 
//	subsequent calls to Msiv functions will use this database.
//	This sets the (global) g_hDatabase to the handle of the open database

EXPORT UINT WINAPI MsivOpenDatabase(
		LPCTSTR szDatabase
		) {
	g_iDataSource = DS_DATABASE;
	return cDatabase.MsicOpenDatabase(szDatabase);
}


//--------------------------------------------------------------------------------------------------
// MsivCloseDatabase
//	Closes an open database. All subsequent calls to Msiv functions will
//	assume the registry is in use, till either another database or a profile
//	is opened

EXPORT UINT WINAPI MsivCloseDatabase() {
	g_iDataSource = DS_REGISTRY;
	return cDatabase.MsicCloseDatabase();
}


//--------------------------------------------------------------------------------------------------
// MsivGetDatabaseName
//	Fills the given buffer with the name of the database in use. If a 
//	database is not being used, the buffer returned is empty ("")

EXPORT UINT WINAPI MsivGetDatabaseName(
		LPTSTR lpValueBuf,
		DWORD	*pcchValueBuf
		) {

	// make sure return buffer is not NULL
	if ((!lpValueBuf) || (!pcchValueBuf))
		return ERROR_INVALID_PARAMETER;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicGetDatabaseName(lpValueBuf, pcchValueBuf);

	case DS_PROFILE:		// fall-thru
	case DS_REGISTRY:		// fall-thru
	default:
		return ERROR_;
	}
}


// _________________________________________________________________________________________________

//--------------------------------------------------------------------------------------------------
// Functions to handle Profiles
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
// MsivSaveProfile
//	Saves a snapshot of the current configuration into an INI-format file
//	The snapshot stores the info from whatever is in use- the registry, 
//	a database, or another profile.
//	If a profile is in use, and an attempt is made to save to the same 
//	profile, the function just returns without taking any action

EXPORT UINT WINAPI MsivSaveProfile(
		LPCTSTR	szFileName
		) {

	if (!szFileName)
		return ERROR_INVALID_PARAMETER;

	return cProfile.MsicSaveProfile(szFileName);
}


//--------------------------------------------------------------------------------------------------
// MsivLoadProfile
//	Opens a Profile. 
//	All subsequent calls to Msiv functions will use this profile.
//	This sets the (global) g_szProfile to the name of the profile

EXPORT UINT WINAPI MsivLoadProfile(
		LPTSTR	szFileName
		) {

	g_iDataSource = DS_PROFILE;
	return cProfile.MsicLoadProfile(szFileName);
}



//--------------------------------------------------------------------------------------------------
// MsivCloseProfile
//	Closes an open profile. All subsequent calls to Msiv functions will
//	assume the registry is in use, till either another database or a profile
//	is opened

EXPORT UINT WINAPI MsivCloseProfile(
		) {
	g_iDataSource = DS_REGISTRY;
	return cProfile.MsicCloseProfile();
}


//--------------------------------------------------------------------------------------------------
// MsivGetProfileName
//	Fills the given buffer with the name of the profile in use. If a 
//	profile is not being used, the buffer returned is empty ("")

EXPORT UINT WINAPI MsivGetProfileName(
		LPTSTR	lpValueBuf,
		DWORD	*pcchValueBuf
		) {


	// make sure return buffer is not NULL
	if ((!lpValueBuf) || (!pcchValueBuf))
		return ERROR_INVALID_PARAMETER;

	switch (g_iDataSource){
	case DS_PROFILE:
			return cProfile.MsicGetProfileName(lpValueBuf, pcchValueBuf);

	case DS_DATABASE:		// fall-thru
	case DS_REGISTRY:		// fall-thru
	default:
		return ERROR_;
	}
}



//--------------------------------------------------------------------------------------------------
// MsivEnumClients
//	Enumerates the clients of the given component.
//	If a database is in use, ONLY the current product is enumerated if
//	it uses the component.
//	If a profile is in use, the info is returned from the profile
//	if the registry is in use, the corresponding MSI function is called

EXPORT UINT WINAPI MsivEnumClients(
	LPCTSTR	szComponent,
	DWORD	dwProductIndex,	// 0-based index into client products
	LPTSTR	lpProductBuf	// buffer of char count: cchGUID+1 (size of string GUID)
	) {


	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicEnumClients(szComponent, dwProductIndex, lpProductBuf);

	case DS_PROFILE:
			return cProfile.MsicEnumClients(szComponent, dwProductIndex, lpProductBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicEnumClients(szComponent, dwProductIndex, lpProductBuf);
	
	default:
		return ERROR_;
	}
}


// TEMP ----------------------------------------------------------------
// MsivGetProfileInfo
//	Returns Info about a profile.
//	The interface is temporary, and will be changed after a spec review

EXPORT UINT WINAPI MsivGetProfileInfo(
		UINT	iIndex,
		LPTSTR	szValue,
		DWORD	*pcchCount
		) {

	switch (g_iDataSource){
	case DS_PROFILE:
			return cProfile.MsicGetProfileInfo(iIndex, szValue, pcchCount);

	case DS_DATABASE:		// fall-thru
	case DS_REGISTRY:		// fall-thru
	default:
		return ERROR_;
	}
}



//--------------------------------------------------------------------------------------------------
// MsivEnumFilesFromComponent
//	Enumerates files of a component
//	If a database is in use, the Component and File tables are used
//	If a profile is in use, info is read in directly from it
//	If the registry is in use, the corresponding database is opened,
//	and the info is read in from the Component and File tables
//	(Waiting for MsiEnumFilesFromComponent, on Darwin Beta 2 tasklist)

EXPORT UINT WINAPI MsivEnumFilesFromComponent(
		LPCTSTR	szComponentId,			// the component GUID
		DWORD	dwFileIndex,				// o-based index into enumeration
		LPTSTR	lpValueBuf,				// returned value buffer
		DWORD	*pcchCount				// size of buffer
		) {


	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicEnumFilesFromComponent(szComponentId, dwFileIndex, lpValueBuf, pcchCount);

	case DS_PROFILE:
			return cProfile.MsicEnumFilesFromComponent(szComponentId, dwFileIndex, lpValueBuf, pcchCount);

	case DS_REGISTRY: 
			return cRegistry.MsicEnumFilesFromComponent(szComponentId, dwFileIndex, lpValueBuf, pcchCount);
	
	default:
		return ERROR_;
	}

}



// TEMP ----------------------------------------------------------------
// MsivGetFileInfo
//	Returns info about a file
//	For a list of attributes, check msispyu.h (FILEPROPERTY_*)
//	If the registry is in use, the corresponding database is used, since
//	there is no similar MSI function
//	If a database is in use, the Component and File tables are used
//	If a profile is in use, the info is read in directly
//	The interface and functionality may be changed after a spec review (?)

EXPORT UINT WINAPI MsivGetFileInfo(
		LPCTSTR szProductCode, 
		LPCTSTR	szComponentId,
		LPCTSTR	szFileName,
		LPCTSTR	szAttribute,
		LPTSTR	lpValueBuf,
		DWORD	*pcchValueBuf
		) {

	// make sure return buffer is valid
	if ((!lpValueBuf) || (!pcchValueBuf) || (*pcchValueBuf < 1))
		return ERROR_INVALID_PARAMETER;

	switch (g_iDataSource){
	case DS_DATABASE:
			return cDatabase.MsicGetFileInfo(szProductCode, szComponentId, szFileName, szAttribute, lpValueBuf, pcchValueBuf);

	case DS_PROFILE:
			return cProfile.MsicGetFileInfo(szProductCode, szComponentId, szFileName, szAttribute, lpValueBuf, pcchValueBuf);

	case DS_REGISTRY: 
			return cRegistry.MsicGetFileInfo(szProductCode, szComponentId, szFileName, szAttribute, lpValueBuf, pcchValueBuf);
	
	default:
		return ERROR_;
	}

}




// ___________________________________________________________________________________________
//
//	CSpyDatabase Class Implementation
// ___________________________________________________________________________________________


CSpyDatabase::CSpyDatabase() {
	MsicCloseDatabase();		// reset member variables
}

/////////////////////////////////////////////////
// destructor
CSpyDatabase::~CSpyDatabase() {	
	// nothing to do
}


UINT WINAPI CSpyDatabase::MsicOpenDatabase(LPCTSTR szDatabase) 
{
	UINT iReturnValue;
	MsicCloseDatabase();		// blank out m_szProductCode;

	if ((iReturnValue = MSI::MsiOpenDatabase(szDatabase, MSIDBOPEN_READONLY, &m_hDatabase)) != ERROR_SUCCESS)
		return iReturnValue;
		
	lstrcpy(m_szDatabaseName, szDatabase);			// store current DB name

	// find the ProductCode for the current product
	PMSIHANDLE hProductView;
	if (ERROR_SUCCESS == MSI::MsiDatabaseOpenView(m_hDatabase, 
						 TEXT("SELECT Value FROM Property WHERE Property='ProductCode'"), 
						 &hProductView))  

		if (ERROR_SUCCESS == MSI::MsiViewExecute(hProductView, 0)) 
		{
			// fetch ProductCode
			PMSIHANDLE hProductRec;
			if ((MSI::MsiViewFetch(hProductView, &hProductRec) == ERROR_SUCCESS) 
				&& (MSI::MsiRecordDataSize(hProductRec, 1) > 0))
				{
					DWORD cchProductBuf = MAX_GUID+1;
					if (ERROR_SUCCESS == MSI::MsiRecordGetString(hProductRec, 1, m_szProductCode, &cchProductBuf))
						return ERROR_SUCCESS;		// lpProductBuf contains required ProductCode
				}
		}

	// something failed above
	MsicCloseDatabase();		// reset member variables
	return ERROR_OPEN_FAILED;
}


UINT WINAPI CSpyDatabase::MsicOpenProduct(LPCTSTR szProductCode) {

	MsicCloseDatabase();

	// no UI- else 'preparing to install' dialog displayed
	INSTALLUILEVEL hPreviousUILevel = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL); 
	PMSIHANDLE	hInstall;

	m_hDatabase = (MsiOpenProduct(szProductCode, &hInstall) == ERROR_SUCCESS)?MsiGetActiveDatabase(hInstall):0;

	// reset UI Level
	MsiSetInternalUI(hPreviousUILevel, NULL);

	return m_hDatabase?
			(lstrcpy(m_szProductCode, szProductCode),ERROR_SUCCESS):
			ERROR_OPEN_FAILED;

	return ERROR_SUCCESS;
}


UINT WINAPI CSpyDatabase::MsicCloseDatabase() 
{
	// null everything out
	m_hDatabase = NULL;
	BLANK(m_szDatabaseName);
	BLANK(m_szProductCode);

	return ERROR_SUCCESS;
}


UINT WINAPI CSpyDatabase::MsicGetDatabaseName(LPTSTR lpValueBuf, LPDWORD pcchValueBuf) 
{
	lstrcpyn(lpValueBuf, m_szDatabaseName, *pcchValueBuf);
	*pcchValueBuf=lstrlen(lpValueBuf);
	return ERROR_SUCCESS;
}


UINT WINAPI CSpyDatabase::MsicEnumProducts(const DWORD dwProductIndex, LPTSTR lpProductBuf) 
{
	if (!lpProductBuf)
		return ERROR_INVALID_PARAMETER;

	// only one product will be enumerated from database
	if (dwProductIndex != 0)
		return ERROR_NO_MORE_ITEMS;

	lstrcpy(lpProductBuf, m_szProductCode);
	return ERROR_SUCCESS;
}


UINT WINAPI CSpyDatabase::MsicEnumFeatures(
		LPCTSTR szProduct, 
  const DWORD	dwFeatureIndex, 
		LPTSTR	lpFeatureBuf,			// MAX_FEATURE_CHARS+1 chars long
		LPTSTR	lpParentBuf				// NULL or MAX_FEATURE_CHARS+1 chars long
		) 
{

	if (!szProduct || (lstrlen(szProduct) != cchProductCode) ||
		 !lpFeatureBuf)
		 return ERROR_INVALID_PARAMETER;
	
	if (lstrcmp(m_szProductCode, szProduct))
		return ERROR_UNKNOWN_PRODUCT;

	static DWORD		dwPrevIndex		= 0;		// can't be -1 as View won't be opened then if dwFeatureIndex==0
	static PMSIHANDLE	hFeatureView	= NULL;		// PMSI so no close required
	static PMSIHANDLE	hFeatureRec		= NULL;	

	if (++dwPrevIndex != dwFeatureIndex) // if we receive an unexpected index then we start afresh
	{
		// we can't handle an unexpected index other than 0
		if (dwFeatureIndex != 0)
			return ERROR_INVALID_PARAMETER;

		if (ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, TEXT("SELECT Feature,Feature_Parent FROM Feature"), &hFeatureView))
			return ERROR_BAD_CONFIGURATION;

		if (ERROR_SUCCESS != MSI::MsiViewExecute(hFeatureView, 0))
			return ERROR_BAD_CONFIGURATION;

		dwPrevIndex = 0;
	}
		
	if ((ERROR_SUCCESS == MSI::MsiViewFetch(hFeatureView, &hFeatureRec))
		&& (MSI::MsiRecordDataSize(hFeatureRec, 1) > 0))
	{
		DWORD cchFeatureBuf = MAX_FEATURE_CHARS+1;
		MSI::MsiRecordGetString(hFeatureRec, 1, lpFeatureBuf, &cchFeatureBuf);

		if (lpParentBuf) 
		{
			BLANK(lpParentBuf);
			cchFeatureBuf  = MAX_FEATURE_CHARS+1;
			if (MSI::MsiRecordDataSize(hFeatureRec, 2) > 0) 
				MSI::MsiRecordGetString(hFeatureRec, 2, lpParentBuf, &cchFeatureBuf);
		}

		return ERROR_SUCCESS;
	}

	// view fetch failed: no more data
	dwPrevIndex = 0;
	return ERROR_NO_DATA;
}



UINT WINAPI CSpyDatabase::MsicEnumComponents(const DWORD dwComponentIndex, LPTSTR lpComponentBuf) 
{

	if (!lpComponentBuf)
		return ERROR_INVALID_PARAMETER;

	static  DWORD		dwPrevIndex		= 0;
	static	PMSIHANDLE	hComponentRec	= NULL;
	static	PMSIHANDLE	hComponentView	= NULL;


	if (++dwPrevIndex != dwComponentIndex)	// if we recv an unexpected index we start afresh
	{
		// we can't handle an unexpected index other than 0
		if (dwComponentIndex != 0)
			return ERROR_INVALID_PARAMETER;
//!!optimise
		if(ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, TEXT("SELECT ComponentId FROM Component"), &hComponentView))
			return ERROR_BAD_CONFIGURATION;

		if (ERROR_SUCCESS != MSI::MsiViewExecute(hComponentView, 0))
			return ERROR_BAD_CONFIGURATION;

		dwPrevIndex = 0;
	}

	UINT iErrorCode, iSize;
	if ((ERROR_SUCCESS == (iErrorCode =MSI::MsiViewFetch(hComponentView, &hComponentRec)))
		&& ((iSize = MSI::MsiRecordDataSize(hComponentRec, 1)) > 0))
	{
		DWORD	cchComponentBuf = cchGUID + 1;
		MSI::MsiRecordGetString(hComponentRec, 1, lpComponentBuf, &cchComponentBuf);

		// all is well- lpComponentBuf has the reqd value
		return ERROR_SUCCESS;
	}

	// view fetch failed- no more components
	dwPrevIndex = 0;
	return ERROR_NO_DATA;
}


UINT WINAPI CSpyDatabase::MsicEnumComponentsFromFeature(
		  LPCTSTR	szProduct, 
		  LPCTSTR	szFeature, 
	const DWORD		dwComponentIndex, 
		  LPTSTR	lpComponentBuf,
		  LPTSTR	lpComponentNameBuf,
		  LPDWORD	pcchComponentNameBuf) 
{

	if (!szProduct || !szFeature || !lpComponentBuf || (lpComponentNameBuf && !pcchComponentNameBuf))
		return ERROR_INVALID_PARAMETER;
	
	if (lstrcmp(m_szProductCode, szProduct))
		return ERROR_UNKNOWN_PRODUCT;

	static DWORD		dwPrevIndex		= 0;
	static PMSIHANDLE	hComponentView	= NULL;		// PMSI so no close required
	static PMSIHANDLE	hComponentRec	= NULL;	
	static TCHAR		szPrevFeature[MAX_FEATURE_CHARS+1];

	if ((++dwPrevIndex != dwComponentIndex)			// if we receive an unexpected index then we start afresh
		|| (lstrcmp(szFeature, szPrevFeature)))		// or a new feature
	{
		// we can't handle an unexpected index other than 0
		if (dwComponentIndex != 0) 
			return ERROR_INVALID_PARAMETER;
	
		TCHAR	szCompQuery[60+MAX_FEATURE_CHARS+1];
		wsprintf(szCompQuery, TEXT("SELECT Component_ FROM FeatureComponents WHERE Feature_='%s'"), szFeature);

		if(ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, szCompQuery, &hComponentView)) 
			return ERROR_BAD_CONFIGURATION;

		if (ERROR_SUCCESS != MSI::MsiViewExecute(hComponentView, 0))
			return ERROR_BAD_CONFIGURATION;

		lstrcpyn(szPrevFeature, szFeature, MAX_FEATURE_CHARS);
		dwPrevIndex = 0;
	}


	if ((ERROR_SUCCESS == MSI::MsiViewFetch(hComponentView, &hComponentRec))
		&& (MSI::MsiRecordDataSize(hComponentRec, 1) > 0))
	{

		static PMSIHANDLE	hCompView2	= NULL;
		static PMSIHANDLE	hCompRec2	= NULL;
		static TCHAR		szCompQuery2[52+MAX_COMPONENT_CHARS];
		DWORD	cchComponentBuf = MAX_COMPONENT_CHARS+1;

		// get the component name
		if (lpComponentNameBuf) 
		{
			MSI::MsiRecordGetString(hComponentRec, 1, lpComponentNameBuf, pcchComponentNameBuf); 
			wsprintf(szCompQuery2, TEXT("SELECT ComponentId FROM Component WHERE Component='%s'"), lpComponentNameBuf);
		} 
		else 
		{
			TCHAR	szComponentName[MAX_COMPONENT_CHARS+1];
			MSI::MsiRecordGetString(hComponentRec, 1, szComponentName, &cchComponentBuf); 
			wsprintf(szCompQuery2, TEXT("SELECT ComponentId FROM Component WHERE Component='%s'"), szComponentName);
		}
		
		// we got the component name, now we need to get the component ID ...
		if(ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, szCompQuery2, &hCompView2)) 
			return ERROR_BAD_CONFIGURATION;

		if (ERROR_SUCCESS != MSI::MsiViewExecute(hCompView2, 0))
			return ERROR_BAD_CONFIGURATION;

		if ((ERROR_SUCCESS == MSI::MsiViewFetch(hCompView2, &hCompRec2))
			&& (MSI::MsiRecordDataSize(hCompRec2, 1) > 0))
		{
			cchComponentBuf = cchGUID + 1;
			MSI::MsiRecordGetString(hCompRec2, 1, lpComponentBuf, &cchComponentBuf); 

			// we found the reqd component Id, all is well
			return ERROR_SUCCESS;
		}
	}

	dwPrevIndex = 0;
	lstrcpy(szPrevFeature, m_szNullString);
	return ERROR_NO_DATA;
}


UINT WINAPI CSpyDatabase::MsicGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentName, LPDWORD pcchComponentName) 
{ //!!optimise?

	if (!lpComponentName || !pcchComponentName)
		return ERROR_INVALID_PARAMETER;

	TCHAR szCompQuery[52+MAX_GUID];
	PMSIHANDLE hCompView;

	// Set up a query to find the component name from the component Id
	wsprintf(szCompQuery, TEXT("SELECT Component FROM Component WHERE ComponentId='%s'"), szComponentId);
	if(ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, szCompQuery, &hCompView))
		return ERROR_BAD_CONFIGURATION;
	
	if (ERROR_SUCCESS != MSI::MsiViewExecute(hCompView, 0)) 
		return ERROR_BAD_CONFIGURATION;

	// Fetch the record
	PMSIHANDLE hCompRec;
	if ((ERROR_SUCCESS == MSI::MsiViewFetch(hCompView, &hCompRec))
		&& (MSI::MsiRecordDataSize(hCompRec, 1)>0))
	{
			MSI::MsiRecordGetString(hCompRec, 1, lpComponentName, pcchComponentName);
			return ERROR_SUCCESS;
	}

	return ERROR_NO_DATA;
}


UINT WINAPI CSpyDatabase::MsicGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf) 
{

	if (!lpValueBuf || !pcchValueBuf || !szAttribute || !szProduct)
		return ERROR_INVALID_PARAMETER;

	if (lstrcmp(m_szProductCode, szProduct))
		return ERROR_UNKNOWN_PRODUCT;

	// a mapping from the install_properties in Msi to the corresponding
	// properties in the database. Some don't have matches- this function
	// returns ERROR_NO_DATA if this is the case
	lstrcpy(lpValueBuf, m_szNullString);
	TCHAR rgszProperties[14][MAX_ATTRIB_CHARS+1] = {
		INSTALLPROPERTY_PRODUCTNAME,			TEXT("ProductName"),
		INSTALLPROPERTY_INSTALLEDPRODUCTNAME,	TEXT("ProductName"),
		INSTALLPROPERTY_VERSIONSTRING,			TEXT("ProductVersion"),
		INSTALLPROPERTY_HELPLINK,				TEXT("SupportURL"),
		INSTALLPROPERTY_HELPTELEPHONE,			TEXT("SupportPhone"),
		INSTALLPROPERTY_PUBLISHER,				TEXT("Manufacturer"),
		TEXT(""),								TEXT("")
	};

	// find out which attribute is needed
	TCHAR szAttrib[MAX_ATTRIB_CHARS+1]=TEXT("");
	for (int i=0; ((i<30) && (!lstrcmp(szAttrib, m_szNullString))); i+=2)
	{
		if (!lstrcmp(szAttribute, rgszProperties[i]))
			lstrcpy(szAttrib, rgszProperties[i+1]);
	}

	// attribute isn't one of the ones recognised above-
	// maybe it is something new in the DB, try finding it directly ...
	if (!lstrcmp(szAttrib, m_szNullString)) 
		lstrcpy(szAttrib, szAttribute);

	// set up and execute the query ...
	TCHAR szProdQuery[MAX_ATTRIB_CHARS+50];
	PMSIHANDLE hProdView;
	wsprintf(szProdQuery, TEXT("SELECT Value FROM Property WHERE Property='%s'"), szAttrib);
	if(ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, szProdQuery, &hProdView)) 
		return ERROR_BAD_CONFIGURATION;

	if (ERROR_SUCCESS != MSI::MsiViewExecute(hProdView, 0))
		return ERROR_BAD_CONFIGURATION;

	// fetch required record
	PMSIHANDLE hProdRec = NULL;
	if ((ERROR_SUCCESS == MSI::MsiViewFetch(hProdView, &hProdRec))
		&& (MSI::MsiRecordDataSize(hProdRec, 1) > 0))
	{
		MSI::MsiRecordGetString(hProdRec, 1, lpValueBuf, pcchValueBuf);
		return ERROR_SUCCESS;
	}
	
	return ERROR_NO_DATA;
}


UINT WINAPI CSpyDatabase::MsicGetFeatureInfo(
		LPCTSTR szProduct, 
		LPCTSTR szFeature, 
		LPCTSTR szAttribute, 
		LPTSTR	lpValueBuf, 
		LPDWORD pcchValueBuf
		) 
{
	if (!szProduct || !szFeature || !szAttribute || !lpValueBuf || !pcchValueBuf)
		return ERROR_INVALID_PARAMETER;

	if (lstrcmp(m_szProductCode, szProduct))
		return ERROR_UNKNOWN_PRODUCT;


	TCHAR szFeatureQuery[MAX_FEATURE_CHARS+MAX_ATTRIB_CHARS+60];
	PMSIHANDLE hFeatureView;

	// set up and execute query to fetch the required property
	wsprintf(szFeatureQuery, TEXT("SELECT %s FROM Feature WHERE Feature ='%s'"), szAttribute, szFeature);
	if(ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, szFeatureQuery, &hFeatureView))
		return ERROR_BAD_CONFIGURATION;
	
	if(ERROR_SUCCESS != MSI::MsiViewExecute(hFeatureView, 0))
		return ERROR_BAD_CONFIGURATION;

	// fetch the record
	PMSIHANDLE hFeatureRec;
	if ((ERROR_SUCCESS == MSI::MsiViewFetch(hFeatureView, &hFeatureRec))
		&& (MSI::MsiRecordDataSize(hFeatureRec, 1) > 0))
	{
		MSI::MsiRecordGetString(hFeatureRec, 1, lpValueBuf, pcchValueBuf);
		return ERROR_SUCCESS;
	}

	return ERROR_NO_DATA;	// the required value was not found
}


UINT WINAPI CSpyDatabase::MsicEnumClients(LPCTSTR szComponent, const DWORD dwProductIndex, LPTSTR lpProductBuf) 
{ 

	if (!szComponent || !lpProductBuf)
		return ERROR_INVALID_PARAMETER;

	// will return at most 1 client- the current product
	if (dwProductIndex != 0) 
		return ERROR_NO_DATA;

	// query the database to get the component
	PMSIHANDLE hCompView;
	TCHAR szCompQuery[MAX_COMPONENT_CHARS+100];
	
	wsprintf(szCompQuery, TEXT("SELECT ComponentId FROM Component WHERE ComponentId='%s'"), szComponent);
	if(ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, szCompQuery, &hCompView))
		return ERROR_BAD_CONFIGURATION;

	if (ERROR_SUCCESS != MSI::MsiViewExecute(hCompView, 0))
		return ERROR_BAD_CONFIGURATION;

	// check if the component is present in the database
	// if it is, enumerate the current product
	PMSIHANDLE	hCompRec;
	if ((ERROR_SUCCESS == MSI::MsiViewFetch(hCompView, &hCompRec))
		&& (MSI::MsiRecordDataSize(hCompRec, 1) > 0))
	{
		lstrcpy(lpProductBuf, m_szProductCode);
		return ERROR_SUCCESS;
	}

	// component was not found in the database-
	// the current product is not a client of the component
	return ERROR_NO_DATA;
}


UINT WINAPI CSpyDatabase::MsicEnumFilesFromComponent(
		LPCTSTR szComponentId, 
		DWORD	dwFileIndex, 
		LPTSTR	lpValueBuf, 
		LPDWORD pcchValueBuf) 
{

	static DWORD	dwPrevIndex = 0;
	static TCHAR	szPrevComponent[MAX_GUID+1];

	static PMSIHANDLE hFileView = NULL;
	static PMSIHANDLE hFileRec  = NULL;



	if ((++dwPrevIndex != dwFileIndex)					// if we recv an unexpected index, we start afresh
		|| lstrcmp(szComponentId, szPrevComponent))		// ditto if we recv a new component
	{

		// we can't handle an unexpected index other than 0
		if (dwFileIndex != 0)
			return ERROR_INVALID_PARAMETER;

		// set up file query
		TCHAR szFileQuery[106+MAX_GUID];
		wsprintf(szFileQuery,
			TEXT("SELECT File FROM File,Component WHERE File.Component_ = Component.Component AND Component.ComponentId = '%s'"),
			szComponentId);

		// and execute it
		if(ERROR_SUCCESS != MSI::MsiDatabaseOpenView(m_hDatabase, szFileQuery, &hFileView))
			return ERROR_BAD_CONFIGURATION;

		if(ERROR_SUCCESS != MSI::MsiViewExecute(hFileView, 0))
			return ERROR_BAD_CONFIGURATION;

		dwPrevIndex = 0;
	}

	if ((ERROR_SUCCESS == MSI::MsiViewFetch(hFileView, &hFileRec))
		&& (MSI::MsiRecordDataSize(hFileRec, 1) >0))
	{
		MSI::MsiRecordGetString(hFileRec, 1, lpValueBuf, pcchValueBuf);
		return ERROR_SUCCESS;		// lpValueBuf has reqd data
	}

	// view fetch failed
	dwPrevIndex = 0;
	return ERROR_NO_DATA;
}



UINT WINAPI CSpyDatabase::MsicGetFileInfo(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf) 
{
	// set up and execute query to find the file attribute
	TCHAR szFileQuery[MAX_PATH+1];
	PMSIHANDLE hFileView;
	PMSIHANDLE hFileRec;

	wsprintf(szFileQuery, TEXT("SELECT %s FROM File WHERE File ='%s'"), szAttribute, szFileName);
	if ((ERROR_SUCCESS == MSI::MsiDatabaseOpenView(m_hDatabase, szFileQuery, &hFileView))
		&& (ERROR_SUCCESS == MSI::MsiViewExecute(hFileView, 0))
		&& (ERROR_SUCCESS == MSI::MsiViewFetch(hFileView, &hFileRec))
		&& (MSI::MsiRecordDataSize(hFileRec, 1) > 0))
	{

		MSI::MsiRecordGetString(hFileRec, 1, lpValueBuf, pcchValueBuf);

		if (!lstrcmp(szAttribute, FILEPROPERTY_NAME))
		{
			int i = -1;
			while (lpValueBuf[++i])
				if (TEXT('|') == lpValueBuf[i])
				{	// filename is in the "short|long" format.

					static int iFileSystemType = -1;
					if (-1 == iFileSystemType)
					{	// we don't know the file system type yet

						HKEY hkFileSystem;
						BYTE bData[4];
						DWORD cbData = 4;
						DWORD dwType;

						// query the win-31 key. If key is 0, use long file names, else use short file names.
						RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\FileSystem"),
							0, KEY_EXECUTE, &hkFileSystem);
						RegQueryValueEx(hkFileSystem, TEXT("Win31FileSystem"), NULL, &dwType, bData, &cbData);

						iFileSystemType = (int) bData[0];
					}

					if (iFileSystemType)	
					{	// short file name			
						lpValueBuf[i]= '\0';	// change "short|long" to "short\0"
						*pcchValueBuf=i;
					}
					else
					{	// long file name
						*pcchValueBuf-=i;
						memmove(lpValueBuf, lpValueBuf+ sizeof(TCHAR)*i, *pcchValueBuf + sizeof(TCHAR));	// move from "short|long" to "long"
					}

					return ERROR_SUCCESS;
				}

			return ERROR_SUCCESS;
		}

	}


// TODO: suboptimal. need to fix this part after spec review (?).

	// property does not exist in the file table.
	// for other properties, we need the full file path.
	TCHAR	szFileLocation[MAX_PATH+1];
	DWORD	cchFileLocation = MAX_PATH+1;
	if (ERROR_SUCCESS != MsicGetFileInfo(szProductCode, szComponentId, szFileName, FILEPROPERTY_NAME, szFileLocation, &cchFileLocation))
		return ERROR_NO_DATA;

	// we have file name, now find full path.
	TCHAR	szComponentPath[MAX_PATH+1];
	TCHAR	szLocation[MAX_PATH+1];
	WIN32_FIND_DATA	fdFileData;

	DWORD cchCount=MAX_PATH+1;
	MsicGetComponentPath(szProductCode, szComponentId, szComponentPath, &cchCount);
	UINT iLength=lstrlen(szComponentPath)+1;

	while ((szComponentPath[--iLength] != TEXT('\\')) && iLength)
		;

	lstrcpyn(szLocation, szComponentPath, iLength+1);
	lstrcat(szLocation, TEXT("\\"));
	lstrcat(szLocation, szFileLocation);

	// we have the full path- now try locating the file
	if (FindFirstFile(szLocation, &fdFileData) == INVALID_HANDLE_VALUE)
	{
		if (!lstrcmp(szAttribute, FILEPROPERTY_STATUS)) 
			BLANK (lpValueBuf);
//			lstrcpy(lpValueBuf, TEXT("File Not Found"));		//!! localisation
		return ERROR_NO_DATA;
	}
	else 
	{

// TODO Localisation below.
		// we found the file- now check which property is needed
		TCHAR	szTempBuffer[30]= TEXT("");
		SYSTEMTIME stSystemTime;
		FILETIME	ftLocalTime;

		if (!lstrcmp(szAttribute, FILEPROPERTY_ACTUALSIZE)) 
		{
			// actual size
			wsprintf(szTempBuffer, TEXT("%d"), (fdFileData.nFileSizeHigh * MAXDWORD) + fdFileData.nFileSizeLow);
		} 
		else if (!lstrcmp(szAttribute, FILEPROPERTY_CREATIONTIME)) 
		{
			// file creation date and time
			FileTimeToLocalFileTime(&fdFileData.ftCreationTime, &ftLocalTime);
			FileTimeToSystemTime(&ftLocalTime, &stSystemTime);
			wsprintf(szTempBuffer, TEXT("%2.2d-%2.2d-%2.2d (%2.2d:%2.2d:%2.2d)"), 
				stSystemTime.wMonth, stSystemTime.wDay, stSystemTime.wYear,
				stSystemTime.wHour, stSystemTime.wMinute,	stSystemTime.wSecond);
		}
		else if (!lstrcmp(szAttribute, FILEPROPERTY_LASTWRITETIME)) 
		{
			// last modification date and time
			FileTimeToLocalFileTime(&fdFileData.ftLastWriteTime, &ftLocalTime);
			FileTimeToSystemTime(&ftLocalTime, &stSystemTime);
			wsprintf(szTempBuffer, TEXT("%2.2d-%2.2d-%2.2d (%2.2d:%2.2d:%2.2d)"), 
				stSystemTime.wMonth,
				stSystemTime.wDay,
				stSystemTime.wYear,
				stSystemTime.wHour,
				stSystemTime.wMinute,
				stSystemTime.wSecond);
		} 
		else if (!lstrcmp(szAttribute, FILEPROPERTY_LASTACCESSTIME)) 
		{
			// last access date and time
			FileTimeToLocalFileTime(&fdFileData.ftLastAccessTime, &ftLocalTime);
			FileTimeToSystemTime(&ftLocalTime, &stSystemTime);
			wsprintf(szTempBuffer, TEXT("%2.2d-%2.2d-%2.2d (%2.2d:%2.2d:%2.2d)"), 
				stSystemTime.wMonth,
				stSystemTime.wDay,
				stSystemTime.wYear,
				stSystemTime.wHour,
				stSystemTime.wMinute,
				stSystemTime.wSecond);
		} 
		else if (!lstrcmp(szAttribute, FILEPROPERTY_STATUS)) 
		{
			// file status
			wsprintf(szFileQuery, TEXT("SELECT FileSize FROM File WHERE File ='%s'"), szFileName);
			if(ERROR_SUCCESS == MSI::MsiDatabaseOpenView(m_hDatabase, szFileQuery, &hFileView))
			{
				if(ERROR_SUCCESS == MSI::MsiViewExecute(hFileView, 0))
				{
					if (((MSI::MsiViewFetch(hFileView, &hFileRec)) == ERROR_SUCCESS) && hFileRec) 
					{
						TCHAR	szFileSize[30];
						UINT	cbFeatureRec = MSI::MsiRecordDataSize(hFileRec, 1);	
						BLANK(szFileSize);

						cchCount = 30;
						MSI::MsiRecordGetString(hFileRec, 1, szFileSize, &cchCount);
						wsprintf(szTempBuffer, TEXT("%d"), (fdFileData.nFileSizeHigh * MAXDWORD) + fdFileData.nFileSizeLow);
						if (!lstrcmp(szTempBuffer, szFileSize))
							lstrcpy(szTempBuffer, FILESTATUS_OKAY);
						else
							lstrcpy(szTempBuffer, FILESTATUS_DIFFSIZE);
					}
				}
			}

		} 
		else
			return ERROR_UNKNOWN_PROPERTY;

		lstrcpy (lpValueBuf, szTempBuffer);
		*pcchValueBuf = lstrlen(lpValueBuf);

		return ERROR_SUCCESS;
	}

	return ERROR_NO_DATA;
}

#if 0 //t-guhans 17Aug98
{
	// set up and execute query to find the file attribute
	TCHAR szFileQuery[MAX_PATH+1];
	PMSIHANDLE hFileView;
	PMSIHANDLE hFileRec;

	wsprintf(szFileQuery, TEXT("SELECT %s FROM File WHERE File ='%s'"), szAttribute, szFileName);
	if (ERROR_SUCCESS == MSI::MsiDatabaseOpenView(m_hDatabase, szFileQuery, &hFileView))
	{
		if (ERROR_SUCCESS == MSI::MsiViewExecute(hFileView, 0))
		{
			if ((ERROR_SUCCESS == MSI::MsiViewFetch(hFileView, &hFileRec)) && (hFileRec))
			{
				UINT	cbFeatureRec = MSI::MsiRecordDataSize(hFileRec, 1);	
				BLANK(lpValueBuf);

				if (cbFeatureRec > 0) 
					MSI::MsiRecordGetString(hFileRec, 1, lpValueBuf, pcchValueBuf);
				if (!lstrcmp(szAttribute, FILEPROPERTY_NAME)) 
				{
					// make sure that if filename is in "short|long" format,
					// only the appropriate name is returned
					UINT	iTemp=0;
					while ((lpValueBuf[iTemp] != '\0') && (lpValueBuf[iTemp] != '|'))
						iTemp++;

					if (lpValueBuf[iTemp] == '|') 
					{
						// filename is in "short|long" format, find out which one to use
						// this info is obtained from the Win31FileSystem attribute in the
						// registry. If Win31FileSystem is set (1), short names are in use
						// else we should return the long name

						HKEY	hkResult;
						RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
							TEXT("SYSTEM\\CurrentControlSet\\Control\\FileSystem"),
							0, KEY_EXECUTE, &hkResult);

						BYTE	bData[4];
						DWORD	cbData=4;
						DWORD	dwType;
						RegQueryValueEx(hkResult, TEXT("Win31FileSystem"), NULL, 
							&dwType, bData, &cbData);

						if (bData[0] != '\0') 
						{
							// short name is needed ... just replace the "|" by the termination
							// character in "short|long".
							lpValueBuf[iTemp]= '\0';
							*pcchValueBuf=iTemp;
						}
						else 
						{
							// long names are in use ... copy over the long name to the 
							// beginning of the buffer and reduce size of the buffer
							*pcchValueBuf-=iTemp;
							memmove(lpValueBuf, lpValueBuf+(sizeof(TCHAR)*(iTemp+1)), ((*pcchValueBuf)+sizeof(TCHAR)));		//unicode issue.
						}
					}
				}
			
				return ERROR_SUCCESS;
//				RETURNSUCCESS(hFileRec, hFileView)
			}
		}
	}

//	MsiCloseHandle(hFileRec);
//	MsiCloseHandle(hFileView);

	// get the file name to get the other properties
	DWORD cchCount;
	BOOL fOkay=FALSE;
	TCHAR	szFileLoc[MAX_PATH+1];
	wsprintf(szFileQuery, TEXT("SELECT FileName FROM File WHERE File ='%s'"), szFileName);
	if(ERROR_SUCCESS == MSI::MsiDatabaseOpenView(m_hDatabase, szFileQuery, &hFileView))
	{
		if(ERROR_SUCCESS == MSI::MsiViewExecute(hFileView, 0))
		{
			if (((MSI::MsiViewFetch(hFileView, &hFileRec)) == ERROR_SUCCESS) && hFileRec) 
			{
				fOkay = TRUE;

				TCHAR	szFileSize[30];
				UINT	cbFeatureRec = MSI::MsiRecordDataSize(hFileRec, 1);	
				BLANK(szFileSize);

				cchCount = MAX_PATH+1;
				MSI::MsiRecordGetString(hFileRec, 1, szFileLoc, &cchCount);
				UINT	iTemp=0;
				while ((szFileLoc[iTemp] != '\0') && (szFileLoc[iTemp] != '|'))
					iTemp++;

				if (szFileLoc[iTemp] == '|') 
				{

					HKEY	hkResult;
					RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
						TEXT("SYSTEM\\CurrentControlSet\\Control\\FileSystem"),
						0, KEY_EXECUTE, &hkResult);

					BYTE	bData[4];
					DWORD	cbData=4;
					DWORD	dwType;
					RegQueryValueEx(hkResult, TEXT("Win31FileSystem"), NULL, 
						&dwType, bData, &cbData);

					if (bData[0] != '\0') 
					{
						szFileLoc[iTemp]= '\0';
						cchCount=iTemp;
					}
					else 
					{
						cchCount-=iTemp;
						memmove(szFileLoc, szFileLoc+(sizeof(TCHAR)*(iTemp+1)), ((cchCount)+(sizeof(TCHAR))));		//unicode issue.
					}
				}
			}
		}
	} 

//	MsiCloseHandle(hFileRec);
//	MsiCloseHandle(hFileView);

	if (!fOkay) 
	{
		// could not get file name
		BLANK(lpValueBuf);
		return ERROR_;
	}

	TCHAR	szComponentPath[MAX_GUID+1];
	TCHAR	szLocation[MAX_PATH+1];
	WIN32_FIND_DATA	fdFileData;

	cchCount=MAX_PATH+1;
//	MsicLocateComponent(szComponentId, szComponentPath, &cchCount);
	MsicGetComponentPath(szProductCode, szComponentId, szComponentPath, &cchCount);
	UINT iLength=lstrlen(szComponentPath);

	// we have the file name- now find full path
	while ((szComponentPath[iLength] != '\\') && (iLength>0))
		iLength--;

	lstrcpyn(szLocation, szComponentPath, iLength+1);
	lstrcat(szLocation, TEXT("\\"));
	lstrcat(szLocation, szFileLoc);

	// we have the full path- now try locating the file
	if (FindFirstFile(szLocation, &fdFileData) == INVALID_HANDLE_VALUE)
	{
		if (!lstrcmp(szAttribute, FILEPROPERTY_STATUS)) 
			lstrcpy(lpValueBuf, TEXT("File Not Found"));
		else 
			BLANK(lpValueBuf);
		return ERROR_SUCCESS;

	}
	else 
	{
		// we found the file- now check which property is needed
		TCHAR	szTempBuffer[30]= TEXT("");
		SYSTEMTIME stSystemTime;
		FILETIME	ftLocalTime;

		if (!lstrcmp(szAttribute, FILEPROPERTY_ACTUALSIZE)) 
		{
			// actual size
			wsprintf(szTempBuffer, TEXT("%d"), (fdFileData.nFileSizeHigh * MAXDWORD) + fdFileData.nFileSizeLow);
		} 
		else if (!lstrcmp(szAttribute, FILEPROPERTY_CREATIONTIME)) 
		{
			// file creation date and time
			FileTimeToLocalFileTime(&fdFileData.ftCreationTime, &ftLocalTime);
			FileTimeToSystemTime(&ftLocalTime, &stSystemTime);
			wsprintf(szTempBuffer, TEXT("%2.2d-%2.2d-%2.2d (%2.2d:%2.2d:%2.2d)"), 
				stSystemTime.wMonth, stSystemTime.wDay, stSystemTime.wYear,
				stSystemTime.wHour, stSystemTime.wMinute,	stSystemTime.wSecond);
		}
		else if (!lstrcmp(szAttribute, FILEPROPERTY_LASTWRITETIME)) 
		{
			// last modification date and time
			FileTimeToLocalFileTime(&fdFileData.ftLastWriteTime, &ftLocalTime);
			FileTimeToSystemTime(&ftLocalTime, &stSystemTime);
			wsprintf(szTempBuffer, TEXT("%2.2d-%2.2d-%2.2d (%2.2d:%2.2d:%2.2d)"), 
				stSystemTime.wMonth,
				stSystemTime.wDay,
				stSystemTime.wYear,
				stSystemTime.wHour,
				stSystemTime.wMinute,
				stSystemTime.wSecond);
		} 
		else if (!lstrcmp(szAttribute, FILEPROPERTY_LASTACCESSTIME)) 
		{
			// last access date and time
			FileTimeToLocalFileTime(&fdFileData.ftLastAccessTime, &ftLocalTime);
			FileTimeToSystemTime(&ftLocalTime, &stSystemTime);
			wsprintf(szTempBuffer, TEXT("%2.2d-%2.2d-%2.2d (%2.2d:%2.2d:%2.2d)"), 
				stSystemTime.wMonth,
				stSystemTime.wDay,
				stSystemTime.wYear,
				stSystemTime.wHour,
				stSystemTime.wMinute,
				stSystemTime.wSecond);
		} 
		else if (!lstrcmp(szAttribute, FILEPROPERTY_STATUS)) 
		{
			// file status
			wsprintf(szFileQuery, TEXT("SELECT FileSize FROM File WHERE File ='%s'"), szFileName);
			if(ERROR_SUCCESS == MSI::MsiDatabaseOpenView(m_hDatabase, szFileQuery, &hFileView))
			{
				if(ERROR_SUCCESS == MSI::MsiViewExecute(hFileView, 0))
				{
					if (((MSI::MsiViewFetch(hFileView, &hFileRec)) == ERROR_SUCCESS) && hFileRec) 
					{
						TCHAR	szFileSize[30];
						UINT	cbFeatureRec = MSI::MsiRecordDataSize(hFileRec, 1);	
						BLANK(szFileSize);

						cchCount = 30;
						MSI::MsiRecordGetString(hFileRec, 1, szFileSize, &cchCount);
						wsprintf(szTempBuffer, TEXT("%d"), (fdFileData.nFileSizeHigh * MAXDWORD) + fdFileData.nFileSizeLow);
						if (!lstrcmp(szTempBuffer, szFileSize))
							lstrcpy(szTempBuffer, FILESTATUS_OKAY);
						else
							lstrcpy(szTempBuffer, FILESTATUS_DIFFSIZE);
					}
				}
			}

		} 
		else
			return ERROR_UNKNOWN_PROPERTY;

		lstrcpy (lpValueBuf, szTempBuffer);
		*pcchValueBuf = lstrlen(lpValueBuf);

		return ERROR_SUCCESS;
//		RETURNSUCCESS(hFileRec, hFileView);
	}

	return ERROR_NO_DATA;
//	RETURNERROR(hFileRec, hFileView)
}
#endif // 0


// direct mappings to MSI API.
INSTALLSTATE WINAPI CSpyDatabase::MsicQueryProductState(LPCTSTR szProduct) 
{
	return MSI::MsiQueryProductState(szProduct);
}


INSTALLSTATE WINAPI CSpyDatabase::MsicQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature) 
{
	return MSI::MsiQueryFeatureState(szProduct, szFeature);
}


INSTALLSTATE WINAPI CSpyDatabase::MsicLocateComponent(LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf) 
{

	return MSI::MsiLocateComponent(szComponentId, lpPathBuf, pcchBuf);


#if 0
	// 0'ed out by t-guhans, 14Aug98
	// why shouldn't we map directly as above?
	// NOTE: We should NOT be setting m_szProductCode below in any event, since
	// that is set ONLY if the corresponding database is open. If we directly
	// set m_szProductCode, most other CSpyDatabase:: functions WILL break.
//--
	if (lpPathBuf) BLANK(lpPathBuf);

	if (NULL == *m_szProductCode)
	{		
		//!! is setting the global product code the right thing to do?
		if (ERROR_SUCCESS != MSI::MsiGetProductCode(szComponentId, m_szProductCode))
		return INSTALLSTATE_UNKNOWN; //?? Is this the correct thing to return?
	}

	return MSI::MsiGetComponentPath(m_szProductCode, szComponentId, lpPathBuf, pcchBuf);
//--
#endif	// 0
}


INSTALLSTATE WINAPI CSpyDatabase::MsicGetComponentPath(LPCTSTR szProduct, LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf) 
{
	if (lstrcmp(m_szProductCode, szProduct))
		return INSTALLSTATE_UNKNOWN;

	return MSI::MsiGetComponentPath(szProduct, szComponentId, lpPathBuf, pcchBuf);
}	// end of MsicGetComponentPath


UINT WINAPI CSpyDatabase::MsicEnumComponentsFromProduct(LPCTSTR szProductCode, const DWORD dwComponentIndex, LPTSTR lpComponentBuf) 
{
	if (lstrcmp(m_szProductCode, szProductCode))
		return ERROR_UNKNOWN_PRODUCT;

	// a database is in use- we can use MsivEnumComponents, since it enumerates
	// the components of the current product only
	return MsicEnumComponents(dwComponentIndex, lpComponentBuf);
}


UINT WINAPI CSpyDatabase::MsicGetFeatureUsage(LPCTSTR szProduct, LPCTSTR szFeature, LPDWORD pdwUseCount, WORD *pwDateUsed) 
{
	if (lstrcmp(m_szProductCode, szProduct))
		return ERROR_UNKNOWN_PRODUCT;

	return MsiGetFeatureUsage(szProduct, szFeature, pdwUseCount, pwDateUsed);
}


USERINFOSTATE WINAPI CSpyDatabase::MsicGetUserInfo(
		LPCTSTR szProduct, 
		LPTSTR  lpUserNameBuf, 
		LPDWORD pcchUserNameBuf, 
		LPTSTR  lpOrgNameBuf,
		LPDWORD pcchOrgNameBuf, 
		LPTSTR  lpSerialBuf, 
		LPDWORD pcchSerialBuf
		) 
{

	if (lstrcmp(m_szProductCode, szProduct))
		return USERINFOSTATE_UNKNOWN;
	
	return MSI::MsiGetUserInfo(szProduct, lpUserNameBuf, pcchUserNameBuf, 
							   lpOrgNameBuf, pcchOrgNameBuf, lpSerialBuf, pcchSerialBuf);
}




// ___________________________________________________________________________________________
//
//	CSpyProfile Class Implementation
// ___________________________________________________________________________________________


CSpyProfile::CSpyProfile() 
{
	lstrcpy(m_szProfileName, TEXT(""));			// no profile is open
	m_hfProfile = NULL;

	lstrcpy(m_szDefaultText, TEXT("|def"));
	m_iCurrentProduct = 
	m_iCurrentFeature = 
	m_iCurrentComponent = -1;
	lstrcpy(m_szNullString, TEXT(""));
	m_hashTable.Clear();

}


CSpyProfile::~CSpyProfile() 
{
	if (m_hfProfile)
		FindClose(m_hfProfile);
}


UINT WINAPI CSpyProfile::MsicEnumProducts(const DWORD dwProductIndex, LPTSTR lpProductBuf) 
{
	if (!lpProductBuf)
		return ERROR_INVALID_PARAMETER;

	// find the product with the given index
	TCHAR	szSection[15];
	wsprintf(szSection, TEXT("Product %d"), dwProductIndex);

	GetPrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTCODE, m_szNullString, 
		lpProductBuf, MAX_GUID+1, m_szProfileName);

	if (lstrcmp(lpProductBuf,  m_szNullString))
		return ERROR_SUCCESS;
	else
		return ERROR_NO_MORE_ITEMS;		// product was not found

}


UINT WINAPI CSpyProfile::MsicEnumFeatures(LPCTSTR szProduct, const DWORD dwFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf) 
{

	if (!FindProductIndex(szProduct))					// make sure productcode is valid
		return ERROR_UNKNOWN_PRODUCT;

	TCHAR	szSection[30];

	// try finding the required feature and parent
	wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, dwFeatureIndex);
	GetPrivateProfileString(szSection, FEATUREPROPERTY_NAME, m_szNullString, 
		lpFeatureBuf, MAX_FEATURE_CHARS+1, m_szProfileName);

	if (lpParentBuf)
		GetPrivateProfileString(szSection, FEATUREPROPERTY_PARENT, m_szNullString, 
			lpParentBuf, MAX_FEATURE_CHARS+1, m_szProfileName);

	if (lstrcmp(lpFeatureBuf, m_szNullString))
		return ERROR_SUCCESS;
	else
		return ERROR_NO_DATA;	// feature doesn't exist
}


UINT WINAPI CSpyProfile::MsicEnumComponentsFromFeature(
			  LPCTSTR	szProduct, 
			  LPCTSTR	szFeature, 
		const DWORD		dwComponentIndex, 
			  LPTSTR	lpComponentBuf,
			  LPTSTR	lpComponentNameBuf,
			  LPDWORD	pcchComponentNameBuf) 
{

	if (!szProduct || !szFeature || !lpComponentBuf || (lpComponentNameBuf && !pcchComponentNameBuf))
		return ERROR_INVALID_PARAMETER;
	if (!FindProductIndex(szProduct)) 
		return ERROR_UNKNOWN_PRODUCT;
	if (!FindFeatureIndex(szFeature))
		return ERROR_UNKNOWN_FEATURE;

	TCHAR	szSection[20+MAX_GUID];
	TCHAR	szKey[20];

	// find component GUID
	wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, m_iCurrentFeature);
	wsprintf(szKey, TEXT("Component %d"), dwComponentIndex);
	GetPrivateProfileString(szSection, szKey, m_szNullString, 
		lpComponentBuf, MAX_COMPONENT_CHARS+1, m_szProfileName);

	// get component name if buffer exists
	if (lpComponentNameBuf) 
	{
		wsprintf(szSection, TEXT("Component %s, File 0"), lpComponentBuf);
		GetPrivateProfileString(szSection, FILEPROPERTY_COMPONENT, m_szNullString, 
			lpComponentNameBuf, *pcchComponentNameBuf, m_szProfileName);
		*pcchComponentNameBuf = lstrlen(lpComponentNameBuf);
	}

	if (lstrcmp(lpComponentBuf, m_szNullString))
		return ERROR_SUCCESS;
	else
		return ERROR_NO_DATA;	// component doesn't exist

}


UINT WINAPI CSpyProfile::MsicEnumComponents(const DWORD dwComponentIndex, LPTSTR lpComponentBuf) {

	if (!lpComponentBuf)
		return ERROR_INVALID_PARAMETER;

	TCHAR	szSection[17];

	// find the component with the required index
	wsprintf(szSection, TEXT("Component %d"), dwComponentIndex);
	GetPrivateProfileString(szSection, COMPONENTPROPERTY_GUID, m_szNullString, lpComponentBuf, cchGUID+1, m_szProfileName);
	
	if (lstrcmp(lpComponentBuf, m_szNullString))
		return ERROR_SUCCESS;		// lpComponentBuf has the reqd value
	else 
		return ERROR_NO_DATA;		// component doesn't exist

}


UINT WINAPI CSpyProfile::MsicGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentNameBuf, LPDWORD pcchComponentNameBuf) {

	if (!szComponentId || !lpComponentNameBuf || !pcchComponentNameBuf)
		return ERROR_INVALID_PARAMETER;

	TCHAR szSection[20+MAX_GUID];

	if (!FindComponentIndex(szComponentId))
		return ERROR_UNKNOWN_COMPONENT;

	wsprintf(szSection, TEXT("Component %d"), m_iCurrentComponent);

	GetPrivateProfileString(szSection, COMPONENTPROPERTY_NAME, m_szNullString, lpComponentNameBuf, *pcchComponentNameBuf, m_szProfileName);
	*pcchComponentNameBuf = lstrlen(lpComponentNameBuf);	// If path was not found, lpPathBuf will
									// be empty ("") and *pcchBuf will be 0
	
	if (lstrcmp(lpComponentNameBuf, m_szNullString))
		return ERROR_SUCCESS;
	else
		return ERROR_NO_DATA;				// component doesn't exist
}


UINT WINAPI CSpyProfile::MsicGetProductInfo(
		LPCTSTR szProduct, 
		LPCTSTR szAttribute, 
		LPTSTR lpValueBuf, 
		LPDWORD pcchValueBuf
		) 
{
	if (!szProduct || !szAttribute || !lpValueBuf || !pcchValueBuf)
		return ERROR_INVALID_PARAMETER;

	if (!FindProductIndex(szProduct))	// go to the appropriate product
		return ERROR_NO_DATA;			// product doesn't exist in profile

	TCHAR	szSection[15];

	// and fetch the required attribute
	wsprintf(szSection, TEXT("Product %d"), m_iCurrentProduct);
	GetPrivateProfileString(szSection, szAttribute, m_szDefaultText, 
		lpValueBuf, *pcchValueBuf, m_szProfileName);

	if (lstrcmp(lpValueBuf, m_szDefaultText))
		return ERROR_SUCCESS;
	else
		return ERROR_NO_DATA;	// attribute was not found
}


UINT WINAPI CSpyProfile::MsicGetFeatureInfo(
		LPCTSTR szProduct, 
		LPCTSTR szFeature, 
		LPCTSTR szAttribute, 
		LPTSTR lpValueBuf, 
		LPDWORD pcchValueBuf
		) 
{

	if (!szProduct || !szFeature || ! szAttribute || !lpValueBuf || !pcchValueBuf)
		return ERROR_INVALID_PARAMETER;

	if (!FindProductIndex(szProduct))		// go to appropriate product
		return ERROR_UNKNOWN_PRODUCT;		// product doesn't exist in profile

	if (!FindFeatureIndex(szFeature))
		return ERROR_UNKNOWN_FEATURE;		// feature doesn't exist in this product

	TCHAR	szSection[30];

	// fetch the required info
	wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, m_iCurrentFeature);
	GetPrivateProfileString(szSection, szAttribute, m_szDefaultText, lpValueBuf, *pcchValueBuf, m_szProfileName);

	if (lstrcmp(lpValueBuf, m_szDefaultText))
		return ERROR_SUCCESS;
	else
		return ERROR_NO_DATA;		// attribute was not found
}


INSTALLSTATE WINAPI CSpyProfile::MsicQueryProductState(LPCTSTR szProduct) 
{

	if (!szProduct || !FindProductIndex(szProduct))		// find the product's index
		return INSTALLSTATE_UNKNOWN;		// product doesn't exist

	TCHAR	szDefault[] = TEXT("DEF");
	TCHAR	szSection[15];
	TCHAR	szTemp[5];

	// get the product's state from the profile
	wsprintf(szSection, TEXT("Product %d"), m_iCurrentProduct);
	GetPrivateProfileString(szSection, INSTALLPROPERTY_STATE, szDefault, 
		szTemp, 5, m_szProfileName);

	// if the state couldn't be found return UNKNOWN
	if (!lstrcmp(szTemp, szDefault))
		return INSTALLSTATE_UNKNOWN;

	// if the state exists in the profile type-cast it to INSTALLSTATE and return it
	UINT	iReturn = _ttoi (szTemp);
	return  *(INSTALLSTATE *)&iReturn;
}


INSTALLSTATE WINAPI CSpyProfile::MsicQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature) 
{

	// find the current product and feature
	// if either is not found, feature isn't recognized.
	if (!szProduct || !szFeature || !FindProductIndex(szProduct) || !FindFeatureIndex(szFeature))
		return INSTALLSTATE_UNKNOWN;

	//	get the info  ...
	TCHAR	szDefault[] = TEXT("DEF");
	TCHAR	szSection[30];
	TCHAR	szTemp[5];

	wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, m_iCurrentFeature);
	GetPrivateProfileString(szSection, FEATUREPROPERTY_STATE, szDefault, 
		szTemp, 5, m_szProfileName);

	// if state couldn't be read, something's wrong.
	if (!lstrcmp(szTemp, szDefault))
		return INSTALLSTATE_UNKNOWN;

	// if state was read in, type-cast and return it.
	UINT	iReturn = _ttoi (szTemp);
	return  *(INSTALLSTATE *)&iReturn;
}


INSTALLSTATE WINAPI CSpyProfile::MsicLocateComponent(LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf) 
{

	if (!szComponentId || (lpPathBuf  && !pcchBuf))
		return INSTALLSTATE_UNKNOWN;

	if (!FindComponentIndex(szComponentId))
		return INSTALLSTATE_UNKNOWN;

	TCHAR szSection[17];
	wsprintf(szSection, TEXT("Component %d"), m_iCurrentComponent);

	if (lpPathBuf)
	{
		GetPrivateProfileString(szSection, COMPONENTPROPERTY_PATH, m_szNullString, 
			lpPathBuf, *pcchBuf, m_szProfileName);
		*pcchBuf = lstrlen(lpPathBuf);	// If path was not found, lpPathBuf will
										// be empty ("") and *pcchBuf will be 0
	}

	TCHAR	szTemp[5];
	GetPrivateProfileString(szSection, COMPONENTPROPERTY_STATE, m_szDefaultText, 
		szTemp, 5, m_szProfileName);

	if (!lstrcmp(szTemp, m_szDefaultText)) 
		return INSTALLSTATE_UNKNOWN;

	// state was found- typecast and return it
	UINT	iReturn = _ttoi (szTemp);
	return  *(INSTALLSTATE *)&iReturn;
}


INSTALLSTATE WINAPI CSpyProfile::MsicGetComponentPath(
		LPCTSTR szProductId, 
		LPCTSTR szComponentId, 
		LPTSTR lpPathBuf, 
		LPDWORD pcchBuf) 
{

	if (!szProductId) 
		return INSTALLSTATE_UNKNOWN;

	return MsicLocateComponent(szComponentId, lpPathBuf, pcchBuf);
}

UINT WINAPI CSpyProfile::MsicEnumComponentsFromProduct(
		LPCTSTR szProductCode, 
  const DWORD	dwComponentIndex, 
		LPTSTR	lpComponentBuf) 
{

	if (!szProductCode || !lpComponentBuf)
		return ERROR_INVALID_PARAMETER;

	// locate current product, and fill up the hashtable with the component list
	// for the current product (if it is already current, nothing is changed)
	if (!FindProductIndex(szProductCode))
		return ERROR_UNKNOWN_PRODUCT;
	
	FillInComponents();

	DWORD cbComponentBuf = MAX_GUID+1;
	// return the appropriate component index
	return m_hashTable.EnumElements(dwComponentIndex, lpComponentBuf, &cbComponentBuf);

}


// save profile
UINT WINAPI CSpyProfile::MsicSaveProfile(LPCTSTR szFileName) 
{
	TCHAR	szSection[70];
	TCHAR	szValue[MAX_PATH+1];
	UINT	iComponentCount = 0;
	TCHAR	szComponentId[MAX_GUID+1];
	DWORD	cchCount = MAX_PATH+1;

	TCHAR	rgszFileAttribute[][20] = {
		FILEPROPERTY_COMPONENT,
		FILEPROPERTY_NAME,
		FILEPROPERTY_SIZE,
		FILEPROPERTY_VERSION,
		FILEPROPERTY_LANGUAGE,
		FILEPROPERTY_ATTRIBUTES,
		FILEPROPERTY_SEQUENCE,
		FILEPROPERTY_ACTUALSIZE,
		FILEPROPERTY_CREATIONTIME,
		FILEPROPERTY_LASTWRITETIME,
		FILEPROPERTY_LASTACCESSTIME,
		FILEPROPERTY_STATUS,
		TEXT("")
	};



//	wsprintf(szSection, TEXT("Profile Info"), iComponentCount);
	wsprintf(szSection, TEXT("Profile Info"));

	GetUserName(szValue, &cchCount);
	WritePrivateProfileString(szSection, TEXT("Saved By"), szValue, szFileName);

	SYSTEMTIME	stCurrentTime;
	GetLocalTime(&stCurrentTime);

	wsprintf(szValue, TEXT("%2.2d-%2.2d-%2.2d (%2.2d:%2.2d:%2.2d)"), 
		stCurrentTime.wMonth,
		stCurrentTime.wDay,
		stCurrentTime.wYear,
		stCurrentTime.wHour,
		stCurrentTime.wMinute,
		stCurrentTime.wSecond);
	WritePrivateProfileString(szSection, TEXT("Saved On"), szValue, szFileName);
	

	OSVERSIONINFO sOsVersion;
	sOsVersion.dwOSVersionInfoSize = sizeof (sOsVersion);

	GetVersionEx(&sOsVersion);

	switch (sOsVersion.dwPlatformId) {
	case VER_PLATFORM_WIN32s:
		lstrcpy(szValue, TEXT("Microsoft Windows 3.1"));
		break;
	case VER_PLATFORM_WIN32_WINDOWS:
		lstrcpy(szValue, TEXT("Microsoft Windows 95"));
		break;
	case VER_PLATFORM_WIN32_NT:
		lstrcpy(szValue, TEXT("Microsoft Windows NT"));
		break;
	default:
		BLANK(szValue);
		break;
	}
	WritePrivateProfileString(szSection, TEXT("OS Name"), szValue, szFileName);

	wsprintf(szValue, TEXT("%d.%d"), sOsVersion.dwMajorVersion, sOsVersion.dwMinorVersion);
	WritePrivateProfileString(szSection, TEXT("OS Version"), szValue, szFileName);
	
	wsprintf(szValue, TEXT("%d"), sOsVersion.dwBuildNumber);
	WritePrivateProfileString(szSection, TEXT("OS Build Number"), szValue, szFileName);
	
	WritePrivateProfileString(szSection, TEXT("OS Info"), sOsVersion.szCSDVersion, szFileName);
	
	while (MsivEnumComponents(iComponentCount, szComponentId)
	== ERROR_SUCCESS) {

		TCHAR szProductCode[MAX_GUID+1];

		MsiEnumClients(szComponentId, 0, szProductCode);

//--
		wsprintf(szSection, TEXT("Component %s"), szComponentId);
		TCHAR szIndexTemp[5];
		wsprintf(szIndexTemp, TEXT("%d"), iComponentCount);
		WritePrivateProfileString(szSection, TEXT("Index"), szIndexTemp, szFileName);


		wsprintf(szSection, TEXT("Component %d"), iComponentCount);
		WritePrivateProfileString(szSection, COMPONENTPROPERTY_GUID, szComponentId, szFileName);

		cchCount=MAX_COMPONENT_CHARS+1;
		TCHAR	szComponentName[MAX_COMPONENT_CHARS+1];
		MsivGetComponentName(szComponentId, szComponentName, &cchCount);
		WritePrivateProfileString(szSection, COMPONENTPROPERTY_NAME, szComponentName, szFileName);

		cchCount=MAX_PATH+1;
		INSTALLSTATE iState = MsivLocateComponent(szComponentId, szValue, &cchCount);
		WritePrivateProfileString(szSection, COMPONENTPROPERTY_PATH, szValue, szFileName);

		wsprintf(szValue, TEXT("%d"), iState);
		WritePrivateProfileString(szSection, COMPONENTPROPERTY_STATE, szValue, szFileName);

		TCHAR	szFile[MAX_PATH+1]	= TEXT("");
		DWORD	cchFile				= MAX_PATH+1;
		UINT	iFileCount			= 0;

		while (MsivEnumFilesFromComponent(szComponentId, iFileCount, szFile, &cchFile) == ERROR_SUCCESS) {

			wsprintf(szSection, TEXT("Component %s, File %d"), szComponentId, iFileCount);
			WritePrivateProfileString(szSection, FILEPROPERTY_TITLE, szFile, szFileName);

			for (UINT iTempCount=0; lstrcmp(rgszFileAttribute[iTempCount], m_szNullString); iTempCount++) {
				cchCount=MAX_PATH+1;

//				MsivGetFileInfo(szComponentId, szFile, rgszFileAttribute[iTempCount], szValue, &cchCount);
				MsivGetFileInfo(szProductCode, szComponentId, szFile, rgszFileAttribute[iTempCount], szValue, &cchCount);
//assert(0);
				WritePrivateProfileString(szSection, rgszFileAttribute[iTempCount], szValue, szFileName);
			}


			iFileCount++;
			cchFile=MAX_PATH+1;
		}
		iComponentCount++;

	}

	int		iProdCount = 0;
	TCHAR	szProductCode[MAX_GUID+1];

	while ((MSI::MsivEnumProducts(iProdCount, szProductCode)) == ERROR_SUCCESS) {
		wsprintf(szSection, TEXT("Product %d"), iProdCount);
		WritePrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTCODE, szProductCode, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, szValue, &cchCount)
				!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTNAME, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTNAME, szValue, szFileName);

			
		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_VERSIONSTRING, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_VERSIONSTRING, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_VERSIONSTRING, szValue, szFileName);


		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PUBLISHER, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_PUBLISHER, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_PUBLISHER, szValue, szFileName);


		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_LOCALPACKAGE, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_LOCALPACKAGE, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_LOCALPACKAGE, szValue, szFileName);


		TCHAR	szUserName[MAX_PATH+1];
		TCHAR	szUserCompany[MAX_PATH+1];
		TCHAR	szProductId[MAX_PATH+1];
		DWORD	cchCount1=MAX_PATH+1;
		DWORD	cchCount2=MAX_PATH+1;
		DWORD	cchCount3=MAX_PATH+1;

		if (MsiGetUserInfo(szProductCode, szUserName, &cchCount1, szUserCompany, &cchCount2,
		szProductId, &cchCount3) !=	USERINFOSTATE_PRESENT) {
			WritePrivateProfileString(szSection, INSTALLPROPERTY_USERNAME, m_szNullString, szFileName);
			WritePrivateProfileString(szSection, INSTALLPROPERTY_USERORGNAME, m_szNullString, szFileName);
			WritePrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTID, m_szNullString, szFileName);
		}
		else {
			WritePrivateProfileString(szSection, INSTALLPROPERTY_USERNAME, szUserName, szFileName);
			WritePrivateProfileString(szSection, INSTALLPROPERTY_USERORGNAME, szUserCompany, szFileName);
			WritePrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTID, szProductId, szFileName);
		}


		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_PRODUCTNAME, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTNAME, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTNAME, szValue, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_HELPLINK, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_HELPLINK, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_HELPLINK, szValue, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_URLINFOABOUT, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_URLINFOABOUT, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_URLINFOABOUT, szValue, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_URLUPDATEINFO, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_URLUPDATEINFO, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_URLUPDATEINFO, szValue, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_HELPTELEPHONE, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_HELPTELEPHONE, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_HELPTELEPHONE, szValue, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLDATE, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_INSTALLDATE, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_INSTALLDATE, szValue, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLSOURCE, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_INSTALLSOURCE, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_INSTALLSOURCE, szValue, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLLOCATION, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_INSTALLLOCATION, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_INSTALLLOCATION, szValue, szFileName);

		cchCount = MAX_PATH+1;
		if (MsivGetProductInfo(szProductCode, INSTALLPROPERTY_LANGUAGE, szValue, &cchCount)
		!=ERROR_SUCCESS)
			WritePrivateProfileString(szSection, INSTALLPROPERTY_LANGUAGE, m_szNullString, szFileName);
		else
			WritePrivateProfileString(szSection, INSTALLPROPERTY_LANGUAGE, szValue, szFileName);

		INSTALLSTATE iState = MsivQueryProductState(szProductCode);
		wsprintf(szValue, TEXT("%d"), iState);
		WritePrivateProfileString(szSection, INSTALLPROPERTY_STATE, szValue, szFileName);

		UINT	iFeatureCount = 0;
		TCHAR	szFeature[MAX_FEATURE_CHARS+1];
		TCHAR	szParent[MAX_FEATURE_CHARS+1];

		while (MsivEnumFeatures(szProductCode, iFeatureCount, szFeature, szParent)
		== ERROR_SUCCESS) {

			wsprintf(szSection, TEXT("Product %d, Feature %d"), iProdCount, iFeatureCount);
			WritePrivateProfileString(szSection, FEATUREPROPERTY_NAME, szFeature, szFileName);

			cchCount = MAX_PATH+1;
			if (MsivGetFeatureInfo(szProductCode, szFeature, FEATUREPROPERTY_PARENT, 
			szValue, &cchCount) != ERROR_SUCCESS)
				WritePrivateProfileString(szSection, FEATUREPROPERTY_PARENT, m_szNullString, szFileName);
			else
				WritePrivateProfileString(szSection, FEATUREPROPERTY_PARENT, szValue, szFileName);

			cchCount = MAX_PATH+1;
			if (MsivGetFeatureInfo(szProductCode, szFeature, FEATUREPROPERTY_TITLE, 
			szValue, &cchCount) != ERROR_SUCCESS)
				WritePrivateProfileString(szSection, FEATUREPROPERTY_TITLE, m_szNullString, szFileName);
			else
				WritePrivateProfileString(szSection, FEATUREPROPERTY_TITLE, szValue, szFileName);

			cchCount = MAX_PATH+1;
			if (MsivGetFeatureInfo(szProductCode, szFeature, FEATUREPROPERTY_DESC, 
			szValue, &cchCount) != ERROR_SUCCESS)
				WritePrivateProfileString(szSection, FEATUREPROPERTY_DESC, m_szNullString, szFileName);
			else
				WritePrivateProfileString(szSection, FEATUREPROPERTY_DESC, szValue, szFileName);
		
			INSTALLSTATE iState = MsivQueryFeatureState(szProductCode, szFeature);
			wsprintf(szValue, TEXT("%d"), iState);
			WritePrivateProfileString(szSection, FEATUREPROPERTY_STATE, szValue, szFileName);

			WORD	wDateUsed;
			DWORD	iUseCount;
			TCHAR	szDateUsed[MAX_PATH+1];
			TCHAR	szUseCount[MAX_PATH+1];

			MsiGetFeatureUsage(szProductCode, szFeature, &iUseCount, &wDateUsed);
			wsprintf(szDateUsed,  TEXT("%d"), wDateUsed);
			wsprintf(szUseCount, TEXT("%d"), iUseCount);

			WritePrivateProfileString(szSection, FEATUREPROPERTY_DATE, szDateUsed, szFileName);
			WritePrivateProfileString(szSection, FEATUREPROPERTY_COUNT, szUseCount, szFileName);

			iComponentCount = 0;
			TCHAR	szKey[20];
		
			while (MsivEnumComponentsFromFeature(szProductCode, szFeature, iComponentCount, szComponentId, NULL, NULL)
			== ERROR_SUCCESS) {
				wsprintf(szKey, TEXT("Component %d"), iComponentCount);
				WritePrivateProfileString(szSection, szKey, szComponentId, szFileName);
				iComponentCount++;
			}
			iFeatureCount++;
		}
		iProdCount++;
	}
	return ERROR_SUCCESS;
}


UINT WINAPI CSpyProfile::MsicLoadProfile(LPCTSTR szFileName) 
{

	if (!szFileName)
		return ERROR_INVALID_PARAMETER;

	WIN32_FIND_DATA	fdFileData;
	// try locating the file
	if (INVALID_HANDLE_VALUE == (m_hfProfile = FindFirstFile(szFileName, &fdFileData)))
		return ERROR_UNKNOWN;

	lstrcpy(m_szProfileName, szFileName);
	return ERROR_SUCCESS;
}


UINT WINAPI CSpyProfile::MsicCloseProfile() 
{
	FindClose(m_hfProfile);
	BLANK(m_szProfileName);

	m_hfProfile = NULL;
	return ERROR_SUCCESS;
}


UINT WINAPI CSpyProfile::MsicGetProfileName(LPTSTR lpValueBuf, LPDWORD pcchValueBuf) 
{
	if (!lpValueBuf || !pcchValueBuf)
		return ERROR_INVALID_PARAMETER;

	if (lstrlen(lpValueBuf) > *pcchValueBuf)
		return ERROR_MORE_DATA;

	lstrcpyn(lpValueBuf, m_szProfileName, *pcchValueBuf);
	*pcchValueBuf=lstrlen(lpValueBuf);
	return ERROR_SUCCESS;
}


UINT WINAPI CSpyProfile::MsicGetFeatureUsage(
	LPCTSTR szProduct, 
	LPCTSTR szFeature, 
	LPDWORD pdwUseCount, 
	LPWORD pwDateUsed) 
{

	if (!szProduct || !szFeature || !pdwUseCount || !pwDateUsed)
		return ERROR_INVALID_PARAMETER;

	*pdwUseCount = 0;
	*pwDateUsed = 0;
	TCHAR szSection[30];

	// try finding the product and feature in the profile
	// if either of them are not valid, return ERROR
	if (!FindProductIndex(szProduct)) 
		return ERROR_UNKNOWN_PRODUCT;

	if (!FindFeatureIndex(szFeature))
		return ERROR_UNKNOWN_FEATURE;

	// get the required info
	TCHAR szValue[10];
	wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, m_iCurrentFeature);

	GetPrivateProfileString(szSection, FEATUREPROPERTY_COUNT, m_szDefaultText, 
		szValue, 10, m_szProfileName);

	// typecast the use count to a dword 
	UINT iTemp = _ttoi(szValue);
	*pdwUseCount = *(LPDWORD )&iTemp;

	GetPrivateProfileString(szSection, FEATUREPROPERTY_DATE, m_szDefaultText, 
		szValue, 10, m_szProfileName);

	// typecast the last use date to a word 
	iTemp = _ttoi(szValue);
	*pwDateUsed = *(WORD *)&iTemp;

	return ERROR_SUCCESS;
}


USERINFOSTATE WINAPI CSpyProfile::MsicGetUserInfo(
		LPCTSTR szProduct, 
		LPTSTR	lpUserNameBuf, 
		LPDWORD	pcchUserNameBuf, 
		LPTSTR	lpOrgNameBuf, 
		LPDWORD	pcchOrgNameBuf, 
		LPTSTR	lpSerialBuf, 
		LPDWORD	pcchSerialBuf) 
{


	if (!szProduct || !lpUserNameBuf || !pcchUserNameBuf || 
		!lpOrgNameBuf || !pcchOrgNameBuf || !lpSerialBuf || !pcchSerialBuf)
		return USERINFOSTATE_UNKNOWN;

	// try finding the product and feature in the profile
	// if either of them are not valid, return ERROR
	if (!FindProductIndex(szProduct))
		return USERINFOSTATE_UNKNOWN;

	TCHAR	szDefault[] = TEXT("");
	TCHAR	szSection[15];

	// get the required info
	wsprintf(szSection, TEXT("Product %d"), m_iCurrentProduct);
	GetPrivateProfileString(szSection, INSTALLPROPERTY_USERNAME, m_szNullString, 
		lpUserNameBuf, *pcchUserNameBuf, m_szProfileName);

	GetPrivateProfileString(szSection, INSTALLPROPERTY_USERORGNAME, m_szNullString, 
		lpOrgNameBuf, *pcchOrgNameBuf, m_szProfileName);

	GetPrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTID, m_szNullString, 
		lpSerialBuf, *pcchSerialBuf, m_szProfileName);

	return USERINFOSTATE_PRESENT;
}


UINT WINAPI CSpyProfile::MsicEnumClients(
		LPCTSTR szComponent, 
  const DWORD	dwProductIndex, 
		LPTSTR	lpProductBuf) 
{ 
	UINT iTraversed=0;
	UINT iProdCount=0;

	// go thru all the products and see if they are clients of the
	// component. Return the appropriate one, based on the dwProductIndex
	while (MsicEnumProducts(iProdCount++, lpProductBuf) == ERROR_SUCCESS) {
		UINT iCompCount=0;
		TCHAR szEnumComp[MAX_GUID+1];
		while (MsicEnumComponentsFromProduct(lpProductBuf, iCompCount++, szEnumComp) == ERROR_SUCCESS) {
			if (!lstrcmp(szComponent, szEnumComp)) {
				iTraversed++;
				if (iTraversed == dwProductIndex+1)
					return ERROR_SUCCESS;
			}
		}
	}

	// we're out of products
	BLANK(lpProductBuf);
	return ERROR_NO_DATA;
}


// !! TODO: To fix this, at the moment this takes in an Index, not attribute ...
UINT WINAPI CSpyProfile::MsicGetProfileInfo(UINT iIndex, LPTSTR szValue, LPDWORD pcchCount) {

	TCHAR	szDefault[] = TEXT("");
	TCHAR	szSection[15];

	wsprintf(szSection, TEXT("Profile Info"), m_iCurrentProduct);


	switch (iIndex) {
	case 0:
		lstrcpy(szValue, m_szProfileName);
		*pcchCount=lstrlen(m_szProfileName);
		break;

	case 1:
		GetPrivateProfileString(szSection, TEXT("Saved By"), szDefault, 
			szValue, *pcchCount, m_szProfileName);
		break;

	case 2:
		GetPrivateProfileString(szSection, TEXT("Saved On"), szDefault, 
			szValue, *pcchCount, m_szProfileName);
		break;

	case 3:
		GetPrivateProfileString(szSection, TEXT("OS Name"), szDefault, 
			szValue, *pcchCount, m_szProfileName);
		break;
	
	case 4:
		GetPrivateProfileString(szSection, TEXT("OS Version"), szDefault, 
			szValue, *pcchCount, m_szProfileName);
		break;

	case 5:
		GetPrivateProfileString(szSection, TEXT("OS Build Number"), szDefault, 
			szValue, *pcchCount, m_szProfileName);
		break;

	case 6:
		GetPrivateProfileString(szSection, TEXT("OS Info"), szDefault, 
			szValue, *pcchCount, m_szProfileName);
		break;

	default:
		BLANK(szValue);
		*pcchCount = 0;
		return ERROR_NO_DATA;
		break;
	}
	return ERROR_SUCCESS;
} 


UINT WINAPI CSpyProfile::MsicEnumFilesFromComponent(
		LPCTSTR szComponentId, 
		DWORD	dwFileIndex, 
		LPTSTR	lpValueBuf, 
		LPDWORD pcchCount) 
{


	if (!szComponentId || !lpValueBuf || !pcchCount)
		return ERROR_INVALID_PARAMETER;

	TCHAR	szDefault[] = TEXT("prn");		// can't have a file named 'prn'
	TCHAR	szSection[25+MAX_GUID];

	// get the required info
	wsprintf(szSection, TEXT("Component %s, File %d"), szComponentId, dwFileIndex);
	GetPrivateProfileString(szSection, FILEPROPERTY_TITLE, szDefault, 
		lpValueBuf, *pcchCount, m_szProfileName);
	
	if (lstrcmp(lpValueBuf, szDefault))
		return ERROR_SUCCESS;
	else 
		return ERROR_NO_DATA;			// info does not exist

}

UINT WINAPI CSpyProfile::MsicGetFileInfo(
		LPCTSTR szProductCode, 
		LPCTSTR szComponentId, 
		LPCTSTR szFileName, 
		LPCTSTR szAttribute, 
		LPTSTR lpValueBuf, 
		LPDWORD pcchValueBuf) 
{

	UINT	dwFileIndex					= 0;
	TCHAR	szDefault[]					= TEXT("prn");		// cannot have a file named 'prn'
	TCHAR	szSection[25+MAX_GUID]		= TEXT("");
	TCHAR	szTempBuffer[MAX_PATH+1]	= TEXT("");

	// go thru all the files till we find the reqd file
	while (TRUE) 
	{
		wsprintf(szSection, TEXT("Component %s, File %d"), szComponentId, dwFileIndex++);
		GetPrivateProfileString(szSection, FILEPROPERTY_TITLE, szDefault, szTempBuffer, MAX_PATH+1, m_szProfileName);
		
		if (lstrcmp(szTempBuffer, szDefault)) 
		{
			if (!(lstrcmp(szTempBuffer, szFileName))) 
			{	// we found the reqd file

				// get the reqd attribute
				GetPrivateProfileString(szSection, szAttribute, szDefault, 
					lpValueBuf, *pcchValueBuf, m_szProfileName);
							
				if (lstrcmp(lpValueBuf, szDefault))
					return ERROR_SUCCESS;
				else
					return ERROR_NO_DATA;	// the attribute doesn't exist
			}
		}
		else 
			return ERROR_NO_DATA;			// we ran out of files, no match was found
	}
}



// _________________________________________________________________________________________________

// ----------------------------------------
// Functions called when a Profile is in use
// ----------------------------------------

//--------------------------------------------------------------------------------------------------
// FindProductIndex
// Sets m_iProductIndex to the Index of the product in the current profile
// with Product Code == szReqdProductCode
// If current value of product index is upto date, the function just returns.
// Else, each product in the profile is checked till a product with the same 
// code as szReqdProductCode is found (m_iProductIndex is set to the index for that 
// product, returns TRUE), or till we run out of products in the profile (m_iProductIndex is 
// set to -1, returns FALSE)

BOOL WINAPI	CSpyProfile::FindProductIndex(LPCTSTR szReqdProductCode)
{
	TCHAR	szSection[15];
	TCHAR	szCurrProductCode[MAX_GUID+1];

	wsprintf(szSection, TEXT("Product %d"), m_iCurrentProduct);
	GetPrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTCODE, m_szDefaultText, 
		szCurrProductCode, MAX_GUID+1, m_szProfileName);

	if (!(lstrcmp(szCurrProductCode, szReqdProductCode)))
		return TRUE;			// current value is upto date, no need to change anything.

	// current dwProductIndex pointed to some other product,
	// so start from 0 and compare szReqdProductCode for each product
	// with the szReqdProductCode passed in.
	m_iCurrentProduct=0;
	while (TRUE) 
	{
		wsprintf(szSection, TEXT("Product %d"), m_iCurrentProduct);
		GetPrivateProfileString(szSection, INSTALLPROPERTY_PRODUCTCODE, m_szDefaultText, 
			szCurrProductCode, MAX_GUID+1, m_szProfileName);

		if (!(lstrcmp(szCurrProductCode, szReqdProductCode)))
			return TRUE;		// a match was found- leave dwProductIndex at this value and return

		if (!(lstrcmp(szCurrProductCode, m_szDefaultText))) 
		{
			// we ran out of products in the profile and no match was found
			m_iCurrentProduct=-1;
			return FALSE;
		}
		m_iCurrentProduct++;
	}

	return FALSE;
}

//--------------------------------------------------------------------------------------------------
// FindFeatureIndex
// similar to dwProductIndex.
// sets m_iFeatureIndex to index of feature with the same name as
// the one passed in IN the CURRENT product. 
// Other behaviour same as CSpyProfile::FindProductIndex- see above.
// IMPORTANT: FindProductIndex MUST be called before this is called 

BOOL WINAPI	CSpyProfile::FindFeatureIndex(LPCTSTR szTargetFeature)
{
	TCHAR	szSection[30];
	TCHAR	szCurrentFeature[MAX_FEATURE_CHARS+1];

	wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, m_iCurrentFeature);
	GetPrivateProfileString(szSection, FEATUREPROPERTY_NAME, m_szDefaultText, 
		szCurrentFeature, MAX_FEATURE_CHARS+1, m_szProfileName);

	if (!(lstrcmp(szCurrentFeature, szTargetFeature)))
		return TRUE;		// current value is upto date, no need to change anything

	// current dwFeatureIndex pointed to some other feature,
	// so start from 0 and compare FeatureName for each feature in the current
	// product (dwProductIndex) with the FeatureName passed in.
	m_iCurrentFeature=0;
	while (TRUE) 
	{
		wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, m_iCurrentFeature);
		GetPrivateProfileString(szSection, FEATUREPROPERTY_NAME, m_szDefaultText, 
			szCurrentFeature, MAX_FEATURE_CHARS+1, m_szProfileName);
		
		if (!(lstrcmp(szCurrentFeature, szTargetFeature)))
			return TRUE;		// a match was found- leave dwFeatureIndex at this value and return
	
		if (!(lstrcmp(szCurrentFeature, m_szDefaultText))) 
		{
			// we ran out of features in the current product and no match was found
			m_iCurrentFeature=-1;
			return FALSE;
		}

		m_iCurrentFeature++;
	}

	return FALSE;
}


//--------------------------------------------------------------------------------------------------
// FindComponentIndex
// Sets m_iCurrentComponent to the Index of the component in the current profile
// with Component GUID == szReqdComponentGUID if it exists (returns TRUE), 
// else to -1 (return value is FALSE)

BOOL WINAPI CSpyProfile::FindComponentIndex(LPCTSTR szReqdComponentGUID) 
{

	TCHAR szSection[20+MAX_GUID];
	wsprintf(szSection, TEXT("Component %s"), szReqdComponentGUID);

	TCHAR szTemp[5];
	GetPrivateProfileString(szSection, TEXT("Index"), TEXT("-1"), szTemp, 5, m_szProfileName);

	m_iCurrentComponent = _ttoi (szTemp);

	return (m_iCurrentComponent >= 0);
}


//--------------------------------------------------------------------------------------------------
// FillInComponents
// Fills in the global hashtable 'm_hashTable' with componentIDs of all the
// components of the current Product.
// The table's uniqueId is set to the product's index in the profile
// If the table already has the components for the current product,
// the function just returns. Else, it goes thru each feature of the
// product and adds in the components to the table.
// This function (and the entire hashtable) is needed to avoid repeats
// in MsivEnumComponents while using a profile, since a component may be
// shared and repeated many times in the profile.

void WINAPI CSpyProfile::FillInComponents() {

	if (m_iCurrentProduct == -1)							// invalid product
		return;

	if (m_hashTable.GetIndex() == m_iCurrentProduct)	
		// table already has components of the current product, don't change anything 
		return;


	// clear the current product and update it's unique ID
	m_hashTable.Clear();
	m_hashTable.SetIndex(m_iCurrentProduct);

	TCHAR	szSection[30];
	TCHAR	szComponentBuf[MAX_GUID+1];
	TCHAR	szKey[17];

	int iFeatureCount = 0;

	// get info about all the components of each feature, and add the componentId 
	// to the table. The add function adds it in only if it doesn't already exist
	while (TRUE) {

		BOOL fMoveOn=FALSE;				// move on to next feature?
		int iComponentCount=0;			// start from component 0 for each new feature
		wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, iFeatureCount);

		while (!fMoveOn) {
			// try finding the ID of the next component
			wsprintf(szKey, TEXT("Component %d"), iComponentCount);
			GetPrivateProfileString(szSection, szKey, m_szDefaultText, 
				szComponentBuf, MAX_COMPONENT_CHARS+1, m_szProfileName);
		
			if (!(lstrcmp(szComponentBuf, m_szDefaultText))) {
				//  ID wasn't found, ie this feature is out of components, try to find next feature
				iFeatureCount++;
				wsprintf(szSection, TEXT("Product %d, Feature %d"), m_iCurrentProduct, iFeatureCount);
				GetPrivateProfileString(szSection, FEATUREPROPERTY_NAME, m_szDefaultText, 
					szComponentBuf, MAX_COMPONENT_CHARS+1, m_szProfileName);
				
				if (!(lstrcmp(szComponentBuf, m_szDefaultText)))
					// the next feature was not found, ie all features have been covered
					return;

				// more features exist, go to the next feature
				fMoveOn =TRUE;
			} 
			else 
				// found a componentID, add it to the table.
				// the add function will only add it if it doesn't already exist.
				m_hashTable.AddElement(szComponentBuf, lstrlen(szComponentBuf)+1);
			
			// time for the next component
			iComponentCount++;
		}
	}

	return;
}


// ___________________________________________________________________________________________
//
//	CSpyRegistry Class Implementation
// ___________________________________________________________________________________________



CSpyRegistry::CSpyRegistry() {
	lstrcpy(m_szNullString, TEXT(""));
	lstrcpy(m_szLocalProductCode, TEXT(""));
}

CSpyRegistry::~CSpyRegistry()
{
	// nothing to do
}

UINT WINAPI CSpyRegistry::MsicEnumProducts(const DWORD dwProductIndex, LPTSTR lpProductBuf) 
{
	return MSI::MsiEnumProducts(dwProductIndex, lpProductBuf);
}


UINT WINAPI CSpyRegistry::MsicEnumFeatures(LPCTSTR szProduct, const DWORD dwFeatureIndex, LPTSTR lpFeatureBuf, LPTSTR lpParentBuf) 
{
	return MsiEnumFeatures(szProduct, dwFeatureIndex, lpFeatureBuf, lpParentBuf);
}


UINT WINAPI CSpyRegistry::MsicEnumComponentsFromFeature(
			  LPCTSTR	szProduct, 
			  LPCTSTR	szFeature, 
		const DWORD		dwComponentIndex, 
			  LPTSTR	lpComponentBuf,
			  LPTSTR	lpComponentNameBuf,
			  LPDWORD	pcchComponentNameBuf) 
{

	if (!szProduct)		// remaining params are checked by m_spydb
		return ERROR_INVALID_PARAMETER;

	if (lstrcmp(szProduct, m_szLocalProductCode) && (ERROR_SUCCESS != OpenTempDB(szProduct)))
		return ERROR_UNKNOWN;

	return m_spydb.MsicEnumComponentsFromFeature(szProduct, szFeature, dwComponentIndex, 
		lpComponentBuf, lpComponentNameBuf, pcchComponentNameBuf);
}


UINT WINAPI CSpyRegistry::MsicEnumComponents(const DWORD dwComponentIndex, LPTSTR lpComponentBuf) 
{
	return MsiEnumComponents(dwComponentIndex, lpComponentBuf);
}


UINT WINAPI CSpyRegistry::MsicGetComponentName(LPCTSTR szComponentId, LPTSTR lpComponentName, LPDWORD pcchComponentName) 
{

	UINT iFailCode = 0;
	DWORD cchValueBuf = *pcchComponentName;
	if (ERROR_SUCCESS != (iFailCode = m_spydb.MsicGetComponentName(szComponentId, lpComponentName, pcchComponentName)))
	{
		TCHAR szProduct[MAX_GUID+1];
		MsicEnumClients(szComponentId, 0, szProduct);
		if (lstrcmp(szProduct, m_szLocalProductCode) && (ERROR_SUCCESS != OpenTempDB(szProduct))) 
			return iFailCode;			// we're out of luck- the database couldn't be opened either
		else
		{
			*pcchComponentName = cchValueBuf;
			return m_spydb.MsicGetComponentName(szComponentId, lpComponentName, pcchComponentName);
		}
	}
	else 
		return ERROR_SUCCESS;
}


UINT WINAPI CSpyRegistry::MsicGetProductInfo(LPCTSTR szProduct, LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf) 
{

	UINT iFailCode = 0;
	DWORD cchValueBuf = *pcchValueBuf;
	if (ERROR_SUCCESS != (iFailCode = MSI::MsiGetProductInfo(szProduct, szAttribute, lpValueBuf, pcchValueBuf))) {
		// call to MSI failed, try checking local database directly
		if (lstrcmp(szProduct, m_szLocalProductCode) && (ERROR_SUCCESS != OpenTempDB(szProduct))) 
			return iFailCode;			// we're out of luck- the database couldn't be opened either
		else
		{
			*pcchValueBuf = cchValueBuf;
			return m_spydb.MsicGetProductInfo(szProduct, szAttribute, lpValueBuf, pcchValueBuf);
		}
	}
	else 
		return ERROR_SUCCESS;
}

UINT WINAPI CSpyRegistry::MsicGetFeatureInfo(
		LPCTSTR szProduct, 
		LPCTSTR szFeature, 
		LPCTSTR szAttribute, 
		LPTSTR	lpValueBuf, 
		LPDWORD pcchValueBuf) 
{

	if (lstrcmp(szProduct, m_szLocalProductCode) && (ERROR_SUCCESS != OpenTempDB(szProduct)))
		return ERROR_UNKNOWN;
	else
		return m_spydb.MsicGetFeatureInfo(szProduct, szFeature, szAttribute, lpValueBuf, pcchValueBuf);

} 


INSTALLSTATE WINAPI CSpyRegistry::MsicQueryProductState(LPCTSTR szProduct) 
{
	return MSI::MsiQueryProductState(szProduct);
}


INSTALLSTATE WINAPI CSpyRegistry::MsicQueryFeatureState(LPCTSTR szProduct, LPCTSTR szFeature) 
{
	return MSI::MsiQueryFeatureState(szProduct, szFeature);
}


INSTALLSTATE WINAPI CSpyRegistry::MsicLocateComponent(LPCTSTR szComponentId, LPTSTR lpPathBuf, LPDWORD pcchBuf) 
{
	return MSI::MsiLocateComponent(szComponentId, lpPathBuf, pcchBuf);

#if 0	// t-guhans 15Aug98 why can't we just directly map it to MSI::??

	if (lpPathBuf) BLANK(lpPathBuf);
	TCHAR szProductCode[MAX_GUID+1] = TEXT("");
//	return MSI::MsiLocateComponent(szComponentId, lpPathBuf, pcchBuf);

	if (ERROR_SUCCESS != MSI::MsiGetProductCode(szComponentId, szProductCode))
		return INSTALLSTATE_UNKNOWN; //?? Is this the correct thing to return?
	else
		return MSI::MsiGetComponentPath(szProductCode, szComponentId, lpPathBuf, pcchBuf);
#endif // 0
}


INSTALLSTATE WINAPI CSpyRegistry::MsicGetComponentPath(
		LPCTSTR szProductId, 
		LPCTSTR szComponentId, 
		LPTSTR	lpPathBuf, 
		LPDWORD pcchBuf) 
{
	return MSI::MsiGetComponentPath(szProductId, szComponentId, lpPathBuf, pcchBuf);
}


UINT WINAPI CSpyRegistry::MsicEnumComponentsFromProduct(LPCTSTR szProductCode, const DWORD dwComponentIndex, LPTSTR lpComponentBuf) 
{
	if (lstrcmp(szProductCode, m_szLocalProductCode) && (ERROR_SUCCESS != OpenTempDB(szProductCode)))
		return ERROR_UNKNOWN;
	else
		return m_spydb.MsicEnumComponentsFromProduct(szProductCode, dwComponentIndex, lpComponentBuf);

}


UINT WINAPI CSpyRegistry::MsicGetFeatureUsage(LPCTSTR szProduct, LPCTSTR szFeature, LPDWORD pdwUseCount, WORD *pwDateUsed) 
{
	return MsiGetFeatureUsage(szProduct, szFeature, pdwUseCount, pwDateUsed);
}


USERINFOSTATE WINAPI CSpyRegistry::MsicGetUserInfo(
		LPCTSTR szProduct, 
		LPTSTR	lpUserNameBuf, 
		LPDWORD pcchUserNameBuf, 
		LPTSTR	lpOrgNameBuf, 
		LPDWORD pcchOrgNameBuf, 
		LPTSTR	lpSerialBuf, 
		LPDWORD pcchSerialBuf) 
{
	return MsiGetUserInfo(szProduct, lpUserNameBuf, pcchUserNameBuf, 
			lpOrgNameBuf, pcchOrgNameBuf, lpSerialBuf, pcchSerialBuf);
}


UINT WINAPI CSpyRegistry::MsicEnumClients(LPCTSTR szComponent, const DWORD dwProductIndex, LPTSTR lpProductBuf) 
{ 
	return MsiEnumClients(szComponent, dwProductIndex, lpProductBuf);
}

UINT WINAPI CSpyRegistry::MsicEnumFilesFromComponent(LPCTSTR szComponentId, DWORD dwFileIndex, LPTSTR lpValueBuf, LPDWORD pcchCount) 
{

	UINT iFailCode = 0;
	DWORD cchValueBuf = *pcchCount;
	if (ERROR_SUCCESS != (iFailCode = m_spydb.MsicEnumFilesFromComponent(szComponentId, dwFileIndex, lpValueBuf, pcchCount)))
	{
		TCHAR szProduct[MAX_GUID+1];
		MsicEnumClients(szComponentId, 0, szProduct);
		if (lstrcmp(szProduct, m_szLocalProductCode) && (ERROR_SUCCESS != OpenTempDB(szProduct))) 
			return iFailCode;			// we're out of luck- the database couldn't be opened either
		else
		{
			*pcchCount = cchValueBuf;
			return m_spydb.MsicEnumFilesFromComponent(szComponentId, dwFileIndex, lpValueBuf, pcchCount);
		}
	}
	else 
		return ERROR_SUCCESS;
}


UINT WINAPI CSpyRegistry::MsicGetFileInfo(LPCTSTR szProductCode, LPCTSTR szComponentId, LPCTSTR szFileName, 
										  LPCTSTR szAttribute, LPTSTR lpValueBuf, LPDWORD pcchValueBuf) 
{

	if (lstrcmp(szProductCode, m_szLocalProductCode) && (ERROR_SUCCESS != OpenTempDB(szProductCode)))
		return ERROR_UNKNOWN;
	else
		return m_spydb.MsicGetFileInfo(szProductCode, szComponentId, szFileName, szAttribute, lpValueBuf, pcchValueBuf);
}




// _________________________________________________________________________________________________
//
//	Private Functions
// _________________________________________________________________________________________________



//--------------------------------------------------------------------------------------------------
// OpenTempDB
// Finds the local-package (cached DB) for the current (selected) product
// and try's opening it. If successful, 
// (global) m_hDatabase points to the database. 
// (global) m_szLocalProductCode has a copy of the current product's code.
// All functions that need info from a DB when the registry is being used 
// access the DB thru m_hDatabase if it is valid.

UINT WINAPI CSpyRegistry::OpenTempDB(
		LPCTSTR szProductID
		) {


	return (ERROR_SUCCESS == m_spydb.MsicOpenProduct(szProductID))?
			(lstrcpy(m_szLocalProductCode, szProductID),ERROR_SUCCESS):
			(BLANK(m_szLocalProductCode),ERROR_OPEN_FAILED);

#if 0 // t-guhans 15Aug98	
	
	// no UI- else 'preparing to install' dialog displayed
	INSTALLUILEVEL hPreviousUILevel = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL); 
					
	PMSIHANDLE	hInstall;
	MsiCloseHandle(m_hDatabase);

	m_hDatabase = (MsiOpenProduct(szProductID, &hInstall) == ERROR_SUCCESS)?MsiGetActiveDatabase(hInstall):0;
	
	// reset UI Level
	MsiSetInternalUI(hPreviousUILevel, NULL);

	return m_hDatabase?
			(lstrcpy(m_szLocalProductCode, szProductID),ERROR_SUCCESS):
			(BLANK(m_szLocalProductCode),ERROR_);
#endif
}


//___________________________________________________________________________________________________________________
//____________________________________-----------------------------------------______________________________________
//___________________________________- A U T O M A T I O N   F U N C T I O N S -_____________________________________
//____________________________________-----------------------------------------______________________________________
//___________________________________________________________________________________________________________________



// Log file definitions
// WARNING: These characters must track the INSTALLLOGMODE bit flags in
//          msi.h. INSTALLLOGMODE 0x1 must correspond to the first log
//          mode specified here, 0x2 to the second, 0x4 to the third, etc...

const char szLogChars[] =  "m"  // imtOutOfMemory
							"e"  // imtError
							"w"  // imtWarning
							"u"  // imtUser
							"i"  // imtInfo
							"d"  // imtDiagnostic
							"c"  // imtCommonData
							"x"  // imtReserved
							"a"  // imtActionStart
							"r"  // imtActionData (record)
							"p"; // iLogPropertyDump

//____________________________________________________________________________
//
// Unicode translation API wrappers
//____________________________________________________________________________


#ifdef W32   // override system call in order to do Unicode translation
static BSTR AllocBSTR(const char* sz)
{
	if (sz == 0)
		return 0;
	int cchWide = W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, 0, 0) - 1;
	BSTR bstr = OLEAUT32::SysAllocStringLen(0, cchWide); // null added by API
	W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, bstr, cchWide);
	bstr[cchWide] = 0; // API function does not null terminate
	return bstr;
}
static BSTR AllocBSTRLen(const char* sz, unsigned int cch)
{
	if (sz == 0)
		return 0;
	int cchWide = W32::MultiByteToWideChar(CP_ACP, 0, sz, cch, 0, 0);
	BSTR bstr = OLEAUT32::SysAllocStringLen(0, cchWide);
	W32::MultiByteToWideChar(CP_ACP, 0, sz, cch, bstr, cchWide);
	bstr[cchWide] = 0; // API function does not null terminate
	return bstr;
}
#else // MAC
inline BSTR AllocBSTR(const char* sz)
{
	return OLEAUT32::SysAllocString(sz);
}
inline BSTR AllocBSTRLen(const char* sz, unsigned int cch)
{
	return OLEAUT32::SysAllocStringLen(sz, cch);
}
#endif




//____________________________________________________________________________
//
// CVariant definition, VARIANT with conversion operators
//____________________________________________________________________________

class CVariant : public tagVARIANT {
 public:
	operator const char*();
	operator const wchar_t*();
	operator int();
	operator unsigned int();
	operator short();
//	operator unsigned short();
	operator long();
//	operator unsigned long();
	operator Bool();
//	operator MsiDate();
	operator IDispatch*();
	operator tagVARIANT*();
	void operator =(int i);           // used by controller
	void operator =(const char* sz);  // used by CEnumVariant
	void operator =(const wchar_t* sz);  // used by CEnumVariant
	void operator =(IDispatch* pi);   // used by CEnumVariant
	int  GetType();
	void Clear();      // free any references, set type to VT_EMPTY
	Bool IsRef();
	Bool IsString();
//	MSIHANDLE GetHandle(const IID& riid);   // throws exception if invalid type
//	MSIHANDLE GetOptionalHandle(const IID& riid); // throws exception if invalid type
 private:
	void ConvRef(int type);
  char*& StringDBCS() { return *(char**)(&bstrVal + 1); }

 
 friend class CAutoArgs;
 friend CVariant* GetCVariantPtr(VARIANT* var);
};
inline CVariant* GetCVariantPtr(VARIANT* var) { return (CVariant*)var; }
inline CVariant::operator tagVARIANT*() { return this; }

//____________________________________________________________________________
//
// CAutoArgs definition, access to automation variant arguments
// operator[] returns CVariant& argument 1 to n, 0 for property value
//____________________________________________________________________________

enum varVoid {fVoid};

enum axAuto
{
	axNoError,
	axInvalidType,
	axConversionFailed,
	axNotObject,
	axBadObjectType,
	axOverflow,
	axMissingArg,
	axExtraArg,
	axCreationFailed,
	axInvalidArg,
};

class CAutoArgs
{
 public:
	CAutoArgs(DISPPARAMS* pdispparams, VARIANT* pvarResult, WORD wFlags);
  ~CAutoArgs();
	CVariant& operator[](unsigned int iArg); // 1-based, 0 for property value
	Bool Present(unsigned int iArg);
	Bool PropertySet();
	unsigned int GetLastArg();
	void operator =(const wchar_t* wsz);
	void operator =(int             i);
	void operator =(unsigned int    i);
	void operator =(short           i);
	void operator =(long            i);
	void operator =(Bool            f);
	void operator =(FILETIME&     rft);
	void operator =(IDispatch*     pi);
	void operator =(varVoid         v);
	void operator =(void*			pv);
//	void operator =(const wchar_t& wrsz);
//	void operator =(IEnumVARIANT&  ri);
	void operator =(const char*		sz);
	
 protected:
	int       m_cArgs;
	int       m_cNamed;
	long*     m_rgiNamed;
	CVariant* m_rgvArgs;
	CVariant* m_pvResult;
	int       m_wFlags;
	int       m_iLastArg;
	CVariant  m_vTemp;
};

inline Bool CAutoArgs::PropertySet()
{
	return (m_wFlags & DISPATCH_PROPERTYPUT) ? fTrue : fFalse;
}

inline unsigned int CAutoArgs::GetLastArg()
{
	return m_iLastArg;
}

class CAutoBase;

enum aafType
{ 
	 aafMethod=DISPATCH_METHOD,
	 aafPropRW=DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT,
	 aafPropRO=DISPATCH_PROPERTYGET,
	 aafPropWO=DISPATCH_PROPERTYPUT
};

template<class T> struct DispatchEntry
{
	DISPID    dispid;
	aafType   aaf;
	void (T::*pmf)(CAutoArgs& args);
	wchar_t*  sz;
	operator DispatchEntry<CAutoBase>*()
	{return (DispatchEntry<CAutoBase>*)this;}
}; // assumption made that CAutoBase is the first or only base class of T

//____________________________________________________________________________
//
// CAutoBase definition, common implementation class for IDispatch  
//____________________________________________________________________________

class CAutoBase : public IDispatch  // class private to this module
{
 public:   // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall GetTypeInfoCount(unsigned int *pcTinfo);
	HRESULT       __stdcall GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo** ppi);
	HRESULT       __stdcall GetIDsOfNames(const IID& riid, OLECHAR** rgszNames,
													unsigned int cNames, LCID lcid, DISPID* rgDispId);
	HRESULT       __stdcall Invoke(DISPID dispid, const IID&, LCID lcid, WORD wFlags,
											DISPPARAMS* pdispparams, VARIANT* pvarResult,
											EXCEPINFO* pexcepinfo, unsigned int* puArgErr);
 public:  // common methods of all automation classes
//	void HasInterface(CAutoArgs& args);
//	void GetInterface(CAutoArgs& args);
//	void RefCount    (CAutoArgs& args);
 protected: // class-specific implementation required
	virtual ~CAutoBase();  // no need to be virtual if no derived destructors
//	virtual IUnknown& GetInterface();   // Does not AddRef()
//	virtual IMsiServices* GetCurrentServices() { return s_piServices; }
//	BSTR    FormatErrorString(IMsiRecord& riRecord);
//	void	ReleaseStaticServices();
 protected: // constructor
	CAutoBase(DispatchEntry<CAutoBase>* pTable, int cDispId, const IID& riid, MSIHANDLE hMsi);
 protected: 
	int         m_iRefCnt;
	DispatchEntry<CAutoBase>* m_pTable;
	int         m_cDispId;
	const IID&  m_riid;
	MSIHANDLE   m_hMsi;
 private: // suppress warning
	void operator =(CAutoBase&){}
 private:
};

typedef DispatchEntry<CAutoBase> DispatchEntryBase;

// sole function is to force template instantiation for VC4.0, never called
inline DISPID GetEntryDispId(DispatchEntryBase* pTable)
{
	return pTable->dispid;
}


//____________________________________________________________________________
//
// Automation wrapper class definitions
//____________________________________________________________________________




class CMsispyDatabase: public CAutoBase
{
public:
	CMsispyDatabase();

	void Open(CAutoArgs& args);
	void Close(CAutoArgs& args);
	void GetProduct(CAutoArgs& args);
	void GetFeatureFromProduct(CAutoArgs& args);
	void GetComponent(CAutoArgs& args);
	void GetComponentFromProduct(CAutoArgs& args);
	void GetComponentFromFeature(CAutoArgs& args);
	void GetComponentName(CAutoArgs& args);
	void GetProductInfo(CAutoArgs& args);
	void GetFeatureInfo(CAutoArgs& args);
	void QueryProductState(CAutoArgs& args);
	void QueryFeatureState(CAutoArgs& args);
	void QueryComponentState(CAutoArgs& args);
//	void MsivGetDatabaseName(CAutoArgs& args);
	void GetFeatureUsage(CAutoArgs& args);
	void GetClientFromComponent(CAutoArgs& args);
	void GetFileFromComponent(CAutoArgs& args);
	void GetFileInfo(CAutoArgs& args);
	void GetComponentLocation(CAutoArgs& args);
	void GetComponentPath(CAutoArgs& args);
private:
	CSpyDatabase	cSpyDatabase;
};



class CMsispyProfile: public CAutoBase
{
public:
	CMsispyProfile();

	void Open(CAutoArgs& args);
	void Close(CAutoArgs& args);
	void GetProduct(CAutoArgs& args);
	void GetFeatureFromProduct(CAutoArgs& args);
	void GetComponent(CAutoArgs& args);
	void GetComponentFromProduct(CAutoArgs& args);
	void GetComponentFromFeature(CAutoArgs& args);
	void GetComponentName(CAutoArgs& args);
	void GetProductInfo(CAutoArgs& args);
	void GetFeatureInfo(CAutoArgs& args);
	void QueryProductState(CAutoArgs& args);
	void QueryFeatureState(CAutoArgs& args);
	void QueryComponentState(CAutoArgs& args);
//	void MsivGetProfileName(CAutoArgs& args);
	void GetFeatureUsage(CAutoArgs& args);
	void GetClientFromComponent(CAutoArgs& args);
	void GetFileFromComponent(CAutoArgs& args);
	void GetFileInfo(CAutoArgs& args);
	void GetComponentLocation(CAutoArgs& args);
	void GetComponentPath(CAutoArgs& args);
private:
	CSpyProfile	cSpyProfile;
};



class CMsispyRegistry: public CAutoBase
{
public:
	CMsispyRegistry();

	void Open(CAutoArgs& args);
	void Close(CAutoArgs& args);
	void GetProduct(CAutoArgs& args);
	void GetFeatureFromProduct(CAutoArgs& args);
	void GetComponent(CAutoArgs& args);
	void GetComponentFromProduct(CAutoArgs& args);
	void GetComponentFromFeature(CAutoArgs& args);
	void GetComponentName(CAutoArgs& args);
	void GetProductInfo(CAutoArgs& args);
	void GetFeatureInfo(CAutoArgs& args);
	void QueryProductState(CAutoArgs& args);
	void QueryFeatureState(CAutoArgs& args);
	void QueryComponentState(CAutoArgs& args);
//	void MsivGetRegistryName(CAutoArgs& args);
	void GetFeatureUsage(CAutoArgs& args);
	void GetClientFromComponent(CAutoArgs& args);
	void GetFileFromComponent(CAutoArgs& args);
	void GetFileInfo(CAutoArgs& args);
	void GetComponentLocation(CAutoArgs& args);
	void GetComponentPath(CAutoArgs& args);
private:
	CSpyRegistry	cSpyRegistry;
};


class CObjectSafety : public IObjectSafety
{
 public: // implementation of IObjectSafety
	HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT __stdcall GetInterfaceSafetyOptions(const IID& riid, DWORD* pdwSupportedOptions, DWORD* pdwEnabledOptions);
	HRESULT __stdcall SetInterfaceSafetyOptions(const IID& riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
	IUnknown* This;  // parent object
};

class CMsispy : public CAutoBase
{
 public:
	CMsispy();
	~CMsispy();
	void CreateDatabase   (CAutoArgs& args);
	void CreateProfile    (CAutoArgs& args);
	void CreateRegistry   (CAutoArgs& args);
 private:
	HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj);
	CObjectSafety m_ObjectSafety;
};


//____________________________________________________________________________
//
// CVariant inline function definitions
//____________________________________________________________________________

inline int CVariant::GetType()
{
	return vt;
}

inline Bool CVariant::IsRef()
{
	return (vt & VT_BYREF) ? fTrue : fFalse;
}

inline Bool CVariant::IsString()
{
	return (vt & 0xFF) == VT_BSTR ? fTrue : fFalse;
}

//____________________________________________________________________________
//
// CUnknown - dummy IUnknown definition
//____________________________________________________________________________

class CUnknown : public IUnknown
{
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
};

//____________________________________________________________________________
//
// Global data
//____________________________________________________________________________

HINSTANCE g_hInstance = 0;
int g_cInstances = 0;

//____________________________________________________________________________
//
// CAutoArgs implementation
//____________________________________________________________________________

CAutoArgs::CAutoArgs(DISPPARAMS* pdispparms, VARIANT* pvarResult, WORD wFlags)
{
	m_cArgs = pdispparms->cArgs;
	m_cNamed = pdispparms->cNamedArgs;
	m_rgiNamed = pdispparms->rgdispidNamedArgs;
	m_rgvArgs = (CVariant*)pdispparms->rgvarg;
	m_pvResult= (CVariant*)pvarResult;
	m_wFlags = wFlags;
#ifdef W32
	for (int cArgs = m_cArgs; cArgs--; )
	{
		CVariant* pvar = &m_rgvArgs[cArgs];
		if (pvar->vt == VT_VARIANT+VT_BYREF)
			pvar = (CVariant*)pvar->pvarVal;
		if ((pvar->vt & ~VT_BYREF) == VT_BSTR)  // s.bstr is Unicode string
		{
			OLECHAR* bstr;
			if (pvar->vt == VT_BSTR)
				bstr = pvar->bstrVal;
			else // (VT_BYREF | VT_BSTR))
				bstr = *pvar->pbstrVal;
			int cchWide = OLEAUT32::SysStringLen(bstr);
			BOOL fUsedDefault;
			int cbDBCS = W32::WideCharToMultiByte(CP_ACP, 0, bstr, cchWide, 0, 0, 0, 0);
			char* szDBCS = new char[cbDBCS + 1 + sizeof(char*)];
			*(char**)szDBCS = pvar->StringDBCS();
			pvar->StringDBCS() = szDBCS;  // save for subsequent deallocation
			W32::WideCharToMultiByte(CP_ACP, 0, bstr, cchWide, szDBCS+sizeof(char*), cbDBCS, 0, &fUsedDefault);
			szDBCS[cbDBCS+sizeof(char*)] = 0; // API function does not null terminate
		}
	}
#endif
	if (pvarResult != 0 && pvarResult->vt != VT_EMPTY)
		OLEAUT32::VariantClear(pvarResult);
}

CAutoArgs::~CAutoArgs()
{
#ifdef W32
	for (int cArgs = m_cArgs; cArgs--; )
	{
		CVariant* pvar = &m_rgvArgs[cArgs];
		if (pvar->vt == VT_VARIANT+VT_BYREF)
			pvar = (CVariant*)pvar->pvarVal;
		if ((pvar->vt & ~VT_BYREF) == VT_BSTR)
		{
			char* szDBCS = pvar->StringDBCS();  // recover allocated string
			pvar->StringDBCS() = *(char**)szDBCS;  // restore extra bytes in union
			delete szDBCS;    // free translated string
		}
	}
#endif

}

CVariant& CAutoArgs::operator [](unsigned int iArg)
{
//	if (iArg > m_cArgs) // || (iArg ==0 && (wFlags & DISPATCH_PROPERTYPUT))
//		throw axMissingArg;
	int ivarArgs = m_cArgs - iArg;            // get index if unnamed parameter
	if (iArg == 0 || (int) iArg > m_cArgs-m_cNamed) // SET value or named or error
	{
		iArg = iArg==0 ? DISPID_PROPERTYPUT : iArg - 1;  // values are 0-based
		for (ivarArgs = m_cNamed; --ivarArgs >= 0; )
			if (m_rgiNamed[ivarArgs] == (int) iArg)
				break;
	}
	if (ivarArgs < 0)  // loop termination above without match
		throw axMissingArg;
	m_iLastArg = ivarArgs;
	CVariant* pvarRet = &m_rgvArgs[ivarArgs];
	if (pvarRet->GetType() == VT_VARIANT+VT_BYREF)
		pvarRet = (CVariant*)pvarRet->pvarVal;
	return *pvarRet;
}

Bool CAutoArgs::Present(unsigned int iArg)
{
	int ivarArgs = m_cArgs - iArg;            // get index if unnamed parameter
	if (iArg == 0 || (int) iArg > m_cArgs-m_cNamed) // SET value or named or error
	{
		for (ivarArgs = m_cNamed; --ivarArgs >= 0; )
			if (m_rgiNamed[ivarArgs] == (int) iArg-1)
				break;
	}
	return (ivarArgs >=0 && m_rgvArgs[ivarArgs].GetType() != VT_EMPTY) ?
				fTrue : fFalse;
}



//____________________________________________________________________________
//
// CAutoArgs assignment operators implementation
//____________________________________________________________________________

void CAutoArgs::operator =(enum varVoid)
{
	if (m_pvResult)
		m_pvResult->vt = VT_EMPTY;
}

inline void CAutoArgs::operator =(unsigned int i) {operator =(int(i));}
void CAutoArgs::operator =(int i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = i;
	}
}

void CAutoArgs::operator =(long i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = i;
	}
}

void CAutoArgs::operator =(Bool f)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BOOL;
		//m_pvResult->boolVal = short(f == fFalse ? 0 : -1);
		V_BOOL(m_pvResult) = short(f == fFalse ? 0 : -1);
	}
}

void CAutoArgs::operator =(FILETIME& rft)
{
	if (m_pvResult)
	{
		SYSTEMTIME stime;
		m_pvResult->vt = VT_DATE;
		if (!OLE32::FileTimeToSystemTime(&rft, &stime))
			throw axConversionFailed;
		if (!OLEAUT32::SystemTimeToVariantTime(&stime, &m_pvResult->date))
			throw axConversionFailed;
	}
}

void CAutoArgs::operator =(short i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I2;
		m_pvResult->iVal = i;
	}
}

void CAutoArgs::operator =(IDispatch* pi)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_DISPATCH;
		m_pvResult->pdispVal = pi;  // reference count already bumped
	}
	else if(pi)
		pi->Release();
}

void CAutoArgs::operator =(const char* sz)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = OLE::AllocBSTR(sz);
	}
}

void CAutoArgs::operator =(const wchar_t* wsz)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = OLEAUT32::SysAllocString(wsz);
	}
}
#if 0
void CAutoArgs::operator =(IEnumVARIANT& ri)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_UNKNOWN; // no defined type for IEnumVARIANT
		m_pvResult->punkVal = &ri;  // reference count already bumped
	}
	else
		ri.Release();
}

void CAutoArgs::operator =(void * pv)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = (long)pv;
	}
}
#endif

//____________________________________________________________________________
//
// CVariant conversion operators implementation
//____________________________________________________________________________

CVariant::operator int()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLEAUT32::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I4);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	return varTemp.lVal;
}

CVariant::operator long()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLEAUT32::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I4);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	return varTemp.lVal;
}

CVariant::operator unsigned int()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLEAUT32::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I4);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	if (varTemp.lVal < 0)
		throw axOverflow;
	return (unsigned int)varTemp.lVal;
}

CVariant::operator short()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLEAUT32::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_I2);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	return varTemp.iVal;
}

CVariant::operator Bool()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLEAUT32::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_BOOL);
	if (hrStat != NOERROR)
		throw axConversionFailed;
	//return varTemp.boolVal ? fTrue : fFalse;
	return V_BOOL(&varTemp) ? fTrue : fFalse;
}
#if 0
CVariant::operator MsiDate()
{
	VARIANT varTemp;
	varTemp.vt = VT_EMPTY;
	HRESULT hrStat = OLEAUT32::VariantChangeType(&varTemp, (VARIANT*)this, 0, VT_DATE);
	if (hrStat != NOERROR)
		throw axConversionFailed;

	unsigned short usDOSDate, usDOSTime;
	int fTime = (varTemp.dblVal >= 0. && varTemp.dblVal < 1.);
	if (fTime)
		varTemp.dblVal += 29221.;  // add 1/1/80 offset so that conversion doesn't fail
	if (!OLEAUT32::VariantTimeToDosDateTime(varTemp.date, &usDOSDate, &usDOSTime))
		throw axConversionFailed;

	if (fTime)
		usDOSDate = 0;  // remove offset, should be 0021H
	MsiDate ad = (MsiDate)((usDOSDate << 16) | usDOSTime);
	return ad;
}
#endif
CVariant::operator const wchar_t*()
{
	OLECHAR* bstr;
	if (vt == VT_EMPTY)
		bstr = 0;
	if (vt == VT_BSTR)
		bstr = bstrVal;
	else if (vt == (VT_BYREF | VT_BSTR))
		bstr = *pbstrVal;
	else
		throw axInvalidType;
	return bstr;
}


CVariant::operator const char*()
{
	OLECHAR* bstr;
	if (vt == VT_EMPTY)
		return 0;
	if (vt == VT_BSTR)
		bstr = bstrVal;
	else if (vt == (VT_BYREF | VT_BSTR))
		bstr = *pbstrVal;
	else
		throw axInvalidType;
#ifdef W32
//	char* szDBCS = StringDBCS();  // recover allocated string
	return StringDBCS() + sizeof(char*);
#else //MAC
	return bstr;
#endif
}


CVariant::operator IDispatch*()
{
	IDispatch* piDispatch;
	if (vt == VT_EMPTY)
		return 0;
	if (vt == VT_DISPATCH)
		piDispatch = pdispVal;
	else if (vt == (VT_BYREF | VT_DISPATCH))
		piDispatch = *ppdispVal;
	else
		throw axNotObject;
	if (piDispatch)
		piDispatch->AddRef();
	return piDispatch;
}
#if 0
IUnknown& CVariant::Object(const IID& riid)
{
	IUnknown* piUnknown;
	if (vt == VT_DISPATCH || vt == VT_UNKNOWN)
		piUnknown = punkVal;
	else if (vt == (VT_BYREF | VT_DISPATCH) || vt == (VT_BYREF | VT_UNKNOWN))
		piUnknown = *ppunkVal;
	else
		piUnknown = 0;
	if (piUnknown == 0)
		throw axNotObject;
	if (piUnknown->QueryInterface(riid, (void**)&piUnknown) != NOERROR)
		throw axBadObjectType;
	piUnknown->Release();  // we don't keep a reference count
	return *piUnknown;
}

IUnknown* CVariant::ObjectPtr(const IID& riid)
{
	IUnknown* piUnknown;
	if (vt == VT_DISPATCH || vt == VT_UNKNOWN)
		piUnknown = punkVal;
	else if (vt == (VT_BYREF | VT_DISPATCH) || vt == (VT_BYREF | VT_UNKNOWN))
		piUnknown = *ppunkVal;
	else
		throw axNotObject;
	if (piUnknown != 0)
	{
		if (piUnknown->QueryInterface(riid, (void**)&piUnknown) != NOERROR)
			throw axBadObjectType;
		piUnknown->Release();  // we don't keep a reference count
	}
	return piUnknown;
}

MSIHANDLE CVariant::GetHandle(const IID& riid)
{
	IUnknown* piUnknown;
	if (vt == VT_DISPATCH || vt == VT_UNKNOWN)
		piUnknown = punkVal;
	else if (vt == (VT_BYREF | VT_DISPATCH) || vt == (VT_BYREF | VT_UNKNOWN))
		piUnknown = *ppunkVal;
	else
		piUnknown = 0;
	if (piUnknown == 0)
		throw axNotObject;
	if (piUnknown->QueryInterface(riid, (void**)&piUnknown) != NOERROR)
		throw axBadObjectType;
	return (MSIHANDLE)piUnknown;
}

MSIHANDLE CVariant::GetOptionalHandle(const IID& riid)
{
	IUnknown* piUnknown;
	if (vt == VT_DISPATCH || vt == VT_UNKNOWN)
		piUnknown = punkVal;
	else if (vt == (VT_BYREF | VT_DISPATCH) || vt == (VT_BYREF | VT_UNKNOWN))
		piUnknown = *ppunkVal;
	else if (vt == VT_EMPTY)
		piUnknown = 0;
	else
		throw axBadObjectType;
	if (piUnknown != 0)
	{
		if (piUnknown->QueryInterface(riid, (void**)&piUnknown) != NOERROR)
			throw axBadObjectType;
	}
	return (MSIHANDLE)piUnknown;
}
#endif

void CVariant::operator =(const char* sz)
{
	vt = VT_BSTR;
	bstrVal = OLE::AllocBSTR(sz);
}


void CVariant::operator =(const wchar_t* wsz)
{
	vt = VT_BSTR;
	bstrVal = OLEAUT32::SysAllocString(wsz);
}


void CVariant::operator =(IDispatch* pi)
{
	vt = VT_DISPATCH;
	pdispVal = pi;  // reference count already bumped
}

void CVariant::operator =(int i)
{
	vt = VT_I4;
	lVal = i;
}

//____________________________________________________________________________
//
// CAutoBase implementation, common implementation for IDispatch  
//____________________________________________________________________________

CAutoBase::CAutoBase(DispatchEntry<CAutoBase>* pTable, int cDispId, const IID& riid, MSIHANDLE hMsi)
 : m_pTable(pTable)
 , m_cDispId(cDispId)
 , m_hMsi(hMsi)
 , m_riid(riid)
{
	m_iRefCnt = 1;
   g_cInstances++;
}

CAutoBase::~CAutoBase()
{
	MsiCloseHandle(m_hMsi);
   g_cInstances--;
}

#if 0
IUnknown& CAutoBase::GetInterface()  // default impl. if no delegated interface
{
	return g_NullInterface;  // no installer interface available
}

void CAutoBase::HasInterface(CAutoArgs& args)
{
	static GUID s_Guid = GUID_IID_IUnknown;
	s_Guid.Data1 = (long)args[1];
	Bool fStat = fTrue;
	IUnknown* pi;
	if (QueryInterface(s_Guid, (void**)&pi) == NOERROR)
		pi->Release();
	else	
		fStat = fFalse;
	args = fStat;
}

void CAutoBase::RefCount(CAutoArgs& args)
{
	int i;
	IUnknown& ri = GetInterface();
	if (&ri == &g_NullInterface)  // no delegated object
		i = m_iRefCnt;
	else
	{
		ri.AddRef();
		i = ri.Release();
	}
	args = i;
}

void CAutoBase::GetInterface(CAutoArgs& args)
{
	static GUID s_Guid = GUID_IID_IMsiAuto;
	long iidLow = (long)args[1];
	s_Guid.Data1 = iidLow;
	IUnknown* piUnknown;
	if (QueryInterface(s_Guid, (void**)&piUnknown) != NOERROR)
		throw axBadObjectType;
	IDispatch* piDispatch = ::CreateAutoObject(*piUnknown, iidLow);
	piUnknown->Release();
	if (!piDispatch)
		throw axBadObjectType;
	args = piDispatch;
}
#endif


HRESULT CAutoBase::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IDispatch)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else if (riid == m_riid)
	{
		*ppvObj = (void*)ULongToPtr(m_hMsi);
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CAutoBase::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CAutoBase::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT CAutoBase::GetTypeInfoCount(unsigned int *pcTinfo)
{
	*pcTinfo = 0;
	return NOERROR;
}

HRESULT CAutoBase::GetTypeInfo(unsigned int /*itinfo*/, LCID /*lcid*/, ITypeInfo** ppi)
{
	*ppi = 0;
	return E_NOINTERFACE;
}

HRESULT CAutoBase::GetIDsOfNames(const IID&, OLECHAR** rgszNames, unsigned int cNames,
									 			LCID /*lcid*/, DISPID* rgDispId)
{
	if (cNames == 0 || rgszNames == 0 || rgDispId == 0)
		return E_INVALIDARG;

	unsigned int cErr = cNames;
	DispatchEntryBase* pTable = m_pTable;
	int cEntry = m_cDispId;
	*rgDispId = DISPID_UNKNOWN;
	for (;; pTable++, cEntry--)
	{
		if (cEntry == 0)
		{
//			if (pTable == AutoBaseTable + AutoBaseCount)
				break;
//			cEntry = AutoBaseCount;
//			pTable = AutoBaseTable; // cancel loop increment
		}

		wchar_t* pchName = pTable->sz; 
		for (OLECHAR* pchIn = *rgszNames; *pchIn; pchIn++, pchName++)
		{
			if ((*pchIn ^ *pchName) & ~0x20)
				break;
		}
		if (*pchIn == 0 && *pchName < '0')
		{
			*rgDispId++ = pTable->dispid;
			cErr--;
			while(--cNames != 0)
			{
				rgszNames++;
				*rgDispId = DISPID_UNKNOWN;
				wchar_t* pch = pchName;
				for (DISPID dispid = 0; *pch != 0; dispid++)
				{
					if (*pch != 0)
						pch++;
					for (pchIn = *rgszNames; *pchIn; pchIn++, pch++)
					{
						if ((*pchIn ^ *pch) & ~0x20)
							break;
					}
					if (*pchIn == 0 && *pchName < '0')
					{
						*rgDispId++ = dispid;
						cErr--;
						break;
					}
					while (*pch >= '0')
						pch++;
				}
			}
			break;
		}
	}
	return cErr ? DISP_E_UNKNOWNNAME : NOERROR;
}

HRESULT CAutoBase::Invoke(DISPID dispid, const IID&, LCID /*lcid*/, WORD wFlags,
										DISPPARAMS* pdispparams, VARIANT* pvarResult,
										EXCEPINFO* pExceptInfo, unsigned int* puArgErr)
{
	HRESULT hrStat = NOERROR;
	DispatchEntryBase* pTable = m_pTable;
	int cEntry = m_cDispId;
	while (pTable->dispid != dispid)
	{
		pTable++;
		if (--cEntry == 0)
		{
//			if (pTable == AutoBaseTable + AutoBaseCount)
				return DISP_E_MEMBERNOTFOUND;
//			cEntry = AutoBaseCount;
//			pTable = AutoBaseTable;
		}
	}

	if ((wFlags & pTable->aaf) == 0)
		return DISP_E_MEMBERNOTFOUND;

	if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
		pvarResult = 0;

	CAutoArgs Args(pdispparams, pvarResult, wFlags);
	try
 	{
		(this->*(pTable->pmf))(Args);
	}
	catch(axAuto axError)
	{
		switch (axError)
		{
		case axInvalidType:      hrStat = DISP_E_TYPEMISMATCH;     break;
		case axConversionFailed: hrStat = DISP_E_TYPEMISMATCH;     break;
		case axNotObject:        hrStat = DISP_E_TYPEMISMATCH;     break;
		case axBadObjectType:    hrStat = DISP_E_TYPEMISMATCH;     break;
		case axOverflow:         hrStat = DISP_E_OVERFLOW;         break;
		case axMissingArg:       hrStat = DISP_E_PARAMNOTOPTIONAL; break;
		case axExtraArg:         hrStat = DISP_E_BADPARAMCOUNT;    break;
		case axCreationFailed:   hrStat = DISP_E_TYPEMISMATCH;     break;
		case axInvalidArg:       hrStat = DISP_E_BADINDEX;         break;
		}
		if (puArgErr)
			*puArgErr = Args.GetLastArg();
	}
	catch(int iHelpContext)
	{
		if (pExceptInfo)
		{
			pExceptInfo->wCode = 1000; //!! ? what should we give?
			pExceptInfo->wReserved = 0;
			pExceptInfo->bstrSource = OLEAUT32::SysAllocString(ERROR_SOURCE_NAME);
			pExceptInfo->bstrDescription = OLEAUT32::SysAllocString(pTable->sz);
			pExceptInfo->bstrHelpFile = OLEAUT32::SysAllocString(L"msi.chm");
			pExceptInfo->dwHelpContext = iHelpContext;
			pExceptInfo->pfnDeferredFillIn = 0;
			pExceptInfo->scode = E_FAIL;
			hrStat = DISP_E_EXCEPTION;
		}
		else
			hrStat = E_FAIL;  // no appropriate error?
	}
	return hrStat;
}

//____________________________________________________________________________
//
// Checks return value from Msi API calls, and throw appropriate exceptions
//____________________________________________________________________________

void CheckRet(UINT iRet, int iHelpContext)
{
	if (iRet == ERROR_SUCCESS)
		return;
	if (iRet == ERROR_INVALID_HANDLE)
		throw axBadObjectType;
	if (iRet == ERROR_INVALID_PARAMETER)
		throw axInvalidArg;
	throw iHelpContext;
}

//____________________________________________________________________________
//
// Resizable buffer class to manage returned strings from API calls
//____________________________________________________________________________

template <int size> class CRetBuffer
{
 public:
	CRetBuffer() : m_cchBuf(size-1), m_szBuf(m_rgchBuf) {}
  ~CRetBuffer() {if (m_szBuf != m_rgchBuf) delete m_szBuf;}
	operator WCHAR*() {return m_szBuf;}
	DWORD* operator &()        // returns address of buffer size value
	{	m_cchBuf++;             // buffer size must include term. null
		if (m_cchBuf > size)    // overflow, must create larger buffer
		{
			if (m_szBuf != m_rgchBuf) delete m_szBuf; // cover rare case
			m_szBuf = (WCHAR*)new WCHAR[m_cchBuf+1];  // temp allocation
		}
		return &m_cchBuf;  // caller will replace size with data length
	}
 private:
	DWORD  m_cchBuf;
	WCHAR  m_rgchBuf[size];
	WCHAR* m_szBuf;
};

//____________________________________________________________________________
//
// CObjectSafety implementation
//____________________________________________________________________________

HRESULT CObjectSafety::QueryInterface(const IID& riid, void** ppvObj)
{
	return This->QueryInterface(riid, ppvObj);
}

unsigned long CObjectSafety::AddRef()
{
	return This->AddRef();
}

unsigned long CObjectSafety::Release()
{
	return This->Release();
}

HRESULT CObjectSafety::GetInterfaceSafetyOptions(const IID& riid, DWORD* pdwSupportedOptions, DWORD* pdwEnabledOptions)
{
	if (!pdwSupportedOptions || !pdwEnabledOptions)
		return E_POINTER;
	*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
	*pdwEnabledOptions = 0;
	if (riid == IID_IDispatch) // Client wants to know if object is safe for scripting
	{		
		*pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		return S_OK;
	}
	return E_NOINTERFACE;
}

HRESULT CObjectSafety::SetInterfaceSafetyOptions(const IID& riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
	if (riid == IID_IDispatch) // Client asking if it's safe to call through IDispatch
	{
		if (INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwOptionSetMask && INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwEnabledOptions)
			return S_OK;
		else
			return E_FAIL;
	}
	return E_FAIL;
}

//____________________________________________________________________________
//
// CMsispy implementation
//____________________________________________________________________________


DispatchEntry<CMsispy> MsispyTable[] = {
  DISPID_Msispy_CreateDatabase,  aafMethod, CMsispy::CreateDatabase,  L"CreateDatabase",
  DISPID_Msispy_CreateProfile,   aafMethod, CMsispy::CreateProfile,   L"CreateProfile",
  DISPID_Msispy_CreateRegistry,  aafMethod, CMsispy::CreateRegistry,  L"CreateRegistry",
};
const int MsispyCount = sizeof(MsispyTable)/sizeof(DispatchEntryBase);

HRESULT CMsispy::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IObjectSafety)
	{
		*ppvObj = &m_ObjectSafety;
		AddRef();
		return S_OK;
	}
	return CAutoBase::QueryInterface(riid, ppvObj);
}

CMsispy::CMsispy()
 : CAutoBase(*MsispyTable, MsispyCount, IID_IMsispy, 0)
{
	m_ObjectSafety.This = this;
}

CMsispy::~CMsispy() {
//	MsiCloseAllHandles();
}

IDispatch* CreateMsispy() { return new CMsispy; }

void CMsispy::CreateDatabase(CAutoArgs& args)
{
	args = new CMsispyDatabase();
}


void CMsispy::CreateProfile(CAutoArgs& args)
{
	args = new CMsispyProfile();
}

void CMsispy::CreateRegistry(CAutoArgs& args)
{
	args = new CMsispyRegistry();
}



//____________________________________________________________________________
//
// CMsispyDatabase automation implementation
//____________________________________________________________________________

DispatchEntry<CMsispyDatabase> MsispyDatabaseTable[] = {
  DISPID_MsispyDatabase_Open,			aafMethod, CMsispyDatabase::Open,			L"Open,databasePath",
  DISPID_MsispyDatabase_Close,			aafMethod, CMsispyDatabase::Close,			L"Close",
  DISPID_MsispyDatabase_GetProduct,		aafPropRO, CMsispyDatabase::GetProduct,				L"GetProduct,productIndex",
  DISPID_MsispyDatabase_GetFeatureFromProduct,	aafPropRO, CMsispyDatabase::GetFeatureFromProduct,	L"GetFeatureFromProduct,productCode,featureIndex",
  DISPID_MsispyDatabase_GetComponent, aafPropRO, CMsispyDatabase::GetComponent,			L"GetComponent,componentIndex",
  DISPID_MsispyDatabase_GetComponentFromProduct, aafPropRO, CMsispyDatabase::GetComponentFromProduct,	L"GetComponentFromProduct,productCode,componentIndex",
  DISPID_MsispyDatabase_GetComponentFromFeature, aafPropRO, CMsispyDatabase::GetComponentFromFeature,	L"GetComponentFromFeature,productCode,featureName,componentIndex",
  DISPID_MsispyDatabase_GetComponentName,	aafPropRO, CMsispyDatabase::GetComponentName,	L"GetComponentName,componentGuid",
  DISPID_MsispyDatabase_GetProductInfo,		aafPropRO, CMsispyDatabase::GetProductInfo,		L"GetProductInfo,productCode,productAttribute",
  DISPID_MsispyDatabase_GetFeatureInfo,		aafPropRO, CMsispyDatabase::GetFeatureInfo,		L"GetFeatureInfo,productCode,featureName,featureAttribute",
  DISPID_MsispyDatabase_QueryProductState,	aafPropRO, CMsispyDatabase::QueryProductState,	L"QueryProductState,productCode",
  DISPID_MsispyDatabase_QueryFeatureState,	aafPropRO, CMsispyDatabase::QueryFeatureState,	L"QueryFeatureState,productCode,featureName",
  DISPID_MsispyDatabase_QueryComponentState,aafPropRO, CMsispyDatabase::QueryComponentState,		L"QueryComponentState,productCode,componentGuid",
  DISPID_MsispyDatabase_GetFeatureUsage,	aafPropRO, CMsispyDatabase::GetFeatureUsage,			L"GetFeatureUsage,productCode,featureName",
  DISPID_MsispyDatabase_GetClientFromComponent,	aafPropRO, CMsispyDatabase::GetClientFromComponent,	L"GetClientFromComponent,componentGuid,clientIndex",
  DISPID_MsispyDatabase_GetFileFromComponent,	aafPropRO, CMsispyDatabase::GetFileFromComponent,	L"GetFileFromComponent,componentGuid,fileIndex",
  DISPID_MsispyDatabase_GetFileInfo,			aafPropRO, CMsispyDatabase::GetFileInfo,			L"GetFileInfo,productCode,componentGuid,fileName,fileAttribute",
  DISPID_MsispyDatabase_GetComponentLocation,	aafPropRO, CMsispyDatabase::GetComponentLocation,	L"GetComponentLocation,componentGuid",
  DISPID_MsispyDatabase_GetComponentPath,	aafPropRO, CMsispyDatabase::GetComponentPath,	L"GetComponentPath,productCode,componentGuid",
};
const int MsispyDatabaseCount = sizeof(MsispyDatabaseTable)/sizeof(DispatchEntryBase);

CMsispyDatabase::CMsispyDatabase()
 : CAutoBase(*MsispyDatabaseTable, MsispyDatabaseCount, IID_IMsispyDatabase, 0)
{
}

void CMsispyDatabase::Open(CAutoArgs& args)
{
	CheckRet(cSpyDatabase.MsicOpenDatabase(args[1]), 0);
}

void CMsispyDatabase::Close(CAutoArgs& args)
{
	CheckRet(cSpyDatabase.MsicCloseDatabase(), 0);
}


void CMsispyDatabase::GetProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[1];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyDatabase.MsicEnumProducts(iIndex, szValue);
	args = szValue;
}


void CMsispyDatabase::GetFeatureFromProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyDatabase.MsicEnumFeatures(args[1], iIndex, szValue, NULL);
	args = szValue;
}


void CMsispyDatabase::GetComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[1];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyDatabase.MsicEnumComponents(iIndex, szValue);
	args = szValue;
}


void CMsispyDatabase::GetComponentFromProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyDatabase.MsicEnumComponentsFromProduct(args[1], iIndex, szValue);
	args = szValue;
}


void CMsispyDatabase::GetComponentFromFeature(CAutoArgs& args)
{
	unsigned int iIndex = args[3];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyDatabase.MsicEnumComponentsFromFeature(args[1], args[2], iIndex, szValue, NULL, NULL);
	args = szValue;
}


void CMsispyDatabase::GetComponentName(CAutoArgs& args)
{
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyDatabase.MsicGetComponentName(args[1], szValue, &cchbValue);
	args = szValue;
}


void CMsispyDatabase::GetProductInfo(CAutoArgs& args)
{
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyDatabase.MsicGetProductInfo(args[1], args[2], szValue, &cchbValue);
	args = szValue;
}


void CMsispyDatabase::GetFeatureInfo(CAutoArgs& args)
{
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyDatabase.MsicGetFeatureInfo(args[1], args[2], args[3], szValue, &cchbValue);
	args = szValue;
}


void CMsispyDatabase::QueryProductState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyDatabase.MsicQueryProductState(args[1]);
	args = *(int *) &iState;
}

void CMsispyDatabase::QueryFeatureState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyDatabase.MsicQueryFeatureState(args[1], args[2]);
	args = *(int *) &iState;
}

void CMsispyDatabase::QueryComponentState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyDatabase.MsicGetComponentPath(args[1], args[2], NULL, NULL);
	args = *(int *) &iState;
}

void CMsispyDatabase::GetFeatureUsage(CAutoArgs& args)
{
	DWORD dwCount;
	WORD	wTemp;
	cSpyDatabase.MsicGetFeatureUsage(args[1], args[2], &dwCount, &wTemp);
	args = *(long *) &dwCount;
}


void CMsispyDatabase::GetClientFromComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyDatabase.MsicEnumClients(args[1], iIndex, szValue);
	args = szValue;
}


void CMsispyDatabase::GetFileFromComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyDatabase.MsicEnumFilesFromComponent(args[1], iIndex, szValue, &cchbValue);
	args = szValue;
}



void CMsispyDatabase::GetFileInfo(CAutoArgs& args)
{
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyDatabase.MsicGetFileInfo(args[1], args[2], args[3], args[4], szValue, &cchbValue);
	args = szValue;
}

void CMsispyDatabase::GetComponentLocation(CAutoArgs& args)
{
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyDatabase.MsicLocateComponent(args[1], szValue, &cchbValue);
	args = szValue;
}


/////////////////////////////////////////////////////////////////////
// GetComponentPath
// Pre:	args[1] = Product GUID
//		args[2] = Component GUID
// Pos:	returns path to component
void CMsispyDatabase::GetComponentPath(CAutoArgs& args)
{
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyDatabase.MsicGetComponentPath(args[1], args[2], szValue, &cchbValue);
	args = szValue;
}	// end of GetComponentPath



//____________________________________________________________________________
//
// CMsispyProfile automation implementation
//____________________________________________________________________________

DispatchEntry<CMsispyProfile> MsispyProfileTable[] = {
  DISPID_MsispyProfile_Open,			aafMethod, CMsispyProfile::Open,			L"Open,profilePath",
  DISPID_MsispyProfile_Close,			aafMethod, CMsispyProfile::Close,			L"Close",
  DISPID_MsispyProfile_GetProduct,	aafPropRO, CMsispyProfile::GetProduct,	L"GetProduct,productIndex",
  DISPID_MsispyProfile_GetFeatureFromProduct,	aafPropRO, CMsispyProfile::GetFeatureFromProduct,	L"GetFeatureFromProduct,productCode,featureIndex",
  DISPID_MsispyProfile_GetComponent, aafPropRO, CMsispyProfile::GetComponent,	L"GetComponent,componentIndex",
  DISPID_MsispyProfile_GetComponentFromProduct, aafPropRO, CMsispyProfile::GetComponentFromProduct,	L"GetComponentFromProduct,productCode,componentIndex",
  DISPID_MsispyProfile_GetComponentFromFeature, aafPropRO, CMsispyProfile::GetComponentFromFeature,	L"GetComponentFromFeature,productCode,featureName,componentIndex",
  DISPID_MsispyProfile_GetComponentName,	aafPropRO, CMsispyProfile::GetComponentName,	L"GetComponentName,componentGuid",
  DISPID_MsispyProfile_GetProductInfo,		aafPropRO, CMsispyProfile::GetProductInfo,		L"GetProductInfo,productCode,productAttribute",
  DISPID_MsispyProfile_GetFeatureInfo,		aafPropRO, CMsispyProfile::GetFeatureInfo,		L"GetFeatureInfo,productCode,featureName,featureAttribute",
  DISPID_MsispyProfile_QueryProductState,	aafPropRO, CMsispyProfile::QueryProductState,	L"QueryProductState,productCode",
  DISPID_MsispyProfile_QueryFeatureState,	aafPropRO, CMsispyProfile::QueryFeatureState,	L"QueryFeatureState,productCode,featureName",
  DISPID_MsispyProfile_QueryComponentState,aafPropRO, CMsispyProfile::QueryComponentState, L"QueryComponentState,productCode,componentGuid",
  DISPID_MsispyProfile_GetFeatureUsage,	aafPropRO, CMsispyProfile::GetFeatureUsage,	L"GetFeatureUsage,productCode,featureName",
  DISPID_MsispyProfile_GetClientFromComponent,		aafPropRO, CMsispyProfile::GetClientFromComponent,		L"GetClientFromComponent,componentGuid,clientIndex",
  DISPID_MsispyProfile_GetFileFromComponent,	aafPropRO, CMsispyProfile::GetFileFromComponent, L"GetFileFromComponent,componentGuid,fileIndex",
  DISPID_MsispyProfile_GetFileInfo,			aafPropRO, CMsispyProfile::GetFileInfo,			L"GetFileInfo,productCode,productCode,componentGuid,fileName,fileAttribute",
  DISPID_MsispyProfile_GetComponentLocation,	aafPropRO, CMsispyProfile::GetComponentLocation,	L"GetComponentLocation,componentGuid",
  DISPID_MsispyProfile_GetComponentPath,	aafPropRO, CMsispyProfile::GetComponentPath,	L"GetComponentPath,productCode,componentGuid",
};
const int MsispyProfileCount = sizeof(MsispyProfileTable)/sizeof(DispatchEntryBase);

CMsispyProfile::CMsispyProfile()
 : CAutoBase(*MsispyProfileTable, MsispyProfileCount, IID_IMsispyProfile, 0)
{
}


void CMsispyProfile::Open(CAutoArgs& args)
{
	CheckRet(cSpyProfile.MsicLoadProfile(args[1]), 0);
}

void CMsispyProfile::Close(CAutoArgs& args)
{
	CheckRet(cSpyProfile.MsicCloseProfile(), 0);
}


void CMsispyProfile::GetProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[1];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyProfile.MsicEnumProducts(iIndex, szValue);
	args = szValue;
}


void CMsispyProfile::GetFeatureFromProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyProfile.MsicEnumFeatures(args[1], iIndex, szValue, NULL);
	args = szValue;
}


void CMsispyProfile::GetComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[1];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyProfile.MsicEnumComponents(iIndex, szValue);
	args = szValue;
}


void CMsispyProfile::GetComponentFromProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyProfile.MsicEnumComponentsFromProduct(args[1], iIndex, szValue);
	args = szValue;
}


void CMsispyProfile::GetComponentFromFeature(CAutoArgs& args)
{
	unsigned int iIndex = args[3];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyProfile.MsicEnumComponentsFromFeature(args[1], args[2], iIndex, szValue, NULL, NULL);
	args = szValue;
}


void CMsispyProfile::GetComponentName(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyProfile.MsicGetComponentName(args[1], szValue, &cchbValue);
	args = szValue;
}


void CMsispyProfile::GetProductInfo(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyProfile.MsicGetProductInfo(args[1], args[2], szValue, &cchbValue);
	args = szValue;
}


void CMsispyProfile::GetFeatureInfo(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyProfile.MsicGetFeatureInfo(args[1], args[2], args[3], szValue, &cchbValue);
	args = szValue;
}


void CMsispyProfile::QueryProductState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyProfile.MsicQueryProductState(args[1]);
	args = *(int *) &iState;
}

void CMsispyProfile::QueryFeatureState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyProfile.MsicQueryFeatureState(args[1], args[2]);
	args = *(int *) &iState;
}

void CMsispyProfile::QueryComponentState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyProfile.MsicGetComponentPath(args[1], args[2], NULL, NULL);
	args = *(int *) &iState;
}

void CMsispyProfile::GetFeatureUsage(CAutoArgs& args)
{
	DWORD dwCount;
	WORD	wTemp;
	cSpyProfile.MsicGetFeatureUsage(args[1], args[2], &dwCount, &wTemp);
	args = *(long *) &dwCount;
}


void CMsispyProfile::GetClientFromComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyProfile.MsicEnumClients(args[1], iIndex, szValue);
	args = szValue;
}


void CMsispyProfile::GetFileFromComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyProfile.MsicEnumFilesFromComponent(args[1], iIndex, szValue, &cchbValue);
	args = szValue;
}



void CMsispyProfile::GetFileInfo(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyProfile.MsicGetFileInfo(args[1], args[2], args[3], args[4], szValue, &cchbValue);
	args = szValue;
}

void CMsispyProfile::GetComponentLocation(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyProfile.MsicLocateComponent(args[1], szValue, &cchbValue);
	args = szValue;
}


/////////////////////////////////////////////////////////////////////
// GetComponentPath
// Pre:	args[1] = Product GUID
//		args[2] = Component GUID
// Pos:	returns path to component
void CMsispyProfile::GetComponentPath(CAutoArgs& args)
{
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyProfile.MsicGetComponentPath(args[1], args[2], szValue, &cchbValue);
	args = szValue;
}	// end of GetComponentPath




//____________________________________________________________________________
//
// CMsispyRegistry automation implementation
//____________________________________________________________________________

DispatchEntry<CMsispyRegistry> MsispyRegistryTable[] = {
  DISPID_MsispyRegistry_Open,			aafMethod, CMsispyRegistry::Open,			L"Open",
  DISPID_MsispyRegistry_Close,			aafMethod, CMsispyRegistry::Close,			L"Close",
  DISPID_MsispyRegistry_GetProduct,	aafPropRO, CMsispyRegistry::GetProduct,	L"GetProduct,productIndex",
  DISPID_MsispyRegistry_GetFeatureFromProduct,	aafPropRO, CMsispyRegistry::GetFeatureFromProduct,	L"GetFeatureFromProduct,productCode,featureIndex",
  DISPID_MsispyRegistry_GetComponent, aafPropRO, CMsispyRegistry::GetComponent,	L"GetComponent,componentIndex",
  DISPID_MsispyRegistry_GetComponentFromProduct, aafPropRO, CMsispyRegistry::GetComponentFromProduct,	L"GetComponentFromProduct,productCode,componentIndex",
  DISPID_MsispyRegistry_GetComponentFromFeature, aafPropRO, CMsispyRegistry::GetComponentFromFeature,	L"GetComponentFromFeature,productCode,featureName,componentIndex",
  DISPID_MsispyRegistry_GetComponentName,	aafPropRO, CMsispyRegistry::GetComponentName,	L"GetComponentName,componentGuid",
  DISPID_MsispyRegistry_GetProductInfo,		aafPropRO, CMsispyRegistry::GetProductInfo,		L"GetProductInfo,productCode,productAttribute",
  DISPID_MsispyRegistry_GetFeatureInfo,		aafPropRO, CMsispyRegistry::GetFeatureInfo,		L"GetFeatureInfo,productCode,featureName,featureAttribute",
  DISPID_MsispyRegistry_QueryProductState,	aafPropRO, CMsispyRegistry::QueryProductState,	L"QueryProductState,productCode",
  DISPID_MsispyRegistry_QueryFeatureState,	aafPropRO, CMsispyRegistry::QueryFeatureState,	L"QueryFeatureState,productCode,featureName",
  DISPID_MsispyRegistry_QueryComponentState,aafPropRO, CMsispyRegistry::QueryComponentState, L"QueryComponentState,productCode,componentGuid",
  DISPID_MsispyRegistry_GetFeatureUsage,	aafPropRO, CMsispyRegistry::GetFeatureUsage,	L"GetFeatureUsage,productCode,featureName",
  DISPID_MsispyRegistry_GetClientFromComponent,		aafPropRO, CMsispyRegistry::GetClientFromComponent,		L"GetClientFromComponent,componentGuid,clientIndex",
  DISPID_MsispyRegistry_GetFileFromComponent,	aafPropRO, CMsispyRegistry::GetFileFromComponent, L"GetFileFromComponent,componentGuid,fileIndex",
  DISPID_MsispyRegistry_GetFileInfo,			aafPropRO, CMsispyRegistry::GetFileInfo,			L"GetFileInfo,productCode,componentGuid,fileName,fileAttribute",
  DISPID_MsispyRegistry_GetComponentLocation,	aafPropRO, CMsispyRegistry::GetComponentLocation,	L"GetComponentLocation,componentGuid",
  DISPID_MsispyRegistry_GetComponentPath,	aafPropRO, CMsispyRegistry::GetComponentPath,	L"GetComponentPath,productCode,componentGuid",
};
const int MsispyRegistryCount = sizeof(MsispyRegistryTable)/sizeof(DispatchEntryBase);

CMsispyRegistry::CMsispyRegistry()
 : CAutoBase(*MsispyRegistryTable, MsispyRegistryCount, IID_IMsispyRegistry, 0)
{
}

void CMsispyRegistry::Open(CAutoArgs& args)
{
// no initialisation to do for now
}

void CMsispyRegistry::Close(CAutoArgs& args)
{
// no cleanup to do for now
}


void CMsispyRegistry::GetProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[1];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyRegistry.MsicEnumProducts(iIndex, szValue);
	args = szValue;
}


void CMsispyRegistry::GetFeatureFromProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyRegistry.MsicEnumFeatures(args[1], iIndex, szValue, NULL);
	args = szValue;
}


void CMsispyRegistry::GetComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[1];

	TCHAR	szValue[MAX_GUID+1] = TEXT("");
	cSpyRegistry.MsicEnumComponents(iIndex, szValue);
	args = szValue;
}


void CMsispyRegistry::GetComponentFromProduct(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyRegistry.MsicEnumComponentsFromProduct(args[1], iIndex, szValue);
	args = szValue;
}


void CMsispyRegistry::GetComponentFromFeature(CAutoArgs& args)
{
	unsigned int iIndex = args[3];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyRegistry.MsicEnumComponentsFromFeature(args[1], args[2], iIndex, szValue, NULL, NULL);
	args = szValue;
}


void CMsispyRegistry::GetComponentName(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyRegistry.MsicGetComponentName(args[1], szValue, &cchbValue);
	args = szValue;
}


void CMsispyRegistry::GetProductInfo(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyRegistry.MsicGetProductInfo(args[1], args[2], szValue, &cchbValue);
	args = szValue;
}


void CMsispyRegistry::GetFeatureInfo(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyRegistry.MsicGetFeatureInfo(args[1], args[2], args[3], szValue, &cchbValue);
	args = szValue;
}


void CMsispyRegistry::QueryProductState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyRegistry.MsicQueryProductState(args[1]);
	args = *(int *) &iState;
}

void CMsispyRegistry::QueryFeatureState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyRegistry.MsicQueryFeatureState(args[1], args[2]);
	args = *(int *) &iState;
}

void CMsispyRegistry::QueryComponentState(CAutoArgs& args)
{
	INSTALLSTATE iState = cSpyRegistry.MsicGetComponentPath(args[1], args[2], NULL, NULL);
	args = *(int *) &iState;
}

void CMsispyRegistry::GetFeatureUsage(CAutoArgs& args)
{
	DWORD dwCount;
	WORD	wTemp;
	cSpyRegistry.MsicGetFeatureUsage(args[1], args[2], &dwCount, &wTemp);
	args = *(long *) &dwCount;
}


void CMsispyRegistry::GetClientFromComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_GUID+1] = TEXT("");
	cSpyRegistry.MsicEnumClients(args[1], iIndex, szValue);
	args = szValue;
}


void CMsispyRegistry::GetFileFromComponent(CAutoArgs& args)
{
	unsigned int iIndex = args[2];
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyRegistry.MsicEnumFilesFromComponent(args[1], iIndex, szValue, &cchbValue);
	args = szValue;
}



void CMsispyRegistry::GetFileInfo(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyRegistry.MsicGetFileInfo(args[1], args[2], args[3], args[4], szValue, &cchbValue);
	args = szValue;
}

void CMsispyRegistry::GetComponentLocation(CAutoArgs& args)
{
	TCHAR szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyRegistry.MsicLocateComponent(args[1], szValue, &cchbValue);
	args = szValue;
}


/////////////////////////////////////////////////////////////////////
// GetComponentPath
// Pre:	args[1] = Product GUID
//		args[2] = Component GUID
// Pos:	returns path to component
void CMsispyRegistry::GetComponentPath(CAutoArgs& args)
{
	TCHAR	szValue[MAX_PATH+1] = TEXT("");
	DWORD	cchbValue = MAX_PATH+1;
	cSpyRegistry.MsicGetComponentPath(args[1], args[2], szValue, &cchbValue);
	args = szValue;
}	// end of GetComponentPath





//____________________________________________________________________________
//
// DLL management
//____________________________________________________________________________

int __stdcall
DllMain(HINSTANCE hInst, DWORD fdwReason, void* /*pvreserved*/)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_hInstance = hInst;
	else if (fdwReason == DLL_PROCESS_DETACH)
		g_hInstance = 0;
	return TRUE;
};   

class CModuleFactory : public IClassFactory
{
 public: // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall CreateInstance(IUnknown* pUnkOuter, const IID& riid,
														void** ppvObject);
	HRESULT       __stdcall LockServer(BOOL fLock);
};
HRESULT CModuleFactory::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IClassFactory)
		return (*ppvObj = this, NOERROR);
	else
		return (*ppvObj = 0, E_NOINTERFACE);
}
unsigned long CModuleFactory::AddRef()
{
	return 1;
}
unsigned long CModuleFactory::Release()
{
	return 1;
}
HRESULT CModuleFactory::CreateInstance(IUnknown* pUnkOuter, const IID& riid,
													void** ppvObject)
{
	if (pUnkOuter)
		return CLASS_E_NOAGGREGATION;
	if (!(riid == IID_IUnknown || riid == IID_IMsispy || riid == IID_IDispatch))
		return E_NOINTERFACE;
	*ppvObject = (void*)::CreateMsispy();
	if (!(*ppvObject))
		return E_OUTOFMEMORY;
	return NOERROR;
}
HRESULT CModuleFactory::LockServer(BOOL fLock)
{
   if (fLock)
      g_cInstances++;
   else if (g_cInstances)
		g_cInstances--;
	return NOERROR;
}
CModuleFactory g_MsispyFactory;

extern "C" HRESULT __stdcall
DllGetClassObject(const GUID& clsid, const IID& iid, void** ppvRet)
{
	*ppvRet = 0;
	if (!(iid == IID_IUnknown || iid == IID_IClassFactory))
		return E_NOINTERFACE;
	if (!(clsid == IID_IMsispy))
		return E_FAIL;
	*ppvRet = (void*)&g_MsispyFactory;
	return NOERROR;
}

extern "C" HRESULT __stdcall
DllCanUnloadNow()
{
   return g_cInstances ? S_FALSE : S_OK;
}

TCHAR szRegFilePath[MAX_PATH+1];
TCHAR szRegCLSID[40];  // buffer for string form of CLSID
TCHAR szRegLIBID[40];  // buffer for string form of LIBID
const TCHAR szRegProgId[]      = TEXT("Msispy.Automation");
const TCHAR szRegDescription[] = TEXT("Msispy automation");

const TCHAR* rgszRegData[] = {
	TEXT("CLSID\\%s\\InprocServer32"),  szRegCLSID, szRegFilePath,
	TEXT("CLSID\\%s\\InprocHandler32"), szRegCLSID, TEXT("ole32.dll"),
	TEXT("CLSID\\%s\\ProgId"),          szRegCLSID, szRegProgId,
	TEXT("CLSID\\%s\\TypeLib"),         szRegCLSID, szRegLIBID,
	TEXT("CLSID\\%s"),                  szRegCLSID, szRegDescription,
	TEXT("%s\\CLSID"),                  szRegProgId, szRegCLSID,
	TEXT("%s"),                         szRegProgId, szRegDescription,
	0
};

HRESULT __stdcall
DllRegisterServer()
{
	HRESULT hRes = 0;
	int cchFilePath = W32::GetModuleFileName(g_hInstance, szRegFilePath, sizeof(szRegFilePath));
	int cErr = 0;
	wsprintf(szRegCLSID,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsispy);
	wsprintf(szRegLIBID,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsispyTypeLib);
	const TCHAR** psz = rgszRegData;
	while (*psz)
	{
		if ((*(psz+1) != 0) && (*(psz+2) != 0)) // handle NULL ProgID
		{
			TCHAR szRegKey[80];
			const TCHAR* szTemplate = *psz++;
			wsprintf(szRegKey, szTemplate, *psz++);
			HKEY hkey;
			if (W32::RegCreateKeyEx(HKEY_CLASSES_ROOT, szRegKey, 0, 0, 0,
											KEY_READ|KEY_WRITE, 0, &hkey, 0) != ERROR_SUCCESS
			 || W32::RegSetValueEx(hkey, 0, 0, REG_SZ, (CONST BYTE*)*psz, (lstrlen(*psz)+1)*sizeof(TCHAR)) != ERROR_SUCCESS)		//unicode issue.
				cErr++;
			psz++;
			W32::RegCloseKey(hkey);
		}
	}
	if (cErr)
		return SELFREG_E_CLASS;
#ifdef UNICODE
	OLECHAR *szTypeLibPath = szRegFilePath;
#else
	OLECHAR szTypeLibPath[MAX_PATH+1];
	W32::MultiByteToWideChar(CP_ACP, 0, szRegFilePath, cchFilePath+1, szTypeLibPath, MAX_PATH);
#endif
	ITypeLib* piTypeLib = 0;
	HRESULT hres = OLEAUT32::LoadTypeLib(szTypeLibPath, &piTypeLib);
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
	hres = OLEAUT32::RegisterTypeLib(piTypeLib, szTypeLibPath, 0);
	piTypeLib->Release();
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
//NT4,Win95 only: if (OLEAUT32::LoadTypeLibEx(szTypeLibPath, REGKIND_REGISTER, &piTypeLib) != S_OK)
	return NOERROR;
}

HRESULT __stdcall
DllUnregisterServer()
{
	TCHAR szRegKey[80];
	int cErr = 0;
	// unregister keys under CLSID and ProgId
	wsprintf(szRegCLSID,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsispy);
	wsprintf(szRegLIBID,      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsispyTypeLib);
	const TCHAR** psz = rgszRegData;
	while (*psz)
	{
		if ((*(psz+1) != 0) && (*(psz+2) != 0)) // handle NULL ProgID
		{
			const TCHAR* szTemplate = *psz++;
			wsprintf(szRegKey, szTemplate, *psz++);
			long lResult = W32::RegDeleteKey(HKEY_CLASSES_ROOT, szRegKey);
			if((ERROR_KEY_DELETED != lResult) &&
				(ERROR_FILE_NOT_FOUND != lResult) && (ERROR_SUCCESS != lResult))
				cErr++;
			psz++;
		}
	}
	OLEAUT32::UnRegisterTypeLib(IID_IMsispyTypeLib, rmj, rmm, 0x0409, SYS_WIN32);
	return cErr ? SELFREG_E_CLASS : NOERROR;
}

//____________________________________________________________________________
//
// Win32 API wrappers to perform on-demand binding to expensive DLLs
//____________________________________________________________________________

#define Assert(p)

// doesn't work for function definitions: using namespace OLEAUT32;

FARPROC Bind_OLEAUT32(const TCHAR* szEntry)
{
	static HINSTANCE hInst = 0;
	if (hInst == 0)
	{
		hInst = W32::LoadLibrary(TEXT("OLEAUT32.DLL"));
		Assert(hInst != 0);
	}
#ifdef UNICODE
	char rgchEntry[MAX_PATH+1];
	WideCharToMultiByte(CP_ACP, NULL, szEntry, -1, rgchEntry, MAX_PATH+1, NULL, NULL);
	return W32::GetProcAddress(hInst, rgchEntry);
#else
	return W32::GetProcAddress(hInst, szEntry);
#endif
}

FARPROC Bind_OLE32(const TCHAR* szEntry)
{
	static HINSTANCE hInst = 0;
	if (hInst == 0)
	{
		hInst = W32::LoadLibrary(TEXT("OLE32.DLL"));
		Assert(hInst != 0);
	}
#ifdef UNICODE
	char rgchEntry[MAX_PATH+1];
	WideCharToMultiByte(CP_ACP, NULL, szEntry, -1, rgchEntry, MAX_PATH+1, NULL, NULL);
	return W32::GetProcAddress(hInst, rgchEntry);
#else
	return W32::GetProcAddress(hInst, szEntry);
#endif
}

BSTR WINAPI OLEAUT32::F_SysAllocString(const OLECHAR* sz)
{
	SysAllocString = (T_SysAllocString)Bind_OLEAUT32(TEXT("SysAllocString"));
	Assert(SysAllocString != 0);
	return SysAllocString ? (*SysAllocString)(sz) : 0;
}

BSTR WINAPI OLEAUT32::F_SysAllocStringLen(const OLECHAR* sz, UINT cch)
{
	SysAllocStringLen = (T_SysAllocStringLen)Bind_OLEAUT32(TEXT("SysAllocStringLen"));
	Assert(SysAllocStringLen != 0);
	return SysAllocStringLen ? (*SysAllocStringLen)(sz, cch) : 0;
}

void WINAPI OLEAUT32::F_SysFreeString(const OLECHAR* sz)
{
	SysFreeString = (T_SysFreeString)Bind_OLEAUT32(TEXT("SysFreeString"));
	Assert(SysFreeString != 0);
	if (SysFreeString) (*SysFreeString)(sz);
}

UINT WINAPI OLEAUT32::F_SysStringLen(const OLECHAR* sz)
{
	SysStringLen = (T_SysStringLen)Bind_OLEAUT32(TEXT("SysStringLen"));
	Assert(SysStringLen != 0);
	return SysStringLen ? (*SysStringLen)(sz) : 0;
}

HRESULT WINAPI OLEAUT32::F_VariantClear(VARIANTARG * pvarg)
{
	VariantClear = (T_VariantClear)Bind_OLEAUT32(TEXT("VariantClear"));
	Assert(VariantClear != 0);
	return VariantClear ? (*VariantClear)(pvarg) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

HRESULT WINAPI OLEAUT32::F_VariantChangeType(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, USHORT wFlags, VARTYPE vt)
{
	VariantChangeType = (T_VariantChangeType)Bind_OLEAUT32(TEXT("VariantChangeType"));
	Assert(VariantChangeType != 0);
	if (VariantChangeType == 0)
		return TYPE_E_DLLFUNCTIONNOTFOUND;
	return (*VariantChangeType)(pvargDest, pvarSrc, wFlags, vt);
}

HRESULT WINAPI OLEAUT32::F_LoadTypeLib(const OLECHAR  *szFile, ITypeLib ** pptlib)
{
	LoadTypeLib = (T_LoadTypeLib)Bind_OLEAUT32(TEXT("LoadTypeLib"));
	Assert(LoadTypeLib != 0);
	return LoadTypeLib ? (*LoadTypeLib)(szFile, pptlib) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

HRESULT WINAPI OLEAUT32::F_RegisterTypeLib(ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir)
{
	RegisterTypeLib = (T_RegisterTypeLib)Bind_OLEAUT32(TEXT("RegisterTypeLib"));
	Assert(RegisterTypeLib != 0);
	return RegisterTypeLib ? (*RegisterTypeLib)(ptlib, szFullPath, szHelpDir) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

HRESULT WINAPI OLEAUT32::F_UnRegisterTypeLib(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind)
{
	UnRegisterTypeLib = (T_UnRegisterTypeLib)Bind_OLEAUT32(TEXT("UnRegisterTypeLib"));
	Assert(UnRegisterTypeLib != 0);
	return UnRegisterTypeLib ? (*UnRegisterTypeLib)(libID, wVerMajor, wVerMinor, lcid, syskind) : TYPE_E_DLLFUNCTIONNOTFOUND;
}

INT WINAPI OLEAUT32::F_SystemTimeToVariantTime(LPSYSTEMTIME lpSystemTime, double *pvtime)
{
	SystemTimeToVariantTime = (T_SystemTimeToVariantTime)Bind_OLEAUT32(TEXT("SystemTimeToVariantTime"));
	Assert(SystemTimeToVariantTime != 0);
	return SystemTimeToVariantTime ? (*SystemTimeToVariantTime)(lpSystemTime, pvtime) : 0;
}

INT WINAPI OLEAUT32::F_VariantTimeToSystemTime(double vtime, LPSYSTEMTIME lpSystemTime)
{
	VariantTimeToSystemTime = (T_VariantTimeToSystemTime)Bind_OLEAUT32(TEXT("VariantTimeToSystemTime"));
	Assert(VariantTimeToSystemTime != 0);
	return VariantTimeToSystemTime ? (*VariantTimeToSystemTime)(vtime, lpSystemTime) : 0;
}

BOOL WINAPI OLE32::F_FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
{
	FileTimeToSystemTime = (T_FileTimeToSystemTime)Bind_OLEAUT32(TEXT("FileTimeToSystemTime"));
	Assert(FileTimeToSystemTime != 0);
	return FileTimeToSystemTime ? (*FileTimeToSystemTime)(lpFileTime, lpSystemTime) : FALSE;
}

BOOL WINAPI OLE32::F_SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
{
	SystemTimeToFileTime = (T_SystemTimeToFileTime)Bind_OLEAUT32(TEXT("SystemTimeToFileTime"));
	Assert(SystemTimeToFileTime != 0);
	return SystemTimeToFileTime ? (*SystemTimeToFileTime)(lpSystemTime, lpFileTime) : FALSE;
}

//____________________________________________________________________________

#else // RC_INVOKED, end of source code, start of resources
1 typelib msispyu.tlb
#endif // RC_INVOKED

#else // __MKTYPLIB__  -  ODL for type library
#include "spydspid.h"   // help context ID definitions, dispatch IDs
#include "..\..\inc\version.h"
#define MAKE_VERSION(a,b) a##.##b
[
	uuid(000C1121-0000-0000-C000-000000000046), // LIBID_MsispyTypeLib
	helpstring("Msispy automation TypeLibrary"),
	lcid(0x0409),
	version( MAKE_VERSION(rmj,rmm) )
]
library Msispy
{
	importlib("stdole32.tlb");
	dispinterface Msispy;
	dispinterface MsispyDatabase;
	dispinterface MsispyProfile;
	dispinterface MsispyRegistry;

typedef [helpcontext(0),helpstring("Msispy enumerations")] enum
{
	[helpcontext(0),helpstring("Msispy Help")]
		isfInteger  = 0,

} Constants;

	[
		uuid(000C1122-0000-0000-C000-000000000046),  // IID_IMsispy
		helpcontext(HELPID_Msispy),helpstring("Msispy top-level object.")
	]
	dispinterface Msispy
	{
		properties:
		methods:
			[id(DISPID_Msispy_CreateDatabase), helpcontext(HELPID_Msispy_CreateDatabase), helpstring("Creates a new database object")]
				MsispyDatabase *CreateDatabase();
			[id(DISPID_Msispy_CreateProfile), helpcontext(HELPID_Msispy_CreateProfile), helpstring("Creates a new profile object")]
				MsispyProfile *CreateProfile();
			[id(DISPID_Msispy_CreateRegistry), helpcontext(HELPID_Msispy_CreateRegistry), helpstring("Creates a new registry object")]
				MsispyRegistry *CreateRegistry();
	};

	[
		uuid(000C1123-0000-0000-C000-000000000046),  // IID_IMsispyDatabase
		helpcontext(HELPID_MsispyDatabase),helpstring("MsispyDatabase object")
	]
	dispinterface MsispyDatabase
	{
		properties:
		methods:
			[id(DISPID_MsispyDatabase_Open), helpcontext(HELPID_MsispyDatabase_Open), helpstring("MsispyDatabase.Open action: opens a database object")]
				void Open([in] BSTR databasePath);
			[id(DISPID_MsispyDatabase_Close), helpcontext(HELPID_MsispyDatabase_Close), helpstring("MsispyDatabase.Close action: closes a database object")]
				void Close();
			[id(DISPID_MsispyDatabase_GetProduct), propget, helpcontext(HELPID_MsispyDatabase_GetProduct), helpstring("Returns product codes from a database, on a 0-based index")]
				BSTR GetProduct([in] long productIndex);
			[id(DISPID_MsispyDatabase_GetFeatureFromProduct), propget, helpcontext(HELPID_MsispyDatabase_GetFeatureFromProduct), helpstring("Returns names of features of a product, on a 0-based index ")]
				BSTR GetFeatureFromProduct([in] BSTR productCode, [in] long featureIndex);
			[id(DISPID_MsispyDatabase_GetComponent), propget, helpcontext(HELPID_MsispyDatabase_GetComponent), helpstring("Returns component GUIDs from a database, on a 0-based index")]
				BSTR GetComponent([in] long componentIndex);
			[id(DISPID_MsispyDatabase_GetComponentFromProduct), propget, helpcontext(HELPID_MsispyDatabase_GetComponentFromProduct), helpstring("Returns GUIDs of components of a product, on a 0-based index")]
				BSTR GetComponentFromProduct([in] BSTR productCode, [in] long componentIndex);
			[id(DISPID_MsispyDatabase_GetComponentFromFeature), propget, helpcontext(HELPID_MsispyDatabase_GetComponentFromFeature), helpstring("Returns GUIDs of components of a feature, on a 0-based index")]
				BSTR GetComponentFromFeature([in] BSTR productCode, [in] BSTR featureName, [in] long componentIndex);
			[id(DISPID_MsispyDatabase_GetComponentName), propget, helpcontext(HELPID_MsispyDatabase_GetComponentName), helpstring("Returns the name of the component whose GUID is passed in")]
				BSTR GetComponentName([in] BSTR componentGuid);
			[id(DISPID_MsispyDatabase_GetProductInfo), propget, helpcontext(HELPID_MsispyDatabase_GetProductInfo), helpstring("Returns info on a product based on the case-sensitive productAttribute")]
				BSTR GetProductInfo([in] BSTR productCode, [in] BSTR productAttribute);
			[id(DISPID_MsispyDatabase_GetFeatureInfo), propget, helpcontext(HELPID_MsispyDatabase_GetFeatureInfo), helpstring("Returns info on a feature based on the case-sensitive featureAttribute")]
				BSTR GetFeatureInfo([in] BSTR productCode, [in] BSTR featureName, [in] BSTR featureAttribute);
			[id(DISPID_MsispyDatabase_QueryProductState), propget, helpcontext(HELPID_MsispyDatabase_QueryProductState), helpstring("Returns the numeric state of a product")]
				int QueryProductState([in] BSTR productCode);
			[id(DISPID_MsispyDatabase_QueryFeatureState), propget, helpcontext(HELPID_MsispyDatabase_QueryFeatureState), helpstring("Returns the numeric state of a feature")]
				int QueryFeatureState([in] BSTR productCode, [in] BSTR featureName);
			[id(DISPID_MsispyDatabase_QueryComponentState), propget, helpcontext(HELPID_MsispyDatabase_QueryComponentState), helpstring("Returns the numeric state of a component")]
				int QueryComponentState([in] BSTR productCode, [in] BSTR componentGuid);
			[id(DISPID_MsispyDatabase_GetFeatureUsage), propget, helpcontext(HELPID_MsispyDatabase_GetFeatureUsage), helpstring("Returns the usage-count of a feature")]
				long GetFeatureUsage([in] BSTR productCode, [in] BSTR featureName);
			[id(DISPID_MsispyDatabase_GetClientFromComponent), propget, helpcontext(HELPID_MsispyDatabase_GetClientFromComponent), helpstring("Returns product codes of products that use a component, on a 0-based index")]
				BSTR GetClientFromComponent([in] BSTR componentGuid, [in] long clientIndex);
			[id(DISPID_MsispyDatabase_GetFileFromComponent), propget, helpcontext(HELPID_MsispyDatabase_GetFileFromComponent), helpstring("Returns names of files of a component, on a 0-based index")]
				BSTR GetFileFromComponent([in] BSTR componentGuid, [in] long productIndex);
			[id(DISPID_MsispyDatabase_GetFileInfo), propget, helpcontext(HELPID_MsispyDatabase_GetFileInfo), helpstring("Returns info on a file based on the case-sensitive fileAttribute")]
				BSTR GetFileInfo([in] BSTR productCode, [in] BSTR componentGuid, [in] BSTR fileName, [in] BSTR fileAttribute);
			[id(DISPID_MsispyDatabase_GetComponentLocation), propget, helpcontext(HELPID_MsispyDatabase_GetComponentLocation), helpstring("Returns the full path of an installed component")]
				BSTR GetComponentLocation([in] BSTR componentGuid);
	};

	
	[
		uuid(000C1124-0000-0000-C000-000000000046),  // IID_IMsispyProfile
		helpcontext(HELPID_MsispyProfile),helpstring("MsispyProfile object.")
	]
	dispinterface MsispyProfile
	{
		properties:
		methods:
			[id(DISPID_MsispyProfile_Open), helpcontext(HELPID_MsispyProfile_Open), helpstring("MsispyProfile.Open action: opens a profile object")]
				void Open([in] BSTR ProfilePath);
			[id(DISPID_MsispyProfile_Close), helpcontext(HELPID_MsispyProfile_Close), helpstring("MsispyProfile.Close action: closes a profile object")]
				void Close();
			[id(DISPID_MsispyProfile_GetProduct), propget, helpcontext(HELPID_MsispyProfile_GetProduct), helpstring("Returns product codes from a profile, on a 0-based index")]
				BSTR GetProduct([in] long productIndex);
			[id(DISPID_MsispyProfile_GetFeatureFromProduct), propget, helpcontext(HELPID_MsispyProfile_GetFeatureFromProduct), helpstring("Returns names of features of a product, on a 0-based index")]
				BSTR GetFeatureFromProduct([in] BSTR productCode, [in] long featureIndex);
			[id(DISPID_MsispyProfile_GetComponent), propget, helpcontext(HELPID_MsispyProfile_GetComponent), helpstring("Returns component GUIDs from a profile, on a 0-based index")]
				BSTR GetComponent([in] long componentIndex);
			[id(DISPID_MsispyProfile_GetComponentFromProduct), propget, helpcontext(HELPID_MsispyProfile_GetComponentFromProduct), helpstring("Returns GUIDs of components of a product, on a 0-based index")]
				BSTR GetComponentFromProduct([in] BSTR productCode, [in] long componentIndex);
			[id(DISPID_MsispyProfile_GetComponentFromFeature), propget, helpcontext(HELPID_MsispyProfile_GetComponentFromFeature), helpstring("Returns GUIDs of components of a feature, on a 0-based index")]
				BSTR GetComponentFromFeature([in] BSTR productCode, [in] BSTR featureName, [in] long componentIndex);
			[id(DISPID_MsispyProfile_GetComponentName), propget, helpcontext(HELPID_MsispyProfile_GetComponentName), helpstring("Returns the name of the component whose GUID is passed in")]
				BSTR GetComponentName([in] BSTR componentGuid);
			[id(DISPID_MsispyProfile_GetProductInfo), propget, helpcontext(HELPID_MsispyProfile_GetProductInfo), helpstring("Returns info on a product based on the case-sensitive productAttribute")]
				BSTR GetProductInfo([in] BSTR productCode, [in] BSTR productAttribute);
			[id(DISPID_MsispyProfile_GetFeatureInfo), propget, helpcontext(HELPID_MsispyProfile_GetFeatureInfo), helpstring("Returns info on a feature based on the case-sensitive featureAttribute")]
				BSTR GetFeatureInfo([in] BSTR productCode, [in] BSTR featureName, [in] BSTR featureAttribute);
			[id(DISPID_MsispyProfile_QueryProductState), propget, helpcontext(HELPID_MsispyProfile_QueryProductState), helpstring("Returns the numeric state of a product")]
				int QueryProductState([in] BSTR productCode);
			[id(DISPID_MsispyProfile_QueryFeatureState), propget, helpcontext(HELPID_MsispyProfile_QueryFeatureState), helpstring("Returns the numeric state of a feature")]
				int QueryFeatureState([in] BSTR productCode, [in] BSTR featureName);
			[id(DISPID_MsispyProfile_QueryComponentState), propget, helpcontext(HELPID_MsispyProfile_QueryComponentState), helpstring("Returns the numeric state of a component")]
				int QueryComponentState([in] BSTR productCode, [in] BSTR componentGuid);
			[id(DISPID_MsispyProfile_GetFeatureUsage), propget, helpcontext(HELPID_MsispyProfile_GetFeatureUsage), helpstring("Returns the usage-count of a feature")]
				long GetFeatureUsage([in] BSTR productCode, [in] BSTR featureName);
			[id(DISPID_MsispyProfile_GetClientFromComponent), propget, helpcontext(HELPID_MsispyProfile_GetClientFromComponent), helpstring("Returns product codes of products that use a component, on a 0-based index")]
				BSTR GetClientFromComponent([in] BSTR componentGuid, [in] long clientIndex);
			[id(DISPID_MsispyProfile_GetFileFromComponent), propget, helpcontext(HELPID_MsispyProfile_GetFileFromComponent), helpstring("20. No help available!")]
				BSTR GetFileFromComponent([in] BSTR componentGuid, [in] long productIndex);
			[id(DISPID_MsispyProfile_GetFileInfo), propget, helpcontext(HELPID_MsispyProfile_GetFileInfo), helpstring("Returns info on a file based on the case-sensitive fileAttribute")]
				BSTR GetFileInfo([in] BSTR productCode, [in] BSTR ComponentGuid, [in] BSTR fileName, [in] BSTR fileAttribute);
			[id(DISPID_MsispyProfile_GetComponentLocation), propget, helpcontext(HELPID_MsispyProfile_GetComponentLocation), helpstring("Returns the full path of an installed component")]
				BSTR GetComponentLocation([in] BSTR componentGuid);
	};


	[
		uuid(000C1125-0000-0000-C000-000000000046),  // IID_IMsispyRegistry
		helpcontext(HELPID_MsispyRegistry),helpstring("MsispyRegistry object.")
	]
	dispinterface MsispyRegistry
	{
		properties:
		methods:
			[id(DISPID_MsispyRegistry_Open), helpcontext(HELPID_MsispyRegistry_Open), helpstring("MsispyRegistry.Open action: opens a registry object")]
				void Open();
			[id(DISPID_MsispyRegistry_Close), helpcontext(HELPID_MsispyRegistry_Close), helpstring("MsispyRegistry.Close action: closes a registry object")]
				void Close();
			[id(DISPID_MsispyRegistry_GetProduct), propget, helpcontext(HELPID_MsispyRegistry_GetProduct), helpstring("Returns product codes from the registry, on a 0-based index")]
				BSTR GetProduct([in] long productIndex);
			[id(DISPID_MsispyRegistry_GetFeatureFromProduct), propget, helpcontext(HELPID_MsispyRegistry_GetFeatureFromProduct), helpstring("Returns names of features of a product, on a 0-based index")]
				BSTR GetFeatureFromProduct([in] BSTR productCode, [in] long featureIndex);
			[id(DISPID_MsispyRegistry_GetComponent), propget, helpcontext(HELPID_MsispyRegistry_GetComponent), helpstring("Returns component GUIDs from the registry, on a 0-based index")]
				BSTR GetComponent([in] long componentIndex);
			[id(DISPID_MsispyRegistry_GetComponentFromProduct), propget, helpcontext(HELPID_MsispyRegistry_GetComponentFromProduct), helpstring("Returns GUIDs of components of a product, on a 0-based index")]
				BSTR GetComponentFromProduct([in] BSTR productCode, [in] long componentIndex);
			[id(DISPID_MsispyRegistry_GetComponentFromFeature), propget, helpcontext(HELPID_MsispyRegistry_GetComponentFromFeature), helpstring("Returns GUIDs of components of a feature, on a 0-based index")]
				BSTR GetComponentFromFeature([in] BSTR productCode, [in] BSTR featureName, [in] long componentIndex);
			[id(DISPID_MsispyRegistry_GetComponentName), propget, helpcontext(HELPID_MsispyRegistry_GetComponentName), helpstring("Returns the name of the component whose GUID is passed in")]
				BSTR GetComponentName([in] BSTR componentGuid);
			[id(DISPID_MsispyRegistry_GetProductInfo), propget, helpcontext(HELPID_MsispyRegistry_GetProductInfo), helpstring("Returns info on a product based on the case-sensitive productAttribute")]
				BSTR GetProductInfo([in] BSTR productCode, [in] BSTR productAttribute);
			[id(DISPID_MsispyRegistry_GetFeatureInfo), propget, helpcontext(HELPID_MsispyRegistry_GetFeatureInfo), helpstring("Returns info on a feature based on the case-sensitive featureAttribute")]
				BSTR GetFeatureInfo([in] BSTR productCode, [in] BSTR featureName, [in] BSTR featureAttribute);
			[id(DISPID_MsispyRegistry_QueryProductState), propget, helpcontext(HELPID_MsispyRegistry_QueryProductState), helpstring("Returns the numeric state of a product")]
				int QueryProductState([in] BSTR productCode);
			[id(DISPID_MsispyRegistry_QueryFeatureState), propget, helpcontext(HELPID_MsispyRegistry_QueryFeatureState), helpstring("Returns the numeric state of a feature")]
				int QueryFeatureState([in] BSTR productCode, [in] BSTR featureName);
			[id(DISPID_MsispyRegistry_QueryComponentState), propget, helpcontext(HELPID_MsispyRegistry_QueryComponentState), helpstring("Returns the numeric state of a component")]
				int QueryComponentState([in] BSTR productCode, [in] BSTR componentGuid);
			[id(DISPID_MsispyRegistry_GetFeatureUsage), propget, helpcontext(HELPID_MsispyRegistry_GetFeatureUsage), helpstring("Returns the usage-count of a feature")]
				long GetFeatureUsage([in] BSTR productCode, [in] BSTR featureName);
			[id(DISPID_MsispyRegistry_GetClientFromComponent), propget, helpcontext(HELPID_MsispyRegistry_GetClientFromComponent), helpstring("Returns product codes of products that use a component, on a 0-based index")]
				BSTR GetClientFromComponent([in] BSTR componentGuid, [in] long clientIndex);
			[id(DISPID_MsispyRegistry_GetFileFromComponent), propget, helpcontext(HELPID_MsispyRegistry_GetFileFromComponent), helpstring("20. No help available!")]
				BSTR GetFileFromComponent([in] BSTR componentGuid, [in] long productIndex);
			[id(DISPID_MsispyRegistry_GetFileInfo), propget, helpcontext(HELPID_MsispyRegistry_GetFileInfo), helpstring("Returns info on a file based on the case-sensitive fileAttribute")]
				BSTR GetFileInfo([in] BSTR productCode, [in] BSTR ComponentGuid, [in] BSTR fileName, [in] BSTR fileAttribute);
			[id(DISPID_MsispyRegistry_GetComponentLocation), propget, helpcontext(HELPID_MsispyRegistry_GetComponentLocation), helpstring("Returns the full path of an installed component")]
				BSTR GetComponentLocation([in] BSTR componentGuid);
	};

};
#endif  // __MKTYPLIB__

#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyenu.dll\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyara.dll\sources.inc ===
TARGETNAME=SpyAra
!INCLUDE ..\..\..\..\MsiMake.inc
MSISPY_DIR=$(SRC_DIR)\MsiTools\MsiSpy

TARGETTYPE=DYNLINK
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NTTARGETFILE0=AraResAll

UMTYPE=console
DLLDEF=
TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=$(O)\araAll.res
C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=
SOURCES=spyara.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spydeu.dll\spydeu.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//--------------------------------------------------------------------------

// Does nothing but provide a SOURCES target for Spy resource dll, which
// simply links to localized ui***.res file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spydeu.dll\sources.inc ===
TARGETNAME=SpyDeu
!INCLUDE ..\..\..\..\MsiMake.inc
MSISPY_DIR=$(SRC_DIR)\MsiTools\MsiSpy

TARGETTYPE=DYNLINK
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NTTARGETFILE0=DeuResAll

UMTYPE=console
DLLDEF=
TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=$(O)\deuall.res

C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=
SOURCES=..\spydeu.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyara.dll\spyara.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//--------------------------------------------------------------------------

// Does nothing but provide a SOURCES target for Spy resource dll, which
// simply links to localized ui***.res file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyjpn.dll\spyjpn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//--------------------------------------------------------------------------

// Does nothing but provide a SOURCES target for Spy resource dll, which
// simply links to localized ui***.res file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyenu.dll\sources.inc ===
TARGETNAME=SpyEnu
!INCLUDE ..\..\..\..\MsiMake.inc
MSISPY_DIR=$(SRC_DIR)\MsiTools\MsiSpy

TARGETTYPE=DYNLINK
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
DLLDEF=
TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=
C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=$(INC_DIR);$(MSI_SPYRES_DIR);$(RES_OBJDIR)

SOURCES=..\spyenu.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyjpn.dll\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyjpn.dll\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyinc\spydspid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       spydspid.h
//
//--------------------------------------------------------------------------


/* AutoApi.h - defines for MSI API automation layer */

/* Help context IDs */
#include "msispy.hh"

/* OLE automation dispatch IDs */

#define DISPID_Msispy_CreateDatabase				1
#define DISPID_Msispy_CreateProfile					2
#define DISPID_Msispy_CreateRegistry				3

#define DISPID_MsispyDatabase_Open							 1
#define DISPID_MsispyDatabase_Close							 2
#define DISPID_MsispyDatabase_GetProduct					 3
#define	DISPID_MsispyDatabase_GetFeatureFromProduct			 4
#define	DISPID_MsispyDatabase_GetComponent					 5
#define	DISPID_MsispyDatabase_GetComponentFromProduct		 6
#define	DISPID_MsispyDatabase_GetComponentFromFeature		 7
#define	DISPID_MsispyDatabase_GetComponentName				 8
#define	DISPID_MsispyDatabase_GetProductInfo				 9
#define	DISPID_MsispyDatabase_GetFeatureInfo				10
#define	DISPID_MsispyDatabase_QueryProductState				11
#define	DISPID_MsispyDatabase_QueryFeatureState				12
#define	DISPID_MsispyDatabase_QueryComponentState			13
#define	DISPID_MsispyDatabase_GetFeatureUsage				14
#define	DISPID_MsispyDatabase_GetClientFromComponent		15
#define	DISPID_MsispyDatabase_GetFileFromComponent			16
#define	DISPID_MsispyDatabase_GetFileInfo					17
#define	DISPID_MsispyDatabase_GetComponentLocation			18
#define	DISPID_MsispyDatabase_GetComponentPath				19

#define DISPID_MsispyProfile_Open							 1
#define DISPID_MsispyProfile_Close							 2
#define DISPID_MsispyProfile_GetProduct						 3
#define	DISPID_MsispyProfile_GetFeatureFromProduct			 4
#define	DISPID_MsispyProfile_GetComponent					 5
#define	DISPID_MsispyProfile_GetComponentFromProduct		 6
#define	DISPID_MsispyProfile_GetComponentFromFeature		 7
#define	DISPID_MsispyProfile_GetComponentName				 8
#define	DISPID_MsispyProfile_GetProductInfo					 9
#define	DISPID_MsispyProfile_GetFeatureInfo					10
#define	DISPID_MsispyProfile_QueryProductState				11
#define	DISPID_MsispyProfile_QueryFeatureState				12
#define	DISPID_MsispyProfile_QueryComponentState			13
#define	DISPID_MsispyProfile_GetFeatureUsage				14
#define	DISPID_MsispyProfile_GetClientFromComponent			15
#define	DISPID_MsispyProfile_GetFileFromComponent			16
#define	DISPID_MsispyProfile_GetFileInfo					17
#define	DISPID_MsispyProfile_GetComponentLocation			18
#define	DISPID_MsispyProfile_GetComponentPath				19

#define DISPID_MsispyRegistry_Open							 1
#define DISPID_MsispyRegistry_Close							 2
#define DISPID_MsispyRegistry_GetProduct					 3
#define	DISPID_MsispyRegistry_GetFeatureFromProduct			 4
#define	DISPID_MsispyRegistry_GetComponent					 5
#define	DISPID_MsispyRegistry_GetComponentFromProduct		 6
#define	DISPID_MsispyRegistry_GetComponentFromFeature		 7
#define	DISPID_MsispyRegistry_GetComponentName				 8
#define	DISPID_MsispyRegistry_GetProductInfo				 9
#define	DISPID_MsispyRegistry_GetFeatureInfo				10
#define	DISPID_MsispyRegistry_QueryProductState				11
#define	DISPID_MsispyRegistry_QueryFeatureState				12
#define	DISPID_MsispyRegistry_QueryComponentState			13
#define	DISPID_MsispyRegistry_GetFeatureUsage				14
#define	DISPID_MsispyRegistry_GetClientFromComponent		15
#define	DISPID_MsispyRegistry_GetFileFromComponent			16
#define	DISPID_MsispyRegistry_GetFileInfo					17
#define	DISPID_MsispyRegistry_GetComponentLocation			18
#define	DISPID_MsispyRegistry_GetComponentPath				19
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyjpn.dll\sources.inc ===
TARGETNAME=SpyJpn
!INCLUDE ..\..\..\..\MsiMake.inc
MSISPY_DIR=$(SRC_DIR)\MsiTools\MsiSpy

TARGETTYPE=DYNLINK
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
DLLDEF=
TARGETPATH=$(MSI_BUILD_TARGET)

NTTARGETFILE0=JpnResAll

TARGETLIBS=$(O)\jpnAll.res
C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=
SOURCES=..\spyjpn.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyjpn.dll\make.inc ===
JpnResAll: $(O)\jpnAll.res

$(O)\jpnAll.res: $(O)\spyjpn.res ..\uijpn.res
	copy /b $(O)\spyjpn.res + ..\uijpn.res /b $@

$(O)\spyjpn.res: ..\spyjpn.rc
	rc $(C_DEFINES) -d_RC32 -Fo$@ -i $(INC_DIR) -i $(SDK_INC_PATH) -i $(RES_OBJDIR) -dNEUTRAL_SUBLANGUAGE ..\spyjpn.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyinc\hash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       hash.cpp
//
//--------------------------------------------------------------------------

#include "hash.h"
#include <assert.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>


// TODO: Ignore case in all.

// The ListNode Class ----------------------------------------------------
// Used by the List Class below, not meant for direct external use

ListNode::ListNode() {
	m_lpNext	= NULL;
	m_lpData	= NULL;
	m_cbData	= 0;
}


ListNode::~ListNode() {
	if (m_lpData)
		delete [] m_lpData;
}


UINT ListNode::SetData(LPCTSTR lpData, const DWORD cbData) {

	if (!lpData) 
		return ERROR_INVALID_PARAMETER;

	if (m_lpData)
		delete [] m_lpData;

	m_lpData = new TCHAR[cbData];

	if (!m_lpData)
		return ERROR_OUTOFMEMORY;

	lstrcpyn(m_lpData, lpData, cbData);
	m_cbData = cbData;
	return ERROR_SUCCESS;
}


UINT ListNode::GetData(LPTSTR lpData, LPDWORD lpcbData) const {

	if (!(lpData && lpcbData)) 
		return ERROR_INVALID_PARAMETER;

	if (*lpcbData < m_cbData)
		return ERROR_MORE_DATA;

	lstrcpyn(lpData, m_lpData, m_cbData);
	*lpcbData = m_cbData;
	return ERROR_SUCCESS;
}


BOOL ListNode::IsEqual(LPCTSTR lpData, const DWORD cbData, BOOL fIgnoreCase) const {
	return ((lpData) && 
		(cbData == m_cbData) && !(fIgnoreCase?(lstrcmpi(lpData, m_lpData)):(lstrcmp(lpData, m_lpData))));
}




// The List Class --------------------------------------------------------
// Used by the Hashtable Class below, not meant to be used directly

List::List() {
	m_lpFirst = NULL;
	m_iElementCount = 0;
}


List::~List() {
	// clear the list and free memory
	Clear();
}


UINT List::InsertElement(LPCTSTR		lpData, 
						 const DWORD	cbData, 
						 const BOOL		fOnlyIfNew) {

	// already there?
	if (fOnlyIfNew && IsMember(lpData, cbData))
		return ERROR_SUCCESS;
	
	// create new node
	ListNode *lpNewNode = new ListNode();

	if (!lpNewNode)
		return ERROR_OUTOFMEMORY;
		
	// and set data
	UINT iReturnCode;
	if (ERROR_SUCCESS != (iReturnCode = (lpNewNode->SetData(lpData, cbData)))) {
		delete lpNewNode;
		return iReturnCode;
	}

	// add new node at head
	if (!m_iElementCount)		// no elements in list 
		m_lpFirst = lpNewNode;

	else {
		lpNewNode->m_lpNext = m_lpFirst;
		m_lpFirst = lpNewNode;
	}

	// new element added
	m_iElementCount++;

	return ERROR_SUCCESS;
}



UINT List::RemoveElement(LPCTSTR lpData, const DWORD cbData, const BOOL fAllOccurrences) {

	ListNode* lpCurr = m_lpFirst;
	ListNode* lpNext = m_lpFirst;

	// special case: first node
	while (lpNext->IsEqual(lpData, cbData)) {

		m_lpFirst = lpNext->m_lpNext;
		delete lpNext;
		m_iElementCount--;
		lpCurr = lpNext = m_lpFirst;

		if (!fAllOccurrences) 
			return ERROR_SUCCESS;
	}

	// general case
	lpNext = lpNext->m_lpNext;

	while (lpNext) {
		if (lpNext->IsEqual(lpData, cbData)) {

			lpCurr->m_lpNext = lpNext->m_lpNext;
			delete lpNext;
			m_iElementCount--;
			lpNext = lpCurr->m_lpNext;

			if (!fAllOccurrences) 
				return ERROR_SUCCESS;
		} 
		else {
			lpCurr = lpNext;
			lpNext = lpNext->m_lpNext;
		}

	}

	return ERROR_SUCCESS;
}



BOOL List::IsMember(LPCTSTR lpData, const DWORD cbData) const {

	if (!lpData) 
		return FALSE;

	ListNode*	lpCurrent	= m_lpFirst;
	BOOL		fFound		= FALSE;

	while (lpCurrent && !fFound) {
		fFound = lpCurrent->IsEqual(lpData, cbData);
		lpCurrent = lpCurrent->m_lpNext;
	}

	return fFound;
}



UINT List::EnumElements(DWORD	iIndex,
						LPTSTR  lpData, 
						LPDWORD lpcbData) const {


	if (iIndex >= m_iElementCount)
		return ERROR_NO_MORE_ITEMS;
	
	if (!(lpData && lpcbData))
		return ERROR_INVALID_PARAMETER;


	ListNode *lpCurrent	= m_lpFirst;
	DWORD	 dwCounter	= 0;

	while (lpCurrent && (dwCounter++ < iIndex))
		lpCurrent = lpCurrent->m_lpNext;

	if (lpCurrent)
		return lpCurrent->GetData(lpData, lpcbData);

	return ERROR_NO_MORE_ITEMS;
}


void List::Clear() {

	if (m_iElementCount) {
		ListNode *lpCurr = m_lpFirst;
		ListNode *lpPrev;

		while (lpCurr) {
			lpPrev = lpCurr;
			lpCurr = lpCurr->m_lpNext;
			delete lpPrev;
		}
	}

	m_lpFirst = NULL;
	m_iElementCount = 0;
}



// The HashTable Class
// constructors
HashTable::HashTable() {
	m_iIndex		= -1;
	m_iElementCount =  0;
}


HashTable::HashTable(int iIndex) {
	m_iIndex		= iIndex;
	m_iElementCount = 0;
}


HashTable::~HashTable() {
	Clear();
}

// public functions
UINT HashTable::AddElement(LPCTSTR lpData, const DWORD cbData) {



	UINT iErrorCode = 
		m_listBucket[GetHashValue(lpData, cbData)].InsertElement(lpData, cbData);

	if (iErrorCode == ERROR_SUCCESS)
		m_iElementCount++;

	return iErrorCode;
}


UINT HashTable::RemoveElement(LPCTSTR lpData, const DWORD cbData) {

    UINT iIndex = GetHashValue(lpData, cbData);

	m_iElementCount -= m_listBucket[iIndex].GetElementCount();
	UINT iErrorCode  = m_listBucket[iIndex].RemoveElement(lpData, cbData);
	m_iElementCount += m_listBucket[iIndex].GetElementCount();

	return iErrorCode;

}


UINT HashTable::EnumElements(UINT iIndex, LPTSTR lpData, LPDWORD lpcbData) const {

	if (iIndex >= m_iElementCount)
		return ERROR_NO_MORE_ITEMS;
	
	if (!(lpData && lpcbData))
		return ERROR_INVALID_PARAMETER;


	UINT iElementCount	= 0;
	UINT iBucketIndex	= 0;

	while ((iElementCount <= iIndex) && (iBucketIndex < HASHTABLE_BUCKETCOUNT))
		iElementCount += m_listBucket[iBucketIndex++].GetElementCount();

	iElementCount -= m_listBucket[--iBucketIndex].GetElementCount();

	return m_listBucket[iBucketIndex].EnumElements(iIndex-iElementCount, lpData, lpcbData);
}


BOOL HashTable::IsMember(LPCTSTR lpData, const DWORD cbData) const {
	return m_listBucket[GetHashValue(lpData, cbData)].IsMember(lpData, cbData);
}


int HashTable::SetIndex(const int iIndex) {
	int iPreviousIndex = m_iIndex;
	m_iIndex = iIndex;
	return iPreviousIndex;
}


int HashTable::GetIndex() const {
	return m_iIndex;
}


void HashTable::Clear() {

	for (UINT iCount = 0; iCount < HASHTABLE_BUCKETCOUNT; iCount++) 
		m_listBucket[iCount].Clear();

	m_iIndex		= -1;
	m_iElementCount =  0;
}


// private function
UINT HashTable::GetHashValue(LPCTSTR lpData, const DWORD cbData) const {

	UINT iReturnValue = 0;
	DWORD iCounter = 0;
	TCHAR ch = TEXT(' ');

	while (iCounter++ <= cbData && ch) {
		ch = lpData[iCounter-1];
		if (ch >= TEXT('a') && ch <= TEXT('f')) {
			ch = ch - TEXT('a') + TEXT('A');
		}
		// ch in '0'-'9', 'A'-'F': add 0-15, ch btwn '0' and 'A' or ch < '0' : +16, ch > 'F' : +17
		iReturnValue += ch > TEXT('F') ? 17 : ch > TEXT('9') ? ch - TEXT('A') + 10 : ch > TEXT('0') ? ch - TEXT('0') : 16;  

	}

	return (iReturnValue % HASHTABLE_BUCKETCOUNT);

}



// FeatureNode class


FeatureNode::FeatureNode() {
	m_cbParent	  = 0;
	m_lpParent	  = NULL;
	m_lpNext	  = NULL;

}


FeatureNode::~FeatureNode() {
	if (m_lpParent)
		delete [] m_lpParent;

	m_listChildren.Clear();
}


UINT FeatureNode::SetData(LPCTSTR lpParent, const DWORD cbParent) {

	if (!lpParent) 
		return ERROR_INVALID_PARAMETER;

	if (m_lpParent)
		delete [] m_lpParent;

	m_lpParent = new TCHAR[cbParent];

	if (!m_lpParent)
		return ERROR_OUTOFMEMORY;

	lstrcpyn(m_lpParent, lpParent, cbParent);
	m_cbParent = cbParent;
	return ERROR_SUCCESS;
}


UINT FeatureNode::GetData(LPTSTR lpParent, LPDWORD lpcbParent) const {

	if (!(lpParent && lpcbParent)) 
		return ERROR_INVALID_PARAMETER;

	if (*lpcbParent < m_cbParent)
		return ERROR_MORE_DATA;

	lstrcpyn(lpParent, m_lpParent, m_cbParent);
	*lpcbParent = m_cbParent;
	return ERROR_SUCCESS;
}


BOOL FeatureNode::IsEqual(LPCTSTR lpParent, const DWORD cbParent) const {
	return ((lpParent) && (cbParent == m_cbParent) && !(lstrcmp(lpParent, m_lpParent)));
}




FeatureList::FeatureList() {
	m_lpHead = NULL;
}


FeatureList::~FeatureList() {
	Clear();
}


// public functions

UINT FeatureList::AddElement(LPCTSTR lpParent, const DWORD cbParent,
							 LPCTSTR lpChild,  const DWORD cbChild) {


	FeatureNode* lpTemp = m_lpHead;

	while (lpTemp && !lpTemp->IsEqual(lpParent, cbParent))
		lpTemp = lpTemp->m_lpNext;

	if (lpTemp) // Parent exists
		return lpTemp->m_listChildren.InsertElement(lpChild, cbChild);
	else {		// create new node

		// create new node
		FeatureNode *lpNewNode = new FeatureNode();

		if (!lpNewNode)
			return ERROR_OUTOFMEMORY;
			
		// and set data
		UINT iReturnCode;
		if (ERROR_SUCCESS != (iReturnCode = (lpNewNode->SetData(lpParent, cbParent)))) {
			delete lpNewNode;
			return iReturnCode;
		}

		// add new node at head
		lpNewNode->m_lpNext = m_lpHead;
		m_lpHead = lpNewNode;

		return lpNewNode->m_listChildren.InsertElement(lpChild, cbChild);
	}
}


UINT FeatureList::GetAndRemoveNextChild(LPCTSTR		lpParent, 
										const DWORD	cbParent,
										LPTSTR		lpChildData, 
										LPDWORD		lpcbChildData) {

	if (!(lpChildData && lpcbChildData))
		return ERROR_INVALID_PARAMETER;


	FeatureNode* lpTemp = m_lpHead;
	FeatureNode* lpPrev = NULL;

	while (lpTemp && !lpTemp->IsEqual(lpParent, cbParent)) {
		lpPrev = lpTemp;
		lpTemp = lpTemp->m_lpNext;
	}

	UINT iErrorCode;
	if (lpTemp) {

		if (ERROR_SUCCESS != (iErrorCode = lpTemp->m_listChildren.EnumElements(0, lpChildData, lpcbChildData))) {

			if (ERROR_NO_MORE_ITEMS == iErrorCode) {
				if (lpPrev)
					lpPrev->m_lpNext = lpTemp->m_lpNext;
				else
					m_lpHead = lpTemp->m_lpNext;
				delete lpTemp;
			}

			return iErrorCode;
		}

		if (ERROR_SUCCESS != (iErrorCode = lpTemp->m_listChildren.RemoveElement(lpChildData, *lpcbChildData, FALSE)))
			return iErrorCode;

		return ERROR_SUCCESS;
	}
	else
		return ERROR_NO_MORE_ITEMS;
}


void FeatureList::Clear() {

	if (m_lpHead) {
		FeatureNode *lpCurr = m_lpHead;
		FeatureNode *lpPrev;

		while (lpCurr) {
			lpPrev = lpCurr;
			lpCurr = lpCurr->m_lpNext;
			delete lpPrev;
		}
	}

	m_lpHead = NULL;
}


// FeatureTable

// The FeatureTable Class
// constructors
FeatureTable::FeatureTable() {
	m_iElementCount =  0;
}


FeatureTable::~FeatureTable() {
	Clear();
}

// public functions
UINT FeatureTable::AddElement(LPCTSTR		lpParent, 
							  const DWORD	cbParent,
							  LPCTSTR		lpChild,
							  const DWORD	cbChild) {

	UINT iErrorCode = 
		m_listBucket[GetHashValue(lpParent, cbParent)].AddElement(lpParent, cbParent, lpChild, cbChild);

	if (iErrorCode == ERROR_SUCCESS)
		m_iElementCount++;

	return iErrorCode;
}

/*
UINT FeatureTable::RemoveElement(LPCTSTR lpData, const DWORD cbData) {

    UINT iIndex = GetHashValue(lpData, cbData);

	m_iElementCount -= m_listBucket[iIndex].GetElementCount();
	UINT iErrorCode  = m_listBucket[iIndex].RemoveElement(lpData, cbData);
	m_iElementCount += m_listBucket[iIndex].GetElementCount();

	return iErrorCode;

}
*/



UINT FeatureTable::GetAndRemoveNextChild(LPCTSTR lpParent, const DWORD cbParent,
										 LPTSTR	lpChild, LPDWORD lpcbChild) {

	if (!(lpChild && lpcbChild))
		return ERROR_INVALID_PARAMETER;

	return 
		m_listBucket[GetHashValue(lpParent, cbParent)].GetAndRemoveNextChild(lpParent, cbParent, lpChild, lpcbChild);


}

/*
BOOL FeatureTable::IsMember(LPCTSTR lpData, const DWORD cbData) const {
	return m_listBucket[GetHashValue(lpData, cbData)].IsMember(lpData, cbData);
}
*/



void FeatureTable::Clear() {

	for (UINT iCount = 0; iCount < FEATURETABLE_BUCKETCOUNT; iCount++) 
		m_listBucket[iCount].Clear();

	m_iElementCount =  0;
}


// private function
UINT FeatureTable::GetHashValue(LPCTSTR lpData, const DWORD cbData) const {

	UINT iReturnValue = 0;
	DWORD iCounter = 0;
	TCHAR ch = TEXT(' ');

	while (iCounter++ <= cbData && ch) {
		ch = lpData[iCounter-1];
		if (ch >= TEXT('a') && ch <= TEXT('f')) {
			ch = ch - TEXT('a') + TEXT('A');
		}
		// ch in '0'-'9', 'A'-'F': add 0-15, ch btwn '0' and 'A' or ch < '0' : +16, ch > 'F' : +17
		iReturnValue += ch > TEXT('F') ? 17 : ch > TEXT('9') ? ch - TEXT('A') + 10 : ch > TEXT('0') ? ch - TEXT('0') : 16;  

	}

	return (iReturnValue % FEATURETABLE_BUCKETCOUNT);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyenu.dll\spyenu.cpp ===
#if 0
MODULENAME = spyenu
DESCRIPTION = MsiSpy English UI
FILEVERSION = MSI
SUBSYSTEM = RESOURCE
DEPEND = resource.h
!include "..\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//--------------------------------------------------------------------------


#ifndef RC_INVOKED    // start of source code
#else // RC_INVOKED, end of source code, start of resources
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#define APSTUDIO_HIDDEN_SYMBOLS
#include "windows.h"
#undef APSTUDIO_HIDDEN_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_MSISPY              ICON    DISCARDABLE     "msispy.ico"
IDI_ABSENTFE            ICON    DISCARDABLE     "absentfe.ico"
IDI_BROKENCO            ICON    DISCARDABLE     "brokenco.ico"
IDI_BROKENFE            ICON    DISCARDABLE     "brokenfe.ico"
IDI_BROKENPR            ICON    DISCARDABLE     "brokenpr.ico"
IDI_COMPONENT           ICON    DISCARDABLE     "componen.ico"
IDI_COMPUTER            ICON    DISCARDABLE     "computer.ico"
IDI_FEATURE             ICON    DISCARDABLE     "feature.ico"
IDI_PRODUCT             ICON    DISCARDABLE     "product.ico"
IDI_BROKENFL            ICON    DISCARDABLE     "brokenfl.ico"
IDI_FILE                ICON    DISCARDABLE     "file.ico"
IDI_ABSENTCO            ICON    DISCARDABLE     "absentco.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//


IDD_ABOUT DIALOGEX 0, 0, 254, 170
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About Msispy"
FONT 6, "MS Sans Serif"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,196,126,49,14
    LTEXT           "",IDT_ABT_APPNAME,57,20,178,11
    LTEXT           "Copyright 2000 Microsoft Corporation",-1,57,43,120,8
    LTEXT           "",IDT_ABT_USERINFO,57,79,188,34,0,WS_EX_CLIENTEDGE
    LTEXT           "This product is licensed to",-2,57,68,107,8
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,7,119,238,1
    CONTROL         IDB_ABOUT,-1,"Static",SS_BITMAP,7,20,42,92
    CONTROL         IDB_COPYRIGHT,-1,"Static",SS_BITMAP,7,122,177,38
END


IDD_PREFERENCES1 DIALOG DISCARDABLE  0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Preferences"
FONT 8, "MS Sans Serif"
BEGIN
    CONTROL         "Normal",IDC_MODENORMAL,"Button",BS_AUTORADIOBUTTON,15,35,59,
                    8
    CONTROL         "Diagnostic",IDC_MODEDIAGNOSTIC,"Button",BS_AUTORADIOBUTTON,15,
                    50,59,8
    CONTROL         "Restricted",IDC_MODERESTRICTED,"Button",BS_AUTORADIOBUTTON,15,
                    65,59,8
    LTEXT           "",IDC_MODEHELP,15,85,190,60
    GROUPBOX        "Mode",-1,10,20,200,130
//    CONTROL         "Save Settings on Exit",IDC_SAVESETTINGS,"Button",
//                    BS_AUTOCHECKBOX | WS_TABSTOP,13,175,198,16
END

IDD_PREFERENCES2 DIALOG DISCARDABLE  0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Msispy Language Preferences"
FONT 8, "MS Sans Serif"
BEGIN
    CONTROL         "",IDC_LANGUAGELIST,"SysListView32",WS_BORDER | WS_TABSTOP,10,
                    55,205,75,WS_EX_CLIENTEDGE
    LTEXT           "Msispy can be configured to run in any of these \
languages on this machine. If you would like to change the current \
language, click on the desired language and click OK:",-1,10,26,206,25
    LTEXT           "Current Selection:",-1,10,142,56,8
    EDITTEXT        IDC_CURRLANGUAGE,70,142,140,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP
END

/*

IDD_MISSINGCOMP DIALOGEX 0, 0, 221, 177
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Msispy: Missing Features"
FONT 8, "MS Sans Serif"
BEGIN
    CONTROL         302,-1,"Static",SS_BITMAP,13,13,42,92
    DEFPUSHBUTTON   "OK",IDOK,160,131,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,160,150,50,14
    LTEXT           "The following Msispy feature(s) are missing or corrupted on this machine:",
                    -1,67,13,137,16
    CONTROL         "",IDC_COMPLIST,"SysListView32",WS_BORDER | 
                    WS_TABSTOP,67,30,137,20,WS_EX_CLIENTEDGE
    LTEXT           "Would you like Msispy to attempt to fix itself?",-1,67,
                    58,144,8
    CONTROL         "Yes",IDC_YUP,"Button",BS_AUTORADIOBUTTON,67,71,92,11
    CONTROL         "No",IDC_NOPE,"Button",BS_AUTORADIOBUTTON,67,84,42,8
    GROUPBOX        "",-1,7,109,147,57
    LTEXT           "",IDC_HELPLINE1,13,116,134,18
    EDITTEXT        IDC_INSTSRC,13,133,134,8,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    LTEXT           "",IDC_HELPLINE2,13,146,134,18
END
*/

IDD_PF_REINSTALL DIALOG DISCARDABLE  0, 0, 246, 194
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Re-install Product or Feature"
FONT 8, "MS Sans Serif"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,178,6,54,14
    PUSHBUTTON      "Cancel",IDCANCEL,178,23,54,14
    PUSHBUTTON      "Advanced >>",IDC_PF_RI_ADVANCED,178,40,54,14

    LTEXT           "Select Re-install Mode:",-1,7,13,73,14
    LTEXT           "Additonal Re-install Modes:",-1,7,80,120,14

    CONTROL         "Repair all detected reinstall problems",IDC_PF_RI_FILEVERIFY,
                    "Button",BS_AUTORADIOBUTTON,19,28,150,13
    CONTROL         "Reinstall only if file is missing",IDC_PF_RI_FILEMISSING,
                    "Button",BS_AUTORADIOBUTTON,19,41,150,13
    CONTROL         "Force all files to be reinstalled",IDC_PF_RI_FILEREPLACE,
                    "Button",BS_AUTORADIOBUTTON,19,54,150,13

    CONTROL         "Reinstall if file is missing, or an older version exists",
                    IDC_PF_RI_FILEOLDER,"Button",BS_AUTORADIOBUTTON,19,95,208,13
    CONTROL         "Reinstall if file is missing, or an older or equal version exists",
                    IDC_PF_RI_FILEEQUAL,"Button",BS_AUTORADIOBUTTON,19,108,208,13
    CONTROL         "Reinstall if existing file has different version",
                    IDC_PF_RI_FILEEXACT,"Button",BS_AUTORADIOBUTTON,19,121,208,13
    CONTROL         "Verify that required user registry entries are present",
                    IDC_PF_RI_USERDATA,"Button",BS_AUTORADIOBUTTON,19,134,208,13
    CONTROL         "Verify that required local machine registry entries are present",
                    IDC_PF_RI_MACHINEDATA,"Button",BS_AUTORADIOBUTTON,19,147,208,13
    CONTROL         "Recreate all shortcuts",IDC_PF_RI_SHORTCUT,"Button",
                    BS_AUTORADIOBUTTON,19,160,208,13
    CONTROL         "Validate advertised shortcuts and icons",IDC_PF_RI_ADVERTISE,
                    "Button",BS_AUTORADIOBUTTON,19,173,208,13
END


IDD_P_CONFIGURE DIALOG DISCARDABLE  0, 0, 225, 230
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Install or Configure Product"
FONT 8, "MS Sans Serif"
BEGIN
    DEFPUSHBUTTON   "Proceed",IDOK,107,206,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,165,206,50,14
    LTEXT           "This will attempt to install or configure the selected product to the settings you specify. \
To complete this operation, you may need the source from which the selected product was installed.",
                    -1,9,18,190,34
    GROUPBOX        "Product Settings",-1,5,59,210,140
    LTEXT           "Please select the new installation state:",-1,13,74,177,11
    CONTROL         "Default (Files will be installed to their default location)",
                    IDC_P_RC_DEFAULT,"Button",BS_AUTORADIOBUTTON,20,86,181,10
    CONTROL         "Local (Files will be installed on the local machine)",
                    IDC_P_RC_LOCAL,"Button",BS_AUTORADIOBUTTON,20,98,181,10
    CONTROL         "Source (Files will be run from the installation source)",
                    IDC_P_RC_SOURCE,"Button",BS_AUTORADIOBUTTON,20,110,181,10
    CONTROL         "On Demand (Files will be installed when needed)",
                    IDC_P_RC_ADVERTISE,"Button",BS_AUTORADIOBUTTON,20,122,181,10
    LTEXT           "Please select the new installation level:",-1,13,144,177,11
    CONTROL         "Minimum (Only the essential features will be installed)",
                    IDC_P_RC_MINIMUM,"Button",BS_AUTORADIOBUTTON,20,156,193,10
    CONTROL         "Typical (Most commonly used features will be installed)",
                    IDC_P_RC_TYPICAL,"Button",BS_AUTORADIOBUTTON,20,168,193,10
    CONTROL         "Complete (All of the program's features will be installed)",
                    IDC_P_RC_COMPLETE,"Button",BS_AUTORADIOBUTTON,20,180,193,10
END

IDD_F_CONFIGURE DIALOG DISCARDABLE  0, 0, 225, 172
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Install or Configure Feature"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "This will attempt to install or configure the selected feature to the settings you specify. \
To complete this operation, you may need the source from which the selected feature was installed.",
                    -1,9,18,190,34
    GROUPBOX        "Feature Settings",-1,5,59,210,82
    LTEXT           "Please select the new installation state:",-1,13,74,155,11
    CONTROL         "Default (Files will be installed to their default location)",
                    IDC_F_RC_DEFAULT,"Button",BS_AUTORADIOBUTTON,20,86,181,10
    CONTROL         "Local (Files will be installed on the local machine)",
                    IDC_F_RC_LOCAL,"Button",BS_AUTORADIOBUTTON,20,98,181,10
    CONTROL         "Source (Files will be run from the installation source)",
                    IDC_F_RC_SOURCE,"Button",BS_AUTORADIOBUTTON,20,110,181,10
    CONTROL         "On Demand (Files will be installed when needed)",
                    IDC_F_RC_ADVERTISE,"Button",BS_AUTORADIOBUTTON,20,122,181,10
    DEFPUSHBUTTON   "Proceed",IDOK,107,148,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,165,148,50,14
END


IDD_C_PROPERTIES DIALOG DISCARDABLE  0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Component Properties"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Name:",-1,10,26,30,12
    LTEXT           "GUID:",-1,10,61,30,12
    LTEXT           "Status:",-1,10,74,30,12
    LTEXT           "Location:",-1,10,87,30,12

    EDITTEXT        IDT_C_NAME,45,26,162,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_C_GUID,45,61,162,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_C_STATUS,45,74,162,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_C_LOCATION,45,87,162,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,51,206,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,130,206,1
END

IDD_PFC_FILELIST DIALOGEX 0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "File List"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Name:",-1,10,21,30,12
    EDITTEXT        IDT_FLIST_PFC_NAME,45,21,162,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,35,205,1
    LTEXT           "Files:",-1,11,43,59,10
    CONTROL         "",IDC_FILELIST,"SysListView32",WS_BORDER | WS_TABSTOP,
                    10,57,205,143
    PUSHBUTTON      "Verify Files ...",IDC_VERIFYFILELIST,10,205,65,14
    CONTROL         "Include sub-features",IDC_SUBFEATURES,"Button",
                    BS_AUTOCHECKBOX | NOT WS_VISIBLE | WS_TABSTOP,135,42,80,9
    EDITTEXT        IDT_FLIST_TOTALFILES,103,205,112,8,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT | WS_EX_RIGHT
    EDITTEXT        IDT_FLIST_TOTALSIZE,103,214,112,8,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT | WS_EX_RIGHT
END

IDD_F_PROPERTIES DIALOG DISCARDABLE  0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Feature Properties"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Name:",-1,10,26,40,8
    LTEXT           "Title:",-1,10,61,40,8
    LTEXT           "Parent:",-1,10,74,40,8
    LTEXT           "Description:",-1,10,87,40,8
    LTEXT           "Usage Count:",-1,10,140,45,8
    LTEXT           "Last Used:",-1,10,153,45,8
    LTEXT           "Status:",-1,10,166,45,8

    EDITTEXT        IDT_F_NAME,54,26,158,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_F_TITLE,54,61,158,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_F_PARENT,54,74,158,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_F_DESCRIPTION,54,87,158,40,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP|ES_MULTILINE,WS_EX_TRANSPARENT
    EDITTEXT        IDT_F_USAGE_COUNT,58,140,158,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_F_LASTUSED_DATE,58,153,158,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_F_STATUS,58,166,158,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT

    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,51,206,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,130,206,1
END


IDD_P_PROPERTIES1 DIALOG DISCARDABLE  0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Product Properties 1"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Name:",-1,10,26,50,8
    LTEXT           "Version:",-1,10,61,50,8
    LTEXT           "Publisher:",-1,10,74,50,8
    LTEXT           "Product Code:",-1,10,87,50,8
    LTEXT           "Local Package:",-1,10,100,50,8
    LTEXT           "Registered To:",-1,10,135,50,8
    LTEXT           "Product ID:",-1,10,160,50,8
    LTEXT           "Status:",-1,10,174,50,8

    EDITTEXT        IDT_P1_NAME,63,26,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P1_VERSION,63,61,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P1_PUBLISHER,63,74,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P1_PRODUCTCODE,63,87,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P1_LOCALPACKAGE,63,100,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P1_USERNAME,63,135,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P1_USERORG,63,145,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P1_PRODUCT_ID,63,160,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P1_STATUS,63,174,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT

    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,51,206,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,125,206,1
END

IDD_P_PROPERTIES2 DIALOG DISCARDABLE  0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Product Properties 2"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Name:",-1,10,26,50,8
    LTEXT           "Help Link:",-1,10,61,50,8
    LTEXT           "Information:",-1,10,74,50,8
    LTEXT           "Updates:",-1,10,87,50,8
    LTEXT           "Help Line:",-1,10,100,50,8
    LTEXT           "Installed on:",-1,10,135,50,8
    LTEXT           "Installed from:",-1,10,148,50,8
    LTEXT           "Installed to:",-1,10,161,50,8
    LTEXT           "Language:",-1,10,174,50,8

    EDITTEXT        IDT_P2_NAME,63,26,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P2_HELPLINK_URL,63,61,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P2_INFO_URL,63,74,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P2_UPDATES_URL,68,87,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P2_HELPPHONE,63,100,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P2_INSTALL_DATE,63,135,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P2_INSTALL_SOURCE,63,148,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P2_INSTALL_TO,63,161,150,12,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_P2_LANGUAGE,63,174,150,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,51,206,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,125,206,1
END
//    LTEXT           "Company:",-1,10,74,50,8
//    LTEXT           "",IDT_USERCOMP,63,74,150,8


IDD_MSI_PROPERTIES1 DIALOGEX 0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Windows installer Package Properties Page1"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Title:",-1,10,26,50,8
    LTEXT           "Subject:",-1,10,51,50,8
    LTEXT           "Author:",-1,10,64,50,8
    LTEXT           "Keywords:",-1,10,77,50,8
    LTEXT           "Comments:",-1,10,90,50,8
    LTEXT           "Template:",-1,10,114,50,8
    LTEXT           "Codepage:",-1,10,127,50,8
    LTEXT           "Dictionary:",-1,10,140,50,8
    LTEXT           "Application:",-1,10,167,50,8
    LTEXT           "Security:",-1,10,180,50,8
    LTEXT           "Thumbnail:",-1,10,193,50,8

    EDITTEXT        IDT_MSI1_TITLE,63,26,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_SUBJECT,63,51,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_AUTHOR,63,64,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_KEYWORDS,63,77,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_COMMENTS,63,90,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_TEMPLATE,63,114,150,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_CODEPAGE,63,127,150,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_DICTIONARY,63,140,150,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_APPLICATION,63,167,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_SECURITY,63,180,150,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI1_THUMBNAIL,63,193,150,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,42,205,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,103,205,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,156,204,1
END

IDD_MSI_PROPERTIES2 DIALOGEX 0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Database Properties 2"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Title:",-1,10,26,50,8
    LTEXT           "Location:",-1,10,51,50,8
    LTEXT           "Last Saved:",-1,10,64,50,8
    LTEXT           "Revision:",-1,10,77,50,8
    LTEXT           "Saved By:",-1,10,90,50,8
    LTEXT           "Created:",-1,10,114,50,8
    LTEXT           "Edit Time:",-1,10,127,50,8
    LTEXT           "Printed:",-1,10,140,50,8
    LTEXT           "MSI Version Used:",-1,10,167,60,8
    LTEXT           "MSI Source Type:",-1,10,180,59,8
    LTEXT           "MSI Transform:",-1,10,193,59,8
    EDITTEXT        IDT_MSI1_TITLE,63,26,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_LOCATION,63,51,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_LASTSAVED_ON,63,64,136,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_REVISION_NUM,63,77,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_LASTSAVED_BY,63,90,150,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_CREATED_ON,63,114,150,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_EDITTIME,63,127,150,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_LASTPRINTED,63,140,150,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_MSI_VERSION,77,167,136,12,ES_AUTOHSCROLL | ES_READONLY | 
                    NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_MSI_SOURCETYPE,77,180,136,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    EDITTEXT        IDT_MSI2_MSI_TRANSFORM,77,193,136,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,
                    WS_EX_TRANSPARENT
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,42,205,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,103,205,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,156,204,1
END



IDD_SS_PROPERTIES DIALOG DISCARDABLE  0, 0, 226, 226
STYLE WS_CHILD | WS_DISABLED | WS_CAPTION
CAPTION "Saved State File Properties"
FONT 8, "MS Sans Serif"
BEGIN
    LTEXT           "Location:",-1,10,26,40,8
    LTEXT           "Saved By:",-1,10,61,40,8
    LTEXT           "Saved On:",-1,10,74,40,8
    LTEXT           "OS Name:",-1,10,135,50,8
    LTEXT           "OS Version:",-1,10,148,50,8
    LTEXT           "OS Build:",-1,10,161,50,8
    LTEXT           "OS Info:",-1,10,174,50,8

    EDITTEXT        IDT_SS_LOCATION,55,26,162,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_SS_SAVED_BY,55,61,162,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_SS_SAVED_ON,55,74,162,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT

    EDITTEXT        IDT_SS_OS_NAME,55,135,162,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_SS_OS_VERSION,55,148,162,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_SS_OS_BUILD,55,161,162,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    EDITTEXT        IDT_SS_OS_INFO,55,174,162,8,ES_AUTOHSCROLL|ES_READONLY|NOT WS_BORDER|NOT WS_TABSTOP,WS_EX_TRANSPARENT
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,51,206,1
    CONTROL         "",-1,"Static",SS_ETCHEDHORZ | SS_SUNKEN,10,130,206,1
END


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MSISPYMENU MENU DISCARDABLE 
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "View &Windows installer Package...\tCtrl+W",      IDM_FL_OPEN_MSI_PACKAGE
        MENUITEM "View &Installed Products \tCtrl+I",				IDM_FL_OPEN_LOCAL_SYS
        MENUITEM SEPARATOR
        MENUITEM "View &Msispy Saved State...\tCtrl+M",				IDM_FL_LOAD_SAVED_STATE
        MENUITEM "&Save Current State...\tCtrl+S",					IDM_FL_SAVE_CURRENT_STATE
        MENUITEM "&Restore Saved State\tCtrl+R", 		            IDM_FL_RESTORE_STATE, GRAYED
        MENUITEM "&Log Differences...\tCtrl+L",        				IDM_FL_CHECK_DIFFERENCES, GRAYED
        MENUITEM SEPARATOR
        MENUITEM "E&xit",                          					IDM_FL_EXIT
    END
    POPUP "&View"
    BEGIN
        MENUITEM "&Refresh\tF5",                      IDM_VW_REFRESH
        MENUITEM SEPARATOR
        MENUITEM "&Preferences...",                   IDM_VW_PREFERENCES
    END
//  POPUP "&Options"
//  BEGIN
//        MENUITEM "&Diagnostic Mode",                IDM_DIAGNOSTIC
//    END
    POPUP "&Help"
    BEGIN
		MENUITEM "&Index\tF1"						  IDM_HLP_INDEX
        MENUITEM "&About Msispy...",                  IDM_HLP_ABOUT
    END
END

IDR_LVPOPMENU MENU DISCARDABLE 
BEGIN
    POPUP "&Options"
    BEGIN
        MENUITEM "&Properties...",                        IDM_C_SHOW_PROPERTIES
    END
END

IDR_TVPOPMENU MENU DISCARDABLE 
BEGIN
    POPUP "&Options"
    BEGIN
        MENUITEM "&Properties...",                        IDM_PF_SHOW_PROPERTIES
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_ACCEL ACCELERATORS DISCARDABLE 
BEGIN
    VK_F5,          IDM_VW_REFRESH,						VIRTKEY, NOINVERT
    VK_F1,          IDM_HLP_INDEX,						VIRTKEY, NOINVERT
    "W",            IDM_FL_OPEN_MSI_PACKAGE,			VIRTKEY, CONTROL, NOINVERT
    "I",            IDM_FL_OPEN_LOCAL_SYS,				VIRTKEY, CONTROL, NOINVERT
    "M",            IDM_FL_LOAD_SAVED_STATE,			VIRTKEY, CONTROL, NOINVERT
    "S",            IDM_FL_SAVE_CURRENT_STATE,			VIRTKEY, CONTROL, NOINVERT
    "R",            IDM_FL_RESTORE_STATE,				VIRTKEY, CONTROL, NOINVERT
    "L",            IDM_FL_CHECK_DIFFERENCES,			VIRTKEY, CONTROL, NOINVERT
END


/////////////////////////////////////////////////////////////////////////////
//
// Cursor
//

IDC_SPLIT               CURSOR  DISCARDABLE     "split.cur"



/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//
IDB_ABOUT               BITMAP  DISCARDABLE     "spyabout.bmp"
IDB_COPYRIGHT           BITMAP  DISCARDABLE     "copyrit.bmp"


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//



STRINGTABLE DISCARDABLE 
BEGIN
    IDS_CLASSNAME          "Msispy"
    IDS_APPNAME            "Msispy"
    IDS_FATALINITERRMSG    "Msispy could not be initialized\nPlease click on OK to quit"
    IDS_FATALERRCAPTION    "Fatal Error"
    IDS_NULLSTRING         ""
END

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_TV_ROOT						"My Computer"
    IDS_SB_NOTHING_SELECTED			"No product or feature selected"
    IDS_SB_NO_COMPONENTS			"No components to display"
    IDS_SB_ONE_COMPONENT			"1 component"
    IDS_SB_PF_SELECTED				"%s selected"
    IDS_SB_MANY_COMPONENTS			"%d components"
	//changed
    IDS_MSI_PACKAGE					"MSI Package: '%s'"
    IDS_SAVED_STATE					"Saved State: '%s'"
	IDS_RESTORE_SS					"Restore Saved State"
END

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_P_PROPERTIES_DEFAULT		""
    IDS_P_PROPERTIES_HEADER1		"General"
    IDS_P_PROPERTIES_HEADER2		"More Info"
    IDS_P_PROPERTIES_CAPTION		"Product Properties"

    IDS_SS_PROPERTIES_HEADER		"General"
    IDS_SS_PROPERTIES_CAPTION		"Saved State File Properties"
END

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_F_PROPERTIES_DEFAULT		""
    IDS_F_PROPERTIES_HEADER			"General"
    IDS_F_PROPERTIES_CAPTION		"Feature Properties"
    IDS_PF_REINSTALL				"Re-install '%s'..."
    IDS_PF_CONFIGURE				"Configure '%s'..."
    IDS_PF_UNINSTALL				"Uninstall '%s'"
    IDS_PF_INSTALL					"Install '%s'..."
    IDS_PF_ADVERTISE				"Advertise '%s'"
END

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_C_PROPERTIES_DEFAULT		""
    IDS_C_PROPERTIES_HEADER1		"General"
    IDS_C_PROPERTIES_CAPTION		"Component Properties"
    IDS_C_NAME_HEADER				"Component Name"
    IDS_C_STATUS_HEADER				"Component Status"
    IDS_C_PATH_HEADER				"Component Location"
    IDS_C_GUID_HEADER				"Component Id"
    IDS_C_REINSTALL					"Re-install '%s'..."
    IDS_C_PROPERTIES_HEADER2		"File List"
END

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_MSI_OPEN_FILTER				"Windows installer Packages (*.msi)\0*.msi\0All Files (*.*)\0*.*\0\0"
    IDS_MSI_OPEN_CAPTION			"View Windows installer Package"
    IDS_MSI_OPEN_DEFAULT_EXTN		"msi"
    IDS_MSI_OPEN_ERROR_MESSAGE		"The file '%s' is not a valid Windows installer package. \
Please check the file name and path and try again."
    IDS_MSI_OPEN_ERROR_CAPTION		"Error Opening Windows installer Package"
END


STRINGTABLE DISCARDABLE 
BEGIN
    IDS_MSI_PROPERTIES_DEFAULT		""
    IDS_MSI_PROPERTIES_HEADER1		"General"
    IDS_MSI_PROPERTIES_HEADER2		"More Info"
    IDS_MSI_PROPERTIES_CAPTION		"Windows installer Package Properties"

END


STRINGTABLE DISCARDABLE 
BEGIN
    IDS_SS_OPEN_FILTER				"Msispy Saved States (*.mss)\0*.mss\0All files (*.*)\0*.*\0\0"
    IDS_SS_OPEN_CAPTION				"View Msispy Saved State"
    IDS_SS_OPEN_DEFAULT_EXTN		"mss"
END

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_SS_SAVE_FILTER				"Msispy Saved States (*.mss)\0*.mss\0All files (*.*)\0*.*\0\0"
    IDS_SS_SAVE_CAPTION				"Save Current State"
    IDS_SS_SAVE_DEFAULT_EXTN		"mss"
END

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_CHKDIFF_SAVE_FILTER			"Msispy Difference Logs (*.log)\0*.log\0All files (*.*)\0*.*\0\0"
    IDS_CHKDIFF_SAVE_CAPTION		"Log Differences"
    IDS_CHKDIFF_SAVE_DEFAULT_EXTN	"log"
END


STRINGTABLE DISCARDABLE 
BEGIN
    IDS_FILELISTHDR					"File List"
    IDS_FILELISTHDR_COMPONENT_NAME	"Component"
    IDS_FILELISTHDR_FILE_TITLE		"File Title"
    IDS_FILELISTHDR_FILE_PATH		"Location"
    IDS_FILELISTHDR_EXPECTED_SIZE	"Install Size"
    IDS_FILELISTHDR_CURRENT_SIZE	"Current Size"
    IDS_FILELISTHDR_CREATED			"File Created"
    IDS_FILELISTHDR_LASTWRITE		"Last Modified"
    IDS_FILELISTHDR_LASTACCESS		"Last Accessed"

    IDS_FILELIST_ERROR_MESSAGE		"Could not create window\n Out of Memory?"
    IDS_FILELIST_ERROR_CAPTION		"Error"
	IDS_FILEVERIFY_CAPTION			"File Verify Results ..."
END

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_FILE						"%d File"
    IDS_FILES						"%d Files"
    IDS_BYTE						"%d Byte"
    IDS_BYTES						"%d Bytes"
    IDS_MBYTE						"%d MB"
    IDS_KBYTE						"%d KB"
END


STRINGTABLE DISCARDABLE 
BEGIN
	IDS_IS_NOTUSED			"Disabled"
	IDS_IS_BADCONFIG		"Configuration data corrupt"
	IDS_IS_INCOMPLETE		"Installation suspended or in progress"
	IDS_IS_SOURCEABSENT		"Source at remote location is absent"
	IDS_IS_MOREDATA			"Return buffer overflow"
	IDS_IS_INVALIDARG		"Invalid function argument"
	IDS_IS_UNKNOWN			"Unrecognized"
	IDS_IS_BROKEN			"Broken"
	IDS_IS_ADVERTISED		"Advertised on local system"
	IDS_IS_ABSENT			"Not installed"
	IDS_IS_LOCAL			"Installed on local drive"
	IDS_IS_SOURCE			"Installed to run from source"
	IDS_IS_DEFAULT			"Installed at default location"
	IDS_IS_UNDETERMINED		"Could not be determined"
// LOCALISE::
	IDS_IS_UNKNOWNPRODUCT	"Unrecognized product"
	IDS_IS_UNKNOWNFEATURE	"Unrecognized feature"
	IDS_IS_UNKNOWNCOMPONENT	"Unrecognized component"
	IDS_IS_SOMEFILESMISSING	"Some files modified or missing"
// endLOCALISE
END
			
STRINGTABLE DISCARDABLE 
BEGIN
	IDS_PF_RI_ADVANCED				"Advanced <<"
	IDS_PF_RI_NOADVANCED			"Advanced >>"
	IDS_DIAGNOSTICMODE_CAPTION		"Diagnostic Mode"
	IDS_DIAGNOSTICMODE_MESSAGE		"Msispy will now switch to the diagnostic mode.\n\n\
In this mode, Msispy will perform a complete check of all files to determine\n\
component status, instead of relying on the component key file. This mode\n\
will give a more accurate picture of the component status, but will make the\n\
program significantly slower. Msispy should not normally be used in this mode.\n\n\
Are you sure you want to switch to the diagnostic mode?\n\n"
END



STRINGTABLE DISCARDABLE 
BEGIN
    IDS_ITEMTYPE_NONE				" item"
    IDS_ITEMTYPE_COMPONENT			" component"
    IDS_ITEMTYPE_FEATURE			" feature"
    IDS_ITEMTYPE_PRODUCT			" product"
    IDS_ITEMTYPE_ROOT				" item"
END


STRINGTABLE DISCARDABLE 
BEGIN
    IDS_COMMANDLINEHELP_MESSAGE		"/d<srcprof.mss> <destfile.log> :\n\
\tSaves the differences between current system and\n\
\tprofile <srcprof.mss> into <destfile.log>\n\n\
/s<destprof.mss> :\n\
\tSaves current system profile to <destprof.mss>\n\n\
/r<srcprof.mss> :\n\
\tRestores current system to state saved in <srcprof.mss>\n\n\
<srcprof.mss> :\n\
\tLaunches GUI version and loads <srcprof.mss>\n\n\
without any command-line option :\n\
\tLaunches GUI version\n\n"

    IDS_COMMANDLINEHELP_CAPTION		"Msispy Command Line Options"

    IDS_ERRORRESTORING_MESSAGE1		"Msispy could not open the saved state '%s'\n\
Please check the file name and path and try again.\n\n\
For help with the Msispy command line options type in 'msispy /?'"

    IDS_ERRORRESTORING_CAPTION		"Msispy: Error Restoring Saved State"

    IDS_ERRORCHKDIFF_MESSAGE1		"Msispy could not open the saved state '%s'\n\
Please check the file name and path and try again.\n\n\
For help with the Msispy command line options type in 'msispy /?'"

    IDS_ERRORCHKDIFF_CAPTION		"Msispy: Error Checking Differences"

END

// not used
STRINGTABLE DISCARDABLE 
BEGIN
    IDS_YESHELPLINE1				"Msispy will attempt to reinstall the missing feature(s) from the original source"
    IDS_YESHELPLINE2				"If this is on a CD or a floppy disk, you will need to insert it for the reinstall to proceed"
    IDS_NOHELPLINE1					"Msispy will attempt to continue without reinstalling the broken feature(s)."
    IDS_NOHELPLINE2					"The functionality of Msispy will be limited and some features will not be available."
END
// end not used

STRINGTABLE DISCARDABLE 
BEGIN
    IDS_HELP_FAILED_MESSAGE					"Msispy could not load the help file. Please ensure that the help file is present."
    IDS_HELP_FAILED_CAPTION					"Error Loading Help"
	IDS_SWITCH_TO_RESTRICTED_MESSAGE		"\
Msispy has switched to the restricted mode, since a required \n\
system-interface DLL could not be loaded. The functionality \n\
of Msispy will be limited and some features will not be \n\
available in this mode."

	IDS_SWITCH_TO_RESTRICTED_CAPTION		"Msispy Information"
	IDS_STARTUP_RESTRICTED_MESSAGE		"\
Msispy started up in the restricted mode, since a required \n\
system-interface DLL could not be loaded. The functionality \n\
of Msispy will be limited and some features will not be \n\
available in this mode."

	IDS_STARTUP_RESTRICTED_CAPTION		"Msispy Information"

	IDS_UNABLE_TO_FIND_SS_MESSAGE			"Msispy could not load the saved state '%s'\n\
Please check the file name and path and try again.\n\n\
For help with the Msispy command line options type in 'msispy /?'"

	IDS_UNABLE_TO_FIND_SS_CAPTION			"Msispy: Error Loading Saved State"
END

STRINGTABLE DISCARDABLE
BEGIN

	IDS_F_ERROR_RESTORING_LN1		"Msispy could not restore the feature '%s' to its original state." 
	IDS_P_ERROR_RESTORING_LN1		"Msispy could not restore the product '%s' to its original state." 
	IDS_PFC_ERROR_RESTORING_LN2		"Status in saved state: '%s'\n\
Current status: '%s'\n\n\
Please select from one of the options below: \n"
END

STRINGTABLE DISCARDABLE
BEGIN
	IDS_PREFERENCES_HEADER1				"General"
	IDS_PREFERENCES_HEADER2				"Language"
	IDS_PREFERENCES_CAPTION				"Msispy Preferences"
	IDS_MODENORMAL_HELP				"This is the default Msispy mode. In this mode, \
the status of a component is determined solely by checking the key-file. \
All the features of Msispy are available in this mode."
	IDS_MODEDIAGNOSTIC_HELP			"In this mode, Msispy will perform a complete check of all files to determine \
component status, instead of relying on component key files. This mode \
will give a more accurate picture of the component status, but will make the \
program significantly slower. Msispy should not normally be used in this mode."
	IDS_MODERESTRICTED_HELP			"In this mode, the functionality of Msispy is limited to \
the Local Database only. You will not be able to access Windows installer packages \
or Msispy saved states. Leads to a slight performance gain."
	IDS_MODEDEGRADED_HELP			"Msispy can only run in the restricted mode, since a required \
system-interface DLL could not be loaded. The functionality \
of Msispy is limited and you will not be able to access Windows installer packages \
or Msispy saved states. To restore the broken features, you may need to \
re-install Msispy."
	IDS_COPYRIGHT			"Warning: This program is protected by \
copyright law and international treaties. Unauthorized reproduction or distribution of \
this program, or any portion of it, may result in severe civil and criminal penalties, \
and will be prosecuted under the law."
END

#endif // RC_INVOKED

#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msitran\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msistuff\sources.inc ===
TARGETNAME=MsiStuff
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

USE_LIBCMT=1

TARGETLIBS=\
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_NOLIBS=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=\
	..\msistuff.cpp \
	..\msistuff.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyinc\hash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       hash.h
//
//--------------------------------------------------------------------------

// hash.h
// hashtables class

#ifndef HASH_H
#define HASH_H

#include <windows.h>


#define HASHTABLE_BUCKETCOUNT 31
#define FEATURETABLE_BUCKETCOUNT 101

class ListNode {

	friend class List;

public:

	// constructors & destructor
			ListNode();
			~ListNode();

// no longer provided since this may lead to a crash
// if new memory cannot be allocated there is no way of recovering
//			ListNode(LPTSTR	lpData, LPDWORD lpcbData);

	// public functions
	UINT	SetData(LPCTSTR lpData, const DWORD cbData);
	UINT	GetData(LPTSTR lpData, LPDWORD lpcbData) const;
	BOOL	IsEqual(LPCTSTR lpData, const DWORD cbData, BOOL fIgnoreCase=TRUE) const;

private:

	// data members
	LPTSTR		m_lpData;
	DWORD		m_cbData;
	ListNode*	m_lpNext;
};




class List {

public:

	// constructors & desctructor
			List();
			~List();

	// public functions

	// O(n) if fOnlyIfNew is TRUE;
	// O(1) else.
	UINT	InsertElement(LPCTSTR		lpData, 
						  const DWORD	cbData, 
						  const BOOL	fOnlyIfNew = TRUE);

	UINT	RemoveElement(LPCTSTR	  lpData, 
						  const DWORD cbData, 
						  const BOOL  fAllOccurrences = FALSE);	// O(n)


	BOOL	IsMember(LPCTSTR lpData, const DWORD cbData) const;	// O(n)

	UINT	EnumElements(DWORD	 iIndex, 
						 LPTSTR  lpData, 
						 LPDWORD lpcbData) const;				// O(n)

	UINT	GetElementCount() const { return m_iElementCount; }	// O(1)

	void	Clear();											// O(n)

private:

	// data members
	ListNode*	m_lpFirst;
	UINT		m_iElementCount;
};




class HashTable {
public:

	// constructors
			HashTable();
			HashTable(int iIndex);
			~HashTable();

	// access functions
	UINT	AddElement(LPCTSTR lpData, const DWORD cbData);

	UINT	RemoveElement(LPCTSTR lpData, const DWORD cbData);

	UINT	EnumElements(UINT	 iIndex, 
						 LPTSTR  lpValueBuf, 
						 LPDWORD lpcbData) const;

	BOOL	IsMember(LPCTSTR lpData, const DWORD cbData) const;
	int		SetIndex(const int iIndex);
	int		GetIndex() const;
	void	Clear();

private:
	// functions
	UINT	GetHashValue(LPCTSTR lpData, const DWORD cbData) const;

	// data members
	int		m_iIndex;
	List	m_listBucket[HASHTABLE_BUCKETCOUNT];
	UINT	m_iElementCount;
};



class FeatureNode {

	friend class FeatureList;

public:

	// constructors & destructor
			FeatureNode();
			~FeatureNode();

// no longer provided since this may lead to a crash
// if new memory cannot be allocated there is no way of recovering
//			FeatureNode(LPTSTR	lpData, LPDWORD lpcbData);

	// public functions
	UINT	SetData(LPCTSTR lpParent, const DWORD cbParent);
	UINT	GetData(LPTSTR lpParent, LPDWORD lpcbParent) const;
	BOOL	IsEqual(LPCTSTR lpParent, const DWORD cbParent) const;

private:

	// data members
	LPTSTR		m_lpParent;
	DWORD		m_cbParent;
	List		m_listChildren;
	FeatureNode*	m_lpNext;
};


class FeatureList {

public:
	FeatureList();
	~FeatureList();

	// public functions

	UINT AddElement(LPCTSTR lpParent, const DWORD cbParent,
					LPCTSTR lpChild,  const DWORD cbChild);

	UINT GetAndRemoveNextChild(LPCTSTR lpParent, const DWORD cbParent,
							LPTSTR lpChildData, LPDWORD lpcbChildData);

	void Clear();


private:

	FeatureNode* m_lpHead;

};


class FeatureTable {
public:

	// constructors
	FeatureTable();
	~FeatureTable();

	// access functions
	UINT AddElement(LPCTSTR lpParent, const DWORD cbParent,
					LPCTSTR lpChild,  const DWORD cbChild);

	UINT GetAndRemoveNextChild(LPCTSTR lpParent, const DWORD cbParent,
										 LPTSTR	lpChild, LPDWORD lpcbChild);


	void Clear();

private:
	// functions
	UINT	GetHashValue(LPCTSTR lpData, const DWORD cbData) const;

	// data members
	FeatureList	m_listBucket[FEATURETABLE_BUCKETCOUNT];
	UINT		m_iElementCount;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msitran\sources.inc ===
TARGETNAME=msitran
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\OLE32.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msitran.cpp \
	..\msitran.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msispy\spyres\spyres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


// Resource.h
// Resource Identifiers for MSI Spy
#ifndef RESOURCE_H
#define RESOURCE_H




//-Icons--
#define IDI_MSISPY				101

#define IDI_COMPUTER			111
#define IDI_PRODUCT				112
#define IDI_BROKENPR			113
#define IDI_FEATURE				114
#define IDI_ABSENTFE			115
#define IDI_BROKENFE			116

#define IDI_COMPONENT			121
#define IDI_BROKENCO			122
#define	IDI_FILE				123
#define	IDI_BROKENFL			124
#define IDI_ABSENTCO			125	

//-Windows--
#define IDW_TREEVIEW			201
#define	IDW_LISTVIEW			202
#define IDW_STATUS				203
#define IDW_ABOUT				204


//-Other Resources--
#define IDR_MSISPYMENU			211
#define IDR_TVPOPMENU			212
#define IDR_LVPOPMENU			213
#define IDR_ACCEL				215


//-Dialogue Boxes--
#define IDD_ABOUT				1011
#define IDD_P_PROPERTIES1		1021
#define IDD_P_PROPERTIES2		1022
#define IDD_P_CONFIGURE			1031

#define IDD_F_PROPERTIES		1041
#define IDD_PF_REINSTALL		1051
#define	IDD_PF_REINSTALL_MORE	1052
#define IDD_F_CONFIGURE			1061

#define IDD_C_PROPERTIES		1071

#define IDD_MSI_PROPERTIES1		1081		// MSI packages			(MSI_)
#define IDD_MSI_PROPERTIES2		1082
#define IDD_SS_PROPERTIES		1091		// msispy Saved State	(SS_)

#define	IDD_PFC_FILELIST		1101		// Products/Features/Component	(PFC_)



//-Controls--
// Product/Feature ReInstall (PF_RC_)
#define	IDC_PF_RI_FILEVERIFY	2011
#define	IDC_PF_RI_FILEMISSING	2012
#define	IDC_PF_RI_FILEREPLACE	2013
#define	IDC_PF_RI_FILEOLDER		2014
#define	IDC_PF_RI_FILEEQUAL		2015
#define	IDC_PF_RI_FILEEXACT		2016
#define	IDC_PF_RI_USERDATA		2017
#define	IDC_PF_RI_MACHINEDATA	2018
#define	IDC_PF_RI_SHORTCUT		2019
#define	IDC_PF_RI_ADVERTISE		2020

#define	IDC_PF_RI_ADVANCED		2031

// Feature ReConfigure (F_RC_)
#define IDC_F_RC_LOCAL			2041
#define IDC_F_RC_DEFAULT		2042
#define IDC_F_RC_SOURCE			2043
#define IDC_F_RC_UNCACHE		2044
#define IDC_F_RC_ADVERTISE		2045

// Product ReConfigure (P_RC_)
#define IDC_P_RC_TYPICAL		2051
#define IDC_P_RC_COMPLETE		2052
#define IDC_P_RC_MINIMUM		2053
#define IDC_P_RC_DEFAULT		2054
#define IDC_P_RC_LOCAL			2055
#define IDC_P_RC_ADVERTISE		2056
#define IDC_P_RC_SOURCE			2057
#define IDC_P_RC_UNCACHE		2058

#define	IDC_FILELIST			2071
#define	IDC_VERIFYFILELIST		2072
#define IDC_SUBFEATURES			2073

//-Cursor--
#define IDC_SPLIT				2061


//-Menu Options--
#define MENUOPS_BASE			3000

// file menu
#define IDM_FL_OPEN_MSI_PACKAGE		MENUOPS_BASE+11
#define IDM_FL_OPEN_LOCAL_SYS		MENUOPS_BASE+12
#define IDM_FL_LOAD_SAVED_STATE		MENUOPS_BASE+13
#define IDM_FL_SAVE_CURRENT_STATE	MENUOPS_BASE+14
#define IDM_FL_RESTORE_STATE		MENUOPS_BASE+15
#define IDM_FL_CHECK_DIFFERENCES	MENUOPS_BASE+16
#define IDM_FL_EXIT					MENUOPS_BASE+17

// view/help menu
#define IDM_VW_REFRESH				MENUOPS_BASE+21
#define	IDM_VW_PREFERENCES			MENUOPS_BASE+22
#define	IDM_HLP_INDEX				MENUOPS_BASE+42	
#define IDM_HLP_ABOUT				MENUOPS_BASE+41

// pop-up menus
#define IDM_C_SHOW_PROPERTIES		MENUOPS_BASE+101
#define IDM_PF_SHOW_PROPERTIES		MENUOPS_BASE+201
#define	IDM_PF_UNINSTALL			MENUOPS_BASE+202
#define	IDM_P_INSTALL				MENUOPS_BASE+211
#define	IDM_P_ADVERTISE				MENUOPS_BASE+212

#define IDM_C_REINSTALL				MENUOPS_BASE+301
#define IDM_PF_REINSTALL			MENUOPS_BASE+302
#define IDM_PF_CONFIGURE			MENUOPS_BASE+303


//-Static Text--
#define STATICTEXT_BASE			4000
#define IDT_ABT_COPYRIGHT		STATICTEXT_BASE+11
#define IDT_ABT_USERINFO		STATICTEXT_BASE+12
#define IDT_ABT_APPNAME			STATICTEXT_BASE+13

#define IDT_P1_NAME				STATICTEXT_BASE+101
#define IDT_P1_VERSION			STATICTEXT_BASE+111
#define IDT_P1_PUBLISHER		STATICTEXT_BASE+112
#define IDT_P1_PRODUCTCODE		STATICTEXT_BASE+113
#define	IDT_P1_LOCALPACKAGE		STATICTEXT_BASE+114
#define IDT_P1_USERNAME			STATICTEXT_BASE+121
#define	IDT_P1_USERORG			STATICTEXT_BASE+122
#define	IDT_P1_PRODUCT_ID		STATICTEXT_BASE+123
#define	IDT_P1_STATUS			STATICTEXT_BASE+124

#define IDT_P2_NAME				STATICTEXT_BASE+151
#define IDT_P2_HELPLINK_URL		STATICTEXT_BASE+161
#define IDT_P2_INFO_URL			STATICTEXT_BASE+162
#define IDT_P2_UPDATES_URL		STATICTEXT_BASE+163
#define	IDT_P2_HELPPHONE		STATICTEXT_BASE+164
#define IDT_P2_INSTALL_DATE		STATICTEXT_BASE+171
#define IDT_P2_INSTALL_SOURCE	STATICTEXT_BASE+172
#define IDT_P2_INSTALL_TO		STATICTEXT_BASE+173
#define IDT_P2_LANGUAGE			STATICTEXT_BASE+174

#define IDT_F_NAME				STATICTEXT_BASE+201
#define IDT_F_TITLE				STATICTEXT_BASE+202
#define IDT_F_PARENT		 	STATICTEXT_BASE+203
#define IDT_F_DESCRIPTION		STATICTEXT_BASE+204
#define	IDT_F_USAGE_COUNT		STATICTEXT_BASE+211
#define IDT_F_LASTUSED_DATE		STATICTEXT_BASE+212
#define IDT_F_STATUS			STATICTEXT_BASE+213

#define	IDT_C_NAME				STATICTEXT_BASE+301
#define	IDT_C_GUID				STATICTEXT_BASE+302
#define	IDT_C_STATUS			STATICTEXT_BASE+303
#define	IDT_C_LOCATION			STATICTEXT_BASE+304

#define	IDT_FLIST_PFC_NAME		STATICTEXT_BASE+351
#define	IDT_FLIST_TOTALFILES	STATICTEXT_BASE+352
#define	IDT_FLIST_TOTALSIZE		STATICTEXT_BASE+353

#define	IDT_MSI_PROPERTY		STATICTEXT_BASE+400
#define	IDT_MSI1_TITLE			IDT_MSI_PROPERTY+2
#define	IDT_MSI1_SUBJECT		IDT_MSI_PROPERTY+3
#define	IDT_MSI1_AUTHOR			IDT_MSI_PROPERTY+4
#define	IDT_MSI1_KEYWORDS		IDT_MSI_PROPERTY+5
#define	IDT_MSI1_COMMENTS		IDT_MSI_PROPERTY+6
#define	IDT_MSI1_TEMPLATE		IDT_MSI_PROPERTY+7
#define	IDT_MSI1_CODEPAGE		IDT_MSI_PROPERTY+1
#define	IDT_MSI1_DICTIONARY		IDT_MSI_PROPERTY+0
#define	IDT_MSI1_APPLICATION	IDT_MSI_PROPERTY+18
#define	IDT_MSI1_SECURITY		IDT_MSI_PROPERTY+19
#define	IDT_MSI1_THUMBNAIL		IDT_MSI_PROPERTY+17

#define	IDT_MSI2_LOCATION		IDT_MSI_PROPERTY+20
#define	IDT_MSI2_LASTSAVED_ON	IDT_MSI_PROPERTY+13
#define	IDT_MSI2_REVISION_NUM	IDT_MSI_PROPERTY+9
#define	IDT_MSI2_LASTSAVED_BY	IDT_MSI_PROPERTY+8
#define	IDT_MSI2_CREATED_ON		IDT_MSI_PROPERTY+12
#define	IDT_MSI2_EDITTIME		IDT_MSI_PROPERTY+10
#define	IDT_MSI2_LASTPRINTED	IDT_MSI_PROPERTY+11
#define	IDT_MSI2_MSI_VERSION	IDT_MSI_PROPERTY+14
#define	IDT_MSI2_MSI_SOURCETYPE	IDT_MSI_PROPERTY+15
#define	IDT_MSI2_MSI_TRANSFORM	IDT_MSI_PROPERTY+16

#define	IDT_SS_PROPERTY			STATICTEXT_BASE+500
#define	IDT_SS_LOCATION			IDT_SS_PROPERTY+1
#define	IDT_SS_SAVED_BY			IDT_SS_PROPERTY+2
#define	IDT_SS_SAVED_ON			IDT_SS_PROPERTY+3
#define	IDT_SS_OS_NAME			IDT_SS_PROPERTY+4
#define	IDT_SS_OS_VERSION		IDT_SS_PROPERTY+5
#define	IDT_SS_OS_BUILD			IDT_SS_PROPERTY+6
#define	IDT_SS_OS_INFO			IDT_SS_PROPERTY+7

//-String Table Entries--
#define STRINGS_BASE			5000
#define	IDS_CLASSNAME			STRINGS_BASE+1	
#define	IDS_APPNAME				STRINGS_BASE+2
#define	IDS_FATALINITERRMSG		STRINGS_BASE+3
#define	IDS_FATALERRCAPTION		STRINGS_BASE+4
#define	IDS_NULLSTRING			STRINGS_BASE+5

#define	IDS_TV_ROOT				STRINGS_BASE+11


#define	IDS_SB_NOTHING_SELECTED		STRINGS_BASE+12
#define	IDS_SB_NO_COMPONENTS		STRINGS_BASE+13
#define	IDS_SB_ONE_COMPONENT		STRINGS_BASE+14
#define	IDS_SB_PF_SELECTED			STRINGS_BASE+15
#define	IDS_SB_MANY_COMPONENTS		STRINGS_BASE+16

#define	IDS_MSI_PACKAGE				STRINGS_BASE+17
#define	IDS_SAVED_STATE				STRINGS_BASE+18
#define	IDS_RESTORE_SS				STRINGS_BASE+19

#define	IDS_P_PROPERTIES_DEFAULT	STRINGS_BASE+21
#define	IDS_P_PROPERTIES_HEADER1	STRINGS_BASE+22
#define	IDS_P_PROPERTIES_HEADER2	STRINGS_BASE+23
#define	IDS_P_PROPERTIES_CAPTION	STRINGS_BASE+24

#define	IDS_F_PROPERTIES_DEFAULT	STRINGS_BASE+31
#define	IDS_F_PROPERTIES_HEADER		STRINGS_BASE+32
#define	IDS_F_PROPERTIES_CAPTION	STRINGS_BASE+33

#define	IDS_PF_REINSTALL			STRINGS_BASE+34
#define	IDS_PF_CONFIGURE			STRINGS_BASE+35
#define	IDS_PF_UNINSTALL			STRINGS_BASE+36
#define	IDS_PF_INSTALL				STRINGS_BASE+37
#define	IDS_PF_ADVERTISE			STRINGS_BASE+38
#define	IDS_C_REINSTALL				STRINGS_BASE+48

#define	IDS_C_PROPERTIES_DEFAULT	STRINGS_BASE+41
#define	IDS_C_PROPERTIES_HEADER1	STRINGS_BASE+42
#define	IDS_C_PROPERTIES_HEADER2	STRINGS_BASE+49
#define	IDS_C_PROPERTIES_CAPTION	STRINGS_BASE+43
#define	IDS_C_NAME_HEADER			STRINGS_BASE+44
#define	IDS_C_STATUS_HEADER			STRINGS_BASE+45
#define	IDS_C_PATH_HEADER			STRINGS_BASE+46
#define	IDS_C_GUID_HEADER			STRINGS_BASE+47

#define	IDS_SS_OPEN_FILTER			STRINGS_BASE+61
#define	IDS_SS_OPEN_CAPTION			STRINGS_BASE+62
#define	IDS_SS_OPEN_DEFAULT_EXTN	STRINGS_BASE+63

#define	IDS_SS_SAVE_FILTER			STRINGS_BASE+71
#define	IDS_SS_SAVE_CAPTION			STRINGS_BASE+72
#define	IDS_SS_SAVE_DEFAULT_EXTN	STRINGS_BASE+73

#define	IDS_MSI_PROPERTIES_DEFAULT	STRINGS_BASE+81
#define	IDS_MSI_PROPERTIES_HEADER1	STRINGS_BASE+82
#define	IDS_MSI_PROPERTIES_HEADER2	STRINGS_BASE+83
#define	IDS_MSI_PROPERTIES_CAPTION	STRINGS_BASE+84

#define	IDS_SS_PROPERTIES_HEADER	STRINGS_BASE+91
#define	IDS_SS_PROPERTIES_CAPTION	STRINGS_BASE+92

#define	IDS_MSI_OPEN_FILTER				STRINGS_BASE+101
#define	IDS_MSI_OPEN_CAPTION			STRINGS_BASE+102
#define	IDS_MSI_OPEN_DEFAULT_EXTN		STRINGS_BASE+103
#define	IDS_MSI_OPEN_ERROR_MESSAGE		STRINGS_BASE+104
#define	IDS_MSI_OPEN_ERROR_CAPTION		STRINGS_BASE+105

#define IDS_FILELISTHDR					STRINGS_BASE+110
#define IDS_FILELISTHDR_COMPONENT_NAME	STRINGS_BASE+111
#define IDS_FILELISTHDR_FILE_TITLE		STRINGS_BASE+112
#define IDS_FILELISTHDR_FILE_PATH		STRINGS_BASE+113
#define IDS_FILELISTHDR_EXPECTED_SIZE	STRINGS_BASE+114
#define IDS_FILELISTHDR_CURRENT_SIZE	STRINGS_BASE+115
#define IDS_FILELISTHDR_CREATED			STRINGS_BASE+116
#define IDS_FILELISTHDR_LASTWRITE		STRINGS_BASE+117
#define IDS_FILELISTHDR_LASTACCESS		STRINGS_BASE+118

#define IDS_FILELIST_ERROR_MESSAGE		STRINGS_BASE+121
#define IDS_FILELIST_ERROR_CAPTION		STRINGS_BASE+122
#define IDS_FILEVERIFY_CAPTION			STRINGS_BASE+123

#define IDS_FILE						STRINGS_BASE+131
#define IDS_FILES						STRINGS_BASE+132
#define IDS_BYTE						STRINGS_BASE+133
#define IDS_BYTES						STRINGS_BASE+134
#define IDS_MBYTE						STRINGS_BASE+135
#define IDS_KBYTE						STRINGS_BASE+136

#define IDS_IS_NOTUSED				STRINGS_BASE+140
#define IDS_IS_BADCONFIG			STRINGS_BASE+141
#define IDS_IS_INCOMPLETE			STRINGS_BASE+142
#define IDS_IS_SOURCEABSENT			STRINGS_BASE+143
#define IDS_IS_MOREDATA				STRINGS_BASE+144
#define IDS_IS_INVALIDARG			STRINGS_BASE+145
#define IDS_IS_UNKNOWN				STRINGS_BASE+146
#define IDS_IS_BROKEN				STRINGS_BASE+147
#define IDS_IS_ADVERTISED			STRINGS_BASE+148
#define IDS_IS_ABSENT				STRINGS_BASE+149
#define IDS_IS_LOCAL				STRINGS_BASE+150
#define IDS_IS_SOURCE				STRINGS_BASE+151
#define IDS_IS_DEFAULT				STRINGS_BASE+152
#define IDS_IS_UNDETERMINED			STRINGS_BASE+153
#define IDS_IS_SOMEFILESMISSING		STRINGS_BASE+154


#define IDS_PF_RI_ADVANCED			STRINGS_BASE+161
#define IDS_PF_RI_NOADVANCED		STRINGS_BASE+162
#define IDS_DIAGNOSTICMODE_MESSAGE		STRINGS_BASE+163
#define IDS_DIAGNOSTICMODE_CAPTION		STRINGS_BASE+164

#define IDS_ITEMTYPE_NONE				STRINGS_BASE+171
#define IDS_ITEMTYPE_COMPONENT			STRINGS_BASE+172
#define IDS_ITEMTYPE_FEATURE			STRINGS_BASE+173
#define IDS_ITEMTYPE_PRODUCT			STRINGS_BASE+174
#define IDS_ITEMTYPE_ROOT				STRINGS_BASE+175

#define	IDS_CHKDIFF_SAVE_FILTER			STRINGS_BASE+181
#define	IDS_CHKDIFF_SAVE_CAPTION		STRINGS_BASE+182
#define	IDS_CHKDIFF_SAVE_DEFAULT_EXTN	STRINGS_BASE+183

#define	IDS_COMMANDLINEHELP_MESSAGE			STRINGS_BASE+191
#define	IDS_COMMANDLINEHELP_CAPTION			STRINGS_BASE+192
#define	IDS_ERRORRESTORING_MESSAGE1			STRINGS_BASE+193
#define	IDS_ERRORRESTORING_MESSAGE2			STRINGS_BASE+194
#define	IDS_ERRORRESTORING_CAPTION			STRINGS_BASE+195
#define	IDS_ERRORCHKDIFF_MESSAGE1			STRINGS_BASE+196
#define	IDS_ERRORCHKDIFF_MESSAGE2			STRINGS_BASE+197
#define	IDS_ERRORCHKDIFF_CAPTION			STRINGS_BASE+198



//-Bitmaps--
#define	IDB_ABOUT						302
#define	IDB_COPYRIGHT					303


#define	IDS_HELP_FAILED_MESSAGE				STRINGS_BASE+301
#define	IDS_HELP_FAILED_CAPTION				STRINGS_BASE+302
#define	IDS_SWITCH_TO_RESTRICTED_MESSAGE	STRINGS_BASE+303
#define	IDS_SWITCH_TO_RESTRICTED_CAPTION	STRINGS_BASE+304
#define	IDS_STARTUP_RESTRICTED_MESSAGE		STRINGS_BASE+305
#define	IDS_STARTUP_RESTRICTED_CAPTION		STRINGS_BASE+306
#define	IDS_UNABLE_TO_FIND_SS_MESSAGE		STRINGS_BASE+307
#define	IDS_PLEASE_CHECK_PATH_MESSAGE		STRINGS_BASE+308
#define	IDS_UNABLE_TO_FIND_SS_CAPTION		STRINGS_BASE+309
		
#define	IDS_F_ERROR_RESTORING_LN1			STRINGS_BASE+321
#define	IDS_P_ERROR_RESTORING_LN1			STRINGS_BASE+322
#define	IDS_PFC_ERROR_RESTORING_LN2			STRINGS_BASE+323
#define	IDS_STATUS_IN_SS_MESSAGE			STRINGS_BASE+324
#define	IDS_CURRENT_STATUS_MESSAGE			STRINGS_BASE+325
#define	IDS_PFC_ERROR_RESTORING_LN3			STRINGS_BASE+326

#define	IDS_PREFERENCES_HEADER1				STRINGS_BASE+351
#define	IDS_PREFERENCES_HEADER2				STRINGS_BASE+352
#define	IDS_PREFERENCES_CAPTION				STRINGS_BASE+353
#define	IDS_MODENORMAL_HELP					STRINGS_BASE+361
#define	IDS_MODEDIAGNOSTIC_HELP				STRINGS_BASE+362
#define	IDS_MODERESTRICTED_HELP				STRINGS_BASE+363
#define	IDS_MODEDEGRADED_HELP				STRINGS_BASE+364

#define IDS_COPYRIGHT					STRINGS_BASE+401
#define IDS_IS_UNKNOWNPRODUCT			STRINGS_BASE+155	
#define IDS_IS_UNKNOWNFEATURE			STRINGS_BASE+156	
#define IDS_IS_UNKNOWNCOMPONENT			STRINGS_BASE+157	

#define IDD_PREFERENCES1				1201
#define IDD_PREFERENCES2				1202

#define IDC_MODENORMAL					2201
#define IDC_MODEDIAGNOSTIC				2202
#define IDC_MODERESTRICTED				2203
#define IDC_MODEHELP					2204
#define IDC_SAVESETTINGS				2205
#define IDC_LANGUAGELIST				2211
#define IDC_CURRLANGUAGE				2212


//---not used any more--
#define IDD_COMPPROP2			1072
#define	IDD_MISSINGCOMP			1111

#define IDM_OP_DIAGNOSTIC			MENUOPS_BASE+31

#define	IDC_COMPLIST			2081
#define	IDC_HELPLINE1			2082
#define	IDC_HELPLINE2			2083
#define IDC_YUP					2084
#define IDC_NOPE				2085
#define IDC_INSTSRC				2086

#define IDS_YESHELPLINE1				STRINGS_BASE+201
#define IDS_YESHELPLINE2				STRINGS_BASE+202
#define IDS_NOHELPLINE1					STRINGS_BASE+203
#define IDS_NOHELPLINE2					STRINGS_BASE+204

//---end not used--




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msistver\msistver.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msistver.cpp
//
//--------------------------------------------------------------------------


#define W32
#define MSI

#include <windows.h>
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <stdio.h>
#include <stdlib.h>
#include "MsiQuery.h" // MSI API
#include "version.h"

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

const char szHelp[] = "MSI Set Version. Syntax: m {module} | p {package}\n";

const char szDBQuery[] = "UPDATE `Property` SET `Value`='%d.%02d.%.4d.%d' WHERE `Property`='ProductVersion'";
const char szModuleQuery[] = "UPDATE `ModuleSignature` SET `Version`='%d.%02d.%.4d.%d'";

const int cchDisplayBuf = 4096;										

char g_rgchBuffer[409];

//________________________________________________________________________________
//
// Function prototypes
//________________________________________________________________________________

UINT CheckError(UINT iError, LPCSTR szMessage);

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

int __cdecl main(int argc, char* argv[])
{
	if (argc != 3)
	{
		printf(szHelp);
		return -1;
	}


	LPCSTR szQueryTmpl = NULL;
	if (*argv[1]==TEXT('m'))
		szQueryTmpl = szModuleQuery;
	else
		szQueryTmpl = szDBQuery;

	char szQuery[2048];
	sprintf(szQuery, szQueryTmpl, rmj, rmm, rup, rin);
	
	MSIHANDLE hDB = 0;
	MSIHANDLE hView = 0;
	printf("Changing Version: Open...");
	if (!CheckError(MsiOpenDatabaseA(argv[2], (char *)MSIDBOPEN_DIRECT, &hDB), "Failed to Open Database"))
	{
		printf("Query...");
		if (!CheckError(MsiDatabaseOpenViewA(hDB, szQuery, &hView), "Failed to Open View"))
		{
			printf("Change...");
			if (!CheckError(MsiViewExecute(hView, 0), "Failed to Execute View"))
			{
				printf("Close...");
				CheckError(MsiDatabaseCommit(hDB), "Failed to Commit DB");
			}
		}
	}

	MsiCloseHandle(hView);
	MsiCloseHandle(hDB);
	printf("Done.\n");
	return 0;
}


UINT CheckError(UINT iError, LPCSTR szMessage)
{
	if (iError != ERROR_SUCCESS)
	{
		printf(szMessage);
	}
	return iError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msival\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msitran\msitran.cpp ===
#if 0  // makefile definitions
DESCRIPTION = Transform file display
MODULENAME = MsiTran
SUBSYSTEM = console
FILEVERSION = Msi
LINKLIBS = OLE32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       msitran.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f msitran.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 Console Application project
//      2. Add msitran.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

#define W32DOWS_LEAN_AND_MEAN  // faster compile
#define OLE
#define W32
#define MSI

#include <windows.h>
#ifndef RC_INVOKED    // start of source code
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <stdio.h>
#include <wtypes.h> // Needed for OLECHAR definitions
#include <objidl.h> // Needed for IStorage definitions
#include "MsiQuery.h" // MSI API

//________________________________________________________________________________
//
// Constants and globals
//________________________________________________________________________________

// storage format classes (IStorage SetClass, Stat)
const int iidMsiDatabaseStorage           = 0xC1080L;
const int iidMsiTransformStorage          = 0xC1081L;
const int iidMsiTransformStorageOld       = 0xC1082L;
#define MSGUID(iid) {iid,0,0,{0xC0,0,0,0,0,0,0,0x46}}
const GUID STGID_MsiDatabase     = MSGUID(iidMsiDatabaseStorage);
const GUID STGID_MsiTransform    = MSGUID(iidMsiTransformStorage);
const GUID STGID_MsiTransformOld = MSGUID(iidMsiTransformStorageOld);

const TCHAR szStringPool[]       = TEXT("_StringPool");
const TCHAR szStringData[]       = TEXT("_StringData");
const TCHAR szTableCatalog[]     = TEXT("_Tables");
const TCHAR szColumnCatalog[]    = TEXT("_Columns");
const TCHAR szSummaryInfo[]      = TEXT("\005SummaryInformation");
const TCHAR szTransformCatalog[] = TEXT("_Transforms");

const TCHAR szHelp[] =
TEXT("Copyright (C) Microsoft Corporation, 1997-2001.  All rights reserved.\nMsi Transform Tool --- Generate and Apply Transform Files\n\n")
TEXT("Options for MsiTran.exe:\n")
TEXT("-g {base db} {new db} {transform} [{error/validation conditions}] -->Generate\n")
TEXT("-a {transform} {database} [{error conditions}]              -->Apply\n\n")
TEXT("Error Conditions:\n")
TEXT("The following errors may be suppressed when applying a transform.\n")
TEXT("To suppress an error, include the appropriate character in\n")
TEXT("{error conditions}. Conditions specified with -g are placed in\n")
TEXT("the summary information of the transform, but are not used when\n")
TEXT("applying a transform with -a.\n\n")
TEXT("'a': Add existing row.\n")
TEXT("'b': Delete non-existing row.\n")
TEXT("'c': Add existing table.\n")
TEXT("'d': Delete non-existing table.\n")
TEXT("'e': Modify existing row.\n")
TEXT("'f': Change codepage.\n\n")
TEXT("Validation Conditions:\n")
TEXT("The following validation conditions may be used to indicate when a\n")
TEXT("transform may be applied to a package. These conditions may be\n")
TEXT("specified with -g but not -a.\n\n")
TEXT("'g': Check upgrade code.\n")
TEXT("'l': Check language.\n")
TEXT("'p': Check platform.\n")
TEXT("'r': Check product.\n")
TEXT("'s': Check major version only.\n")
TEXT("'t': Check major and minor versions only.\n")
TEXT("'u': Check major, minor, and update versions.\n")
TEXT("'v': Applied database version < base database version.\n")
TEXT("'w': Applied database version <= base database version.\n")
TEXT("'x': Applied database version =  base database version.\n")
TEXT("'y': Applied database version >= base database version.\n")
TEXT("'z': Applied database version >  base database version.\n") 

TEXT("\nGenerate transform without summary info stream (conditions ignored):\n")
TEXT("'@': Suppress summary information stream generation.\n");

const int cchDisplayBuf = 4096;										

const int icdShort      = 1 << 10; // 16-bit integer, or string index
const int icdObject     = 1 << 11; // IMsiData pointer for temp. column, stream for persistent column
const int icdNullable   = 1 << 12; // column will accept null values
const int icdPrimaryKey = 1 << 13; // column is component of primary key
const int icdLong     = 0; // !Object && !Short
const int icdString   = icdObject+icdShort;
const int icdTypeMask = icdObject+icdShort;


const int ictTable = 1;
const int ictColumn = 2;
const int ictOrder = 3;
const int ictType = 4;

OLECHAR* g_szwStringPool;
OLECHAR* g_szwStringData;
OLECHAR* g_szwSummaryInfo;
OLECHAR* g_szwTableCatalog;
OLECHAR* g_szwColumnCatalog;

HANDLE g_hStdOut;
TCHAR g_rgchBuffer[4096];
BOOL g_cbShort;  // used temporarily to support display of old format transform files

//________________________________________________________________________________
//
// Structures and enums
//________________________________________________________________________________

struct StringEntry
{
	char* sz;      // String
	StringEntry() : sz(0) {}
};

enum iceDef
{
	iceNone   = 0,  // No Definition
	iceLong   = 1,  // Long Integer
	iceShort  = 2,  // Short Integer
	iceStream = 3,  // Stream
	iceString = 4   // String
};

struct ColumnEntry
{
	int  nTable;      // Index Into TableEntry Array
	BOOL fPrimaryKey; // Whether Col Is A Primary Key
	BOOL fNullable;   // Whether Col Is Nullable
	char* szName;    // Name Of Col
	iceDef iceType;   // Col Type
	ColumnEntry() : szName(0), nTable(0), iceType(iceNone), fPrimaryKey(FALSE), fNullable(FALSE) {}
};

struct TableEntry
{
	char* szName;         // Name Of Table
	int cColumns;          // Number Of Columns In Table
	int cPrimaryKeys;      // Number Of Primary Keys
	BOOL fNew;             // Whether new table
	iceDef iceColDefs[32]; // Array of Column Definitions
	TableEntry() : szName(0), cColumns(0), cPrimaryKeys(0), fNew(FALSE) {memset(iceColDefs, iceNone, sizeof(iceColDefs));}
};



//________________________________________________________________________________
//
// Function prototypes
//________________________________________________________________________________

void Display(LPCTSTR szMessage);
void ErrorExit(UINT iError, LPCTSTR szMessage);
void CheckError(UINT iError, LPCTSTR szMessage);
void CheckErrorRecord(UINT iError, LPCTSTR szMessage);
void ProcessTransformFile(TCHAR* szDatabase, TCHAR* szTransform);
void AnsiToWide(LPCTSTR sz, OLECHAR*& szw);
void WideToAnsi(const OLECHAR* szw, char*& sz);
void DisplayWide(const char* sz, OLECHAR*& szw);
void EnumerateStreams(IStorage& riStorage, IEnumSTATSTG& riEnum, BOOL fTableCatalog, BOOL fColumnCatalog, MSIHANDLE hDatabase);
void DecodeStringPool(IStorage& riStorage, StringEntry*& rgStrings, int& iMaxStringId);
void FillTransformCatalogArrays(IStorage& riTransformStg, TableEntry*& rgTables, int& cTables,
										  ColumnEntry*& rgColumns, int& cColumns, StringEntry* rgStrings, int iMaxStringId); 
void DisplayColumnCatalog(ColumnEntry* rgColumns, int cColumns, TableEntry* rgTables);
void DisplayTableCatalog(IStorage& riStorage, StringEntry* rgStrings, int iMaxStringId);
void DisplayStream(IStorage& riStorage, OLECHAR* szwStreamName, TCHAR* szStreamName, int cbSize, MSIHANDLE hView, TableEntry* rgTables,
						 int cTables, StringEntry* rgStrings, int iMaxStringId);
void GenerateTransform(TCHAR* szBaseDb, TCHAR* szRefDb, TCHAR* szTransform, int iErrorConditions, int iValidationConditions);
void ApplyTransform(TCHAR* szTransform, TCHAR* szDatabase, int iErrorConditions);
int  TranslateErrorConditions(TCHAR* szErrorConditions);
int  TranslateValidationConditions(TCHAR* szErrorConditions);

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// Determine handle
	g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped

	OLE::CoInitialize(0);

	if (argc == 2 && ((_tcscmp(argv[1], TEXT("-?")) == 0) || (_tcscmp(argv[1], TEXT("/?")) == 0)))
		ErrorExit(0, szHelp);

	// Check for enough arguments and valid options
	if (argc <= 1)
		ErrorExit( 1, TEXT("USAGE: msitran.exe [Option] [Values....]"));
	CheckError(argv[1][0] != TEXT('-') && argv[1][0] != TEXT('/'), TEXT("USAGE: msitran.exe [Option] [Values....]"));
	CheckError(_tcsclen(argv[1]) != 2, TEXT("USAGE: msitran.exe [Option] [Values....]"));

	// Determine option
	switch (argv[1][1])
	{
	case TEXT('a'):
		{
			// Apply Transform

			CheckError(argc != 4 && argc != 5, TEXT("msitran.exe -a {transform} {database} [{error conditions}]"));
			TCHAR* szTransform = argv[2];
			TCHAR* szDatabase = argv[3];
			int iErrorConditions = 0;
			if(argc == 5)
				iErrorConditions = TranslateErrorConditions(argv[4]);
			ApplyTransform(szTransform, szDatabase, iErrorConditions);
			ErrorExit(0, TEXT("Done"));
			break;
		}
	case TEXT('g'):
		{
			// Generate Transform
			CheckError(argc != 5 && argc != 6, TEXT("msitran.exe -g {base db} {ref db} {transform} [{error conditions}]"));
			TCHAR* szBaseDb = argv[2];
			TCHAR* szRefDb = argv[3];
			TCHAR* szTransform = argv[4];
			int iErrorConditions = 0;
			int iValidationConditions = 0;
			if(argc == 6)
			{
				if(_tcsstr(argv[5],TEXT("@")))
					iErrorConditions = -1;  // no summary info
				else
				{
					iErrorConditions = TranslateErrorConditions(argv[5]);
					iValidationConditions = TranslateValidationConditions(argv[5]);
				}
			}
			GenerateTransform(szBaseDb, szRefDb, szTransform, iErrorConditions, iValidationConditions);
			ErrorExit(0, TEXT("Done"));
			break;
		}
	default:
		{
			// Unknown Option
			ErrorExit(1, TEXT("Unknown Option."));
			break;
		}
	};

	return 0;
}

//________________________________________________________________________________
//
// Utility functions:
//    TranslateErrorConditions(...);
//    TranslateValidationConditions(...);
//________________________________________________________________________________

int TranslateErrorConditions(TCHAR* szConditions)
{
	if(!szConditions || !*szConditions)
		return 0;
	
	int iErrorConditions = 0;
	if(_tcsstr(szConditions,TEXT("a")))
		iErrorConditions |= MSITRANSFORM_ERROR_ADDEXISTINGROW;
	if(_tcsstr(szConditions,TEXT("b")))
		iErrorConditions |= MSITRANSFORM_ERROR_DELMISSINGROW;
	if(_tcsstr(szConditions,TEXT("c")))
		iErrorConditions |= MSITRANSFORM_ERROR_ADDEXISTINGTABLE;
	if(_tcsstr(szConditions,TEXT("d")))
		iErrorConditions |= MSITRANSFORM_ERROR_DELMISSINGTABLE;
	if(_tcsstr(szConditions,TEXT("e")))
		iErrorConditions |= MSITRANSFORM_ERROR_UPDATEMISSINGROW;
	if(_tcsstr(szConditions,TEXT("f")))
		iErrorConditions |= MSITRANSFORM_ERROR_CHANGECODEPAGE;

	return iErrorConditions;
}

int TranslateValidationConditions(TCHAR* szConditions)
{
	if(!szConditions || !*szConditions)
		return 0;
	
	int iValidationConditions = 0;
	if(_tcsstr(szConditions,TEXT("s")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_MAJORVERSION;
	if(_tcsstr(szConditions,TEXT("t")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_MINORVERSION;
	if(_tcsstr(szConditions,TEXT("u")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_UPDATEVERSION;
	if(_tcsstr(szConditions,TEXT("v")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION;
	if(_tcsstr(szConditions,TEXT("w")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION;
	if(_tcsstr(szConditions,TEXT("x")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION;
	if(_tcsstr(szConditions,TEXT("y")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION;
	if(_tcsstr(szConditions,TEXT("z")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION;
	if(_tcsstr(szConditions,TEXT("l")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_LANGUAGE;
	if(_tcsstr(szConditions,TEXT("p")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_PLATFORM;
	if(_tcsstr(szConditions,TEXT("r")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_PRODUCT;
	if(_tcsstr(szConditions,TEXT("g")))
		iValidationConditions |= MSITRANSFORM_VALIDATE_UPGRADECODE;

	return iValidationConditions;
}

//________________________________________________________________________________
//
// Error handling and Display functions:
//    Display(...);
//	   ErrorExit(...);
//    CheckError(...);
//
//________________________________________________________________________________

void Display(LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut = _tcsclen(szMessage);;
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif // UNICODE
			DWORD cbWritten;
			W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
	}
}


void ErrorExit(UINT iError, LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut;
		TCHAR szBuffer[256];  // errors only, not used for display output
		if (iError == 0)
			cbOut = lstrlen(szMessage);
		else
		{
			LPCTSTR szTemplate = (iError & 0x80000000L)
										? TEXT("Error 0x%X. %s\n")
										: TEXT("Error %i. %s\n");
			cbOut = _stprintf(szBuffer, szTemplate, iError, szMessage);
			szMessage = szBuffer;
		}
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (W32::GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				W32::WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= sizeof(TCHAR);   // write Unicode if not console device
#endif // UNICODE
			DWORD cbWritten;
			W32::WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			W32::MessageBox(0, szMessage, W32::GetCommandLine(), MB_OK);
	}
	MSI::MsiCloseAllHandles();
	OLE::CoUninitialize();
	W32::ExitProcess(iError);
}

void CheckError(UINT iError, LPCTSTR szMessage)
{
	if (iError != ERROR_SUCCESS)
		ErrorExit(iError, szMessage);
}

void CheckErrorRecord(UINT iError, LPCTSTR szMessage)
{
	if (iError != ERROR_SUCCESS)
	{
		PMSIHANDLE hError = MsiGetLastErrorRecord();
		if (hError)
		{ 
			if (MsiRecordIsNull(hError, 0))
				MsiRecordSetString(hError, 0, TEXT("Error [1]: [2]{, [3]}{, [4]}{, [5]}"));
			TCHAR rgchBuf[1024];
			DWORD cchBuf = sizeof(rgchBuf)/sizeof(TCHAR);
			MsiFormatRecord(0, hError, rgchBuf, &cchBuf);
			szMessage = rgchBuf;
		}
		ErrorExit(iError, szMessage);
	}
}

//_____________________________________________________________________________________________________
//
// Transform application and generation functions
//    GenerateTransform(...);
//    ApplyTransform(...);
//_____________________________________________________________________________________________________

void GenerateTransform(TCHAR* szBaseDb, TCHAR* szRefDb, TCHAR* szTransform, int iErrorConditions,
							  int iValidation)
{
	PMSIHANDLE hBaseDb = 0;
	PMSIHANDLE hRefDb = 0;

	CheckError(MSI::MsiOpenDatabase(szBaseDb, MSIDBOPEN_READONLY, &hBaseDb), TEXT("Error Opening Base Database"));
	CheckError(MSI::MsiOpenDatabase(szRefDb, MSIDBOPEN_READONLY, &hRefDb), TEXT("Error Opening Updated Database"));

	CheckErrorRecord(MSI::MsiDatabaseGenerateTransform(hRefDb, hBaseDb, szTransform, 0, 0), TEXT("Error Generating Transform"));
	if (iErrorConditions != -1)
	{
		CheckErrorRecord(MSI::MsiCreateTransformSummaryInfo(hRefDb, hBaseDb, szTransform, iErrorConditions, iValidation), TEXT("Error Create Transform Summary Info"));
	}
}


void ApplyTransform(TCHAR* szTransform, TCHAR* szDatabase, int iErrorConditions)
{
	PMSIHANDLE hDatabase = 0;

	CheckError(MSI::MsiOpenDatabase(szDatabase, MSIDBOPEN_TRANSACT, &hDatabase), TEXT("Error Opening Database"));

	CheckErrorRecord(MSI::MsiDatabaseApplyTransform(hDatabase, szTransform, iErrorConditions), TEXT("Error Applying Transform"));
	CheckErrorRecord(MSI::MsiDatabaseCommit(hDatabase), TEXT("Error Saving Database"));
}

#else // RC_INVOKED, end of source code, start of resources
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msistuff\msistuff.cpp ===
//+-------------------------------------------------------------------------
//
//      Copyright (C) Microsoft Corporation. All rights reserved.
//
//      File:           msistuff.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include "..\setup.exe\common.h"

//=======================================================
// command line options and matching properties
// ORDER is IMPORTANT!
//=======================================================
TCHAR rgszCommandOptions[]= TEXT("udnviawpmo");
//////////////////////////        0123456789

TCHAR* rgszResName[] = {
/* BaseURL                 */ ISETUPPROPNAME_BASEURL, 
/* Msi Package             */ ISETUPPROPNAME_DATABASE,
/* Product Name            */ ISETUPPROPNAME_PRODUCTNAME,
/* Minimum Msi Version     */ ISETUPPROPNAME_MINIMUM_MSI,
/* InstMsi URL Location    */ ISETUPPROPNAME_INSTLOCATION,
/* InstMsiA                */ ISETUPPROPNAME_INSTMSIA,
/* InstMsiW                */ ISETUPPROPNAME_INSTMSIW,
/* Properties              */ ISETUPPROPNAME_PROPERTIES,
/* Patch                   */ ISETUPPROPNAME_PATCH,
/* Operation               */ ISETUPPROPNAME_OPERATION
};
const int cStandardProperties = sizeof(rgszResName)/sizeof(TCHAR*);

TCHAR rgchResSwitch[] ={TEXT('u'),TEXT('d'),TEXT('n'),TEXT('v'),TEXT('i'),TEXT('a'),TEXT('w'),TEXT('p'),TEXT('m'),TEXT('o')};

//=======================================================
// special options
//=======================================================
const TCHAR chProperties      = TEXT('p');
const TCHAR chMinMsiVer       = TEXT('v');
const TCHAR chOperation       = TEXT('o');
const TCHAR szInstall[]         = TEXT("INSTALL");
const TCHAR szInstallUpd[]      = TEXT("INSTALLUPD");
const TCHAR szMinPatch[]        = TEXT("MINPATCH");
const TCHAR szMajPatch[]        = TEXT("MAJPATCH");
const int   iMinMsiAllowedVer = 150;



//=======================================================
// function prototypes
//=======================================================

void           DisplayHelp();
bool           ParseCommandLine(LPTSTR lpCommandLine);
TCHAR          SkipWhiteSpace(TCHAR*& rpch);
bool           SkipValue(TCHAR*& rpch);
void           RemoveQuotes(LPCTSTR lpOriginal, LPTSTR lpStripped);
bool           DisplayResources(LPCTSTR lpExecutable);
bool           DisplayInstallResource(HMODULE hExeModule, LPCTSTR lpszType, LPCTSTR lpszName);
BOOL  CALLBACK EnumResNamesProc(HMODULE hExeModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR lParam);

//=======================================================
// global constants
//=======================================================
int g_cResources = 0; // count of resources in setup.exe; information purposes only

//_____________________________________________________________________________________________________
//
// main 
//_____________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
        if (argc <= 2)
        {
                if (1 == argc
                        || 0 == lstrcmp(argv[1], TEXT("/?"))
                        || 0 == lstrcmp(argv[1], TEXT("-?")))
                {
                        //
                        // display help

                        DisplayHelp();
                }
                else
                {
                        //
                        // display setup resources

                        TCHAR szExecutable[MAX_PATH] = {0};
                        lstrcpy(szExecutable, argv[1]);
                        if (!DisplayResources(szExecutable))
                                return -1;
                }

        }
        else
        {
                //
                // set resource properties

                TCHAR *szCommandLine = GetCommandLine();
                if (!ParseCommandLine(szCommandLine))
                        return -1;
        }

        return 0;
}

//_____________________________________________________________________________________________________
//
// DisplayHelp
//_____________________________________________________________________________________________________

void DisplayHelp()
{
        TCHAR szHelp[] =
                                        TEXT("Copyright (c) Microsoft Corporation, 2000-2001. All rights reserved.\n")
                                        TEXT("\n")
                                        TEXT("MsiStuff will display or update the resources \n")
                                        TEXT(" in the setup.exe boot strap executable\n")
                                        TEXT("\n")
                                        TEXT("[MsiStuff Command Line Syntax]\n")
                                        TEXT(" Display Properties->> msistuff setup.exe \n")
                                        TEXT(" Set Properties    ->> msistuff setup.exe option {data} ... \n")
                                        TEXT("\n")
                                        TEXT("[MsiStuff Options -- Multiple specifications are allowed]\n")
                                        TEXT(" BaseURL                             - /u {value} \n")
                                        TEXT(" Msi                                 - /d {value} \n")
                                        TEXT(" Product Name                        - /n {value} \n")
                                        TEXT(" Minimum Msi Version                 - /v {value} \n")
                                        TEXT(" InstMsi URL Location                - /i {value} \n")
                                        TEXT(" InstMsiA                            - /a {value} \n")
                                        TEXT(" InstMsiW                            - /w {value} \n")
                                        TEXT(" Patch                               - /m {value} \n")
                                        TEXT(" Operation                           - /o {value} \n")
                                        TEXT(" Properties (PROPERTY=VALUE strings) - /p {value} \n")
                                        TEXT("\n")
                                        TEXT("If an option is specified multiple times, the last one wins\n")
                                        TEXT("\n")
                                        TEXT("/p must be last on the command line.  The remainder of\n")
                                        TEXT("the command line is considered a part of the {value}\n")
                                        TEXT("This also means that /p cannot be specified multiple times\n");
        _tprintf(szHelp);
}

//_____________________________________________________________________________________________________
//
// ParseCommandLine
//
//       If a property has a value that contains spaces, the value must be enclosed in quotation marks
//_____________________________________________________________________________________________________

bool ParseCommandLine(LPTSTR lpCommandLine)
{
        TCHAR szSetupEXE[MAX_PATH] = {0};
        TCHAR szFullPath[2*MAX_PATH] = {0};

        TCHAR  chNextCommand;
        TCHAR *pchCommandLine = lpCommandLine;
        

        // skip over module name and subsequent white space
        SkipValue(pchCommandLine);
        chNextCommand = SkipWhiteSpace(pchCommandLine);
        
        TCHAR* pchCommandData = pchCommandLine;
        SkipValue(pchCommandLine);
        RemoveQuotes(pchCommandData, szSetupEXE);

        // handle possibility of a relative path
        LPTSTR lpszFilePart = 0;
        if (0 == GetFullPathName(szSetupEXE, sizeof(szFullPath)/sizeof(TCHAR), szFullPath, &lpszFilePart))
        {
                // error
                _tprintf(TEXT("Unable to obtain fullpath for %s\n"), szSetupEXE);
                return false;
        }

        _tprintf(TEXT("\nModifying setup properties in:\n\t<%s>\n\n"), szFullPath);

        // make sure the EXE is not already loaded,in use, or read-only
        HANDLE hInUse = CreateFile(szFullPath, GENERIC_WRITE, (DWORD)0, (LPSECURITY_ATTRIBUTES)0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE)0);
        if (INVALID_HANDLE_VALUE == hInUse)
        {
                // error
                _tprintf(TEXT("Unable to obtain file handle for %s.  The file probably does not exist, is marked read-only, or is in use.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }
        CloseHandle(hInUse);

        // begin update resource
        HANDLE hUpdate = BeginUpdateResource(szFullPath, /* bDeleteExistingResources = */ FALSE);
        if ( !hUpdate )
        {
                // error
                _tprintf(TEXT("Unable to update resources in %s.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }

        while ((chNextCommand = SkipWhiteSpace(pchCommandLine)) != 0)
        {
                if (chNextCommand == TEXT('/') || chNextCommand == TEXT('-'))
                {
                        TCHAR *szOption = pchCommandLine++;  // save for error msg
                        TCHAR  chOption = (TCHAR)(*pchCommandLine++ | 0x20); // lower case flag
                        chNextCommand = SkipWhiteSpace(pchCommandLine);
                        pchCommandData = pchCommandLine;

                        for (const TCHAR* pchOptions = rgszCommandOptions; *pchOptions; pchOptions++)
                        {
                                if (*pchOptions == chOption)
                                        break;
                        }

                        if (*pchOptions)
                        {
                                bool fSkipValue   = true; // whether or not to look for next option in command line; (true = look)
                                bool fDeleteValue = false;// whether to delete the value

                                // option is recognized
                                const TCHAR chIndex = (TCHAR)(pchOptions - rgszCommandOptions);
                                if (chIndex >= cStandardProperties)
                                {
                                        // error
                                        _tprintf(TEXT("Invalid index (chIndex = %d, chOption = %c)!!!\n"), chIndex, chOption);
                                        return false;
                                }

                                if (chOption == chProperties)
                                {
                                        fSkipValue = false;
                                        // special for /p -- remainder of command line is part of property
                                        TCHAR chNext = *pchCommandData;
                                        if (chNext == 0 || chNext == TEXT('/') || chNext == TEXT('-'))
                                        {
                                                // no value present
                                                fDeleteValue = true;
                                        }
                                        else
                                        {
                                                // set value to remainder of command line, i.e. all of pchCommandData
                                                // with enclosing quotes stripped -- we do this by telling the command
                                                // line processor to not attempt to look for other options on the
                                                // command line; the remainder is part of this property
                                                fSkipValue = false;
                                        }
                                }

                                if (fSkipValue)
                                        fDeleteValue = (SkipValue(pchCommandLine)) ? false : true;

                                if (fDeleteValue)
                                {
                                        // delete value (special for NT bug where not always updated correctly in case of removal ... so must reset)
                                        if (!UpdateResource(hUpdate, RT_INSTALL_PROPERTY, rgszResName[chIndex], MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL), NULL, 0)
                                                || !EndUpdateResource(hUpdate, /* fDiscard = */ FALSE)
                                                || (!(hUpdate = BeginUpdateResource(szFullPath, /* bDeleteExistingResources = */ FALSE))))
                                        {
                                                // error
                                                _tprintf(TEXT("Unable to delete resource %s in %s.  LastError = %d\n"), rgszResName[chIndex], szFullPath, GetLastError());
                                                return false;
                                        }
                                        _tprintf(TEXT("Removing '%s' . . .\n"), rgszResName[chIndex]);
                                }
                                else
                                {
                                        TCHAR szValueBuf[1024];
                                        RemoveQuotes(pchCommandData, szValueBuf);

                                        if (chOption == chMinMsiVer && (_ttoi(szValueBuf) < iMinMsiAllowedVer))
                                        {
                                                // extra validation: must be >= iMinAllowedVer
                                                _tprintf(TEXT("Skipping option %c with data %s. Data value must be >= %d. . .\n"), chOption, szValueBuf, iMinMsiAllowedVer);
                                                continue;
                                        }

                                        if (chOption == chOperation
                                            && 0 != lstrcmpi(szValueBuf, szInstall)
                                            && 0 != lstrcmpi(szValueBuf, szInstallUpd) 
                                            && 0 != lstrcmpi(szValueBuf, szMinPatch)
                                            && 0 != lstrcmpi(szValueBuf, szMajPatch))
                                        {
                                            // extra validation: must be one of those values
                                            _tprintf(TEXT("Skipping option %c with data %s. Data value must be INSTALL, INSTALLUPD, MINPATCH, or MAJPATCH...\n"), chOption, szValueBuf);
                                            continue;
                                        }

                                        // update value -- this is our own custom resource, so to make it easier on ourselves, we will pack in the NULL as well
                                #ifdef UNICODE
                                        if (!UpdateResource(hUpdate, RT_INSTALL_PROPERTY, rgszResName[chIndex], MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL), szValueBuf, (lstrlen(szValueBuf) + 1)*sizeof(TCHAR)))
                                        {
                                                // error
                                                _tprintf(TEXT("Unable to update resource %s in %s with value %s.  LastError = %d\n"), rgszResName[chIndex], szFullPath, szValueBuf, GetLastError());
                                                return false;
                                        }
                                #else // !UNICODE
                                        // must convert value to Unicode
                                        WCHAR wszValueBuf[1024];
                                        MultiByteToWideChar(CP_ACP, 0, szValueBuf, -1, wszValueBuf, sizeof(wszValueBuf)/sizeof(WCHAR));
                                        if (!UpdateResource(hUpdate, RT_INSTALL_PROPERTY, rgszResName[chIndex], MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL), wszValueBuf, (lstrlenW(wszValueBuf) +1)*sizeof(WCHAR)))
                                        {
                                                // error
                                                _tprintf(TEXT("Unable to update resource %s in %s with value %s.  LastError = %d\n"), rgszResName[chIndex], szFullPath, szValueBuf, GetLastError());
                                                return false;
                                        }
                                #endif // UNICODE
                                        _tprintf(TEXT("Setting '%s' to '%s' . . .\n"), rgszResName[chIndex], szValueBuf);
                                        if (!fSkipValue)
                                                break; // done processing
                                }
                        }
                        else
                        {
                                // invalid option
                                _tprintf(TEXT("Skipping invalid option %c . . .\n"), chOption);
                                SkipValue(pchCommandLine);
                                continue;
                        }
                }
                else
                {
                        // error
                        _tprintf(TEXT("Switch is missing\n"));
                        return false;
                }
        }

        // persist changes
        if (!EndUpdateResource(hUpdate, /* fDiscard = */ FALSE))
        {
                // error
                _tprintf(TEXT("Unable to update resources in %s.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }

        return true;
}

//_____________________________________________________________________________________________________
//
// SkipWhiteSpace
//
//       Skips whitespace in the string and returns next non-tab non-whitespace charcter 
//_____________________________________________________________________________________________________

TCHAR SkipWhiteSpace(TCHAR*& rpch)
{
        TCHAR ch;
        for (; (ch = *rpch) == TEXT(' ') || ch == TEXT('\t'); rpch++)
                ;
        return ch;
}

//_____________________________________________________________________________________________________
//
// SkipValue
//
//       Skips over the value of a switch and returns true if a value was present. Handles value enclosed
//       in quotation marks
//_____________________________________________________________________________________________________

bool SkipValue(TCHAR*& rpch)
{
        TCHAR ch = *rpch;
        if (ch == 0 || ch == TEXT('/') || ch == TEXT('-'))
                return false;   // no value present
        for (int i = 0; (ch = *rpch) != TEXT(' ') && ch != TEXT('\t') && ch != 0; rpch++, i++)
        {
                if (0 == i && *rpch == TEXT('"'))
                {
                        rpch++; // for '"'
                        for (; (ch = *rpch) != TEXT('"') && ch != 0; rpch++)
                                ;
                        ch = *(++rpch);
                        break;
                }
        }
        if (ch != 0)
                *rpch++ = 0;
        return true;
}

//_____________________________________________________________________________________________________
//
// RemoveQuotes
//
//  Removes enclosing quotation marks for the value. Assumes lpStripped is sufficiently sized.  Returns
//  if no enclosing quotation mark at front of string.
//_____________________________________________________________________________________________________

void RemoveQuotes(LPCTSTR lpOriginal, LPTSTR lpStripped)
{
        bool fEnclosedInQuotes = false;

        const TCHAR *pchOrig = lpOriginal;

        // check for "
        if (*pchOrig == TEXT('"'))
        {
                fEnclosedInQuotes = true;
                pchOrig++;
        }
        
        lstrcpy(lpStripped, pchOrig);

        if (!fEnclosedInQuotes)
                return;

        TCHAR *pch = lpStripped + lstrlen(lpStripped) + 1; // start at NULL

        pch = CharPrev(lpStripped, pch);

        // look for trailing "
        while (pch != lpStripped)
        {
                if (*pch == TEXT('"'))
                {
                        *pch = 0;
                        break; // only care about trailing ", and not quotes in middle
                }
                pch = CharPrev(lpStripped, pch);
        }
}

//_____________________________________________________________________________________________________
//
// DisplayInstallResource
//_____________________________________________________________________________________________________

bool DisplayInstallResource(HMODULE hExeModule, LPCTSTR lpszType, LPCTSTR lpszName)
{
        HRSRC   hRsrc   = 0;
        HGLOBAL hGlobal = 0;
        WCHAR   *pch    = 0;

        if ((hRsrc = FindResource(hExeModule, lpszName, lpszType)) != 0
                && (hGlobal = LoadResource(hExeModule, hRsrc)) != 0
                && (pch = (WCHAR*)LockResource(hGlobal)) != 0)
        {
                // resource exists
                g_cResources++;

                if (!pch)
                        _tprintf(TEXT("%s = NULL\n"), lpszName);
                else
                {
                #ifdef UNICODE
                        _tprintf(TEXT("%s = %s\n"), lpszName, pch);
                #else // !UNICODE
                        unsigned int cch = WideCharToMultiByte(CP_ACP, 0, pch, -1, NULL, 0, NULL, NULL);
                        char *szValue = new char[cch];
                        if (!szValue)
                        {
                                _tprintf(TEXT("Error -- out of memory\n"));
                                return false;
                        }

                        WideCharToMultiByte(CP_ACP, 0, pch, -1, szValue, cch, NULL, NULL);

                        _tprintf(TEXT("%s = %s\n"), lpszName, szValue);
                #endif // UNICODE
                }
        }

        // assert (?) -- resource does not exist (but we're enumerating!)

        return true;
}

//_____________________________________________________________________________________________________
//
// EnumResNamesProc
//_____________________________________________________________________________________________________

BOOL CALLBACK EnumResNamesProc(HMODULE hExeModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR /*lParam*/)
{
        if (!DisplayInstallResource(hExeModule, lpszType, lpszName))
                return FALSE;
        return TRUE;
}

//_____________________________________________________________________________________________________
//
// DisplayResources
//_____________________________________________________________________________________________________

bool DisplayResources(LPCTSTR szExecutable)
{
        // handle possibility of a relative path
        TCHAR szFullPath[2*MAX_PATH] = {0};
        LPTSTR lpszFilePart = 0;
        if (0 == GetFullPathName(szExecutable, sizeof(szFullPath)/sizeof(TCHAR), szFullPath, &lpszFilePart))
        {
                // error
                _tprintf(TEXT("Unable to obtain full file path for %s.  LastError = %d\n"), szExecutable, GetLastError());
                return false;
        }

        _tprintf(TEXT("\n<%s>\n\n"), szFullPath);

        HMODULE hExeModule = LoadLibraryEx(szFullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (NULL == hExeModule)
        {
                // error
                _tprintf(TEXT("Unable to load %s.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }

        // only enumerate on RT_INSTALL_PROPERTY type
        if (!EnumResourceNames(hExeModule, RT_INSTALL_PROPERTY, EnumResNamesProc, (LPARAM)0))
        {
                DWORD dwLastErr = GetLastError();
                if (ERROR_RESOURCE_TYPE_NOT_FOUND == dwLastErr)
                        _tprintf(TEXT("No RT_INSTALL_PROPERTY resources were found.\n"));
                else if (ERROR_RESOURCE_DATA_NOT_FOUND == dwLastErr)
                        _tprintf(TEXT("This file does not have a resource section.\n"));
                else
                {
                        // error
                        _tprintf(TEXT("Failed to enumerate all resources in %s.  LastError = %d\n"), szFullPath, GetLastError());
                        FreeLibrary(hExeModule);
                        return false;
                }
        }

        if (g_cResources)
        {
                if (1 == g_cResources)
                        _tprintf(TEXT("\n\n 1 RT_INSTALL_PROPERTY resource was found.\n"));
                else
                        _tprintf(TEXT("\n\n %d RT_INSTALL_PROPERTY resources were found.\n"), g_cResources);
        }

        if (!FreeLibrary(hExeModule))
        {
                // error
                _tprintf(TEXT("Failed to unload %s.  LastError = %d\n"), szFullPath, GetLastError());
                return false;
        }

        return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msival2\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msival\sources.inc ===
TARGETNAME=msival
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1
USE_NATIVE_EH=1

INCLUDES=$(INCLUDES);$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msival.cpp \
	..\msival.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msival\msival.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       msival.h
//
//--------------------------------------------------------------------------

#include <windows.h>

#define IDS_NoError            0
#define IDS_DuplicateKey       1
#define IDS_Required           2
#define IDS_BadLink            3
#define IDS_Overflow           4
#define IDS_Underflow          5
#define IDS_NotInSet           6
#define IDS_BadVersion         7
#define IDS_BadCase            8
#define IDS_BadGuid            9
#define IDS_BadWildCard        10
#define IDS_BadIdentifier      11
#define IDS_BadLanguage        12
#define IDS_BadFileName        13
#define IDS_BadPath            14
#define IDS_BadCondition       15
#define IDS_BadFormatted       16
#define IDS_BadTemplate        17
#define IDS_BadDefaultDir      18
#define IDS_BadRegPath         19
#define IDS_BadCustomSource    20 
#define IDS_BadProperty        21
#define IDS_MissingData        22
#define IDS_BadCabinet         23
#define IDS_BadCategory        24
#define IDS_BadKeyTable        25
#define IDS_BadMaxMinValues    26
#define IDS_BadShortcut        27
#define IDS_StringOverflow     28
#define IDS_UndefinedError     29
#define IDS_MissingEntry       30
#define IDS_BadLocalizeAttrib  31
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msival\msival.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       msival.cpp
//
//--------------------------------------------------------------------------

// Required headers
#include "msival.h"
#include <stdio.h>   // printf/wprintf
#include <stdlib.h>  // atoi
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h"

//!! Need to fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

TCHAR*  g_szErrorContext = 0; // Global error string
HANDLE g_hStdOut = 0; // Global handle

// Function prototypes
void Display(LPCTSTR szMessage);
void CheckMsi(UINT iStat, TCHAR* szContext);
void CheckMsiRecord(UINT iStat, TCHAR* szContext);
BOOL CheckMissingColumns(MSIHANDLE hDatabase);
BOOL Validate(MSIHANDLE hDatabase);
BOOL ValidateRequired(MSIHANDLE hDatabase);
BOOL ValidateInstallSequence(MSIHANDLE hDatabase, const TCHAR* szSQLInstallSeqTable);

// SQL queries
const TCHAR szSQLTableCatalog[]         = TEXT("SELECT `Name` FROM `_Tables`");
const TCHAR szSQLTable[]                = TEXT("SELECT * FROM ");
const TCHAR szSQLColMissing[]           = TEXT("SELECT `Table`, `Number`, `Name`, `Type` FROM `_Columns` WHERE `Table`=? AND `Name`=?");
const TCHAR szSQLValidationTable[]      = TEXT("SELECT `Table`, `Column` FROM `_Validation`, `_Tables` WHERE `_Validation`.`Table` = `_Tables`.`Name`");

struct
{
	const TCHAR* Name;
	const TCHAR* SQL;
} pSeqTables[] =

{
	TEXT("AdminExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `AdvtExecuteSequence` ORDER BY `Sequence`"),
	TEXT("AdminUISequence"), TEXT("SELECT `Action`, `Sequence` FROM `AdminUISequence` ORDER BY `Sequence`"),
	TEXT("AdvtExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `AdvtExecuteSequence` ORDER BY `Sequence`"),
	TEXT("AdvtUISequence"), TEXT("SELECT `Action`, `Sequence` FROM `AdvtUISequence` ORDER BY `Sequence`"),
	TEXT("InstallExecuteSequence"), TEXT("SELECT `Action`, `Sequence` FROM `InstallExecuteSequence` ORDER BY `Sequence`"),
	TEXT("InstallUISequence"), TEXT("SELECT `Action`, `Sequence` FROM `InstallUISequence` ORDER BY `Sequence`")
};


const TCHAR szSQLInstallValidate[]      = TEXT("SELECT `Action`, `SectionFlag` FROM `_InstallValidate` WHERE `Action`=?");
const TCHAR szSQLRequiredTable[]        = TEXT("SELECT `Table`, `Value`, `KeyCount` FROM `_Required` ORDER BY `Table`");
const TCHAR szSQLSeqTableQueryNotNull[] = TEXT("SELECT `Dependent` FROM `_Sequence` WHERE `Action`=? AND `Marker`<>0  AND `After`=0");
const TCHAR szSQLSeqTableQueryNull[]    = TEXT("SELECT `Dependent` FROM `_Sequence` WHERE `Action`=? AND `Marker`=0 AND `After`=1 AND `Optional`=0"); 
const TCHAR szSQLSeqTableAddCol[]       = TEXT("ALTER TABLE `_Sequence` ADD `Marker` SHORT TEMPORARY");
const TCHAR szSQLSeqMarkerInit[]        = TEXT("UPDATE `_Sequence` SET `Marker`=0");

const TCHAR sqlSeqInsert[]           = TEXT("SELECT `Action`, `Dependent`, `After`, `Optional` FROM `_Sequence`");
const TCHAR sqlSeqFindAfterOptional[]= TEXT("SELECT `Dependent`, `Action`, `After`, `Optional` FROM `_Sequence` WHERE `After`=1 AND `Optional`=1");

const int iMaxNumColumns = 32;
const int cchBuffer = 4096;
const int cbName = 64;

const int cchDisplayBuf = 4096;

//_______________________________________________________________________________________________________________
//
// _tmain -- UNICODE/ANSI main function
// 
// Driver routine
//_______________________________________________________________________________________________________________

extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// Determine handle
	g_hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (g_hStdOut == INVALID_HANDLE_VALUE)
		g_hStdOut = 0;  // non-zero if stdout redirected or piped

	// Bool to allow user to specify option to turn OFF InstallSequence and Required Validation
	// So that databases won't fail if don't have the _InstallValidate and/or _Required tables
	// fSeq means to validate sequencing only.   Basically, the opposite of -OFF.
	BOOL fOff = FALSE;
	BOOL fSeq = FALSE;
	BOOL fSeqAll = FALSE;

	if (2 > argc)
	{
		_tprintf(TEXT("USAGE:\n msival.exe {database}\n msival.exe {database} -OFF"));
		return 1;
	}
	
	if (argc == 2 && (lstrcmp(argv[1],TEXT("-?")) == 0 || lstrcmp(argv[1],TEXT("/?")) == 0))
	{
		_tprintf(TEXT("USAGE:\n msival.exe {database}\n msival.exe {database} -OFF\nNOTE:\n For validation to proceed. . .\n\tTables required:\n\t _Validation (always)\n\t _InstallValidate (unless -OFF)\n\t _Required (unless -OFF)\n\t _Sequence (unless -OFF)\n"));
		return 0;
	}

	if (argc == 3)
	{
		if (lstrcmp(argv[2],TEXT("-OFF")) == 0 || lstrcmp(argv[2],TEXT("/OFF")) == 0
			|| lstrcmp(argv[2],TEXT("-off")) == 0 || lstrcmp(argv[2],TEXT("/off")) == 0)
			fOff = TRUE;
		else if (lstrcmp(argv[2],TEXT("-SEQ")) == 0 || lstrcmp(argv[2],TEXT("/SEQ")) == 0
			|| lstrcmp(argv[2],TEXT("-seq")) == 0 || lstrcmp(argv[2],TEXT("/seq")) == 0)
			fSeq = TRUE;
		else if (lstrcmp(argv[2],TEXT("-SEQALL")) == 0 || lstrcmp(argv[2],TEXT("/SEQALL")) == 0
			|| lstrcmp(argv[2],TEXT("-seqall")) == 0 || lstrcmp(argv[2],TEXT("/seqall")) == 0)
		{
			fSeq = TRUE;
			fSeqAll = TRUE;
		}
		else
		{
			_tprintf(TEXT("USAGE:\n msival.exe {database} -OFF\n"));
			return 0;
		}
	}

	BOOL fDataValid = TRUE;
	BOOL fColValid  = TRUE;
	BOOL fSeqOrderValid = TRUE;
	BOOL fReqValid  = TRUE;
	try
	{
		PMSIHANDLE hDatabase;
		CheckMsiRecord(MsiOpenDatabase(argv[1],MSIDBOPEN_READONLY,&hDatabase),TEXT("OpenDatabase"));


		if (fSeq)
			_tprintf(TEXT("WARNING!  Skipping validation for missing columns, data and foriegn keys.  Database may not be completely valid\n"));
		else
		{
			_tprintf(TEXT("INFO: Validating for missing columns. . .\n"));
			fColValid = CheckMissingColumns(hDatabase);
			_tprintf(TEXT("INFO: Validating data and foreign keys. . .\n"));
			fDataValid = Validate(hDatabase);
		}

		if (fOff)
		{
			// Print out warning of database not exactly valid since skipping these validations
			_tprintf(TEXT("WARNING! Skipping InstallSequence and Required Validation. Database may not be completely valid\n"));
		}
		else
		{
			if (MsiDatabaseIsTablePersistent(hDatabase, TEXT("_Sequence")) == MSICONDITION_NONE)
			{
				_tprintf(TEXT("No _Sequence table in this database.  Use ICEMAN/msival2/orca for this validation\n"));
				fSeqOrderValid = TRUE; // no validation to occur
			}
			else
			{
				const int cTables = sizeof(pSeqTables) / (2*sizeof(TCHAR*));
				_tprintf(TEXT("INFO: Validating Sequence of Actions In *Sequence Table. . .\n"));
				for (int cCounter = 0; cCounter < cTables; cCounter++)
				{
					if(MsiDatabaseIsTablePersistent(hDatabase,pSeqTables[cCounter].Name) == MSICONDITION_NONE)
					{
						_tprintf(TEXT("\tINFO: %s not found, skipping. . .\n"), pSeqTables[cCounter].Name);
						continue;
					}

					_tprintf(TEXT("\tINFO: %s\n"), pSeqTables[cCounter].Name);
					fSeqOrderValid = ValidateInstallSequence(hDatabase, pSeqTables[cCounter].SQL);
					if (!fSeqOrderValid)
						if (!fSeqAll)
							break;
				}
			}

			if (fSeq)
				_tprintf(TEXT("WARNING!  Skipping validation for required values.  Database may not be completely valid\n"));
			else
			{
				_tprintf(TEXT("INFO: Validating Required Values. . .\n"));
				fReqValid = ValidateRequired(hDatabase);
			}

		}
		if (fDataValid && fColValid && fReqValid && fSeqOrderValid)
			_tprintf(TEXT("Database is valid: %s\n"), argv[1]);
	}
	catch (UINT iError)
	{
		_tprintf(TEXT("\n%s error %i"), g_szErrorContext, iError);
		MsiCloseAllHandles();
		return 1;
	}
	catch (...)
	{
		_tprintf(TEXT("\n%s"), TEXT("Unhandled exception"));
		MsiCloseAllHandles();
		return 99;
	}
	int iOpenHandles = MsiCloseAllHandles();  // diagnostic check only
	if (iOpenHandles != 0)
		_tprintf(TEXT("\n%i Handle(s) not closed"), iOpenHandles);
	return (fDataValid && fColValid && fReqValid && fSeqOrderValid) ? 0 : 1;
}


void CheckMsi(UINT iStat, TCHAR* szContext)
/*----------------------------------------------------------------------------------
CheckMsi -- Routine to check return status for error and throw exception if error.
  Arguments:
	iStat -- error status
	szContext -- error string
  Returns:
	none, but throws error if one
-------------------------------------------------------------------------------------*/
{
	if (iStat != ERROR_SUCCESS)
	{
		g_szErrorContext = szContext;
		throw iStat;
	}
}

void CheckMsiRecord(UINT iStat, TCHAR* szContext)
/*----------------------------------------------------------------------------------
CheckMsi -- Routine to check return status for error and throw exception if error.
            If MsiGetLastErrorRecord returns record, that string is used instead.
  Arguments:
	iStat -- error status
	szContext -- error string
  Returns:
	none, but throws error if one
-------------------------------------------------------------------------------------*/
{
	if (iStat != ERROR_SUCCESS)
	{
		PMSIHANDLE hError = MsiGetLastErrorRecord();
		if (hError)
		{ 
			if (MsiRecordIsNull(hError, 0))
				MsiRecordSetString(hError, 0, TEXT("Error [1]: [2]{, [3]}{, [4]}{, [5]}"));
			TCHAR rgchBuf[1024];
			DWORD cchBuf = sizeof(rgchBuf)/sizeof(TCHAR);
			MsiFormatRecord(0, hError, rgchBuf, &cchBuf);
			g_szErrorContext = rgchBuf;
			throw iStat;
		}
		else
		{
			CheckMsi(iStat, szContext);
		}
	}
}


BOOL CheckMissingColumns(MSIHANDLE hDatabase)
/*---------------------------------------------------------------------
CheckMissingColumns -- used _Validation table and _Columns catalog to
 determine if any columns/tables are not listed.  All columns in
 _Validation table must be listed in the _Columns catalog.  If a column
 is optional and not used in the database, then it should not be found
 in the _Validation table or the _Columns catalog.  Normal validation
 catches the instance where a column is defined in the _Columns catalog
 but not in the _Validation table.
---------------------------------------------------------------------*/
{
	PMSIHANDLE hValidationView   = 0;
	PMSIHANDLE hColCatalogView   = 0;
	PMSIHANDLE hValidationRecord = 0;
	PMSIHANDLE hColCatalogRecord = 0;
	PMSIHANDLE hExecRecord       = 0;
	
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLColMissing, &hColCatalogView), TEXT("OpenColumnCatalogView"));
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLValidationTable, &hValidationView), TEXT("OpenValidationTableView"));

	UINT iRet = 0;
	TCHAR szTable[cbName] = {0};
	TCHAR szColumn[cbName] = {0};
	unsigned long cchTableBuf = sizeof(szTable)/sizeof(TCHAR);
	unsigned long cchColumnBuf = sizeof(szColumn)/sizeof(TCHAR);
	BOOL fStat = TRUE;

	hExecRecord = MsiCreateRecord(2);
	CheckMsiRecord(MsiViewExecute(hValidationView, 0), TEXT("ExecuteValidationView"));
	for (;;)
	{
		iRet = MsiViewFetch(hValidationView, &hValidationRecord);
		if (iRet == ERROR_NO_MORE_ITEMS || !hValidationRecord)
			break;
		CheckMsiRecord(iRet, TEXT("ColumnCatalogFetch"));
		CheckMsi(MsiRecordGetString(hValidationRecord, 1, szTable, &cchTableBuf), TEXT("GetTableName"));
		cchTableBuf = sizeof(szTable)/sizeof(TCHAR);
		CheckMsi(MsiRecordGetString(hValidationRecord, 2, szColumn, &cchColumnBuf), TEXT("GetColumnName"));
		cchColumnBuf = sizeof(szColumn)/sizeof(TCHAR);
		CheckMsi(MsiRecordSetString(hExecRecord, 1, szTable), TEXT("SetTableName"));
		CheckMsi(MsiRecordSetString(hExecRecord, 2, szColumn), TEXT("SetColumnName"));
		CheckMsi(MsiViewExecute(hColCatalogView, hExecRecord), TEXT("ExecuteColumnCatalogView"));
		iRet = MsiViewFetch(hColCatalogView, &hColCatalogRecord);
		if (iRet == ERROR_NO_MORE_ITEMS || !hColCatalogRecord)
		{
			// Error --> Missing from database
			TCHAR szMsgBuf[150];
			const TCHAR* szMessage = (TCHAR*)IDS_MissingEntry;
			const TCHAR** pszMsg;
			pszMsg = &szMessage;
			::LoadString(0, *(unsigned*)pszMsg, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR));
			*pszMsg = szMsgBuf;
			_tprintf(TEXT("Table.Column: %s.%s Message: %s\n"), szTable, szColumn, szMsgBuf);
			fStat = FALSE;
		}
		CheckMsi(MsiViewClose(hColCatalogView), TEXT("CloseView"));
	}
	MsiViewClose(hValidationView);
	
	return fStat;
}


BOOL ValidateRequired(MSIHANDLE hDatabase)
/*-----------------------------------------------------------------------------------
ValidateRequired -- Uses the _Required table and checks the tables listed for the
'required' values that are listed in the table.

-------------------------------------------------------------------------------------*/
{
	PMSIHANDLE hviewRequiredTable = 0;
	PMSIHANDLE hviewTable         = 0;
	PMSIHANDLE hrecTableExecute   = 0;
	PMSIHANDLE hrecRequiredFetch  = 0;
	PMSIHANDLE hrecTableFetch     = 0;
	PMSIHANDLE hrecColInfo        = 0;

	BOOL fValid = TRUE;
	BOOL fFirstRun = TRUE;
	UINT iStat = ERROR_SUCCESS;

	TCHAR szPrevTable[100] = {0};
	TCHAR szTable[100] = {0};
	TCHAR szValue[256] = {0};
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLRequiredTable, &hviewRequiredTable), TEXT("OpenViewRequiredTable"));
	CheckMsiRecord(MsiViewExecute(hviewRequiredTable, 0), TEXT("RequiredTableViewExecute"));
	while ((iStat = MsiViewFetch(hviewRequiredTable, &hrecRequiredFetch)) != ERROR_NO_MORE_ITEMS)
	{
		CheckMsi(iStat, TEXT("RequiredTableViewFetch"));
		if (!hrecRequiredFetch)
			break;
		int cPrimaryKeys = MsiRecordGetInteger(hrecRequiredFetch, 3);
		DWORD cbTable = sizeof(szTable)/sizeof(TCHAR);
		DWORD cbValue = sizeof(szValue)/sizeof(TCHAR);
		CheckMsi(MsiRecordGetString(hrecRequiredFetch, 1, szTable, &cbTable), TEXT("RequiredTableRecordGetString"));
		CheckMsi(MsiRecordGetString(hrecRequiredFetch, 2, szValue, &cbValue), TEXT("RequiredTableRecordGetString"));
		if (fFirstRun)
			fFirstRun = FALSE;
		else
			CheckMsi(MsiViewClose(hviewTable), TEXT("TableViewClose"));
		hrecTableExecute = MsiCreateRecord(cPrimaryKeys);
		if (hrecTableExecute == 0)
			return FALSE;

		if (lstrcmp(szPrevTable, szTable) != 0)
		{
			// New table, need to open a new view.
			TCHAR szSQL[1024] = {0};
			PMSIHANDLE hrecPrimaryKeys = 0;
			TCHAR szKeyColName[50] = {0};
			DWORD cbKey = sizeof(szKeyColName)/sizeof(TCHAR);
			CheckMsi(MsiDatabaseGetPrimaryKeys(hDatabase, szTable, &hrecPrimaryKeys), TEXT("DatabaseGetPrimaryKeys"));
			CheckMsi(MsiRecordGetString(hrecPrimaryKeys, 1, szKeyColName, &cbKey), TEXT("PrimaryKeysRecordGetString"));
			CheckMsi(MsiRecordGetFieldCount(hrecPrimaryKeys) != cPrimaryKeys, TEXT("PrimaryKeyCountWrong"));
			CheckMsi(cPrimaryKeys == ERROR_INVALID_HANDLE, TEXT("PrimaryKeysRecordGetFieldCount"));
			
			// Develop query of table to be checked
			int cchWritten = _stprintf(szSQL, TEXT("SELECT * FROM `%s` WHERE `%s`=?"), szTable, szKeyColName);
			int cchAddition = cchWritten;
			for (int i = 2; i <= cPrimaryKeys; i++)
			{
				cbKey = sizeof(szKeyColName)/sizeof(TCHAR);
				CheckMsi(MsiRecordGetString(hrecPrimaryKeys, i, szKeyColName, &cbKey), TEXT("PrimaryKeysRecordGetString"));
				cchWritten = _stprintf(szSQL + cchAddition, TEXT(" AND `%s`=?"), szKeyColName);
				cchAddition = cchWritten;
			}
			CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQL, &hviewTable), TEXT("DatabaseOpenView"));
			CheckMsi(MsiViewGetColumnInfo(hviewTable, MSICOLINFO_TYPES, &hrecColInfo), TEXT("GetColumnInfo"));
			lstrcpy(szPrevTable, szTable);
		}

		// Fill in execute record with the key data values
		TCHAR* pch = szValue;
		TCHAR szKeyValue[256] = {0};
		TCHAR szType[32] = {0};
		DWORD cbType = sizeof(szType)/sizeof(TCHAR);
		int nDex = 0;
		for (int j = 1; j <= cPrimaryKeys; j++)
		{
			while (pch != 0 && *pch != TEXT(';') &&  *pch != 0)
				szKeyValue[nDex++] = *pch++;
			szKeyValue[nDex] = 0;
			pch++; // for ; or 0
			cbType = sizeof(szType)/sizeof(TCHAR);
			CheckMsi(MsiRecordGetString(hrecColInfo, j, szType, &cbType), TEXT("ColInfoGetString"));
			if (szType != 0 && *szType == TEXT('s'))
				CheckMsi(MsiRecordSetString(hrecTableExecute, j, szKeyValue), TEXT("TableExecuteRecordSetString"));
			else // integer primary key
				CheckMsi(MsiRecordSetInteger(hrecTableExecute, j, _ttoi(szKeyValue)), TEXT("TableExecuteRecordSetInteger"));
			nDex = 0;
		}

		// Execute view and attempt to fetch listed item from table
		CheckMsiRecord(MsiViewExecute(hviewTable, hrecTableExecute), TEXT("TableViewExecute"));
		iStat = MsiViewFetch(hviewTable, &hrecTableFetch);
		if (iStat == ERROR_NO_MORE_ITEMS)
		{
			// Value not found
			TCHAR szError[cchBuffer] = {0};
			_stprintf(szError, TEXT("ERROR: Value: '%s' Is Required In Table: '%s'\n"), szValue, szTable);
			Display(szError);
			fValid = FALSE;
		}
		else if (iStat != ERROR_SUCCESS)
			CheckMsi(iStat, TEXT("TableViewFetch"));
	}

	return fValid;

}


BOOL ValidateInstallSequence(MSIHANDLE hDatabase, const TCHAR* szSQLInstallSeqTable)
/*----------------------------------------------------------------------------
ValidateInstallSequence -- validates the order of the actions in the
InstallSequence table to ensure that they are allowed by the _Sequence table.
The _Sequence table is required for this validation.
------------------------------------------------------------------------------*/
{
	BOOL fValid = TRUE;
	UINT iStat1 = ERROR_SUCCESS;
	UINT iStat2 = ERROR_SUCCESS;
	
	PMSIHANDLE hviewInstallTable    = 0;
	PMSIHANDLE hviewSeqQueryNull    = 0;
	PMSIHANDLE hviewSeqQueryNotNull = 0;
	PMSIHANDLE hviewSeqUpdate       = 0;
	PMSIHANDLE hviewSeqAddColumn    = 0;
	PMSIHANDLE hviewSeqMarkerInit   = 0;
	PMSIHANDLE hrecSeqUpdateExecute = 0;
	PMSIHANDLE hrecQueryExecute     = 0;
	PMSIHANDLE hrecInstallFetch     = 0;
	PMSIHANDLE hrecQueryNullFetch   = 0;
	PMSIHANDLE hrecQueryNotNullFetch= 0;

	// Set up the _Sequence table with the insert temporary of actions where After=1 and Optional=1
	// This is so that we can catch errors.  WE need to insert w/ Action=Dependent, Dependent=Action, After=0, and Optional=1
	PMSIHANDLE hViewSeqInsert = 0;
	PMSIHANDLE hViewSeqFind   = 0;
	PMSIHANDLE hRecSeqFind    = 0;
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, sqlSeqFindAfterOptional, &hViewSeqFind), TEXT("Find AfterOptional entries"));
	CheckMsiRecord(MsiViewExecute(hViewSeqFind, 0), TEXT("Execute AfterOptional entries"));
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, sqlSeqInsert, &hViewSeqInsert), TEXT("Insert query for AfterOptional"));
	CheckMsiRecord(MsiViewExecute(hViewSeqInsert, 0), TEXT("Execute insert query for AfterOptional"));

	// fetch all of those actions
	while (ERROR_SUCCESS == (iStat1 = MsiViewFetch(hViewSeqFind, &hRecSeqFind)))
	{
		CheckMsi(iStat1, TEXT("AfterOptional Find Fetch"));

		// set After from 1 to 0, leave optional as is
		::MsiRecordSetInteger(hRecSeqFind, 3, 0);

		// insert temporary (possible read only db)
		if (ERROR_SUCCESS != (iStat1 = ::MsiViewModify(hViewSeqInsert, MSIMODIFY_INSERT_TEMPORARY, hRecSeqFind)))
		{
			// if ERROR_FUNCTION_FAILED, we're okay....author already took care of this for us
			if (ERROR_FUNCTION_FAILED != iStat1)
				CheckMsi(iStat1, TEXT("MsiViewModify after-optional"));
		}
	}
	::MsiViewClose(hViewSeqFind);
	::MsiViewClose(hViewSeqInsert);

	// Create the temporary marking column for the _Sequence table (this will store the sequence #s of the Dependent Actions)
	if (ERROR_SUCCESS == (iStat1 = MsiDatabaseOpenView(hDatabase, szSQLSeqTableAddCol, &hviewSeqAddColumn)))
	{
		CheckMsiRecord(MsiViewExecute(hviewSeqAddColumn, 0), TEXT("_SequenceTableAddColExecute"));
		CheckMsi(MsiViewClose(hviewSeqAddColumn), TEXT("_SequenceTableAddColClose"));
	}
	else if (iStat1 != ERROR_BAD_QUERY_SYNTAX) // Marking column already in memory
		CheckMsiRecord(iStat1, TEXT("Add column view"));
	
	// Initialize the temporary marking column to zero
	// NO INSTALL SEQUENCE ACTIONS CAN HAVE A ZERO SEQUENCE # AS ZERO IS CONSIDERED "NULL"
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLSeqMarkerInit, &hviewSeqMarkerInit), TEXT("_SequenceTableMarkerInitOpenView"));
	CheckMsiRecord(MsiViewExecute(hviewSeqMarkerInit, 0), TEXT("_SequenceTableMarkerInitExecute"));
	CheckMsi(MsiViewClose(hviewSeqMarkerInit), TEXT("_SequenceTableMarkerInitClose"));

	// Open view on InstallSequence table and order by the Sequence #
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLInstallSeqTable, &hviewInstallTable), TEXT("InstallSequenceTableOpenView"));
	CheckMsiRecord(MsiViewExecute(hviewInstallTable, 0), TEXT("InstallSequenceTableExecute"));

	// Open the two query views on _Sequence table for determining the validity of the actions
	// Create execution record
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLSeqTableQueryNull, &hviewSeqQueryNull), TEXT("SequenceTableQueryNullOpenView"));
	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLSeqTableQueryNotNull, &hviewSeqQueryNotNull), TEXT("_SequenceTableQueryNotNullOpenView"));
	hrecQueryExecute = MsiCreateRecord(1); // for action
	CheckMsi(hrecQueryExecute == 0, TEXT("QueryExecuteCreateRecord"));
	hrecSeqUpdateExecute = MsiCreateRecord(1); // for action
	CheckMsi(hrecSeqUpdateExecute == 0, TEXT("UpdateExecuteCreateRecord"));

	// Start fetching actions from the InstallSequence table
	TCHAR szSQLUpdateQuery[4096] = {0};
	TCHAR szAction[100] = {0};
	int iSequence = 0;
	for (;;)
	{
		iStat1 = MsiViewFetch(hviewInstallTable, &hrecInstallFetch);
		if (iStat1 == ERROR_NO_MORE_ITEMS || !hrecInstallFetch)
			break;
		CheckMsi(iStat1, TEXT("InstallTableFetch"));
		DWORD cbSize = sizeof(szAction)/sizeof(TCHAR);
		
		// Obtain name of action and Sequence # of action in InstallSequence table
		CheckMsi(MsiRecordGetString(hrecInstallFetch, 1, szAction, &cbSize), TEXT("InstallFetchRecordGetString"));
		iSequence = MsiRecordGetInteger(hrecInstallFetch, 2);
		CheckMsi(iSequence == MSI_NULL_INTEGER, TEXT("InstallFetchRecordGetInteger"));

		// Prepare execution records
		CheckMsi(MsiRecordSetString(hrecQueryExecute, 1, szAction), TEXT("_SequenceQueryExecuteRecordSetString"));
		CheckMsi(MsiRecordSetString(hrecSeqUpdateExecute, 1, szAction), TEXT("_SequenceUpdateExecuteRecordSetString"));
		
		// Execute _Sequence query table views
		CheckMsiRecord(MsiViewExecute(hviewSeqQueryNull, hrecQueryExecute), TEXT("_SequenceQueryNullExecute"));
		CheckMsiRecord(MsiViewExecute(hviewSeqQueryNotNull, hrecQueryExecute), TEXT("_SequenceQueryNotNullExecute"));

		// Fetch from _Sequence table.  If resultant set, then ERROR
		// Following are the possibilities and whether permitted:
		//   Action After Dependent Where Dependent Is Required And Temp Sequence Column Is Zero --> ERROR
		//   Action After Dependent Where Dependent Is Required And Temp Sequence Column Is Greater Than Zero --> CORRECT
		//   Action After Dependent Where Dependent Is Optional And Temp Sequence Column Is Zero --> CORRECT
		//   Action After Dependent Where Dependent Is Optional And Temp Sequence Column Is Greater Than Zero --> CORRECT
		//   Action Before Dependent Where Dependent Is Optional Or Required And Temp Sequence Column Is Zero --> CORRECT
		//   Action Before Dependent Where Dependent Is Optional Or Requred And Temp Sequence Column Is Greater Than Zero --> ERROR

		// ** Only issue is when Action Is After Optional Dependent And Temp Sequence Column Is Zero because we
		// ** have no way of knowing whether the action will be later (in which case it would be invalid.  This is
		// ** ensured to be successful though by proper authoring of the _Sequence table.  If an Action comes after
		// ** the Optional Dependent Action, then the _Sequence table must also be authored with the Dependent Action
		// ** listed as coming before that Action (so if we come later, and find a result set, we flag this case).

		// If return is not equal to ERROR_NO_MORE_ITEMS, then ERROR and Output Action
		while (ERROR_NO_MORE_ITEMS != MsiViewFetch(hviewSeqQueryNull, &hrecQueryNullFetch))
		{
			TCHAR szError[1024] = {0};
			TCHAR szDependent[100] = {0};
			DWORD cch = sizeof(szDependent)/sizeof(TCHAR);
			CheckMsi(MsiRecordGetString(hrecQueryNullFetch, 1, szDependent, &cch), TEXT("MsiRecordGetString"));
			_stprintf(szError, TEXT("ERROR: %s Action Is Sequenced Incorrectly (Dependent=%s)\n"), szAction, szDependent);
			Display(szError);
			cch = sizeof(szDependent)/sizeof(TCHAR); // reset
			fValid = FALSE;
		}

		while (ERROR_NO_MORE_ITEMS != MsiViewFetch(hviewSeqQueryNotNull, &hrecQueryNotNullFetch))
		{
			TCHAR szError[1024] = {0};
			TCHAR szDependent[100] = {0};
			DWORD cch = sizeof(szDependent)/sizeof(TCHAR);
			CheckMsi(MsiRecordGetString(hrecQueryNotNullFetch, 1, szDependent, &cch), TEXT("MsiRecordGetString"));
			_stprintf(szError, TEXT("ERROR: %s Action Is Sequenced Incorrectly (Dependent=%s)\n"), szAction, szDependent);
			Display(szError);
			cch = sizeof(szDependent)/sizeof(TCHAR); // reset
			fValid = FALSE;
		}

		// Update _Sequence table temporary Sequence column (that we created) with the install sequence number
		// The Sequence column stores the sequence number of the Dependent Actions, so we are updating every
		// row where the action in the Dependent column equals the current action.  In the query view, we only
		// check to insure that this column is zero or greater than zero (so we don't care too much about the value)
		// Build the query: UPDATE `_Sequence` SET `Marker`=iSequence WHERE `Dependent`=szAction
		_stprintf(szSQLUpdateQuery, TEXT("UPDATE `_Sequence` SET `Marker`=%d WHERE `Dependent`=?"), iSequence);
		CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLUpdateQuery, &hviewSeqUpdate), TEXT("_SequenceTableUpdateOpenView"));
		CheckMsiRecord(MsiViewExecute(hviewSeqUpdate, hrecSeqUpdateExecute), TEXT("_SequenceUpdateExectue"));

		// Close the _Sequence table views so we can re-execute
		CheckMsi(MsiViewClose(hviewSeqUpdate), TEXT("_SequenceUpdateViewClose"));
		CheckMsi(MsiViewClose(hviewSeqQueryNull), TEXT("_SequenceQueryNullViewClose"));
		CheckMsi(MsiViewClose(hviewSeqQueryNotNull), TEXT("_SequenceQueryNotNullViewClose"));
	}

	// Close the InstallSequence table view
	CheckMsi(MsiViewClose(hviewInstallTable), TEXT("InstallSequenceTableViewClose"));

	return fValid;
}


BOOL Validate(MSIHANDLE hDatabase)
/*-----------------------------------------------------------------------------------
Validate -- Routine to validate database.  Prints out invalid data if any.
  Arguments:
	hDatabase -- handle to database
	iValid -- integer for storing whether database is valid
  Returns:
	BOOL status -- TRUE (all valid), FALSE (invalid data found)
-------------------------------------------------------------------------------------*/
{
	// _Tables (Table Catalog)
	PMSIHANDLE hTableCatalogView;
	PMSIHANDLE hTableCatalogRecord;
	// Table To Validate
	PMSIHANDLE hValidationView;
	PMSIHANDLE hValidationRecord;
	// Record for Primary Keys
	PMSIHANDLE hKeyRecord;

	CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQLTableCatalog, &hTableCatalogView),TEXT("OpenTableCatalogView"));
	CheckMsiRecord(MsiViewExecute(hTableCatalogView, 0), TEXT("Execute Table Catalog View"));
	TCHAR szSQL[256];
	TCHAR szTableName[32];
	TCHAR szColumnData[255];
	TCHAR szColumnName[32];
	DWORD cchTableName = sizeof(szTableName)/sizeof(TCHAR);
	DWORD cchColumnName = sizeof(szColumnName)/sizeof(TCHAR);
	DWORD cchColumnData = sizeof(szColumnData)/sizeof(TCHAR);
	
	BOOL fDataValid = TRUE; // initially valid
	DWORD cchTableBuf = cchTableName;
	DWORD cchDataBuf = cchColumnData;
	DWORD cchBuf = cchColumnName;
	UINT uiRet = 0;			

	// process the tables.
	for (;;)
	{

		uiRet = MsiViewFetch(hTableCatalogView, &hTableCatalogRecord);
		if (uiRet == ERROR_NO_MORE_ITEMS)
			break;
		CheckMsi(uiRet, TEXT("Fetch Table Catalog Record"));
		if (!hTableCatalogRecord)
			break;
		cchTableBuf = cchTableName; // on return size of string written
		CheckMsi(MsiRecordGetString(hTableCatalogRecord, 1, szTableName, &cchTableBuf), TEXT("Get Table Name From Fetched Record"));
		MSICONDITION ice = MsiDatabaseIsTablePersistent(hDatabase, szTableName);
		if (ice == MSICONDITION_FALSE)
			continue;
		CheckMsi(ice != MSICONDITION_TRUE, TEXT("IsTablePersistent"));
		_stprintf(szSQL, TEXT("%s`%s`"), szSQLTable, szTableName);
		CheckMsiRecord(MsiDatabaseOpenView(hDatabase, szSQL, &hValidationView),TEXT("OpenView"));
		CheckMsiRecord(MsiViewExecute(hValidationView, 0), TEXT("Execute View"));

		BOOL fMissingValidation = FALSE;
		BOOL fSkipMissingValidation = FALSE;

		// process current table
		for (;;)
		{
			uiRet = MsiViewFetch(hValidationView, &hValidationRecord);
			if (uiRet == ERROR_NO_MORE_ITEMS)
				break;
			CheckMsi(uiRet, TEXT("Fetch record"));
			if (!hValidationRecord)
				break;
			if (MsiViewModify(hValidationView, MSIMODIFY_VALIDATE, hValidationRecord) != ERROR_SUCCESS)
			{
				fDataValid = FALSE;
				cchTableBuf = cchTableName;
				cchDataBuf = cchColumnData;
				cchBuf = cchColumnName;

				MSIDBERROR eReturn;
				if (fMissingValidation)
					fSkipMissingValidation = TRUE;

				// Display errors from current row
				while ((eReturn = MsiViewGetError(hValidationView, szColumnName, &cchBuf)) != MSIDBERROR_NOERROR)
				{
					if (eReturn == MSIDBERROR_FUNCTIONERROR || eReturn == MSIDBERROR_MOREDATA || eReturn == MSIDBERROR_INVALIDARG)
					{
						_tprintf(TEXT("\nFunction Error"));
					//	break;
					}
					
					int iResId;
					int iValue;
					switch (eReturn)
					{
					case MSIDBERROR_NOERROR:           iResId = IDS_NoError;          break;
					case MSIDBERROR_DUPLICATEKEY:      iResId = IDS_DuplicateKey;     break;
					case MSIDBERROR_REQUIRED:          iResId = IDS_Required;         break;
					case MSIDBERROR_BADLINK:           iResId = IDS_BadLink;          break;
					case MSIDBERROR_OVERFLOW:          iResId = IDS_Overflow;         break;
					case MSIDBERROR_UNDERFLOW:         iResId = IDS_Underflow;        break;
					case MSIDBERROR_NOTINSET:          iResId = IDS_NotInSet;         break;
					case MSIDBERROR_BADVERSION:        iResId = IDS_BadVersion;       break;
					case MSIDBERROR_BADCASE:           iResId = IDS_BadCase;          break;
					case MSIDBERROR_BADGUID:           iResId = IDS_BadGuid;          break;
					case MSIDBERROR_BADWILDCARD:       iResId = IDS_BadWildCard;      break;
					case MSIDBERROR_BADIDENTIFIER:     iResId = IDS_BadIdentifier;    break;
					case MSIDBERROR_BADLANGUAGE:       iResId = IDS_BadLanguage;      break;
					case MSIDBERROR_BADFILENAME:       iResId = IDS_BadFileName;      break;
					case MSIDBERROR_BADPATH:           iResId = IDS_BadPath;          break;
					case MSIDBERROR_BADCONDITION:      iResId = IDS_BadCondition;     break;
					case MSIDBERROR_BADFORMATTED:      iResId = IDS_BadFormatted;     break;
					case MSIDBERROR_BADTEMPLATE:       iResId = IDS_BadTemplate;      break;
					case MSIDBERROR_BADDEFAULTDIR:     iResId = IDS_BadDefaultDir;    break;
					case MSIDBERROR_BADREGPATH:        iResId = IDS_BadRegPath;       break;
					case MSIDBERROR_BADCUSTOMSOURCE:   iResId = IDS_BadCustomSource;  break;
					case MSIDBERROR_BADPROPERTY:       iResId = IDS_BadProperty;      break;
					case MSIDBERROR_MISSINGDATA:       iResId = IDS_MissingData;      
						fMissingValidation = TRUE;  
						break;
					case MSIDBERROR_BADCATEGORY:       iResId = IDS_BadCategory;      break;
					case MSIDBERROR_BADKEYTABLE:       iResId = IDS_BadKeyTable;      break;
					case MSIDBERROR_BADMAXMINVALUES:   iResId = IDS_BadMaxMinValues;  break;
					case MSIDBERROR_BADCABINET:        iResId = IDS_BadCabinet;       break;
					case MSIDBERROR_BADSHORTCUT:       iResId = IDS_BadShortcut;      break;
					case MSIDBERROR_STRINGOVERFLOW:    iResId = IDS_StringOverflow;   break;
					case MSIDBERROR_BADLOCALIZEATTRIB: iResId = IDS_BadLocalizeAttrib;break;
					default:                           iResId = IDS_UndefinedError;   break;
					};

					cchBuf = cchColumnName; // on return size of string written
					cchDataBuf = cchColumnData;

					if ((MSIDBERROR_MISSINGDATA == eReturn) && fSkipMissingValidation)
						continue;

					// Print table
					_tprintf(TEXT("\n Error: %s\t"), szTableName);
					
					// Get Row	
					CheckMsi(MsiDatabaseGetPrimaryKeys(hDatabase, szTableName, &hKeyRecord), TEXT("Get Primary Keys"));
					unsigned int iNumFields = MsiRecordGetFieldCount(hKeyRecord);
					if (MsiRecordGetString(hValidationRecord, 1, szColumnData, &cchDataBuf) != ERROR_SUCCESS)
					{
						iValue = MsiRecordGetInteger(hValidationRecord, 1);
						_tprintf(TEXT("%d"), iValue);
					}
					else
						_tprintf(TEXT("%s"), szColumnData);
					cchDataBuf = cchColumnData;
					for (int i = 2; i <= iNumFields; i++)
					{
						_tprintf(TEXT("."));
						cchDataBuf = cchColumnData;
						if (MsiRecordGetString(hValidationRecord, i, szColumnData, &cchDataBuf) != ERROR_SUCCESS)
						{
							iValue = MsiRecordGetInteger(hValidationRecord, 1);
							_tprintf(TEXT("%d"), iValue);
						}
						else
							_tprintf(TEXT("%s"), szColumnData);
					}
					// Print name of column and enum value
					TCHAR szMsgBuf[80];
					const TCHAR* szMessage = (TCHAR*)IntToPtr(iResId);
					const TCHAR** pszMsg;
					pszMsg = &szMessage;
					::LoadString(0, *(unsigned*)pszMsg, szMsgBuf, sizeof(szMsgBuf)/sizeof(TCHAR));
					*pszMsg = szMsgBuf;
					_tprintf(TEXT("\t%s\t%s\n"), szColumnName, szMsgBuf);

				}
				cchBuf = cchColumnName; // on return size of string written
			}
		}
		CheckMsi(MsiViewClose(hValidationView), TEXT("Close view"));
	}
	CheckMsi(MsiViewClose(hTableCatalogView), TEXT("Close Table Catalog View"));
	return fDataValid;
}

void Display(LPCTSTR szMessage)
{
	if (szMessage)
	{
		int cbOut = _tcsclen(szMessage);;
		if (g_hStdOut)
		{
#ifdef UNICODE
			char rgchTemp[cchDisplayBuf];
			if (GetFileType(g_hStdOut) == FILE_TYPE_CHAR)
			{
				WideCharToMultiByte(CP_ACP, 0, szMessage, cbOut, rgchTemp, sizeof(rgchTemp), 0, 0);
				szMessage = (LPCWSTR)rgchTemp;
			}
			else
				cbOut *= 2;   // write Unicode if not console device
#endif
			DWORD cbWritten;
			WriteFile(g_hStdOut, szMessage, cbOut, &cbWritten, 0);
		}
		else
			MessageBox(0, szMessage, GetCommandLine(), MB_OK);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msizap\sources.inc ===
TARGETNAME=MsiZap
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\shell32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(BUILD_DIR)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INC_DIR);$(RES_OBJDIR);$(ADMIN_INC_PATH)

SOURCES=..\msizap.cpp \
	..\msizap.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msival2\sources.inc ===
TARGETNAME=Msival2
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\msi.lib 

C_DEFINES=$(C_DEFINES) -D_EXE
USE_LIBCMT=1

INCLUDES=$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\msival2.cpp \
	..\msival2.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msival2\msival2.cpp ===
#if 0  // makefile definitions, to build: %vcbin%\nmake -fMsiVal2.cpp
DESCRIPTION = MSI Evaluation Tool - using ICEs
MODULENAME = msival2
SUBSYSTEM = console
FILEVERSION = MSI
LINKLIBS = OLE32.lib
!include "MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       msival2.cpp
//
//--------------------------------------------------------------------------

// Required headers
#include <windows.h>

#define IDS_UnknownTable      36

#ifndef RC_INVOKED    // start of source code

#ifndef W32	// if W32 not defined
#define W32
#endif	// W32 defined

#ifndef MSI	// if MSI not defined
#define MSI
#endif	// MSI defined

#include "msiquery.h"
#include <stdio.h>   // wprintf
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE

/////////////////////////////////////////////////////////////////////////////
// global strings
TCHAR g_szFormatter[] = _T("%-10s   %-7s   %s\r\n");
TCHAR g_szLatest[] = _T("http:\\\\dartools\\Iceman\\darice.cub"); 
BOOL  g_fInfo = TRUE;

/////////////////////////////////////////////////////////////////////////////
// COM
#include <objbase.h>
#include <initguid.h>
#include "iface.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ProductCode changes from one SDK to the Next; Component Code stays the same 
// Below must be changed when/if Component Code changes in the MSI!
// MsiVal2 has conditionalized components for main exe depending on platform
#define MAX_GUID 38
TCHAR   g_szMsiValWin9XComponentCode[MAX_GUID+1] = _T("{EAB27DFA-90C6-11D2-88AC-00A0C981B015}");
TCHAR   g_szMsiValWinNTComponentCode[MAX_GUID+1] = _T("{EAB27DFB-90C6-11D2-88AC-00A0C981B015}");

///////////////////////////////////////////////////////////
// CleanUp
// uninitializes COM and cleans up evaluator
//
void CleanUp(IEval* pIEval)
{
	if (pIEval)
		pIEval->Release();
	W32::CoUninitialize();
}

///////////////////////////////////////////////////////////
// AnsiToWide
// pre:  sz is the ansi string
// pos:  szw is the wide string
//NOTE:  if sz is NULL, sets szw to NULL
void AnsiToWide(LPCSTR sz, OLECHAR*& szw)
{
	if (!sz)
	{
		szw = NULL;
		return;
	}
	int cchWide = W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, szw, 0);
	szw = new OLECHAR[cchWide];
	W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, szw, cchWide);
}

////////////////////////////////////////////////////////////
// WideToAnsi
// pre: szw is the wide string
// pos: sz is the ansi string
//NOTE: if szw is NULL, sets sz to NULL
void WideToAnsi(const OLECHAR* szw, char*& sz)
{
	if (!szw)
	{
		sz = NULL;
		return;
	}
	int cchAnsi = W32::WideCharToMultiByte(CP_ACP, 0, szw, -1, 0, 0, 0, 0);
	sz = new char[cchAnsi];
	W32::WideCharToMultiByte(CP_ACP, 0, szw, -1, sz, cchAnsi, 0, 0);
}		

///////////////////////////////////////////////////////////
// CheckFeature
// pre:	szFeatureName is a Feature that belongs to this product
// pos:	installs the feature if not present and we go
BOOL CheckFeature(LPCTSTR szFeatureName)
{
	// determine platform (Win9X or WinNT) -- EXE component code conditionalized on platform
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); // init structure
	if (!GetVersionEx(&osvi))
		return FALSE;

	bool fWin9X = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ? true : false;

	// get ProductCode -- Windows Installer can determine the product code from a component code.
	// Here we use the MsiVal2 main component (component containing msival2.exe).  You must choose
	// a component that identifies the app, not a component that could be shared across products.
	// This is why we can't use the EvalComServer component.  EvalCom is shared between msival2 and orca
	// so the Windows Installer would be unable to determine to which product (if both were installed)
	// the component belonged.
	TCHAR szProductCode[MAX_GUID+1] = TEXT("");
	UINT iStat = 0;
	if (ERROR_SUCCESS != (iStat = MsiGetProductCode(fWin9X ? g_szMsiValWin9XComponentCode : g_szMsiValWinNTComponentCode,
											szProductCode)))
	{
		// error obtaining product code (may not be installed or component code may have changed)
		_tprintf(_T(">>> Fatal Error: MsiGetProductCode failed with error: %d.  Please install or re-install MsiVal2\n"), iStat);
		return FALSE;
	}

	// Prepare to use the feature: check its current state and increase usage count.
	INSTALLSTATE iFeatureState = MSI::MsiUseFeature(szProductCode, szFeatureName);


	// If feature is not currently usable, try fixing it
	switch (iFeatureState) 
	{
	case INSTALLSTATE_LOCAL:
	case INSTALLSTATE_SOURCE:
		break;
	case INSTALLSTATE_ABSENT:
		// feature isn't installed, try installing it
		if (ERROR_SUCCESS != MSI::MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_LOCAL))
			return FALSE;			// installation failed
		break;
	default:
		// feature is busted- try fixing it
		if (MsiReinstallFeature(szProductCode, szFeatureName, 
			REINSTALLMODE_FILEEQUALVERSION
			+ REINSTALLMODE_MACHINEDATA 
			+ REINSTALLMODE_USERDATA
			+ REINSTALLMODE_SHORTCUT) != ERROR_SUCCESS)
			return FALSE;			// we couldn't fix it
		break;
	}

	return TRUE;
}	// end of CheckFeature

///////////////////////////////////////////////////////////
// DisplayFunction
// pre:	called from Evaluation COM Object
// pos:	displays output from COM Object
BOOL WINAPI DisplayFunction(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation)
{
	if (ieInfo == uiType && !g_fInfo)
		return TRUE;

	// try to change the context into a log file handle
	HANDLE hLogFile = *((HANDLE*)pContext);

	// fill up a buffer string
	static TCHAR szBuffer[1024];
	DWORD cchBuffer;
	

	// set the type correctly
	LPTSTR szType;
	switch (uiType)
	{
	case ieError:
		szType = _T("ERROR");
		break;
	case ieWarning:
		szType = _T("WARNING");
		break;
	case ieInfo:
		szType = _T("INFO");
		break;
	default:
		szType = _T("UNKNOWN");
		break;
	}

	// create and then get length of buffer
#ifdef UNICODE
	_stprintf(szBuffer, g_szFormatter, szwVal, szType, szwDescription);
	cchBuffer = wcslen(szBuffer);
#else
	// convert the display strings into ANSI
	char *szVal = NULL;
	char *szDescription = NULL;
	WideToAnsi(szwVal, szVal);
	WideToAnsi(szwDescription, szDescription);
	_stprintf(szBuffer, g_szFormatter, szVal, szType, szDescription);
	cchBuffer = strlen(szBuffer);
#endif // UNICODE

	// if there is something in the buffer to display
	if (cchBuffer > 0)
	{
		// display the buffer string
		_tprintf(szBuffer);

		// if there is a log file write to it
		if (hLogFile != INVALID_HANDLE_VALUE)
		{
			// write to file
			DWORD cchDiscard;
			W32::WriteFile(hLogFile, szBuffer, cchBuffer * sizeof(TCHAR), &cchDiscard, NULL);
		}
	}

#ifndef UNICODE
	if (szVal)
		delete [] szVal;
	if (szDescription)
		delete [] szDescription;
#endif // !UNICODE

	return FALSE;
}

///////////////////////////////////////////////////////////
// RemoveQuotes
// pre:	pszOriginal points to a string
// pos:	removes " from either end of string
void RemoveQuotes(TCHAR*& rpszOriginal)
{
	// if string starts with a "
	if (*rpszOriginal == _T('"'))
		rpszOriginal++;	// step over "

	// get length of string
	int iLen = lstrlen(rpszOriginal);

	// if string ends with a " erase last char
	if (*(rpszOriginal + iLen) == _T('"'))
		*(rpszOriginal + iLen) = _T('\0');
}	// end of RemoveQuotes

///////////////////////////////////////////////////////////
// Usage
// pre:	none
// pos:	prints help to stdout
void Usage()
{
	_tprintf(_T("Copyright (C) Microsoft Corporation, 1998-2001.  All rights reserved.\n"));
	_tprintf(_T("msival2.exe database.msi EvaluationURL/Filename\n"));
//	_tprintf(_T("msival2.exe database.msi -Z\n"));
	_tprintf(_T("            [-i ICE1:ICE2:ICE3:...] [-l LogFile] [-?] [-f]\n"));
	_tprintf(_T("   i - [optional] specifies exact Internal Consistency Evaluators to run.\n"));
	_tprintf(_T("                  Each ICE must be separated by a colon.\n"));
	_tprintf(_T("   l - [optional] specifies log file \n"));
    _tprintf(_T("   ? - [optional] displays this help\n"));
//	_tprintf(_T("   Z - [special] use latest known evaluation file (off of ICEMAN website)"));
	_tprintf(_T("   f - [optional] suppress info messages\n\n"));
    _tprintf(_T("   WARNING: Be careful not to reverse the order of your database file and your validation file as no direct error message will be given if you do.\n"));

	return;
}	// end of Usage

///////////////////////////////////////////////////////////
// main
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
	// flags
	BOOL bLogging = FALSE;			// assume no logging
	
	BOOL bResult = FALSE;				// assume results are always bad
	HRESULT hResult = ERROR_SUCCESS;	// assume COM results are always good

	// strings for command line information
	TCHAR* pszDatabase = NULL;
	TCHAR* pszEvalFile = NULL;
	TCHAR* pszICEs = NULL;
	TCHAR* pszLogFile = NULL;
	HANDLE hLogFile = INVALID_HANDLE_VALUE;	// set the log file to invalid

	// if there is something on the command line
	// set the database to the first parameter on the command line
	if (argc > 1)
	{
		pszDatabase = argv[1];
		RemoveQuotes(pszDatabase);
	}

	if (argc > 2)
	{
		pszEvalFile = argv[2];
		if (_T('-') == *argv[2] || _T('/') == *argv[2])
		{
			// get the command letter
			if (_T('Z') == argv[2][1] || _T('z') == argv[2][1])
				pszEvalFile = g_szLatest; // use the latest release.  *special* switch
		}
		RemoveQuotes(pszEvalFile);
	}

	// loop through all parameters on command line
	TCHAR chCommand;
	for(int i = 0; i < argc; i++)
	{
		// if we have a command character
		if ('-' == *argv[i] || '/' == *argv[i])
		{
			// get the command letter
			chCommand = argv[i][1];

			switch (chCommand)
			{
				case 'D':	// set the database
				case 'd':
					if (argc == i + 1)
					{
						_tprintf(TEXT(">>ERROR: Database not specified\n"));
						return 0;
					}
					pszDatabase = argv[i + 1];
					RemoveQuotes(pszDatabase);
					i++;
					break;
				case 'E':	// set evaluation file
				case 'e':
					if (argc == i + 1)
					{
						_tprintf(TEXT(">>ERROR: Evaluation file not specified\n"));
						return 0;
					}
					pszEvalFile = argv[i + 1];
					RemoveQuotes(pszEvalFile);
					i++;
					break;
				case 'I':	// set ices
				case 'i':
					if (argc == i + 1)
					{
						_tprintf(TEXT(">>ERROR: ICES not specified\n"));
						return 0;
					}
					pszICEs = argv[i + 1];
					RemoveQuotes(pszICEs);
					i++;
					break;
				case 'L':	// log file
				case 'l':
					if (argc == i + 1)
					{
						_tprintf(TEXT(">>ERROR: Log file not specified\n"));
						return 0;
					}
					pszLogFile = argv[i + 1];
					RemoveQuotes(pszLogFile);
					i++;
					break;
				case '?':		// help 
					Usage();
					return 0;		// bail program
				case 'T':		// test for the existance of the COM Object
				case 't':
					W32::CoInitialize(NULL);

					IEval* pIDiscard;
					hResult = W32::CoCreateInstance(CLSID_EvalCom, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
																		 IID_IEval, (void**)&pIDiscard);
					W32::CoUninitialize();

					if (FAILED(hResult))
					{
						_tprintf(_T("Evaluation server is NOT registered.\n"));
//						ERRMSG(hResult);
					}
					else
						_tprintf(_T("Evaluation server is registered and ready to rock.\n   Bring on the ICE!!!\n"));

					return hResult;
				case 'Z':
				case 'z':
					break;
				case 'F':
				case 'f':
					g_fInfo = FALSE; // suppress info messages
					break;
				default:
					_tprintf(_T("Unknown parameter: %c\n\n"), chCommand);
					Usage();
					
					return -1;
			}
		}
	}

	BOOL bGood = TRUE;		// assume everything's good

	// if database was not defined
	if (!pszDatabase)
	{
		_tprintf(_T(">> Error: MSI Database not specified.\n"));
		bGood = FALSE;
	}

	// if we are doing files and sourceDir was not defined
	if (!pszEvalFile)
	{
		_tprintf(_T(">> Error: Did not specify evaluation file.\n"));
		bGood = FALSE;
	}

	// if we're not good anymore bail
	if (!bGood)
	{
		_tprintf(_T(">>> Fatal Error: Cannot recover from previous errors.\n"));
		_tprintf(_T("\nUse -? for more information.\n"));
		return -1;
	}

	// check the msival2 COM Server real quick before using it
	if (!CheckFeature(_T("EvalComServer")))
	{
		_tprintf(_T(">>> Fatal Error:  Failed to locate msival2 Evaluation COM Server.\n"));
		return -666;
	}

	W32::CoInitialize(NULL);

	// create a msival2 COM object
	IEval* pIEval;
	hResult = W32::CoCreateInstance(CLSID_EvalCom, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
											  IID_IEval, (void**)&pIEval);

	// if failed to create the object
	if (FAILED(hResult))
	{
		_tprintf(_T(">>> Fatal Error: Failed to instantiate EvalCom Object.\n\n"));
		return -1;
	}

	// if we are logging
	if (pszLogFile)
	{
		// open the file or create it if it doesn't exist
		hLogFile = W32::CreateFile(pszLogFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		
		// if the file is open
		if (INVALID_HANDLE_VALUE != hLogFile)
		{
			// move the pointer to the end of file
			W32::SetFilePointer(hLogFile, 0, 0, FILE_END);
		}
		else
		{
			_tprintf(_T(">> Error: Failed to open log file: %s\r\n"), pszLogFile);
			CleanUp(pIEval);
			return -2;
		}
	}

	// open the database and the evaluations
	HRESULT hResOpen;

#ifdef UNICODE
	hResult = pIEval->OpenDatabase(pszDatabase);
	hResOpen = pIEval->OpenEvaluations(pszEvalFile);
#else
	OLECHAR *szwDatabase = NULL;
	OLECHAR *szwEvalFile = NULL;
	AnsiToWide(pszDatabase, szwDatabase);
	hResult = pIEval->OpenDatabase(szwDatabase);
	AnsiToWide(pszEvalFile, szwEvalFile);
	hResOpen = pIEval->OpenEvaluations(szwEvalFile);
#endif // UNICODE

	// check results
	if (FAILED(hResult))
	{
		_tprintf(_T(">>> Fatal Error: Failed to open database: %s\r\n"), pszDatabase);
		CleanUp(pIEval);
		return -2;
	}

	if (FAILED(hResOpen))
	{
		_tprintf(_T(">>> Fatal Error: Failed to open evaulation file: %s\r\n"), pszEvalFile);
		CleanUp(pIEval);
		return -2;
	}
	else
	{
		// set UI handler
		pIEval->SetDisplay(DisplayFunction, &hLogFile);
		
		// now do the evaluations
		_tprintf(g_szFormatter, _T(" ICE"), _T(" Type"), _T("  Description"));

#ifdef UNICODE
		hResult = pIEval->Evaluate(pszICEs);
#else
		OLECHAR* szwICEs = NULL;
		AnsiToWide(pszICEs, szwICEs);
		hResult = pIEval->Evaluate(szwICEs);
#endif // UNICODE

		pIEval->CloseDatabase();
		pIEval->CloseEvaluations();

		if(FAILED(hResult))
		{
			_tprintf(_T("\n>> Error: Failed to run all of the evaluations.\r\n"));
			CleanUp(pIEval);
			return -2;
		}

		// cleanup
#ifndef UNICODE
		if (szwICEs)
			delete [] szwICEs;
#endif // !UNICODE
	}
	
	// see if there were any validation errors
	IEnumEvalResult* pIEnumEvalResults;
	ULONG pcResults;
	hResult = pIEval->GetResults(&pIEnumEvalResults, &pcResults);
	if (FAILED(hResult))
	{
		_tprintf(_T("\n>> Error: Failed to obtain enumerator.\r\n"));
		if (pIEnumEvalResults)
			pIEnumEvalResults->Release();
		CleanUp(pIEval);
		return -2;
	}

	// count errors
	int cErrors = 0;
	RESULTTYPES tResult;			// type of result
	ULONG cFetched;
	IEvalResult* pIResult;
	for (ULONG j = 0; j < pcResults; j++)
	{
		// get the next result
		pIEnumEvalResults->Next(1, &pIResult, &cFetched);

		if (cFetched != 1)
		{
			_tprintf(_T("\n>> Error: Failed to fetch error.\r\n"));
			if (pIEnumEvalResults)
				pIEnumEvalResults->Release();
			CleanUp(pIEval);
			return -2;
		}

		// if this is an error message or warning message
		pIResult->GetResultType((UINT*)&tResult);
		if (ieError == tResult)
		{
			cErrors++;
		}
	}

	// release enumerator
	if (pIEnumEvalResults)
		pIEnumEvalResults->Release();

	// release the object
	if (pIEval)
		pIEval->Release();

	// cleanup
#ifndef UNICODE
	if (szwDatabase)
		delete [] szwDatabase;
	if (szwEvalFile)
		delete [] szwEvalFile;
#endif // !UNICODE

	W32::CoUninitialize();	// uninitialize COM

	
	// for build process possibility, return 0 for success, -1 for failure
	if (cErrors)
		return -1;

	return 0;
}	// end of main



#else // RC_INVOKED, end of source code, start of resources
// resource definition go here
STRINGTABLE DISCARDABLE
{
 IDS_UnknownTable,       "Table name not found"
}

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\addrowd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// CAddRowD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "AddRowD.h"

#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ID_EDIT 666

/////////////////////////////////////////////////////////////////////////////
// CAddRowD dialog


CAddRowD::CAddRowD(CWnd* pParent /*=NULL*/)
	: CDialog(CAddRowD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddRowD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_iOldItem = -1;

	m_fReadyForInput = false;
}

CAddRowD::~CAddRowD()
{
}

void CAddRowD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddRowD)
	DDX_Control(pDX, IDC_ITEMLIST, m_ctrlItemList);
	DDX_Control(pDX, IDC_EDITTEXT, m_ctrlEditText);
	DDX_Control(pDX, IDC_DESCRIPTION, m_ctrlDescription);
	DDX_Control(pDX, IDC_BROWSE, m_ctrlBrowse);
	DDX_Text(pDX, IDC_DESCRIPTION, m_strDescription);
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddRowD, CDialog)
	//{{AFX_MSG_MAP(CAddRowD)
	//}}AFX_MSG_MAP
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_ITEMLIST, OnItemchanged)
	ON_NOTIFY(NM_DBLCLK, IDC_ITEMLIST, OnDblclkItemList)
	ON_MESSAGE(WM_AUTOMOVE_PREV, OnPrevColumn)
	ON_MESSAGE(WM_AUTOMOVE_NEXT, OnNextColumn)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddRowD message handlers

BOOL CAddRowD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	m_ctrlItemList.InsertColumn(1, TEXT("Name"), LVCFMT_LEFT, -1, 0);
	m_ctrlItemList.InsertColumn(1, TEXT("Value"), LVCFMT_LEFT, -1, 1);
	m_ctrlItemList.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);
		
    CImageList* m_pImageList = new CImageList();
	ASSERT(m_pImageList != NULL);    // serious allocation failure checking
	m_pImageList->Create(11, 22, ILC_COLOR | ILC_MASK, 4, 0);

	m_bmpKey.LoadBitmap(IDB_KEY);
	m_pImageList->Add(&m_bmpKey, RGB(0xC0, 0xC0, 0xC0));
	m_ctrlItemList.SetImageList(m_pImageList, LVSIL_SMALL);
	
	COrcaColumn* pColumn;
	UINT_PTR iColSize = m_pcolArray.GetSize();
	ASSERT(iColSize <= 31);
	// never more than 31 columns, so OK to cast down
	int cCols = static_cast<int>(iColSize);
	for (int i = 0; i < cCols; i++)
	{
		pColumn = m_pcolArray.GetAt(i);

		int iIndex = m_ctrlItemList.InsertItem(i, pColumn->m_strName, pColumn->IsPrimaryKey() ? 0 : 1);
		m_ctrlItemList.SetItemData(iIndex, reinterpret_cast<INT_PTR>(pColumn));
	}

	if (m_ctrlItemList.GetItemCount() > 0)
	{
		m_ctrlItemList.SetColumnWidth(0, LVSCW_AUTOSIZE);
		m_ctrlItemList.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
	
		// call the item changed handler to populate the initial controls
		m_fReadyForInput = true;
		ChangeToItem(0, true, true);
	}

	return FALSE;  // return TRUE unless you set the focus to a control
}

void CAddRowD::OnOK() 
{
	// this is the command handler for IDOK WM_COMMAND, which also happens when somebody hits
	// ENTER on a control. Check to see if either edit box has focus. If so, don't dismiss
	// the dialog, just change the list control item to the next in sequence.
	CWnd* pFocusWnd = GetFocus();
	if (pFocusWnd == &m_ctrlEditText)
	{
		LRESULT fNoOp = SendMessage(WM_AUTOMOVE_NEXT, 0, 0);

		// if the "next item" op changed something, don't process the default command, 
		// but if it didn't do anything (already at the end of the list), try to 
		// end the dialog anyway.
		if (!fNoOp)
			return;
	}
	BOOL bGood = true;
	CString strPrompt;

	// save the currently edited value into the control
	SaveValueInItem();

	// clear the existing output list
	m_strListReturn.RemoveAll();

	for (int iItem = 0; iItem < m_ctrlItemList.GetItemCount(); iItem++)
	{
		COrcaColumn* pColumn = reinterpret_cast<COrcaColumn*>(m_ctrlItemList.GetItemData(iItem));

		// if there is no column pointer, skip this column
		if (pColumn == NULL)
			continue;

		// grab string from control
		CString strValue = m_ctrlItemList.GetItemText(iItem, 1);

		// check "Nullable" Attribute
		if (!(pColumn->m_bNullable) && strValue.IsEmpty())
		{
			strPrompt.Format(_T("Column '%s' must be filled in."), pColumn->m_strName);
			AfxMessageBox(strPrompt);
			bGood = FALSE;
			ChangeToItem(iItem, true, /*SetListControl*/true);
			break;
		}

		// if the column is binary, check that the path exists
		if (iColumnBinary == pColumn->m_eiType)
		{
			// if the file does not exist
			if (!strValue.IsEmpty() && !FileExists(strValue))
			{
				strPrompt.Format(_T("Binary file '%s' does not exist."), strValue);
				AfxMessageBox(strPrompt);
				bGood = FALSE;
				ChangeToItem(iItem, true, /*SetListControl*/true);
				break;
			}
		}

		m_strListReturn.AddTail(strValue);	// add to the end of the string list
	}

	if (bGood)
		CDialog::OnOK();
}

////
// pulls the current value from whatever edit control is active and stores the string
// in the currently active item from the item list
void CAddRowD::SaveValueInItem()
{
	if (m_iOldItem >= 0)
	{
		CString strValue;
	
		// save off the appropiate value
		m_ctrlEditText.GetWindowText(strValue);		
		m_ctrlItemList.SetItemText(m_iOldItem, 1, strValue);
	}
}

void CAddRowD::SetSelToString(CString& strValue)
{
	// set the appropiate value in the edit control
	m_ctrlEditText.SetWindowText(strValue);
}

LRESULT CAddRowD::ChangeToItem(int iItem, bool fSetFocus, bool fSetListControl)
{
	// if we're still populating the list control, don't bother doing anything
	if (!m_fReadyForInput)
		return 0;

	if (fSetListControl)
	{
		// this triggers a recursive call into this function (fSetListControl will
		// be false. Can't just exit after making this call because the recursive call
		// loses fSetFocus, so its still this call's job to set control focus
		m_ctrlItemList.SetItemState(iItem, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
		m_ctrlItemList.EnsureVisible(iItem, /*PartialOK=*/FALSE);
	}
	else
	{
		// if this is a "no-op change"
		if (m_iOldItem == iItem)
		{
			return 0;
		}
	
		// save the old value into the control
		SaveValueInItem();
	
		// save off new item as old item for next click
		m_iOldItem = iItem;
		
		COrcaColumn* pColumn = reinterpret_cast<COrcaColumn*>(m_ctrlItemList.GetItemData(iItem));
	
		if (pColumn)
		{
			CString strRequired = _T(", Required");
			if (pColumn->m_bNullable)
				strRequired = _T("");
	
			switch (pColumn->m_eiType)
			{
			case iColumnString:
				m_strDescription.Format(_T("%s - String[%d]%s"), pColumn->m_strName, pColumn->m_iSize, strRequired);
				break;
			case iColumnLocal:
				m_strDescription.Format(_T("%s - Localizable String[%d]%s"), pColumn->m_strName, pColumn->m_iSize, strRequired);
				break;
			case iColumnShort:
				m_strDescription.Format(_T("%s - Short%s"), pColumn->m_strName, strRequired);
				break;
			case iColumnLong:
				m_strDescription.Format(_T("%s - Long%s"), pColumn->m_strName, strRequired);
				break;
			case iColumnBinary:
				m_strDescription.Format(_T("%s - Binary (enter filename)%s"), pColumn->m_strName, strRequired);
				break;
			default:
				ASSERT(FALSE);
			}
	
		
			// show or hide the edit controls and browse button based on the column type
			switch (pColumn->m_eiType)
			{
			case iColumnNone:
				ASSERT(0);
				break;
			case iColumnBinary:
			case iColumnString:
			case iColumnLocal:
			{
				// enable browse button only for binary data columns
				m_ctrlBrowse.ShowWindow(pColumn->m_eiType == iColumnBinary ? SW_SHOW : SW_HIDE);
				break;
			}
			case iColumnShort:
			case iColumnLong:
			{
				m_ctrlBrowse.ShowWindow(SW_HIDE);
				break;
			}		
			}
	
			// set the edit control to the current value from the list control
			CString strDefault = m_ctrlItemList.GetItemText(m_iOldItem, 1);
			SetSelToString(strDefault);
		}

		// refresh the description
		UpdateData(FALSE);
	}
	
	// if asked to set focus, set the focus to the currently active edit control
	if (fSetFocus)
	{
		m_ctrlEditText.SetFocus();
	}
	return 0;
}

////
// message handler for private message from edit controls that 
// moves to the next item in the list. Returns 1 if we were
// already at the last item in the list
LRESULT CAddRowD::OnNextColumn(WPARAM wParam, LPARAM lParam)
{
	int iItem = m_ctrlItemList.GetNextItem(-1, LVNI_FOCUSED);

	// but if we're in the last item, close the dialog anyway
	if (iItem < m_ctrlItemList.GetItemCount()-1)
	{
		ChangeToItem(iItem+1, /*fSetFocus=*/true, /*fSetListCtrl=*/true);
		return 0;
	}
	return 1;
}

////
// message handler for private message from edit controls that 
// moves to the previous item in the list. Returns 1 if we were
// already at the first item in the list
LRESULT CAddRowD::OnPrevColumn(WPARAM wParam, LPARAM lParam)
{
	int iItem = m_ctrlItemList.GetNextItem(-1, LVNI_FOCUSED);

	// but if we're in the last item, close the dialog anyway
	if (iItem > 0)
	{
		ChangeToItem(iItem-1, /*fSetFocus=*/true, /*fSetListCtrl=*/true);
		return 0;
	}
	return 1;
}


////
//  refresh secondary controls on item change
void CAddRowD::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	*pResult = ChangeToItem(pNMListView->iItem, false, /*SetListControl*/false);
}

////
//  Throws up a browse dialog for finding a cab extraction path
void CAddRowD::OnBrowse() 
{
	CString strValue;

	// get current path 
	m_ctrlEditText.GetWindowText(strValue);
	
	// open the file open dialog
	CFileDialog dlg(TRUE, NULL, strValue, OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST, _T("All Files (*.*)|*.*||"), this);
	if (IDOK == dlg.DoModal())
	{
		SetSelToString(dlg.GetPathName());
	}
}

////
// when an item is double-clicked, set focus to the edit control 
void CAddRowD::OnDblclkItemList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NMITEMACTIVATE* pEvent = reinterpret_cast<NMITEMACTIVATE*>(pNMHDR);
	int iItem = m_ctrlItemList.HitTest(pEvent->ptAction);
	if (iItem != -1)
	{
		m_ctrlEditText.SetFocus();
	}
	*pResult = 0;
}




/////////////////////////////////////////////////////////////////////////////
// private CEdit class that traps some keys for use in navigating the 
// column list

BEGIN_MESSAGE_MAP(CAddRowEdit, CEdit)
	ON_WM_KEYDOWN( )
END_MESSAGE_MAP()

////
// the message handler for keydown filters out cursor messages of interest
// to the parent in navigating the row list.
void CAddRowEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	UINT uiMessage = 0;
	switch (nChar)
	{
	case VK_UP:
		uiMessage = WM_AUTOMOVE_PREV;
		break;
	case VK_RETURN:
	case VK_DOWN:
		uiMessage = WM_AUTOMOVE_NEXT;
		break;
	default:
		CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
		return;
	}

	CWnd* pDialog = GetParent();
	if (pDialog)
	{
		LRESULT fNoOp = pDialog->SendMessage(uiMessage, 0, 0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\addrowd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_ADDROWD_H__AF466B57_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_)
#define AFX_ADDROWD_H__AF466B57_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CAddRowD.h : header file
//

#include "Column.h"

class CAddRowEdit : public CEdit
{
protected:
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// messages for communicating between private edit box and dialog
const int WM_AUTOMOVE_NEXT = (WM_APP+0);
const int WM_AUTOMOVE_PREV = (WM_APP+1);

/////////////////////////////////////////////////////////////////////////////
// CAddRowD dialog

class CAddRowD : public CDialog
{
// Construction
public:
	CAddRowD(CWnd* pParent = NULL);   // standard constructor
	~CAddRowD();

// Dialog Data
	//{{AFX_DATA(CAddRowD)
	enum { IDD = IDD_ADD_ROW };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	CTypedPtrArray<CObArray, COrcaColumn*> m_pcolArray;
	CStringList m_strListReturn;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddRowD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddRowD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	
	afx_msg void OnBrowse();
	afx_msg LRESULT OnPrevColumn(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnNextColumn(WPARAM wParam, LPARAM lParam);
	afx_msg void OnDblclkItemList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


private:
	CAddRowEdit m_ctrlEditText;
	CStatic     m_ctrlDescription;
	CListCtrl   m_ctrlItemList;
	CButton     m_ctrlBrowse;
	CString	    m_strDescription;
	bool        m_fReadyForInput;
	int         m_iOldItem;
	CBitmap     m_bmpKey;

	void SaveValueInItem();
	void SetSelToString(CString& strValue);
	LRESULT ChangeToItem(int iItem, bool fSetFocus, bool fSetListControl);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDROWD_H__AF466B57_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msizap\msizap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       msizap.h
//
//--------------------------------------------------------------------------

#ifndef _MSIZAP_H_
#define _MSIZAP_H_

#include <aclapi.h>


//==============================================================================================
// CRegHandle class declaration -- smart class for managing registry key handles (HKEYs)

class CRegHandle
{
public:
    CRegHandle();
    CRegHandle(HKEY h);
    ~CRegHandle();
    void operator =(HKEY h);
    operator HKEY() const;
    HKEY* operator &();
    operator bool() { return m_h==0 ? false : true; }
//   HKEY* operator &() { return &m_h;}
//   operator &() { return m_h;}

private:
    HKEY m_h;
};

//!! eugend: I've copied this over from Darwin's COMMON.H.  It had
//           been around for ever so I don't expect it to have any
//           bugs.
//____________________________________________________________________________
//
// CTempBuffer<class T, int C>   // T is array type, C is element count
//
// Temporary buffer object for variable size stack buffer allocations
// Template arguments are the type and the stack array size.
// The size may be reset at construction or later to any other size.
// If the size is larger that the stack allocation, new will be called.
// When the object goes out of scope or if its size is changed,
// any memory allocated by new will be freed.
// Function arguments may be typed as CTempBufferRef<class T>&
//  to avoid knowledge of the allocated size of the buffer object.
// CTempBuffer<T,C> will be implicitly converted when passed to such a function.
//____________________________________________________________________________

template <class T> class CTempBufferRef;  // for passing CTempBuffer as unsized ref

template <class T, int C> class CTempBuffer
{
 public:
        CTempBuffer() {m_cT = C; m_pT = m_rgT;}
        CTempBuffer(int cT) {m_pT = (m_cT = cT) > C ? new T[cT] : m_rgT;}
        ~CTempBuffer() {if (m_cT > C) delete m_pT;}
        operator T*()  {return  m_pT;}  // returns pointer
        operator T&()  {return *m_pT;}  // returns reference
        int  GetSize() {return  m_cT;}  // returns last requested size
        void SetSize(int cT) {if (m_cT > C) delete[] m_pT; m_pT = (m_cT=cT) > C ? new T[cT] : m_rgT;}
        void Resize(int cT) {
                T* pT = cT > C ? new T[cT] : m_rgT;
                if ( ! pT ) cT = 0;
                if(m_pT != pT)
                        for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
                if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
        }
        operator CTempBufferRef<T>&() {m_cC = C; return *(CTempBufferRef<T>*)this;}
        T& operator [](int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
        T& operator [](unsigned int iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#ifdef _WIN64           //--merced: additional operators for int64
        T& operator [](INT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
        T& operator [](UINT_PTR iTmp)  {return  *(m_pT + iTmp);}  // returns pointer
#endif
 protected:
        void* operator new(size_t) {return 0;} // restrict use to temporary objects
        T*  m_pT;     // current buffer pointer
        int m_cT;     // reqested buffer size, allocated if > C
        int m_cC;     // size of local buffer, set only by conversion to CTempBufferRef
        T   m_rgT[C]; // local buffer, must be final member data
};

template <class T> class CTempBufferRef : public CTempBuffer<T,1>
{
 public:
        void SetSize(int cT) {if (m_cT > m_cC) delete[] m_pT; m_pT = (m_cT=cT) > m_cC ? new T[cT] : m_rgT;}
        void Resize(int cT) {
                T* pT = cT > m_cC ? new T[cT] : m_rgT;
                if ( ! pT ) cT = 0;
                if(m_pT != pT)
                        for(int iTmp = (cT < m_cT)? cT: m_cT; iTmp--;) pT[iTmp] = m_pT[iTmp];
                if(m_pT != m_rgT) delete[] m_pT; m_pT = pT; m_cT = cT;
        }
 private:
        CTempBufferRef(); // cannot be constructed
        ~CTempBufferRef(); // ensure use as a reference
};


//==============================================================================================
// Constants

const int cbMaxSID  = sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD);
const int cchMaxSID = 256;

const int iRemoveAllFoldersButUserProfile = 1 << 0;
const int iRemoveAllRegKeys               = 1 << 1;
const int iRemoveInProgressRegKey         = 1 << 2;
const int iOnlyRemoveACLs                 = 1 << 3;
const int iAdjustSharedDLLCounts          = 1 << 4;
const int iForceYes                       = 1 << 5;
const int iStopService                    = 1 << 6;
const int iRemoveUserProfileFolder        = 1 << 7;
const int iRemoveWinMsiFolder             = 1 << 8;
const int iRemoveConfigMsiFolder          = 1 << 9;
const int iRemoveUninstallKey             = 1 << 10;
const int iRemoveProduct                  = 1 << 11;
const int iRemoveRollbackKey              = 1 << 13; 
const int iOrphanProduct                  = 1 << 14; // removes Installer info about product but leaves other info (like sharedDLL counts)
const int iForAllUsers                    = 1 << 15;
const int iRemoveGarbageFiles             = 1 << 16;
const int iRemoveRollback                 = iRemoveRollbackKey | iRemoveConfigMsiFolder;
const int iRemoveAllFolders               = iRemoveWinMsiFolder | iRemoveUserProfileFolder | iRemoveConfigMsiFolder;
const int iRemoveAllNonStateData          = iRemoveAllFolders | iRemoveAllRegKeys | iAdjustSharedDLLCounts | iStopService;

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

/*
#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_GROUPS )                            \
    + 10*(sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES)
*/
#define MAX_SID_STRING 256

const TCHAR* szAllProductsArg = TEXT("ALLPRODUCTS");

//==============================================================================================
// Functions -- SID manipulation
DWORD GetAdminSid(char** pSid);
void GetStringSID(PISID pSID, TCHAR* szSID);
DWORD GetUserSID(HANDLE hToken, char* rgSID);
DWORD GetCurrentUserSID(char* rgchSID);
inline TCHAR* GetCurrentUserStringSID(DWORD* dwReturn);
const TCHAR szLocalSystemSID[] = TEXT("S-1-5-18");

//==============================================================================================
// Functions -- Token manipulation
DWORD OpenUserToken(HANDLE &hToken, bool* pfThreadToken=0);
DWORD GetCurrentUserToken(HANDLE &hToken);
bool GetUsersToken(HANDLE &hToken);
bool AcquireTokenPrivilege(const TCHAR* szPrivilege);

//==============================================================================================
// Functions -- Security manipulation
DWORD AddAdminFullControl(HANDLE hObject, SE_OBJECT_TYPE ObjectType);
DWORD AddAdminOwnership(HANDLE hObject, SE_OBJECT_TYPE ObjectType);
DWORD AddAdminFullControlToRegKey(HKEY hKey);
DWORD GetAdminFullControlSecurityDescriptor(char** pSecurityDescriptor);
DWORD TakeOwnershipOfFile(const TCHAR* szFile, bool fFolder);
DWORD MakeAdminRegKeyOwner(HKEY hKey, TCHAR* szSubKey);


//==============================================================================================
// Functions -- Miscellaneous
bool StopService();
BOOL IsGUID(const TCHAR* sz);
void GetSQUID(const TCHAR* szProduct, TCHAR* szProductSQUID);
bool IsProductInstalledByOthers(const TCHAR* szProductSQUID);
void DisplayHelp(bool fVerbose);
void SetPlatformFlags(void);
bool ReadInUsers();
bool DoTheJob(int iTodo, const TCHAR* szProduct);
bool IsAdmin();

//==============================================================================================
// Functions -- Zap
bool RemoveFile(TCHAR* szFilePath, bool fJustRemoveACLs);
BOOL DeleteFolder(TCHAR* szFolder, bool fJustRemoveACLs);
BOOL DeleteTree(HKEY hKey, TCHAR* szSubKey, bool fJustRemoveACLs);
bool ClearWindowsUninstallKey(bool fJustRemoveACLs, const TCHAR* szProduct);
bool ClearUninstallKey(bool fJustRemoveACLs, const TCHAR* szProduct=0);
bool ClearSharedDLLCounts(TCHAR* szComponentsSubkey, const TCHAR* szProduct=0);
bool ClearProductClientInfo(TCHAR* szComponentsSubkey, const TCHAR *szProduct, bool fJustRemoveACLs);
bool ClearFolders(int iTodo, const TCHAR* szProduct, bool fOrphan);
bool ClearPublishComponents(HKEY hKey, TCHAR* szSubKey, const TCHAR* szProduct);
bool ClearRollbackKey(bool fJustRemoveACLs);
bool ClearInProgressKey(bool fJustRemoveACLs);
bool ClearRegistry(bool fJustRemoveACLs);
bool RemoveCachedPackage(const TCHAR* szProduct, bool fJustRemoveACLs);
bool ClearPatchReferences(HKEY hRoot, HKEY hProdPatchKey, TCHAR* szPatchKey, TCHAR* szProductsKey, TCHAR* szProductSQUID);
bool ClearUpgradeProductReference(HKEY HRoot, const TCHAR* szSubKey, const TCHAR* szProductSQUID);
bool ClearProduct(int iTodo, const TCHAR* szProduct, bool fJustRemoveACLs, bool fOrphan);



#endif _MSIZAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\msizap\msizap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       msizap.cpp
//
//--------------------------------------------------------------------------

// Required headers
#include <windows.h>
#include "msiquery.h"
#include "msip.h"
#include "msizap.h"
#include <aclapi.h>
#include <stdio.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <shlobj.h>

//!! Fix warnings and remove pragma
#pragma warning(disable : 4018) // signed/unsigned mismatch

//==============================================================================================
// Globals

bool g_fWin9X = false;
bool g_fWinNT64 = false;
DWORD g_iMajorVersion = 0;
TCHAR** g_rgpszAllUsers = NULL;
int g_iUserIndex = -1;
bool g_fDataFound = false;

//==============================================================================================
// CRegHandle class implementation -- smart class for managing registry key handles (HKEYs)

inline CRegHandle::CRegHandle() : m_h(0)
{
}

inline CRegHandle::CRegHandle(HKEY h) : m_h(h)
{
}

inline void CRegHandle::operator =(HKEY h) 
{ 
    if(m_h != 0) 
        RegCloseKey(m_h); 
    m_h = h; 
}

inline CRegHandle::operator HKEY() const 
{ 
    return m_h; 
}

inline HKEY* CRegHandle::operator &() 
{ 
    if (m_h != 0) 
    {
        RegCloseKey(m_h); 
        m_h = 0;
    }
    return &m_h; 
}

inline CRegHandle::~CRegHandle()
{
    if(m_h != 0) 
    {
        RegCloseKey(m_h); 
        m_h = 0;
    }

}

inline DWORD RegOpen64bitKey(IN HKEY hKey,
                             IN LPCTSTR lpSubKey,
                             IN DWORD ulOptions,
                             IN REGSAM samDesired,
                             OUT PHKEY phkResult)
{
#ifndef _WIN64
    if ( g_fWinNT64 &&
         (samDesired & KEY_WOW64_64KEY) != KEY_WOW64_64KEY )
        samDesired |= KEY_WOW64_64KEY;
#endif
    return RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}


DWORD RegDelete64bitKey(IN HKEY hKey,
                               IN LPCTSTR lpSubKey)
{
#ifndef _WIN64
    if ( g_fWinNT64 )
    {
        // 32-bit RegDeleteKey does not handle deletion of 64-bit redirected
        // registry keys so we need to call NtDeleteKey
        
        CRegHandle hTemp;
        DWORD dwRes = RegOpen64bitKey(hKey, lpSubKey, 0,
                                      KEY_ALL_ACCESS, &hTemp);
        if ( dwRes == ERROR_SUCCESS )
        {
            HMODULE hModule = LoadLibrary(TEXT("ntdll.dll"));
            if( hModule != NULL )
            {
                typedef LONG(NTAPI *pNtDeleteKey)(IN HANDLE KeyHandle);
                typedef ULONG(NTAPI *pRtlNtStatusToDosError)(IN LONG Status);
                pNtDeleteKey pDel = NULL;
                pRtlNtStatusToDosError pConv = NULL;
                pDel = (pNtDeleteKey)GetProcAddress(hModule, "NtDeleteKey");
                if ( pDel )
                    pConv = (pRtlNtStatusToDosError)GetProcAddress(hModule, "RtlNtStatusToDosError");
                if ( pDel && pConv )
                    dwRes = pConv(pDel(hTemp));
                else
                    dwRes = GetLastError();
                FreeLibrary(hModule);
            }
            else
                dwRes = GetLastError();
        }
        return dwRes;
    }
#endif
    return RegDeleteKey(hKey, lpSubKey);
}

enum ieFolder
{
    iefSystem = 0,
    iefFirst = iefSystem,
    iefPrograms = 1,
    iefCommon = 2,
    iefLast = iefCommon,
};

enum ieBitness
{
    ieb32bit = 0,
    iebFirst = ieb32bit,
    ieb64bit = 1,
    iebLast = ieb64bit,
};

// the array below is initialized with the special 64-bit NT folders in this outlay:
//
// 32-bit folders:                      corresponding 64-bit folder:
//
// C:\Windows\Syswow64                  C:\Windows\System32
// C:\Program Files (x86)               C:\Program Files
// C:\Program Files (x86)\CommonFiles   C:\Program Files\CommonFiles
//
TCHAR g_rgchSpecialFolders[iefLast+1][iebLast+1][MAX_PATH];

void LoadSpecialFolders(int iTodo)
{
    CRegHandle hKey = 0;
    
    for (int i = iefFirst; i <= iefLast; i++)
        for (int j = iebFirst; j <= iebLast; j++)
            *g_rgchSpecialFolders[i][j] = NULL;

    if ( g_fWinNT64 )
    {
        TCHAR rgchBuffer[(MAX_PATH+5)*iebLast];
        TCHAR rgchPath[MAX_PATH+1];

#ifdef _WIN64
        // this is the recommended method of retrieving these folders,
        // only that it does not work properly in 32-bit processes
        // running on IA64
        HMODULE hModule = LoadLibrary(TEXT("shell32.dll"));
        if( hModule == NULL )
        {
            wsprintf(rgchBuffer,
                     TEXT("MsiZap warning: failed to load Shell32.dll. ")
                     TEXT("GetLastError returned %d\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
            goto OneMoreTry;
        }

        typedef HRESULT(WINAPI *pSHGetFolderPathW)(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
        pSHGetFolderPathW pFunc = (pSHGetFolderPathW)GetProcAddress(hModule, "SHGetFolderPathW");
        if( pFunc == NULL )
        {
            wsprintf(rgchBuffer,
                     TEXT("MsiZap warning: failed to get pointer to SHGetFolderPathW. ")
                     TEXT("GetLastError returned %d\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
            FreeLibrary(hModule);
            goto OneMoreTry;
        }

        // Initialize the special folder paths.
        int SpecialFoldersCSIDL[][iebLast+1] = 
            {{CSIDL_SYSTEMX86, CSIDL_SYSTEM},
             {CSIDL_PROGRAM_FILESX86, CSIDL_PROGRAM_FILES},
             {CSIDL_PROGRAM_FILES_COMMONX86, CSIDL_PROGRAM_FILES_COMMON}};
        int cErrors = 0;
        for(i = iefFirst; i <= iefLast; i++)
        {
            for(int j = iebFirst; j <= iebLast; j++)
            {
                HRESULT hRes = pFunc(NULL,
                                     SpecialFoldersCSIDL[i][j],
                                     NULL,
                                     SHGFP_TYPE_DEFAULT,
                                     g_rgchSpecialFolders[i][j]);
                if( hRes != S_OK )
                {
                    wsprintf(rgchBuffer,
                             TEXT("MsiZap warning: failed to get special folder path ")
                             TEXT("for CSIDL = %d. GetLastError returned %d\n"),
                             GetLastError());
                    OutputDebugString(rgchBuffer);
                    cErrors++;
                }
            }
        }
        FreeLibrary(hModule);
        if ( cErrors == sizeof(SpecialFoldersCSIDL)/sizeof(SpecialFoldersCSIDL[0]) )
            // no special folder could be retrieved
            goto OneMoreTry;
        else
            goto End;
#else // _WIN64
        goto OneMoreTry; // keeps the 32-bit compilation happy
#endif // _WIN64
        
OneMoreTry:        
        if ( !GetSystemDirectory(rgchPath, sizeof(rgchPath)/sizeof(TCHAR)) )
        {
            wsprintf(rgchBuffer,
                     TEXT("MsiZap warning: GetSystemDirectory call failed. "),
                     TEXT("GetLastError returned %d.\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
        }
        else
        {
            _tcscpy(g_rgchSpecialFolders[iefSystem][ieb64bit], rgchPath); // 'strcpy'
            TCHAR* pszSep = _tcsrchr(rgchPath, TEXT('\\')); // 'strrchr'
            if ( !pszSep || !_tcsclen(pszSep) ) // 'strlen'
            {
                wsprintf(rgchBuffer,
                         TEXT("MsiZap warning: \'%s\' is a strange 64-bit system directory. ")
                         TEXT("We'll not attempt to figure out its 32-bit counterpart.\n"),
                         rgchPath);
                OutputDebugString(rgchBuffer);
            }
            else
            {
                _tcscpy(pszSep, TEXT("\\syswow64")); // 'strcpy'
                _tcscpy(g_rgchSpecialFolders[iefSystem][ieb32bit], rgchPath); // 'strcpy'
            }
        }

        const TCHAR rgchSubKey[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
        LONG lResult = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                                       rgchSubKey, 0, KEY_READ, &hKey);
        if ( lResult != ERROR_SUCCESS )
        {
            wsprintf(rgchBuffer,
                     TEXT("MsiZap warning: RegOpenKeyEx failed returning %d ")
                     TEXT("while retrieving special folders.  GetLastError ")
                     TEXT("returns %d.\n"), lResult, GetLastError());
            OutputDebugString(rgchBuffer);
            goto End;
        }

        struct
        {
           const TCHAR*  szRegistryName;
           const TCHAR*  szFolderName;
        } rgData64[][2] = {{{TEXT("ProgramFilesDir (x86)"), TEXT("Program Files (x86)")},
                            {TEXT("ProgramFilesDir"),       TEXT("Program Files")      }},
                           {{TEXT("CommonFilesDir (x86)"),  TEXT("Common Files (x86)") },
                            {TEXT("CommonFilesDir"),        TEXT("Common Files")       }}};
        for (int i = 0, ii = iefPrograms; i < 2; i++, ii++)
        {
            for (int j = 0, jj = ieb32bit; j < 2; j++, jj++)
            {
                DWORD cbValue = sizeof(rgchPath);
                lResult = RegQueryValueEx(hKey, rgData64[i][j].szRegistryName,
                                          0, 0, (BYTE*)rgchPath, &cbValue);
                if ( lResult != ERROR_SUCCESS )
                {
                    wsprintf(rgchBuffer,
                             TEXT("MsiZap warning: RegQueryValueEx failed returning %d ")
                             TEXT("while retrieving \'%s\' folder.  GetLastError ")
                             TEXT("returns %d.\n"), lResult,
                             rgData64[i][j].szFolderName, GetLastError());
                    OutputDebugString(rgchBuffer);
                    continue;
                }

                _tcscpy(g_rgchSpecialFolders[ii][jj], rgchPath); // 'strcpy'
            }
        }
End:
#ifdef DEBUG
        OutputDebugString(TEXT("MsiZap info: special folders table's content:\n"));
        int iLen = 0;
        for (int i = iefFirst; i <= iefLast; i++, iLen = 0)
        {
            for (int j = iebFirst; j <= iebLast; j++)
            {
                int iThisLen = wsprintf(rgchBuffer+iLen,
                                        TEXT("   \'%s\'"),
                                        g_rgchSpecialFolders[i][j]);
                iLen += iThisLen;
            }
            wsprintf(rgchBuffer+iLen, TEXT("\n"));
            OutputDebugString(rgchBuffer);
        }
#else
        int iDummyStatement = 1;
#endif // DEBUG
    } // if ( g_fWinNT64 )
}

enum ieFolderType
{
    ieftNotSpecial = 0,
    ieft32bit,
    ieft64bit,
};

ieFolderType IsInSpecialFolder(LPTSTR rgchFolder, int* piIndex = 0)
{
    if ( !g_fWinNT64 )
        return ieftNotSpecial;

    for (int i = iebFirst; i <= iebLast; i++)
    {
        for (int j = iefFirst; j <= iefLast; j++)
        {
            if ( !*g_rgchSpecialFolders[i][j] )
                continue;
            int iSpFolderLen = _tcsclen(g_rgchSpecialFolders[i][j]); // a sophisticated 'strlen'
            if ( !_tcsncicmp(rgchFolder, g_rgchSpecialFolders[i][j], iSpFolderLen) &&
                 (!rgchFolder[iSpFolderLen] || rgchFolder[iSpFolderLen] == TEXT('\\')) )
            {
                // OK, we have a match
                if ( piIndex )
                    *piIndex = j;
                return i == ieb32bit ? ieft32bit : ieft64bit;
            }

        }
    }

    return ieftNotSpecial;
}

enum ieSwapType
{
    iest32to64 = 0,
    iest64to32,
};

void SwapSpecialFolder(LPTSTR rgchFolder, ieSwapType iHowTo)
{
    int iIndex = -1;

    ieFolderType iType = IsInSpecialFolder(rgchFolder, &iIndex);
    if ( iType == ieftNotSpecial )
        return;

    if ( iIndex < iefFirst || iIndex > iefLast )
    {
        OutputDebugString(TEXT("MsiZap warning: did not swap special folder due to invalid index.\n"));
        return;
    }
    if ( (iHowTo == iest32to64 && iType == ieft64bit) ||
         (iHowTo == iest64to32 && iType == ieft32bit) )
    {
        OutputDebugString(TEXT("MsiZap warning: did not swap special folder due to mismatching types.\n"));
        return;
    }
    TCHAR rgchBuffer[MAX_PATH+1];
    int iSwapFrom = iHowTo == iest32to64 ? ieb32bit : ieb64bit;
    int iSwapTo = iSwapFrom == ieb32bit ? ieb64bit : ieb32bit;
    if ( !*g_rgchSpecialFolders[iIndex][iSwapTo] )
    {
        wsprintf(rgchBuffer,
                 TEXT("MsiZap warning: did not swap \'%s\' folder because of uninitialized replacement.\n"),
                 rgchFolder);
        OutputDebugString(rgchBuffer);
        return;
    }
    int iSwappedLength = _tcsclen(g_rgchSpecialFolders[iIndex][iSwapFrom]); // 'strlen'
    _tcscpy(rgchBuffer, g_rgchSpecialFolders[iIndex][iSwapTo]); // 'strcpy'
    if ( rgchFolder[iSwappedLength] )
        _tcscat(rgchBuffer, &rgchFolder[iSwappedLength]); // 'strcat'
    _tcscpy(rgchFolder, rgchBuffer); // 'strcpy'
}

//  functions called from ClearGarbageFiles

#define DYNAMIC_ARRAY_SIZE      10

bool IsStringInArray(LPCTSTR szString,
                CTempBufferRef<TCHAR*>& rgStrings,
                UINT* piIndex = 0)
{
    if ( !szString || !*szString )
        // empty strings are out of discussion
        return false;

    for (UINT i = 0; i < rgStrings.GetSize(); i++)
        if ( rgStrings[i] && !_tcsicmp(rgStrings[i], szString) ) // '_stricmp'
        {
            if ( piIndex )
                *piIndex = i;
            // szString is in array
            return true;
        }
    return false;
}

bool LearnNewString(LPCTSTR szString,
               CTempBufferRef<TCHAR*>& rgNewStrings, UINT& cNewStrings,
               bool fCheckExistence = false)
{
    if ( !szString || !*szString )
        // empty strings are out of discussion
        return true;

    if ( fCheckExistence && IsStringInArray(szString, rgNewStrings) )
    {
        // szString is already known
        return true;
    }

    // OK, we have a new string that we'll 'memorize'
    if ( rgNewStrings.GetSize() == cNewStrings )
    {
        // rgNewStrings is max-ed.
        rgNewStrings.Resize(cNewStrings+DYNAMIC_ARRAY_SIZE);
        if ( !rgNewStrings.GetSize() )
            // there was a problem allocating memory
            return false;
        for (UINT i = cNewStrings; i < rgNewStrings.GetSize(); i++)
            rgNewStrings[i] = NULL;
    }

    TCHAR* pszDup = _tcsdup(szString); // '_strdup'
    if ( !pszDup )
        // there was a problem allocating memory
        return false;

    rgNewStrings[cNewStrings++] = pszDup;
    return true;
}

bool LearnPathAndExtension(LPCTSTR szPath,
               CTempBufferRef<TCHAR*>& rgPaths, UINT& cPaths,
               CTempBufferRef<TCHAR*>& rgExts, UINT& cExts)
{
    TCHAR* pszDot = _tcsrchr(szPath, TEXT('.')); // 'strrchr'
    if ( pszDot )
    {
        if ( !LearnNewString(pszDot, rgExts, cExts, true) )
            return false;
    }

    // since we're dealing with paths in the FS there's no need here to
    // make sure here that they're unique.
    return LearnNewString(szPath, rgPaths, cPaths);
}

// ClearGarbageFiles goes through the folders where Windows Installer caches
// data files and removes the ones that are not referenced in the registry

bool ClearGarbageFiles(void)
{
    // this ensures this function runs only once
    static bool fAlreadyRun = false;
    static bool fError = false;
    if ( fAlreadyRun )
        return !fError;
    else
        fAlreadyRun = true;

    _tprintf(TEXT("Removing orphaned cached files.\n"));

    // 0. Declare and initialize arrays where we store info we learn

    // dynamic list of folders where we look for cached files
    CTempBuffer<TCHAR*, DYNAMIC_ARRAY_SIZE> rgpszFolders;
    UINT cFolders = 0;
    for (int i = 0; i < rgpszFolders.GetSize(); i++)
        rgpszFolders[i] = NULL;
    
    // dynamic array of cached files that are referenced in the registry
    CTempBuffer<TCHAR*, DYNAMIC_ARRAY_SIZE> rgpszReferencedFiles;
    UINT cReferencedFiles = 0;
    for (i = 0; i < rgpszReferencedFiles.GetSize(); i++)
        rgpszReferencedFiles[i] = NULL;

    // dynamic array of file extensions
    CTempBuffer<TCHAR*, DYNAMIC_ARRAY_SIZE> rgpszExtensions;
    UINT cExtensions = 0;
    for (i = 0; i < rgpszExtensions.GetSize(); i++)
        rgpszExtensions[i] = NULL;
    const TCHAR* rgpszKnownExtensions[] = {TEXT(".msi"),
                                           TEXT(".mst"),
                                           TEXT(".msp")};
    for (i = 0; i < sizeof(rgpszKnownExtensions)/sizeof(rgpszKnownExtensions[0]); i++ )
    {
        if ( !LearnNewString(rgpszKnownExtensions[i], rgpszExtensions, cExtensions) )
            return !(fError = true);
    }

    TCHAR rgchMsiDirectory[MAX_PATH] = {0};
    if ( !GetWindowsDirectory(rgchMsiDirectory, MAX_PATH) )
    {
        _tprintf(TEXT("   Error retrieving Windows directory. GetLastError returned: %d.\n"),
                 GetLastError());
        fError = true;
    }
    else
    {
        int iLen = _tcsclen(rgchMsiDirectory); // 'strlen'
        if ( rgchMsiDirectory[iLen-1] != TEXT('\\') )
            _tcscat(rgchMsiDirectory, TEXT("\\")); // 'strcat'
        _tcscat(rgchMsiDirectory, TEXT("Installer"));
    }

    // 1. We read in the list of cached files the Windows Installer knows about

    // 1.1. We go first through the user-migrated keys
    bool fUserDataFound = false;
    CRegHandle hKey;
    long lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData"),
                          0, KEY_READ, &hKey);
    if ( lError == ERROR_SUCCESS )
    {
        TCHAR szUser[MAX_PATH];
        DWORD cchUser = sizeof(szUser)/sizeof(TCHAR);
        // 1.1.1. We enumerate users that have products installed
        for ( int iUserIndex = 0;
              (lError = RegEnumKeyEx(hKey, iUserIndex,
                                     szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iUserIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
        {
            TCHAR rgchBuffer[MAX_PATH];
            wsprintf(rgchBuffer, TEXT("%s\\Products"), szUser);
            CRegHandle hProductsKey;
            lError = RegOpen64bitKey(hKey, rgchBuffer,
                                     0, KEY_READ, &hProductsKey);
            if ( lError != ERROR_SUCCESS )
            {
                if ( lError != ERROR_FILE_NOT_FOUND )
                {
                    _tprintf(TEXT("   Error opening HKLM\\...\\Installer\\UserData\\%s\\Products key. Error: %d.\n"),
                             szUser, lError);
                    fError = true;
                    goto Patches; // ugly, but saves some indentations
                }
            }
            TCHAR szProduct[MAX_PATH];
            DWORD cchProduct = sizeof(szProduct)/sizeof(TCHAR);
            // 1.1.1.1. For each user we enumerate products and check if they'd
            //          been installed with Windows Installer.  If so, we
            //          'memorize' the path to the cached package & transforms
            for ( int iProdIndex = 0;
                  (lError = RegEnumKeyEx(hProductsKey, iProdIndex,
                                         szProduct, &cchProduct, 0, 0, 0, 0)) == ERROR_SUCCESS;
                  iProdIndex++, cchProduct = sizeof(szProduct)/sizeof(TCHAR) )
            {
                TCHAR szKey[MAX_PATH];
                wsprintf(szKey, TEXT("%s\\InstallProperties"),
                         szProduct);
                CRegHandle hUserProductKey;
                lError = RegOpen64bitKey(hProductsKey, szKey, 0,
                                         KEY_READ, &hUserProductKey);
                if ( lError != ERROR_SUCCESS )
                {
                    _tprintf(TEXT("   Error opening %s subkey of Products key for %s user. Error: %d.\n"),
                             szKey, szUser, lError);
                    fError = true;
                    continue;
                }

                DWORD dwType;
                DWORD dwValue;
                DWORD cb = sizeof(DWORD);
                lError = RegQueryValueEx(hUserProductKey,
                                         TEXT("WindowsInstaller"), 0,
                                         &dwType, (LPBYTE)&dwValue, &cb);
                if ( lError != ERROR_SUCCESS || (dwType == REG_DWORD && dwValue != 1) )
                    // this product had not been installed by Windows Installer
                    continue;
                else
                    fUserDataFound = true;

                TCHAR szPath[MAX_PATH] = {0};
                TCHAR* rgpszPackageTypes[] = {TEXT("LocalPackage"),
                                              TEXT("ManagedLocalPackage"),
                                              NULL};
                for (int i = 0; rgpszPackageTypes[i]; i++)
                {
                    cb = sizeof(szPath);
                    lError = RegQueryValueEx(hUserProductKey,
                                             rgpszPackageTypes[i], 0,
                                             &dwType, (LPBYTE)szPath, &cb);
                    if ( lError == ERROR_SUCCESS && dwType == REG_SZ )
                        break;
                }
                if ( *szPath )
                {
                    // OK, we have a path in hand: we 'memorize' it and try
                    // to learn new extensions
                    bool fLearn = LearnPathAndExtension(szPath,
                            rgpszReferencedFiles, cReferencedFiles,
                            rgpszExtensions, cExtensions);
                    if ( !fLearn )
                    {
                        fError = true;
                        goto Return;
                    }
                }
                if ( !g_fWin9X && *rgchMsiDirectory )
                {
                    // let's take a peek at cached secure transforms
                    wsprintf(szKey, TEXT("%s\\Transforms"), szProduct);
                    CRegHandle hTransforms;
                    lError = RegOpen64bitKey(hProductsKey, szKey, 0,
                                             KEY_READ, &hTransforms);
                    if ( lError != ERROR_SUCCESS )
                    {
                        if ( lError != ERROR_FILE_NOT_FOUND )
                        {
                            _tprintf(TEXT("   Error opening %s subkey of Products key for %s user. Error: %d.\n"),
                                     szKey, szUser, lError);
                            fError = true;
                        }
                        continue;
                    }
                    TCHAR rgchFullPath[MAX_PATH];
                    _tcscpy(rgchFullPath, rgchMsiDirectory);
                    int iLen = _tcsclen(rgchFullPath); // 'strlen'
                    if ( rgchFullPath[iLen-1] != TEXT('\\') )
                        _tcscat(rgchFullPath, TEXT("\\")); // 'strcat'
                    TCHAR* pszEnd = _tcsrchr(rgchFullPath, TEXT('\\'));
                    pszEnd++;

                    TCHAR rgchDummy[MAX_PATH];
                    DWORD dwDummy = sizeof(rgchDummy)/sizeof(TCHAR);
                    cb = sizeof(szPath);
                    DWORD dwType;
                    for (i = 0;
                         (lError = RegEnumValue(hTransforms, i++, rgchDummy, &dwDummy,
                                    0, &dwType, (LPBYTE)szPath, &cb)) == ERROR_SUCCESS;
                         i++, cb = sizeof(szPath), dwDummy = sizeof(rgchDummy)/sizeof(TCHAR))
                    {
                        if ( *szPath && dwType == REG_SZ )
                        {
                            _tcscpy(pszEnd, szPath); // 'strcpy'
                            bool fLearn = LearnPathAndExtension(rgchFullPath,
                                                    rgpszReferencedFiles,
                                                    cReferencedFiles,
                                                    rgpszExtensions,
                                                    cExtensions);
                            if ( !fLearn )
                            {
                                fError = true;
                                goto Return;
                            }
                        }
                    }
                    if (ERROR_NO_MORE_ITEMS != lError)
                    {
                        _tprintf(TEXT("   Error enumerating %s key for %s user. Error: %d.\n"),
                                 szKey, szUser, lError);
                        fError = true;
                    }
                }
            }
            if (ERROR_NO_MORE_ITEMS != lError)
            {
                _tprintf(TEXT("   Error enumerating Products key for %s user. Error: %d.\n"),
                         szUser, lError);
                fError = true;
            }
Patches:
            // 1.1.1.2. For each user we enumerate patches and 'memorize'
            //          the paths to the cached packages.
            wsprintf(rgchBuffer, TEXT("%s\\Patches"), szUser);
            CRegHandle hPatchesKey;
            lError = RegOpen64bitKey(hKey, rgchBuffer,
                                     0, KEY_READ, &hPatchesKey);
            if ( lError != ERROR_SUCCESS )
            {
                if ( lError != ERROR_FILE_NOT_FOUND )
                {
                    _tprintf(TEXT("   Error opening HKLM\\...\\Installer\\UserData\\%s\\Patches key. Error: %d.\n"),
                             szUser, lError);
                    fError = true;
                }
                continue;
            }
            TCHAR szPatch[MAX_PATH];
            DWORD cchPatch = sizeof(szPatch)/sizeof(TCHAR);
            for ( int iPatchIndex = 0;
                  (lError = RegEnumKeyEx(hPatchesKey, iPatchIndex,
                                         szPatch, &cchPatch, 0, 0, 0, 0)) == ERROR_SUCCESS;
                  iPatchIndex++, cchPatch = sizeof(szPatch)/sizeof(TCHAR) )
            {
                CRegHandle hPatchKey;
                lError = RegOpen64bitKey(hPatchesKey, szPatch, 0,
                                         KEY_READ, &hPatchKey);
                if ( lError != ERROR_SUCCESS )
                {
                    _tprintf(TEXT("   Error opening %s subkey of HKLM\\...\\Installer\\UserData\\%s\\Patches key. Error: %d.\n"),
                             szPatch, szUser, lError);
                    fError = true;
                    continue;
                }
                fUserDataFound = true;
                DWORD dwType;
                DWORD cb = sizeof(rgchBuffer);
                *rgchBuffer = NULL;
                lError = RegQueryValueEx(hPatchKey,
                                         TEXT("LocalPackage"), 0,
                                         &dwType, (LPBYTE)rgchBuffer, &cb);
                if ( lError == ERROR_SUCCESS && dwType == REG_SZ && *rgchBuffer )
                {
                    if ( !LearnPathAndExtension(rgchBuffer,
                                                rgpszReferencedFiles,
                                                cReferencedFiles,
                                                rgpszExtensions,
                                                cExtensions) )
                    {
                        fError = true;
                        goto Return;
                    }
                }
            }
            if (ERROR_NO_MORE_ITEMS != lError)
            {
                _tprintf(TEXT("   Error enumerating Patches key for %s user. Error: %d.\n"),
                         szUser, lError);
                fError = true;
            }
        }
        if (ERROR_NO_MORE_ITEMS != lError)
        {
            _tprintf(TEXT("   Error enumerating user IDs. Error: %d.\n"), lError);
            fError = true;
        }
    }
    else if ( lError != ERROR_FILE_NOT_FOUND )
    {
        _tprintf(TEXT("   Error opening HKLM\\...\\Installer\\UserData key. Error: %d.\n"),
                 lError);
        fError = true;
    }

    // 1.2. we go through old, non-user-migrated configuration data.
    lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"),
                0, KEY_READ, &hKey);
    if ( lError == ERROR_SUCCESS )
    {
        TCHAR szProduct[MAX_PATH];
        DWORD cchProduct = sizeof(szProduct)/sizeof(TCHAR);
        // 1.2.1. We enumerate products and check if they'd
        //        been installed with Windows Installer
        for ( int iProdIndex = 0;
              (lError = RegEnumKeyEx(hKey, iProdIndex,
                                     szProduct, &cchProduct, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iProdIndex++, cchProduct = sizeof(szProduct)/sizeof(TCHAR) )
        {
            CRegHandle hProductKey;
            lError = RegOpen64bitKey(hKey, szProduct, 0,
                                     KEY_READ, &hProductKey);
            if ( lError != ERROR_SUCCESS )
            {
                _tprintf(TEXT("   Error opening %s subkey of HKLM\\...\\CurrentVersion\\Uninstall key. Error: %d.\n"),
                         szProduct, lError);
                fError = true;
                continue;
            }

            DWORD dwType;
            DWORD dwValue;
            DWORD cb = sizeof(DWORD);
            lError = RegQueryValueEx(hProductKey,
                                     TEXT("WindowsInstaller"), 0,
                                     &dwType, (LPBYTE)&dwValue, &cb);
            if ( lError != ERROR_SUCCESS || (dwType == REG_DWORD && dwValue != 1) )
                // this product had not been installed by the Windows Installer
                continue;

            TCHAR szPath[MAX_PATH] = {0};
            TCHAR* rgpszPackageTypes[] = {TEXT("LocalPackage"),
                                          TEXT("ManagedLocalPackage"),
                                          NULL};
            for (int i = 0; rgpszPackageTypes[i]; i++)
            {
                cb = sizeof(szPath);
                lError = RegQueryValueEx(hProductKey,
                                         rgpszPackageTypes[i], 0,
                                         &dwType, (LPBYTE)szPath, &cb);
                if ( lError == ERROR_SUCCESS && dwType == REG_SZ )
                    break;
            }
            if ( !*szPath )
                continue;

            // OK, we have a path in hand: we 'memorize' it and try
            // to learn new extensions
            bool fLearn = LearnPathAndExtension(szPath,
                                rgpszReferencedFiles, cReferencedFiles,
                                rgpszExtensions, cExtensions);
            if ( !fLearn )
            {
                fError = true;
                goto Return;
            }
        }
        if (ERROR_NO_MORE_ITEMS != lError)
        {
            _tprintf(TEXT("   Error enumerating Products key under HKLM\\...\\Uninstall key. Error: %d.\n"),
                     lError);
            fError = true;
        }
    }
    else if ( lError != ERROR_FILE_NOT_FOUND )
    {
        _tprintf(TEXT("   Error opening HKLM\\...\\CurrentVersion\\Uninstall key. Error: %d.\n"),
                 lError);
        fError = true;
    }

    // 1.3. we go through some other old, pre-per-user-migrated configuration data.
    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages"),
                            0, KEY_READ, &hKey)) == ERROR_SUCCESS)
    {
        TCHAR szProduct[MAX_PATH];
        DWORD cchProduct = sizeof(szProduct)/sizeof(TCHAR);
        // 1.3.1. We enumerate the products.
        for ( int iProdIndex = 0;
              (lError = RegEnumKeyEx(hKey, iProdIndex,
                                     szProduct, &cchProduct, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iProdIndex++, cchProduct = sizeof(szProduct)/sizeof(TCHAR) )
        {
            CRegHandle hProductKey;
            lError = RegOpen64bitKey(hKey, szProduct, 0,
                                     KEY_READ, &hProductKey);
            if ( lError != ERROR_SUCCESS )
            {
                _tprintf(TEXT("   Error opening %s subkey of HKLM\\...\\Installer\\LocalPackages key. Error: %d.\n"),
                         szProduct, lError);
                fError = true;
                continue;
            }

            int iValueIndex = 0;
            DWORD dwType;
            TCHAR szPackage[MAX_PATH] = {0};
            DWORD cbPackage = sizeof(szPackage);
            TCHAR rgchDummy[MAX_PATH] = {0};
            DWORD dwDummy = sizeof(rgchDummy)/sizeof(TCHAR);

            // 1.3.1.1. we enumerate packages within product
            while (ERROR_SUCCESS == (lError = RegEnumValue(hProductKey,
                                                iValueIndex++,
                                                rgchDummy, &dwDummy,
                                                0, &dwType,
                                                (LPBYTE)szPackage, &cbPackage)))
            {
                // OK, we have a path in hand: we 'memorize' it and try
                // to learn new extensions
                bool fLearn = LearnPathAndExtension(szPackage,
                                    rgpszReferencedFiles, cReferencedFiles,
                                    rgpszExtensions, cExtensions);
                if ( !fLearn )
                {
                    fError = true;
                    goto Return;
                }
                dwDummy = sizeof(rgchDummy)/sizeof(TCHAR);
                cbPackage = sizeof(szPackage);
            }
            if (ERROR_NO_MORE_ITEMS != lError)
            {
                _tprintf(TEXT("   Error enumerating %s subkey of HKLM\\...\\Installer\\LocalPackages key. Error: %d.\n"),
                         szProduct, lError);
                fError = true;
            }
        }
        if (ERROR_NO_MORE_ITEMS != lError)
        {
            _tprintf(TEXT("   Error enumerating Products key under ")
                     TEXT("HKLM\\...\\Installer\\LocalPackages key. Error: %d.\n"),
                     lError);
            fError = true;
        }
    }
    else if ( lError != ERROR_FILE_NOT_FOUND )
    {
        _tprintf(TEXT("   Error opening HKLM\\...\\CurrentVersion\\Installer\\LocalPackages key. Error: %d.\n"),
                 lError);
        fError = true;
    }

    // 1.4. we go through some old registry location where info about patches
    //      used to be stored.
    lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches"),
                0, KEY_READ, &hKey);
    if ( lError == ERROR_SUCCESS )
    {
        TCHAR szPatch[MAX_PATH];
        DWORD cchPatch = sizeof(szPatch)/sizeof(TCHAR);
        // 1.4.1. We enumerate patches and look for LocalPackage value
        for ( int iPatchIndex = 0;
              (lError = RegEnumKeyEx(hKey, iPatchIndex,
                                     szPatch, &cchPatch, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iPatchIndex++, cchPatch = sizeof(szPatch)/sizeof(TCHAR) )
        {
            CRegHandle hPatchKey;
            lError = RegOpen64bitKey(hKey, szPatch, 0,
                                     KEY_READ, &hPatchKey);
            if ( lError != ERROR_SUCCESS )
            {
                _tprintf(TEXT("   Error opening %s subkey of HKLM\\...\\Installer\\Patches key. Error: %d.\n"),
                         szPatch, lError);
                fError = true;
                continue;
            }
            DWORD dwType;
            DWORD cchPatch = sizeof(szPatch);
            lError = RegQueryValueEx(hPatchKey,
                                     TEXT("LocalPackage"), 0,
                                     &dwType, (LPBYTE)szPatch, &cchPatch);
            if ( lError == ERROR_SUCCESS && dwType == REG_SZ && *szPatch )
            {
                if ( !LearnPathAndExtension(szPatch,
                                            rgpszReferencedFiles,
                                            cReferencedFiles,
                                            rgpszExtensions,
                                            cExtensions) )
                {
                    fError = true;
                    goto Return;
                }
            }
        }
        if (ERROR_NO_MORE_ITEMS != lError)
        {
            _tprintf(TEXT("   Error enumerating Patches under HKLM\\...\\Installer\\Patches key. Error: %d.\n"),
                     lError);
            fError = true;
        }
    }
    else if ( lError != ERROR_FILE_NOT_FOUND )
    {
        _tprintf(TEXT("   Error opening HKLM\\...\\CurrentVersion\\Installer\\Patches key. Error: %d.\n"),
                 lError);
        fError = true;
    }

    // 2. we figure out the folders where cached files reside
    
    // 2.1. we figure out folders we know we are/had been using
    TCHAR szFolder[2*MAX_PATH+1];
    if ( *rgchMsiDirectory )
    {
        if ( !LearnNewString(rgchMsiDirectory, rgpszFolders, cFolders, true) )
        {
            fError = true;
            goto Return;
        }
        _tcscpy(szFolder, rgchMsiDirectory);
        TCHAR* pszEnd = _tcsrchr(szFolder, TEXT('\\')); // 'strrchr'
        if ( pszEnd )
        {
            _tcscpy(pszEnd, TEXT("\\Msi")); // 'strcpy'
            if ( !LearnNewString(szFolder, rgpszFolders, cFolders, true) )
            {
                fError = true;
                goto Return;
            }
        }
    }
    if ( GetEnvironmentVariable(TEXT("USERPROFILE"), szFolder, sizeof(szFolder)/sizeof(TCHAR)) )
    {
        _tcscat(szFolder, TEXT("\\Msi")); // 'strcat'
        if ( !LearnNewString(szFolder, rgpszFolders, cFolders, true) )
        {
            fError = true;
            goto Return;
        }
    }
    *szFolder = NULL;
    IMalloc* piMalloc = 0;
    LPITEMIDLIST pidlFolder; // NOT ITEMIDLIST*, LPITEMIDLIST is UNALIGNED ITEMIDLIST*
    if (SHGetMalloc(&piMalloc) == NOERROR)
    {
        if (SHGetSpecialFolderLocation(0, CSIDL_APPDATA, &pidlFolder) == NOERROR)
        {
            if (SHGetPathFromIDList(pidlFolder, szFolder))
            {
                // it's safer not to try to guess locations for other users
                // so we check these folders only for the current user.
                if (szFolder[_tcsclen(szFolder) - 1] != TEXT('\\')) // 'strlen'
                {
                    _tcscat(szFolder, TEXT("\\")); // 'strcat'
                }

                _tcscat(szFolder, TEXT("Microsoft\\Installer")); // 'strcat'
            }
            piMalloc->Free(pidlFolder);
        }
        piMalloc->Release();
        piMalloc = 0;
    }
    if ( *szFolder && !LearnNewString(szFolder, rgpszFolders, cFolders, true) )
    {
        fError = true;
        goto Return;
    }

    if ( cReferencedFiles )
    {
        // 2.2. we go through the list of cached files and try to learn
        //      some new folders
        for (int i = 0; i < cReferencedFiles; i++)
        {
            TCHAR* pszDelim = _tcsrchr(rgpszReferencedFiles[i], TEXT('\\')); // 'strrchr'
            if ( !pszDelim )
                continue;
            INT_PTR iLen = pszDelim - rgpszReferencedFiles[i];
            _tcsnccpy(szFolder, rgpszReferencedFiles[i], iLen);
            szFolder[iLen] = 0;
            if ( !LearnNewString(szFolder, rgpszFolders, cFolders, true) )
            {
                fError = true;
                goto Return;
            }
        }
    }

#ifdef DEBUG
    TCHAR rgchBuffer[MAX_PATH];
    if ( cReferencedFiles )
    {

        OutputDebugString(TEXT("MsiZap info: the cached files below were found in the registry. ")
                          TEXT(" These files will not be removed.\n"));
        for (int i = 0; i < cReferencedFiles; i++)
        {
            wsprintf(rgchBuffer, TEXT("   %s\n"), rgpszReferencedFiles[i]);
            OutputDebugString(rgchBuffer);
        }
    }
    else
        OutputDebugString(TEXT("MsiZap info: no cached files were found in the registry.\n"));
    OutputDebugString(TEXT("MsiZap info: cached files with the following extensions will be removed:\n"));
    for (int i = 0; i < cExtensions; i++)
    {
        wsprintf(rgchBuffer, TEXT("   %s\n"), rgpszExtensions[i]);
        OutputDebugString(rgchBuffer);
    }
    OutputDebugString(TEXT("MsiZap info: cached files will be removed from the following directories:\n"));
    for (int i = 0; i < cFolders; i++)
    {
        wsprintf(rgchBuffer, TEXT("   %s\n"), rgpszFolders[i]);
        OutputDebugString(rgchBuffer);
    }
#endif

    // 3.  we go through the constructed list of folders, we look for files
    //     with extensions in the constructed array of extensions and we
    //     delete all files we find on the disk that are not present in the
    //     registry (files that are not present in rgpszReferencedFiles array)
    for (UINT iF = 0; iF < cFolders; iF++)
    {
        for (UINT iE = 0; iE < cExtensions; iE++)
        {
            _tcscpy(szFolder, rgpszFolders[iF]); // 'strcpy'
            if ( szFolder[_tcsclen(szFolder)] != TEXT('\\') ) // 'strlen'
                _tcscat(szFolder, TEXT("\\")); // 'strcat'
            _tcscat(szFolder, TEXT("*"));
            TCHAR* pszDelim = _tcsrchr(szFolder, TEXT('*')); // 'strrchr'
            _tcscat(szFolder, rgpszExtensions[iE]);
            DWORD dwError = ERROR_SUCCESS;
            WIN32_FIND_DATA FindFileData;
            HANDLE hHandle = FindFirstFile(szFolder, &FindFileData);
            if ( hHandle == INVALID_HANDLE_VALUE )
            {
                dwError = GetLastError();
                if ( dwError != ERROR_FILE_NOT_FOUND &&
                     dwError != ERROR_PATH_NOT_FOUND )
                {
                    _tprintf(TEXT("   Could not find any \'%s\' files. GetLastError returns: %d.\n"),
                             szFolder, dwError);
                }
                continue;
            }
            BOOL fFound;
            do
            {
                if ( (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) !=
                     FILE_ATTRIBUTE_DIRECTORY)
                {
                    _tcscpy(pszDelim, FindFileData.cFileName);
                    // OK, we have the full file name, now we need to check
                    // if it is a known file.
                    if ( !IsStringInArray(szFolder, rgpszReferencedFiles) )
                    {
                        if ( !RemoveFile(szFolder, false) )
                            fError = true;
                    }
                }
                fFound = FindNextFile(hHandle, &FindFileData);
                if ( !fFound &&
                     (dwError = GetLastError()) != ERROR_NO_MORE_FILES )
                {
                    _tprintf(TEXT("   Could not find any more \'%s\' files. GetLastError returns: %d.\n"),
                             szFolder, dwError);
                }
            } while( fFound );
            FindClose(hHandle);
        }
    }

Return:
    for (i = 0; i < rgpszExtensions.GetSize(); i++)
        if ( rgpszExtensions[i] )
            free(rgpszExtensions[i]);
    for (i = 0; i < rgpszReferencedFiles.GetSize(); i++)
        if ( rgpszReferencedFiles[i] )
            free(rgpszReferencedFiles[i]);
    for (i = 0; i < rgpszFolders.GetSize(); i++)
        if ( rgpszFolders[i] )
            free(rgpszFolders[i]);

    return !fError;
}


//==============================================================================================
// StopService function:
//   Queries the Service Control Manager for MsiServer (Windows Installer Service) and
//    attempts to stop the service if currently running
//
bool StopService()
{
    SERVICE_STATUS          ssStatus;       // current status of the service

    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    int iRetval = ERROR_SUCCESS;

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (schSCManager)
    {
        schService = OpenService(schSCManager, TEXT("MsiServer"), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if (ControlService(schService, SERVICE_CONTROL_STOP, &ssStatus))
            {
                 Sleep(1000);
                 while (QueryServiceStatus(schService, &ssStatus))
                 {
                      if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING)
                            Sleep(1000);
                      else
                            break;
                 }
                
                 if (ssStatus.dwCurrentState != SERVICE_STOPPED)
                    iRetval = E_FAIL; //??
            }
            else // control service may have failed because service was already stopped
            {
                iRetval = GetLastError();

                if (ERROR_SERVICE_NOT_ACTIVE == iRetval)
                    iRetval = ERROR_SUCCESS;
            }

            CloseServiceHandle(schService);
        }
        else // !schService
        {
            iRetval = GetLastError();
            if (ERROR_SERVICE_DOES_NOT_EXIST == iRetval)
                iRetval = ERROR_SUCCESS;

        }

        CloseServiceHandle(schSCManager);
    }
    else // !schSCManager
    {
        iRetval = GetLastError();
    }
    
    if (iRetval != ERROR_SUCCESS)
        _tprintf(TEXT("Could not stop Msi service: Error %d\n"), iRetval);
    return iRetval == ERROR_SUCCESS;
}

//==============================================================================================
// GetAdminSid function:
//   Allocates a sid for the BUILTIN\Administrators group
//
DWORD GetAdminSid(char** pSid)
{
    static bool fSIDSet = false;
    static char rgchStaticSID[256];
    const int cbStaticSID = sizeof(rgchStaticSID);
    SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
    PSID pSID;
    if (!AllocateAndInitializeSid(&siaNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, (void**)&(pSID)))
        return GetLastError();

    //Assert(pSID->GetLengthSid() <= cbStaticSID);
    memcpy(rgchStaticSID, pSID, GetLengthSid(pSID));
    *pSid = rgchStaticSID;
    fSIDSet = true;
    return ERROR_SUCCESS;
}

//==============================================================================================
// OpenUserToken function:
//   Returns the user's thread token if available; otherwise, it obtain's the user token from
//    the process token
//
DWORD OpenUserToken(HANDLE &hToken, bool* pfThreadToken)
{
    DWORD dwResult = ERROR_SUCCESS;
    if (pfThreadToken)
        *pfThreadToken = true;

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE|TOKEN_QUERY, TRUE, &hToken))
    {
        // if the thread has no access token then use the process's access token
        dwResult = GetLastError();
        if (pfThreadToken)
            *pfThreadToken = false;
        if (ERROR_NO_TOKEN == dwResult)
        {
            dwResult = ERROR_SUCCESS;
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE|TOKEN_QUERY, &hToken))
                dwResult = GetLastError();
        }
    }
    return dwResult;
}

//==============================================================================================
// GetCurrentUserToken function:
//  Obtains the current user token -- either from the thread token or the process token.
//   Wrapper around OpenUserToken
//
DWORD GetCurrentUserToken(HANDLE &hToken)
{
    DWORD dwRet = ERROR_SUCCESS;
    dwRet = OpenUserToken(hToken);
    return dwRet;
}

//==============================================================================================
// GetStringSID function:
//  Converts a binary SID into its string from (S-n-...). szSID should be length of cchMaxSID
//
void GetStringSID(PISID pSID, TCHAR* szSID)
{
    TCHAR Buffer[cchMaxSID];
    
    wsprintf(Buffer, TEXT("S-%u-"), (USHORT)pSID->Revision);

    lstrcpy(szSID, Buffer);

    if (  (pSID->IdentifierAuthority.Value[0] != 0)  ||
            (pSID->IdentifierAuthority.Value[1] != 0)     )
    {
        wsprintf(Buffer, TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                     (USHORT)pSID->IdentifierAuthority.Value[0],
                     (USHORT)pSID->IdentifierAuthority.Value[1],
                    (USHORT)pSID->IdentifierAuthority.Value[2],
                    (USHORT)pSID->IdentifierAuthority.Value[3],
                    (USHORT)pSID->IdentifierAuthority.Value[4],
                    (USHORT)pSID->IdentifierAuthority.Value[5] );
        lstrcat(szSID, Buffer);

    } else {

        ULONG Tmp = (ULONG)pSID->IdentifierAuthority.Value[5]          +
              (ULONG)(pSID->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(pSID->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(pSID->IdentifierAuthority.Value[2] << 24);
        wsprintf(Buffer, TEXT("%lu"), Tmp);
        lstrcat(szSID, Buffer);
    }

    for (int i=0;i<pSID->SubAuthorityCount ;i++ ) {
        wsprintf(Buffer, TEXT("-%lu"), pSID->SubAuthority[i]);
        lstrcat(szSID, Buffer);
    }
}

//==============================================================================================
// GetUserSID function:
//  Obtains the (binary form of the) SID for the user specified by hToken
//
DWORD GetUserSID(HANDLE hToken, char* rgSID)
{
    UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG ReturnLength;

    BOOL f = GetTokenInformation(hToken,
                                                TokenUser,
                                                TokenInformation,
                                                sizeof(TokenInformation),
                                                &ReturnLength);

    if(f == FALSE)
    {
        DWORD dwRet = GetLastError();
        return dwRet;
    }

    PISID iSid = (PISID)((PTOKEN_USER)TokenInformation)->User.Sid;
    if (CopySid(cbMaxSID, rgSID, iSid))
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

//==============================================================================================
// GetCurrentUserSID function:
//  Obtains the (binary form of the) SID for the current user. Caller does NOT need to
//   impersonate
//
DWORD GetCurrentUserSID(char* rgchSID)
{
    HANDLE hToken;
    DWORD dwRet = ERROR_SUCCESS;

    dwRet = GetCurrentUserToken(hToken);
    if (ERROR_SUCCESS == dwRet)
    {
        dwRet = GetUserSID(hToken, rgchSID);
        CloseHandle(hToken);
    }
    return dwRet;
}

//==============================================================================================
// GetCurrentUserStringSID function:
//  Obtains the string from of the SID for the current user. Caller does NOT need to impersonate
//
inline TCHAR* GetCurrentUserStringSID(DWORD* dwReturn)
{
    DWORD dwRet = ERROR_SUCCESS;
    TCHAR *szReturn = NULL;

    if ( g_iUserIndex >= 0 && g_rgpszAllUsers )
        szReturn = g_rgpszAllUsers[g_iUserIndex];
    else
    {
        if ( !g_fWin9X )
        {
            static TCHAR szCurrentUserSID[cchMaxSID] = {0};
            if ( !*szCurrentUserSID )
            {
                char rgchSID[cbMaxSID];
                if (ERROR_SUCCESS == (dwRet = GetCurrentUserSID(rgchSID)))
                {
                    GetStringSID((PISID)rgchSID, szCurrentUserSID);
                }
            }
            szReturn = szCurrentUserSID;
        }
        else
        {
            static TCHAR szWin9xSID[] = TEXT("CommonUser");
            szReturn = szWin9xSID;
        }
    }

    if ( dwReturn )
        *dwReturn = dwRet;
    return szReturn;
}

//==============================================================================================
// GetAdminFullControlSecurityDescriptor function:
//  Returns a full control ACL for BUILTIN\Administrators
//
DWORD GetAdminFullControlSecurityDescriptor(char** pSecurityDescriptor)
{
    static bool fDescriptorSet = false;
    static char rgchStaticSD[256];
    const int cbStaticSD = sizeof(rgchStaticSD);

    DWORD dwError;
    if (!fDescriptorSet)
    {

        char* pAdminSid;
        if (ERROR_SUCCESS != (dwError = GetAdminSid(&pAdminSid)))
            return dwError;
        
        const SID* psidOwner = (SID*)pAdminSid;

        DWORD dwAccessMask = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL;

        // Initialize our ACL

        const int cbAce = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD); // subtract ACE.SidStart from the size
        int cbAcl = sizeof (ACL);

        cbAcl += (2*GetLengthSid(pAdminSid) + 2*cbAce);

        const int cbDefaultAcl = 512; //??
        char rgchACL[cbDefaultAcl];

        if (!InitializeAcl ((ACL*) (char*) rgchACL, cbAcl, ACL_REVISION))
            return GetLastError();

        // Add an access-allowed ACE for each of our SIDs

        if (!AddAccessAllowedAce((ACL*) (char*) rgchACL, ACL_REVISION, (GENERIC_ALL), pAdminSid))
            return GetLastError();
        if (!AddAccessAllowedAce((ACL*) (char*) rgchACL, ACL_REVISION, (GENERIC_ALL), pAdminSid))
            return GetLastError();

        ACCESS_ALLOWED_ACE* pAce;
        if (!GetAce((ACL*)(char*)rgchACL, 0, (void**)&pAce))
            return GetLastError();

        pAce->Header.AceFlags = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;

        if (!GetAce((ACL*)(char*)rgchACL, 1, (void**)&pAce))
            return GetLastError();

        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE;

/*
   ACE1 (applies to files in the directory)
      ACE flags:   INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE
      Access Mask: DELETE | GENERIC_READ | GENERIC_WRITE |
                   GENERIC_EXECUTE
   ACE2 (applies to the directory and subdirectories)
      ACE flags:   CONTAINER_INHERIT_ACE
      Access Mask: DELETE | FILE_GENERIC_READ | FILE_GENERIC_WRITE |
                   FILE_GENERIC_EXECUTE
*/
        // Initialize our security descriptor,throw the ACL into it, and set the owner

        SECURITY_DESCRIPTOR sd;

        if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ||
            (!SetSecurityDescriptorDacl(&sd, TRUE, (ACL*) (char*) rgchACL, FALSE)) ||
            (!SetSecurityDescriptorOwner(&sd, (PSID)psidOwner, FALSE)))
        {
            return GetLastError();
        }

        DWORD cbSD = GetSecurityDescriptorLength(&sd);
        if (cbStaticSD < cbSD)
            return ERROR_INSUFFICIENT_BUFFER;

        MakeSelfRelativeSD(&sd, (char*)rgchStaticSD, &cbSD); //!! AssertNonZero
        fDescriptorSet = true;
    }

    *pSecurityDescriptor = rgchStaticSD;
    return ERROR_SUCCESS;
}

//==============================================================================================
// GetUsersToken function:
//  Returns the user's thread token if possible; otherwise obtains the user's process token.
//   Caller must impersonate!
//
bool GetUsersToken(HANDLE &hToken)
{
    bool fResult = true;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE|TOKEN_QUERY, &hToken))
        fResult = false;

    return fResult;
}

//==============================================================================================
// IsAdmin(): return true if current user is an Administrator (or if on Win95)
// See KB Q118626 
#define ADVAPI32_DLL TEXT("advapi32.dll")
#define ADVAPI32_CheckTokenMembership "CheckTokenMembership"
typedef BOOL (WINAPI *PFnAdvapi32CheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

bool IsAdmin(void)
{
	if(g_fWin9X)
		return true; // convention: always Admin on Win95
	
	// get the administrator sid		
	PSID psidAdministrators;
	SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
	if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&psidAdministrators))
		return false;

	// on NT5, use the CheckTokenMembershipAPI to correctly handle cases where
	// the Administrators group might be disabled. bIsAdmin is BOOL 
	BOOL bIsAdmin = FALSE;
	if (g_iMajorVersion >= 5) 
	{
		// CheckTokenMembership checks if the SID is enabled in the token. NULL for
		// the token means the token of the current thread. Disabled groups, restricted
		// SIDS, and SE_GROUP_USE_FOR_DENY_ONLY are all considered. If the function
		// returns false, ignore the result.
		HMODULE hAdvapi32 = 0;
		hAdvapi32 = LoadLibrary(ADVAPI32_DLL);
		if (hAdvapi32)
		{
			PFnAdvapi32CheckTokenMembership pfnAdvapi32CheckTokenMembership = (PFnAdvapi32CheckTokenMembership)GetProcAddress(hAdvapi32, ADVAPI32_CheckTokenMembership);
			if (pfnAdvapi32CheckTokenMembership)
			{
				if (!pfnAdvapi32CheckTokenMembership(NULL, psidAdministrators, &bIsAdmin))
					bIsAdmin = FALSE;
			}
			FreeLibrary(hAdvapi32);
			hAdvapi32 = 0;
		}
	}
	else
	{
		// NT4, check groups of user
		HANDLE hAccessToken;
		DWORD dwOrigInfoBufferSize = 1024;
		DWORD dwInfoBufferSize;
		UCHAR *pInfoBuffer = new UCHAR[dwOrigInfoBufferSize]; // may need to resize if TokenInfo too big
		if (!pInfoBuffer)
		{
			_tprintf(TEXT("Out of memory\n"));
			return false;
		}
		UINT x;

		if (OpenProcessToken(GetCurrentProcess(),TOKEN_READ,&hAccessToken))
		{
			bool bSuccess = false;
			bSuccess = GetTokenInformation(hAccessToken,TokenGroups,pInfoBuffer,
				dwOrigInfoBufferSize, &dwInfoBufferSize) == TRUE;

			if(dwInfoBufferSize > dwOrigInfoBufferSize)
			{
				delete [] pInfoBuffer;
				pInfoBuffer = new UCHAR[dwInfoBufferSize];
				if (!pInfoBuffer)
				{
					_tprintf(TEXT("Out of memory\n"));
					return false;
				}
				bSuccess = GetTokenInformation(hAccessToken,TokenGroups,pInfoBuffer,
					dwInfoBufferSize, &dwInfoBufferSize) == TRUE;
			}

			CloseHandle(hAccessToken);
			
			if (bSuccess)
			{
				PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)(UCHAR*)pInfoBuffer;
				for(x=0;x<ptgGroups->GroupCount;x++)
				{
					if( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
					{
						bIsAdmin = TRUE;
						break;
					}

				}
			}
		}

		if (pInfoBuffer)
		{
			delete [] pInfoBuffer;
			pInfoBuffer = 0;
		}
	}
	
	FreeSid(psidAdministrators);
	return bIsAdmin ? true : false;
}

//==============================================================================================
// AcquireTokenPrivilege function:
//  Acquires the requested privilege
//
bool AcquireTokenPrivilege(const TCHAR* szPrivilege)
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;
    // get the token for this process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        return false;
    // the the LUID for the shutdown privilege
    if (!LookupPrivilegeValue(0, szPrivilege, &tkp.Privileges[0].Luid))
        return CloseHandle(hToken), false;
    tkp.PrivilegeCount = 1; // one privilege to set
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    // get the shutdown privilege for this process
    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) 0, 0);
    // cannot test the return value of AdjustTokenPrivileges
    CloseHandle(hToken);
    if (GetLastError() != ERROR_SUCCESS)
        return false;
    return true;
}

//==============================================================================================
// IsGUID function:
//  Indicates whether or not the provided string is a valid GUID
//
BOOL IsGUID(const TCHAR* sz)
{
    return ( (lstrlen(sz) == 38) && 
             (sz[0] == '{') && 
             (sz[9] == '-') &&
             (sz[14] == '-') &&
             (sz[19] == '-') &&
             (sz[24] == '-') &&
             (sz[37] == '}')
             ) ? TRUE : FALSE;
}

//==============================================================================================
// GetSQUID function:
//  Converts the provided product code into a SQUID
//
void GetSQUID(const TCHAR* szProduct, TCHAR* szProductSQUID)
{
    TCHAR* pchSQUID = szProductSQUID;
    const unsigned char rgOrderGUID[32] = {8,7,6,5,4,3,2,1, 13,12,11,10, 18,17,16,15,
                                           21,20, 23,22, 26,25, 28,27, 30,29, 32,31, 34,33, 36,35}; 

    const unsigned char* pch = rgOrderGUID;
    while (pch < rgOrderGUID + sizeof(rgOrderGUID))
        *pchSQUID++ = szProduct[*pch++];
    *pchSQUID = 0;
}

//==============================================================================================
// TakeOwnershipOfFile function:
//  Attempts to give the admin ownership and full control of the file (or folder)
//
DWORD TakeOwnershipOfFile(const TCHAR* szFile, bool fFolder)
{
    DWORD lError = ERROR_SUCCESS;
	HANDLE hFile = INVALID_HANDLE_VALUE;
    if (AcquireTokenPrivilege(SE_TAKE_OWNERSHIP_NAME))
    {
		// open file with WRITE_DAC, WRITE_OWNER, and READ_CONTROL access
		DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
		if (fFolder)
			dwFlagsAndAttributes |= FILE_FLAG_BACKUP_SEMANTICS;
		hFile = CreateFile(szFile, READ_CONTROL | WRITE_DAC | WRITE_OWNER, FILE_SHARE_READ, NULL, OPEN_EXISTING, dwFlagsAndAttributes, NULL);
		if (INVALID_HANDLE_VALUE == hFile)
		{
			lError = GetLastError();
			_tprintf(TEXT("   Failed to access %s: %s. LastError %d\n"), fFolder ? TEXT("folder") : TEXT("file"), szFile, lError);
			return lError;
		}

		// add admin as owner and include admin full control in DACL
		if (ERROR_SUCCESS == (lError = AddAdminOwnership(hFile, SE_FILE_OBJECT)))
		{
			lError = AddAdminFullControl(hFile, SE_FILE_OBJECT);
		}
    }

    if (ERROR_SUCCESS == lError || ERROR_CALL_NOT_IMPLEMENTED == lError)
    {
        if (!SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL))
		{
			lError = GetLastError();
            _tprintf(TEXT("   Failed to set file attributes for %s: %s %d\n"), fFolder ? TEXT("folder") : TEXT("file"), szFile, lError);
		}
    }

	if (ERROR_SUCCESS != lError)
		_tprintf(TEXT("   Failed to take ownership of %s: %s %d\n"), fFolder ? TEXT("folder") : TEXT("file"), szFile, lError);
   
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return lError;
}

//==============================================================================================
// RemoveFile function:
//  Deletes a file or adjusts the ACLs on the file. If the 1st attempt to delete the file
//   fails, will attempt a 2nd time after having taken ownership
//
bool RemoveFile(TCHAR* szFilePath, bool fJustRemoveACLs)
{
	if (GetFileAttributes(szFilePath) == 0xFFFFFFFF && GetLastError() == ERROR_FILE_NOT_FOUND)
		return true; // nothing to do -- file does not exist

	DWORD dwRet = ERROR_SUCCESS;
	if (fJustRemoveACLs || !DeleteFile(szFilePath))
	{
		dwRet = TakeOwnershipOfFile(szFilePath, /*fFolder=*/false);
		if (!fJustRemoveACLs && !DeleteFile(szFilePath))
		{
			TCHAR szMsg[256];
			DWORD cchMsg = sizeof(szMsg)/sizeof(TCHAR);
			UINT uiLastErr = GetLastError();
			if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, uiLastErr, 0, szMsg, cchMsg, 0))
				_tprintf(TEXT("   Error %d attempting to delete file: '%s'\n"), uiLastErr, szFilePath);
			else
				_tprintf(TEXT("   Could not delete file: %s\n      %s\n"), szFilePath, szMsg);

			return false;
		}
	}

	if (ERROR_SUCCESS != dwRet)
	{
		_tprintf(fJustRemoveACLs ? TEXT("   Failed to remove ACL on file: %s\n") : TEXT("   Failed to remove file: %s\n"), szFilePath);
		return false;
	}

	// success!
	_tprintf(fJustRemoveACLs ? TEXT("   Removed ACL on file: %s\n") : TEXT("   Removed file: %s\n"), szFilePath);
	g_fDataFound = true;
	return true;
}

//==============================================================================================
// DeleteFolder function:
//  Deletes a folder and all files contained within the folder
//
BOOL DeleteFolder(TCHAR* szFolder, bool fJustRemoveACLs)
{
    TCHAR szSearchPath[MAX_PATH*3];
    TCHAR szFilePath[MAX_PATH*3];
    lstrcpy(szSearchPath, szFolder);
    lstrcat(szSearchPath, TEXT("\\*.*"));

    if (0xFFFFFFFF == GetFileAttributes(szFolder)/* && ERROR_FILE_NOT_FOUND == GetLastError()*/) // return TRUE if the folder isn't there
        return TRUE;

    WIN32_FIND_DATA fdFindData;
    HANDLE hFile = FindFirstFile(szSearchPath, &fdFindData);

    if ((hFile == INVALID_HANDLE_VALUE) && (ERROR_ACCESS_DENIED == GetLastError()))
    {
        TakeOwnershipOfFile(szFolder, /*fFolder=*/true);
        hFile = FindFirstFile(szSearchPath, &fdFindData);
    }
    
    if(hFile != INVALID_HANDLE_VALUE)
    {
        // may still only contain "." and ".."
        do
        {
            if((0 != lstrcmp(fdFindData.cFileName, TEXT("."))) &&
                (0 != lstrcmp(fdFindData.cFileName, TEXT(".."))))
            {
                lstrcpy(szFilePath, szFolder);
                lstrcat(szFilePath, TEXT("\\"));
                lstrcat(szFilePath, fdFindData.cFileName);
                if (GetFileAttributes(szFilePath) & FILE_ATTRIBUTE_DIRECTORY)
                {
                    if (!DeleteFolder(szFilePath, fJustRemoveACLs))
                        return FALSE;
                }
                else
                {
                    if (!RemoveFile(szFilePath, fJustRemoveACLs))
                        return FALSE;
                }
            }

        }
        while(FindNextFile(hFile, &fdFindData) == TRUE);
    }
    else if (ERROR_FILE_NOT_FOUND != GetLastError())
    {
        _tprintf(TEXT("   Error enumerating files in folder %s\n"), szFolder);
    }
    else
    {
        return TRUE;
    }
    
    FindClose(hFile);

	DWORD dwRet = ERROR_SUCCESS;
	if (fJustRemoveACLs || !RemoveDirectory(szFolder))
	{
		dwRet = TakeOwnershipOfFile(szFolder, /*fFolder=*/true);
		if (!fJustRemoveACLs && !RemoveDirectory(szFolder))
		{
			TCHAR szMsg[256];
			DWORD cchMsg = sizeof(szMsg)/sizeof(TCHAR);
			UINT uiLastErr = GetLastError();
			if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, uiLastErr, 0, szMsg, cchMsg, 0))
				_tprintf(TEXT("   Error %d attempting to delete folder: '%s'\n"), uiLastErr, szFolder);
			else
				_tprintf(TEXT("   Could not delete folder: %s\n      %s\n"), szFolder, szMsg);

			return FALSE;
		}
	}

	if (ERROR_SUCCESS != dwRet)
	{
		_tprintf(fJustRemoveACLs ? TEXT("   Failed to remove ACL on folder: %s\n") : TEXT("   Failed to remove folder: %s\n"), szFolder);
		return FALSE;
	}

	// success!
	_tprintf(fJustRemoveACLs ? TEXT("   Removed ACL on folder: %s\n") : TEXT("   Removed folder: %s\n"), szFolder);
	g_fDataFound = true;
	return TRUE;
}

//==============================================================================================
// AddAdminOwnership function:
//  Sets the BUILTIN\Administrators group as the owner of the provided object
//
DWORD AddAdminOwnership(HANDLE hObject, SE_OBJECT_TYPE ObjectType)
{
	DWORD dwRes = 0;
	SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
	PSID pAdminSID = NULL;

	// Create a SID for the BUILTIN\Administrators group.

	if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
					 SECURITY_BUILTIN_DOMAIN_RID,
					 DOMAIN_ALIAS_RID_ADMINS,
					 0, 0, 0, 0, 0, 0,
					 &pAdminSID) ) {
		dwRes = GetLastError();
		_tprintf(TEXT("   AllocateAndInitializeSid Error %u\n"), dwRes );
		return dwRes;
	}


	// Attach the admin sid as the object's owner

	dwRes = SetSecurityInfo(hObject, ObjectType, 
		  OWNER_SECURITY_INFORMATION,
		  pAdminSID, NULL, NULL, NULL);
	if (ERROR_SUCCESS != dwRes)  {
		if (pAdminSID)
			FreeSid(pAdminSID);
		_tprintf(TEXT("   SetSecurityInfo Error %u\n"), dwRes );
		return dwRes;
	}  

	if (pAdminSID)
		FreeSid(pAdminSID);

	return ERROR_SUCCESS;
}

//==============================================================================================
// MakeAdminRegKeyOwner function:
//  Sets the BUILTIN\Administrators group as the owner of the provided registry key
//
DWORD MakeAdminRegKeyOwner(HKEY hKey, TCHAR* szSubKey)
{
	CRegHandle HSubKey = 0;
	LONG lError = 0;

	// Open registry key with permission to change owner
	if (ERROR_SUCCESS != (lError = RegOpen64bitKey(hKey, szSubKey, 0, WRITE_OWNER, &HSubKey)))
	{
		_tprintf(TEXT("   Error %d opening subkey: '%s'\n"), szSubKey);
		return lError;
	}

	return AddAdminOwnership(HSubKey, SE_REGISTRY_KEY);
}

//==============================================================================================
// AddAdminFullControl function:
//  Includes admin full control (BUILTIN\Administrators group) in the current DACL on the
//   specified object (can be file or registry key)
//
DWORD AddAdminFullControl(HANDLE hObject, SE_OBJECT_TYPE ObjectType)
{
	DWORD dwRes = 0;
	PACL pOldDACL = NULL, pNewDACL = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;
	EXPLICIT_ACCESS ea;
	PSID pAdminSID = NULL;
	SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;

	// Get a pointer to the existing DACL.

	dwRes = GetSecurityInfo(hObject, ObjectType, 
		  DACL_SECURITY_INFORMATION,
		  NULL, NULL, &pOldDACL, NULL, &pSD);
	if (ERROR_SUCCESS != dwRes) {
		_tprintf( TEXT("   GetSecurityInfo Error %u\n"), dwRes );
		goto Cleanup; 
	}  

	// Create a SID for the BUILTIN\Administrators group.

	if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
					 SECURITY_BUILTIN_DOMAIN_RID,
					 DOMAIN_ALIAS_RID_ADMINS,
					 0, 0, 0, 0, 0, 0,
					 &pAdminSID) ) {
		dwRes = GetLastError();
		_tprintf( TEXT("   AllocateAndInitializeSid Error %u\n"), dwRes );
		goto Cleanup; 
	}

	// Initialize an EXPLICIT_ACCESS structure for an ACE.
	// The ACE will allow the Administrators group full access to the key.

	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = KEY_ALL_ACCESS;
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance= NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ea.Trustee.ptstrName  = (LPTSTR) pAdminSID;

	// Create a new ACL that merges the new ACE
	// into the existing DACL.

	dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
	if (ERROR_SUCCESS != dwRes)  {
		_tprintf( TEXT("   SetEntriesInAcl Error %u\n"), dwRes );
		goto Cleanup; 
	}  

	// Attach the new ACL as the object's DACL.

	dwRes = SetSecurityInfo(hObject, ObjectType, 
		  DACL_SECURITY_INFORMATION,
		  NULL, NULL, pNewDACL, NULL);
	if (ERROR_SUCCESS != dwRes)  {
		_tprintf( TEXT("   SetSecurityInfo Error %u\n"), dwRes );
		goto Cleanup; 
	}  

Cleanup:

	if(pSD != NULL) 
		LocalFree((HLOCAL) pSD); 
	if(pNewDACL != NULL) 
		LocalFree((HLOCAL) pNewDACL); 
	if (pAdminSID != NULL)
		FreeSid(pAdminSID);

	return dwRes;
}

//==============================================================================================
// AddAdminFullControlToRegKey function:
//  Includes admin full control (BUILTIN\Administrators group) in the current DACL on the
//   registry key
//
DWORD AddAdminFullControlToRegKey(HKEY hKey)
{
	return AddAdminFullControl(hKey, SE_REGISTRY_KEY);
}

//==============================================================================================
// DeleteTree function:
//  Deletes the key szSubKey and all subkeys and values beneath it
//
BOOL DeleteTree(HKEY hKey, TCHAR* szSubKey, bool fJustRemoveACLs)
{
    CRegHandle HSubKey;
    LONG lError;
    if ((lError = RegOpen64bitKey(hKey, szSubKey, 0, KEY_READ, &HSubKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND != lError)
        {
			_tprintf(TEXT("   Error %d attempting to open \\%s\n"), lError, szSubKey);
            return FALSE;
		}
        else
			return TRUE; // nothing to do
    }
    TCHAR szName[500];
    DWORD cbName = sizeof(szName)/sizeof(TCHAR);
    unsigned int iIndex = 0;
    while ((lError = RegEnumKeyEx(HSubKey, iIndex, szName, &cbName, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        if (!DeleteTree(HSubKey, szName, fJustRemoveACLs))
            return FALSE;

        if (fJustRemoveACLs)
            iIndex++;

        cbName = sizeof(szName)/sizeof(TCHAR);
    }

    if (lError != ERROR_NO_MORE_ITEMS)
	{
		_tprintf(TEXT("   Failed to enumerate all subkeys. Error: %d\n"), lError);
        return FALSE;
	}

    HSubKey = 0;

    if (fJustRemoveACLs || (ERROR_SUCCESS != (lError = RegDelete64bitKey(hKey, szSubKey))))
    {
        if (fJustRemoveACLs || (ERROR_ACCESS_DENIED == lError))
        {
            // see whether we're *really* denied access. 
            // give the admin ownership and full control of the key and try again to delete it
            if (AcquireTokenPrivilege(SE_TAKE_OWNERSHIP_NAME))
            {
				if (ERROR_SUCCESS != (lError = MakeAdminRegKeyOwner(hKey, szSubKey)))
				{
					_tprintf(TEXT("   Error %d setting BUILTIN\\Administrators as owner of key '%s'\n"), lError, szSubKey);
					if (fJustRemoveACLs)
						return FALSE;
				}
				else if (ERROR_SUCCESS == (lError = RegOpen64bitKey(hKey, szSubKey, 0, READ_CONTROL | WRITE_DAC, &HSubKey)))
				{
					if (ERROR_SUCCESS == (lError = AddAdminFullControlToRegKey(HSubKey)))
						_tprintf(TEXT("   ACLs changed to admin ownership and full control for key '%s'\n"), szSubKey);
					else
					{
						_tprintf(TEXT("   Unable to add admin full control to reg key '%s'. Error: %d\n"), szSubKey, lError);
						if (fJustRemoveACLs)
							return FALSE;
					}
					HSubKey = 0;
					if (!fJustRemoveACLs)
						lError = RegDelete64bitKey(hKey, szSubKey);
				}
				else
				{
					_tprintf(TEXT("   Error %d opening subkey: '%s'\n"), lError, szSubKey);
					HSubKey = 0;
				}
			}
        }

        if (ERROR_SUCCESS != lError && !fJustRemoveACLs)
        {
            TCHAR szMsg[256];
            DWORD cchMsg = sizeof(szMsg)/sizeof(TCHAR);
            if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, lError, 0, szMsg, cchMsg, 0))
                _tprintf(TEXT("   Error %d attempting to delete subkey: '%s'\n"), lError, szSubKey);
            else
                _tprintf(TEXT("   Could not delete subkey: %s\n      %s"), szSubKey, szMsg);

            return FALSE;
        }
    }

	// success!
    _tprintf(TEXT("   %s \\%s\n"), fJustRemoveACLs ? TEXT("Removed ACLs from") : TEXT("Removed "), szSubKey);
	g_fDataFound = true;
    return TRUE;
}

//==============================================================================================
// ClearWindowsUninstallKey function:
//  Removes all data for the product from the HKLM\SW\MS\Windows\CV\Uninstall key
//
bool ClearWindowsUninstallKey(bool fJustRemoveACLs, const TCHAR* szProduct)
{
	_tprintf(TEXT("Searching for product %s data in the HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall key. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    CRegHandle hUninstallKey;
    LONG lError;

    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"),
                            0, KEY_ALL_ACCESS, &hUninstallKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            return true;
        else
        {
            _tprintf(TEXT("   Could not open HKLM\\%s. Error: %d\n"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"), lError);
            return false;
        }
    }

    TCHAR szBuf[256];
    DWORD cbBuf = sizeof(szBuf)/sizeof(TCHAR);

    // for each product 
    int iIndex = 0;
    while ((lError = RegEnumKeyEx(hUninstallKey, iIndex, szBuf, &cbBuf, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        if (IsGUID(szBuf))
        {
            if (szProduct)
            {
                if (0 != lstrcmpi(szBuf, szProduct))
                {
                    iIndex++;
                    cbBuf = sizeof(szBuf);
                    continue;
                }
            }
 
			if (!DeleteTree(hUninstallKey, szBuf, fJustRemoveACLs))
                return false;
        
            if (fJustRemoveACLs)
                iIndex++;
        }
        else
        {
            iIndex++;
        }

        cbBuf = sizeof(szBuf)/sizeof(TCHAR);
    }
    return true;
}

//==============================================================================================
// IsProductInstalledByOthers function:
//  Returns whether another user has installed the specified product
//
bool IsProductInstalledByOthers(const TCHAR* szProductSQUID)
{
    CRegHandle hUserDataKey;

    bool fOtherUsers = false;
    // we look up the migrated per-user data key
    long lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData"),
                          0, KEY_READ, &hUserDataKey);
    if ( lError == ERROR_SUCCESS )
    {
        TCHAR szUser[MAX_PATH];
        DWORD cchUser = sizeof(szUser)/sizeof(TCHAR);
        for ( int iIndex = 0;
              (lError = RegEnumKeyEx(hUserDataKey, iIndex,
                                     szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
        {
            if ( lstrcmp(szUser, GetCurrentUserStringSID(NULL)) )
            {
                // it's a different user.  Check if [s]he has szProductSQUID product installed
                TCHAR szKey[MAX_PATH];
                wsprintf(szKey, TEXT("%s\\Products\\%s"), szUser, szProductSQUID);
                CRegHandle hDummy;
                if ( RegOpen64bitKey(hUserDataKey, szKey, 0, KEY_READ, &hDummy) == ERROR_SUCCESS )
                {
                    fOtherUsers = true;
                    break;
                }
            }
        }
    }

    if ( !fOtherUsers && 
         ERROR_SUCCESS == (lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed"),
                                        0, KEY_READ, &hUserDataKey)) )
    {
        // we look up the managed user key too.
        TCHAR szUser[MAX_PATH];
        DWORD cchUser = sizeof(szUser)/sizeof(TCHAR);
        for ( int iIndex = 0;
              (lError = RegEnumKeyEx(hUserDataKey, iIndex,
                                     szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
              iIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
        {
            if ( lstrcmp(szUser, GetCurrentUserStringSID(NULL)) )
            {
                // it's a different user.  Check if [s]he has szProductSQUID product installed
                TCHAR szKey[MAX_PATH];
                wsprintf(szKey, TEXT("%s\\Installer\\Products\\%s"), szUser, szProductSQUID);
                CRegHandle hDummy;
                if ( RegOpen64bitKey(hUserDataKey, szKey, 0, KEY_READ, &hDummy) == ERROR_SUCCESS )
                {
                    fOtherUsers = true;
                    break;
                }
            }
        }
    }

    return fOtherUsers;
}

//==============================================================================================
// ClearUninstallKey function:
//  Handles deletion of the uninstall key in all of the correct cases
//
bool ClearUninstallKey(bool fJustRemoveACLs, const TCHAR* szProduct)
{
	_tprintf(TEXT("Searching for install property data for product %s. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    LONG lError;
    TCHAR rgchKeyBuf[MAX_PATH];
    DWORD dwRes;
    CRegHandle hUserProductsKey;

    bool fNotPerUserMigrated = false;
    wsprintf(rgchKeyBuf,
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Products"),
        GetCurrentUserStringSID(&dwRes));
    if ( dwRes != ERROR_SUCCESS )
        return false;
    lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, rgchKeyBuf,
                          0, KEY_ALL_ACCESS, &hUserProductsKey);
    if ( lError != ERROR_SUCCESS )
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            fNotPerUserMigrated = true;
        else
        {
            _tprintf(TEXT("   Could not open HKLM\\%s. Error: %d\n"), rgchKeyBuf, lError);
            return false;
        }
    }

    if ( fNotPerUserMigrated )
        return ClearWindowsUninstallKey(fJustRemoveACLs, szProduct);

    // in the migrated-per-user-data world, we remove the ...\\CurrentVersion\\Uninstall entry
    // only if there are no more installations of szProduct.

    TCHAR szRegProduct[MAX_PATH];
    DWORD cchRegProduct = sizeof(szRegProduct)/sizeof(TCHAR);

    TCHAR szProductSQUID[40] = {0};
    if ( szProduct )
        GetSQUID(szProduct, szProductSQUID);

    bool fError = false;
    // for each product in hUserProductsKey
    for ( int iIndex = 0;
          (lError = RegEnumKeyEx(hUserProductsKey, iIndex, szRegProduct, &cchRegProduct, 0, 0, 0, 0)) == ERROR_SUCCESS;
          cchRegProduct = sizeof(szRegProduct)/sizeof(TCHAR), iIndex++ )
    {
        if (*szProductSQUID && 0 != lstrcmpi(szRegProduct, szProductSQUID))
            continue;

        TCHAR szUninstallData[MAX_PATH];
        wsprintf(szUninstallData, TEXT("%s\\InstallProperties"), szRegProduct);
        if (!DeleteTree(hUserProductsKey, szUninstallData, fJustRemoveACLs))
            return false;

        if ( !IsProductInstalledByOthers(szRegProduct) )
            fError |= !ClearWindowsUninstallKey(fJustRemoveACLs, szProduct);
    }

    return !fError;
}

bool GoOpenKey(HKEY hRoot, LPCTSTR szRoot, LPCTSTR szKey, REGSAM sam,
               CRegHandle& HKey, bool& fReturn)
{
    DWORD lResult = RegOpenKeyEx(hRoot, szKey, 0, sam, &HKey);
    if ( lResult == ERROR_SUCCESS )
    {
        fReturn = true;
        return true;
    }
    else
    {
        if ( lResult == ERROR_FILE_NOT_FOUND )
        {
            _tprintf(TEXT("   %s\\%s key is not present.\n"),
                     szRoot, szKey);
            fReturn = true;
        }
        else
        {
            _tprintf(TEXT("   Could not open %s\\%s. Error: %d\n"),
                    szRoot, szKey, lResult);
            fReturn = false;
        }
        return false;
    }
}

//==============================================================================================
// ClearSharedDLLCounts function:
//  Adjusts shared DLL counts for specified component of specified product
//
bool ClearSharedDLLCounts(TCHAR* szComponentsSubkey, const TCHAR* szProduct)
{
    _tprintf(TEXT("Searching for shared DLL counts for components tied to the product %s. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    CRegHandle HSubKey;
    CRegHandle HSharedDLLsKey;
    CRegHandle HSharedDLLsKey32;
    CRegHandle HComponentsKey;
    LONG lError;
    bool fError = false;
    bool fReturn;

    if ( !GoOpenKey(HKEY_LOCAL_MACHINE, TEXT("HKLM"), szComponentsSubkey,
                    KEY_READ | (g_fWinNT64 ? KEY_WOW64_64KEY : 0),
                    HComponentsKey, fReturn) )
        return fReturn;

    const TCHAR rgchSharedDll[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs");
    if ( g_fWinNT64 )
    {
        bool fRet1 = GoOpenKey(HKEY_LOCAL_MACHINE, TEXT("HKLM"), rgchSharedDll,
                               KEY_ALL_ACCESS | KEY_WOW64_64KEY, HSharedDLLsKey, fReturn);;
        bool fRet2 = GoOpenKey(HKEY_LOCAL_MACHINE, TEXT("HKLM32"), rgchSharedDll,
                               KEY_ALL_ACCESS | KEY_WOW64_32KEY, HSharedDLLsKey32, fReturn);
        if ( !fRet1 && !fRet2 )
            return false;
    }
    else
    {
        if ( !GoOpenKey(HKEY_LOCAL_MACHINE, TEXT("HKLM"), rgchSharedDll,
                        KEY_ALL_ACCESS, HSharedDLLsKey, fReturn) )
            return fReturn;
    }

    TCHAR szComponentCode[500];
    TCHAR szProductCode[40];
    TCHAR szKeyFile[MAX_PATH + 1];
    DWORD cbKeyFile = sizeof(szKeyFile);
    DWORD cbProductCode = sizeof(szProductCode)/sizeof(TCHAR);
    DWORD cbComponentCode = sizeof(szComponentCode)/sizeof(TCHAR);
    CRegHandle HComponentKey;

    // for each component 
    int iIndex = 0;
    while ((lError = RegEnumKeyEx(HComponentsKey, iIndex, szComponentCode, &cbComponentCode, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, KEY_READ, &HComponentKey);
        if (ERROR_SUCCESS == lError)
        {
            int iValueIndex = 0;
            DWORD dwType;
            while (ERROR_SUCCESS == (lError = RegEnumValue(HComponentKey, iValueIndex++, szProductCode, &cbProductCode,
                                  0, &dwType, (LPBYTE)(TCHAR*)szKeyFile, &cbKeyFile)))
            {
                if ((!szProduct || 0==lstrcmpi(szProductCode, szProduct)) && (szKeyFile[0] && szKeyFile[1] == '?'))
                {
                    szKeyFile[1] = ':';
                    ieFolderType iType = ieftNotSpecial;
                    if ( g_fWinNT64 )
                    {
                        int iIndex;
                        iType = IsInSpecialFolder(szKeyFile, &iIndex);
                        if ( iType == ieft32bit && iIndex == iefSystem )
                            // this is the 32-bit Syswow64 folder that
                            // gets recorded in the registry as System32,
                            // so we need to swap it.
                            SwapSpecialFolder(szKeyFile, iest32to64);
                    }
                    // on Win64, if we do not know that a file is in a
                    // definite 32 or 64-bit folder, we have no idea of
                    // its bitness, so we go and decrement its refcount
                    // in both SharedDll registry keys.
                    int iNumIter = g_fWinNT64 && iType == ieftNotSpecial ? 2 : 1;
                    for (int i = 0; i < iNumIter; i++)
                    {
                        HKEY hKey;
                        if ( g_fWinNT64 && (i == 0 || iType == ieft32bit) )
                            // it's either the first iteration on Win64 or the
                            // only one (since it's a known 32-bit file type)
                            hKey = HSharedDLLsKey32;
                        else
                            hKey = HSharedDLLsKey;
                        if ( !hKey )
                            continue;

                        DWORD dwRefCount;
                        DWORD cbRefCnt = sizeof(DWORD);
                        if (ERROR_SUCCESS == (lError = RegQueryValueEx(hKey, szKeyFile, 0, &dwType, (LPBYTE)&dwRefCount, &cbRefCnt)))
                        {
                            if (dwRefCount == 1)
                            {
                                lError = RegDeleteValue(hKey, szKeyFile);
                                if ( lError == ERROR_SUCCESS )
                                {
                                    g_fDataFound = true;
                                    _tprintf(TEXT("   Removed shared DLL entry: %s\n"), szKeyFile);
                                }
                                else
                                    _tprintf(TEXT("   Failed to remove shared DLL entry: %s. GetLastError returned %d.\n"),
                                             szKeyFile, GetLastError());
                            }
                            else
                            {
                                dwRefCount--;
                                lError = RegSetValueEx(hKey, szKeyFile, 0, REG_DWORD, (CONST BYTE*)&dwRefCount, cbRefCnt);
                                if ( lError == ERROR_SUCCESS )
                                {
                                    _tprintf(TEXT("   Reduced shared DLL count to %d for: %s\n"), dwRefCount, szKeyFile);
                                    g_fDataFound = true;
                                }
                                else
                                    _tprintf(TEXT("   Failed to reduce shared DLL count for: %s. GetLastError returned %d.\n"),
                                             szKeyFile, GetLastError());
                            }

                        }
                        else if (ERROR_FILE_NOT_FOUND != lError)
                        {
                            _tprintf(TEXT("   Error querying shared DLL key for client %s, keyfile %s\n"), szProductCode, szKeyFile);
                            fError = true;
                        }
                    }
                }
                cbProductCode = sizeof(szProductCode)/sizeof(TCHAR);
                cbKeyFile = sizeof(szKeyFile);
            }
            if (ERROR_NO_MORE_ITEMS != lError)
            {
                _tprintf(TEXT("   Error enumerating clients of component %s. Error: %d.\n"), szComponentCode, lError);
                fError = true;
            }
        }
        else
        {
            _tprintf(TEXT("   Error opening key for component %s. Error %d.\n"), szComponentCode, lError);
            fError = true;
        }

        cbComponentCode = sizeof(szComponentCode)/sizeof(TCHAR);
        iIndex++;
    }
    return fError == false;
}

//==============================================================================================
// ClearProductClientInfo function:
//
bool ClearProductClientInfo(TCHAR* szComponentsSubkey, const TCHAR *szProduct, bool fJustRemoveACLs)
{
	_tprintf(TEXT("  Searching for product %s client info data. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    CRegHandle HSubKey;
    CRegHandle HComponentsKey;
    LONG lError;
    bool fError = false;

    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, szComponentsSubkey, 0, KEY_READ, &HComponentsKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            return true;
        else
        {
            _tprintf(TEXT("   Could not open HKLM\\%s. Error: %d\n"), szComponentsSubkey, lError);
            return false;
        }
    }

    TCHAR szComponentCode[500];
    DWORD cbComponentCode = sizeof(szComponentCode)/sizeof(TCHAR);
    CRegHandle HComponentKey;

    // for each component 
    int iIndex = 0;
    while ((lError = RegEnumKeyEx(HComponentsKey, iIndex++, szComponentCode, &cbComponentCode, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        if (fJustRemoveACLs || (ERROR_SUCCESS != (lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, KEY_READ|KEY_WRITE, &HComponentKey))))
        {
                if (fJustRemoveACLs || (ERROR_ACCESS_DENIED == lError))
                {
                    if (!fJustRemoveACLs ||
                        ((ERROR_SUCCESS == (lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, KEY_READ, &HComponentKey)) &&
                         (ERROR_SUCCESS == (lError = RegQueryValueEx(HComponentKey, szProduct, 0, 0, 0, 0))))))
                    {
                        // see whether we're *really* denied access. 
                        // give the admin ownership and full control of the key and try again to delete it
                        char *pSecurityDescriptor;
                        if (AcquireTokenPrivilege(SE_TAKE_OWNERSHIP_NAME))
                        {
							if (ERROR_SUCCESS != (lError = MakeAdminRegKeyOwner(HComponentsKey, szComponentCode)))
							{
								_tprintf(TEXT("   Error %d setting BUILTIN\\Administrators as owner of key '%s'\n"), lError, szComponentCode);
								if (fJustRemoveACLs)
									return FALSE;
							}
							else if (ERROR_SUCCESS == (lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, READ_CONTROL | WRITE_DAC, &HSubKey)))
							{
								if (ERROR_SUCCESS == (lError = AddAdminFullControlToRegKey(HSubKey)))
									_tprintf(TEXT("   ACLs changed to admin ownership and full control for key '%s'\n"), szComponentCode);
								else
								{
									_tprintf(TEXT("   Failed to add admin full control to key '%s'. Error: %d\n"), szComponentCode, lError);
									if (fJustRemoveACLs)
										return FALSE;
								}
								HSubKey = 0;
								if (!fJustRemoveACLs)
									lError = RegOpen64bitKey(HComponentsKey, szComponentCode, 0, KEY_READ|KEY_WRITE, &HComponentKey);
							}
							else
							{
								_tprintf(TEXT("   Error %d opening subkey: '%s'\n"), lError, szComponentCode);
								HSubKey = 0;
							}
                        }
                    }
                }

        }

        if (ERROR_SUCCESS == lError && !fJustRemoveACLs)
            lError = RegDeleteValue(HComponentKey, szProduct);

        if (ERROR_SUCCESS == lError && !fJustRemoveACLs)
        {
            TCHAR sz[1];
            DWORD cch = 1;
            if (ERROR_NO_MORE_ITEMS == RegEnumValue(HComponentKey, 0, sz, &cch, 0, 0, 0, 0))
            {
                if (ERROR_SUCCESS == RegDelete64bitKey(HComponentsKey, szComponentCode))
                    iIndex--;
            }
        }

        if (ERROR_SUCCESS == lError)
        {
            if (fJustRemoveACLs)
                _tprintf(TEXT("   Removed ACLs for component %s\n"), szComponentCode);
            else
                _tprintf(TEXT("   Removed client of component %s\n"), szComponentCode);
			g_fDataFound = true;
        }
        else if (ERROR_FILE_NOT_FOUND != lError)
        {
            _tprintf(TEXT("   Error deleting client of component %s. Error: %d\n"), szComponentCode, lError);
            fError = true;
        }
        
        cbComponentCode = sizeof(szComponentCode)/sizeof(TCHAR);
    }
	if (ERROR_NO_MORE_ITEMS != lError)
	{
		_tprintf(TEXT("   Unable to enumerate all product client info. Error: %d\n"), lError);
		return false;
	}
    return fError == false;
}

//==============================================================================================
// ClearFolders function:
//
bool ClearFolders(int iTodo, const TCHAR* szProduct, bool fOrphan)
{
	_tprintf(TEXT("Searching for Installer files and folders associated with the product %s. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    bool fError          = false;
    bool fJustRemoveACLs = (iTodo & iOnlyRemoveACLs) != 0;
    
    TCHAR szFolder[2*MAX_PATH+1];

    if (iTodo & iRemoveUserProfileFolder)
    {
		_tprintf(TEXT("  Searching for files and folders in the user's profile. . .\n"));

        if (!szProduct)
        {
            // delete %USERPROFILE%\msi
            if (GetEnvironmentVariable(TEXT("USERPROFILE"), szFolder, sizeof(szFolder)/sizeof(TCHAR)))
            {
                lstrcat(szFolder, TEXT("\\Msi"));
                if (!DeleteFolder(szFolder, fJustRemoveACLs))
                    return false;
            }
        }

        // delete {AppData}\Microsoft\Installer
        if (!fOrphan)
        {
            IMalloc* piMalloc = 0;
            LPITEMIDLIST pidlFolder; // NOT ITEMIDLIST*, LPITEMIDLIST is UNALIGNED ITEMIDLIST*

            if (SHGetMalloc(&piMalloc) == NOERROR)
            {
                if (SHGetSpecialFolderLocation(0, CSIDL_APPDATA, &pidlFolder) == NOERROR)
                {
                    if (SHGetPathFromIDList(pidlFolder, szFolder))
                    {
                        if (szFolder[lstrlen(szFolder) - 1] != '\\')
                        {
                            lstrcat(szFolder, TEXT("\\"));
                        }

                        lstrcat(szFolder, TEXT("Microsoft\\Installer"));

                        if (szProduct)
                        {
                            lstrcat(szFolder, TEXT("\\"));
                            lstrcat(szFolder, szProduct);
                        }

                        if (!DeleteFolder(szFolder, fJustRemoveACLs))
                            return false;
                    }
                    piMalloc->Free(pidlFolder);
                }
                piMalloc->Release();
                piMalloc = 0;
            }
        }
    }

    if (iTodo & iRemoveWinMsiFolder)
    {
		_tprintf(TEXT("  Searching for files and folders in the %%WINDIR%%\\Installer folder\n"));

        if (!szProduct)
        {
            // delete %WINDIR%\msi
            if (GetWindowsDirectory(szFolder, sizeof(szFolder)/sizeof(TCHAR)))
            {
                lstrcat(szFolder, TEXT("\\Msi"));
                if (!DeleteFolder(szFolder, fJustRemoveACLs))
                    return false;
            }
        }

        // delete %WINDIR%\Installer
        if (!fOrphan && GetWindowsDirectory(szFolder, sizeof(szFolder)/sizeof(TCHAR)))
        {
            lstrcat(szFolder, TEXT("\\Installer"));
            if (szProduct)
            {
                lstrcat(szFolder, TEXT("\\"));
                lstrcat(szFolder, szProduct);
            }

            if (!DeleteFolder(szFolder, fJustRemoveACLs))
                return false;
        }


    }

    if (iTodo & iRemoveConfigMsiFolder)
    {
		_tprintf(TEXT("  Searching for rollback folders. . .\n"));

        // delete X:\config.msi for all local drives
        TCHAR szDrive[MAX_PATH];

        for (int iDrive = 0; iDrive < 26; iDrive++)
        {
            wsprintf(szDrive, TEXT("%c:\\"), iDrive+'A');
            if (DRIVE_FIXED == GetDriveType(szDrive))
            {
                wsprintf(szDrive, TEXT("%c:\\%s"), iDrive+'A', TEXT("config.msi"));
                if (!DeleteFolder(szDrive, fJustRemoveACLs))
                    return false;
            }
        }
    }
    return fError == false;
}

//==============================================================================================
// ClearPublishComponents function:
//
bool ClearPublishComponents(HKEY hKey, TCHAR* szSubKey, const TCHAR* szProduct)
{
	_tprintf(TEXT("  Searching %s for published component data for the product %s. . .\n"), szSubKey, szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    bool fError = false;

    // enumerate all keys beneath the Components key
    // subkeys are packed GUIDs of ComponentIds from PublishComponent table
    // values of the subkeys are {Qualifier}={multi-sz list of (DD + app data)}
    LONG lError,lError2;
    CRegHandle hComponentsKey;
    if ((lError = RegOpen64bitKey(hKey, szSubKey, 0, KEY_READ|KEY_SET_VALUE, &hComponentsKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            return true;
        return false;
    }

    TCHAR szPublishedComponent[40];
    DWORD cchPublishedComponent = sizeof(szPublishedComponent)/sizeof(TCHAR);

    DWORD dwValueLen;
    DWORD dwDataLen;
    DWORD dwType;

    TCHAR* szQualifier = NULL;
    LPTSTR lpData = NULL;
    TCHAR* pchData = NULL;

    TCHAR szPublishProductCode[40];

    int iIndex = 0;
    // for each published component
    while (!fError && ((lError = RegEnumKeyEx(hComponentsKey, iIndex, szPublishedComponent, &cchPublishedComponent, 0, 0, 0, 0)) == ERROR_SUCCESS))
    {
        // open the key
        CRegHandle hPubCompKey;
        if (ERROR_SUCCESS != (lError2 = RegOpen64bitKey(hComponentsKey, szPublishedComponent, 0, KEY_READ|KEY_SET_VALUE, &hPubCompKey)))
        {
            fError = true;
            break;
        }

        // determine max value and max value data length sizes
        if (ERROR_SUCCESS != (lError2 = RegQueryInfoKey(hPubCompKey, 0, 0, 0, 0, 0, 0, 0, &dwValueLen, &dwDataLen, 0, 0)))
        {
            fError = true;
            break;
        }
        
        szQualifier = new TCHAR[++dwValueLen];
        DWORD cchQualifier = dwValueLen;
        lpData = new TCHAR[++dwDataLen];
        DWORD cbData = dwDataLen * sizeof(TCHAR);
        
        // for each qualifier value of the published component
        int iIndex2 = 0;
        bool fMatchFound;
        int csz = 0;
        while ((lError2 = RegEnumValue(hPubCompKey, iIndex2, szQualifier, &cchQualifier, 0, &dwType, (LPBYTE)lpData, &cbData)) == ERROR_SUCCESS)
        {
            // init
            fMatchFound = false;
            csz = 0;

            if (REG_MULTI_SZ == dwType && lpData)
            {
                pchData = lpData; // store beginning

                // this is a multi-sz list of DD+AppData
                // with multi-sz, end of str signified by double null
                while (!fError && *lpData)
                {
                    // sz found
                    ++csz;

                    // grab product code from Darwin Descriptor in data arg
                    if (ERROR_SUCCESS == MsiDecomposeDescriptor(lpData, szPublishProductCode, 0, 0, 0))
                    {
                        // compare product codes
                        if (0 == lstrcmpi(szProduct, szPublishProductCode))
                        {
                            // match found -- delete this value (done below)

                            --csz; // we are removing this one
                            fMatchFound = true; // found a match

                            TCHAR* pch = lpData;
                            // adjust cbData for loss of this sz
                            cbData = cbData - (lstrlen(lpData) + 1) * sizeof(TCHAR);


                            if (!(*(lpData + lstrlen(lpData) + 1)))
                            {
                                // we are at the end of the multi-sz
                                // no shuffle occurs, so must manually incr the ptr
                                lpData = lpData + lstrlen(lpData) + 1;
                                // double null terminate at this location
                                *pch = 0;
                            }
                            else
                            {
                                // must reshuffle data
                                TCHAR* pchCur = lpData;

                                // skip over current string to remove
                                pchCur = pchCur + lstrlen(pchCur) + 1;
                                while (*pchCur)
                                {
                                    // copy next sz out of multi-sz
                                    while (*pchCur)
                                        *pch++ = *pchCur++;
                                    // copy null terminator
                                    *pch++ = *pchCur++;
                                }//while haven't reached end of multi-sz (2 nulls denote end)
                                
                                // copy 2nd null terminator denoting end of multi-sz
                                *pch = *pchCur; 
                            }
                            // set the new *revised* data
                            if (ERROR_SUCCESS != (RegSetValueEx(hPubCompKey, szQualifier, 0, REG_MULTI_SZ, (LPBYTE)pchData, cbData)))
                            {
                                fError = true;
                                break;
                            }
                            _tprintf(TEXT("   Removed product's published component qualifier value %s for published component %s\n"), szQualifier, szPublishedComponent);
							g_fDataFound = true;
                        }// if product codes match
                        else
                        {
                            // continue searching
                            lpData = lpData + lstrlen(lpData) + 1;
                        }
                    }// if MsiDecomposeDescriptor succeeds
                    else
                    {
                        // somehow publishcomponent information is corrupted
                        fError = true;
                        break;
                    }
                }//while (!fError && *lpData)
                lpData = pchData;
            }//if (REG_MULTI_SZ && lpData)

            if (fMatchFound && csz == 0)
            {
                // no multi-sz's remain, therefore delete the value
                if (ERROR_SUCCESS != RegDeleteValue(hPubCompKey, szQualifier))
                {
                    fError = true; // unable to delete it
                    iIndex2++;
                }
                _tprintf(TEXT("   Removed published component qualifier value %s\n"), szQualifier);
				g_fDataFound = true;
            }
            else // only increment if no delete of value occurred
                iIndex2++;

            // reset sizes
            cchQualifier = dwValueLen;
            cbData = dwDataLen * sizeof(TCHAR);

        }//while RegEnumValueEx
        if (ERROR_NO_MORE_ITEMS != lError2)
        {
            fError = true;
            break;
        }

        // if the published component's key is now empty, delete the key
        DWORD dwNumValues;
        if (ERROR_SUCCESS != (lError2 == RegQueryInfoKey(hPubCompKey, 0, 0, 0, 0, 0, 0, &dwNumValues, 0, 0, 0, 0)))
        {
            fError = true;
            break;
        }
        if (0 == dwNumValues)
        {
            // key is empty
            hPubCompKey = 0;
            if (ERROR_SUCCESS != (lError2 = RegDelete64bitKey(hComponentsKey, szPublishedComponent)))
            {
                // cannot delete the key
                fError = true;
                break;
            }
            _tprintf(TEXT("   Removed %s\\%s\\%s\n"), hKey == HKEY_LOCAL_MACHINE ? TEXT("HKLM") : TEXT("HKCU"), szSubKey, szPublishedComponent);
            g_fDataFound = true;
        }
        else
            iIndex++; // only increment index if key hasn't been deleted

        cchPublishedComponent = sizeof(szPublishedComponent)/sizeof(TCHAR); // reset
    }// while RegEnumKey
    if (ERROR_NO_MORE_ITEMS != lError)
        fError = true;

    if (szQualifier)
        delete [] szQualifier;
    if (lpData)
        delete [] lpData;

    return fError == false;
}

//==============================================================================================
// ClearRollbackKey function:
//
bool ClearRollbackKey(bool fJustRemoveACLs)
{
	_tprintf(TEXT("Searching for the Windows Installer Rollback key. . .\n"));

    bool fError = false;

    if (!DeleteTree(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Rollback"), fJustRemoveACLs))
        fError = true;

    return fError == false;
}

//==============================================================================================
// ClearInProgressKey function:
//
bool ClearInProgressKey(bool fJustRemoveACLs)
{
	_tprintf(TEXT("Searching for the Windows Installer InProgress key. . .\n"));
    
	bool fError = false;

    if (!DeleteTree(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\InProgress"), fJustRemoveACLs))
        fError = true;

    return fError == false;
}

//==============================================================================================
// ClearRegistry function:
//
bool ClearRegistry(bool fJustRemoveACLs)
{
	_tprintf(TEXT("Searching for all Windows Installer registry data. . .\n"));

    bool fError = false;

    if (!ClearInProgressKey(fJustRemoveACLs))
        fError = true;

    if (!DeleteTree(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), fJustRemoveACLs))
        fError = true;

    if (!DeleteTree(HKEY_LOCAL_MACHINE, TEXT("Software\\Classes\\Installer"), fJustRemoveACLs))
        fError = true;

	if (g_fWin9X)
	{
		// always an admin on Win9X so we are never the admin running this for the other user
		if (!DeleteTree(HKEY_CURRENT_USER, TEXT("Software\\Classes\\Installer"), fJustRemoveACLs))
			fError = true;

		if (!DeleteTree(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Installer"), fJustRemoveACLs))
			fError = true;
	}
	else // WinNT
	{
		// normal user can't run msizap so we need to open the proper hive
		DWORD dwResult = ERROR_SUCCESS;
		TCHAR* szUserSid = GetCurrentUserStringSID(&dwResult);
		if (ERROR_SUCCESS == dwResult && szUserSid)
		{
			// no per-user installs as local system (S-1-5-18)
			if (0 != lstrcmpi(szUserSid, szLocalSystemSID))
			{
				CRegHandle HUserHiveKey;
				LONG lError = ERROR_SUCCESS;

				if (ERROR_SUCCESS != (lError = RegOpenKeyEx(HKEY_USERS, szUserSid, 0, KEY_READ, &HUserHiveKey)))
				{
					// inability to access hive is not considered a fatal error
					_tprintf(TEXT("Unable to open the HKEY_USERS hive for user %s. The hive may not be loaded at this time. (LastError = %d)\n"), szUserSid, lError);
				}
				else
				{
					if (!DeleteTree(HUserHiveKey, TEXT("Software\\Classes\\Installer"), fJustRemoveACLs))
						fError = true;

					if (!DeleteTree(HUserHiveKey, TEXT("Software\\Microsoft\\Installer"), fJustRemoveACLs))
						fError = true;
				}
			}
		}
		else
		{
			_tprintf(TEXT("Attempt to obtain user's SID failed with error %d\n"), dwResult);
			fError = true;
		}
	}

    return fError == false;
}

//==============================================================================================
// RemoveCachedPackage function:
//
bool RemoveCachedPackage(const TCHAR* szProduct, bool fJustRemoveACLs)
{
	_tprintf(TEXT("Searching for the product %s cached package. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

    CRegHandle HUninstallKey;
    LONG lError;
    TCHAR szKey[MAX_PATH];

    wsprintf(szKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s"), szProduct);

    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            szKey,
                            0, KEY_READ, &HUninstallKey)) == ERROR_SUCCESS)

    {
        TCHAR szPackage[MAX_PATH];
        DWORD cbPackage = sizeof(szPackage);
        DWORD dwType;
        if (ERROR_SUCCESS == (lError = RegQueryValueEx(HUninstallKey, TEXT("LocalPackage"), 0, &dwType, (LPBYTE)&szPackage, &cbPackage)))
        {
            return RemoveFile(szPackage, fJustRemoveACLs);
        }
    }


    // clean up cached database copies as per new scheme (bug #9395)
    TCHAR szProductSQUID[40];
    GetSQUID(szProduct, szProductSQUID);

    wsprintf(szKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages\\%s"), szProductSQUID);
    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            szKey,
                            0, KEY_READ, &HUninstallKey)) == ERROR_SUCCESS)
    {
        // enumerate all the values under the key and delete the cached databases 1 by 1

        int iValueIndex = 0;
        DWORD dwType;
        TCHAR szPackage[MAX_PATH];
        DWORD cbPackage = sizeof(szPackage);

        TCHAR szSID[cchMaxSID + sizeof(TEXT("(Managed)"))/sizeof(TCHAR)];
        DWORD cbSID = sizeof(szSID)/sizeof(TCHAR);

        while (ERROR_SUCCESS == (lError = RegEnumValue(HUninstallKey, iValueIndex++, szSID, &cbSID,
                              0, &dwType, (LPBYTE)(TCHAR*)szPackage, &cbPackage)))
        {
            if(!RemoveFile(szPackage, fJustRemoveACLs))
                return false;

            cbPackage = sizeof(szPackage);
            cbSID = sizeof(szSID)/sizeof(TCHAR);
        }

        // remove the key
        if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\LocalPackages"),
                            0, KEY_READ, &HUninstallKey)) == ERROR_SUCCESS)
        {
            if (!DeleteTree(HUninstallKey, szProductSQUID, fJustRemoveACLs))
                return false;
        }
    }

    // as per post data-user migration
    DWORD dwRet;
    wsprintf(szKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Products\\%s\\InstallProperties"),
        GetCurrentUserStringSID(&dwRet), szProductSQUID);
    if ( dwRet != ERROR_SUCCESS )
        return false;

    if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, 
                            szKey,
                            0, KEY_READ, &HUninstallKey)) == ERROR_SUCCESS)
    {
        DWORD dwType;
        TCHAR szPackage[MAX_PATH];
        DWORD cbPackage = sizeof(szPackage);
        lError = RegQueryValueEx(HUninstallKey, TEXT("LocalPackage"), 0, &dwType, (LPBYTE)szPackage, &cbPackage);
        if ( lError != ERROR_SUCCESS || dwType != REG_SZ )
            return false;

        if(!RemoveFile(szPackage, fJustRemoveACLs))
            return false;
    }

    return true;
}

//==============================================================================================
// ClearPatchReferences function:
//
bool ClearPatchReferences(HKEY hRoot, HKEY hProdPatchKey, TCHAR* szPatchKey, TCHAR* szProductsKey, TCHAR* szProductSQUID)
{
    LONG lError  = ERROR_SUCCESS;
	LONG lErr    = ERROR_SUCCESS;
    bool fReturn = false;
	int iTry     = 0;

    CRegHandle hProductsKey;
    CRegHandle hPatchCompKey;
    CRegHandle hPatchKey;
	CRegHandle hCachedPatchKey;

	TCHAR* szUserSID =  NULL;
	DWORD dwRes = ERROR_SUCCESS;

    
    /**************************************
    Find all patches for particular product
    ***************************************/
    struct Patch
    {
        TCHAR  szPatchSQUID[500];
        BOOL   fUsed;
    };
    // determine number of patches, note that # patches is 1 less than number of values under key
    // keep a multi-sz string list as one.  only want patch code SQUIDS
    DWORD cPatches;
    if ((lError = RegQueryInfoKey(hProdPatchKey, 0,0,0,0,0,0,&cPatches,0,0,0,0)) != ERROR_SUCCESS)
        return false;
    Patch* pPatches = new Patch[cPatches];
    int iIndex = 0;
    TCHAR szValue[500];
    DWORD cbValue = sizeof(szValue)/sizeof(TCHAR);
    DWORD dwValueType;
    int iPatchIndex = 0;
    // fill in patch data into list array
    while ((lError = RegEnumValue(hProdPatchKey, iIndex, szValue, &cbValue, 0, &dwValueType, 0, 0)) == ERROR_SUCCESS)
    {
        if (dwValueType != REG_MULTI_SZ)
        {
            _tcscpy(pPatches[iPatchIndex].szPatchSQUID, szValue);
            pPatches[iPatchIndex++].fUsed = FALSE;
        }
        iIndex++;
        cbValue = sizeof(szValue)/sizeof(TCHAR);
    }
    if (lError != ERROR_NO_MORE_ITEMS)
        goto Return;

	szUserSID = GetCurrentUserStringSID(&dwRes);
	if (ERROR_SUCCESS != dwRes || !szUserSID)
		goto Return;

    // store number of patches in array
    cPatches = iIndex; 
    /**************************************
    Enumerate all products, searching for
    products with patches for comparison
    ***************************************/
    if ((lError = RegOpen64bitKey(hRoot, szProductsKey, 0, KEY_READ, &hProductsKey)) != ERROR_SUCCESS)
        goto Return;
    iIndex = 0;
    cbValue = sizeof(szValue)/sizeof(TCHAR);
    while  ((lError = RegEnumKeyEx(hProductsKey, iIndex, szValue, &cbValue, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        // ignore ourselves
        if (0 != lstrcmpi(szProductSQUID, szValue))
        {
            // see if product has patches
            TCHAR rgchKeyBuf[MAX_PATH];
            wsprintf(rgchKeyBuf, TEXT("%s\\%s\\Patches"), szProductsKey, szValue);
            if ((lError = RegOpen64bitKey(hRoot, rgchKeyBuf, 0, KEY_READ, &hPatchCompKey)) == ERROR_SUCCESS)
            {
                /*****************************
                search patch array for matches
                for each patch
                ******************************/
                TCHAR szPatchMatch[MAX_PATH];
                DWORD cbPatchMatch = sizeof(szPatchMatch)/sizeof(TCHAR);
                LONG lError2;
                DWORD iMatchIndex = 0;
                DWORD dwType;
                while ((lError2 = RegEnumValue(hPatchCompKey, iMatchIndex, szPatchMatch, &cbPatchMatch, 0, &dwType, 0, 0)) == ERROR_SUCCESS)
                {
                    // ignore multi-sz
                    if (dwType != REG_MULTI_SZ)
                    {
                        for (int i = 0; i < cPatches; i++)
                        {
                            if (!pPatches[i].fUsed && 0 == lstrcmpi(pPatches[i].szPatchSQUID, szPatchMatch))
                            {
                                pPatches[i].fUsed = TRUE;
                                break; // found, don't continue search
                            }
                        }
                    }
                    iMatchIndex++;
                    cbPatchMatch = sizeof(szPatchMatch)/sizeof(TCHAR);
                }
                if (ERROR_NO_MORE_ITEMS != lError2)
                    goto Return;

            }
            else if (lError != ERROR_FILE_NOT_FOUND)
                goto Return;
            // else no patches
        }
        iIndex++;
        cbValue = sizeof(szValue)/sizeof(TCHAR);
    }
    if (lError != ERROR_NO_MORE_ITEMS)
        goto Return;

    /**********************************
    Delete all patches not in use from
    main "Patches" key
    ***********************************/
    TCHAR rgchPatchCodeKeyBuf[MAX_PATH] = {0};
	TCHAR rgchLocalPatch[MAX_PATH] = {0};
	DWORD dwLocalPatch = MAX_PATH;
	DWORD dwType = 0;
    for (iPatchIndex = 0; iPatchIndex < cPatches; iPatchIndex++)
    {
        if (pPatches[iPatchIndex].fUsed == FALSE)
        {
            // remove patchcode key under Patches
            wsprintf(rgchPatchCodeKeyBuf, TEXT("%s\\%s"), szPatchKey, pPatches[iPatchIndex].szPatchSQUID);
            if (!DeleteTree(hRoot, rgchPatchCodeKeyBuf, false))
                goto Return;

			// remove cached patch
			//  try1 = old location HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\Patches
			//  try2 = new location HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\UserData\{user sid}\Patches
			for (iTry = 0; iTry < 2; iTry++)
			{
				if (0 == iTry)
				{
					wsprintf(rgchPatchCodeKeyBuf, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches\\%s"), pPatches[iPatchIndex].szPatchSQUID);
				}
				else
				{
					wsprintf(rgchPatchCodeKeyBuf, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Patches\\%s"), szUserSID, pPatches[iPatchIndex].szPatchSQUID);
				}

				if ((lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchPatchCodeKeyBuf, 0, KEY_READ, &hCachedPatchKey)) != ERROR_SUCCESS)
				{
					if (ERROR_FILE_NOT_FOUND != lErr)
						goto Return;
				}
				else 
				{
					// read LocalPackage value
               dwLocalPatch = sizeof(rgchLocalPatch);
					if (ERROR_SUCCESS == (lErr = RegQueryValueEx(hCachedPatchKey, TEXT("LocalPackage"), NULL, &dwType, (BYTE*)rgchLocalPatch, &dwLocalPatch))
						&& REG_SZ == dwType && *rgchLocalPatch != 0)
					{
						RemoveFile(rgchLocalPatch, false);
					}
				}
				
				hCachedPatchKey = 0;

				DeleteTree(HKEY_LOCAL_MACHINE, rgchPatchCodeKeyBuf, false);
			}
        }
    }

    /************************
    clean-up empty keys
    *************************/
    DWORD dwNumKeys;
    if ((lError = RegOpen64bitKey(hRoot, szPatchKey, 0, KEY_READ, &hPatchKey)) != ERROR_SUCCESS)
        goto Return;
    if ((lError = RegQueryInfoKey(hPatchKey, 0, 0, 0, &dwNumKeys, 0, 0, 0, 0, 0, 0, 0)) != ERROR_SUCCESS)
        goto Return;
    if (0 == dwNumKeys)
    {
        // key is empty
        hPatchKey = 0; // enable delete
        DeleteTree(hRoot, szPatchKey, false);
    }

	TCHAR szInstallerPatchesKey[MAX_PATH];
	for (iTry = 0; iTry < 2; iTry++)
	{
		if (iTry == 0)
		{
			// try old location
			wsprintf(szInstallerPatchesKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Patches"));
		}
		else
		{
			// try new location Installer 2.0+
			wsprintf(szInstallerPatchesKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Patches"), szUserSID);
		}

		if ((lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE, szInstallerPatchesKey, 0, KEY_READ, &hPatchKey)) == ERROR_SUCCESS)
		{
			dwNumKeys = 0;
			if ((lError = RegQueryInfoKey(hPatchKey, 0, 0, 0, &dwNumKeys, 0, 0, 0, 0, 0, 0, 0)) == ERROR_SUCCESS
				&& 0 == dwNumKeys)
			{
				// key is empty
				hPatchKey = 0; // enable delete
				if (!DeleteTree(HKEY_LOCAL_MACHINE, szInstallerPatchesKey, false))
					goto Return;
			}
		}
	}

    fReturn = true;

Return:
    delete [] pPatches;
    return fReturn;
}

//==============================================================================================
// ClearUpgradeProductReference function:
//
bool ClearUpgradeProductReference(HKEY HRoot, const TCHAR* szSubKey, const TCHAR* szProductSQUID)
{
	_tprintf(TEXT("  Searching for product %s upgrade codes in %s...\n"), szProductSQUID, szSubKey);

    if ( szProductSQUID && *szProductSQUID && 
         IsProductInstalledByOthers(szProductSQUID) )
        return true;

    // upgrade codes stored as subkeys of UpgradeKey on HKLM and HKCU
    // product codes (SQUIDs) are values of particular upgrade code
    // product can only have 1 upgrade
    CRegHandle HKey;
    LONG lError;
    if ((lError = RegOpen64bitKey(HRoot, szSubKey, 0, KEY_READ, &HKey)) != ERROR_SUCCESS)
    {
        if (ERROR_FILE_NOT_FOUND == lError)
            return true;  // registry key not there
        else
        {
            _tprintf(TEXT("   Could not open %s\\%s"), HRoot == HKEY_LOCAL_MACHINE ? TEXT("HKLM") : TEXT("HKCU"), szSubKey);
            return false;
        }
    }

    TCHAR szName[500];
    DWORD cchName = sizeof(szName)/sizeof(TCHAR);
    unsigned int iIndex = 0;
    BOOL fUpgradeFound = FALSE;
    // for each upgrade code
    while ((lError = RegEnumKeyEx(HKey, iIndex, szName, &cchName, 0, 0, 0, 0)) == ERROR_SUCCESS)
    {
        // open sub key for enumeration
        CRegHandle HSubKey;
        if ((lError = RegOpen64bitKey(HKey, szName, 0, KEY_READ|KEY_SET_VALUE, &HSubKey)) != ERROR_SUCCESS)
            return false;

        // enumerate values of key
        long lError2;
        TCHAR szValue[500];
        DWORD cbValue = sizeof(szValue)/sizeof(TCHAR);
        unsigned int iValueIndex = 0;
        // for each product code
        while ((lError2 = RegEnumValue(HSubKey, iValueIndex, szValue, &cbValue, 0, 0, 0, 0)) == ERROR_SUCCESS)
        {
            // compare value to productSQUID
            if (0 == lstrcmpi(szValue, szProductSQUID))
            {
                // same, reference to product so remove the reference
                if ((lError2 = RegDeleteValue(HSubKey, szValue)) != ERROR_SUCCESS)
                    return false;
                _tprintf(TEXT("   Removed upgrade code '%s' at %s\\%s\n"), szValue, HRoot == HKEY_LOCAL_MACHINE ? TEXT("HKLM") : TEXT("HKCU"), szSubKey);
                // found it, this is the only one so we can break here and should break out of key entirely
                // since product allowed to have only one upgrade
                fUpgradeFound = TRUE;
                g_fDataFound = true;
                break;
            }
            iValueIndex++;
            cbValue = sizeof(szValue)/sizeof(TCHAR);
        }
        if (lError2 != ERROR_NO_MORE_ITEMS && lError2 != ERROR_SUCCESS)
            return false;
        // if no more values, key is empty so delete
        DWORD dwNumValues;
        if (ERROR_SUCCESS != RegQueryInfoKey(HSubKey, 0, 0, 0, 0, 0, 0, &dwNumValues, 0, 0, 0, 0))
            return false;
        if (0 == dwNumValues)
        {
            HSubKey = 0; // enable delete
            RegDelete64bitKey(HKey, szName);
			g_fDataFound = true;
        }
        if (fUpgradeFound)
            break; // product can only have 1 upgrade
        iIndex++;
        cchName = sizeof(szName)/sizeof(TCHAR);
    }

    if (lError != ERROR_NO_MORE_ITEMS && lError != ERROR_SUCCESS)
        return false;
    // if no more subkeys, UpgradeCodes key is empty so delete 
    DWORD dwNumKeys;
    if (ERROR_SUCCESS != RegQueryInfoKey(HKey, 0, 0, 0, &dwNumKeys, 0, 0, 0, 0, 0, 0, 0))
        return false;
    if (0 == dwNumKeys)
    {
        HKey = 0; // enable delete
        RegDelete64bitKey(HRoot, szSubKey);
		g_fDataFound = true;
    }
    return true;
}


//==============================================================================================
// ClearProduct function:
//
bool ClearProduct(int iTodo, const TCHAR* szProduct, bool fJustRemoveACLs, bool fOrphan)
{
    bool fError = false;

    fError = RemoveCachedPackage(szProduct, fJustRemoveACLs) != true;

    // remove uninstall key info

    if (!ClearUninstallKey(fJustRemoveACLs, szProduct))
        fError = true;


    // remove published info from all possible keys

    struct Key
    {
        const TCHAR* szKey;
        HKEY hRoot;
		bool fUserHive;
        const TCHAR* szRoot;
		const TCHAR* szInfo;
    };

	DWORD dwRes = ERROR_SUCCESS;
	TCHAR* szUserSID = GetCurrentUserStringSID(&dwRes);
	if (dwRes != ERROR_SUCCESS || !szUserSID)
	{
		_tprintf(TEXT("Unable to obtain the current user's SID (LastError = %d)"), dwRes);
		fError = true;
	}
	else
	{
		CRegHandle HUserHiveKey;
		LONG lError = ERROR_SUCCESS;
		bool fUserHiveAvailable = true;

		if (!g_fWin9X)
		{
			// only concerned about HKCU access via HKEY_USERS on NT
			if (ERROR_SUCCESS != (lError = RegOpenKeyEx(HKEY_USERS, szUserSID, 0, KEY_READ, &HUserHiveKey)))
			{
				_tprintf(TEXT("Unable to open the HKEY_USERS hive for user %s. HKCU data for this user will not be modified.  The hive may not be loaded at this time. (LastError = %d)\n"), szUserSID, lError);
				fUserHiveAvailable = false;
			}
		}

		TCHAR szPerUserGlobalConfig[MAX_PATH];
		wsprintf(szPerUserGlobalConfig, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s"), szUserSID);

		TCHAR szPerMachineGlobalConfig[MAX_PATH] = {0};
		wsprintf(szPerMachineGlobalConfig, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s"), szLocalSystemSID);

		Key keysNT[] = 
			{szPerUserGlobalConfig,                                          HKEY_LOCAL_MACHINE,  false, TEXT("HKLM"), TEXT("user's global config"),
			szPerMachineGlobalConfig,                                        HKEY_LOCAL_MACHINE,  false, TEXT("HKLM"), TEXT("per-machine global config"),
			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), HKEY_LOCAL_MACHINE,  false, TEXT("HKLM"), TEXT("old global config"), // old location
			TEXT("Software\\Classes\\Installer"),                            HKEY_LOCAL_MACHINE,  false, TEXT("HKLM"), TEXT("per-machine"),
			TEXT("Software\\Classes\\Installer"),                            HUserHiveKey,   true, TEXT("HKCU"), TEXT("old per-user"),
			TEXT("Software\\Microsoft\\Installer"),                          HUserHiveKey,   true, TEXT("HKCU"), TEXT("per-user"),
			0,0,0,0};
		Key keys9X[] = 
			{szPerUserGlobalConfig,                                          HKEY_LOCAL_MACHINE,  false, TEXT("HKLM"), TEXT("user's global config"),
			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), HKEY_LOCAL_MACHINE,  false, TEXT("HKLM"), TEXT("global config"), // old location
			TEXT("Software\\Classes\\Installer"),                            HKEY_LOCAL_MACHINE,  false, TEXT("HKLM"), TEXT("per-machine"),
			TEXT("Software\\Classes\\Installer"),                            HKEY_CURRENT_USER,   true, TEXT("HKCU"), TEXT("old per-user"),
			TEXT("Software\\Microsoft\\Installer"),                          HKEY_CURRENT_USER,   true, TEXT("HKCU"), TEXT("per-user"),
			0,0,0,0};
		Key *k = g_fWin9X ? keys9X : keysNT;


		TCHAR szProductSQUID[40];
		GetSQUID(szProduct, szProductSQUID);

		TCHAR rgchKeyBuf[MAX_PATH];
		for ( ; k->szKey; k++ )
		{
			if (k->fUserHive && !fUserHiveAvailable)
			{
				// can't access the user's hive so we can't delete any per-user data
				_tprintf(TEXT("Skipping search of %s location for product %s data since the registry hive is not available.\n"), k->szInfo, szProduct);
				continue;
			}

			if (k->fUserHive && 0 == lstrcmpi(szUserSID, szLocalSystemSID))
			{
				// no per-user installs as local system
				continue;
			}

			_tprintf(TEXT("Searching %s location for product %s data. . .\n"), k->szInfo, szProduct);

			// NOTE: patch and upgrades checks must come first or else we lose them
			// only remove upgrade and patch info if removing product (not just ACLs)
			// only remove Published Components information if removing product (not just ACLs)
			if (!fJustRemoveACLs)
			{
				// upgrade codes haven't moved to per-user locations
				TCHAR* szUserData = _tcsstr(k->szKey, TEXT("\\UserData"));  // a sophisticated 'strstr'
				if ( szUserData )
				{
					lstrcpyn(rgchKeyBuf, k->szKey, int(szUserData - k->szKey) + 1);
					lstrcat(rgchKeyBuf, TEXT("\\UpgradeCodes"));
				}
				else
					wsprintf(rgchKeyBuf, TEXT("%s\\UpgradeCodes"), k->szKey);
				if (!ClearUpgradeProductReference(k->hRoot, rgchKeyBuf, szProductSQUID))
					fError = true;

				// only remove patch refs if product has patches (i.e. Patches key under ProductCode)
				wsprintf(rgchKeyBuf, TEXT("%s\\Products\\%s\\Patches"), k->szKey, szProductSQUID);

				_tprintf(TEXT("  Searching for patches for product %s in %s\n"), szProductSQUID, rgchKeyBuf);

				CRegHandle hProdPatchesKey;
				LONG lError;
				if ((lError = RegOpenKeyEx(k->hRoot, rgchKeyBuf, 0, KEY_READ, &hProdPatchesKey)) == ERROR_SUCCESS)
				{
					// product has patches
					TCHAR rgchProdKeyBuf[MAX_PATH];
					wsprintf(rgchProdKeyBuf, TEXT("%s\\Products"), k->szKey);
					wsprintf(rgchKeyBuf, TEXT("%s\\Patches"), k->szKey);
					if (!ClearPatchReferences(k->hRoot, hProdPatchesKey, rgchKeyBuf, rgchProdKeyBuf, szProductSQUID))
						fError = true; 
				}
				else if (lError != ERROR_FILE_NOT_FOUND)
				{
					// ERROR_FILE_NOT_FOUND means product does not have patches
					_tprintf(TEXT("   Error opening %s\\%s\n"), k->hRoot == HKEY_LOCAL_MACHINE ? TEXT("HKLM") : TEXT("HKCU"), rgchKeyBuf);
					fError = true;
				}

				// HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\[UserData\<User ID>\]Components is not a PublishComponents key
				// ('_tcsstr' is a sophisticated 'strstr')
				if (k->hRoot != HKEY_LOCAL_MACHINE || !_tcsstr(k->szKey, TEXT("Software\\Microsoft")))
				{
					wsprintf(rgchKeyBuf, TEXT("%s\\Components"), k->szKey);
					if (!ClearPublishComponents(k->hRoot, rgchKeyBuf, szProduct))
						fError = true;
				}
			}

			wsprintf(rgchKeyBuf, TEXT("%s\\Products\\%s"), k->szKey, szProductSQUID);
			_tprintf(TEXT("  Searching %s\\%s for product data. . .\n"), k->szRoot, rgchKeyBuf); 
			if (!DeleteTree(k->hRoot, rgchKeyBuf, fJustRemoveACLs))
				fError = true;

			wsprintf(rgchKeyBuf, TEXT("%s\\Features\\%s"), k->szKey, szProductSQUID);
			_tprintf(TEXT("  Searching %s\\%s for product feature data. . .\n"), k->szRoot, rgchKeyBuf); 
			if (!DeleteTree(k->hRoot, rgchKeyBuf, fJustRemoveACLs))
				fError = true;

		}

		// remove per-user managed information
		// patch and upgrades checks must come first or else we lose them

		_tprintf(TEXT("Searching for product %s in per-user managed location. . .\n"), szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));

		if (!fJustRemoveACLs)
		{
			wsprintf(rgchKeyBuf, TEXT("%s\\Managed\\%s\\Installer\\UpgradeCodes"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID);
			if (!ClearUpgradeProductReference(HKEY_LOCAL_MACHINE, rgchKeyBuf, szProductSQUID))
				fError = true;

			// only remove patch refs if product has patches (i.e. Patches key under ProductCode)
			wsprintf(rgchKeyBuf, TEXT("%s\\Managed\\%s\\Installer\\Products\\%s\\Patches"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID, szProductSQUID);
			_tprintf(TEXT("  Searching for patches for product %s in %s\n"), szProductSQUID, rgchKeyBuf);

			CRegHandle hProdPatchesKey;
			LONG lError;
            
			// ERROR_FILE_NOT_FOUND means product does not have patches
			if ((lError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchKeyBuf, 0, KEY_READ, &hProdPatchesKey)) == ERROR_SUCCESS)
			{
				// product has patches
				TCHAR rgchProdKeyBuf[MAX_PATH];
				wsprintf(rgchProdKeyBuf, TEXT("%s\\Managed\\%s\\Installer\\Products"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID);
				wsprintf(rgchKeyBuf, TEXT("%s\\Managed\\%s\\Installer\\Patches"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID);
				if (!ClearPatchReferences(HKEY_LOCAL_MACHINE, hProdPatchesKey, rgchKeyBuf, rgchProdKeyBuf, szProductSQUID))
					fError = true; 
			}
			else if (lError != ERROR_FILE_NOT_FOUND)
			{
				_tprintf(TEXT("   Error opening HKLM\\%s\n"), rgchKeyBuf);
				fError = true;
			}

			// remove published component information
			wsprintf(rgchKeyBuf, TEXT("%s\\Managed\\%s\\Installer\\Components"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID);
			if (!ClearPublishComponents(HKEY_LOCAL_MACHINE, rgchKeyBuf, szProduct))
				fError = true;
		}
		wsprintf(rgchKeyBuf, TEXT("%s\\Managed\\%s\\Installer\\Products\\%s"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID, szProductSQUID);
		_tprintf(TEXT("  Searching %s\\%s for product data. . .\n"), TEXT("HKLM"), rgchKeyBuf); 
		if (!DeleteTree(HKEY_LOCAL_MACHINE, rgchKeyBuf, fJustRemoveACLs))
			fError = true;

		wsprintf(rgchKeyBuf, TEXT("%s\\Managed\\%s\\Installer\\Features\\%s"), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer"), szUserSID, szProductSQUID);
		_tprintf(TEXT("  Searching %s\\%s for product feature data. . .\n"), TEXT("HKLM"), rgchKeyBuf); 
		if (!DeleteTree(HKEY_LOCAL_MACHINE, rgchKeyBuf, fJustRemoveACLs))
			fError = true;

		// remove component clients and feature usage metrics
		wsprintf(rgchKeyBuf, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Products\\%s"), szProductSQUID);
		if (!DeleteTree(HKEY_LOCAL_MACHINE, rgchKeyBuf, fJustRemoveACLs))
			fError = true;

		if (!fJustRemoveACLs && !fOrphan && !ClearSharedDLLCounts(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components"), szProductSQUID))
			fError = true;

		wsprintf(rgchKeyBuf, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Products\\%s"), szUserSID, szProductSQUID);
		if (dwRes == ERROR_SUCCESS && !DeleteTree(HKEY_LOCAL_MACHINE, rgchKeyBuf, fJustRemoveACLs))
			fError = true;

		wsprintf(rgchKeyBuf, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Components"), szUserSID);
		if (dwRes == ERROR_SUCCESS && !fJustRemoveACLs && !fOrphan && !ClearSharedDLLCounts(rgchKeyBuf, szProductSQUID))
			fError = true;

		if (dwRes == ERROR_SUCCESS && !ClearProductClientInfo(rgchKeyBuf, szProductSQUID, fJustRemoveACLs))
			fError = true;

		if (!ClearProductClientInfo(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components"), szProductSQUID, fJustRemoveACLs))
			fError = true;

		int iFolders = iRemoveUserProfileFolder|iRemoveWinMsiFolder;
		if (fJustRemoveACLs)
			iFolders |= iOnlyRemoveACLs;
		if (!ClearFolders(iFolders, szProduct, fOrphan))
			fError = true;
	}

    return fError == false;
}

//==============================================================================================
// DisplayHelp function:
//  Outputs command line options for MsiZap
//
void DisplayHelp(bool fVerbose)
{
    // the O option, which works similar to the T option is undocumented at this time
    // it was added as an option for OEMs.
    _tprintf(TEXT("Copyright (C) Microsoft Corporation, 1998 - 2001.  All rights reserved.\n")
             TEXT("MSIZAP - Zaps (almost) all traces of Windows Installer data from your machine.\n")
             TEXT("\n")
             TEXT("Usage: msizap T[A!] {product code}\n")
             TEXT("       msizap T[A!] {msi package}\n")
             TEXT("       msizap *[A!] ALLPRODUCTS\n")
             TEXT("       msizap PSA?!\n")
             TEXT("\n")
             TEXT("       * = remove all Windows Installer folders and regkeys;\n")
             TEXT("           adjust shared DLL counts; stop Windows Installer service\n")
             TEXT("       T = remove all info for given product code\n")
             TEXT("       P = remove In-Progress key\n")
             TEXT("       S = remove Rollback Information\n")
             TEXT("       A = for any specified removal, just change ACLs to Admin Full Control\n")
             TEXT("       W = for all users (by default, only for the current user)\n")
             TEXT("       G = remove orphaned cached Windows Installer data files (for all users)\n")
             TEXT("       ? = verbose help\n")
             TEXT("       ! = force 'yes' response to any prompt\n")
             TEXT("\n")
             TEXT("CAUTION: Products installed by the Windows Installer may fail to\n")
             TEXT("         function after using msizap\n")
			 TEXT("\n")
			 TEXT("NOTE: MsiZap requires admin privileges to run correctly. The W option requires that the profiles for all of the users be loaded.\n")
             );

    if (fVerbose)
    {
        _tprintf(TEXT("\n")
             TEXT("* Any published icons will be removed.\n")
             TEXT("\n")
             TEXT("* The following keys will be deleted:\n")
             TEXT("  HKCU\\Software\\Classes\\Installer\n")
             TEXT("  HKCU\\Software\\Microsoft\\Installer\n")
             TEXT("  HKLM\\Software\\Classes\\Installer\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Installer\n")
             TEXT(" On NT:\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\<User ID>\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{ProductCode} - only if there are no more installations of {ProductCode}\n")
             TEXT(" On Win9x:\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\CommonUser\n")
             TEXT("  HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{ProductCode}\n")
             TEXT("\n")
             TEXT("* Shared DLL refcounts for files refcounted by the Windows Installer will be adjusted.\n")
             TEXT("\n")
             TEXT("* The following folders will be deleted:\n")
             TEXT("  %%USERPROFILE%%\\MSI\n")
             TEXT("  {AppData}\\Microsoft\\Installer\n")
             TEXT("  %%WINDIR%%\\MSI\n")
             TEXT("  %%WINDIR%%\\Installer\n")
             TEXT("  X:\\config.msi (for each local drive)\n")
             TEXT("\n")
             TEXT("Notes/Warnings: MsiZap blissfully ignores ACL's if you're an Admin.\n")
            );
    }
}

//==============================================================================================
// SetPlatformFlags function:
//  Initializes the global Win9X & WinNT64 flag variables with the correct OS information
//
void SetPlatformFlags(void)
{
    // figure out what OS wer're running on
    OSVERSIONINFO osviVersion;
    osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osviVersion); // fails only if size set wrong
    if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        g_fWin9X = true;
    g_iMajorVersion = osviVersion.dwMajorVersion;
#ifdef _WIN64
    g_fWinNT64 = true;
#else
    g_fWinNT64 = false;
    if ( osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT &&
         (osviVersion.dwMajorVersion > 5 ||
         (osviVersion.dwMajorVersion == 5 && osviVersion.dwMinorVersion >= 1)) )
    {
        TCHAR rgchBuffer[MAX_PATH+1];
        HMODULE hModule = LoadLibrary(TEXT("kernel32.dll"));
        if( hModule == NULL )
        {
            wsprintf(rgchBuffer,
                     TEXT("MsiZap warning: failed to load Kernel32.dll, ")
                     TEXT("so we cannot access IsWow64Process API. ")
                     TEXT("GetLastError returned %d\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
            return;
        }

        typedef BOOL(WINAPI *pIsWow64Process)(HANDLE hProcess, PBOOL Wow64Process);
        pIsWow64Process pFunc = (pIsWow64Process)GetProcAddress(hModule, "IsWow64Process");
        if( pFunc == NULL )
        {
            wsprintf(rgchBuffer,
                     TEXT("MsiZap info: failed to get pointer to IsWow64Process. ")
                     TEXT("GetLastError returned %d\n"),
                     GetLastError());
            OutputDebugString(rgchBuffer);
            FreeLibrary(hModule);
            return;
        }

        BOOL fRet = FALSE;
        pFunc(GetCurrentProcess(), &fRet);
        g_fWinNT64 = fRet ? true : false;
    }
#endif // _WIN64
}

//==============================================================================================
// ReadInUsers function:
//
bool ReadInUsers()
{
    if ( !g_fWin9X )
    {
        CRegHandle hUserDataKey(0);
        long lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData"),
                              0, KEY_READ, &hUserDataKey);
        DWORD cUsers = 0;
        if ( hUserDataKey )
            lError = RegQueryInfoKey(hUserDataKey, 0, 0, 0, &cUsers, 0, 0, 0, 0, 0, 0, 0);

        CRegHandle hManagedUserKey(0);
        lError = RegOpen64bitKey(HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed"),
                              0, KEY_READ, &hManagedUserKey);
        DWORD cManagedUsers = 0;
        if ( hManagedUserKey )
            lError = RegQueryInfoKey(hManagedUserKey, 0, 0, 0, &cManagedUsers, 0, 0, 0, 0, 0, 0, 0);

        int cSIDs = cUsers + cManagedUsers + 1 + 1; // one for the machine and one for the terminating NULL
        g_rgpszAllUsers = new TCHAR* [cSIDs];
        if ( !g_rgpszAllUsers )
            return false;

        g_rgpszAllUsers[0] = _tcsdup(szLocalSystemSID);  // a sophisticated 'strdup'
        for ( int i = 1; i < cSIDs; i++ )
            g_rgpszAllUsers[i] = NULL;
        int iArrayIndex = 1;

        int iIndex;
        TCHAR szUser[cchMaxSID];
        DWORD cchUser = sizeof(szUser)/sizeof(TCHAR);
        if ( cUsers )
            for ( iIndex = 0;
                  (lError = RegEnumKeyEx(hUserDataKey, iIndex,
                                         szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
                  iIndex++, iArrayIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
            {
                g_rgpszAllUsers[iArrayIndex] = _tcsdup(szUser);  // a sophisticated 'strdup'
            }

        if ( cManagedUsers )
            for ( iIndex = 0;
                  (lError = RegEnumKeyEx(hManagedUserKey, iIndex,
                                         szUser, &cchUser, 0, 0, 0, 0)) == ERROR_SUCCESS;
                  iIndex++, iArrayIndex++, cchUser = sizeof(szUser)/sizeof(TCHAR) )
            {
                g_rgpszAllUsers[iArrayIndex] = _tcsdup(szUser);  // a sophisticated 'strdup'
            }
    }
    else
    {
        g_rgpszAllUsers = new TCHAR* [2];
        if ( !g_rgpszAllUsers )
            return false;
        g_rgpszAllUsers[0] = _tcsdup(TEXT("CommonUser"));  // a sophisticated 'strdup'
        g_rgpszAllUsers[1] = NULL;
    }

    return true;
}

//==============================================================================================
// DoTheJob function:
//
bool DoTheJob(int iTodo, const TCHAR* szProduct)
{
	_tprintf(TEXT("MsiZapInfo: Performing operations for user %s\n"), GetCurrentUserStringSID(NULL));

    bool fError = false;

    if ((iTodo & iAdjustSharedDLLCounts) && ((iTodo & iOnlyRemoveACLs) == 0))
    {
        TCHAR rgchKeyBuf[MAX_PATH];
        DWORD dwRes;
        wsprintf(rgchKeyBuf, 
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\%s\\Components"),
            GetCurrentUserStringSID(&dwRes));
        if ( dwRes != ERROR_SUCCESS )
            fError = true;
        else if (!ClearSharedDLLCounts(rgchKeyBuf))
            fError = true;

        if (!ClearSharedDLLCounts(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components")))
            fError = true;
    }
    
    if (iTodo & iRemoveAllRegKeys)
    {
        if (ClearRegistry((iTodo & iOnlyRemoveACLs) != 0) && ClearUninstallKey((iTodo & iOnlyRemoveACLs) != 0))
        {
            OutputDebugString(TEXT("Registry data cleared.\r\n"));
            if (iTodo & iOnlyRemoveACLs)
                _tprintf(TEXT("Registry ACLs cleared.\n"));
            else
                _tprintf(TEXT("Registry data cleared.\n"));
        }
        else
            fError = true;
    }
    else if ((iTodo & iRemoveInProgressRegKey) != 0)
    {
        if (!ClearInProgressKey((iTodo & iOnlyRemoveACLs) != 0))
            fError = true;
    }

    if ((iTodo & iRemoveUninstallKey) != 0)
    {
        if (!ClearUninstallKey((iTodo & iOnlyRemoveACLs) != 0))
            fError = true;
    }

    if ((iTodo & iRemoveRollback) != 0)
    {
        if (!ClearFolders(iTodo, szProduct, false /*fOrphan*/)) // del config.msi from all drives
			fError = true;
        if (!ClearRollbackKey((iTodo & iOnlyRemoveACLs) != 0))
            fError = true;
    }

    if ((iTodo & iRemoveAllFolders) == iRemoveAllFolders)
    {
        if (ClearFolders(iTodo, szProduct, false /*fOrphan*/))
		{
            OutputDebugString(TEXT("Folders cleared.\r\n"));
            if (iTodo & iOnlyRemoveACLs)
                _tprintf(TEXT("Folder ACLs cleared.\n"));
            else
                _tprintf(TEXT("Folders cleared.\n"));
		}
		else
			fError = true;
    }

    if (iTodo & iStopService)
    {
        if (!g_fWin9X && !StopService())
            fError = true;
    }

    if (((iTodo & iRemoveProduct) || (iTodo & iOrphanProduct)) && szProduct)
        if (!ClearProduct(iTodo, szProduct, (iTodo & iOnlyRemoveACLs) != 0, (iTodo & iOrphanProduct) ? true : false /*fOrphan*/))
            fError = true;

    if ( (iTodo & iRemoveGarbageFiles) == iRemoveGarbageFiles )
        if ( !ClearGarbageFiles() )
            fError = true;

    return !fError;
}


//==============================================================================================
// MAIN FUNCTION
//
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
    unsigned int iTodo = 0;
    bool fVerbose = false;

    TCHAR* szProduct = 0;

    if (argc == 3 || argc == 2)
    {
        TCHAR ch;
        while ((ch = *(argv[1]++)) != 0)
        {
            switch (ch | 0x20)
            {
            case '*': iTodo |= iRemoveAllNonStateData | iRemoveInProgressRegKey | iRemoveRollback;break;
            case '!': iTodo |= iForceYes;                                                         break;
            case 'f': _tprintf(TEXT("Option 'F' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 'r': _tprintf(TEXT("Option 'R' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 'a': iTodo |= iOnlyRemoveACLs;                                                   break;
            case 'p': iTodo |= iRemoveInProgressRegKey;                                           break;
            case 's': iTodo |= iRemoveRollback;                                                   break;
            case 'v': _tprintf(TEXT("Option 'V' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 'u': _tprintf(TEXT("Option 'U' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 'n': _tprintf(TEXT("Option 'N' is no longer supported. Action can be accomplished with remove all.\n"));        break;
            case 't': iTodo |= iRemoveProduct;                                                    break;
            case 'o': iTodo |= iOrphanProduct;                                                    break;
            case 'w': iTodo |= iForAllUsers;                                                      break;
            case 'g': iTodo |= iRemoveGarbageFiles;                                                      break;
            case '?': fVerbose = true;                                                            // fall through
            default:
                DisplayHelp(fVerbose);
                return 1;
            }
        }

        if (argc == 3)
        {
            szProduct = argv[2];
            if (!IsGUID(szProduct))
            {
                if (0 == _tcsicmp(szProduct, szAllProductsArg) && ((iTodo & iRemoveAllNonStateData) == iRemoveAllNonStateData))
                {
                    // REMOVE ALL
                    szProduct = 0; // reset
                }
                else if ((iTodo & iRemoveAllNonStateData) == iRemoveAllNonStateData)
                {
                    // attempt to REMOVEALL w/out ALLPRODUCTS arg
                    DisplayHelp(fVerbose);
                    return 1;
                }
                else
                {
                    // assume msi package and attempt to open
                    UINT iStat;
                    PMSIHANDLE hDatabase = 0;
                    if (ERROR_SUCCESS == (iStat = MsiOpenDatabase(argv[1], TEXT("MSIDBOPEN_READONLY"), &hDatabase)))
                    {
                        // zapping product using msi - maybe, must get product code first
                        PMSIHANDLE hViewProperty = 0;
                        if (ERROR_SUCCESS == (iStat = MsiDatabaseOpenView(hDatabase, TEXT("SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'"), &hViewProperty)))
                        {
                            MsiViewExecute(hViewProperty, 0);
                            szProduct = new TCHAR[40];
                            DWORD cchProduct = 40;
                            PMSIHANDLE hProperty = 0;
                            if (ERROR_SUCCESS == (iStat = MsiViewFetch(hViewProperty, &hProperty)))
                                MsiRecordGetString(hProperty, 1, szProduct, &cchProduct);
                        }
                    }
                    if (iStat != ERROR_SUCCESS)
                    {
                        DisplayHelp(fVerbose);
                        return 1;
                    }
                }
            }
            else if (iTodo & iRemoveAllNonStateData)
            {
                DisplayHelp(fVerbose);
                return 1;
            }
        }
        else if (iTodo & ~(iRemoveRollback | iOnlyRemoveACLs | iRemoveInProgressRegKey | iForceYes | iRemoveGarbageFiles))
        {
            // verify correct usage of 2 args -- only with installer state data
            DisplayHelp(fVerbose);
            return 1;
        }
    }
    else
    {
		// equivalent of msizap.exe with no args -- this is okay, maps to msizap ?
        DisplayHelp(false);
        return 0; // exit
    }

    SetPlatformFlags();

	// must be admin to run msizap for it to work properly (non-admin users generally do not have sufficient
	// permissions to modify files or change ownership on files)
	// NOTE: SetPlatformFlags must come before IsAdmin check!
	if (!IsAdmin())
	{
		_tprintf(TEXT("Administrator privileges are required to run MsiZap.\n"));
		return 1; // improper use
	}

    // if all of these are set then we'll prompt to confirm(unless we're told not to prompt)
	// no need to prompt if just adjusting ACLs
    const int iTodoRequiringPrompt = iRemoveAllFolders | iRemoveAllRegKeys | iAdjustSharedDLLCounts;

    if (!(iTodo & iForceYes) && !(iTodo & iOnlyRemoveACLs) && ((iTodo & iTodoRequiringPrompt) == iTodoRequiringPrompt))
    {
        _tprintf(TEXT("Do you want to delete all Windows installer configuration data? If you do, some programs might not run. (Y/N)?"));
        int i = getchar();
        if ((i != 'Y') && (i != 'y'))
        {
            _tprintf(TEXT("Aborted.\n"));
            return 1;
        }
    }

    bool fError = false;

    LoadSpecialFolders(iTodo);

    if ( iTodo & iForAllUsers )
    {
        fError = !ReadInUsers();
        for ( g_iUserIndex = 0; !fError && g_rgpszAllUsers[g_iUserIndex]; g_iUserIndex++ )
        {
            if ( iTodo & iOnlyRemoveACLs)
                _tprintf(TEXT("\n\n***** Adjusting ACLs on data for user %s for product %s *****\n"), g_rgpszAllUsers[g_iUserIndex], szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));
            else
                _tprintf(TEXT("\n\n***** Zapping data for user %s for product %s *****\n"), g_rgpszAllUsers[g_iUserIndex], szProduct ? szProduct : TEXT("{ALL PRODUCTS}"));
            fError |= !DoTheJob(iTodo, szProduct);
            delete g_rgpszAllUsers[g_iUserIndex];
        }
        delete [] g_rgpszAllUsers;
    }
    else
        fError = !DoTheJob(iTodo, szProduct);

    if (fError)
    {
        _tprintf(TEXT("FAILED to clear all data.\n"));
        return 1;
    } 
    else
	{
		if (!g_fDataFound && !(iTodo & iOnlyRemoveACLs))
			_tprintf(TEXT("No product data was found.\n"));
        return 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\addtbld.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// AddTblD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "AddTblD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddTableD dialog


CAddTableD::CAddTableD(CWnd* pParent /*=NULL*/)
	: CDialog(CAddTableD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddTableD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_plistTables = NULL;
}


void CAddTableD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddTableD)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddTableD, CDialog)
	//{{AFX_MSG_MAP(CAddTableD)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddTableD message handlers

BOOL CAddTableD::OnInitDialog() 
{
	ASSERT(m_plistTables);
	CDialog::OnInitDialog();

	// subclass list box to a checkbox
	m_ctrlList.SubclassDlgItem(IDC_LIST_TABLES, this);
	
	while (m_plistTables->GetHeadPosition())
		m_ctrlList.AddString(m_plistTables->RemoveHead());

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CAddTableD::OnOK() 
{
	CString strTable;
	int cTables = m_ctrlList.GetCount();
	for (int i = 0; i < cTables; i++)
	{
		// if the table is checked add it back in the list
		if (1 == m_ctrlList.GetCheck(i))
		{
			m_ctrlList.GetText(i, strTable);
			m_plistTables->AddTail(strTable);
		}
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\celledit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

#if !defined(AFX_CELLEDIT_H__0E0A1774_F10D_11D1_A859_006097ABDE17__INCLUDED_)
#define AFX_CELLEDIT_H__0E0A1774_F10D_11D1_A859_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CellEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCellEdit window

class CCellEdit : public CEdit
{
// Construction
public:
	CCellEdit();

// Attributes
public:
	int m_nRow;
	int m_nCol;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCellEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCellEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCellEdit)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CELLEDIT_H__0E0A1774_F10D_11D1_A859_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\celledit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// CellEdit.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "CellEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCellEdit

CCellEdit::CCellEdit()
{
	m_nRow = -1;
	m_nCol = -1;
}

CCellEdit::~CCellEdit()
{
}


BEGIN_MESSAGE_MAP(CCellEdit, CEdit)
	//{{AFX_MSG_MAP(CCellEdit)
	ON_WM_KILLFOCUS()
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCellEdit message handlers

void CCellEdit::OnKillFocus(CWnd* pNewWnd) 
{
	if (IsWindowVisible())
		// pretend user pressed return
		GetParent()->SendMessage(WM_CHAR, VK_RETURN, 1);
	CEdit::OnKillFocus(pNewWnd);
}

void CCellEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if (VK_RETURN == nChar)
	{
		GetParent()->SendMessage(WM_CHAR, VK_RETURN, 1);	// looses the flags (oh well)
		TRACE(_T("CCellEdit::OnChar - ENTER pressed\n"));
	}
	else if (VK_ESCAPE == nChar)
	{
		// "reflect" the message
		GetParent()->SendMessage(WM_CHAR, VK_ESCAPE);	// looses the flags (oh well)
		TRACE(_T("CCellEdit::OnChar - ESC pressed\n"));
	}
	else
		CEdit::OnChar(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\addtbld.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_ADDTBLD_H__AF466B56_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_)
#define AFX_ADDTBLD_H__AF466B56_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddTblD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddTableD dialog

class CAddTableD : public CDialog
{
// Construction
public:
	CAddTableD(CWnd* pParent = NULL);   // standard constructor

	CStringList* m_plistTables;
	CCheckListBox m_ctrlList;

// Dialog Data
	//{{AFX_DATA(CAddTableD)
	enum { IDD = IDD_ADD_TABLE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddTableD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddTableD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDTBLD_H__AF466B56_F97C_11D1_AD43_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\cellerrd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// CellErrD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "CellErrD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCellErrD dialog


CCellErrD::CCellErrD(CWnd* pParent /*=NULL*/)
	: CDialog(CCellErrD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCellErrD)
	m_strType = _T("");
	m_strICE = _T("");
	m_strDescription = _T("");
	//}}AFX_DATA_INIT
}

CCellErrD::CCellErrD(const CTypedPtrList<CObList, COrcaData::COrcaDataError *> *list, 
					 CWnd* pParent/* = NULL*/)
					 : CDialog(CCellErrD::IDD, pParent), m_Errors(list)
{
	m_strType = _T("");
	m_strICE = _T("");
	m_strDescription = _T("");
}

void CCellErrD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCellErrD)
	DDX_Text(pDX, IDC_TYPE, m_strType);
	DDX_Text(pDX, IDC_ICE, m_strICE);
	DDX_Text(pDX, IDC_DESC, m_strDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCellErrD, CDialog)
	//{{AFX_MSG_MAP(CCellErrD)
	ON_BN_CLICKED(IDC_WEB_HELP, OnWebHelp)
	ON_BN_CLICKED(IDC_NEXT, OnNext)
	ON_BN_CLICKED(IDC_PREVIOUS, OnPrevious)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCellErrD message handlers

BOOL CCellErrD::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_iItem = 0;
	
	// hide web help if special registry value not set. (non-ms)
	if (AfxGetApp()->GetProfileInt(_T("Validation"), _T("EnableHelp"), 0)==0) 
		((CButton *)GetDlgItem(IDC_WEB_HELP))->ShowWindow(SW_HIDE);

	UpdateControls();
	return TRUE;  // return TRUE unless you set the focus to a control
}

void CCellErrD::OnWebHelp() 
{
	if(!m_strURL.IsEmpty())
	{
		if (32 >= (const INT_PTR)ShellExecute(AfxGetMainWnd()->m_hWnd, _T("open"), m_strURL, _T(""), _T(""), SW_SHOWNORMAL)) 
			AfxMessageBox(_T("There was an error opening your browser. Web help is not available."));
	}
	else
		AfxMessageBox(_T("There is no help associated with this ICE at this time."));
}

void CCellErrD::OnNext() 
{
	m_iItem++;
	UpdateControls();
}

void CCellErrD::OnPrevious() 
{
	m_iItem--;
	UpdateControls();
}

void CCellErrD::UpdateControls() 
{
    // we don't handle the possibility of MAX_INT or more errors
	int iMaxItems = static_cast<int>(m_Errors->GetCount());

	// set the window title
	CString strTitle;
	strTitle.Format(_T("Message %d of %d"), m_iItem+1, iMaxItems);
	SetWindowText(strTitle);

	// enable/disable next/prev controls
	((CButton *)GetDlgItem(IDC_NEXT))->EnableWindow(m_iItem < iMaxItems-1);
	((CButton *)GetDlgItem(IDC_PREVIOUS))->EnableWindow(m_iItem > 0);

	COrcaData::COrcaDataError *Error = m_Errors->GetAt(m_Errors->FindIndex(m_iItem));
	// set the text values
	m_strDescription = Error->m_strDescription;
	m_strICE = Error->m_strICE;
	m_strURL = Error->m_strURL;
	switch (Error->m_eiError) {
	case iDataError : m_strType = _T("ERROR"); break;
	case iDataWarning : m_strType = _T("Warning"); break;
	default: ASSERT(false);
	}
	UpdateData(FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\cellerrd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_CELLERRD_H__25468EE4_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
#define AFX_CELLERRD_H__25468EE4_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CellErrD.h : header file
//

#include "stdafx.h"
#include "Orca.h"
#include "Data.h"

/////////////////////////////////////////////////////////////////////////////
// CCellErrD dialog

class CCellErrD : public CDialog
{
// Construction
public:
	CCellErrD(CWnd* pParent = NULL);   // standard constructor
	CCellErrD(const CTypedPtrList<CObList, COrcaData::COrcaDataError *> *list, CWnd* pParent = NULL);   // standard constructor
	CString m_strURL;

// Dialog Data
	//{{AFX_DATA(CCellErrD)
	enum { IDD = IDD_CELL_ERROR };
	CString	m_strType;
	CString	m_strICE;
	CString	m_strDescription;
	//}}AFX_DATA

	const CTypedPtrList<CObList, COrcaData::COrcaDataError *> *m_Errors;
	int m_iItem;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCellErrD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCellErrD)
	virtual BOOL OnInitDialog();
	afx_msg void OnWebHelp();
	afx_msg void OnNext();
	afx_msg void OnPrevious();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void UpdateControls();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CELLERRD_H__25468EE4_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\cmdline.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------
// cmdline.h - defines COrcaCommandLine class

#ifndef _ORCA_COMMAND_LINE_H_
#define _ORCA_COMMAND_LINE_H_

enum CommandTypes
{
	iNone,
	iMergeModule,
	iMsiDatabase,
	iOrcaDatabase,
	iSchema,
	iHelp,
	iLogFile,
	iExecuteMerge,
	iFeatures,
	iRedirect,
	iExtractDir,
	iLanguage,
	iExtractCAB,
	iExtractImage,
	iConfigureFile
};

class COrcaCommandLine : public CCommandLineInfo
{
public:
	COrcaCommandLine();

	void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast);

	BOOL m_bQuiet;
	CommandTypes m_eiDo;
	CString m_strSchema;
	CString m_strLogFile;
	BOOL m_bUnknown;

	// valid only if compiling product
	bool m_bNoImage;

	// variables valid only if doing merge modules
	BOOL m_bCommit;
	bool m_bForceCommit;
	CString m_strExecuteModule;
	CString m_strFeatures;
	CString m_strRedirect;
	CString m_strExtractDir;
	CString m_strExtractCAB;
	CString m_strExtractImage;
	CString m_strLanguage;
	CString m_strConfigFile;
	bool m_bNoCab;
	bool m_bLFN;
};	// end of COrcaCommandLine


COrcaCommandLine::COrcaCommandLine()
{
	m_nShellCommand = CCommandLineInfo::FileNew;
	m_strSchema = _T("orca.dat");
	m_bQuiet = FALSE;
	m_bUnknown = FALSE;

	m_bNoCab = false;
	m_bNoImage = false;
	m_bCommit = FALSE;
	m_bForceCommit = FALSE;
	m_eiDo = iNone;
	m_bLFN = FALSE;
}	// end of constructor

void COrcaCommandLine::ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast)
{
	static CommandTypes eiLastFlag = iNone;	// maintains state for this function

	// if we are doing help bail
	if (iHelp == m_eiDo)
		return;

	if (bFlag)
	{
		// if specifying schema
		if (0 == lstrcmpi(pszParam, _T("s")))
		{
			eiLastFlag = iSchema;
		}
		else if (0 == lstrcmpi(pszParam, _T("l")))	// specifying log file
		{
			eiLastFlag = iLogFile;
		}
		else if (0 == lstrcmpi(pszParam, _T("f")))	// specifying Features
		{
			eiLastFlag = iFeatures;
		}
		else if (0 == lstrcmpi(pszParam, _T("m")))	// specifying execute merge module
		{
			eiLastFlag = iExecuteMerge;
			m_nShellCommand = CCommandLineInfo::FileNothing;
		}
		else if (0 == lstrcmpi(pszParam, _T("r")))	// specifying Redirection Directory
		{
			eiLastFlag = 	iRedirect;
		}
		else if (0 == lstrcmpi(pszParam, _T("c")))	// specifying commit mode
		{
			m_bCommit = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == lstrcmpi(pszParam, _T("!")))	// specifying commit mode
		{
			m_bForceCommit = true;
			eiLastFlag = iNone;
		}
		else if (0 == lstrcmpi(pszParam, _T("g")))	// specify language
		{;
			eiLastFlag = iLanguage;
		}
		else if (0 == lstrcmpi(pszParam, _T("nocab")))	// specifying no CAB create
		{
			m_bNoCab = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == lstrcmpi(pszParam, _T("noimage")))	// specifying no source image
		{
			m_bNoImage = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == lstrcmpi(pszParam, _T("x")))	// merge module extraction dir
		{
			eiLastFlag = iExtractDir;
		}
		else if (0 == lstrcmpi(pszParam, _T("q")))	// specifying quiet mode
		{
			m_bQuiet = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == lstrcmpi(pszParam, _T("?")) ||
					0 == lstrcmpi(pszParam, _T("h")))	// specifying help mode
		{
			m_eiDo = iHelp;
			m_nShellCommand = CCommandLineInfo::FileNothing;
		}
		else if (0 == lstrcmpi(pszParam, _T("LFN")))	// specifying log file
		{
			m_bLFN = TRUE;
			eiLastFlag = iNone;
		}
		else if (0 == lstrcmpi(pszParam, _T("cab")))	// specifying cab path
		{
			eiLastFlag = iExtractCAB;
		}
		else if ((0 == lstrcmpi(pszParam, _T("i"))) ||	// specifying image path
			 (0 == lstrcmpi(pszParam, _T("image"))))
		{
			eiLastFlag = iExtractImage;
		}
		else if (0 == lstrcmpi(pszParam, _T("configure")))	// specifying image path
		{
			eiLastFlag = iConfigureFile;
		}

	}
	else	// database, module, or makefile
	{
		switch (eiLastFlag)
		{
		case iSchema:
			m_strSchema = pszParam;
			break;
		case iLogFile:
			eiLastFlag = iNone;
			m_strLogFile = pszParam;
			break;
		case iFeatures:
			m_strFeatures = pszParam;
			break;
		case iExecuteMerge:
			m_strExecuteModule = pszParam;
			m_eiDo = iExecuteMerge;
			m_nShellCommand = CCommandLineInfo::FileNothing;
			break;
		case iRedirect:
			m_strRedirect = pszParam;
			break;
		case iLanguage:
			m_strLanguage = pszParam;
			break;
		case iExtractDir:
			m_strExtractDir = pszParam;
			break;
		case iExtractCAB:
			m_strExtractCAB = pszParam;
			break;
		case iExtractImage:
			m_strExtractImage = pszParam;
			break;
		case iConfigureFile:
			m_strConfigFile = pszParam;
			break;
		default:
			int cchCount = lstrlen(pszParam);
			if (0 == lstrcmpi((pszParam + cchCount - 4), _T(".MSM")))
			{
				m_eiDo = iMergeModule;
				m_strFileName = pszParam;
				m_nShellCommand = CCommandLineInfo::FileOpen;
			}
			else	// any other file type, including unknown
			{
				// if we're not doing an execute merge just open
				if (m_eiDo != iExecuteMerge)
				{
					m_eiDo = iMsiDatabase;
					m_nShellCommand = CCommandLineInfo::FileOpen;
				}

				m_strFileName = pszParam;
			}
			break;
		}
		eiLastFlag = iNone;
	}
}	// end of ParseParam

#endif // _ORCA_COMMAND_LINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\column.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Column.cpp
//

#include "stdafx.h"
#include "Column.h"

///////////////////////////////////////////////////////////
// constructor
COrcaColumn::COrcaColumn(UINT iColumn, MSIHANDLE hColNames, MSIHANDLE hColTypes, BOOL bPrimaryKey)
{
	m_dwDisplayFlags = 0;
	m_iTransform = iTransformNone;
	m_iColumn = iColumn;

	DWORD cchBuffer = MAX_COLUMNNAME;
	MsiRecordGetString(hColNames, iColumn + 1, m_strName.GetBuffer(cchBuffer), &cchBuffer);
	m_strName.ReleaseBuffer();

	CString strBuffer;
	cchBuffer = MAX_COLUMNTYPE;
	MsiRecordGetString(hColTypes, iColumn + 1, strBuffer.GetBuffer(cchBuffer), &cchBuffer);
	strBuffer.ReleaseBuffer();

	// get the column type
	m_eiType = GetColumnType(strBuffer);

	// get the column size (_ttoi == atoi TCHAR)
	m_iSize = _ttoi(strBuffer.Mid(1));

	// if this is nuallable
	if (IsCharUpper(strBuffer[0]))
		m_bNullable = TRUE;
	else
		m_bNullable = FALSE;

	// set if primary key
	m_bPrimaryKey = (bPrimaryKey != 0);

	m_nWidth = -1;			// set the width invalid
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
COrcaColumn::~COrcaColumn()
{
}	// end of destructor

bool COrcaColumn::SameDefinition(UINT iColumn, MSIHANDLE hColNames, MSIHANDLE hColTypes, bool bPrimaryKey)
{
	m_iColumn = iColumn;
	OrcaColumnType eiType;
	int iSize;
	BOOL bNullable;
	CString strName;

	DWORD cchBuffer = MAX_COLUMNNAME;
	MsiRecordGetString(hColNames, iColumn + 1, strName.GetBuffer(cchBuffer), &cchBuffer);
	strName.ReleaseBuffer();

	CString strBuffer;
	cchBuffer = MAX_COLUMNTYPE;
	MsiRecordGetString(hColTypes, iColumn + 1, strBuffer.GetBuffer(cchBuffer), &cchBuffer);
	strBuffer.ReleaseBuffer();

	// get the column type
	eiType = GetColumnType(strBuffer);

	// get the column size (_ttoi == atoi TCHAR)
	iSize = _ttoi(strBuffer.Mid(1));

	// if this is nuallable
	if (IsCharUpper(strBuffer[0]))
		bNullable = TRUE;
	else
		bNullable = FALSE;

	// set if primary key
	if ((strName != m_strName) ||
		(eiType != m_eiType) || (iSize != m_iSize) || 
		(bNullable != m_bNullable) || (m_bPrimaryKey != bPrimaryKey))
		return false;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\cnfgmsmd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//--------------------------------------------------------------------------

// MergeD.cpp : merge module dialog implementation
//

#include "stdafx.h"
#include "Orca.h"
#include "cnfgmsmD.h"
#include "mergemod.h"
#include "table.h"
#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigMsmD dialog

inline CString BSTRtoCString(const BSTR bstrValue)
{
#ifdef _UNICODE
		return CString(bstrValue);
#else
		size_t cchLen = ::SysStringLen(bstrValue);
		CString strValue;
		LPTSTR szValue = strValue.GetBuffer(cchLen);
		WideToAnsi(bstrValue, szValue, &cchLen);
		strValue.ReleaseBuffer();
		return strValue;
#endif
}

CConfigMsmD::CConfigMsmD(CWnd* pParent /*=NULL*/)
	: CDialog(CConfigMsmD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConfigMsmD)
	m_strDescription = "";
	m_bUseDefault = TRUE;
	//}}AFX_DATA_INIT

	m_iOldItem = -1;
	m_pDoc = NULL;
	m_fComboIsKeyItem = false;
	m_iKeyItemKeyCount = 0;

	m_fReadyForInput = false;
	m_eActiveControl = eTextControl;
}


void CConfigMsmD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfigMsmD)
	DDX_Control(pDX, IDC_ITEMLIST, m_ctrlItemList);
	DDX_Control(pDX, IDC_EDITTEXT, m_ctrlEditText);
	DDX_Control(pDX, IDC_EDITNUMBER, m_ctrlEditNumber);
	DDX_Control(pDX, IDC_EDITCOMBO, m_ctrlEditCombo);
	DDX_Control(pDX, IDC_DESCRIPTION, m_ctrlDescription);
	DDX_Text(pDX, IDC_DESCRIPTION, m_strDescription);
	DDX_Check(pDX, IDC_FUSEDEFAULT, m_bUseDefault);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigMsmD, CDialog)
	//{{AFX_MSG_MAP(CConfigMsmD)
	ON_BN_CLICKED(IDC_FUSEDEFAULT, OnFUseDefault)
	ON_WM_DESTROY()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_ITEMLIST, OnItemchanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigMsmD message handlers
BOOL CheckFeature(LPCTSTR szFeatureName);

#define MAX_GUID 38
TCHAR   g_szOrcaWin9XComponentCode[MAX_GUID+1] = _T("{406D93CF-00E9-11D2-AD47-00A0C9AF11A6}");
TCHAR   g_szOrcaWinNTComponentCode[MAX_GUID+1] = _T("{BE928E10-272A-11D2-B2E4-006097C99860}");
TCHAR   g_szOrcaWin64ComponentCode[MAX_GUID+1] = _T("{2E083580-AB1C-4D2F-AA18-54DCC8BA5A64}");
TCHAR   g_szFeatureName[] = _T("MergeModServer");


struct sItemData
{
	IMsmConfigurableItem *piItem;
	CString strValue;
};

BOOL CConfigMsmD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	m_ctrlItemList.InsertColumn(1, TEXT("Name"), LVCFMT_LEFT, -1, 0);
	m_ctrlItemList.InsertColumn(1, TEXT("Value"), LVCFMT_LEFT, -1, 1);
	m_ctrlItemList.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);

	// create a Mergemod COM object
	IMsmMerge2* piExecute;
	HRESULT hResult = ::CoCreateInstance(CLSID_MsmMerge2, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
														  IID_IMsmMerge2, (void**)&piExecute);
	// if failed to create the object
	if (FAILED(hResult)) 
	{
		if (!CheckFeature(g_szFeatureName) || FAILED(::CoCreateInstance(CLSID_MsmMerge2, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
														  IID_IMsmMerge2, (void**)&piExecute)))
		EndDialog(-5);
		return TRUE;
	}

	// try to open the module
	WCHAR wzModule[MAX_PATH];
#ifndef _UNICODE
	size_t cchBuffer = MAX_PATH;
	::MultiByteToWideChar(CP_ACP, 0, m_strModule, -1, wzModule, cchBuffer);
#else
	lstrcpy(wzModule, m_strModule);
#endif	// _UNICODE
	BSTR bstrModule = ::SysAllocString(wzModule);
	hResult = piExecute->OpenModule(bstrModule, static_cast<short>(m_iLanguage));
	::SysFreeString(bstrModule);
	if (FAILED(hResult))
	{
		// module couldn't be open or doesn't support that language
    	piExecute->Release();
		if (hResult == HRESULT_FROM_WIN32(ERROR_OPEN_FAILED))
		{
			// file didn't exist or couldn't be opened
			EndDialog(-2);
		} 
		else if (hResult == HRESULT_FROM_WIN32(ERROR_INSTALL_LANGUAGE_UNSUPPORTED))
		{
			// unsupported language
			EndDialog(-3);
		}
		else
		{
			// general bad
			EndDialog(-4);
		}
		return TRUE;
	}
	
	// try to get the item enumerator
	int iFailed = 0;
	IMsmConfigurableItems* pItems;
	long cItems;
	hResult = piExecute->get_ConfigurableItems(&pItems);
	if (FAILED(hResult))
	{
		// malformed module or internal error
		piExecute->CloseModule();
		piExecute->Release();
		EndDialog(-4);
		return TRUE;
	}
	else 
	{
		if (FAILED(pItems->get_Count(&cItems)))
		{
			iFailed = -4;
		}
		else
		{
			if (cItems)
			{
				// get the enumerator, and immediately query it for the right type
				// of interface			
				IUnknown *pUnk;
				if (FAILED(pItems->get__NewEnum(&pUnk)))
				{
					iFailed = -4;
				}
				else
				{
					IEnumMsmConfigurableItem *pEnumItems;
					HRESULT hr = pUnk->QueryInterface(IID_IEnumMsmConfigurableItem, (void **)&pEnumItems);
					pUnk->Release();
	
					if (FAILED(hr))
					{
						iFailed = -4;
					}
					else
					{	
						// get the first error.
						unsigned long cItemFetched;
						IMsmConfigurableItem* pItem;
						if (FAILED(pEnumItems->Next(1, &pItem, &cItemFetched)))
							iFailed = -4;
	
						// while an item is fetched
						while (iFailed == 0 && cItemFetched && pItem)
						{
							// add the name
							BSTR bstrName;
							if (FAILED(pItem->get_DisplayName(&bstrName)))
							{
								iFailed = -4;
								break;
							}
							int iIndex = m_ctrlItemList.InsertItem(-1, BSTRtoCString(bstrName));
							::SysFreeString(bstrName);
							sItemData* pData = new sItemData;
							pData->piItem = pItem;
							pData->strValue = TEXT("");
							m_ctrlItemList.SetItemData(iIndex, reinterpret_cast<INT_PTR>(pData));
	
							// load the UI string for the default into the control
							if ((iFailed = SetToDefaultValue(iIndex)) < 0)
								break;
							
							// don't release the pItem, its stored in lParam
							if (FAILED(pEnumItems->Next(1, &pItem, &cItemFetched)))
								iFailed = -4;
						}
						pEnumItems->Release();
					}
				}
			}
		}
	}

	// close all the open files
	piExecute->CloseModule();

	// release and leave happy
	piExecute->Release();

	if (iFailed != 0)
		EndDialog(iFailed);

	ReadValuesFromReg();
	
	if (m_ctrlItemList.GetItemCount() > 0)
	{
		m_ctrlItemList.SetColumnWidth(0, LVSCW_AUTOSIZE);
		m_ctrlItemList.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
		m_ctrlItemList.SetItemState(0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
		
		// call the item changed handler to populate the initial controls
		NM_LISTVIEW nmlvTemp;
		nmlvTemp.iItem = 0;
		nmlvTemp.iSubItem = 0;
		nmlvTemp.lParam = m_ctrlItemList.GetItemData(0);
		LRESULT lRes;

		// need to fake out "change to same item" check to force a UI refresh and correct
		// activation of the context-sensitive controls
		m_fReadyForInput = true;
		OnItemchanged(reinterpret_cast<NMHDR *>(&nmlvTemp), &lRes);
	}
	else
		EndDialog(IDOK);

	return TRUE;  // return TRUE unless you set the focus to a control
}


////
// Given an item and an index into the item list control, sets the 
// item plus any secondary controls (combo, etc) to the default value.
// Secondary controls must be pre-popluated. Returns < 0 on failure 
// (can be used in endDialog), 0 on success.
int CConfigMsmD::SetToDefaultValue(int iItem)
{
	sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(iItem));
	IMsmConfigurableItem *pItem = pData->piItem;

	BSTR bstrValue;
	if (FAILED(pItem->get_DefaultValue(&bstrValue)))
	{
		return -4;
	}
	CString strValue = BSTRtoCString(bstrValue);
	::SysFreeString(bstrValue);

	int iRes = SetItemToValue(iItem, strValue);
	SetSelToString(strValue);
	return iRes;
}


////
// Given an item and a string value, sets the item display string 
// plus any secondary controls (combo, etc) to the provided value.
// Secondary controls must be pre-popluated. Returns < 0 on failure 
// (can be used in endDialog), 0 on success.
int CConfigMsmD::SetItemToValue(int iItem, const CString strValue)
{
	sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(iItem));
	IMsmConfigurableItem *pItem = pData->piItem;

	CString strDisplayValue;

	// if this is an enum or bitfield, must get the display string
	// for the default value, otherwise just stick in the default
	// value
	msmConfigurableItemFormat eFormat;
	if (FAILED(pItem->get_Format(&eFormat)))
	{
		return -4;
	}
	switch (eFormat)
	{
	case msmConfigurableItemText:
	{
		BSTR bstrType;
		if (FAILED(pItem->get_Type(&bstrType)))
		{
			return -4;
		}
		CString strType = BSTRtoCString(bstrType);
		::SysFreeString(bstrType);
		if (strType != TEXT("Enum"))
		{
			strDisplayValue = strValue;
			break;
		}
		// fall through to parse enum value
	}			
	case msmConfigurableItemBitfield:
	{
		BSTR bstrContext;
		if (FAILED(pItem->get_Context(&bstrContext)))
		{
			return -4;
		}
		CString strContext = BSTRtoCString(bstrContext);
		::SysFreeString(bstrContext);
		strDisplayValue = GetNameByValue(strContext, strValue, eFormat == msmConfigurableItemBitfield);
		break;		
	}
	case msmConfigurableItemKey:
	{
		// for key, need to turn strValue into strDisplayValue somehow
		strDisplayValue = "";
		for (int i=0; i < strValue.GetLength(); i++)
		{
			if (strValue[i] == TEXT('\\'))
				i++;
			strDisplayValue += strValue[i];
		}
		break;
	}
	case msmConfigurableItemInteger:
	default:
		strDisplayValue = strValue;
		break;
	}

	m_ctrlItemList.SetItem(iItem, 1, LVIF_TEXT, strDisplayValue, 0, 0, 0, 0);
	pData->strValue = strValue;
	return 0;
}

////
// Given a semicolon-delimited Name=Value set, populates the combo
// box with the "Name" strings
void CConfigMsmD::PopulateComboFromEnum(const CString& strData, bool fIsBitfield)
{
	CString strName;
	CString *pstrValue = new CString;
	bool fReadingValue = false;
	int i=0;
	if (fIsBitfield)
	{
		// skip up to the first semicolon
		while (strData[i] != '\0')
		{
			if (strData[i] == ';')
			{
				if (i==0 || strData[i-1] != '\\')
				{
					// skip over semicolon after mask
					i++;
					break;
				}
			}
			i++;
		}
	}
	
	for (; i <= strData.GetLength(); i++)
	{
		TCHAR ch = strData[i];
		switch (ch)
		{
		case TEXT('\\'):
			(fReadingValue ? *pstrValue : strName) += strData[++i];
			break;
		case TEXT('='):
			fReadingValue = true;
			break;
		case TEXT('\0'):
		case TEXT(';'):
		{
			int iItem = m_ctrlEditCombo.AddString(strName);
			if (iItem != CB_ERR)
				m_ctrlEditCombo.SetItemDataPtr(iItem, pstrValue);
			strName = "";
			pstrValue = new CString;
			fReadingValue = false;
			break;
		}
		default:
			(fReadingValue ? *pstrValue : strName) += ch;
			break;
		}
	}		
	delete pstrValue;
}


////
// Empty the combo box
void CConfigMsmD::EmptyCombo()
{
	// key items have data pointers to OrcaRow objects that don't belong to it.
	// can't free those
	if (!m_fComboIsKeyItem)
	{
		for (int i=0; i < m_ctrlEditCombo.GetCount(); i++)
		{
			CString *pData = static_cast<CString *>(m_ctrlEditCombo.GetItemDataPtr(i));
			if (pData)
				delete pData;
		}
	}
	m_ctrlEditCombo.ResetContent();	
}

////
// Given a semicolon-delimited Name=Value set, returns the value
// associate with strName. If fBitfield is set, skips over the first
// string (mask in bitfield types)
CString CConfigMsmD::GetValueByName(const CString& strInfo, const CString& strName, bool fIsBitfield)
{
	CString strThisName;
	bool fReturnThisValue = false;
	int i=0;
	if (fIsBitfield)
	{
		// skip up to the first semicolon
		while (strInfo[i] != '\0')
		{
			if (strInfo[i] == ';')
			{
				if (i==0 || strInfo[i-1] != '\\')
				{
					// skip over semicolon after mask
					i++;
					break;
				}
			}
			i++;
		}
	}

	for (; i <= strInfo.GetLength(); i++)
	{
		TCHAR ch = strInfo[i];
		switch (ch)
		{
		case TEXT('\\'):
			strThisName += strInfo[++i];
			break;
		case TEXT('='):
		{
			if (strName == strThisName)
				fReturnThisValue = true;
			strThisName = TEXT("");
			break;
		}
		case TEXT('\0'):
		case TEXT(';'):
			if (fReturnThisValue)
				return strThisName;
			strThisName = TEXT("");
			break;
		default:
			strThisName += ch;
			break;
		}
	}

	// hit the end of the string
	return TEXT("");
}


////
// Given a semicolon-delimited Name=Value set, returns the value
// associate with strName. If fBitfield is set, skips over the first
// string (mask in bitfield types)
CString CConfigMsmD::GetNameByValue(const CString& strInfo, const CString& strValue, bool fIsBitfield)
{
	CString strThisName;
	CString strThisValue;
	int i=0;
	if (fIsBitfield)
	{
		// skip up to the first semicolon
		while (strInfo[i] != '\0')
		{
			if (strInfo[i] == ';')
			{
				if (i==0 || strInfo[i-1] != '\\')
				{
					// skip over semicolon after mask
					i++;
					break;
				}
			}
			i++;
		}
	}

	bool fWritingName = true;
	for (; i <= strInfo.GetLength(); i++)
	{
		TCHAR ch = strInfo[i];
		switch (ch)
		{
		case TEXT('\\'):
			(fWritingName ? strThisName : strThisValue) += strInfo[++i];
			break;
		case TEXT('='):
			fWritingName = false;
			break;
		case TEXT('\0'):
		case TEXT(';'):
			if (strValue == strThisValue)
				return strThisName;
			strThisValue = TEXT("");
			strThisName = TEXT("");
			fWritingName = true;
			break;
		default:
			(fWritingName ? strThisName : strThisValue) += ch;
			break;
		}
	}

	return TEXT("");
}

////
// Sets the current selection in whatever edit control is active to the specified
// string, adding it to the combo box if necessary.
void CConfigMsmD::SetSelToString(const CString& strValue)
{
	// check which window is visible and save off the appropiate value
	switch (m_eActiveControl)
	{
	case eComboControl:
	{
		bool fHaveDataPtr = m_ctrlEditCombo.GetItemDataPtr(0) ? true : false;
		for (int iIndex=0; iIndex < m_ctrlEditCombo.GetCount(); iIndex++)
		{
			CString strText;
			m_ctrlEditCombo.GetLBText(iIndex, strText);
			if (strText == strValue)
				break;
		}
		
		// if we couldn't find an exact match, select the first item
		if (iIndex >= m_ctrlEditCombo.GetCount())
		{
			iIndex = 0;
		}	

		// set current selection to match whats in the item list
		m_ctrlEditCombo.SetCurSel(iIndex);
	}
	case eNumberControl:
	{
		m_ctrlEditNumber.SetWindowText(strValue);
	}
	case eTextControl:
	{
		m_ctrlEditText.SetWindowText(strValue);
	}
	}
}

////
// pulls the current value from whatever edit control is active and stores the string
// in the currently active item from the item list
void CConfigMsmD::SaveValueInItem()
{
	if (m_iOldItem >= 0)
	{
		// if the "use default" box is checked, don't save off the value
		if (!m_bUseDefault)
		{
			CString strValue;
			CString strDisplayValue;
		
			// check which window is visible and save off the appropiate value
			switch (m_eActiveControl)
			{
			case eComboControl:
			{
				int iIndex = m_ctrlEditCombo.GetCurSel();
				if (iIndex != CB_ERR)
				{				
					// if this is a key item, we need to do special processing to turn the selection
					// into a properly escaped string. Otherwise its a bitfield or enum, which means
					// the literal string is good enough
					if (m_fComboIsKeyItem)
					{
						strValue = TEXT("");
						COrcaRow *pRow = static_cast<COrcaRow *>(m_ctrlEditCombo.GetItemDataPtr(iIndex));
						if (pRow)
						{	
							for (int i=0; i < m_iKeyItemKeyCount; i++)
							{
								CString strThisColumn = pRow->GetData(i)->GetString();
								for (int cChar=0; cChar < strThisColumn.GetLength(); cChar++)
								{
									if ((strThisColumn[cChar] == TEXT(';')) || 
										(strThisColumn[cChar] == TEXT('=')) || 
										(strThisColumn[cChar] == TEXT('\\')))
										strValue += TEXT('\\');			
									strValue += strThisColumn[cChar];
								}
								if (i != m_iKeyItemKeyCount-1)
									strValue += TEXT(';');
							}
						}
					}
					else
					{
						// get Bitfield or Combo value
						strValue = *static_cast<CString *>(m_ctrlEditCombo.GetItemDataPtr(iIndex));
					}
					m_ctrlEditCombo.GetLBText(iIndex, strDisplayValue);
				}
				break;
			}
			case eNumberControl:
			{
				m_ctrlEditNumber.GetWindowText(strValue);
				strDisplayValue = strValue;
				break;
			}
			case eTextControl:
			{
				m_ctrlEditText.GetWindowText(strValue);
				strDisplayValue = strValue;
				break;
			}
			}
			
			sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(m_iOldItem));
			m_ctrlItemList.SetItemText(m_iOldItem, 1, strDisplayValue);
			pData->strValue = strValue;
		}
	}
}

////
// Enables and disables the edit boxes for the item, and restores the default if
// turned on.
void CConfigMsmD::OnFUseDefault() 
{
	UpdateData(TRUE);
	EnableBasedOnDefault();
	m_ctrlItemList.SetItemState(m_iOldItem, m_bUseDefault ? 0 : INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);

	if (m_bUseDefault)
	{
		SetToDefaultValue(m_iOldItem);
	}
}

void CConfigMsmD::OnOK() 
{
	// run through the list placing name/value pairs into the callback object
	ASSERT(m_pCallback);

	// first save value in case any editing is in-progress
	SaveValueInItem();

	// clear out the combo box to avoid leaking the values
	EmptyCombo();

	// save values to the registry
	WriteValuesToReg();
	
	int iCount = m_ctrlItemList.GetItemCount();
	for (int i=0; i < iCount; i++)
	{
		// no addref, no release
		sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(i));
		BSTR bstrName;
		if (FAILED(pData->piItem->get_Name(&bstrName)))
		{
			// **** fail
			continue;
		}
		m_pCallback->m_lstData.AddTail(BSTRtoCString(bstrName));
		::SysFreeString(bstrName);
		
		// add value
		m_pCallback->m_lstData.AddTail(pData->strValue);
	}

	CDialog::OnOK();
}

void CConfigMsmD::OnDestroy() 
{
	EmptyCombo();
	int iCount = m_ctrlItemList.GetItemCount();
	for (int i=0; i < iCount; i++)
	{
		sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(i));
		pData->piItem->Release();
		delete pData;
	}
	
	CDialog::OnDestroy();
}


void CConfigMsmD::EnableBasedOnDefault()
{
	m_ctrlEditCombo.EnableWindow(!m_bUseDefault);
	m_ctrlEditNumber.EnableWindow(!m_bUseDefault);
	m_ctrlEditText.EnableWindow(!m_bUseDefault);
}

void CConfigMsmD::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	// if we're still populating the list control, don't bother doing anything
	if (!m_fReadyForInput)
		return;
		
	// if this is a "no-op change"
	if (m_iOldItem == pNMListView->iItem)
	{
		*pResult = 0;
		return;
	}

	// save the old value into the control
	SaveValueInItem();

	// save off new item as old item for next click
	m_iOldItem = pNMListView->iItem;

	// retrieve the interface pointer. No AddRef, No Release.
	sItemData *pData = reinterpret_cast<sItemData *>(pNMListView->lParam);
	IMsmConfigurableItem* pItem = pData->piItem;

	// set the "default" checkbox based on the state image mask
	m_bUseDefault = m_ctrlItemList.GetItemState(m_iOldItem, LVIS_STATEIMAGEMASK) ? FALSE : TRUE;
	EnableBasedOnDefault();
	
	// set the description
	BSTR bstrString;
	if (FAILED(pItem->get_Description(&bstrString)))
		m_strDescription = "";
    else
		m_strDescription = BSTRtoCString(bstrString);
	if (bstrString)
		::SysFreeString(bstrString);

	// set the value
	msmConfigurableItemFormat eFormat;
	if (FAILED(pItem->get_Format(&eFormat)))
	{
		// if we couldn't get the format for some reason, assume text
		eFormat = msmConfigurableItemText;
	}
	switch (eFormat)
	{
	case msmConfigurableItemText:
	{
		BSTR bstrType = NULL;
		CString strType;
		if (FAILED(pItem->get_Type(&bstrType)))
		{
			// if we couldn't get the type, assume its an empty text type
			strType = "";
		}
		else
			strType = BSTRtoCString(bstrType);
		if (bstrType)
            ::SysFreeString(bstrType);
		if (strType == TEXT("Enum"))
		{
			EmptyCombo();
			m_ctrlEditNumber.ShowWindow(SW_HIDE);
			m_ctrlEditText.ShowWindow(SW_HIDE);
			BSTR bstrContext = NULL;
			CString strContext;
			if (FAILED(pItem->get_Context(&bstrContext)))
			{
				// an enum where we couldn't get the context. Any 
				// default is bound to be bad, so use an empty string
				strContext = "";
			}
			else
				strContext = BSTRtoCString(bstrContext);
			if (bstrContext)
				::SysFreeString(bstrContext);
			m_iKeyItemKeyCount = 0;
			m_fComboIsKeyItem = false;
			PopulateComboFromEnum(strContext, false);
			m_eActiveControl = eComboControl;
			m_ctrlEditCombo.ShowWindow(SW_SHOW);
		}
		else
		{
			// plain text
			m_eActiveControl = eTextControl;
			m_ctrlEditCombo.ShowWindow(SW_HIDE);
			m_ctrlEditNumber.ShowWindow(SW_HIDE);
			m_ctrlEditText.ShowWindow(SW_SHOW);
		}
		break;
	}
	case msmConfigurableItemInteger:
		m_eActiveControl = eNumberControl;
		m_ctrlEditCombo.ShowWindow(SW_HIDE);
		m_ctrlEditText.ShowWindow(SW_HIDE);
		m_ctrlEditNumber.ShowWindow(SW_SHOW);
		break;
	case msmConfigurableItemKey:
	{
		m_ctrlEditCombo.ResetContent();
		m_ctrlEditNumber.ShowWindow(SW_HIDE);
		m_ctrlEditText.ShowWindow(SW_HIDE);

		// populate the combo box with the keys in the appropriate table
		BSTR bstrTable = NULL;
		CString strTable;
		if (FAILED(pItem->get_Type(&bstrTable)))
		{
			// if we couldn't get the table name, anything we do is bad
			strTable = "";
		}
		else
			strTable = BSTRtoCString(bstrTable);
		if (bstrTable)
			::SysFreeString(bstrTable);
		
		COrcaTable* pTable = m_pDoc->FindAndRetrieveTable(strTable);
		if (pTable)
		{
			POSITION pos = pTable->GetRowHeadPosition();
			int cPrimaryKeys = pTable->GetKeyCount();
			while (pos)
			{
				CString strDisplayString = TEXT("");
				const COrcaRow* pRow = pTable->GetNextRow(pos);
				ASSERT(pRow);
				if (pRow)
				{
					const COrcaData* pData = pRow->GetData(0);
					ASSERT(pData);
					if (pData)
					{
						strDisplayString = pData->GetString();
					}
				}
				for (int i=1; i < cPrimaryKeys; i++)
				{
					strDisplayString += TEXT(";");
					ASSERT(pRow);
					if (pRow)
					{
						const COrcaData* pData = pRow->GetData(i);
						ASSERT(pData);
						if (pData)
							strDisplayString += pData->GetString();
					}
				}
				int iItem = m_ctrlEditCombo.AddString(strDisplayString);
				if (iItem != CB_ERR)
					m_ctrlEditCombo.SetItemDataPtr(iItem, const_cast<void *>(static_cast<const void *>(pRow)));
			}
			m_iKeyItemKeyCount = cPrimaryKeys;
		}
		
		// if the item is nullable, add the empty string
		long lAttributes = 0;
		if (FAILED(pItem->get_Attributes(&lAttributes)))
		{
			// couldn't get attributes, default is 0
			lAttributes = 0;
		}
		if ((lAttributes & msmConfigurableOptionNonNullable) == 0)
		{
			m_ctrlEditCombo.AddString(TEXT(""));
		}
		m_fComboIsKeyItem = true;
		
		m_eActiveControl = eComboControl;
		m_ctrlEditCombo.ShowWindow(SW_SHOW);
		break;
	}
	case msmConfigurableItemBitfield:
	{
		EmptyCombo();
		m_ctrlEditNumber.ShowWindow(SW_HIDE);
		m_ctrlEditText.ShowWindow(SW_HIDE);
		BSTR bstrContext = NULL;
		CString strContext;
		if (FAILED(pItem->get_Context(&bstrContext)))
		{
			// a bitfield where we couldn't get the context. Any 
			// default is bound to be bad, so use an empty string
			strContext = "";
		}
		else
			strContext = BSTRtoCString(bstrContext);
		if (bstrContext)
            ::SysFreeString(bstrContext);
		m_iKeyItemKeyCount = 0;
		m_fComboIsKeyItem = false;
		PopulateComboFromEnum(strContext, true);
		m_eActiveControl = eComboControl;
		m_ctrlEditCombo.ShowWindow(SW_SHOW);
		break;
	}
	}		

	// set the edit control to the current value
	CString strDefault = m_ctrlItemList.GetItemText(m_iOldItem, 1);
	SetSelToString(strDefault);

	UpdateData(FALSE);

	// m_ctrlDescription.ModifyStyle(WS_VSCROLL, 0);
	m_ctrlDescription.ShowScrollBar(SB_VERT, FALSE);

	// if EM_SCROLL returns non-zero in the lower word, it means that
	// the control scrolled a page down. Add a scrollbar and reflow the
	// text in the control.
	if (m_ctrlDescription.SendMessage(EM_SCROLL, SB_PAGEDOWN, 0) & 0xFFFF)
	{
		m_ctrlDescription.SendMessage(EM_SCROLL, SB_PAGEUP, 0);
		m_ctrlDescription.ShowScrollBar(SB_VERT, TRUE);
	}
	
	*pResult = 0;
}

void CConfigMsmD::ReadValuesFromReg()
{
	if (0 == AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("MemoryCount"), 0))
		return;

	CString strFileName;
	int iFirstChar = m_strModule.ReverseFind(TEXT('\\'));
	if (iFirstChar == -1)
		strFileName = m_strModule;
	else
		strFileName = m_strModule.Right(m_strModule.GetLength()-iFirstChar-1);
	strFileName.TrimRight();
	strFileName.MakeLower();

	HKEY hKey = 0;
	CString strKeyName;
	strKeyName.Format(TEXT("Software\\Microsoft\\Orca\\MergeMod\\CMSMInfo\\%s:%d"), strFileName, m_iLanguage);
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, strKeyName, 0, KEY_READ, &hKey))
	{
		int cItemCount = m_ctrlItemList.GetItemCount();
		ASSERT(cItemCount);
		for (int iItem = 0; iItem < cItemCount; iItem++)
		{
			sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(iItem));
			ASSERT(pData);
			BSTR bstrName = NULL;
			if (FAILED(pData->piItem->get_Name(&bstrName)))
			{
				ASSERT(0);
				// without a name we have no chance of finding the registry value
				continue;
			}
			CString strName = BSTRtoCString(bstrName);
			::SysFreeString(bstrName);
	
			DWORD cbBuffer = 0;
			if (ERROR_SUCCESS == RegQueryValueEx(hKey, strName, 0, NULL, NULL, &cbBuffer))
			{
				CString strValue;
				TCHAR *szBuffer = strValue.GetBuffer(cbBuffer/sizeof(TCHAR));
				if (ERROR_SUCCESS != RegQueryValueEx(hKey, strName, 0, NULL, reinterpret_cast<unsigned char *>(szBuffer), &cbBuffer))
				{
					// if we failed reading the registry, not much we can do
					ASSERT(0);
					continue;
				}
				strValue.ReleaseBuffer();  
	
				// if this is a key item, the key must be valid in the current database. If its not,
				// just use the module's default
				msmConfigurableItemFormat eFormat = msmConfigurableItemText;
				if ((S_OK == pData->piItem->get_Format(&eFormat)) && (eFormat == msmConfigurableItemKey))
				{
					BSTR bstrTable = NULL;
					if (FAILED(pData->piItem->get_Type(&bstrTable)))
					{
						// couldn't get the type for Key. No chance to load primary keys
						ASSERT(0);
						continue;
					}

					CString strTable = BSTRtoCString(bstrTable);
					if (bstrName)
						::SysFreeString(bstrName);
					COrcaTable *pTable = NULL;
					ASSERT(m_pDoc);
					if (m_pDoc)
					{
						pTable = m_pDoc->FindAndRetrieveTable(strTable);
					}
					if (!pTable)
					{
						continue;
					}

					// find the row that has primary keys that match this. 
					CString strThisKey=TEXT("");
					CStringArray rgstrRows;
					rgstrRows.SetSize(pTable->GetKeyCount());
					int iKey = 0;
					for (int i=0; i < strValue.GetLength(); i++)
					{
						switch (strValue[i])
						{
						case ';' :
							rgstrRows.SetAt(iKey++, strThisKey);
							strThisKey=TEXT("");
							break;
						case '\\' :
							i++;
							// fall through
						default:
							strThisKey += strValue[i];
						}
					}
					rgstrRows.SetAt(iKey, strThisKey);

					if (!pTable->GetData(pTable->ColArray()->GetAt(0)->m_strName, rgstrRows))
						continue;
				}
				
				// set this item to not use the default
				m_ctrlItemList.SetItemState(iItem, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);

				// store the value, handles creation of display values as necessary
				SetItemToValue(iItem, strValue);

				// making this non-default enables the edit controls. Set the current state
				SetSelToString(strValue);
			}
		}
		RegCloseKey(hKey);
	}
}

void CConfigMsmD::WriteValuesToReg()
{
	int iMemoryLimit = 0;
	if (0 == (iMemoryLimit = AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("MemoryCount"), 0)))
		return;

	CString strFileName;
	int iFirstChar = m_strModule.ReverseFind(TEXT('\\'));
	if (iFirstChar == -1)
		strFileName = m_strModule;
	else
		strFileName = m_strModule.Right(m_strModule.GetLength()-iFirstChar-1);
	strFileName.TrimRight();
	strFileName.MakeLower();

	HKEY hBaseKey = 0;
	UINT uiRes = 0;

	// open the CMSM config key 
	if (ERROR_SUCCESS == (uiRes = RegCreateKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Orca\\MergeMod\\CMSMInfo"), 0, TEXT(""), 0, KEY_READ | KEY_WRITE, NULL, &hBaseKey, NULL)))
	{
		HKEY hModuleKey = 0;

		CString strKeyName;
		strKeyName.Format(TEXT("%s:%d"), strFileName, m_iLanguage);
		CString strOriginalName = strKeyName;
		
		if (ERROR_SUCCESS == (uiRes = RegCreateKeyEx(hBaseKey, strKeyName, 0, TEXT(""), 0, KEY_WRITE, NULL, &hModuleKey, NULL)))
		{
			int cItemCount = m_ctrlItemList.GetItemCount();
			for (int iItem = 0; iItem < cItemCount; iItem++)
			{
				sItemData *pData = reinterpret_cast<sItemData *>(m_ctrlItemList.GetItemData(iItem));
				BSTR bstrName = NULL;
				if (FAILED(pData->piItem->get_Name(&bstrName)))
				{
					// no way to write into registry without the name
					continue;
				}
				CString strName = BSTRtoCString(bstrName);
				::SysFreeString(bstrName);
				
				// if not using the default, write to the registry, otherwise ensure its been deleted
				if (m_ctrlItemList.GetItemState(iItem, LVIS_STATEIMAGEMASK) == 0)
				{
					RegDeleteValue(hModuleKey, strName);
					continue;
				}
				else
				{		
					RegSetValueEx(hModuleKey, strName, 0, REG_SZ, reinterpret_cast<const unsigned char *>(static_cast<const TCHAR *>(pData->strValue)), (pData->strValue.GetLength()+1)*sizeof(TCHAR));
				}
			}
			RegCloseKey(hModuleKey);
		}

		// adjust the ordering of the MRU module list
		int iNext = 1;
		CString strName;
		strName.Format(TEXT("%d"), iNext);
		DWORD cbBuffer;

		// continue looping as long as we have more keys
		while (ERROR_SUCCESS == (uiRes = RegQueryValueEx(hBaseKey, strName, 0, NULL, NULL, &cbBuffer)))
		{
			CString strValue;
							
			TCHAR *szBuffer = strValue.GetBuffer(cbBuffer/sizeof(TCHAR));
			if (ERROR_SUCCESS != RegQueryValueEx(hBaseKey, strName, 0, NULL, reinterpret_cast<unsigned char *>(szBuffer), &cbBuffer))
			{
				// nothing we can do on registry failure
				continue;
			}
			strValue.ReleaseBuffer();

			// if this index is greater than the memory limit, delete the key
			if (iNext > iMemoryLimit)
				RegDeleteKey(hBaseKey, strValue);
			else
			{
				// if this value was the name of the module' being used, we can stop
				// shifting the order at this point
				if (strValue == strOriginalName)
					break;
					
				// otherwise set the value of this guy to the MRU module
				RegSetValueEx(hBaseKey, strName, 0, REG_SZ, reinterpret_cast<const unsigned char *>(static_cast<const TCHAR *>(strKeyName)), (strKeyName.GetLength()+1)*sizeof(TCHAR));

				// and set the previous value as the value to place in the next highest thing
				strKeyName = strValue;
			}

			iNext++;
			strName.Format(TEXT("%d"), iNext);
		}

		// if we finished everything and iNext isn't outside the memory limit, add a new index for this
		// module
		if (iNext <= iMemoryLimit)
			RegSetValueEx(hBaseKey, strName, 0, REG_SZ, reinterpret_cast<const unsigned char *>(static_cast<const TCHAR *>(strKeyName)), (strKeyName.GetLength()+1)*sizeof(TCHAR));
		else
			RegDeleteKey(hBaseKey, strKeyName);
			
		RegCloseKey(hBaseKey);
	}
}

///////////////////////////////////////////////////////////////////////
// This class implements the callback interface for the configurable
// merge system.


CMsmConfigCallback::CMsmConfigCallback()
{
	m_cRef = 1;
}

HRESULT CMsmConfigCallback::QueryInterface(const IID& iid, void** ppv)
{
	// find corresponding interface
	if (iid == IID_IUnknown)
		*ppv = static_cast<IMsmConfigureModule*>(this);
	if (iid == IID_IDispatch)
		*ppv = static_cast<IMsmConfigureModule*>(this);
	else if (iid == IID_IMsmConfigureModule)
		*ppv = static_cast<IMsmConfigureModule*>(this);
	else	// interface is not supported
	{
		// blank and bail
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	// up the refcount and return okay
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}	// end of QueryInterface

///////////////////////////////////////////////////////////
// AddRef - increments the reference count
ULONG CMsmConfigCallback::AddRef()
{
	// increment and return reference count
	return InterlockedIncrement(&m_cRef);
}	// end of AddRef

///////////////////////////////////////////////////////////
// Release - decrements the reference count
ULONG CMsmConfigCallback::Release()
{
	// decrement reference count and if we're at zero
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		// deallocate component
		delete this;
		return 0;		// nothing left
	}

	// return reference count
	return m_cRef;
}	// end of Release


/////////////////////////////////////////////////////////////////////////////
// IDispatch interface
HRESULT CMsmConfigCallback::GetTypeInfoCount(UINT* pctInfo)
{
	if(NULL == pctInfo)
		return E_INVALIDARG;

	*pctInfo = 0;
	return S_OK;
}

HRESULT CMsmConfigCallback::GetTypeInfo(UINT iTInfo, LCID /* lcid */, ITypeInfo** ppTypeInfo)
{
	if (NULL == ppTypeInfo)
		return E_INVALIDARG;

	*ppTypeInfo = NULL;
	return E_NOINTERFACE;
}

HRESULT CMsmConfigCallback::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
						 LCID lcid, DISPID* rgDispID)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	if (cNames == 0 || rgszNames == 0 || rgDispID == 0)
		return E_INVALIDARG;

	bool fError = false;
	for (UINT i=0; i < cNames; i++)
	{
		// CSTR_EQUAL == 2
		if(2 == CompareStringW(lcid, NORM_IGNORECASE, rgszNames[i], -1, L"ProvideTextData", -1))
		{
			rgDispID[i] = 1; // constant DispId for this interface
		}
		else if (2 == CompareStringW(lcid, NORM_IGNORECASE, rgszNames[i], -1, L"ProvideIntegerData", -1))
		{
			rgDispID[i] = 2;
		}
		else
		{
			fError = true;
			rgDispID[i] = -1;
		}
	}
	return fError ? DISP_E_UNKNOWNNAME : S_OK;
}

HRESULT CMsmConfigCallback::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
				  DISPPARAMS* pDispParams, VARIANT* pVarResult,
				  EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	if (wFlags & (DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
		return DISP_E_MEMBERNOTFOUND;

	HRESULT hRes = S_OK;
	switch (dispIdMember)
	{
	case 1:
		if (pDispParams->cArgs != 1)
			return E_INVALIDARG;

		return ProvideTextData(pDispParams->rgvarg[1].bstrVal, &pVarResult->bstrVal);
		break;
	case 2:
		if (pDispParams->cArgs != 1)
			return E_INVALIDARG;

		return ProvideIntegerData(pDispParams->rgvarg[1].bstrVal, &pVarResult->lVal);
		break;
	default:
		return DISP_E_MEMBERNOTFOUND;
	}
	return S_OK;
}

HRESULT CMsmConfigCallback::ProvideTextData(const BSTR Name, BSTR __RPC_FAR *ConfigData)
{
	CString strName = BSTRtoCString(Name);
	POSITION pos = m_lstData.GetHeadPosition();
	while (pos)
	{
		if (m_lstData.GetNext(pos) == strName)
		{
			ASSERT(pos);
			CString strValue = m_lstData.GetNext(pos);
#ifndef _UNICODE
            size_t cchBuffer = strValue.GetLength()+1;
            WCHAR* wzValue = new WCHAR[cchBuffer];
            ::MultiByteToWideChar(CP_ACP, 0, strValue, -1, wzValue, cchBuffer);
			*ConfigData = ::SysAllocString(wzValue);
            delete[] wzValue;
#else
			*ConfigData = ::SysAllocString(strValue);
#endif	// _UNICODE
			return S_OK;
		}

		// if the name doesn't match, skip over the value
		m_lstData.GetNext(pos);
	}

	// didn't find the name, so use the default
	return S_FALSE;
}

bool CMsmConfigCallback::ReadFromFile(const CString strFile)
{
	CStdioFile fileInput;
	if (!fileInput.Open(strFile, CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))
		return false;

	CString strLine;
	while (fileInput.ReadString(strLine))
	{
		int iEqualsLoc = strLine.Find(TEXT('='));
		if (iEqualsLoc == -1)
			return false;

		m_lstData.AddTail(strLine.Left(iEqualsLoc));
		m_lstData.AddTail(strLine.Right(strLine.GetLength()-iEqualsLoc-1));
	}
	return true;
}


HRESULT CMsmConfigCallback::ProvideIntegerData(const BSTR Name, long __RPC_FAR *ConfigData)
{
	CString strName = BSTRtoCString(Name);
	POSITION pos = m_lstData.GetHeadPosition();
	while (pos)
	{
		if (m_lstData.GetNext(pos) == strName)
		{
			ASSERT(pos);
			CString strValue = m_lstData.GetNext(pos);
			*ConfigData = _ttol(strValue);
			return S_OK;
		}

		// if the name doesn't match, skip over the value
		m_lstData.GetNext(pos);
	}

	// didn't find the name, so use the default
	return S_FALSE;
}

///////////////////////////////////////////////////////////
// CheckFeature
// szFeatureName is a Feature that belongs to this product. 
// installs the feature if not present
BOOL CheckFeature(LPCTSTR szFeatureName)
{
#ifndef _WIN64
	// determine platform (Win9X or WinNT) -- EXE component code conditionalized on platform
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); // init structure
	if (!GetVersionEx(&osvi))
		return FALSE;

	bool fWin9X = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ? true : false;
#endif

	// get ProductCode -- Windows Installer can determine the product code from a component code.
	// Here we use the Orca main component (component containing orca.exe).  You must choose
	// a component that identifies the app, not a component that could be shared across products.
	// This is why we can't use the MergeMod component. EvalCom is shared between msival2 and orca
	// so the Windows Installer would be unable to determine to which product (if both were installed)
	// the component belonged.
	TCHAR szProductCode[MAX_GUID+1] = TEXT("");
	UINT iStat = 0;
	if (ERROR_SUCCESS != (iStat = MsiGetProductCode(
#ifdef _WIN64
		g_szOrcaWin64ComponentCode,
#else
		fWin9X ? g_szOrcaWin9XComponentCode : g_szOrcaWinNTComponentCode,
#endif
											szProductCode)))
	{
		// error obtaining product code (may not be installed or component code may have changed)
		return FALSE;
	}

	// Prepare to use the feature: check its current state and increase usage count.
	INSTALLSTATE iFeatureState = MsiUseFeature(szProductCode, szFeatureName);

	// If feature is not currently usable, try fixing it
	switch (iFeatureState) 
	{
	case INSTALLSTATE_LOCAL:
	case INSTALLSTATE_SOURCE:
		break;
	case INSTALLSTATE_ABSENT:
		// feature isn't installed, try installing it
		if (ERROR_SUCCESS != MsiConfigureFeature(szProductCode, szFeatureName, INSTALLSTATE_LOCAL))
			return FALSE;			// installation failed
		break;
	default:
		// feature is busted- try fixing it
		if (MsiReinstallFeature(szProductCode, szFeatureName, 
			REINSTALLMODE_FILEEQUALVERSION
			+ REINSTALLMODE_MACHINEDATA 
			+ REINSTALLMODE_USERDATA
			+ REINSTALLMODE_SHORTCUT) != ERROR_SUCCESS)
			return FALSE;			// we couldn't fix it
		break;
	}

	return TRUE;
}	// end of CheckFeature


BEGIN_MESSAGE_MAP(CStaticEdit, CEdit)
	ON_WM_NCHITTEST( )
END_MESSAGE_MAP()

UINT CStaticEdit::OnNcHitTest( CPoint point )
{
	UINT iRes = CEdit::OnNcHitTest(point);
	if (HTCLIENT == iRes)
		return HTTRANSPARENT;
	else
		return iRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\cnfgmsmd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//--------------------------------------------------------------------------

#if !defined(AFX_CNFGMSMD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
#define AFX_CNFGMSMD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "orcadoc.h"
#include "mergemod.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigMsmD dialog
class CMsmConfigCallback;

class CStaticEdit : public CEdit
{
protected:
	afx_msg UINT OnNcHitTest( CPoint point );
	DECLARE_MESSAGE_MAP()
};

class CConfigMsmD : public CDialog
{
// Construction
public:
	CConfigMsmD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConfigMsmD)
	enum { IDD = IDD_CONFIGUREMSM };
	CComboBox	m_ctrlEditCombo;
	CEdit       m_ctrlEditNumber;
	CEdit       m_ctrlEditText;
	CStaticEdit       m_ctrlDescription;
	CListCtrl   m_ctrlItemList;
	CString	m_strDescription;
	BOOL	m_bUseDefault;
	//}}AFX_DATA

	CString m_strModule;
	int     m_iLanguage;
	int     m_iOldItem;
	COrcaDoc* m_pDoc;
	CMsmConfigCallback *m_pCallback;
	
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigMsmD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigMsmD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnDestroy();
	afx_msg void OnFUseDefault();
	// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);

private:
	void EnableBasedOnDefault();
	void SetSelToString(const CString& strValue);
	void SaveValueInItem();
	void PopulateComboFromEnum(const CString& strValue, bool fIsBitfield);
	CString GetValueByName(const CString& strInfo, const CString& strName, bool fIsBitfield);
	CString GetNameByValue(const CString& strInfo, const CString& strValue, bool fIsBitfield);
	void CConfigMsmD::EmptyCombo();
	int SetToDefaultValue(int iItem);
	int SetItemToValue(int iItem, const CString strValue);

	void ReadValuesFromReg();
	void WriteValuesToReg();

	bool m_fReadyForInput;
	bool m_fComboIsKeyItem;
	enum {
		eTextControl,
		eComboControl,
		eNumberControl
	} m_eActiveControl;
	int  m_iKeyItemKeyCount;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

// this class implements the callback interface
class CMsmConfigCallback : public IMsmConfigureModule
{
	
public:
	CMsmConfigCallback();
	
	// IUnknown interface
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID& iid, void** ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IDispatch methods
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTI);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
														 LCID lcid, DISPID* rgDispID);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
											   DISPPARAMS* pDispParams, VARIANT* pVarResult,
												EXCEPINFO* pExcepInfo, UINT* puArgErr);
	HRESULT STDMETHODCALLTYPE InitTypeInfo();


	HRESULT STDMETHODCALLTYPE ProvideTextData(const BSTR Name, BSTR __RPC_FAR *ConfigData);
	HRESULT STDMETHODCALLTYPE ProvideIntegerData(const BSTR Name, long __RPC_FAR *ConfigData);

	// non-interface methods
	bool ReadFromFile(const CString strFile);
	
	CStringList m_lstData;

private:
	long m_cRef;
};

#endif // !defined(AFX_CNFGMSMD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\data.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Data.cpp
//

#include "stdafx.h"
#include "Data.h"
#include "CellErrD.h"
#include "orcadoc.h"

///////////////////////////////////////////////////////////
// constructor
COrcaData::COrcaData()
{
	m_strData = "";
	m_dwFlags = 0;
	m_pErrors = NULL;
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
COrcaData::~COrcaData()
{
	ClearErrors();
}	// end of destructor


void COrcaData::AddError(int tResult, CString strICE, CString strDesc, CString strURL)
{
	COrcaDataError *newerror = new COrcaDataError();

	newerror->m_eiError = (OrcaDataError)tResult;
	newerror->m_strICE = strICE;
	newerror->m_strURL = strURL;
	newerror->m_strDescription = strDesc;

	if (!m_pErrors)
		m_pErrors = new CTypedPtrList<CObList, COrcaDataError *>;
	if (m_pErrors)
		m_pErrors->AddTail(newerror);
}

void COrcaData::ClearErrors()
{
	SetError(iDataNoError);
	if (m_pErrors)
	{
		POSITION pos = m_pErrors->GetHeadPosition();
		while (pos != NULL) {
			delete m_pErrors->GetNext(pos);
		};
		m_pErrors->RemoveAll();
		delete m_pErrors;
		m_pErrors = NULL;
	}
}

void COrcaData::ShowErrorDlg() const
{
	if (m_pErrors)
	{
		CCellErrD ErrorD(m_pErrors);
		ErrorD.DoModal();
	}
}



// retrieve the string representation of an integer. Display flags
// indicate hex or decimal. Value cached in m_strData, so only
// recalculated when the requested state changes.
const CString& COrcaIntegerData::GetString(DWORD dwFlags) const 
{
	if (IsNull())
	{
		if ((m_dwFlags & iDataFlagsCacheMask) != iDataFlagsCacheNull)
		{
			m_strData = TEXT("");
			m_dwFlags = (m_dwFlags & ~iDataFlagsCacheMask) | iDataFlagsCacheNull;
		}
	}
	else 
	{
		// check the requested format, Hex or Decimal
		if (dwFlags & iDisplayFlagsHex)
		{
			// check if recache required
			if ((m_dwFlags & iDataFlagsCacheMask) != iDataFlagsCacheHex)
			{
				m_strData.Format(TEXT("0x%08X"), m_dwValue);
				m_dwFlags = (m_dwFlags & ~iDataFlagsCacheMask) | iDataFlagsCacheHex;
			}
		}
		else
		{
			// check if recache required
			if ((m_dwFlags & iDataFlagsCacheMask) != iDataFlagsCacheDecimal)
			{
				m_strData.Format(TEXT("%d"), m_dwValue);
				m_dwFlags = (m_dwFlags & ~iDataFlagsCacheMask) | iDataFlagsCacheDecimal;
			}
		}
	}

	// return currently cached value
	return m_strData; 
};

////
// set integer data based on string. If the string is invalid,
// the cell doesn't change and false is returned
bool COrcaIntegerData::SetData(const CString& strData)
{
	if (strData.IsEmpty()) 
	{
		SetNull(true); 
		return true;
	} 
	else
	{
		DWORD dwValue = 0;
		if (ValidateIntegerValue(strData, dwValue))
		{
			SetIntegerData(dwValue);
			return true;
		}
	}
	return false;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\displypp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// DisplayPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "DisplyPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDisplayPropPage property page

IMPLEMENT_DYNCREATE(CDisplayPropPage, CPropertyPage)

CDisplayPropPage::CDisplayPropPage() : CPropertyPage(CDisplayPropPage::IDD)
{
	//{{AFX_DATA_INIT(CDisplayPropPage)
	m_sFontName = _T("");
	m_bCaseSensitive = FALSE;
	m_bForceColumns = FALSE;
	//}}AFX_DATA_INIT

	m_pbrshSelect = NULL;
	m_pbrshNormal = NULL;
	m_pbrshFocus = NULL;
	m_pbrshSelectT = NULL;
	m_pbrshNormalT = NULL;
	m_pbrshFocusT = NULL;
}

CDisplayPropPage::~CDisplayPropPage()
{
	delete m_pbrshSelect;	
	delete m_pbrshFocus;	
	delete m_pbrshNormal;	
	delete m_pbrshSelectT;	
	delete m_pbrshFocusT;	
	delete m_pbrshNormalT;	
}

void CDisplayPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDisplayPropPage)
	DDX_Text(pDX, IDC_FONTNAME, m_sFontName);
	DDX_Check(pDX, IDC_CASESENSITIVE, m_bCaseSensitive);
	DDX_Check(pDX, IDC_FORCECOLUMNS, m_bForceColumns);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDisplayPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CDisplayPropPage)
	ON_BN_CLICKED(IDC_CHFONT, OnChfont)
	ON_WM_DESTROY()
	ON_WM_CTLCOLOR()
	ON_BN_CLICKED(IDC_COLORSEL, OnColorsel)
	ON_BN_CLICKED(IDC_COLORFOCUS, OnColorfocus)
	ON_BN_CLICKED(IDC_COLORNORM, OnColornorm)
	ON_BN_CLICKED(IDC_TEXTSEL, OnTextsel)
	ON_BN_CLICKED(IDC_TEXTFOCUS, OnTextfocus)
	ON_BN_CLICKED(IDC_TEXTNORM, OnTextnorm)
	ON_BN_CLICKED(IDC_CASESENSITIVE, OnDataChange)
	ON_BN_CLICKED(IDC_FORCECOLUMNS, OnDataChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDisplayPropPage message handlers

void CDisplayPropPage::OnChfont() 
{
	// run the font dialog
	if (IDOK == m_pdFontDialog->DoModal()) 
	{
		m_bFontChange = true;
		m_strFontName = m_pdFontDialog->GetFaceName();
		m_iFontSize = m_pdFontDialog->GetSize();
		UpdateFontName();
		UpdateData(FALSE);
	}
}

BOOL CDisplayPropPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	m_pdFontDialog = new CFontDialog(&m_fSelectedFont, 
		CF_EFFECTS|CF_SCREENFONTS|CF_FORCEFONTEXIST|CF_INITTOLOGFONTSTRUCT, NULL, this);
	m_strFontName = m_pdFontDialog->GetFaceName();

	m_bColorChange = false;
	m_bFontChange = false;
	m_bMiscChange = false;
	UpdateFontName();
	UpdateData(FALSE);
	return TRUE;  
}

void CDisplayPropPage::OnDestroy() 
{
	CPropertyPage::OnDestroy();
	delete m_pdFontDialog;	
}

HBRUSH CDisplayPropPage::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{	
	if (nCtlColor == CTLCOLOR_STATIC)
	{
		pDC->SetBkMode(TRANSPARENT);
		switch (pWnd->GetDlgCtrlID())
		{
		case IDC_SELSAMP: pDC->SetTextColor(m_clrTextSel);
		case IDC_COLORSEL: return *m_pbrshSelect;
		case IDC_NORMSAMP: pDC->SetTextColor(m_clrTextNorm);
		case IDC_COLORNORM: return *m_pbrshNormal;
		case IDC_FOCSAMP: pDC->SetTextColor(m_clrTextFoc);
		case IDC_COLORFOCUS: return *m_pbrshFocus;
		case IDC_TEXTSEL: return *m_pbrshSelectT;
		case IDC_TEXTNORM: return *m_pbrshNormalT;
		case IDC_TEXTFOCUS: return *m_pbrshFocusT;
		default: break;
		}
	}
	return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
}

void CDisplayPropPage::GetColors(COLORREF &norm, COLORREF &sel, COLORREF &foc)
{
	LOGBRUSH lbrshTemp;
	m_pbrshSelect->GetLogBrush(&lbrshTemp);
	sel = lbrshTemp.lbColor;
	m_pbrshNormal->GetLogBrush(&lbrshTemp);
	norm = lbrshTemp.lbColor;
	m_pbrshFocus->GetLogBrush(&lbrshTemp);
	foc = lbrshTemp.lbColor;
}

void CDisplayPropPage::GetColorsT(COLORREF &norm, COLORREF &sel, COLORREF &foc)
{
	norm = m_clrTextNorm;
	sel = m_clrTextSel;
	foc = m_clrTextFoc;
}

COLORREF CDisplayPropPage::OnColorDialog(CBrush **newBrush) 
{
	COLORREF clrRet;
	LOGBRUSH lbrshTemp;
	(*newBrush)->GetLogBrush(&lbrshTemp);
	clrRet = lbrshTemp.lbColor;
	CColorDialog *pdColorDialog = new CColorDialog(clrRet);

	if (IDOK == pdColorDialog->DoModal()) 
	{
		delete *newBrush;
		clrRet = pdColorDialog->GetColor();
		*newBrush = new CBrush(clrRet);
		m_bColorChange = true;
	};
	delete pdColorDialog;
	return clrRet;
}	

void CDisplayPropPage::UpdateFontName()
{
	m_sFontName.Format(_T("%s, %0.1fpt."), m_strFontName, (float)(m_iFontSize)/10.0);
}

void CDisplayPropPage::OnColorfocus() 
{
	OnColorDialog(&m_pbrshFocus);
	GetDlgItem(IDC_COLORFOCUS)->Invalidate();
	GetDlgItem(IDC_FOCSAMP)->Invalidate();	
}

void CDisplayPropPage::OnColornorm() 
{
	OnColorDialog(&m_pbrshNormal);
	GetDlgItem(IDC_COLORNORM)->Invalidate();	
	GetDlgItem(IDC_NORMSAMP)->Invalidate();
}

void CDisplayPropPage::OnColorsel() 
{
	OnColorDialog(&m_pbrshSelect);
	GetDlgItem(IDC_COLORSEL)->Invalidate();	
	GetDlgItem(IDC_SELSAMP)->Invalidate();	
}


void CDisplayPropPage::OnTextsel() 
{
	m_clrTextSel=OnColorDialog(&m_pbrshSelectT);
	GetDlgItem(IDC_TEXTSEL)->Invalidate();	
	GetDlgItem(IDC_SELSAMP)->Invalidate();	
}

void CDisplayPropPage::OnTextfocus() 
{
	m_clrTextFoc = OnColorDialog(&m_pbrshFocusT);
	GetDlgItem(IDC_TEXTFOCUS)->Invalidate();	
	GetDlgItem(IDC_FOCSAMP)->Invalidate();	
}

void CDisplayPropPage::OnTextnorm() 
{
	m_clrTextNorm = OnColorDialog(&m_pbrshNormalT);
	GetDlgItem(IDC_TEXTNORM)->Invalidate();	
	GetDlgItem(IDC_NORMSAMP)->Invalidate();	
}

void CDisplayPropPage::SetColors(COLORREF norm, COLORREF sel, COLORREF foc)
{
	m_pbrshSelect = new CBrush();
	m_pbrshFocus = new CBrush();
	m_pbrshNormal = new CBrush();
	m_pbrshSelect->CreateSolidBrush(sel);
	m_pbrshFocus->CreateSolidBrush(foc);
	m_pbrshNormal->CreateSolidBrush(norm);
}

void CDisplayPropPage::SetColorsT(COLORREF norm, COLORREF sel, COLORREF foc)
{
	m_pbrshSelectT = new CBrush();
	m_pbrshFocusT = new CBrush();
	m_pbrshNormalT = new CBrush();
	m_pbrshSelectT->CreateSolidBrush(sel);
	m_pbrshFocusT->CreateSolidBrush(foc);
	m_pbrshNormalT->CreateSolidBrush(norm);
	m_clrTextNorm = norm;
	m_clrTextSel = sel;
	m_clrTextFoc = foc;
}
void CDisplayPropPage::OnDataChange() 
{
	m_bMiscChange = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\column.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Column.h
//

#ifndef _ORCA_COLUMN_H_
#define _ORCA_COLUMN_H_

#define MAX_COLUMNNAME 64
#define MAX_COLUMNTYPE 64

#include "msiquery.h"
#include "data.h"

enum OrcaColumnType
{
	iColumnNone,
	iColumnString,
	iColumnLocal,
	iColumnShort,
	iColumnLong,
	iColumnBinary
};

class COrcaColumn : public CObject
{

public:
	COrcaColumn(UINT iColumn, MSIHANDLE hColNames, MSIHANDLE hColTypes, BOOL bPrimaryKey);
	~COrcaColumn();

	// transform information
	inline const OrcaTransformAction IsTransformed() const { return m_iTransform; };
	inline void Transform(const OrcaTransformAction iAction) { ASSERT(iAction != iTransformDrop); m_iTransform = iAction; }; 
	inline bool DisplayInHex() const { return (m_dwDisplayFlags & iDisplayFlagsHex) ? true : false; };
	inline void SetDisplayInHex(bool fHex) const { m_dwDisplayFlags = (m_dwDisplayFlags & ~iDisplayFlagsHex) | (fHex ? iDisplayFlagsHex : 0); };
	inline bool IsPrimaryKey() const { return m_bPrimaryKey; };
	bool SameDefinition(UINT iColumn, MSIHANDLE hColNames, MSIHANDLE hColTypes, bool bPrimaryKey);

	UINT m_iColumn;
	CString m_strName;
	OrcaColumnType m_eiType;
	int m_iSize;
	
	mutable int m_nWidth;
	mutable int m_dwDisplayFlags;

	BOOL m_bNullable;
	OrcaTransformAction m_iTransform;

private:
	bool m_bPrimaryKey;
};	// end of COrcaColumn

///////////////////////////////////////////////////////////
// GetColumnType
static OrcaColumnType GetColumnType(LPCTSTR szColumnType)
{
	OrcaColumnType iType;

	switch (*szColumnType)
	{
	case _T('s'):		// string
	case _T('S'):
		iType = iColumnString;
		break;
	case _T('l'):		// localizable string
	case _T('L'):
		iType = iColumnLocal;
		break;
	case _T('i'):		// integer
	case _T('I'):
		// if the number is a 2 use short
		if (_T('2') == *(szColumnType + 1))
			iType = iColumnShort;
		else if (_T('4') == *(szColumnType + 1))	// if 4 use LONG
			iType = iColumnLong;
		else	// don't know
			iType = iColumnNone;
		break;
	case L'v':	// binary
	case L'V':
	case L'o':
	case L'O':
		iType = iColumnBinary;
		break;
	default:	// unknown
		iType = iColumnNone;
	}

	return iType;
}

const int COLUMN_INVALID = 0xFFFFFF;

#endif	// _ORCA_COLUMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\data.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Data.h
//

#ifndef _ORCA_DATA_H_
#define _ORCA_DATA_H_

#include "stdafx.h"
#include "msiquery.h"

enum OrcaDataError
{
	iDataNoError = 0,
	iDataError   = 1,
	iDataWarning = 2
};

enum OrcaTransformAction
{
	iTransformNone   = 0,
	iTransformChange = 1,
	iTransformAdd    = 2,
	iTransformDrop   = 3
};



// each cell has a DWORD of bit flags. The lower word is data cell
// flags. The high word is reserved for private display data that is not
// part of the real cell info.
//
// 31                           16                               0
// - - - - - - - - - - - - - C C C - - - - - - - - - - T T - N E E
// 
// C - cached format
// T - cell transform state
// N - null cell flag
// E - error bits

const DWORD iDataFlagsNull          = 0x0004;
const DWORD iDataFlagsErrorMask     = 0x0003;

const DWORD iDataFlagsTransformMask	= 0x0030;
const DWORD iDataFlagsDataMask      = 0xFFFF;

const DWORD iDataFlagsTransformShift = 4;
const DWORD iDataFlagsErrorShift     = 0;

const DWORD iDataFlagsCacheDecimal = 0x10000;
const DWORD iDataFlagsCacheHex     = 0x20000;
const DWORD iDataFlagsCacheNull    = 0x40000;
const DWORD iDataFlagsCacheMask    = 0x70000;

// flags passed to GetString to indicate desired format
const DWORD iDisplayFlagsDecimal = 0x00;
const DWORD iDisplayFlagsHex     = 0x01;

class COrcaDoc;

class OrcaFindInfo {
public:
	bool bWholeDoc;
	int iCount;
	bool bValid;
	CString strFindString;
	CString strUIFindString;
	bool bForward;
	bool bMatchCase;
	bool bWholeWord;

	////
	// operator== only checks the search options, not the results, so two queries
	// are equal even if they are in different states of the actual search
	inline bool operator==(OrcaFindInfo& b) {
		return ((strUIFindString == b.strUIFindString) && (b.bForward == bForward) &&
				(bMatchCase == b.bMatchCase) && (bWholeWord == b.bWholeWord));
	}
	inline bool operator!=(OrcaFindInfo& b) { return !operator==(b); };
};


class COrcaData : public CObject
{
	friend class CCellErrD;

public:
	COrcaData();
	~COrcaData();

	// retrieve display string.
	virtual const CString& GetString(DWORD dwFlags=0) const=0;

	// set/retrieve transform state
	inline const OrcaTransformAction IsTransformed() const { return static_cast<OrcaTransformAction>((m_dwFlags & iDataFlagsTransformMask) >> iDataFlagsTransformShift); };
	inline void  Transform(const OrcaTransformAction iAction) {	m_dwFlags = (m_dwFlags & ~iDataFlagsTransformMask) | (iAction << iDataFlagsTransformShift); };

	// set/retrieve error state
	inline void  SetError(const OrcaDataError eiError) { m_dwFlags = (m_dwFlags & ~iDataFlagsErrorMask) | (eiError << iDataFlagsErrorShift); };
	inline OrcaDataError GetError() const { return static_cast<OrcaDataError>((m_dwFlags & iDataFlagsErrorMask) >> iDataFlagsErrorShift); };
	
	// cell is null?
	inline bool IsNull() const { return (m_dwFlags & iDataFlagsNull) ? true : false; };
	
	// set data based on string.
	virtual bool SetData(const CString& strData)=0;

	// error manipulation
	void ClearErrors();
	void AddError(int tResult, CString strICE, CString strDesc, CString strURL);
	void ShowErrorDlg() const;

	// class to hold error information
	class COrcaDataError : public CObject
	{	
	public:
		OrcaDataError m_eiError;		// error type for message
		CString m_strICE;				// ice causing error
		CString m_strDescription;		// description of error
		CString m_strURL;				// URL top help with error
	};

protected:
	// set cell null flag
	inline void SetNull(bool fNullable) { m_dwFlags = (m_dwFlags & ~iDataFlagsNull) | (fNullable ? iDataFlagsNull : 0); };
	
	// see comments above for format of bitfield. Often contains
	// cache flags, so mutable
	mutable DWORD m_dwFlags;

	// string data. Often used as just a cache, so mutable.
	mutable CString m_strData;

	// pointer to list of errors for this cell. If NULL, no error.
	CTypedPtrList<CObList, COrcaDataError *> *m_pErrors;
};	// end of COrcaData


///////////////////////////////////////////////////////////////////////
// integer data cell. Stores data as DWORD. String in base class is 
// used to cache string representation (in hex or decimal)
class COrcaIntegerData : public COrcaData
{
public:
	COrcaIntegerData() : COrcaData(), m_dwValue(0) {};
	virtual ~COrcaIntegerData() {};

	virtual const CString& GetString(DWORD dwFlags=0) const;
	const DWORD GetInteger() const { return m_dwValue; };

	bool SetData(const CString& strData);
	inline void SetIntegerData(const DWORD dwData) { SetNull(false); m_dwValue = dwData; m_dwFlags = (m_dwFlags & ~iDataFlagsCacheMask);
};

private:
	DWORD m_dwValue;
};

class COrcaStringData : public COrcaData
{
public:
	virtual const CString& GetString(DWORD dwFlags=0) const { return m_strData; };

	bool SetData(const CString& strData) { SetNull(strData.IsEmpty() ? true : false); m_strData = strData; return true;};
private:
};

#endif	// _ORCA_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\displypp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_DISPLAYPROPPAGE_H__68AFD20E_2594_11D2_8888_00A0C981B015__INCLUDED_)
#define AFX_DISPLAYPROPPAGE_H__68AFD20E_2594_11D2_8888_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DisplayPropPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDisplayPropPage dialog

class CDisplayPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CDisplayPropPage)

// Construction
public:
	bool m_bMiscChange;
	void SetColors(COLORREF norm, COLORREF sel, COLORREF foc);
	void SetColorsT(COLORREF norm, COLORREF sel, COLORREF foc);
	bool m_bColorChange;
	void CDisplayPropPage::GetColors(COLORREF &norm, COLORREF &sel, COLORREF &foc);
	void CDisplayPropPage::GetColorsT(COLORREF &norm, COLORREF &sel, COLORREF &foc);
	CString m_strFontName;
	LOGFONT m_fSelectedFont;
	int m_iFontSize;
	bool m_bFontChange;
	CDisplayPropPage();
	~CDisplayPropPage();
	CFontDialog* m_pdFontDialog;

// Dialog Data
	//{{AFX_DATA(CDisplayPropPage)
	enum { IDD = ID_PAGE_FONT };
	CString	m_sFontName;
	BOOL	m_bCaseSensitive;
	BOOL    m_bForceColumns;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDisplayPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDisplayPropPage)
	afx_msg void OnChfont();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnColorsel();
	afx_msg void OnColorfocus();
	afx_msg void OnColornorm();
	afx_msg void OnTextsel();
	afx_msg void OnTextfocus();
	afx_msg void OnTextnorm();
	afx_msg void OnDataChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void UpdateFontName();
	COLORREF OnColorDialog(CBrush **newBrush); 
	
	CBrush * m_pbrshSelect;
	CBrush * m_pbrshFocus;
	CBrush * m_pbrshNormal;
	CBrush * m_pbrshSelectT;
	CBrush * m_pbrshFocusT;
	CBrush * m_pbrshNormalT;
	COLORREF m_clrTextNorm;
	COLORREF m_clrTextSel;
	COLORREF m_clrTextFoc;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DISPLAYPROPPAGE_H__68AFD20E_2594_11D2_8888_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\domerge.h ===
/////////////////////////////////////////////////////////////////////////////
// domerge.h
//		A MergeMod client
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#ifndef _DOMERGE_H_
#define _DOMERGE_H_

#define WINDOWS_LEAN_AND_MEAN 
#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>

typedef void (* LPMERGEDISPLAY)(const BSTR);

enum eCommit_t { 
	commitNo = 0,
	commitYes = 1,
	commitForce = 2
};

struct IMsmConfigureModule;
struct IMsmErrors;
HRESULT ExecuteMerge(const LPMERGEDISPLAY pfnDisplay, const TCHAR *szDatabase, const TCHAR *szModule, 
					 const TCHAR *szFeatures, const int iLanguage = -1, const TCHAR *szRedirectDir = NULL, 
					 const TCHAR *szCABDir = NULL, const TCHAR *szExtractDir = NULL,  const TCHAR *szImageDir = NULL, 
					 const TCHAR *szLogFile = NULL, bool fLogAfterOpen = false, bool fLFN = false, 
					 IMsmConfigureModule* piConfig = NULL, IMsmErrors** ppiErrors = NULL, eCommit_t eCommit = commitNo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\editbind.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_EDITBIND_H__28D3018A_0558_11D2_AD4E_00A0C9AF11A6__INCLUDED_)
#define AFX_EDITBIND_H__28D3018A_0558_11D2_AD4E_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EditBinD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditBinD dialog

class CEditBinD : public CDialog
{
// Construction
public:
	CEditBinD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditBinD)
	enum { IDD = IDD_BINARY_EDIT };
	int		m_nAction;
    bool    m_fNullable;
	bool    m_fCellIsNull;
	CString	m_strFilename;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditBinD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditBinD)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowse();
	virtual void OnOK();
	afx_msg void OnAction();
	afx_msg void OnRadio2();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDITBIND_H__28D3018A_0558_11D2_AD4E_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\domerge.cpp ===
/////////////////////////////////////////////////////////////////////////////
// domerge.cpp
//		A MergeMod client
//		Copyright (C) Microsoft Corp 1998.  All Rights Reserved.
// 

#include "..\common\utils.h"
#include "msiquery.h"
#include <winerror.h>
#include <objbase.h>
#include <initguid.h>
#include "mergemod.h"
#include "msidefs.h"
#include "domerge.h"

///////////////////////////////////////////////////////////
// CheckFeature
// pre:	szFeatureName is a Feature that belongs to this product
// pos:	installs the feature if not present and we go
/*
BOOL CheckFeature(LPCTSTR szFeatureName)
{
	// Prepare to use the feature: check its current state and increase usage count.
	INSTALLSTATE iFeatureState = MSI::MsiUseFeature(g_szProductCode, szFeatureName);
	//MsiQueryFeatureState(g_szProductCode, szFeatureName);
	

	// If feature is not currently usable, try fixing it
	switch (iFeatureState) 
	{
	case INSTALLSTATE_LOCAL:
	case INSTALLSTATE_SOURCE:
		break;
	case INSTALLSTATE_ABSENT:
		// feature isn't installed, try installing it
		if (ERROR_SUCCESS != MSI::MsiConfigureFeature(g_szProductCode, szFeatureName, INSTALLSTATE_LOCAL))
			return FALSE;			// installation failed
		break;
	default:
		// feature is busted- try fixing it
		if (MsiReinstallFeature(g_szProductCode, szFeatureName, 
			REINSTALLMODE_FILEEQUALVERSION
			+ REINSTALLMODE_MACHINEDATA 
			+ REINSTALLMODE_USERDATA
			+ REINSTALLMODE_SHORTCUT) != ERROR_SUCCESS)
			return FALSE;			// we couldn't fix it
		break;
	}

	return TRUE;
}	// end of CheckFeature
*/

HRESULT ExecuteMerge(const LPMERGEDISPLAY pfnDisplay, const TCHAR *szDatabase, const TCHAR *szModule, 
			 const TCHAR *szFeatures, const int iLanguage, const TCHAR *szRedirectDir, const TCHAR *szCABDir, 
			 const TCHAR *szExtractDir, const TCHAR *szImageDir, const TCHAR *szLogFile, bool fLogAfterOpen,
			 bool fLFN, IMsmConfigureModule *piConfigureInterface, IMsmErrors** ppiErrors, eCommit_t eCommit)
{
	if ((!szDatabase) || (!szModule) || (!szFeatures))
		return E_INVALIDARG;

	if (ppiErrors)
		*ppiErrors = NULL;

	// create a Mergemod COM object
	IMsmMerge2* pIExecute;
	HRESULT hResult = ::CoCreateInstance(CLSID_MsmMerge2, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
														  IID_IMsmMerge2, (void**)&pIExecute);

	// if failed to create the object
	if (FAILED(hResult)) 
	{
		printf("Could not load Merge Module COM Server");
		return hResult;
	}

	if (!fLogAfterOpen && szLogFile && (szLogFile[0] != TEXT('\0')))
	{
		// open the log file
		WCHAR wzLogFile[MAX_PATH];
#ifndef _UNICODE
		int cchBuffer = MAX_PATH;
		::MultiByteToWideChar(CP_ACP, 0, szLogFile, -1, wzLogFile, cchBuffer);
#else
		lstrcpy(wzLogFile, szLogFile);
#endif
		BSTR bstrLogFile = ::SysAllocString(wzLogFile);
		pIExecute->OpenLog(bstrLogFile);
		::SysFreeString(bstrLogFile);
	}

	WCHAR wzModule[MAX_PATH] = L"";
	WCHAR wzFeature[91] = L"";
	WCHAR wzRedirect[91] = L"";


	// calculate the language to be used
	int iUseLang = -1;
	if (iLanguage == -1)
	{
		UINT iType;
		int iValue;
		FILETIME ftValue;
		UINT iResult;
		LPTSTR szValue = new TCHAR[100];
		DWORD cchValue = 100;


		PMSIHANDLE hSummary;
		::MsiGetSummaryInformation(0, szDatabase, 0, &hSummary);
		iResult = ::MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, &iType, &iValue, &ftValue, szValue, &cchValue);
		if (ERROR_MORE_DATA == iResult) 
		{
			delete[] szValue;
			szValue = new TCHAR[++cchValue];
			iResult = ::MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, &iType, &iValue, &ftValue, szValue, &cchValue);
		}
		if (ERROR_SUCCESS != iResult)
		{
			delete[] szValue;
			BSTR bstrLog = ::SysAllocString(L">> Unable to retrieve language from database SummaryInfo stream.\r\n");
			pIExecute->Log(bstrLog);
			if (pfnDisplay) pfnDisplay(bstrLog);
			::SysFreeString(bstrLog);
			pIExecute->Release();
			return E_FAIL;
		}

		// the string now contains the template property
		// parse it for the semicolon
		TCHAR *szSemi = _tcschr(szValue, _T(';'));
		TCHAR *szLanguage = (szSemi != NULL) ? szSemi+1 : szValue;
		if (_istdigit(*szLanguage)) 
			iUseLang = _ttoi(szLanguage);
		delete[] szValue;
	}
	else 
		iUseLang = iLanguage;

	// check that we have a language
	if (iUseLang == -1)
	{
		BSTR bstrLog = ::SysAllocString(L">> Unable to determine language to use for merge module. Specify a language on the command line.\r\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
		pIExecute->Release();
		return E_FAIL;
	}

	// open the database
	WCHAR wzDatabase[MAX_PATH];
#ifndef _UNICODE
	int cchBuffer = MAX_PATH;
	::MultiByteToWideChar(CP_ACP, 0, szDatabase, -1, wzDatabase, cchBuffer);
#else
	lstrcpy(wzDatabase, szDatabase);
#endif	// _UNICODE
	BSTR bstrDatabase = ::SysAllocString(wzDatabase);
	hResult = pIExecute->OpenDatabase(bstrDatabase);
	::SysFreeString(bstrDatabase);
	if (FAILED(hResult))
	{
		BSTR bstrLog = SysAllocString(L">> Fatal Error: Failed to open MSI Database.\r\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
		pIExecute->Release();
		return E_FAIL;
	}

	if (fLogAfterOpen && szLogFile && (szLogFile[0] != TEXT('\0')))
	{
		// open the log file
		WCHAR wzLogFile[MAX_PATH];
#ifndef _UNICODE
		int cchBuffer = MAX_PATH;
		::MultiByteToWideChar(CP_ACP, 0, szLogFile, -1, wzLogFile, cchBuffer);
#else
		lstrcpy(wzLogFile, szLogFile);
#endif
		BSTR bstrLogFile = ::SysAllocString(wzLogFile);
		pIExecute->OpenLog(bstrLogFile);
		::SysFreeString(bstrLogFile);
	}

	// try to open the module
#ifndef _UNICODE
	cchBuffer = MAX_PATH;
	::MultiByteToWideChar(CP_ACP, 0, szModule, -1, wzModule, cchBuffer);
#else
	lstrcpy(wzModule, szModule);
#endif	// _UNICODE
	BSTR bstrModule = ::SysAllocString(wzModule);
	hResult = pIExecute->OpenModule(bstrModule, static_cast<short>(iUseLang));
	::SysFreeString(bstrModule);
	if (FAILED(hResult))
	{
		BSTR bstrLog = ::SysAllocString(L">> Failed to open Merge Module.\r\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
		pIExecute->Release();
		return E_FAIL;
	}


	// if there is a colon
	TCHAR * szExtraFeatures = _tcschr(szFeatures, _T(':'));
	if (szExtraFeatures)
	{
		*szExtraFeatures = _T('\0');
		szExtraFeatures = _tcsinc(szExtraFeatures);
	}

#ifndef _UNICODE
	cchBuffer = 91;
	::MultiByteToWideChar(CP_ACP, 0, szFeatures, -1, wzFeature, cchBuffer);
#else
	lstrcpy(wzFeature, szFeatures);
#endif

	// create a wide version of the redirect dir
	if (szRedirectDir)
	{
#ifndef _UNICODE
		cchBuffer = 91;
		::MultiByteToWideChar(CP_ACP, 0, szRedirectDir, -1, wzRedirect, cchBuffer);
#else
		lstrcpy(wzRedirect, szRedirectDir);
#endif
	}

	bool fPerformExtraction = false;
	BSTR bstrFeature = ::SysAllocString(wzFeature);
	BSTR bstrRedirect = ::SysAllocString(wzRedirect);
	hResult = pIExecute->MergeEx(bstrFeature, bstrRedirect, piConfigureInterface);
	::SysFreeString(bstrFeature);
	::SysFreeString(bstrRedirect);
	if (FAILED(hResult))
	{
		fPerformExtraction = false;
		BSTR bstrLog = ::SysAllocString(L">> Failed to merge Merge Module.\r\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
	}
	else
	{
		fPerformExtraction = true;

		// while there is something to set the feature to the extra features
		while (szExtraFeatures)
		{
			*(szExtraFeatures-1) = _T(':');
			// if there is a colon
			TCHAR *szTemp = _tcschr(szExtraFeatures, _T(':'));
			if (szTemp) 
				*szTemp = _T('\0');
	
	#ifndef _UNICODE
			cchBuffer = 91;
			::MultiByteToWideChar(CP_ACP, 0, szExtraFeatures, -1, wzFeature, cchBuffer);
	#else
			lstrcpy(wzFeature, szExtraFeatures);
	#endif	// _UNICODE
			bstrFeature = ::SysAllocString(wzFeature);
			hResult = pIExecute->Connect(wzFeature);
			::SysFreeString(bstrFeature);
	
			if (szTemp) 
			{
				*szTemp = _T(':');
				szExtraFeatures = _tcsinc(szTemp);
			} 
			else
				szExtraFeatures = NULL;
		}
	}

	// try to get the error enumerator
	if (ppiErrors)
		hResult = pIExecute->get_Errors(ppiErrors);

	IMsmErrors* pErrors;
	long cErrors;
	hResult = pIExecute->get_Errors(&pErrors);
	if (FAILED(hResult))
	{
		BSTR bstrLog = ::SysAllocString(L">> Error: Failed to retrieve errors.\n");
		pIExecute->Log(bstrLog);
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);
		if (eCommit != commitForce) eCommit = commitNo;
	}
	else 
	{
		pErrors->get_Count(&cErrors);
		if (0 != cErrors)	// if there are a few errors
		{
			if (eCommit != commitForce) eCommit = commitNo;
		}
		// log the errors
		msmErrorType errType;							// error type returned
		UINT iErrorCount = 0;				// number of errors displayed

		TCHAR szLogError[1025];				// string to ready to display to log
		WCHAR wzDisplay[1025];				// string to actually display to log
#ifndef _UNICODE
		char szErrorBuffer[1025];			// buffer to display strings
		size_t cchErrorBuffer = 1025;
#endif	// !_UNICODE
		ULONG cErrorsFetched;				// number of errors returned
		IMsmError* pIError;

		// get the enumerator, and immediately query it for the right type
		// of interface
		IUnknown *pUnk;
		IEnumMsmError *pIEnumErrors;
		pErrors->get__NewEnum(&pUnk);	
		pUnk->QueryInterface(IID_IEnumMsmError, (void **)&pIEnumErrors);
		pUnk->Release();

		// get the next error.
		pIEnumErrors->Next(1, &pIError, &cErrorsFetched);

		IMsmStrings* pIDatabaseError;		// database error enumerator (strings)
		IMsmStrings* pIModuleError;		// module error enumerator (strings)
		BSTR bstrError;						// pointer to error string
		DWORD cErrorStrings;					// number of strings retrieved

		// while an error is fetched
		while (cErrorsFetched && pIError)
		{
			// get the error type
			pIError->get_Type(&errType);

			// if the errType is a merge/unmerge conflict
			if (msmErrorTableMerge == errType)
			{
				// get error collections
				pIError->get_DatabaseKeys(&pIDatabaseError);
				pIError->get_ModuleKeys(&pIModuleError);

				// fill up the error buffer with tables and rows
				pIError->get_DatabaseTable(&bstrError);
				lstrcpy(szLogError, _T(">> Error: Merge conflict in Database Table: `"));
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				::SysFreeString(bstrError);

				lstrcat(szLogError, _T("` & Module Table: `"));
				pIError->get_ModuleTable(&bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				::SysFreeString(bstrError);
				lstrcat(szLogError, _T("` - Row(s): `"));

				// tack on the error strings
				IEnumMsmString *pIStrings;
				pIDatabaseError->get__NewEnum((IUnknown **)&pUnk);
				pUnk->QueryInterface(IID_IEnumMsmString, (void **)&pIStrings);
				pUnk->Release();

				pIStrings->Next(1, &bstrError, &cErrorStrings);
				while(cErrorStrings > 0)
				{
#ifdef _UNICODE
					lstrcat(szLogError, bstrError);
#else
					cchErrorBuffer = 1025;
					WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
					lstrcat(szLogError, szErrorBuffer);
#endif
					lstrcat(szLogError, _T("`, `",));
					SysFreeString(bstrError);
					pIStrings->Next(1, &bstrError, &cErrorStrings);
				}

				// tack on the ending error stuff
				lstrcat(szLogError, _T("`\r\n",));

#ifdef _UNICODE
				lstrcpy(wzDisplay, szLogError);
#else
				cchErrorBuffer = 1025;
				AnsiToWide(szLogError, (WCHAR*)wzDisplay, &cchErrorBuffer);
#endif
				BSTR bstrLog = ::SysAllocString(wzDisplay);
				pIExecute->Log(bstrLog);		// log error table and rows
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);

				// release the enumerators/collections
				pIStrings->Release();
				pIDatabaseError->Release();
				pIModuleError->Release();

				// up the error count
				iErrorCount++;
			}
			else if (msmErrorResequenceMerge == errType)
			{
				// get error collections
				pIError->get_DatabaseKeys(&pIDatabaseError);
				pIError->get_ModuleKeys(&pIModuleError);

				// fill up the error buffer with tables and rows
				pIError->get_DatabaseTable(&bstrError);
				lstrcpy(szLogError, _T(">> Error: Merge conflict in Database Table: `"));
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				::SysFreeString(bstrError);

				lstrcat(szLogError, _T("` - Action: `"));
				pIDatabaseError->get_Item(1, &bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				::SysFreeString(bstrError);
				lstrcat(szLogError, _T("`\r\n",));

#ifdef _UNICODE
				lstrcpy(wzDisplay, szLogError);
#else
				cchErrorBuffer = 1025;
				AnsiToWide(szLogError, (WCHAR*)wzDisplay, &cchErrorBuffer);
#endif
				BSTR bstrLog = ::SysAllocString(wzDisplay);
				pIExecute->Log(bstrLog);		// log error table and rows
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);

				// release the enumerators
				pIDatabaseError->Release();
				pIModuleError->Release();

				// up the error count
				iErrorCount++;
			}
			else if (msmErrorExclusion == errType)
			{
				// could go either way, moduleerror or database error
				pIError->get_ModuleKeys(&pIModuleError);
				long lCount;
				pIModuleError->get_Count(&lCount);
				if (lCount == 0)
				{
					pIError->get_DatabaseKeys(&pIModuleError);
					pIModuleError->get_Count(&lCount);
				}

				// display error ModuleID
				lstrcpy(szLogError, _T(">> Error: Exclusion detected for Merge Module ID: "));
				pIModuleError->get_Item(1, &bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				SysFreeString(bstrError);
				lstrcat(szLogError, _T(" ",));

				
				pIModuleError->get_Item(2, &bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				SysFreeString(bstrError);
				lstrcat(szLogError, _T(", ",));

				pIModuleError->get_Item(3, &bstrError);
#ifdef _UNICODE
				lstrcat(szLogError, bstrError);
#else
				cchErrorBuffer = 1025;
				WideToAnsi(bstrError, (char*)szErrorBuffer, &cchErrorBuffer);
				lstrcat(szLogError, szErrorBuffer);
#endif
				SysFreeString(bstrError);
				lstrcat(szLogError, _T("\r\n",));

				// create wide version for output log
#ifdef _UNICODE
				lstrcpy(wzDisplay, szLogError);
#else
				cchErrorBuffer = 1025;
				AnsiToWide(szLogError, (WCHAR*)wzDisplay, &cchErrorBuffer);
#endif
				BSTR bstrLog = ::SysAllocString(wzDisplay);
				pIExecute->Log(bstrLog);		// log error table and rows
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);

				// release enumerator
				pIModuleError->Release();

				// up the error count
				iErrorCount++;
			}

			// release this error and get the next error
			pIError->Release();
			pIError = NULL;
			pIEnumErrors->Next(1, &pIError, &cErrorsFetched);
		}

		// set the buffer to print out all errors
		_stprintf(szLogError, _T("Total merge conflicts: %d\r\n"), iErrorCount);
#ifdef _UNICODE
		lstrcpy(wzDisplay, szLogError);
#else
		cchErrorBuffer = 1025;
		AnsiToWide(szLogError, (WCHAR*)wzDisplay, &cchErrorBuffer);
#endif
		BSTR bstrLog = ::SysAllocString(wzDisplay);
		pIExecute->Log(bstrLog);		// log error table and rows
		if (pfnDisplay) pfnDisplay(bstrLog);
		::SysFreeString(bstrLog);

		pIEnumErrors->Release();	// release the error enumerator now
	}

	if (fPerformExtraction)
	{
		if (szExtractDir && (szExtractDir[0] != '\0'))
		{
			// now do extraction
			WCHAR wzExtract[MAX_PATH];
#ifndef _UNICODE
			cchBuffer = MAX_PATH;
			::MultiByteToWideChar(CP_ACP, 0, szExtractDir, -1, wzExtract, cchBuffer);
#else
			lstrcpy(wzExtract, szExtractDir);
#endif	// _UNICODE
			BSTR bstrExtract = ::SysAllocString(wzExtract);
			pIExecute->ExtractFilesEx(bstrExtract, fLFN, NULL);
			::SysFreeString(bstrExtract);
			if (FAILED(hResult))
			{
				BSTR bstrLog = ::SysAllocString(L">> Failed to merge Merge Module.\r\n");
				pIExecute->Log(bstrLog);
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);
				pIExecute->Release();
				return E_FAIL;
			}
		}
	
		if (szCABDir && (szCABDir[0] != '\0'))
		{
			// now do extraction
			WCHAR wzExtract[MAX_PATH];
#ifndef _UNICODE
			cchBuffer = MAX_PATH;
			::MultiByteToWideChar(CP_ACP, 0, szCABDir, -1, wzExtract, cchBuffer);
#else
			lstrcpy(wzExtract, szCABDir);
#endif	// _UNICODE
			BSTR bstrExtract = ::SysAllocString(wzExtract);
			pIExecute->ExtractCAB(bstrExtract);
			::SysFreeString(bstrExtract);
			if (FAILED(hResult))
			{
				BSTR bstrLog = ::SysAllocString(L">> Failed to merge Merge Module.\r\n");
				pIExecute->Log(bstrLog);
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);
				pIExecute->Release();
				return E_FAIL;
			}
		}
		
		if (szImageDir && (szImageDir[0] != '\0'))
		{
			// now do extraction
			WCHAR wzExtract[MAX_PATH];
#ifndef _UNICODE
			cchBuffer = MAX_PATH;
			::MultiByteToWideChar(CP_ACP, 0, szImageDir, -1, wzExtract, cchBuffer);
#else
			lstrcpy(wzExtract, szImageDir);
#endif	// _UNICODE
			BSTR bstrExtract = ::SysAllocString(wzExtract);
			pIExecute->CreateSourceImage(bstrExtract, true, NULL);
			::SysFreeString(bstrExtract);
			if (FAILED(hResult))
			{
				BSTR bstrLog = ::SysAllocString(L">> Failed to merge Merge Module.\r\n");
				pIExecute->Log(bstrLog);
				if (pfnDisplay) pfnDisplay(bstrLog);
				::SysFreeString(bstrLog);
				pIExecute->Release();
				return E_FAIL;
			}
		}
	}

	// close all the open files
	pIExecute->CloseModule();
	if (fLogAfterOpen) 
		pIExecute->CloseLog();
	pIExecute->CloseDatabase(eCommit != commitNo);
	if (!fLogAfterOpen) 
		pIExecute->CloseLog();

	// release and leave happy
	pIExecute->Release();
	return (0 == cErrors) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\editbind.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// EditBinD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "EditBinD.h"

#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditBinD dialog


CEditBinD::CEditBinD(CWnd* pParent /*=NULL*/)
	: CDialog(CEditBinD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditBinD)
	m_nAction = 0;
	m_strFilename = _T("");
    m_fNullable = false;
	//}}AFX_DATA_INIT
}


void CEditBinD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditBinD)
	DDX_Radio(pDX, IDC_ACTION, m_nAction);
	DDX_Text(pDX, IDC_PATH, m_strFilename);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditBinD, CDialog)
	//{{AFX_MSG_MAP(CEditBinD)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_ACTION, OnAction)
	ON_BN_CLICKED(IDC_WRITETOFILE, OnRadio2)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditBinD message handlers

BOOL CEditBinD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	if (m_fCellIsNull)
	{
		CButton* pButton = (CButton*)GetDlgItem(IDC_WRITETOFILE);
		if (pButton)
			pButton->EnableWindow(FALSE);
	}
	return TRUE;
}

void CEditBinD::OnBrowse() 
{
	CFileDialog dlgFile(TRUE, NULL, m_strFilename, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, _T("All Files (*.*)|*.*||"), this);

	if (IDOK == dlgFile.DoModal()) 
	{
		m_strFilename = dlgFile.GetPathName();
		UpdateData(false);
	}
}

void CEditBinD::OnAction() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_BROWSE)->EnableWindow(m_nAction == 0);
}

void CEditBinD::OnRadio2() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_BROWSE)->EnableWindow(m_nAction == 0);
}

void CEditBinD::OnOK() 
{
	UpdateData(TRUE);

	BOOL bGood = TRUE;	// assume we will pass

	if ((0 != m_nAction || !m_fNullable) && m_strFilename.IsEmpty())
	{
		AfxMessageBox(_T("A filename must be specified."));
		return;
	}

	if (0 == m_nAction)	// if importing
	{
		if (!m_strFilename.IsEmpty() && !FileExists(m_strFilename))
		{
			CString strPrompt;
			strPrompt.Format(_T("File `%s` does not exist."), m_strFilename);
			AfxMessageBox(strPrompt);
			bGood = FALSE;
		}
		else	// found the file prepare an overwrite
		{
			// if they don't want to overwrite
			if (IDOK != AfxMessageBox(_T("This will overwrite the current contents of the stream.\nContinue?"), MB_OKCANCEL))
				bGood = FALSE;
		}
	}
	else	// exporting
	{
		int nFind = m_strFilename.ReverseFind(_T('\\'));

		// if found a `\`
		if (-1 != nFind)
		{
			CString strPath;
			strPath = m_strFilename.Left(nFind);

			// if the path does not exist forget it
			if (!PathExists(strPath))
			{
				CString strPrompt;
				strPrompt.Format(_T("Path `%s` does not exist."), strPath);
				AfxMessageBox(strPrompt);
				bGood = FALSE;
			}
		}
		// else file is going to current path
	}

	if (bGood)
		CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\exportd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// ExportD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "ExportD.h"
#include "FolderD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExportD dialog


CExportD::CExportD(CWnd* pParent /*=NULL*/)
	: CDialog(CExportD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CExportD)
	m_strDir = _T("");
	//}}AFX_DATA_INIT

	m_plistTables = NULL;
}


void CExportD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExportD)
	DDX_Text(pDX, IDC_OUTPUT_DIR, m_strDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExportD, CDialog)
	//{{AFX_MSG_MAP(CExportD)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_SELECT_ALL, OnSelectAll)
	ON_BN_CLICKED(IDC_CLEAR_ALL, OnClearAll)
	ON_BN_CLICKED(IDC_INVERT, OnInvert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExportD message handlers

BOOL CExportD::OnInitDialog() 
{
	ASSERT(m_plistTables);
	CDialog::OnInitDialog();

	// subclass list box to a checkbox
	m_ctrlList.SubclassDlgItem(IDC_LIST_TABLES, this);
	
	int nAddedAt;
	CString strAdd;
	while (m_plistTables->GetHeadPosition())
	{
		strAdd = m_plistTables->RemoveHead();
		nAddedAt = m_ctrlList.AddString(strAdd);

		if (strAdd == m_strSelect)
			m_ctrlList.SetCheck(nAddedAt, 1);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CExportD::OnBrowse() 
{
	UpdateData();

	CFolderDialog dlg(this->m_hWnd, _T("Select a directory to Export to."));

	if (IDOK == dlg.DoModal())
	{
		// update the dialog box
		m_strDir = dlg.GetPath();
		UpdateData(FALSE);
	}
}

void CExportD::OnSelectAll() 
{
	// set all to checks
	int cTables = m_ctrlList.GetCount();
	for (int i = 0; i < cTables; i++)
		m_ctrlList.SetCheck(i, 1);
}

void CExportD::OnClearAll() 
{
	// set all to checks
	int cTables = m_ctrlList.GetCount();
	for (int i = 0; i < cTables; i++)
		m_ctrlList.SetCheck(i, 0);
}

void CExportD::OnInvert() 
{
	// set all to checks
	int cTables = m_ctrlList.GetCount();
	for (int i = 0; i < cTables; i++)
		m_ctrlList.SetCheck(i, !m_ctrlList.GetCheck(i));
}

void CExportD::OnOK()
{
	UpdateData();

	if (m_strDir.IsEmpty())
	{
		AfxMessageBox(_T("A valid output directory must be specified"));
		GotoDlgCtrl(GetDlgItem(IDC_OUTPUT_DIR));
	}
	else 
	{
		DWORD dwAttrib = GetFileAttributes(m_strDir);
		if ((0xFFFFFFFF == dwAttrib) ||					// does not exist
			 !(FILE_ATTRIBUTE_DIRECTORY & dwAttrib))	// if not a directory
		{
			AfxMessageBox(_T("Output directory does not exist."));
			GotoDlgCtrl(GetDlgItem(IDC_OUTPUT_DIR));
		}
		else	// good to go
		{
			CString strTable;
			int cTables = m_ctrlList.GetCount();
			for (int i = 0; i < cTables; i++)
			{
				// if the table is checked add it back in the list
				if (1 == m_ctrlList.GetCheck(i))
				{
					m_ctrlList.GetText(i, strTable);
					m_plistTables->AddTail(strTable);
				}
			}

			CDialog::OnOK();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\exportd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_EXPORTD_H__25468EE2_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
#define AFX_EXPORTD_H__25468EE2_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ExportD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CExportD dialog

class CExportD : public CDialog
{
// Construction
public:
	CExportD(CWnd* pParent = NULL);   // standard constructor

	CStringList* m_plistTables;
	CString m_strSelect;
	CCheckListBox m_ctrlList;

// Dialog Data
	//{{AFX_DATA(CExportD)
	enum { IDD = IDD_EXPORT_TABLE };
	CString	m_strDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExportD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CExportD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnBrowse();
	afx_msg void OnSelectAll();
	afx_msg void OnClearAll();
	afx_msg void OnInvert();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXPORTD_H__25468EE2_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\folderd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// FolderD.cpp
//

#include "stdafx.h"
#include "FolderD.h"

CFolderDialog::CFolderDialog(HWND hWnd, LPCTSTR szTitle)
{
	m_bi.hwndOwner = hWnd;
	m_bi.lpszTitle = szTitle;
	m_bi.ulFlags = 0;
	m_bi.pidlRoot = NULL;
	m_bi.lpfn = NULL;
	m_bi.lParam = 0;
	m_bi.iImage = 0;
}

UINT CFolderDialog::DoModal()
{
	UINT iResult = IDCANCEL;	// assume nothing will happen

	// open the dialog
	m_bi.pszDisplayName = m_strFolder.GetBuffer(MAX_PATH);
	LPITEMIDLIST pItemID = SHBrowseForFolder(&m_bi);
	m_strFolder.ReleaseBuffer();

	// if it was good
	if (pItemID)
	{
		// get the full path name
		if (SHGetPathFromIDList(pItemID, m_strFolder.GetBuffer(MAX_PATH))) 
			iResult = IDOK;

		m_strFolder.ReleaseBuffer();
	}

	return iResult;
}

LPCTSTR CFolderDialog::GetPath()
{
	return m_strFolder;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\folderd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// FolderD.h
//

#ifndef _FOLDER_DIALOG_H_
#define _FOLDER_DIALOG_H_

#include <shlobj.h>

class CFolderDialog
{
public:
	CFolderDialog(HWND hWnd, LPCTSTR strTitle);

	UINT DoModal();
	LPCTSTR GetPath();

protected:
	BROWSEINFO m_bi;
	CString m_strFolder;
};	// end of CFolderDialog

#endif	// _FOLDER_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\iface.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       iface.h
//
//--------------------------------------------------------------------------

// iface.h - Evaluation COM Object Interfaces declarations

#ifndef _EVALUATION_COM_INTERFACES_H_
#define _EVALUATION_COM_INTERFACES_H_

#include <objbase.h>


// returned from IEvalResult::GetResultType
typedef enum RESULTTYPES	
{
	ieUnknown = 0,
	ieError,
	ieWarning,
	ieInfo,
};

// values passed to status callback
typedef enum STATUSTYPES
{
	ieStatusGetCUB,
	ieStatusMerge,
	ieStatusSummaryInfo,
	ieStatusCreateEngine,
	ieStatusStarting,
	ieStatusRunICE,
	ieStatusRunSequence,
	ieStatusShutdown,
	ieStatusSuccess,
	ieStatusFail
};

///////////////////////////////////////////////////////////
// IEvalResult
interface IEvalResult : IUnknown
{
	virtual HRESULT __stdcall GetResultType(UINT* puiResultType) = 0;
	virtual HRESULT __stdcall GetResult(IEnumString** pResult) = 0;
};	// end of IEvalResult


///////////////////////////////////////////////////////////
// IEnumEvalResult
interface IEnumEvalResult : IUnknown
{
	virtual HRESULT __stdcall Next(ULONG cResults, IEvalResult** rgpResult, ULONG* pcResultsFetched) = 0;
	virtual HRESULT __stdcall Skip(ULONG cResults) = 0;
	virtual HRESULT __stdcall Reset(void) = 0;
	virtual HRESULT __stdcall Clone(IEnumEvalResult** ppEnum) = 0;
};	// end of IEnumEvalResult


typedef BOOL (WINAPI* LPDISPLAYVAL)(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation);
typedef HRESULT (WINAPI* LPEVALCOMCALLBACK)(STATUSTYPES iStatus, LPVOID pData, LPVOID pContext);

///////////////////////////////////////////////////////////
// IEval
interface IEval : IUnknown
{
	// open/close methods
	virtual HRESULT __stdcall OpenDatabase(LPCOLESTR szDatabase) = 0;				// database to evaluate
	virtual HRESULT __stdcall OpenEvaluations(LPCOLESTR szEvaluation) = 0;		// database that contains evaluations
	virtual HRESULT __stdcall CloseDatabase() = 0;
	virtual HRESULT __stdcall CloseEvaluations() = 0;

	// set methods
	virtual HRESULT __stdcall SetDisplay(LPDISPLAYVAL pDisplayFunction,			// function to handle display
													 LPVOID pContext) = 0;						// context passed back to display
	// evaluation methods
	virtual HRESULT __stdcall Evaluate(LPCOLESTR szRunEvaluations = NULL) = 0;	// internal consistency evaluations to run
	virtual HRESULT __stdcall GetResults(IEnumEvalResult** ppResults,				// result enumerator
													 ULONG* pcResults) = 0;						// number of results
};	// end of IEval

///////////////////////////////////////////////////////////
// ValCom GUIDs
// CLSID_EvalCom
//	IID_IEval
//	IID_IEvalResult
//	IID_IEnumEvalResult

// {DC550E10-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(CLSID_EvalCom, 
0xdc550e10, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E11-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEval, 
0xdc550e11, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E12-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEvalResult, 
0xdc550e12, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

// {DC550E13-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(IID_IEnumEvalResult, 
0xdc550e13, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);

/*
// {DC550E14-DBA5-11d1-A850-006097ABDE17}
DEFINE_GUID(<<name>>, 
0xdc550e14, 0xdba5, 0x11d1, 0xa8, 0x50, 0x0, 0x60, 0x97, 0xab, 0xde, 0x17);
*/

#endif	// _EVALUATION_COM_INTERFACES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\helpd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// HelpD.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "HelpD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelpD dialog


CHelpD::CHelpD(CWnd* pParent /*=NULL*/)
	: CDialog(CHelpD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHelpD)
	m_strVersion = _T("Orca Version ");
	//}}AFX_DATA_INIT
	m_strVersion += static_cast<COrcaApp *>(AfxGetApp())->GetOrcaVersion();
}


void CHelpD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpD)
	DDX_Text(pDX, IDC_VERSIONSTRING, m_strVersion);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpD, CDialog)
	//{{AFX_MSG_MAP(CHelpD)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpD message handlers

BOOL CHelpD::OnInitDialog() 
{
	CDialog::OnInitDialog();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\make.inc ===
BuiltHeaders: \
	$(O)\mergemod.h

!ifndef INCVER
INCVER = 0
!endif

$(O)\Mergemod.h: $(INC_DIR)\Mergemod.w
	wcshdr.exe < $(INC_DIR)\Mergemod.w > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\imprtdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_IMPRTDLG_H__F424160C_4C5B_11D2_8896_00A0C981B015__INCLUDED_)
#define AFX_IMPRTDLG_H__F424160C_4C5B_11D2_8896_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ImprtDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CImportDlg dialog

class CImportDlg : public CDialog
{
// Construction
public:
	CString m_strImportDir;
	CStringList m_lstRefreshTables;
	CStringList m_lstNewTables;
	CString m_strTempFilename;
	MSIHANDLE m_hFinalDB;
	CImportDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CImportDlg)
	enum { IDD = IDD_IMPORT_TABLE };
	CButton	m_bImport;
	CButton	m_bMerge;
	CButton	m_bSkip;
	CButton	m_bReplace;
	CListCtrl	m_ctrlTableList;
	int		m_iAction;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CImportDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CImportDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowse();
	afx_msg void OnItemchangedTablelist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnActionChange();
	virtual void OnOK();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	bool AddExtraColumns(MSIHANDLE hImportDB, const CString strTable, MSIHANDLE hFinalDB);

	int m_cNeedInput;
	CString m_strTempPath;
	PMSIHANDLE m_hImportDB;

	enum eAction {
		actImport = 0x00,
		actReplace = 0x01,
		actMerge = 0x02,
		actSkip = 0x04,
	};

	enum eAllowAction {
		allowImport = 0x10,
		allowMerge = 0x20,
		allowReplace = 0x40,
	};

	enum eTableAttributes {
		hasExtraColumns = 0x100,
	};

	static const TCHAR *rgszAction[4];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IMPRTDLG_H__F424160C_4C5B_11D2_8896_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\imprtdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// ImprtDlg.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include <cderr.h>
#include "ImprtDlg.h"
#include "..\common\query.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CImportDlg dialog
const TCHAR *CImportDlg::rgszAction[4] = {
	_T("Import"),
	_T("Replace"),
	_T("Merge"),
	_T("Skip"),
};

CImportDlg::CImportDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CImportDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CImportDlg)
	m_iAction = -1;
	//}}AFX_DATA_INIT
}


void CImportDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CImportDlg)
	DDX_Control(pDX, IDC_IMPORT, m_bImport);
	DDX_Control(pDX, IDC_MERGE, m_bMerge);
	DDX_Control(pDX, IDC_REPLACE, m_bReplace);
	DDX_Control(pDX, IDC_SKIP, m_bSkip);
	DDX_Control(pDX, IDC_TABLELIST, m_ctrlTableList);
	DDX_Radio(pDX, IDC_IMPORT, m_iAction);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CImportDlg, CDialog)
	//{{AFX_MSG_MAP(CImportDlg)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_TABLELIST, OnItemchangedTablelist)
	ON_BN_CLICKED(IDC_IMPORT, OnActionChange)
	ON_BN_CLICKED(IDC_MERGE, OnActionChange)
	ON_BN_CLICKED(IDC_REPLACE, OnActionChange)
	ON_BN_CLICKED(IDC_SKIP, OnActionChange)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CImportDlg message handlers

BOOL CImportDlg::OnInitDialog() 
{
	CWaitCursor curWait;
	CDialog::OnInitDialog();

	// add columns to the list ctrl
	m_ctrlTableList.InsertColumn(1, _T("Table"), LVCFMT_LEFT, -1, 0);  
	m_ctrlTableList.InsertColumn(2, _T("Action"), LVCFMT_LEFT, -1, 1); 
//	m_ctrlTableList.SetWindowLong(0, LVS_EX_FULLROWSELECT, 0);
//	SetWindowLong(m_ctrlTableList.m_hWnd, GWL_EXSTYLE, LVS_EX_FULLROWSELECT);

	// open a temporary import database
	DWORD cchPath;
	TCHAR *szPath = m_strTempPath.GetBuffer(MAX_PATH);
	cchPath = GetTempPath(MAX_PATH, szPath);
	if (cchPath > MAX_PATH) 
	{
		m_strTempPath.ReleaseBuffer();
		szPath = m_strTempPath.GetBuffer(cchPath+1);
		cchPath++;
		GetTempPath(cchPath, szPath);
	}
	m_strTempPath.ReleaseBuffer();
	TCHAR *szFilename = m_strTempFilename.GetBuffer(MAX_PATH);
	GetTempFileName(m_strTempPath, _T("ORC"), 0, szFilename);
	m_strTempFilename.ReleaseBuffer();
	::MsiOpenDatabase(m_strTempFilename, MSIDBOPEN_CREATE, &m_hImportDB);

	// run the File Browse Dialog, import, and add selections to the list view control
	OnBrowse();

	// if we don't need any user input, don't show the dialog
	if (m_cNeedInput == 0)
		OnOK();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CImportDlg::OnBrowse() 
{
	m_cNeedInput = 0;

	// set to true if one or more tables has a merge table.
	bool bMergeConflict = false;

	CFileDialog FileD(true, _T("idt"), NULL, 
		OFN_ALLOWMULTISELECT | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, 
		_T("IDT files (*.idt)|*.idt|All Files (*.*)|*.*||"), this);

	TCHAR rgchBuffer[2048] = _T("");
	FileD.m_ofn.lpstrFile = rgchBuffer;
	FileD.m_ofn.nMaxFile = 2048;
	FileD.m_ofn.lpstrInitialDir = m_strImportDir;

	if (IDOK == FileD.DoModal())
	{
		// throw up a wait cursor
		CWaitCursor curWait;

		// retrieve the directory
		m_strImportDir = FileD.GetPathName();

		// open a temporary database
		CString strTempFilename;
		PMSIHANDLE hTempDB;
		TCHAR *szFilename = strTempFilename.GetBuffer(MAX_PATH);
		::GetTempFileName(m_strTempPath, _T("ORC"), 0, szFilename);
		strTempFilename.ReleaseBuffer();
		::MsiOpenDatabase(strTempFilename, MSIDBOPEN_CREATE, &hTempDB);

		PMSIHANDLE hTempDB2;
		CString strTempFilename2;
		szFilename = strTempFilename2.GetBuffer(MAX_PATH);
		::GetTempFileName(m_strTempPath, _T("ORC"), 0, szFilename);
		strTempFilename2.ReleaseBuffer();
		::MsiOpenDatabase(strTempFilename2, MSIDBOPEN_CREATE, &hTempDB2);
		::MsiDatabaseMerge(hTempDB2, m_hFinalDB, NULL);

		// add the imported tables to the listview control. If table name already exists,
		// overwrite what exists.
		CQuery qCollide;
		CQuery qExists;
		CQuery qConflict;
		PMSIHANDLE hTableRec;
		LVITEM itemTable;
		TCHAR szTableName[255];
		unsigned long cchTableName = 255;

		itemTable.mask = LVIF_TEXT;
		itemTable.iItem = 0;
		itemTable.iSubItem = 0;
		itemTable.state = 0;
		itemTable.stateMask = 0;
		itemTable.pszText = NULL;
		itemTable.cchTextMax = 0;
		itemTable.iImage = 0;
		itemTable.lParam = 0;
		itemTable.iIndent = 0;

		// import the files into this temporary database, as well as the import database.
		POSITION posFile = FileD.GetStartPosition();
		while (posFile)
		{
			CString strPath = FileD.GetNextPathName(posFile);
			int pos = strPath.ReverseFind(_T('\\'));
			if ((ERROR_SUCCESS != ::MsiDatabaseImport(m_hImportDB, strPath.Left(pos+1), strPath.Right(strPath.GetLength()-pos-1))) ||
				(ERROR_SUCCESS != ::MsiDatabaseImport(hTempDB, strPath.Left(pos+1), strPath.Right(strPath.GetLength()-pos-1))))
			{
				CString strError;
				strError.Format(_T("The file %s is not a valid IDT file."), strPath);
				AfxMessageBox(strError, MB_OK);
				continue;
			}

			// add on to end of list.
			int iNextItem = m_ctrlTableList.GetItemCount();

			qExists.Open(m_hFinalDB, _T("SELECT * FROM `_Tables` WHERE `Name`=?"));

			if (ERROR_SUCCESS == qCollide.FetchOnce(hTempDB, NULL, &hTableRec, _T("SELECT * FROM `_Tables`")))
			{
				cchTableName = 255;
				::MsiRecordGetString(hTableRec, 1, szTableName, &cchTableName);

				// assign an item number to the entry, reusing an existing one if
				// the table name is the same.
				LVFINDINFO findTable;
				findTable.flags = LVFI_STRING;
				findTable.psz = szTableName;
				itemTable.iItem = m_ctrlTableList.FindItem(&findTable, -1);
				if (itemTable.iItem != -1)
					m_ctrlTableList.DeleteItem(itemTable.iItem);

				// add to list control
				itemTable.mask = LVIF_TEXT;
				itemTable.lParam = 0;
				itemTable.iSubItem = 0;
				itemTable.pszText = szTableName;
				itemTable.cchTextMax = cchTableName+1;
				itemTable.iItem = m_ctrlTableList.InsertItem(&itemTable);

				// now decide if it doesn't exist or not and add
				// our best guess for the state
				itemTable.iSubItem = 1;
				qExists.Execute(hTableRec);
				PMSIHANDLE hDummyRec;
				DWORD iData;
				switch (qExists.Fetch(&hDummyRec)) 
				{
				case ERROR_SUCCESS:
				{
					// already exists in our database.
					bool fMergeOK = true;
					bool fExtraColumns = false;
					m_cNeedInput++;

   					// if the number of columns is different, we can only merge
					// if all of the new columns are nullable and there are no merge
					// conficts
					PMSIHANDLE hColInfo;
					CQuery qColumns;
					int cTargetColumns = 0;
					int cSourceColumns = 0;
					if (ERROR_SUCCESS != qColumns.OpenExecute(m_hFinalDB, 0, TEXT("SELECT * FROM %s"), szTableName) ||
						ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_TYPES, &hColInfo))
					{
						CString strPrompt;
						strPrompt.Format(TEXT("Orca was unable to determine the number of columns in the new %s table."), szTableName);
						AfxMessageBox(strPrompt, MB_ICONSTOP);
						fMergeOK = false;
					}
					else
					{
						cTargetColumns = MsiRecordGetFieldCount(hColInfo);

						if (ERROR_SUCCESS != qColumns.OpenExecute(hTempDB, 0, TEXT("SELECT * FROM %s"), szTableName) ||
							ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_TYPES, &hColInfo))
						{
							CString strPrompt;
							strPrompt.Format(TEXT("Orca was unable to determine the number of columns in the %s table."), szTableName);
							AfxMessageBox(strPrompt, MB_ICONSTOP);
							fMergeOK = false;
						}
						else
						{
							cSourceColumns = MsiRecordGetFieldCount(hColInfo);
						}
					}

					if (fMergeOK && cSourceColumns != cTargetColumns)
					{					
						fExtraColumns = true;
						for (int iCol = cTargetColumns+1; iCol <= cSourceColumns; iCol++)
						{
							TCHAR szType[5];
							DWORD cchType = 5;
							MsiRecordGetString(hColInfo, iCol, szType, &cchType);
							if (!_istupper(szType[0]))
							{
								fMergeOK = false;
								break;
							}
						}

						// need to add the extra columns to our temporary database before
						// checking if merging is allowed
						if (!AddExtraColumns(hTempDB, szTableName, hTempDB2))
						{
							fMergeOK = false;
						}
					}


					// try to merge into our database. If successful, set to "Merge"
					if (fMergeOK && ERROR_SUCCESS != ::MsiDatabaseMerge(hTempDB2, hTempDB, NULL)) 
					{
						fMergeOK = false;
					}				

					if (fMergeOK)
					{
						itemTable.pszText = (TCHAR *)rgszAction[actMerge];
						iData = actMerge | allowMerge | allowReplace;
					}
					else
					{
						itemTable.pszText = (TCHAR *)rgszAction[actReplace];
						iData = actReplace | allowReplace;
					}

					// mark that this table has extra columns
					if (fExtraColumns)
						iData |= hasExtraColumns;

					break;
				}
				case ERROR_NO_MORE_ITEMS:
					// doesn't exist in our database, set to "Import"
					itemTable.pszText = (TCHAR *)rgszAction[actImport];
					iData = actImport | allowImport;
					break;
				default:
					// not good.
					AfxMessageBox(_T("Internal Error."), MB_OK);
					return;
				}
				m_ctrlTableList.SetItem(&itemTable);

				// set the lparam value
				m_ctrlTableList.SetItemData(itemTable.iItem, iData);

				// drop the table so the temp database is clean again
				CQuery qDrop;
				qDrop.OpenExecute(hTempDB, NULL, _T("DROP TABLE `%s`"), szTableName);
			}
			else
			{
				CString strError;
				strError.Format(_T("The file %s is not a valid IDT file."), strPath);
				AfxMessageBox(strError, MB_OK);
			}
		} // while posFile

		// we might need input, so adjust the column widths to allow space for the 
		// "Replace..." string, guaranteed at least one item in the listbox
		CString strTemp = m_ctrlTableList.GetItemText(0, 1);
		m_ctrlTableList.SetItemText(0, 1, rgszAction[actReplace]);
		m_ctrlTableList.SetColumnWidth(1, LVSCW_AUTOSIZE);
		CRect rTemp;
		m_ctrlTableList.GetClientRect(&rTemp);
		m_ctrlTableList.SetColumnWidth(0, rTemp.Width()-m_ctrlTableList.GetColumnWidth(1));
		m_ctrlTableList.SetItemText(0, 1, strTemp);

		// clean up temporary files
		::MsiCloseHandle(hTempDB);
		::MsiCloseHandle(hTempDB2);
		::DeleteFile(strTempFilename2);
		::DeleteFile(strTempFilename);
	}
	else
	{
		if (FNERR_BUFFERTOOSMALL == ::CommDlgExtendedError()) 
			AfxMessageBox(_T("Too many files were selected at once. Try choosing fewer files."), MB_OK);
	}
}

void CImportDlg::OnItemchangedTablelist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	int iItem = pNMListView->iItem;

	// determine if the selection state is being set.
	if (pNMListView->uChanged & LVIF_STATE) 
	{
		if (pNMListView->uNewState & LVIS_SELECTED)
		{
			// enable or disable controls based on the status of the item
			int iData = static_cast<int>(m_ctrlTableList.GetItemData(iItem));
			m_iAction = iData & 0x0F;
			iData &= 0xF0;
			m_bImport.EnableWindow(iData & allowImport);
			m_bMerge.EnableWindow(iData & allowMerge);
			m_bReplace.EnableWindow(iData & allowReplace);
			m_bSkip.EnableWindow(TRUE);
			UpdateData(FALSE);
		} 
		else
		{
			m_bSkip.EnableWindow(FALSE);
			m_bImport.EnableWindow(FALSE);
			m_bMerge.EnableWindow(FALSE);
			m_bReplace.EnableWindow(FALSE);
		}
	}
	*pResult = 0;
}

void CImportDlg::OnActionChange() 
{
	// pull the new value out of the Radio group.
	UpdateData(TRUE);

	ASSERT(m_ctrlTableList.GetSelectedCount()==1);

	// get currently selected table, we only allow single sel, so brute search
	// is all we can do
	int iItem;
	int iMax = m_ctrlTableList.GetItemCount();
	for (iItem =0; iItem < iMax; iItem++)
		if (m_ctrlTableList.GetItemState(iItem, LVIS_SELECTED)) break;

	m_ctrlTableList.SetItemData(iItem, m_ctrlTableList.GetItemData(iItem) & 0xF0 | m_iAction);
	m_ctrlTableList.SetItemText(iItem, 1, rgszAction[m_iAction]);
}

void CImportDlg::OnOK() 
{
	bool fModified = false;
	const TCHAR sqlDrop[] = _T("DROP TABLE `%s`");
	CQuery qDrop;
	CString strTable;

	// loop through all entries in the tree control
	int iMaxItem = m_ctrlTableList.GetItemCount();
	for (int i=0; i < iMaxItem; i++) 
	{
		strTable = m_ctrlTableList.GetItemText(i, 0);
		switch (m_ctrlTableList.GetItemData(i) & 0x0F)
		{
		case actReplace:
			// drop from base table.
			qDrop.OpenExecute(m_hFinalDB, NULL, sqlDrop, strTable);
			qDrop.Close();
			m_lstRefreshTables.AddTail(strTable);
			fModified = true;
			break;
		case actMerge:
			// need to add the extra columns from the sources, because merging 
			// won't set that up automatically.
			if ((m_ctrlTableList.GetItemData(i) & hasExtraColumns) == hasExtraColumns)
			{
				if (!AddExtraColumns(m_hImportDB, strTable, m_hFinalDB))
				{
					CString strPrompt;
					strPrompt.Format(TEXT("Orca was unable to add the additional columns to the %s table."), strTable);
					AfxMessageBox(strPrompt, MB_ICONSTOP);
					break;
				}
			}

			m_lstRefreshTables.AddTail(strTable);
			fModified = true;
			break;
		case actImport:
			// no special action required, just save refresh
			m_lstNewTables.AddTail(strTable);
			fModified = true;
			break;
		case actSkip:
			// drop from import table.
			qDrop.OpenExecute(m_hImportDB, NULL, sqlDrop, strTable);
			qDrop.Close();
			break;
		}
	}

	// now merge into our database
	if (ERROR_SUCCESS != ::MsiDatabaseMerge(m_hFinalDB, m_hImportDB, NULL))
		AfxMessageBox(_T("Internal Error. Could not Import Tables into your database."));

	if (fModified)
		CDialog::OnOK();
	else
		EndDialog(IDCANCEL);
}

void CImportDlg::OnDestroy() 
{
	CDialog::OnDestroy();

	MsiCloseHandle(m_hImportDB);
	m_hImportDB = 0;

	// delete the temporary file
	DeleteFile(m_strTempFilename);
}


bool CImportDlg::AddExtraColumns(MSIHANDLE hImportDB, const CString strTable, MSIHANDLE hFinalDB)
{
	PMSIHANDLE hColInfo;
	PMSIHANDLE hColNames;
	CQuery qColumns;
	if (ERROR_SUCCESS != qColumns.OpenExecute(hFinalDB, 0, TEXT("SELECT * FROM %s"), strTable))
		return false;
	if (ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_TYPES, &hColInfo))
		return false;
	int cTargetColumns = MsiRecordGetFieldCount(hColInfo);

	if (ERROR_SUCCESS != qColumns.OpenExecute(hImportDB, 0, TEXT("SELECT * FROM %s"), strTable))
		return false;
	if (ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_TYPES, &hColInfo))
		return false;
	if (ERROR_SUCCESS != qColumns.GetColumnInfo(MSICOLINFO_NAMES, &hColNames))
		return false;
	int cSourceColumns = MsiRecordGetFieldCount(hColInfo);

	if (cSourceColumns != cTargetColumns)
	{
		for (int iCol = cTargetColumns+1; iCol <= cSourceColumns; iCol++)
		{
			TCHAR szType[5] = TEXT("");
			DWORD cchType = 5;
			if (ERROR_SUCCESS != MsiRecordGetString(hColInfo, iCol, szType, &cchType))
				return false;

			CString strName;
			DWORD dwResult = RecordGetString(hColNames, iCol, strName);
			if (ERROR_SUCCESS != dwResult)
				return false;

			CString strAdd;
			switch (szType[0])
			{
			case 'S':
			case 'L':
				strAdd.Format(_T("`%s` CHAR(%s)"), strName, &szType[1]);
				if (szType[0] == 'L')
					strAdd += " LOCALIZABLE";
				break;
			case 'I':
				if (szType[1] == '2')
					strAdd.Format(_T("`%s` SHORT"), strName);
				else
					strAdd.Format(_T("`%s` LONG"), strName);
				break;
			case 'V':
				strAdd.Format(_T("`%s` OBJECT"), strName);
			}
			CQuery qAdd;
			if (ERROR_SUCCESS != qAdd.OpenExecute(hFinalDB, 0, _T("ALTER TABLE %s ADD %s"), strTable, strAdd))
				return false;
		}
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\mainfrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__C3EDC1AC_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_MAINFRM_H__C3EDC1AC_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "Table.h"
#include "Column.h"
#include "valpane.h"
    			
class CTableList;
class CTableView;

class COrcaSplitterWnd : public CSplitterWnd
{
public: 
	COrcaSplitterWnd();
	void HideSecondRow();
	void ShowSecondRow();
};


class CSplitterView : public CWnd
{
	DECLARE_DYNCREATE(CSplitterView)

public:
	CSplitterWnd m_wndSplitter;

protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd( CDC* pDC );

	DECLARE_MESSAGE_MAP();
};

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:
	void SetStatusBarWidth(int nWidth);
	void SetTableCount(int cTables);
	void SetTableName(LPCTSTR szName, int cRows);
	void SetColumnType(LPCTSTR szName, OrcaColumnType eiType, UINT iSize, BOOL bNullable, BOOL bKey);
	void ResetStatusBar();
	void ExportTables(bool bUseSelections);
	void HideValPane();
	void ShowValPane();

	COrcaTable* GetCurrentTable();
	CString m_strExportDir;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;
	COrcaSplitterWnd m_wndValSplitter;

// Generated message map functions
protected:
    afx_msg LONG OnFindReplace(WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnTablesExport();
	afx_msg void OnToolsOptions();
	afx_msg void OnToolsDlgprv();
	afx_msg void OnUpdateToolsDlgprv(CCmdUI* pCmdUI);
	afx_msg void OnEditFind();
	afx_msg void OnEditFindnext();
	afx_msg void OnViewValPane();
	afx_msg void OnUpdateEditFindnext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateViewValPane(CCmdUI* pCmdUI);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CTableView* CMainFrame::GetTableView() const;
	CTableList* CMainFrame::GetTableList() const;
	bool m_bCaseSensitiveSort;
	CFindReplaceDialog * m_dlgFindReplace;
	OrcaFindInfo m_FindInfo;
	OrcaFindInfo m_LastFindInfo;
	
	int m_iValPaneHeight;
	bool m_bChildPanesReady;
	bool m_bValPaneVisible;

	// for now, callbacks are friends
	friend int CALLBACK SortView(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__C3EDC1AC_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\helpd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

#if !defined(AFX_HELPD_H__20272D55_EADD_11D1_A857_006097ABDE17__INCLUDED_)
#define AFX_HELPD_H__20272D55_EADD_11D1_A857_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// HelpD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHelpD dialog

class CHelpD : public CDialog
{
// Construction
public:
	CHelpD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CHelpD)
	enum { IDD = IDD_HELP_DIALOG };
	CString	m_strVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHelpD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHelpD)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HELPD_H__20272D55_EADD_11D1_A857_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\odbutils.cpp ===
#include "..\common\dbutils.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\oquery.cpp ===
#include "..\common\query.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\merged.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//--------------------------------------------------------------------------

// MergeD.cpp : merge module dialog implementation
//

#include "stdafx.h"
#include "Orca.h"
#include "mergeD.h"
#include "FolderD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMergeD dialog


CMergeD::CMergeD(CWnd* pParent /*=NULL*/)
	: CDialog(CMergeD::IDD, pParent)
{
	m_plistFeature = NULL;
	m_plistDirectory = NULL;

	//{{AFX_DATA_INIT(CMergeD)
	m_strModule = "";
	m_strFilePath = "";
	m_strCABPath = "";
	m_strImagePath = "";
	m_strRootDir = "";
	m_strMainFeature = "";
	m_strLanguage = "";
	m_strAddFeature = "";
	m_bExtractCAB = FALSE;
	m_bExtractFiles = FALSE;
	m_bExtractImage = FALSE;
	m_bConfigureModule = FALSE;
	m_bLFN = FALSE;
	//}}AFX_DATA_INIT

	m_plistDirectory = NULL;
}


void CMergeD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMergeD)
	DDX_Control(pDX, IDC_ADDFEATURE, m_ctrlAddFeature);
	DDX_Control(pDX, IDC_MAINFEATURE, m_ctrlMainFeature);
	DDX_Control(pDX, IDC_ROOTDIR, m_ctrlRootDir);
	DDX_Text(pDX, IDC_MODULE, m_strModule);
	DDX_Text(pDX, IDC_EXTRACTPATH, m_strFilePath);
	DDX_Text(pDX, IDC_EXTRACTCAB, m_strCABPath);
	DDX_Text(pDX, IDC_EXTRACTIMAGE, m_strImagePath);
	DDX_Text(pDX, IDC_ROOTDIR, m_strRootDir);
	DDX_Text(pDX, IDC_MAINFEATURE, m_strMainFeature);
	DDX_Text(pDX, IDC_LANGUAGE, m_strLanguage);
	DDX_Check(pDX, IDC_FEXTRACTFILES, m_bExtractFiles);
	DDX_Check(pDX, IDC_FEXTRACTCAB, m_bExtractCAB);
	DDX_Check(pDX, IDC_FEXTRACTIMAGE, m_bExtractImage);
	DDX_Check(pDX, IDC_CONFIGUREMODULE, m_bConfigureModule);
	DDX_Check(pDX, IDC_USELFN, m_bLFN);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMergeD, CDialog)
	//{{AFX_MSG_MAP(CMergeD)
	ON_BN_CLICKED(IDC_MODULEBROWSE, OnModuleBrowse)
	ON_BN_CLICKED(IDC_CABBROWSE, OnCABBrowse)
	ON_BN_CLICKED(IDC_FILESBROWSE, OnFilesBrowse)
	ON_BN_CLICKED(IDC_IMAGEBROWSE, OnImageBrowse)
	ON_BN_CLICKED(IDC_FEXTRACTCAB, OnFExtractCAB)
	ON_BN_CLICKED(IDC_FEXTRACTFILES, OnFExtractFiles)
	ON_BN_CLICKED(IDC_FEXTRACTIMAGE, OnFExtractImage)
	ON_EN_CHANGE(IDC_MODULE, OnChangeModulePath)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMergeD message handlers

BOOL CMergeD::OnInitDialog() 
{
	ASSERT(m_plistFeature);
	ASSERT(m_plistDirectory);
	CDialog::OnInitDialog();

	while (m_plistDirectory->GetHeadPosition())
	{
		m_ctrlRootDir.AddString(m_plistDirectory->RemoveHead());
	}

	// subclass additional feature list box to a checkbox
	m_ctrlAddFeature.SubclassDlgItem(IDC_ADDFEATURE, this);
	
	CString strAdd;
	while (m_plistFeature->GetHeadPosition())
	{
		strAdd = m_plistFeature->RemoveHead();
		m_ctrlMainFeature.AddString(strAdd);
		m_ctrlAddFeature.AddString(strAdd);
	}

	m_ctrlMainFeature.SetCurSel(0);
	m_ctrlRootDir.SetCurSel(0);

	GetDlgItem(IDOK)->EnableWindow(!m_strModule.IsEmpty());

	return TRUE;  // return TRUE unless you set the focus to a control
}


////
//  Throws up a browse dialog for finding a module
void CMergeD::OnModuleBrowse() 
{
	// open the file open dialog
	CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY|OFN_FILEMUSTEXIST,
						 _T("Merge Module (*.msm)|*.msm|All Files (*.*)|*.*||"), this);

	if (IDOK == dlg.DoModal())
	{
		m_strModule = dlg.GetPathName();
		UpdateData(FALSE);
		GetDlgItem(IDOK)->EnableWindow(!m_strModule.IsEmpty());
	}
}

////
//  Throws up a browse dialog for finding a cab extraction path
void CMergeD::OnCABBrowse() 
{
	// open the file open dialog
	CFileDialog dlg(FALSE, _T("cab"), NULL, OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
						 _T("Cabinet (*.cab)|*.cab|All Files (*.*)|*.*||"), this);
	if (IDOK == dlg.DoModal())
	{
		m_strCABPath = dlg.GetPathName();
		UpdateData(FALSE);
	}

}

////
//  Throws up a browse dialog for finding root tree path
void CMergeD::OnFilesBrowse() 
{
	UpdateData();

	CFolderDialog dlg(this->m_hWnd, _T("Select a root path for the module source image."));

	if (IDOK == dlg.DoModal())
	{
		// update the dialog box
		m_strFilePath = dlg.GetPath();
		UpdateData(FALSE);
	}
}


////
//  Throws up a browse dialog for finding root tree path
void CMergeD::OnImageBrowse() 
{
	UpdateData();

	CFolderDialog dlg(this->m_hWnd, _T("Select a root path for the product source image."));

	if (IDOK == dlg.DoModal())
	{
		// update the dialog box
		m_strImagePath = dlg.GetPath();
		UpdateData(FALSE);
	}
}


////
//  Enables and disables the edit and browse boxes for CAB extraction
void CMergeD::OnFExtractCAB() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_CABSTATIC)->EnableWindow(m_bExtractCAB);
	GetDlgItem(IDC_EXTRACTCAB)->EnableWindow(m_bExtractCAB);
	GetDlgItem(IDC_CABBROWSE)->EnableWindow(m_bExtractCAB);
}

////
//  Enables and disables the edit and browse boxes for CAB extraction
void CMergeD::OnFExtractFiles() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_FILESTATIC)->EnableWindow(m_bExtractFiles);
	GetDlgItem(IDC_EXTRACTPATH)->EnableWindow(m_bExtractFiles);
	GetDlgItem(IDC_FILESBROWSE)->EnableWindow(m_bExtractFiles);
}

////
//  Enables and disables the edit and browse boxes for Image extraction
void CMergeD::OnFExtractImage() 
{
	UpdateData(TRUE);
	GetDlgItem(IDC_IMAGESTATIC)->EnableWindow(m_bExtractImage);
	GetDlgItem(IDC_EXTRACTIMAGE)->EnableWindow(m_bExtractImage);
	GetDlgItem(IDC_IMAGEBROWSE)->EnableWindow(m_bExtractImage);
}


////
//  Enables and disables the OK button based on the module path
void CMergeD::OnChangeModulePath() 
{
	CString strValue;
	GetDlgItem(IDC_MODULE)->GetWindowText(strValue);
	GetDlgItem(IDOK)->EnableWindow(!strValue.IsEmpty());
}


void CMergeD::OnOK() 
{
	CString strFeature;

	int cFeature = m_ctrlAddFeature.GetCount();
	m_strAddFeature = TEXT("");
	for (int i = 0; i < cFeature; i++)
	{
		// if the feature is checked, append it to the feature list
		// unless it is the same as the main feature
		if (1 == m_ctrlAddFeature.GetCheck(i))
		{
			m_ctrlAddFeature.GetText(i, strFeature);
			if (strFeature != m_strMainFeature)
			{
				m_strAddFeature += CString(TEXT(":"));
				m_strAddFeature += strFeature;
			}
		}
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\merged.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//--------------------------------------------------------------------------

#if !defined(AFX_MERGED_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
#define AFX_MERGED_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CMergeD dialog

class CMergeD : public CDialog
{
// Construction
public:
	CMergeD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMergeD)
	enum { IDD = IDD_MERGE };
	CCheckListBox	m_ctrlAddFeature;
	CComboBox	m_ctrlMainFeature;
	CComboBox	m_ctrlRootDir;
	CString	m_strModule;
	CString	m_strFilePath;
	CString	m_strCABPath;
	CString	m_strImagePath;
	CString	m_strRootDir;
	CString	m_strLanguage;
	CString	m_strMainFeature;
	BOOL	m_bExtractCAB;
	BOOL	m_bExtractFiles;
	BOOL	m_bExtractImage;
	BOOL	m_bConfigureModule;
	BOOL	m_bLFN;
	//}}AFX_DATA

	CStringList *m_plistDirectory;
	CStringList *m_plistFeature;
	CString	m_strAddFeature;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMergeD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMergeD)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnModuleBrowse();
	afx_msg void OnCABBrowse();
	afx_msg void OnFilesBrowse();
	afx_msg void OnImageBrowse();
	afx_msg void OnFExtractCAB();
	afx_msg void OnFExtractFiles();
	afx_msg void OnFExtractImage();
	afx_msg void OnChangeModulePath();

	// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MERGED_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\mainfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "Orca.h"

#include "MainFrm.h"
#include "OrcaDoc.h"
#include "TableLst.h"
#include "TableVw.h"
#include "ExportD.h"
#include "DisplyPP.h"
#include "PathPP.h"
#include "ValPP.h"
#include "PrvwDlg.h"
#include "ImprtDlg.h"
#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLUMNTYPEWIDTH 200

static UINT WM_FINDREPLACE = ::RegisterWindowMessage(FINDMSGSTRING);

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_TABLES_EXPORT, OnTablesExport)
	ON_COMMAND(ID_TOOLS_OPTIONS, OnToolsOptions)
	ON_COMMAND(ID_TOOLS_DLGPRV, OnToolsDlgprv)
	ON_UPDATE_COMMAND_UI(ID_TOOLS_DLGPRV, OnUpdateToolsDlgprv)
	ON_COMMAND(ID_EDIT_FIND, OnEditFind)
	ON_COMMAND(ID_EDIT_FINDNEXT, OnEditFindnext)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FINDNEXT, OnUpdateEditFindnext)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, OnUpdateEditFind)
	ON_UPDATE_COMMAND_UI(ID_VIEW_VALPANE, OnUpdateViewValPane)
	ON_COMMAND(ID_VIEW_VALPANE, OnViewValPane)
	ON_WM_SIZE()
	ON_WM_DROPFILES()
	//}}AFX_MSG_MAP
    ON_REGISTERED_MESSAGE( WM_FINDREPLACE, OnFindReplace )
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_TABLE_COUNT,
	ID_TABLE_NAME,
	ID_COLUMN_TYPE,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame() : m_iValPaneHeight(0), m_bChildPanesReady(false), m_bValPaneVisible(true)
{
	// TODO: add member initialization code here
	m_dlgFindReplace = NULL;
}

CMainFrame::~CMainFrame()
{
}

inline CTableView* CMainFrame::GetTableView() const { return static_cast<CTableView *>(static_cast<CSplitterView*>(m_wndValSplitter.GetPane(0,0))->m_wndSplitter.GetPane(0,1)); };
inline CTableList* CMainFrame::GetTableList() const { return static_cast<CTableList *>(static_cast<CSplitterView*>(m_wndValSplitter.GetPane(0,0))->m_wndSplitter.GetPane(0,0)); };

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	// create the status bar
	if (!m_wndStatusBar.Create(this))
	{
		TRACE0("Failed to create TableList status bar\n");
		return -1;      // fail to create
	}
	else	// splitter window created
	{
		m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));

		m_wndStatusBar.SetPaneInfo(0, ID_TABLE_COUNT, SBPS_NOBORDERS, 100);
		m_wndStatusBar.SetPaneInfo(1, ID_TABLE_NAME, SBPS_STRETCH, 0);
		m_wndStatusBar.SetPaneInfo(2, ID_COLUMN_TYPE, SBPS_NORMAL, COLUMNTYPEWIDTH);
	}

	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// enable docking of toolbars
	EnableDocking(CBRS_ALIGN_ANY);
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	m_strExportDir = AfxGetApp()->GetProfileString(_T("Path"), _T("Export"));
	m_bCaseSensitiveSort = AfxGetApp()->GetProfileInt(_T("Settings"), _T("CaseSensitiveSort"), 1) == 1;

	if (m_strExportDir.IsEmpty()) {
		// take a crack at getting the current directory for
		int iBufLen = 128;
		LPTSTR szTemp = m_strExportDir.GetBufferSetLength(iBufLen);
		iBufLen = GetCurrentDirectory(iBufLen, szTemp);
		m_strExportDir.ReleaseBuffer();

		// if buffer wasn't big enough, try again
		if (iBufLen >= 128) {
			szTemp = m_strExportDir.GetBufferSetLength(iBufLen);
			::GetCurrentDirectory(iBufLen, szTemp);
			m_strExportDir.ReleaseBuffer();
		}
	};

	// set the find structure to be invalid
	m_FindInfo.bValid = false;
	m_FindInfo.strFindString = _T("");
	m_FindInfo.strUIFindString = _T("");
	m_FindInfo.bForward = true;
	m_FindInfo.bMatchCase = false;
	m_FindInfo.bWholeWord = false;

	m_bValPaneVisible = false;
	m_bChildPanesReady = true;
	m_wndValSplitter.HideSecondRow();
	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) 
{

	if (m_wndValSplitter.CreateStatic(this, 2, 1) == 0)
		return -1;
	
	// set the initial size to 2/3 for the top.
	CSize sizeInit;
	CRect rTemp;
	GetClientRect(&rTemp);
	sizeInit.cx = 125;
	sizeInit.cy = rTemp.bottom*2/3;
	m_wndValSplitter.CreateView(0, 0, RUNTIME_CLASS(CSplitterView), sizeInit, pContext);
	m_wndValSplitter.SetRowInfo(0, sizeInit.cy, 10);

	sizeInit.cy = rTemp.bottom-sizeInit.cy;
	m_iValPaneHeight = sizeInit.cy;
	m_wndValSplitter.CreateView(1, 0, RUNTIME_CLASS(CValidationPane), sizeInit, pContext);
	m_wndValSplitter.SetRowInfo(1, sizeInit.cy, 10);

	return TRUE;
}

void CMainFrame::SetStatusBarWidth(int nWidth)
{
	// can't set width to 0
	if (nWidth < 1) nWidth = 1;

	CString strStore = m_wndStatusBar.GetPaneText(0);
	m_wndStatusBar.SetPaneInfo(0, ID_TABLE_COUNT,  SBPS_NOBORDERS, nWidth - 1);
	m_wndStatusBar.SetPaneText(0, strStore);
}

void CMainFrame::SetTableCount(int cTables)
{
	CString strDisplay;

	strDisplay.Format(_T("Tables: %d"), cTables);
	m_wndStatusBar.SetPaneText(0, strDisplay);
}

void CMainFrame::SetTableName(LPCTSTR szName, int cRows)
{
	CString strDisplay;

	if (1 == cRows)
		strDisplay.Format(_T("%s - %d row"), szName, cRows);
	else // (cRows > 1 || cRows == 0)
		strDisplay.Format(_T("%s - %d rows"), szName, cRows);

	m_wndStatusBar.SetPaneText(1, strDisplay);
}

void CMainFrame::SetColumnType(LPCTSTR szName, OrcaColumnType eiType, UINT iSize, BOOL bNullable, BOOL bKey)
{
	CString strDisplay;

	switch (eiType)
	{
	case iColumnNone:
		strDisplay.Format(_T("%s - Unknown[%d]"), szName, iSize);
		break;
	case iColumnString:
		strDisplay.Format(_T("%s - String[%d]"), szName, iSize);
		break;
	case iColumnLocal:
		strDisplay.Format(_T("%s - Localizable[%d]"), szName, iSize);
		break;
	case iColumnShort:
		strDisplay.Format(_T("%s - Short"), szName);
		break;
	case iColumnLong:
		strDisplay.Format(_T("%s - Long"), szName);
		break;
	case iColumnBinary:
		strDisplay.Format(_T("%s - Binary[%d]"), szName, iSize);
		break;
	default:
		ASSERT(FALSE);	// shouldn't get this
	}

	if (bKey)
		strDisplay += _T(", Key");
	if (bNullable)
		strDisplay += _T(", Nullable");

	m_wndStatusBar.SetPaneInfo(2, ID_COLUMN_TYPE,  SBPS_NORMAL, COLUMNTYPEWIDTH);
	m_wndStatusBar.SetPaneText(2, strDisplay);
}

void CMainFrame::ResetStatusBar()
{
	m_wndStatusBar.SetPaneText(0, _T("Tables: 0"));
	m_wndStatusBar.SetPaneText(1, _T("No table is selected."));
	m_wndStatusBar.SetPaneText(2, _T("No column is selected."));
}

COrcaTable* CMainFrame::GetCurrentTable()
{
	// get the table view
	CTableView* pView = static_cast<CTableView *>(static_cast<CSplitterView*>(m_wndValSplitter.GetPane(0,0))->m_wndSplitter.GetPane(0, 1));
	
	if (!pView)
		return NULL;
	else
		return pView->m_pTable;
}

//////
// handler for menu..Tables...Export, dosen't use current selections in Table View
void CMainFrame::OnTablesExport() {
	ExportTables(false);
};

////
// Creates a dialog box and allows the user to choose which tables to export. In CMainFrame
// because it must be handled regardless of the currently selected view
void CMainFrame::ExportTables(bool bUseSelections)
{
	COrcaTable* pTable = GetCurrentTable();

	CStringList strTableList;

	// get a list of all tables
	
	COrcaDoc *pCurrentDoc = static_cast<COrcaDoc *>(GetActiveDocument());
	ASSERT(pCurrentDoc);
	if (!pCurrentDoc)
		return;

	pCurrentDoc->FillTableList(&strTableList, /*fShadow=*/false, /*fTargetOnly=*/true);

	// create the export dialog box
	CExportD dlg;
	dlg.m_plistTables = &strTableList;
	dlg.m_strDir = m_strExportDir;

	CString strPrompt;
	CString strFilename;
	if (IDOK == dlg.DoModal())
	{
		m_strExportDir = dlg.m_strDir;
		UINT cTables = 0;
		CString strTable;
		POSITION pos = strTableList.GetHeadPosition();
		while (pos)
		{
			strTable = strTableList.GetNext(pos);

			strFilename.Format(_T("%s.idt"), strTable.Left(8));
			if (!pCurrentDoc->ExportTable(&strTable, &m_strExportDir)) 
			{
				strPrompt.Format(_T("`%s` failed to export."), strTable);
				AfxMessageBox(strPrompt);
			}
			else
				cTables++;
		}

		if (1 == cTables)
			strPrompt.Format(_T("Exported %d table."), cTables);
		else
			strPrompt.Format(_T("Exported %d tables."), cTables);
		AfxMessageBox(strPrompt, MB_ICONINFORMATION);
	}
}

void CMainFrame::OnToolsOptions() 
{
	CPropertySheet dOptions(_T("Options"));
	CDisplayPropPage dDisplay;
	CPathPropPage dPaths;
	CValPropPage dValidate;
	CMsmPropPage dMSM;
	CTableView *pTableView = GetTableView();
	CTableList *pTableLst = GetTableList();
	CValidationPane *pValPane = static_cast<CValidationPane*>(m_wndValSplitter.GetPane(1,0));

	// initialize the display page
	pTableView->GetFontInfo(&dDisplay.m_fSelectedFont);
	dDisplay.SetColors(pTableView->m_clrNormal, pTableView->m_clrSelected, pTableView->m_clrFocused);
	dDisplay.SetColorsT(pTableView->m_clrNormalT, pTableView->m_clrSelectedT, pTableView->m_clrFocusedT);
	dDisplay.m_bCaseSensitive = m_bCaseSensitiveSort;
	dDisplay.m_iFontSize = AfxGetApp()->GetProfileInt(_T("Font"),_T("Size"), 100);
	dDisplay.m_bForceColumns = AfxGetApp()->GetProfileInt(_T("Settings"), _T("ForceColumnsToFit"), 1) == 1;

	// init the path page
	dPaths.m_strExportDir = m_strExportDir;
	dPaths.m_strOrcaDat = AfxGetApp()->GetProfileString(_T("Path"),_T("OrcaDat"));

	// init the Validation page
	dValidate.m_strCUBFile = AfxGetApp()->GetProfileString(_T("Validation"),_T("Location"));
	dValidate.m_strICEs = AfxGetApp()->GetProfileString(_T("Validation"),_T("ICEs"));
	dValidate.m_bSuppressWarn = AfxGetApp()->GetProfileInt(_T("Validation"),_T("SuppressWarn"), 0);
	dValidate.m_bSuppressInfo = AfxGetApp()->GetProfileInt(_T("Validation"),_T("SuppressInfo"), 0);
	dValidate.m_bClearResults = AfxGetApp()->GetProfileInt(_T("Validation"),_T("ClearResults"), 1);

	// init the MSM page
	dMSM.m_iMemoryCount = AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("MemoryCount"), 0);
	dMSM.m_bAlwaysConfig = AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("AlwaysConfigure"), 0);
	dMSM.m_bWatchLog = AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("ShowMergeLog"), 0);

	// add everything to the sheet
	dOptions.AddPage(&dDisplay);
	dOptions.AddPage(&dPaths);
	dOptions.AddPage(&dValidate);
	dOptions.AddPage(&dMSM);

	// execute
	if (IDOK == dOptions.DoModal()) 
	{
		if (dDisplay.m_bMiscChange)
		{
			m_bCaseSensitiveSort = (dDisplay.m_bCaseSensitive == TRUE);
			::AfxGetApp()->WriteProfileInt(_T("Settings"),_T("CaseSensitiveSort"), m_bCaseSensitiveSort);
			::AfxGetApp()->WriteProfileInt(_T("Settings"), _T("ForceColumnsToFit"), dDisplay.m_bForceColumns == TRUE);
		}
		if (dDisplay.m_bFontChange) 
		{
			pTableView->SwitchFont(dDisplay.m_strFontName, dDisplay.m_iFontSize);
			pTableLst->SwitchFont(dDisplay.m_strFontName, dDisplay.m_iFontSize);
			pValPane->SwitchFont(dDisplay.m_strFontName, dDisplay.m_iFontSize);
			::AfxGetApp()->WriteProfileInt(_T("Font"),_T("Size"), dDisplay.m_iFontSize);
			::AfxGetApp()->WriteProfileString(_T("Font"),_T("Name"), dDisplay.m_strFontName);
			GetActiveDocument()->UpdateAllViews(NULL, HINT_REDRAW_ALL);
		}
		if (dDisplay.m_bColorChange) 
		{
			COLORREF norm, sel, foc;
			dDisplay.GetColorsT(norm, sel, foc);
			pTableView->SetFGColors(norm, sel, foc);
			pTableLst->SetFGColors(norm, sel, foc);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("SelectFg"), sel);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("FocusFg"), foc);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("NormalFg"), norm);
			dDisplay.GetColors(norm, sel, foc);
			pTableView->SetBGColors(norm, sel, foc);
			pTableLst->SetBGColors(norm, sel, foc);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("SelectBg"), sel);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("FocusBg"), foc);
			::AfxGetApp()->WriteProfileInt(_T("Colors"),_T("NormalBg"), norm);
			GetActiveDocument()->UpdateAllViews(NULL, HINT_REDRAW_ALL);
		};
		if (dPaths.m_bPathChange) 
		{
			m_strExportDir = dPaths.m_strExportDir;
			::AfxGetApp()->WriteProfileString(_T("Path"),_T("Export"), m_strExportDir);
			AfxGetApp()->WriteProfileString(_T("Path"),_T("OrcaDat"), dPaths.m_strOrcaDat);
		};
		if (dValidate.m_bValChange) 
		{
			AfxGetApp()->WriteProfileString(_T("Validation"),_T("Location"), dValidate.m_strCUBFile);
			AfxGetApp()->WriteProfileString(_T("Validation"),_T("ICEs"), dValidate.m_strICEs);
			static_cast<COrcaDoc *>(GetActiveDocument())->m_strICEsToRun = dValidate.m_strICEs;
			AfxGetApp()->WriteProfileInt(_T("Validation"),_T("SuppressWarn"), dValidate.m_bSuppressWarn);
			AfxGetApp()->WriteProfileInt(_T("Validation"),_T("SuppressInfo"), dValidate.m_bSuppressInfo);
			AfxGetApp()->WriteProfileInt(_T("Validation"),_T("ClearResults"), dValidate.m_bClearResults);
		}
		if (dMSM.m_bMSMChange)
		{
			AfxGetApp()->WriteProfileInt(_T("MergeMod"),_T("MemoryCount"), dMSM.m_iMemoryCount);
			AfxGetApp()->WriteProfileInt(_T("MergeMod"),_T("AlwaysConfigure"), dMSM.m_bAlwaysConfig);
			AfxGetApp()->WriteProfileInt(_T("MergeMod"),_T("ShowMergeLog"), dMSM.m_bWatchLog);
		}

	}
	
}

void CMainFrame::OnToolsDlgprv() 
{
	CPreviewDlg dPreview(this);

	COrcaDoc *pDoc = static_cast<COrcaDoc *>(GetActiveDocument());
	ASSERT(pDoc);
	if (pDoc)
	{
		dPreview.m_hDatabase = pDoc->GetTargetDatabase();
		
		dPreview.DoModal();	
	}
}

void CMainFrame::OnUpdateToolsDlgprv(CCmdUI* pCmdUI) 
{
	COrcaDoc* pDoc = static_cast<COrcaDoc *>(GetActiveDocument());
	ASSERT(pDoc);
	if (pDoc)
	{
		COrcaTable *pTable = pDoc->FindAndRetrieveTable(_T("Dialog"));
		pCmdUI->Enable((pTable != NULL) && (pTable->GetRowCount() != 0));
	}
	else
		pCmdUI->Enable(FALSE);
}

void CMainFrame::OnEditFind() 
{
	if (m_dlgFindReplace)
		return;

	m_dlgFindReplace = new CFindReplaceDialog;
 	m_dlgFindReplace->Create(TRUE, m_FindInfo.strUIFindString, _T(""), 
		(m_FindInfo.bForward ? FR_DOWN : 0) |
		(m_FindInfo.bMatchCase ? FR_MATCHCASE : 0) |
		(m_FindInfo.bWholeWord ? FR_WHOLEWORD : 0));

}

afx_msg LONG CMainFrame::OnFindReplace(WPARAM wParam, LPARAM lParam)
{
	// throw up a wait cursor
	CWaitCursor curWait;

	if (m_dlgFindReplace->IsTerminating()) 
	{
		m_dlgFindReplace = NULL;
		CTableView *pTableView = GetTableView();
		pTableView->SetFocus();
		return 0L;
	};
	if (m_dlgFindReplace->FindNext()) 
	{
		// retrieve data from the dialog box
		m_FindInfo.bWholeWord = (m_dlgFindReplace->MatchWholeWord() != 0);
		m_FindInfo.bForward = (m_dlgFindReplace->SearchDown() != 0);
		m_FindInfo.bMatchCase = (m_dlgFindReplace->MatchCase() != 0);
		m_FindInfo.strFindString = m_dlgFindReplace->GetFindString();
		m_FindInfo.strUIFindString = m_FindInfo.strFindString;
		// if our find info was still valid and we havn't changed anything
		if (m_FindInfo.bValid && (m_FindInfo == m_LastFindInfo))
		{
			// keep running the same query
			m_FindInfo = m_LastFindInfo;
		}
		else
		{
			// otherwise reset the query
			m_FindInfo.bValid = true;
			m_FindInfo.bWholeDoc = false;
			m_FindInfo.iCount = 0;
			m_LastFindInfo = m_FindInfo;
		}

		// if case-insensitive, convert the find string to all uppercase
		if (!m_FindInfo.bMatchCase)
			m_FindInfo.strFindString.MakeUpper();

		OnEditFindnext();
		return 0L;
	}
	return 0L;
}

///////////////////////////////////////////////////////////////////////
// command handler for the find next command, but also the find engine
// once the Find dialog sets up a search.
void CMainFrame::OnEditFindnext() 
{
	if (!m_FindInfo.bValid) return;

	CTableView *pTableView = GetTableView();
	CTableList *pTableList = GetTableList();


	// take advantage of short-circuit evaluation to check first visible table
	// then if not found, other tables

	if ((!m_FindInfo.bWholeDoc && pTableView->Find(m_FindInfo)) ||
		pTableList->Find(m_FindInfo))
	{
		pTableView->SetFocus();
		// since we found one, we are want to start the next search from here
		m_FindInfo.bWholeDoc = false;
		return;
	}

	if (m_FindInfo.bWholeDoc && (m_FindInfo.iCount == 0)) {
		CString strPrompt;
		strPrompt.Format(_T("No occurrances of \"%s\" were found."), m_FindInfo.strUIFindString);
		AfxMessageBox(strPrompt, MB_OK);
		m_FindInfo.bValid = false;
		if (m_dlgFindReplace) 
		{
			m_dlgFindReplace->DestroyWindow();
			m_dlgFindReplace = NULL;
			pTableView->SetFocus();
		}
		return;
	};

	CString strPrompt;
	strPrompt.Format(_T("No more occurrances of \"%s\" were found. Continue searching at the %s?"), 
		m_FindInfo.strUIFindString, m_FindInfo.bForward ? _T("beginning") : _T("end"));
	if (IDYES == AfxMessageBox(strPrompt, MB_YESNO)) 
	{
		// must set to whole doc and none found or we could go forever
		m_FindInfo.bWholeDoc = true;
		m_FindInfo.iCount = 0;
		OnEditFindnext();
		return;
	};
	m_FindInfo.bValid = false;
	if (m_dlgFindReplace) 
	{
		m_dlgFindReplace->DestroyWindow();
		m_dlgFindReplace = NULL;
		pTableView->SetFocus();
	}
}


void CMainFrame::OnUpdateEditFindnext(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable((static_cast<COrcaDoc *>(GetActiveDocument())->m_eiType != iDocNone) &&
					m_FindInfo.bValid);	
}

void CMainFrame::OnUpdateEditFind(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable((static_cast<COrcaDoc *>(GetActiveDocument())->m_eiType != iDocNone) && !m_dlgFindReplace);
}

#include <initguid.h>
DEFINE_GUID(STGID_MsiDatabase1,  0xC1080, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiDatabase2,  0xC1084, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiTransform1, 0xC1081, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiTransform2, 0xC1082, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiTransform3, 0xC1085, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiPatch1,     0xC1083, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);
DEFINE_GUID(STGID_MsiPatch2,     0xC1086, 0, 0, 0xC0, 0, 0, 0, 0, 0, 0, 0x46);

////
// drag-and-drop processing that will also accept patches and 
// transforms if a document is already open. Based on default
// implementation from MFC CFrameWnd
void CMainFrame::OnDropFiles(HDROP hDropInfo)
{
	SetActiveWindow();      // activate us first !
	UINT nFiles = ::DragQueryFile(hDropInfo, (UINT)-1, NULL, 0);

	CWinApp* pApp = AfxGetApp();
	ASSERT(pApp != NULL);
	for (UINT iFile = 0; iFile < nFiles; iFile++)
	{
		TCHAR szFileName[_MAX_PATH] = TEXT("");
		::DragQueryFile(hDropInfo, iFile, szFileName, _MAX_PATH);


		// open the file as IStorage to get CLSID. Although this is not publicly
		// exposed information, we use it for perf gain. Otherwise we'd have to try 
		// all three possibilities one right after the other and see which possibility
		// "sticks"

		IStorage *pStorage = 0;
		WCHAR *wzFileName = NULL;
#ifdef UNICODE
		wzFileName = szFileName;
#else
		size_t cchWide = lstrlen(szFileName)+1;
		wzFileName = new WCHAR[cchWide];
		if (!wzFileName)
			return;
		AnsiToWide(szFileName, wzFileName, &cchWide);
#endif
		HRESULT hRes = StgOpenStorage(wzFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT, NULL, 0, &pStorage);
#ifndef UNICODE
		delete[] wzFileName;
#endif
		if (hRes != S_OK || !pStorage)
			continue;

		STATSTG statstg;
		HRESULT hres = pStorage->Stat(&statstg, STATFLAG_NONAME);
		if (hres != S_OK)
		{
			pStorage->Release();
			continue;
		}

		// check the STGIDs
		if ((statstg.clsid == STGID_MsiDatabase2) ||
			(statstg.clsid == STGID_MsiDatabase1))
		{
			pStorage->Release();
			pApp->OpenDocumentFile(szFileName);
		}
		else if ((statstg.clsid == STGID_MsiTransform2) ||
				 (statstg.clsid == STGID_MsiTransform1) ||
				 (statstg.clsid == STGID_MsiTransform3))
		{
			pStorage->Release();
			COrcaDoc* pDoc = static_cast<COrcaDoc*>(GetActiveDocument());
			if (pDoc)
			{
				// can only apply patches if a DB is already open
				if (pDoc->GetOriginalDatabase())
				{
					pDoc->ApplyTransform(szFileName, false);
				}
			}
		}
		else if ((statstg.clsid == STGID_MsiPatch2) ||
				 (statstg.clsid == STGID_MsiPatch1))
		{
			pStorage->Release();
			COrcaDoc* pDoc = static_cast<COrcaDoc*>(GetActiveDocument());
			if (pDoc)
			{
				// can only apply patches if a DB is already open
				if (pDoc->GetOriginalDatabase())
				{
					pDoc->ApplyPatch(szFileName);
				}
			}
		}
		else
		{
			pStorage->Release();
			// unknown OLE storage identifier. Assume MSI
			pApp->OpenDocumentFile(szFileName);
		}
	}
	::DragFinish(hDropInfo);
}


void CMainFrame::OnSize(UINT nType, int cx, int cy) 
{
	CFrameWnd::OnSize(nType, cx, cy);
	if (m_bChildPanesReady)
	{
		m_wndValSplitter.SetRowInfo(0, cy-m_iValPaneHeight, 10);
		m_wndValSplitter.SetRowInfo(1, m_iValPaneHeight, 10);
	}
}

void CMainFrame::OnViewValPane() 
{
	m_bValPaneVisible = !m_bValPaneVisible;
	if (m_bValPaneVisible)
	{
		m_wndValSplitter.ShowSecondRow();
	}
	else
	{
		m_wndValSplitter.HideSecondRow();
	}
}

void CMainFrame::ShowValPane()
{
	m_bValPaneVisible = true;
	m_wndValSplitter.ShowSecondRow();
}

void CMainFrame::HideValPane()
{
	m_bValPaneVisible = false;
	m_wndValSplitter.HideSecondRow();
}

void CMainFrame::OnUpdateViewValPane(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(m_bValPaneVisible);
}


///////////////////////////////////////////////////////////////////////
// the splitter view is really just a wrapper window for the child
// splitter window. It does not derive from CView since views have 
// lots of extra semantics and implicit message handling). 

IMPLEMENT_DYNCREATE(CSplitterView, CWnd);

BEGIN_MESSAGE_MAP(CSplitterView, CWnd)
	//{{AFX_MSG_MAP(CSplitterView)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////
// on creation of the splitter view window, create a child splitter
// window with two panes that completely fills the window area. The 
// child panes manage their own size.
int CSplitterView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// create a splitter window with two horizontal panes.
	m_wndSplitter.CreateStatic(this, 1, 2, WS_CHILD|WS_VISIBLE, AFX_IDW_PANE_FIRST+2);

	// grab the creation context from the parent
	CCreateContext *pContext = (CCreateContext*) lpCreateStruct->lpCreateParams;

	// initial size of child columns is irrelevant, they manage their own size 
	// based on their content.
	CSize sizeInit(100,100);
	m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CTableList), sizeInit, pContext);
	m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CTableView), sizeInit, pContext);
	return 0;
}

// when resizing a splitter view, resize the child to ensure it completely fills the area.
// expand the window sit 2 pixels outside the visible window to hide the border (2 is
// hardcoded in the MFC source)
void CSplitterView::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	m_wndSplitter.SetWindowPos(NULL, -2, -2, cx+4, cy+4, SWP_NOACTIVATE | SWP_NOZORDER);
}

///////////////////////////////////////////////////////////////////////
// the splitter view is completely covered by its splitter window. 
// there is no need to erase the background ever, it just causes 
// flicker when redrawing the window.
afx_msg BOOL CSplitterView::OnEraseBkgnd( CDC* pDC )
{
	return 1;
}


///////////////////////////////////////////////////////////////////////
// the COrcaSplitterWnd is a derived class from CSplitterWnd whose sole
// purpose is to allow us to manipulate the protected data in the base
// class to allow dynamic control over the visibility of the child panes. 
COrcaSplitterWnd::COrcaSplitterWnd() : CSplitterWnd()
{
}

void COrcaSplitterWnd::HideSecondRow()
{ 
	GetPane(1,0)->ShowWindow(SW_HIDE);
	m_nRows = 1; 
	RecalcLayout();
}

void COrcaSplitterWnd::ShowSecondRow()
{ 
	m_nRows = 2; 
	GetPane(1,0)->ShowWindow(SW_SHOW);
	RecalcLayout();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\msmresd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_MsmResD_H__20272D54_EADD_11D1_A857_006097ABDE17__INCLUDED_)
#define AFX_MsmResD_H__20272D54_EADD_11D1_A857_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MsmResD.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CMsmResD dialog
struct IMsmConfigureModule;
struct IMsmErrors;

class CMsmResD : public CDialog
{
// Construction
public:
	CMsmResD(CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CMsmResD)
	enum { IDD = IDD_MERGERESULTS };
		// NOTE: the ClassWizard will add data members here
	CEdit m_ctrlResults;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsmResD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	CString strHandleString;             // db handle as string
	CString m_strModule;             // module path
	CString m_strFeature;
	CString m_strLanguage;    // language
	CString m_strRootDir;            // redirection directory
	CString m_strCABPath;   // extract CAB path
	CString m_strFilePath;
	CString m_strImagePath;
	bool    m_fLFN;
	struct IMsmConfigureModule *CallbackObj;       // callback interface

	HRESULT m_hRes;
				
// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMsmResD)
	virtual BOOL OnInitDialog();
	virtual void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	HANDLE m_hPipeThread;
	HANDLE m_hExecThread;
	HANDLE m_hPipe;

	static DWORD __stdcall WatchPipeThread(CMsmResD *pThis);
	static DWORD __stdcall ExecuteMergeThread(CMsmResD *pThis);
};


class CMsmFailD : public CDialog
{
// Construction
public:
	CMsmFailD(CWnd* pParent = NULL);

	// Dialog Data
	//{{AFX_DATA(CMsmFailD)
	enum { IDD = IDD_MERGEFAILURE };
		// NOTE: the ClassWizard will add data members here
	CListCtrl m_ctrlResults;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsmFailD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	IMsmErrors* m_piErrors;
				
// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMsmFailD)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
 #endif // !defined(AFX_MsmResD_H__20272D54_EADD_11D1_A857_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\msmresd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// MsmResD.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "MsmResD.h"
#include "domerge.h"
#include "mergemod.h"
#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


inline CString BSTRtoCString(const BSTR bstrValue)
{
#ifdef _UNICODE
		return CString(bstrValue);
#else
		size_t cchLen = ::SysStringLen(bstrValue);
		CString strValue;
		LPTSTR szValue = strValue.GetBuffer(cchLen);
 		WideToAnsi(bstrValue, szValue, &cchLen);
		strValue.ReleaseBuffer();
		return strValue;
#endif
}


/////////////////////////////////////////////////////////////////////////////
// CMsmResD dialog


CMsmResD::CMsmResD(CWnd* pParent /*=NULL*/)
	: CDialog(CMsmResD::IDD, pParent)
{
	m_hPipe = INVALID_HANDLE_VALUE;
	m_hPipeThread = INVALID_HANDLE_VALUE;
	m_hExecThread = INVALID_HANDLE_VALUE;
	m_hRes = ERROR_FUNCTION_FAILED;
	//{{AFX_DATA_INIT(CMsmResD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

}


void CMsmResD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMsmResD)
	DDX_Control(pDX, IDC_MERGERESULTS, m_ctrlResults);
	// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMsmResD, CDialog)
	//{{AFX_MSG_MAP(CMsmResD)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsmResD message handlers


const TCHAR szLogFile[] = TEXT("\\\\.\\pipe\\MergeModLog");

DWORD WINAPI CMsmResD::WatchPipeThread(CMsmResD *pThis)
{
	char buffer[1025];
	unsigned long uiBytesRead = 0;
	if (!ConnectNamedPipe(pThis->m_hPipe, NULL))
	{
		// can return 0 if already connected. Thats OK
		if (ERROR_PIPE_CONNECTED != GetLastError())
			return 0;
	}
	
	while (ReadFile(pThis->m_hPipe, buffer, 1024, &uiBytesRead, NULL))
	{
		buffer[uiBytesRead] = 0;
#ifdef _UNICODE
		WCHAR wzBuffer[1025];
		DWORD cchBuffer = 1025;
		::MultiByteToWideChar(CP_ACP, 0, buffer, -1, wzBuffer, cchBuffer);
		pThis->m_ctrlResults.ReplaceSel(wzBuffer);
#else
		pThis->m_ctrlResults.ReplaceSel(buffer);
#endif
	}
	CloseHandle(pThis->m_hPipe);
	pThis->m_hPipe = INVALID_HANDLE_VALUE;
	return 0;
};

BOOL CMsmResD::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_ctrlResults.SetLimitText(0);
	m_hPipe = CreateNamedPipe(szLogFile, PIPE_ACCESS_INBOUND, PIPE_TYPE_BYTE | PIPE_WAIT, 
		PIPE_UNLIMITED_INSTANCES, 1024, 1024, /*timeout=*/1000, NULL);

	// win95/nt don't like NULL for threadId argument to CreateThread;
	DWORD dwThreadId = 0;
	m_hPipeThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE )WatchPipeThread, this, 0, &dwThreadId);
	m_hExecThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE )ExecuteMergeThread, this, 0, &dwThreadId);

	return TRUE;  // return TRUE unless you set the focus to a control
}


void CMsmResD::OnDestroy() 
{
	DWORD dwRes = 0;
	CloseHandle(m_hExecThread);
	CloseHandle(m_hPipeThread);
	if (INVALID_HANDLE_VALUE != m_hPipe)
		CloseHandle(m_hPipe);

}

// this thread performs the actual merge action. The logfile is the pipe name, which causes log writes to 
// wake up the WatchPipe thread and send a dialog message to the edit box. The main thread then pumps messages
// to the control, which appends the information to the log.
DWORD WINAPI CMsmResD::ExecuteMergeThread(CMsmResD *pThis)
{
	CoInitialize(NULL);
	pThis->m_hRes = ::ExecuteMerge(
				(LPMERGEDISPLAY)NULL,         // no log callback
				pThis->strHandleString,       // db handle as string
				pThis->m_strModule,           // module path
				pThis->m_strFeature,
				_ttoi(pThis->m_strLanguage),  // language
				pThis->m_strRootDir,          // redirection directory
				pThis->m_strCABPath,          // extract CAB path
				pThis->m_strFilePath,
				pThis->m_strImagePath,
				szLogFile,                    // log file path
				true,                         // don't log open/close of DB handle
				pThis->m_fLFN,                // long file names
				pThis->CallbackObj,           // callback interface,
				NULL,
				commitNo);                    // don't auto-save
	CoUninitialize();

	pThis->GetDlgItem(IDOK)->EnableWindow(TRUE);
	pThis->GetDlgItem(IDCANCEL)->EnableWindow(TRUE);
	return pThis->m_hRes;
};



inline void MSMStringstoCStringArray(IMsmStrings *piStrings, CStringArray &strArray)
{
	strArray.RemoveAll();

	IUnknown *pUnk = NULL;
	IEnumMsmString *piEnumString = NULL;
	if (S_OK != piStrings->get__NewEnum(&pUnk))
		return;

	HRESULT hRes = pUnk->QueryInterface(IID_IEnumMsmString, reinterpret_cast<void **>(&piEnumString));
	pUnk->Release();
	if (S_OK != hRes)
		return;

	BSTR bstr;
	unsigned long cRead = 0;
	while ((S_OK == piEnumString->Next(1, &bstr, &cRead)) && cRead)
	{
		strArray.Add(BSTRtoCString(bstr));
		::SysFreeString(bstr);
	}
	return;
}



/////////////////////////////////////////////////////////////////////////////
// CMsmFailD dialog


CMsmFailD::CMsmFailD(CWnd* pParent /*=NULL*/)
	: CDialog(CMsmFailD::IDD, pParent)
{
	m_piErrors = NULL;
	//{{AFX_DATA_INIT(CMsmFailD)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

}


void CMsmFailD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMsmResD)
	DDX_Control(pDX, IDC_MERGEFAILURE, m_ctrlResults);
	// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMsmFailD, CDialog)
	//{{AFX_MSG_MAP(CMsmResD)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsmFailD message handlers

BOOL CMsmFailD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	if (!m_piErrors)
		return TRUE;
 	
	m_ctrlResults.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);

    m_ctrlResults.InsertColumn(0, _T("Type"), LVCFMT_LEFT, -1, 0);
    m_ctrlResults.InsertColumn(1, _T("Description"), LVCFMT_LEFT, -1, 1);

    CString strType;
    CString strDescription;
    IMsmError* piError;
	IEnumMsmError* piEnumError;

	IUnknown *pUnk = NULL;
	bool fFailed = FAILED(m_piErrors->get__NewEnum(&pUnk));
	m_piErrors->Release();

	if (!fFailed && pUnk)
	{
		fFailed = FAILED(pUnk->QueryInterface(IID_IEnumMsmError, (void **)&piEnumError));
		pUnk->Release();
	}

	if (!fFailed)
	{
		unsigned long cRead = 0;
		while ((S_OK == piEnumError->Next(1, &piError, &cRead)) && cRead)
		{
			msmErrorType eType;
			if (FAILED(piError->get_Type(&eType)))
			{
				fFailed = true;
				continue;
			}
			switch (eType) 
			{
			case msmErrorLanguageUnsupported:
			{
				strType = TEXT("Unsupported Language");
				short iLanguage;
				if (FAILED(piError->get_Language(&iLanguage)))
				{
					fFailed = true;
					continue;
				}
				strDescription.Format(TEXT("The language %d is not supported by this module."), iLanguage);
				break;
			}
			case msmErrorLanguageFailed:
			{
				strType = TEXT("Language Failure");
				short iLanguage;
				if (FAILED(piError->get_Language(&iLanguage)))
				{
					fFailed = true;
					continue;
				}

				strDescription.Format(TEXT("The module could not be opened in language %d."), iLanguage);
				break;
			}
			case msmErrorExclusion:
			{
				strType = TEXT("Exclusion");
		
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_DatabaseKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}
					
				if (!rgstrModule.GetSize())
				{
					if (FAILED(piError->get_ModuleKeys(&piStrings)))
					{
						fFailed = true;
						continue;
					}

					if (piStrings)
					{
						MSMStringstoCStringArray(piStrings, rgstrModule);
						piStrings->Release();
					}
				}
		
				strDescription.Format(TEXT("The module can not coexist with module %s v%s (%s). "), rgstrModule.GetAt(0), rgstrModule.GetAt(2), rgstrModule.GetAt(1));
				break;
			}
			case msmErrorTableMerge:
			{
				strType = TEXT("Merge Conflict");
				
				BSTR bstr=NULL;
				if (FAILED(piError->get_ModuleTable(&bstr)))
				{
					fFailed = true;
					continue;
				}
				CString strTable = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
		
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}
					
				strDescription.Format(TEXT("Conflict in %s table, Row: %s"), strTable, rgstrModule.GetAt(0));
				for (int i=1; i < rgstrModule.GetSize(); i++)
				{
					strDescription += TEXT(", ");
					strDescription += rgstrModule.GetAt(i);
				}
				
				break;
			}
			case msmErrorResequenceMerge:
			{
				strType = TEXT("Sequencing Conflict");
				
				BSTR bstr=NULL;
				if (FAILED(piError->get_ModuleTable(&bstr)))
				{
					fFailed = true;
					continue;
				}
				CString strTable = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
		
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}
				
				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("Sequence conflict for %s action in %s table."), (LPCTSTR)rgstrModule.GetAt(0), (LPCTSTR)strTable);
				
				break;
			}
			case msmErrorFileCreate:
			{
				strType = TEXT("File Creation");
										
				BSTR bstr = NULL;
				if (FAILED(piError->get_Path(&bstr)))
				{
					fFailed = true;
					continue;
				}

				CString strPath = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
	
				if (strPath.IsEmpty())
					strDescription = TEXT("Could not create file.");
				else
					strDescription.Format(TEXT("Could not create file: %s"), strPath);
				break;
			}
			case msmErrorDirCreate:
			{
				strType = TEXT("Directory Creation");
							
				BSTR bstr = NULL;
				if (FAILED(piError->get_Path(&bstr)))
				{
					fFailed = true;
					continue;
				}

				CString strPath = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
	
				strDescription.Format(TEXT("Could not create path: %s"), strPath);
				break;
			}
			case msmErrorFeatureRequired:
			{
				strType = TEXT("Feature Required");
				
				BSTR bstr = NULL;
				if (FAILED(piError->get_ModuleTable(&bstr)))
				{
					fFailed = true;
					continue;
				}
				CString strTable = BSTRtoCString(bstr);
				if (bstr)
					SysFreeString(bstr);
						
				strDescription.Format(TEXT("A feature is required by the %s table."), strTable);
				break;
			}
			case msmErrorBadNullSubstitution:
			{
				strType = TEXT("Invalid NULL");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("Module configuration attempted to place a NULL value in the %s column of the %s table."), rgstrModule.GetAt(2), rgstrModule.GetAt(0));
				break;
			}
			case msmErrorBadSubstitutionType:
			{
				strType = TEXT("Configuration Error");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("The type of value in the %s column of the %s table did not match the column type."), rgstrModule.GetAt(2), rgstrModule.GetAt(0));
				break;
			}
			case msmErrorMissingConfigItem:
			{
				strType = TEXT("Configuration Error");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("Unknown configuration value requested for the %s column of the %s table."), rgstrModule.GetAt(2), rgstrModule.GetAt(0));
				break;
			}
			case msmErrorBadNullResponse:
			{
				strType = TEXT("Invalid NULL");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}

				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}
				
				strDescription.Format(TEXT("NULL is not a valid response for module configuration parameter %s."), rgstrModule.GetAt(0));
				break;
			}
			case msmErrorDataRequestFailed:
			{
				strType = TEXT("Internal Orca Error");
				
				IMsmStrings* piStrings = NULL;
				if (FAILED(piError->get_ModuleKeys(&piStrings)))
				{
					fFailed = true;
					continue;
				}
				
				CStringArray rgstrModule;
				if (piStrings)
				{
					MSMStringstoCStringArray(piStrings, rgstrModule);
					piStrings->Release();
				}

				strDescription.Format(TEXT("Internal failure providing data for the %s configuration parameter."), rgstrModule.GetAt(0));
				break;
			}
			default:
			{
				strType = TEXT("Unknown Error");
				
				strDescription = TEXT("Unknown failure.");
				break;
			}
			}
		
			// insert item
			int iIndex = m_ctrlResults.InsertItem(1, strType);
			m_ctrlResults.SetItem(iIndex, 1, LVIF_TEXT, strDescription, 0, 0, 0, 0);
		}
	}
	if (fFailed)
	{
		int iIndex = m_ctrlResults.InsertItem(1, TEXT("Failure"));
		m_ctrlResults.SetItem(iIndex, 1, LVIF_TEXT,  TEXT("Orca was unable to retrieve all error data."), 0, 0, 0, 0);
	}

    m_ctrlResults.SetColumnWidth(0, LVSCW_AUTOSIZE);
    m_ctrlResults.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);

	if (!m_ctrlResults.GetItemCount())
		EndDialog(IDOK);

    return TRUE;  // return TRUE unless you set the focus to a control
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\orca.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Orca.h : main header file for the ORCA application
//

#if !defined(AFX_ORCA_H__C3EDC1A8_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_ORCA_H__C3EDC1A8_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include <objbase.h>
#include "msiquery.h"
#include "orca_res.h"       // main symbols

// forward declaration
class COrcaCommandLine;

/////////////////////////////////////////////////////////////////////////////
// COrcaApp:
// See Orca.cpp for the implementation of this class
//
class COrcaApp : public CWinApp
{
public:
	CStringList m_lstClipCleanup;
	CStringList m_lstTempCleanup;
	CString GetOrcaVersion();
	static void OutputMergeDisplay(const BSTR bstrOut);
	COrcaApp();

	CString m_strSchema;
	MSIHANDLE m_hSchema;

	UINT FindSchemaDatabase(CString& rstrSchema);
	UINT ExecuteMergeModule(COrcaCommandLine &cmdInfo);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COrcaApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(COrcaApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

DWORD RecordGetString(MSIHANDLE hRec, int iField, CString &strValue);

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORCA_H__C3EDC1A8_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\orcadoc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// OrcaDoc.cpp : implementation of the COrcaDoc class
//

#include "stdafx.h"
#include "Orca.h"
#include "MainFrm.h"
#include "Imprtdlg.h"

#include <afxdisp.h>

#include "OrcaDoc.h"

#include "SummaryD.h"
#include "ValD.h"
#include "AddTblD.h"
#include "AddRowD.h"
#include "merged.h"
#include "cnfgmsmd.h"
#include "msmresd.h"
#include "trnpropd.h"
#include "..\common\query.h"
#include "..\common\dbutils.h"
#include "..\common\utils.h"
#include "domerge.h"
#include "msidefs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COrcaDoc

IMPLEMENT_DYNCREATE(COrcaDoc, CDocument)

BEGIN_MESSAGE_MAP(COrcaDoc, CDocument)
	//{{AFX_MSG_MAP(COrcaDoc)
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_COMMAND(ID_FILE_SAVE_TRANSFORMED, OnFileSaveTransformed)
	ON_COMMAND(ID_SUMMARY_INFORMATION, OnSummaryInformation)
	ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
	ON_COMMAND(ID_TABLE_ADD, OnTableAdd)
	ON_COMMAND(ID_ROW_ADD, OnRowAdd)
	ON_COMMAND(ID_TABLE_DROP, OnTableDrop)
	ON_COMMAND(ID_TABLES_IMPORT, OnTablesImport)
	ON_COMMAND(ID_VALIDATOR, OnValidator)
	ON_COMMAND(ID_TRANSFORM_APPLYTRANSFORM, OnApplyTransform)
	ON_COMMAND(ID_TRANSFORM_NEWTRANSFORM, OnNewTransform)
	ON_COMMAND(ID_TRANSFORM_GENERATETRANSFORM, OnGenerateTransform)
	ON_COMMAND(ID_TRANSFORM_TRANSFORMPROPERTIES, OnTransformProperties)
	ON_COMMAND(ID_TRANSFORM_CLOSETRANSFORM, OnCloseTransform)
	ON_COMMAND(ID_TRANSFORM_VIEWPATCH, OnTransformViewPatch)
	ON_UPDATE_COMMAND_UI(ID_FILE_CLOSE, OnUpdateFileClose)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_AS, OnUpdateFileSaveAs)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_TRANSFORMED, OnUpdateFileSaveTransformed)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdateFilePrint)
	ON_UPDATE_COMMAND_UI(ID_TABLE_ADD, OnUpdateTableAdd)
	ON_UPDATE_COMMAND_UI(ID_ROW_ADD, OnUpdateRowAdd)
	ON_UPDATE_COMMAND_UI(ID_VALIDATOR, OnUpdateValidator)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_APPLYTRANSFORM, OnUpdateApplyTransform)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_NEWTRANSFORM, OnUpdateNewTransform)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_GENERATETRANSFORM, OnUpdateGenerateTransform)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_CLOSETRANSFORM, OnUpdateCloseTransform)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_VIEWPATCH, OnUpdateTransformViewPatch)
	ON_UPDATE_COMMAND_UI(ID_TABLE_DROP, OnUpdateTableDrop)
	ON_UPDATE_COMMAND_UI(ID_SUMMARY_INFORMATION, OnUpdateSummaryInformation)
	ON_UPDATE_COMMAND_UI(ID_TABLES_EXPORT, OnUpdateTablesExport)
	ON_UPDATE_COMMAND_UI(ID_TABLES_IMPORT, OnUpdateTablesImport)
	ON_COMMAND(ID_TABLES_IMPORT, OnTablesImport)
	ON_UPDATE_COMMAND_UI(ID_VALIDATOR, OnUpdateValidator)
	ON_COMMAND(ID_VALIDATOR, OnValidator)
	ON_COMMAND(ID_TOOLS_MERGEMOD, OnMergeMod)
	ON_UPDATE_COMMAND_UI(ID_TOOLS_MERGEMOD, OnUpdateMergeMod)
	ON_UPDATE_COMMAND_UI(ID_TRANSFORM_TRANSFORMPROPERTIES, OnUpdateTransformProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COrcaDoc construction/destruction

COrcaDoc::COrcaDoc() : 
	m_dwTransformErrFlags(0), 
	m_dwTransformValFlags(0),
	m_bTransformReadOnly(false),
	m_hDatabase(0),
	m_hTransformDB(0),
	m_bTransformModified(false),
	m_bTransformIsPatch(false),
	m_strTransformFile(TEXT(""))
{
	m_eiType = iDocNone;
	m_bReadOnly = false;
	m_strPathName = "";
	m_strICEsToRun = AfxGetApp()->GetProfileString(_T("Validation"), _T("ICEs"), _T(""));
	m_strCUBFile = AfxGetApp()->GetProfileString(_T("Validation"),_T("Location"));
	m_bShowValInfo = ::AfxGetApp()->GetProfileInt(_T("Validation"), _T("SuppressInfo"), 0) != 1;
	m_strStoredModuleLanguage = TEXT("1033");
	m_strStoredModuleName = TEXT("");
}

COrcaDoc::~COrcaDoc()
{
	// if a database is open close it
	if (m_hDatabase)
		MsiCloseHandle(m_hDatabase);

	if (m_hTransformDB)
	{
		MsiCloseHandle(m_hTransformDB);
		m_hTransformDB=0;
		if (!m_strTransformTempDB.IsEmpty())
		{
			DeleteFile(m_strTransformTempDB);
			m_strTransformTempDB = _T("");
		}
	}

	while (!m_lstPatchFiles.IsEmpty())
		m_lstPatchFiles.RemoveHead();

	// just in case
	DestroyTableList();
	m_eiType = iDocNone;
}

/////////////////////////////////////////////////////////////////////////////
// COrcaDoc diagnostics

#ifdef _DEBUG
void COrcaDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void COrcaDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COrcaDoc commands

BOOL COrcaDoc::OnNewDocument()
{
	CWaitCursor curWait;

	TRACE(_T("COrcaDoc::OnNewDocument - called.\n"));

	// if a database is open close it
	if (m_hDatabase)
	{
		MsiCloseHandle(m_hDatabase);
		m_hDatabase = NULL;
	}

	// if a transform is open close it
	if (m_hTransformDB)
	{
		MsiCloseHandle(m_hTransformDB);
		m_hTransformDB = 0;
		if (!m_strTransformTempDB.IsEmpty())
		{
			DeleteFile(m_strTransformTempDB);
			m_strTransformTempDB = _T("");
		}
	}

	// send a hint to change to no table. This cleans up the window
	// and makes it safe to have a refresh in the middle of this call.
	UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
	UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

	// destroy all of the tables, mark no document loaded until regenerated
	DestroyTableList();	
	m_eiType = iDocNone;

	// blank all the summary information
	m_strTitle = _T("Installation Database");
	m_strSubject = _T("");
	m_strAuthor = _T("");
	m_strLastSaved = _T("");
	m_strKeywords = _T("Install,MSI");
	m_strComments = _T("This installer database contains the logic and data required to install <product name>.");
	m_strPlatform = _T("");
	m_strLanguage = _T("0");

	GUID prodGUID;
	int cchGuid = 50;
	m_strProductGUID = _T("");
	CoCreateGuid(&prodGUID);
	m_strProductGUID.Format(_T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), 
				  prodGUID.Data1, prodGUID.Data2, prodGUID.Data3,
				  prodGUID.Data4[0], prodGUID.Data4[1],
				  prodGUID.Data4[2], prodGUID.Data4[3], prodGUID.Data4[4],
				  prodGUID.Data4[5], prodGUID.Data4[6], prodGUID.Data4[7]);
	m_nSchema = 100;
	m_nFilenameType = 0;
	m_nSecurity = 0;

	m_bTransformIsPatch = false;
	m_bTransformReadOnly = false;
	m_bReadOnly = false;

	m_dwTransformErrFlags = 0;
	m_dwTransformValFlags = 0;
	SetModifiedFlag(FALSE);

	// wipe everything
	UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);

	// do the base document's clean up
	if (!CDocument::OnNewDocument())
		return FALSE;

	// get a temp path
	DWORD cchTempPath = MAX_PATH;
	TCHAR szTempPath[MAX_PATH];
	::GetTempPath(cchTempPath, szTempPath);

	// get a temp filename
	TCHAR szTempFilename[MAX_PATH];
	UINT iResult = ::GetTempFileName(szTempPath, _T("ODB"), 0, szTempFilename);

	// try to open the database for read/write
	if (ERROR_SUCCESS != MsiOpenDatabase(szTempFilename, MSIDBOPEN_CREATE, &m_hDatabase))
		return FALSE;

	m_eiType = iDocDatabase;
	SetTitle(m_strPathName);

	return TRUE;
}

///////////////////////////////////////////////////////////
// OnFileOpen
void COrcaDoc::OnFileOpen() 
{
	// open the file open dialog
	CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST,
						 _T("Installer Database Files (*.msi, *.msm, *.pcp)|*.msi;*.msm;*.pcp|Windows Installer (*.msi)|*.msi|Merge Module (*.msm)|*.msm|Patch Creation Properties (*.pcp)|*.pcp|All Files (*.*)|*.*||"), AfxGetMainWnd());

	if (IDOK == dlg.DoModal())
	{
		bool bReadOnly = (FALSE != dlg.GetReadOnlyPref());
		OpenDocument(dlg.GetPathName(), bReadOnly);
	}
}	// end of OnFileOpen

///////////////////////////////////////////////////////////////////////
// OnOpenDocument
// bReadOnly should be set to true if this function should NOT try
// to open the document for read/write. After this function, it will
// be set to the actual state of the file.
BOOL COrcaDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	return OpenDocument(lpszPathName, false);
}

///////////////////////////////////////////////////////////////////////
// OnOpenDocument
// bReadOnly should be set to true if this function should NOT try
// to open the document for read/write. After this function, it will
// be set to the actual state of the file.
BOOL COrcaDoc::OpenDocument(LPCTSTR lpszPathName, bool bReadOnly) 
{
	TRACE(_T("Opening file: %s\n"), lpszPathName);

	CString strPrompt;	// generic prompt string
	BOOL bResult = TRUE;	// assume everything will be okay

	int cchCount = lstrlen(lpszPathName);

	// if a database is open close it
	if (m_hDatabase)
	{
		MsiCloseHandle(m_hDatabase);
		m_hDatabase = NULL;
	}

	// if a transform is open close it
	if (m_hTransformDB)
	{
		MsiCloseHandle(m_hTransformDB);
		m_hTransformDB = 0;
		if (!m_strTransformTempDB.IsEmpty())
		{
			DeleteFile(m_strTransformTempDB);
			m_strTransformTempDB = _T("");
		}
	}
	m_dwTransformErrFlags = 0;
	m_dwTransformValFlags = 0;
	m_bTransformIsPatch = false;
	m_bTransformReadOnly = false;
	m_bReadOnly = false;
	
	// if given file on the command line, the window won't exist yet, so no update.
	// Its handled by InitInstance after the window is created.
	if (NULL != ::AfxGetMainWnd()) 
	{
		// clear any pending validation errors
		UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);
		((CMainFrame*)AfxGetMainWnd())->HideValPane();

		// update the views that everything is gone (prevents redraws from accessing destroyed memory)
		UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
		UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);
	}
	DestroyTableList();				// destroy the old table
	m_eiType = iDocNone;

	// try to open the database for read/write, unless told not to
	UINT iResult;
	if (!bReadOnly &&
		(ERROR_SUCCESS == (iResult = MsiOpenDatabase(lpszPathName, MSIDBOPEN_TRANSACT, &m_hDatabase))))
	{
		// set the database as read/write
		m_bReadOnly = false;
		bResult = true;
	}
	else if (ERROR_SUCCESS == (iResult = MsiOpenDatabase(lpszPathName, MSIDBOPEN_READONLY, &m_hDatabase)))
	{			
		// set the database as read only
		m_bReadOnly = true;
		bResult = true;
	}
	else
	{
		bResult = false;

		strPrompt.Format(_T("Failed to open MSI Database: `%s`"), lpszPathName);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
	}

	// if succeeded
	if (bResult)
	{
		// mark that a file is open
		m_eiType = iDocDatabase;
	
		// read the summary information
		iResult = ReadSummary(m_hDatabase);
		ASSERT(ERROR_SUCCESS == iResult);

		// read the table list
		iResult = BuildTableList(/*AllowLazyLoad=*/true);
		ASSERT(ERROR_SUCCESS == iResult);

		// add this file to recently open files
		m_strPathName = lpszPathName;
		SetPathName(m_strPathName, TRUE);
	}
	else	// nothing is open
	{
		SetPathName(_T(""), FALSE);
		m_strPathName=_T("");
	}

	// new document open, so there shouldn't be any changes yet
	SetModifiedFlag(FALSE);

	// if given file on the command line, the window won't exist yet, so no update.
	// Its handled by InitInstance after the window is created.
	if (NULL != ::AfxGetMainWnd()) 
	{
		// clear anything existing
		UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
		UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);
	}

	return bResult;
}	// end of OpenDocument

///////////////////////////////////////////////////////////
// OnFileSave
void COrcaDoc::OnFileSave() 
{
	ASSERT(!m_bReadOnly);
	CString strPath = GetPathName();
	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);
	OnSaveDocument(strPath);
}	// end of OnFileSave

///////////////////////////////////////////////////////////
// OnFileSaveAs
void COrcaDoc::OnFileSaveAs() 
{
	// open the file open dialog
	CFileDialog dlg(FALSE, NULL, NULL, OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
						 _T("Windows Installer (*.msi)|*.msi|Merge Module (*.msm)|*.msm|Patch Creation Properties (*.pcp)|*.pcp|All Files (*.*)|*.*||"), AfxGetMainWnd());

	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);
	if (IDOK == dlg.DoModal())
	{
		CString strPath = dlg.GetPathName();
		CString strExt = dlg.GetFileExt();

		if (strPath.IsEmpty())
			return;

		// if there is no extension add one
		if (strExt.IsEmpty())
		{
			switch(dlg.m_ofn.nFilterIndex)
			{
			case 1:
				strExt = _T(".msi");
				break;
			case 2:
				strExt = _T(".msm");
				break;
			case 3:
				strExt = _T(".pcp");
				break;
			default:
				strExt = _T(".msi");
				break;
			}

			strPath += strExt;
		}
		
		// if saved document open it up
		if (!OnSaveDocument(strPath))
			AfxMessageBox(_T("Failed to save document."), MB_ICONSTOP);
		else
		{
			// and change the title of the window
			m_strPathName = strPath;

			// no longer read only
			m_bReadOnly = false;

			// add this file to recently open files
			SetPathName(m_strPathName, TRUE);
		}

	}
}	// end of OnFileSaveAs


///////////////////////////////////////////////////////////
// OnFileSaveAs
void COrcaDoc::OnFileSaveTransformed() 
{
	ASSERT(m_hTransformDB);
	if (!m_hTransformDB)
		return;

	// open the file open dialog
	CFileDialog dlg(FALSE, NULL, NULL, OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
						 _T("Windows Installer (*.msi)|*.msi|Merge Module (*.msm)|*.msm|Patch Creation Properties (*.pcp)|*.pcp|All Files (*.*)|*.*||"), AfxGetMainWnd());

	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);
	if (IDOK == dlg.DoModal())
	{
		CString strPath = dlg.GetPathName();
		CString strExt = dlg.GetFileExt();

		if (strPath.IsEmpty())
			return;

		// if there is no extension add one
		if (strExt.IsEmpty())
		{
			switch(dlg.m_ofn.nFilterIndex)
			{
			case 1:
				strExt = _T(".msi");
				break;
			case 2:
				strExt = _T(".msm");
				break;
			case 3:
				strExt = _T(".pcp");
				break;
			default:
				strExt = _T(".msi");
				break;
			}

			strPath += strExt;
		}
		
		// create the database to persist to
		PMSIHANDLE hPersist;
		if (ERROR_SUCCESS != MsiOpenDatabase(strPath, MSIDBOPEN_CREATE, &hPersist))
		{
			AfxMessageBox(_T("Failed to save document."), MB_ICONSTOP);
			return;
		}

		if (ERROR_SUCCESS == PersistTables(hPersist, GetTransformedDatabase(), /*fCommit=*/true))
		{
			SetModifiedFlag(FALSE);
		}
	}
}	// end of OnFileSaveAs

///////////////////////////////////////////////////////////
// OnSaveDocument
BOOL COrcaDoc::OnSaveDocument(LPCTSTR lpszPathName) 
{
	TRACE(_T("COrcaDoc::OnSaveDocument - called[%s]\n"), lpszPathName);

	// if the path name is empty call on OnSaveAs
	if (0 == lstrlen(lpszPathName))
	{
		OnFileSaveAs();
		return TRUE;
	}

	// pop up the wait cursor
	CWaitCursor cursor;

	BOOL bResult = FALSE;		// assume we won't save

	// assume everything is good
	UINT iResult = ERROR_SUCCESS;	

	// if these are not the same databases
	MSIHANDLE hPersist = NULL;
	if (0 != m_strPathName.CompareNoCase(lpszPathName))
	{
		// create the database to persist to
		iResult = MsiOpenDatabase(lpszPathName, MSIDBOPEN_CREATE, &hPersist);
	}
	else	// saving to the same database
		hPersist = m_hDatabase;

	// if tables are persisted (and saved)
	if (ERROR_SUCCESS == PersistTables(hPersist, GetOriginalDatabase(), /*fCommit=*/true))
	{
		SetModifiedFlag(FALSE);
		bResult = TRUE;
	}

	// if the persisted database is valid and not the main database
	if (NULL != hPersist && 
		hPersist != m_hDatabase)
	{
		// close the current database, because SaveAs leaves you
		// with the new one
		MsiCloseHandle(m_hDatabase);	// close it
		m_hDatabase = hPersist;
	}

	return bResult;
}	// end of OnSaveDocument

///////////////////////////////////////////////////////////
// OnFileClose
void COrcaDoc::OnFileClose() 
{
	// commit any changes pending in the edit window
	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);

	// if the document is modified ask to save
	if (IsModified())
	{
		CString strPrompt;
		strPrompt.Format(_T("Save changes to %s?"), m_strPathName);

		UINT iResult = AfxMessageBox(strPrompt, MB_YESNOCANCEL);

		if (IDYES == iResult)
		{
			// if the path name is empty call on OnSaveAs
			if (m_strPathName.IsEmpty())
			{
				OnFileSaveAs();
			}
			else	// already have a path to save to
			{
				// if fail to save as bail
				if (!OnSaveDocument(m_strPathName))
					return;
			}
		}
		else if (IDCANCEL == iResult)
			return;
	}

	// clear any pending validation errors
	UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);
	((CMainFrame*)AfxGetMainWnd())->HideValPane();

	// switch the table list to point to nothing, so that when we destroy the 
	// table list and its corresponding rows, we won't have the view try to 
	// refresh the display of the deleted table
	UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
	UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

	// pop up a wait cursor
	CWaitCursor cursor;

	m_dwTransformErrFlags = 0;
	m_dwTransformValFlags = 0;
	DestroyTableList();				// destroy the tables
	m_eiType = iDocNone;

	if (DoesTransformGetEdit())
		CloseTransform();

	// if a database is open close it
	if (m_hDatabase)
	{
		MsiCloseHandle(m_hDatabase);
		m_hDatabase = NULL;
	}

	m_bReadOnly = false;
	SetModifiedFlag(FALSE);
	m_strPathName = _T("");
	SetPathName(_T(""), FALSE);

	UpdateAllViews(NULL, HINT_RELOAD_ALL);

}	// end of OnFileClose

///////////////////////////////////////////////////////////
// OnTableAdd
void COrcaDoc::OnTableAdd() 
{	
	// get the app
	COrcaApp* pApp = (COrcaApp*)AfxGetApp();

	// get all the table names
	CQuery querySchema;
	if (ERROR_SUCCESS != querySchema.Open(pApp->m_hSchema, _T("SELECT `Name` FROM `_Tables`")))
		return;
	if (ERROR_SUCCESS != querySchema.Execute())
		return;

	CString strTable;
	CStringList strTableList;

	UINT iResult;
	PMSIHANDLE hTable;
	do
	{
		iResult = querySchema.Fetch(&hTable);

		if (ERROR_SUCCESS == iResult)
		{
			// get the table name
			DWORD cchBuffer = 256 * sizeof(TCHAR);
			MsiRecordGetString(hTable, 1, strTable.GetBuffer(cchBuffer), &cchBuffer);
			strTable.ReleaseBuffer();

			// add this table to the list
			strTableList.AddTail(strTable);
		}
		else if (ERROR_NO_MORE_ITEMS != iResult)
		{
			TRACE(_T(">> Unknown error.  #%d\n"), iResult);
			break;
		}
	} while (hTable);

	if (strTableList.GetCount() > 0)
	{
		// get all of the tables from the current database
		CQuery queryDatabase;
		if (ERROR_SUCCESS != queryDatabase.Open(GetTargetDatabase(), _T("SELECT `Name` FROM `_Tables`")))
			return;
		if (ERROR_SUCCESS != queryDatabase.Execute())
			return;

		POSITION posFound;
		do
		{
			iResult = queryDatabase.Fetch(&hTable);

			if (ERROR_SUCCESS == iResult)
			{
				// get the table name
				DWORD cchBuffer = 256 * sizeof(TCHAR);
				MsiRecordGetString(hTable, 1, strTable.GetBuffer(cchBuffer), &cchBuffer);
				strTable.ReleaseBuffer();

				// if this table is in the table list
				posFound = strTableList.Find(strTable);
				if (posFound)
				{
					// remove the string from the list to add
					strTableList.RemoveAt(posFound);
				}
				else	// I don't think I should get here
					ASSERT(FALSE);	// will fail on the flags table
			}
			else if (ERROR_NO_MORE_ITEMS != iResult)
			{
				TRACE(_T(">> Unknown error.  #%d\n"), iResult);
				break;
			}
		} while (hTable);

		// create the add dialog box
		CAddTableD dlg;
		dlg.m_plistTables = &strTableList;

		if (IDOK == dlg.DoModal())
		{
			CString strPrompt;
			POSITION pos = strTableList.GetHeadPosition();
			while (pos)
			{
				strTable = strTableList.GetNext(pos);
				if (ERROR_SUCCESS == MsiDBUtils::CreateTable(strTable, GetTargetDatabase(), pApp->m_hSchema))
				{
					// the document is definitely modified
					SetModifiedFlag(TRUE);
					/// ***********************
					CreateAndLoadNewlyAddedTable(strTable);
				}					
				else	// failed to create the table
				{
					strPrompt.Format(_T("Failed to create table: '%s'"), strTable);
					AfxMessageBox(strPrompt, MB_ICONSTOP);
				}
			}
		}
	}
}	// end of OnTableAdd


///////////////////////////////////////////////////////////////////////
// adds a new table by name. Checks for existing tables. May add a 
// new table to the UI or may not, depending on schema differences
// between the two databasases. Returns pointer to new table.
COrcaTable *COrcaDoc::CreateAndLoadNewlyAddedTable(CString strTable)
{
	// if this table already exists in the UI, it either:
	//  1) is a shadow table
	//  2) is non-split with a compatible schema
	//  3) is non-split with an incompatible schema
	
	// what to do for shadow tables *****************
	// look for the table in the UI. Since this is a new table, we're looking for
	// the opposite database UI entry.
	COrcaTable *pTable = FindTable(strTable, DoesTransformGetEdit() ? odlSplitOriginal : odlSplitTransformed);
	if (pTable)
	{
		ASSERT(MSICONDITION_NONE != ::MsiDatabaseIsTablePersistent(GetOriginalDatabase(), strTable));
		ASSERT(!pTable->IsSplitSource());
		
		// check to see if the schema is compatible.
		bool fExact = false;
		bool fCompatible = !pTable->IsSchemaDifferent(GetTargetDatabase(), false, fExact);

		// if the schemas are not compatible, the existing table becomes a drop, but we
		// also need to add a NEW table with the new column definitions. Both tables are now
		// split-source tables
		if (!fCompatible)
		{
			pTable->SetSplitSource(odlSplitOriginal);
			pTable->Transform(iTransformDrop);
			ASSERT(pTable->IsTransformed());
			
			COrcaTable *pNewTable = CreateAndLoadTable(GetTargetDatabase(), strTable);
			pNewTable->SetSplitSource(odlSplitTransformed);
			pNewTable->Transform(iTransformAdd);

			UpdateAllViews(NULL, HINT_ADD_TABLE, pNewTable);
			UpdateAllViews(NULL, HINT_REDRAW_TABLE, pTable);
		}
		else
		{
			// but if the schemas are compatible, the "drop" or "add" is erased, so we clear the 
			// transform on this table
			pTable->Transform(iTransformNone);

			// and redraw the ui in the table list
			UpdateAllViews(NULL, HINT_REDRAW_TABLE, pTable);

			// if the tables aren't exactly the same, we need to do some schema work, 
			// but if they are exactly the same, a simple data reload will do 
			if (!fExact)
			{
				// when adding a table to a transform, its a superset, so we
				// need to add the additional columns
				pTable->LoadTableSchema(GetTransformedDatabase(), strTable);
				UpdateAllViews(NULL, HINT_TABLE_REDEFINE, pTable);
			}
			else
			{
				// we need to do a data reload in case the newly added table's data differs from
				// the existing table (which it almost always will)
				pTable->EmptyTable();
				
				// and redraw the ui in the table list
				UpdateAllViews(NULL, HINT_TABLE_DATACHANGE, pTable);
			}
		}
	}
	else
	{
		// doesn't exist in the non-target, so this is a "clean add" load the table
		pTable = CreateAndLoadTable(GetTargetDatabase(), strTable);
		if (pTable && DoesTransformGetEdit())
		{
			pTable->Transform(iTransformAdd);
		}
		SetModifiedFlag(TRUE);
		UpdateAllViews(NULL, HINT_ADD_TABLE, pTable);
	}
	return pTable;
}


///////////////////////////////////////////////////////////
// Export Tables, called by messagehandlers of TableList and the menu
// to export a table
bool COrcaDoc::ExportTable(const CString* pstrTableName, const CString *pstrDirName) 
{

	UINT iResult;
	CString strPrompt;
	CString strFilename;
			
	strFilename.Format(_T("%s.idt"), pstrTableName->Left(8));
	iResult = ::MsiDatabaseExport(GetTargetDatabase(), *pstrTableName, *pstrDirName, strFilename);

	return (ERROR_SUCCESS == iResult);
}

///////////////////////////////////////////////////////////
// OnRowAdd - message handler for "add row". Throws UI
// and creates a row from the results, then adds it to
// the table.
void COrcaDoc::OnRowAdd() 
{
	// if read only, do nothing.
	if (TargetIsReadOnly()) return;

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	COrcaTable* pTable = pFrame->GetCurrentTable();
	ASSERT(pTable);
	if (!pTable)
		return;


	CAddRowD dlg;
	pTable->FillColumnArray(&dlg.m_pcolArray, DoesTransformGetEdit());

	if (IDOK == dlg.DoModal())
	{
		CString strPrompt;
		if (ERROR_SUCCESS != AddRow(pTable, &dlg.m_strListReturn))
		{
			strPrompt.Format(_T("Failed to add row to the %s table."), pTable->Name());
			AfxMessageBox(strPrompt);
		}
	}
}	// end of OnRowAdd

void COrcaDoc::OnTableDrop() 
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	COrcaTable* pTable = pFrame->GetCurrentTable();
	ASSERT (pTable && pFrame);
	if (!pTable || ! pFrame)
		return;

	CString strPrompt;
	strPrompt.Format(_T("Drop table '%s'?"), pTable->Name());
	if (IDYES == AfxMessageBox(strPrompt, MB_ICONINFORMATION|MB_YESNO))
	{
		POSITION pos = m_tableList.Find(pTable);
		if (pos)
		{
			pTable->DropTable(GetTargetDatabase());
			SetModifiedFlag(TRUE);

			// the table is removed from the UI if there are no transforms, if the table
			// doesn't exist in the target database, or if the table is marked as
			// a single source table. Otherwise its just a transform op.
			MSIHANDLE hNonTarget = GetOriginalDatabase();
			if (!DoesTransformGetEdit() || (MSICONDITION_NONE == MsiDatabaseIsTablePersistent(hNonTarget, pTable->Name())) ||
			    pTable->IsSplitSource())
			{
				// update the views before yanking the data
				UpdateAllViews(NULL, HINT_DROP_TABLE, pTable);
				m_tableList.RemoveAt(pos);

				if (pTable->IsSplitSource())
				{	
					// doesn't matter what split source we search for, as we just removed this 
					// half from the split table list
					COrcaTable *pOtherTable = FindTable(pTable->Name(), DoesTransformGetEdit() ? odlSplitOriginal : odlSplitTransformed);
					ASSERT(pOtherTable);
					if (pOtherTable)
						pOtherTable->SetSplitSource(odlNotSplit);
				}

				// finally delete the table object
				pTable->DestroyTable();
				delete pTable;
				pTable = NULL;
			}
			else
			{
				// otherwise we're actually transforming the object to signify the drop. The table
				// will take care of any UI changes that need to be done during the drop.
				pTable->Transform(iTransformDrop);
			}
		}
		else	// shouldn't get here
		{
			AfxMessageBox(_T("Error: Attempted to drop non-existant table."), MB_ICONSTOP);
		}
	}
}

///////////////////////////////////////////////////////////
// CmdSetters
void COrcaDoc::OnUpdateFileClose(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateFileSave(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone && m_bModified && !DoesTransformGetEdit());
}

void COrcaDoc::OnUpdateFileSaveAs(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone && !DoesTransformGetEdit());
}

void COrcaDoc::OnUpdateFileSaveTransformed(CCmdUI* pCmdUI) { pCmdUI->Enable(DoesTransformGetEdit() && !m_bTransformIsPatch); }

void COrcaDoc::OnUpdateFilePrint(CCmdUI* pCmdUI) 
{
	// disable printing forever
	pCmdUI->Enable(FALSE);
}

void COrcaDoc::OnUpdateTableAdd(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(!TargetIsReadOnly() && m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateTableDrop(CCmdUI* pCmdUI) 
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame)
		pCmdUI->Enable(FALSE);
	else
	{
		COrcaTable *pTable = pFrame->GetCurrentTable();
		if (DoesTransformGetEdit())
		{
			pCmdUI->Enable(NULL != pTable && !m_bTransformReadOnly && !pTable->IsShadow() && (pTable->IsTransformed() != iTransformDrop));
		}
		else
		{
			pCmdUI->Enable(NULL != pTable && !m_bReadOnly && !pTable->IsShadow());
		}
	}
}

void COrcaDoc::OnUpdateRowAdd(CCmdUI* pCmdUI) 
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame)
		pCmdUI->Enable(FALSE);
	else
	{
		// if there is an active non-shadow table enable it
		COrcaTable *pTable = pFrame->GetCurrentTable();
		if (DoesTransformGetEdit())
			pCmdUI->Enable(!m_bTransformReadOnly && NULL != pTable && !pTable->IsShadow() && (pTable->IsTransformed() != iTransformDrop));
		else
			pCmdUI->Enable(!m_bReadOnly && NULL != pTable && !pTable->IsShadow());

	}
}

void COrcaDoc::OnUpdateValidator(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateMergeMod(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateSummaryInformation(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

void COrcaDoc::OnUpdateTablesExport(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_eiType != iDocNone);
}

///////////////////////////////////////////////////////////
// BuildTableList
// populate the table list with all tables in the orinigal database or
// the transformed database.
UINT COrcaDoc::BuildTableList(bool fAllowLazyDataLoad)
{
	ASSERT(m_hDatabase);
	ASSERT(iDocDatabase == m_eiType);

	// get all the table names
	CQuery queryTables;
	if (ERROR_SUCCESS != queryTables.Open(GetOriginalDatabase(), _T("SELECT `Name` FROM `_Tables`")))
		return ERROR_FUNCTION_FAILED;
	if (ERROR_SUCCESS != queryTables.Execute())
		return ERROR_FUNCTION_FAILED;

	COrcaTable* pTable = NULL;
	CString strTable;

	// this query is used to see if an existing table has been dropped from the opposing database.
	CQuery qDroppedTable;
	if (m_hTransformDB)
	{
		if (ERROR_SUCCESS != qDroppedTable.Open(m_hTransformDB, _T("SELECT `Name` FROM `_Tables` WHERE `Name`=?")))
			return ERROR_FUNCTION_FAILED;
	}
	
	PMSIHANDLE hTable;
	UINT iResult = ERROR_SUCCESS;
	do
	{
		iResult = queryTables.Fetch(&hTable);

		if (ERROR_SUCCESS == iResult)
		{
			// get the table name
			DWORD cchBuffer = 256 * sizeof(TCHAR);
			MsiRecordGetString(hTable, 1, strTable.GetBuffer(cchBuffer), &cchBuffer);
			strTable.ReleaseBuffer();
			
			pTable = CreateAndLoadTable(GetOriginalDatabase(), strTable);
			ASSERT(pTable);
			if (!pTable)
				continue;

			// check to see if the table has been dropped (incompatible schema changes will be
			// handled when the new schema is loaded
			if (m_hTransformDB)
			{
				PMSIHANDLE hRec = MsiCreateRecord(1);
				MsiRecordSetString(hRec, 1, strTable);
				if (ERROR_SUCCESS != qDroppedTable.Execute(hRec))
					return ERROR_FUNCTION_FAILED;

				switch (qDroppedTable.Fetch(&hRec))
				{
				case ERROR_SUCCESS:
					// table exists in the transformed DB, so was not dropped
					break;
				case ERROR_NO_MORE_ITEMS:
					// table does not exist
					pTable->Transform(iTransformDrop);
					break;
				default:
					return ERROR_FUNCTION_FAILED;
				}
			}			
		}
		else if (ERROR_NO_MORE_ITEMS != iResult)
		{
			break;
		}
	} while (hTable);

	// if no more items that's okay
	if (ERROR_NO_MORE_ITEMS == iResult)
		iResult = ERROR_SUCCESS;
	else
	{
		CString strPrompt;
		strPrompt.Format(_T("MSI Error %d while retrieving tables from the database."), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		return ERROR_FUNCTION_FAILED;
	}

	// next check the transformed database for tables that are not in the original database
	if (m_hTransformDB)
	{
		if (ERROR_SUCCESS != queryTables.Open(m_hTransformDB, _T("SELECT `Name` FROM `_Tables`")))
			return ERROR_FUNCTION_FAILED;
		if (ERROR_SUCCESS != queryTables.Execute())
			return ERROR_FUNCTION_FAILED;
		do
		{
			iResult = queryTables.Fetch(&hTable);

			if (ERROR_SUCCESS == iResult)
			{
				// get the table name
				iResult = RecordGetString(hTable, 1, strTable);
				if (ERROR_SUCCESS != iResult)
				{
					CString strPrompt;
					strPrompt.Format(_T("MSI Error %d while retrieving table names from the transformed database."), iResult);
					AfxMessageBox(strPrompt, MB_ICONSTOP);
					return ERROR_FUNCTION_FAILED;
				}

				// search for an existing table object. If one doesn't exist, load
				// this table into a new object (possibly replacing shadow)
				if (NULL == (pTable = FindTable(strTable, odlSplitOriginal)))
				{
					pTable = CreateAndLoadTable(GetTransformedDatabase(), strTable);
					if (!pTable)
					{
						CString strPrompt;
						strPrompt.Format(_T("Error loading the %s table from the transformed database."), strTable);
						AfxMessageBox(strPrompt, MB_ICONSTOP);
						return ERROR_FUNCTION_FAILED;
					}
					pTable->Transform(iTransformAdd);
				}
				else
				{				
					// if an existing table of the same name already exists, we have to check the 
					// transformed database schema to determine if we can share the existing object
					// across both databases. If so, we can just add the colums, otherwise
					// we need to create a new object.
					bool fExact = false;
					if (pTable->IsSchemaDifferent(GetTransformedDatabase(), /*fStrict=*/false, fExact))
					{
						pTable->SetSplitSource(odlSplitOriginal);
						pTable->Transform(iTransformDrop);
						
						COrcaTable *pNewTable = CreateAndLoadTable(GetTransformedDatabase(), strTable);
						if (!pNewTable)
							return ERROR_OUTOFMEMORY;
						pNewTable->SetSplitSource(odlSplitTransformed);
						pNewTable->Transform(iTransformAdd);
					}
					else
					{
						// object can be shared. Only need to reload the schema if its not exactly the same
						if (!fExact)
							pTable->LoadTableSchema(GetTransformedDatabase(), strTable);
					}
				}
			}
			else if (ERROR_NO_MORE_ITEMS != iResult)
			{
				break;
			}
		} while (ERROR_SUCCESS == iResult);
    
		// if no more items that's okay
		if (ERROR_NO_MORE_ITEMS == iResult)
		{
			iResult = ERROR_SUCCESS;
		}
		else
		{
			CString strPrompt;
			strPrompt.Format(_T("MSI Error %d while retrieving tables from the transformed database."), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return ERROR_FUNCTION_FAILED;
		}
	}

	// for lazy-loads we can retrieve the table transform state
	// if no lazy data load or if lazy-load failed, retrieve all data
	if (!fAllowLazyDataLoad)
	{
		COrcaTable* pTable = NULL;
		POSITION pos = m_tableList.GetHeadPosition();
		while (pos)
		{
			pTable = m_tableList.GetNext(pos);

			if (pTable)
				pTable->RetrieveTableData();
		}
	}

	return iResult;
}	// end of BuildTableList

///////////////////////////////////////////////////////////
// DestroyTableList
void COrcaDoc::DestroyTableList()
{
	// empty out table list
	while (!m_tableList.IsEmpty())
	{
		COrcaTable* pTable = m_tableList.RemoveHead();
		if (pTable)
			pTable->DestroyTable();
		delete pTable;
	}

	// reset the status bar
	CMainFrame* pFrame = (CMainFrame*) AfxGetMainWnd();
	if (pFrame)
		pFrame->ResetStatusBar();
}	// end of DestroyTableList

///////////////////////////////////////////////////////////
// LoadTable
// loads the column definitions of a table from the database
// if a shadow table exists with the same name, clobber it
// with the new data and refresh the view of this table.
COrcaTable* COrcaDoc::CreateAndLoadTable(MSIHANDLE hDatabase, CString strTable)
{
	// if we have a shadow table with the same name, use it
	bool fWasShadow = false;
	COrcaTable* pTable = FindAndRetrieveTable(strTable);
	if (pTable)
	{
		fWasShadow = true;
		ASSERT(pTable->IsShadow());
	}
	else
	{
		pTable = new COrcaTable(this);
		if (!pTable)
			return NULL;
		m_tableList.AddTail(pTable);	
	}
	ASSERT(pTable);
	pTable->LoadTableSchema(hDatabase, strTable);

	if (fWasShadow)
		UpdateAllViews(NULL, HINT_TABLE_REDEFINE, pTable);
	return pTable;
}	// end of LoadTable

///////////////////////////////////////////////////////////
// DropTable
UINT COrcaDoc::DropOrcaTable(COrcaTable* pTable)
{
	ASSERT(!TargetIsReadOnly());
	// drop the table from the database
	return pTable->DropTable(m_hDatabase);
}	// end of DropTable

///////////////////////////////////////////////////////////
// AddRow
UINT COrcaDoc::AddRow(COrcaTable* pTable, CStringList* pstrDataList)
{
	ASSERT(pTable && pstrDataList);
	if (!pTable || !pstrDataList)
		return ERROR_FUNCTION_FAILED;

	ASSERT(!TargetIsReadOnly());

	return pTable->AddRow(pstrDataList);
}	// end of AddRow

///////////////////////////////////////////////////////////
// DropRow
bool COrcaDoc::DropRow(COrcaTable* pTable, COrcaRow* pRow)
{
	ASSERT(pTable);
	if (!pTable)
		return false;
	if (TargetIsReadOnly())
		return false;

	return pTable->DropRow(pRow, true);
}	// end of DropRow

UINT COrcaDoc::WriteBinaryCellToFile(COrcaTable* pTable, COrcaRow* pRow, UINT iCol, CString strFile)
{
	UINT iResult;
	ASSERT(pRow && pTable);
	
	// get the data item we're working with
	COrcaData* pData = pRow->GetData(iCol);
	if (!pData)
		return ERROR_FUNCTION_FAILED;

	// if its null, do nothing
	if (pData->IsNull())
		return ERROR_SUCCESS;

	// setup the query
	CString strQuery;
	strQuery.Format(_T("SELECT * FROM `%s` WHERE "), pTable->Name());

	// add the key strings to queyr to do the exact look up
	strQuery += pTable->GetRowWhereClause();

	// get the one row out of the database
	CQuery queryReplace;
	PMSIHANDLE hQueryRec = pRow->GetRowQueryRecord();
	if (ERROR_SUCCESS != (iResult = queryReplace.OpenExecute(GetTargetDatabase(), hQueryRec, strQuery)))
		return iResult;	
	// we have to get that one row, or something is very wrong
	PMSIHANDLE hRec;
	if (ERROR_SUCCESS != (iResult = queryReplace.Fetch(&hRec)))
		return iResult;	
	
	// don't use iCol+1, because WriteStreamToFile already does
	iResult = WriteStreamToFile(hRec, iCol, strFile) ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;

	return iResult;
}	// end of WriteBinaryCellToFile

///////////////////////////////////////////////////////////////////////
// PersistTables - save the database in hSource to hPersist. hSource
// can be the same as hPersist. bCommit of true will call MsiDBCommit 
// after any necessary updates.
UINT COrcaDoc::PersistTables(MSIHANDLE hPersist, MSIHANDLE hSource, bool bCommit)
{
	bool bSame = false;
	UINT iResult = ERROR_SUCCESS;

	if (m_hDatabase == hPersist)
		bSame = true;

	if (!bSame)
	{
		if (ERROR_SUCCESS != MsiDatabaseMerge(hPersist, hSource, NULL))
		{
			return ERROR_FUNCTION_FAILED;
		}
		
		// copy the summaryinfo stream
		CQuery qRead;
		PMSIHANDLE hCopyRec;
		iResult = qRead.FetchOnce(hSource, 0, &hCopyRec, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'"));
		if (ERROR_SUCCESS == iResult)
		{
			CQuery qInsert;
			if ((ERROR_SUCCESS != qInsert.OpenExecute(hPersist, 0, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'"))) ||
				(ERROR_SUCCESS != qInsert.Modify(MSIMODIFY_INSERT, hCopyRec)))
			{
				return ERROR_FUNCTION_FAILED;
			}
		}
		else if (ERROR_NO_MORE_ITEMS == iResult)
		{
			// SummaryInfo stream may not exist, but this is OK if doing a "save as", because
			// we can generate one from the current summary info variables.
			if (hSource == m_hDatabase)
				iResult = ERROR_SUCCESS;
		}
	}

	// if no errors write the summary information
	if (ERROR_SUCCESS == iResult && hSource == m_hDatabase)
	{
		iResult = PersistSummary(hPersist, !bSame);
	}

	// if no errors save the database
	if (bCommit && ERROR_SUCCESS == iResult)
	{
		iResult = MsiDatabaseCommit(hPersist);
	}

	return iResult;
}	// end of PersistTables


/////////////////////////////////////////////////////////////////////
// ReadSummary
UINT COrcaDoc::ReadSummary(MSIHANDLE hSource)
{
	UINT iResult;

	// get the summary information streams
	PMSIHANDLE hSummary;
	if (ERROR_SUCCESS != (iResult = ::MsiGetSummaryInformation(hSource, NULL, 0, &hSummary)))
		return iResult;
	
	UINT iType;
	TCHAR szBuffer[1024];
	DWORD cchBuffer = 1024;

	// fill in the module summary information
	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_TITLE, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strTitle = _T("");
	else
		m_strTitle = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_SUBJECT, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strSubject = _T("");
	else
		m_strSubject = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_AUTHOR, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strAuthor = _T("");
	else
		m_strAuthor = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_KEYWORDS, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strKeywords = _T("");
	else
		m_strKeywords = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_COMMENTS, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strComments = _T("");
	else
		m_strComments = szBuffer;

	// set the platform and language
	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_TEMPLATE, &iType, 0, NULL, szBuffer, &cchBuffer);
	CString strLanguage = szBuffer;
	if (VT_LPSTR != iType)
	{
			m_strPlatform = _T("");
			m_strLanguage = _T("");
	}
	else	// type is right
	{
		int nFind = strLanguage.Find(_T(";"));
		if (nFind > -1)
		{
			m_strPlatform = strLanguage.Left(nFind);
			m_strLanguage = strLanguage.Mid(nFind + 1);
		}
		else
		{
			m_strPlatform = _T("");
			m_strLanguage = _T("");
		}
	}

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_LASTAUTHOR, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strLastSaved = _T("");
	else
		m_strLastSaved = szBuffer;

	cchBuffer = 1024;
	MsiSummaryInfoGetProperty(hSummary, PID_REVNUMBER, &iType, 0, NULL, szBuffer, &cchBuffer);
	if (VT_LPSTR != iType)
		m_strProductGUID = _T("");
	else
		m_strProductGUID = szBuffer;

	MsiSummaryInfoGetProperty(hSummary, PID_PAGECOUNT, &iType, &m_nSchema, NULL, szBuffer, &cchBuffer);
	if (VT_I4 != iType)
		m_nSchema = 100;

	MsiSummaryInfoGetProperty(hSummary, PID_WORDCOUNT, &iType, &m_nFilenameType, NULL, szBuffer, &cchBuffer);
	if (VT_I4 != iType)
		m_nFilenameType = 0;

	MsiSummaryInfoGetProperty(hSummary, PID_SECURITY, &iType, &m_nSecurity, NULL, szBuffer, &cchBuffer);
	if (VT_I4 != iType)
		m_nSecurity = 1;

	return iResult;
}	// end of ReadSummary

/////////////////////////////////////////////////////////////////////
// PersistSummary
UINT COrcaDoc::PersistSummary(MSIHANDLE hTarget, bool bCreate)
{
	UINT iResult;

	// get the summary information streams
	PMSIHANDLE hSummary;
	if (ERROR_SUCCESS != (iResult = ::MsiGetSummaryInformation(hTarget, NULL, MAX_SUMMARY, &hSummary)))
		return iResult;
	
	FILETIME filetime;
	DWORD cchBufDiscard = 1024;

	// fill in the module summary information
	MsiSummaryInfoSetProperty(hSummary, PID_TITLE,		VT_LPSTR, 0, NULL, m_strTitle);
	MsiSummaryInfoSetProperty(hSummary, PID_SUBJECT,	VT_LPSTR, 0, NULL, m_strSubject);
	MsiSummaryInfoSetProperty(hSummary, PID_AUTHOR,		VT_LPSTR, 0, NULL, m_strAuthor);
	MsiSummaryInfoSetProperty(hSummary, PID_KEYWORDS,	VT_LPSTR, 0, NULL, m_strKeywords);
	MsiSummaryInfoSetProperty(hSummary, PID_COMMENTS,	VT_LPSTR, 0, NULL, m_strComments);

	// set the platform and language
	CString strLanguage;
	strLanguage.Format(_T("%s;%s"), m_strPlatform, m_strLanguage);
	MsiSummaryInfoSetProperty(hSummary, PID_TEMPLATE,	VT_LPSTR, 0, NULL, strLanguage);

	// get the current username for summaryinfo stream
	DWORD cchUserName = 255;
	LPTSTR szUserName = m_strLastSaved.GetBuffer(cchUserName);
	GetUserName(szUserName, &cchUserName);
	m_strLastSaved.ReleaseBuffer();
	MsiSummaryInfoSetProperty(hSummary, PID_LASTAUTHOR, VT_LPSTR, 0, NULL, m_strLastSaved);
	MsiSummaryInfoSetProperty(hSummary, PID_REVNUMBER,	VT_LPSTR, 0, NULL, m_strProductGUID);

	// get the current time and set the creation and last saved time to that
	SYSTEMTIME sysTime;
	GetSystemTime(&sysTime);
	SystemTimeToFileTime(&sysTime, &filetime);
	if (bCreate) 
	{
		// only write these values if we are creating the MSI
		MsiSummaryInfoSetProperty(hSummary, PID_CODEPAGE,	VT_I2, 1252, NULL, NULL);
		MsiSummaryInfoSetProperty(hSummary, PID_LASTPRINTED,	VT_FILETIME, 0, &filetime, NULL);
		MsiSummaryInfoSetProperty(hSummary, PID_CREATE_DTM,		VT_FILETIME, 0, &filetime, NULL);
		MsiSummaryInfoSetProperty(hSummary, PID_APPNAME, VT_LPSTR, 0, NULL, _T("Windows Installer"));
	}

	MsiSummaryInfoSetProperty(hSummary, PID_LASTSAVE_DTM,	VT_FILETIME, 0, &filetime, NULL);

	MsiSummaryInfoSetProperty(hSummary, PID_PAGECOUNT,	VT_I4, m_nSchema, NULL, NULL);

	MsiSummaryInfoSetProperty(hSummary, PID_WORDCOUNT, VT_I4, m_nFilenameType, NULL, NULL);
	MsiSummaryInfoSetProperty(hSummary, PID_SECURITY, VT_I4, m_nSecurity, NULL, NULL);

	iResult = ::MsiSummaryInfoPersist(hSummary);

	return iResult;
}	// end of PersistSummary

/////////////////////////////////////////////////////////////////////
// OnSummaryInformation
void COrcaDoc::OnSummaryInformation() 
{
	CSummaryD dlg;

	dlg.m_strTitle = m_strTitle;
	dlg.m_strSubject = m_strSubject;
	dlg.m_strAuthor = m_strAuthor;
	dlg.m_strKeywords = m_strKeywords;
	dlg.m_strComments = m_strComments;
	dlg.m_strPlatform = m_strPlatform;
	dlg.m_strLanguages = m_strLanguage;
	dlg.m_strProductID = m_strProductGUID;
	dlg.m_nSchema = m_nSchema;
	dlg.m_nSecurity = m_nSecurity;
	dlg.m_iFilenames = ((m_nFilenameType & msidbSumInfoSourceTypeSFN) != 0) ? 0 : 1;
	dlg.m_bAdmin = (m_nFilenameType & msidbSumInfoSourceTypeAdminImage) != 0;
	dlg.m_bCompressed = (m_nFilenameType & msidbSumInfoSourceTypeCompressed) != 0;
	dlg.m_bReadOnly = DoesTransformGetEdit() || TargetIsReadOnly();
        
	if ((IDOK == dlg.DoModal()) && !m_bReadOnly && !DoesTransformGetEdit())
	{
		m_strTitle = dlg.m_strTitle;
		m_strSubject = dlg.m_strSubject;
		m_strAuthor = dlg.m_strAuthor;
		m_strKeywords = dlg.m_strKeywords;
		m_strComments = dlg.m_strComments;
		m_strPlatform = dlg.m_strPlatform;
		m_strLanguage = dlg.m_strLanguages;
		m_strProductGUID = dlg.m_strProductID;
		m_nSchema = dlg.m_nSchema;
		m_nSecurity = dlg.m_nSecurity;
		m_nFilenameType = (dlg.m_bAdmin ? msidbSumInfoSourceTypeAdminImage : 0) |
			(dlg.m_bCompressed ? msidbSumInfoSourceTypeCompressed : 0) |
			((dlg.m_iFilenames == 1) ? 0 : msidbSumInfoSourceTypeSFN); 

		// don't save the create-only values
		PersistSummary(m_hDatabase, false);
		SetModifiedFlag(TRUE);
	}
}	// end of OnSummaryInformation


/////////////////////////////////////////////////////////////////////
// OnMergeModules
void COrcaDoc::OnMergeMod() 
{
	CMergeD dlg;
	CStringList lstDir;
	dlg.m_plistDirectory = &lstDir;
	COrcaTable* pTable = FindAndRetrieveTable(TEXT("Directory"));
	if (pTable)
	{
		POSITION pos = pTable->GetRowHeadPosition();
		while (pos)
		{
			const COrcaRow *pRow = pTable->GetNextRow(pos);
			if (pRow)
			{
				COrcaData *pData = pRow->GetData(0);
				if (pData)
					lstDir.AddTail(pData->GetString());
			}
		}
	}

	CStringList lstFeature;
	dlg.m_plistFeature = &lstFeature;
	pTable = FindAndRetrieveTable(TEXT("Feature"));
	if (pTable)
	{
		POSITION pos = pTable->GetRowHeadPosition();
		while (pos)
		{
			const COrcaRow *pRow = pTable->GetNextRow(pos);
			if (pRow)
			{
				COrcaData *pData = pRow->GetData(0);
				if (pData)
					lstFeature.AddTail(pData->GetString());
			}
		}
	}

	dlg.m_strModule = m_strStoredModuleName;
	dlg.m_strLanguage = m_strStoredModuleLanguage;
	dlg.m_bConfigureModule = (1 == AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("AlwaysConfigure"), 0));

	if ((IDOK == dlg.DoModal()) && !TargetIsReadOnly())
	{
		if (dlg.m_strModule.IsEmpty())
			return;

		m_strStoredModuleName = dlg.m_strModule;
		m_strStoredModuleLanguage = dlg.m_strLanguage;
		CConfigMsmD dlgConfig;
		CMsmConfigCallback CallbackObj;
		if (dlg.m_bConfigureModule)
		{
			// need a wait cursr
			CWaitCursor cursor;
			
			// throw the configurable dialog if necessary
			dlgConfig.m_pDoc = this;
			dlgConfig.m_strModule = dlg.m_strModule;
			dlgConfig.m_pCallback = &CallbackObj;

			dlgConfig.m_iLanguage = _ttoi(dlg.m_strLanguage);
			INT_PTR iResult = IDOK;
			switch (iResult = dlgConfig.DoModal())
			{
			case -2:
				// module couldn't be opened
				AfxMessageBox(_T("The specified module could not be opened. Verify that the file exists and is accessible."), MB_OK);
				break;
			case -3:
				// unsupported language
				AfxMessageBox(_T("The specified language is not supported by the module."), MB_OK);
				break;
			case -4:
				// general failure/malformed module
				AfxMessageBox(_T("The module could not be configured. The specified file may not be a valid module."), MB_OK);
				break;
			default:
				break;
				// success and other failures, no message box
			}
			if (IDOK != iResult)
				return;
		}

		{
			// need a wait cursr
			CWaitCursor cursor;
			
			// when a module is merged, we have to have a temp database to apply the module to.
			// This allows Orca to "rollback" the merge if there are conflicts or something goes
			// wrong during the merge itself
			// get a temp path
			DWORD cchTempPath = MAX_PATH;
			TCHAR szTempPath[MAX_PATH];
			::GetTempPath(cchTempPath, szTempPath);

			// get a temp filename
			CString strTempDatabase;
			TCHAR *szTempFilename = strTempDatabase.GetBuffer(MAX_PATH);
			UINT iResult = ::GetTempFileName(szTempPath, _T("ODB"), 0, szTempFilename);
			strTempDatabase.ReleaseBuffer();

			PMSIHANDLE hModuleDB;
			if (ERROR_SUCCESS != MsiOpenDatabase(szTempFilename, MSIDBOPEN_CREATEDIRECT, &hModuleDB))
			{
				AfxMessageBox(_T("Orca was unable to create a database for merging the module. Ensure that the TEMP directory exists and is writable."), MB_ICONSTOP);
				return;
			}
			if (ERROR_SUCCESS != MsiDatabaseMerge(hModuleDB, GetTargetDatabase(), NULL))
			{
				AfxMessageBox(_T("Orca was unable to merge the module."), MB_ICONSTOP);
				MsiCloseHandle(hModuleDB);
				hModuleDB=0;
				DeleteFile(strTempDatabase);
				return;
			}

			// copy the summary information stream to the new database
			{
				CQuery qRead;
				PMSIHANDLE hCopyRec;
				if (ERROR_SUCCESS == qRead.FetchOnce(GetTargetDatabase(), 0, &hCopyRec, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'")))
				{
					CQuery qInsert;
					if (ERROR_SUCCESS == qInsert.OpenExecute(hModuleDB, 0, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'")))
						qInsert.Modify(MSIMODIFY_INSERT, hCopyRec);
				}
			}
			
			CString strHandleString;
			strHandleString.Format(TEXT("#%d"), hModuleDB);

			// can't watch the merge log on Win9X due to lack of pipe support.
			OSVERSIONINFOA osviVersion;
			bool g_fWin9X = false;
			osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
			::GetVersionExA(&osviVersion); // fails only if size set wrong
			if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
				g_fWin9X = true;

			// if the users profile says to display the log output, the ExecuteMerge call comes from
			// a thread inside the dialog with the log file redirected to a pipe. Otherwise the dialog
			// is not created and ExecuteMerge is called directly.
			if (!g_fWin9X && 1 == AfxGetApp()->GetProfileInt(_T("MergeMod"),_T("ShowMergeLog"), 0))
			{
				CMsmResD ResultsDialog;
				ResultsDialog.strHandleString = strHandleString;
				ResultsDialog.m_strModule = dlg.m_strModule;
				ResultsDialog.m_strFeature = dlg.m_strMainFeature +	dlg.m_strAddFeature;
				ResultsDialog.m_strLanguage = dlg.m_strLanguage;
				ResultsDialog.m_strRootDir = dlg.m_strRootDir;
				ResultsDialog.m_strCABPath = dlg.m_bExtractCAB ? dlg.m_strCABPath : "";
				ResultsDialog.m_strFilePath = dlg.m_bExtractFiles ? dlg.m_strFilePath : "";
				ResultsDialog.m_strImagePath = dlg.m_bExtractImage ? dlg.m_strImagePath : "";
				ResultsDialog.m_fLFN = (dlg.m_bLFN != 0);
				ResultsDialog.CallbackObj = &CallbackObj;
				if (IDOK == ResultsDialog.DoModal())
					iResult = ResultsDialog.m_hRes;
				else
					iResult = ERROR_FUNCTION_FAILED;
			}
			else
			{
				CMsmFailD FailDialog;
				iResult = ::ExecuteMerge(
					(LPMERGEDISPLAY)NULL,        // no log callback
					strHandleString,             // db handle as string
					dlg.m_strModule,             // module path
					dlg.m_strMainFeature +       // primary feature 
						dlg.m_strAddFeature,     //   + additional features
					_ttoi(dlg.m_strLanguage),    // language
					dlg.m_strRootDir,            // redirection directory
					dlg.m_bExtractCAB ? 
						dlg.m_strCABPath : "",   // extract CAB path
					dlg.m_bExtractFiles ? 
						dlg.m_strFilePath : "",  // extract file path
					dlg.m_bExtractImage ? 
						dlg.m_strImagePath : "", // extract image path
					NULL,                        // no log file path
					false,						 // log option is irrelevant with no log
					dlg.m_bLFN != 0,             // long file names
					&CallbackObj,                // callback interface,
					&FailDialog.m_piErrors,      // errors collection
					commitNo);                   // don't auto-save
				if (iResult != S_OK)
					iResult = (IDOK == FailDialog.DoModal()) ? S_OK : E_FAIL;
			}

			if (S_OK == iResult || S_FALSE == iResult)
			{
				// need a wait cursr
				CWaitCursor cursor;
				
				// get the name of the current table
				CString strTableName;
				CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
				if (pFrame) 
				{
					COrcaTable *pTable = pFrame->GetCurrentTable();
					if (pTable)
						strTableName = pTable->Name();
				}
				
				// clear anything existing
				UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);
				((CMainFrame*)AfxGetMainWnd())->HideValPane();
				UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
				UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

				// drop all of the tables. If the merge changed any existing rows,
				// we'll get a merge conflict if we try to merge without dropping the table
				// first
				POSITION pos = m_tableList.GetHeadPosition();
				while (pos)
				{
					COrcaTable *pTable = m_tableList.GetNext(pos);
					if (pTable)
						pTable->DropTable(GetTargetDatabase());
				}

				DestroyTableList();
				
				if (ERROR_SUCCESS != MsiDatabaseMerge(GetTargetDatabase(), hModuleDB, NULL))
				{
					// this is very, very bad.
					AfxMessageBox(_T("Orca was unable to merge the module."), MB_ICONSTOP);
					MsiCloseHandle(hModuleDB);
					hModuleDB=0;
					DeleteFile(strTempDatabase);
					return;
				}

				BuildTableList(/*fAllowLazyLoad=*/false);
				UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);
				SetModifiedFlag(TRUE);

				if (!strTableName.IsEmpty())
				{
					// since we're changing to this table, we can call FindAndRetrieve without
					// sacrificing performance (and we don't need to know what DB is active)
					COrcaTable *pTable = FindAndRetrieveTable(strTableName);
					if (pTable)
						UpdateAllViews(NULL, HINT_CHANGE_TABLE, pTable);
				}			
			}
			
			::MsiCloseHandle(hModuleDB);
			DeleteFile(strTempDatabase);
		}
	}
	
}	// end of OnMergeMod

/////////////////////////////////////////////////////////////////////
// OnSummaryInformation
void COrcaDoc::OnTransformProperties() 
{
	CTransformPropDlg dlg;
	dlg.m_bValAddExistingRow   = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_ADDEXISTINGROW) ? TRUE : FALSE;
	dlg.m_bValAddExistingTable = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_ADDEXISTINGTABLE) ? TRUE : FALSE;
	dlg.m_bValDelMissingRow    = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_DELMISSINGROW) ? TRUE : FALSE;
	dlg.m_bValDelMissingTable  = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_DELMISSINGTABLE) ? TRUE : FALSE;
	dlg.m_bValUpdateMissingRow = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_UPDATEMISSINGROW) ? TRUE : FALSE;
	dlg.m_bValChangeCodepage   = (m_dwTransformErrFlags & MSITRANSFORM_ERROR_CHANGECODEPAGE) ? TRUE : FALSE;

	dlg.m_bValLanguage     = (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_LANGUAGE) ? TRUE : FALSE;
	dlg.m_bValProductCode  = (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_PRODUCT) ? TRUE : FALSE;
	dlg.m_bValUpgradeCode  = (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_UPGRADECODE) ? TRUE : FALSE;

	if (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_MAJORVERSION)
		dlg.m_iVersionCheck = 0;
	else if (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_MINORVERSION)
		dlg.m_iVersionCheck = 1;
	else if (m_dwTransformValFlags & MSITRANSFORM_VALIDATE_UPDATEVERSION)
		dlg.m_iVersionCheck = 2;
		
	dlg.m_bValGreaterVersion = (m_dwTransformValFlags & (MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION)) ? TRUE : FALSE;
	dlg.m_bValLowerVersion = (m_dwTransformValFlags & (MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION)) ? TRUE : FALSE;
	dlg.m_bValEqualVersion = (m_dwTransformValFlags & (MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION | MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION)) ? TRUE : FALSE;

	if ((IDOK == dlg.DoModal()) && !m_bTransformReadOnly)
	{
		m_dwTransformErrFlags = 0;
		if (dlg.m_bValAddExistingRow)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_ADDEXISTINGROW;
		if (dlg.m_bValAddExistingTable)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_ADDEXISTINGTABLE;
		if (dlg.m_bValDelMissingRow)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_DELMISSINGROW;
		if (dlg.m_bValDelMissingTable)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_DELMISSINGTABLE;
		if (dlg.m_bValUpdateMissingRow)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_UPDATEMISSINGROW;
		if (dlg.m_bValChangeCodepage)
			m_dwTransformErrFlags |= MSITRANSFORM_ERROR_CHANGECODEPAGE;

		m_dwTransformValFlags = 0;
		if (dlg.m_bValLanguage)
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_LANGUAGE;
		if (dlg.m_bValProductCode)
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_PRODUCT;
		if (dlg.m_bValUpgradeCode)
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_UPGRADECODE;

		switch (dlg.m_iVersionCheck)
		{
		case 0: 
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_MAJORVERSION;
			break;
		case 1:
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_MINORVERSION;
			break;
		case 2:
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_UPDATEVERSION;
			break;
		default:
			break;
		}
		
		if (dlg.m_bValGreaterVersion)
		{
			if (dlg.m_bValEqualVersion)
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION;
			else
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION;
		}		
		else if (dlg.m_bValLowerVersion)
		{
 			if (dlg.m_bValEqualVersion)
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION;
			else
				m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION;
		}
		else if (dlg.m_bValEqualVersion)
			m_dwTransformValFlags |= MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION;
	}
}	// end of OnTransformProperties

/////////////////////////////////////////////////////////////////////
// OnValidator
void COrcaDoc::OnValidator() 
{
	bool bSummWarned = false;
	CValD dlg;
	dlg.m_hDatabase = GetTargetDatabase();
	dlg.m_strICE = m_strICEsToRun;
	dlg.m_strEvaluation = m_strCUBFile;
	dlg.m_bShowInfo = m_bShowValInfo;

	dlg.DoModal();
	m_strICEsToRun = dlg.m_strICE;
	m_strCUBFile = dlg.m_strEvaluation;
	m_bShowValInfo = (dlg.m_bShowInfo ? true : false);
	CWaitCursor curWait;
	// clear out the old errors
	POSITION pos = m_tableList.GetHeadPosition();
	while (pos)
	{
		POSITION pos2 = pos;
		COrcaTable *pTable = m_tableList.GetNext(pos);
		if (pTable->IsShadow())
		{
			UpdateAllViews(NULL, HINT_DROP_TABLE, pTable);
			m_tableList.RemoveAt(pos2);
			delete pTable;
		}
		else
		{
			pTable->ClearErrors();
		}

	}
	UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);

	// if there are any results
	if (dlg.m_pIResults)
	{
		RESULTTYPES tResult;			// type of result
		LPOLESTR rgErrorInfo[3];	// array to hold error information
		CString strICE;				// ice causing error
		CString strDescription;		// description of error
		CString strURL;				// url to help with error
		LPOLESTR rgErrorLoc[2];		// array to hold error location
		CString strColumn;			// column causing error
		CString strTable;				// table causing error
		IEnumString* pIErrors;

		// loop through all the results
		ULONG cFetched;
		IEvalResult* pIResult;
		for (ULONG i = 0; i < dlg.m_cResults; i++)
		{
			// get the next result
			dlg.m_pIResults->Next(1, &pIResult, &cFetched);
			ASSERT(1 == cFetched);	// insure we fetched one result

			// determine result type
			pIResult->GetResultType((UINT*)&tResult);

			// get the string of errors
			pIResult->GetResult(&pIErrors);

			// get the ICE and Description and URL
			pIErrors->Next(3, rgErrorInfo, &cFetched);

			// if we cannot fetch a full error result
			if (cFetched < 2)
			{
				continue;
			}

#ifndef _UNICODE
			// convert the ice string
			int cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[0], -1, NULL, 0, NULL, NULL);
			::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[0], -1, strICE.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
			strICE.ReleaseBuffer();
			// now convert the description string
			cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[1], -1, NULL, 0, NULL, NULL);
			::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[1], -1, strDescription.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
			strDescription.ReleaseBuffer();
#else
			strICE = rgErrorInfo[0];
			strDescription = rgErrorInfo[1];
#endif

			// if at least the ICE and description are valid, we can add something
			// to the pane
			if (2 == cFetched)
			{
				// anything other than an info message gets logged in the pane
				if (tResult != ieInfo)
				{
					CValidationError pError(&strICE, tResult, &strDescription, NULL, NULL, 0);
					UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
				}
				continue;
			}

#ifndef _UNICODE
			// now convert the URL string
			cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[2], -1, NULL, 0, NULL, NULL);
			::WideCharToMultiByte(CP_ACP, 0, rgErrorInfo[2], -1, strURL.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
			strURL.ReleaseBuffer();
#else
			strURL = rgErrorInfo[2];
#endif

			// if this is an error message or warning message
			if (ieError == tResult || ieWarning == tResult)
			{
				TRACE(_T("-- Error, ICE: %s, Desc: %s, URL: %s\n"), strICE, strDescription, strURL);

				// get the Table and Column
				pIErrors->Next(2, rgErrorLoc, &cFetched);

				// if we fetched table and column
				if (2 == cFetched)
				{
#ifndef _UNICODE
					// convert the table string
					cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[0], -1, NULL, 0, NULL, NULL);
					::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[0], -1, strTable.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
					strTable.ReleaseBuffer();
					// convert the column string
					int cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[1], -1, NULL, 0, NULL, NULL);
					::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[1], -1, strColumn.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
					strColumn.ReleaseBuffer();
#else
					strTable= rgErrorLoc[0];
					strColumn = rgErrorLoc[1];
#endif
					// if the table name is an empty string, there is no point in adding a table to the DB
					// with no name. The UI for that is just confusing.
					if (strTable.IsEmpty())
						continue;

					CStringArray strArray;
					BOOL bCheck = FALSE;	// assume we won't check

					// get the table, shadow tables OK, split tables must match current edit
					// state.
					COrcaTable* pTable = FindAndRetrieveTable(strTable);
					if (!pTable)
					{
						// if the table does not exist, create a shadow table to hold this error
						pTable = new COrcaTable(this);
						pTable->ShadowTable(strTable);

						// a table is normally not added to the list until it is first fetched 
						m_tableList.AddTail(pTable);	
						UpdateAllViews(NULL, HINT_ADD_TABLE_QUIET, pTable);
					}
					
					if (pTable->IsShadow())
					{
						// add the ICE and description to this table's list of errors
						pTable->SetError(iTableError);
						pTable->AddError(strICE, strDescription, strURL);					
					
						// add to the validation pane
						CValidationError pError(&strICE, tResult, &strDescription, pTable, NULL, 0);
						UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
					}
					else
					{
						// get the number of primary keys in table
						UINT cKeys = pTable->GetKeyCount();
						LPOLESTR szErrorRow;
						strArray.SetSize(cKeys);

						bCheck = TRUE;	// now assume we will do a check

						// get the strings defining the error row into the array
						CString strBuffer;
						for (UINT j = 0; j < cKeys; j++)
						{
							pIErrors->Next(1, &szErrorRow, &cFetched);
							if (1 != cFetched)
							{
								bCheck = FALSE;	// didn't get all the keys needed to find this error
								break;
							}

#ifndef _UNICODE
							// set the array
							cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, szErrorRow, -1, NULL, 0, NULL, NULL);
							::WideCharToMultiByte(CP_ACP, 0, szErrorRow, -1, strBuffer.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
							strBuffer.ReleaseBuffer();
							strArray.SetAt(j, strBuffer);
#else
							strArray.SetAt(j, szErrorRow);
#endif
						}
					}

					if (bCheck)
					{
						// get the data cell that caused the error
						COrcaRow* pRow = pTable->FindRowByKeys(strArray);
						COrcaData* pData = NULL;
						int iColumn = pTable->FindColumnNumberByName(strColumn);

						if (pRow)
							pData = pRow->GetData(iColumn);

						if (pRow && pData)
						{
							pTable->SetContainsValidationErrors(true);
							pData->AddError(tResult, strICE, strDescription, strURL);
							switch (tResult)
							{
							case ieError:
								// always flag errors
								pData->SetError(iDataError);
								break;
							case ieWarning:
								// only flag as warning if no errors
								if (pData->GetError() != iDataError)
									pData->SetError(iDataWarning);
								break;
							default:
								ASSERT(FALSE);
							}

							// add to the validation pane
							CValidationError pError(&strICE, tResult, &strDescription, pTable, pRow, iColumn);
							UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
						}
						else	// ICE didn't give a good row location
						{
							CString strPrompt;
							strPrompt.Format(_T("%s failed to give a valid row in the database.\nDesc: %s\nURL: %s\nColumn: %s\nLocation: "), strICE, strDescription, strURL, strColumn);
							for (int i = 0; i < strArray.GetSize(); i++)
							{
								strPrompt += strArray.GetAt(i);

								if (i + 1 < strArray.GetSize())
									strPrompt += _T(", ");
							}
							AfxMessageBox(strPrompt, MB_ICONSTOP);
						}
					}
				}
				else if (1 == cFetched)	// fetched only the table name
				{
#ifndef _UNICODE
					// convert the column string
					int cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[0], -1, NULL, 0, NULL, NULL);
					::WideCharToMultiByte(CP_ACP, 0, rgErrorLoc[0], -1, strTable.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
					strColumn.ReleaseBuffer();
#else
					strTable= rgErrorLoc[0];
#endif
					// if the table name is an empty string, there is no point in adding a table to the DB
					// with no name. The UI for that is just confusing.
					if (strTable.IsEmpty())
						continue;

					// get the table. Shadow tables OK, split tables must match current state
					COrcaTable* pTable = FindTable(strTable, DoesTransformGetEdit() ? odlSplitTransformed : odlSplitOriginal);
					if (!pTable)
					{
						// if the table does not exist, create a shadow table to hold this error
						pTable = new COrcaTable(this);
						pTable->ShadowTable(strTable);

						// a table is normally not added to the list until it is first fetched 
						m_tableList.AddTail(pTable);	
						UpdateAllViews(NULL, HINT_ADD_TABLE_QUIET, pTable);
					}
					// add the ICE and description to this table's list of errors
					pTable->SetError(iTableError);
					pTable->AddError(strICE, strDescription, strURL);				 

					// and to the validation pane
					CValidationError pError(&strICE, tResult, &strDescription, pTable, NULL, 0);
					UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
				}
				else	// didn't get a full location
				{
					CValidationError pError(&strICE, tResult, &strDescription, NULL, NULL, 0);
					UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
					TRACE(_T("Could not locate the exact position of the error.\n"));
				}
			}
			else if (ieInfo != tResult)
			{
				// anything other than an info message gets logged in the pane
				CValidationError pError(&strICE, tResult, &strDescription, NULL, NULL, 0);
				UpdateAllViews(NULL, HINT_ADD_VALIDATION_ERROR, &pError);
			}
		}

		// just have the views refresh
		((CMainFrame*)AfxGetMainWnd())->ShowValPane();
		UpdateAllViews(NULL, HINT_REDRAW_ALL);
	}
	else
	{
		((CMainFrame*)AfxGetMainWnd())->HideValPane();
	}

}	// end of OnValidator

/////////////////////////////////////////////////////////////////////////
// fills the provided new list with a list of all tables in the target 
// database. Shadow tables are optional.
bool COrcaDoc::FillTableList(CStringList *pslNewList, bool fShadow, bool fTargetOnly) const
{
	ASSERT(pslNewList != NULL);
	ASSERT(fTargetOnly); // don't support getting list from both places yet.

	pslNewList->RemoveAll();

	// add all of the tables currently loaded to the list
	POSITION pos = m_tableList.GetHeadPosition();
	while (pos)
	{
		COrcaTable *pTable = m_tableList.GetNext(pos);
		if (!pTable)
			continue;

		// don't add shadow tables unless asked
		if (!fShadow && pTable->IsShadow()) 
			continue;

		// don't add split source tables from the other database
		if (fTargetOnly && pTable->IsSplitSource() && pTable->GetSplitSource() == (DoesTransformGetEdit() ? odlSplitOriginal : odlSplitTransformed))
			continue;

		// don't add tables that don't actually exist in this database
		if(fTargetOnly && pTable->IsTransformed() == (DoesTransformGetEdit() ? iTransformDrop : iTransformAdd))
			continue;

		pslNewList->AddTail(pTable->Name());
	}

	return true;
}


void COrcaDoc::OnUpdateTablesImport(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(!TargetIsReadOnly() && m_eiType != iDocNone);	
}

void COrcaDoc::OnTablesImport() 
{
	ASSERT(!TargetIsReadOnly());
	CImportDlg ImportD;
	
	// set the import directory
	ImportD.m_strImportDir = ((CMainFrame *)::AfxGetMainWnd())->m_strExportDir;
	ImportD.m_hFinalDB = GetTargetDatabase();

	if (IDOK == ImportD.DoModal())
	{
		CString strTable;
		while (!ImportD.m_lstRefreshTables.IsEmpty())
		{
			strTable = ImportD.m_lstRefreshTables.RemoveHead();
			RefreshTableAfterImport(strTable);
		}

		while (!ImportD.m_lstNewTables.IsEmpty())
		{
			strTable = ImportD.m_lstNewTables.RemoveHead();
			CreateAndLoadNewlyAddedTable(strTable);
		}
		
		// mark document as dirty
		SetModifiedFlag(TRUE);

		// retrieve the import directory
		((CMainFrame *)::AfxGetMainWnd())->m_strExportDir = ImportD.m_strImportDir;
	}

}


/////////////////////////////////////////////////////////////////////////////////////////
// What differentiates a refresh/replace after import from an add after import is the
// posibility that a split table already exists for this table name or that the existing
// shared table has extra columns that are no longer necessary. This function just
// destroys the appropriate table object and then calls the Create function, which does
// all of the fancy schema logic.
void COrcaDoc::RefreshTableAfterImport(CString strTable)
{
	COrcaTable *pTable;

	// because we are replacing an existing database in the table, there are several possibilities:
	// 1) a shared table holds the data and the schema is compatible
	// 2) a shared table holds the data and the schema is not compatible
	// 3) a pair of split tables holds the data and the schema is 

	// check if the table already exists.
	if (NULL != (pTable = FindTable(strTable, DoesTransformGetEdit() ? odlSplitTransformed : odlSplitOriginal))) 
	{
		// table already exists. check if its a single source table
		if (pTable->IsSplitSource())
		{
			// if there is a split table, we simply find the source from this table and 
			// drop it. Must update the views before yanking the data
			//!!future: We should check the schema to see if its exactly the same or is a
			//!!future: superset. If so, we can re-use the object, preserving settings
			POSITION pos = m_tableList.Find(pTable);
			UpdateAllViews(NULL, HINT_DROP_TABLE, pTable);
			m_tableList.RemoveAt(pos);
			pTable->DestroyTable();
			delete pTable;

			// need to find the opposing split table and mark it as non-split
			pTable = FindTable(strTable, odlSplitOriginal);
			ASSERT(pTable);
			if (pTable)
				pTable->SetSplitSource(odlNotSplit);

			// CreateAndLoadNewlyAddedTable will re-split the table if necessary based
			// on schema.
			CreateAndLoadNewlyAddedTable(strTable);
		}
		else
		{
			bool fExact = false;
			// the object must have exactly the same schema as the new table or a schema 
			// reload is necessary
			//!!future: actually, if its not exact but compatible, for perf we can just add
			//!!future: the added column information and then do a UI reload
			if (DoesTransformGetEdit() && pTable->IsSchemaDifferent(GetTargetDatabase(), /*fStrict=*/false, fExact))
			{
				CreateAndLoadNewlyAddedTable(strTable);
			}
			else if (!fExact)
			{
				UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);
				pTable->DestroyTable();
				pTable->LoadTableSchema(GetOriginalDatabase(), strTable);
				pTable->LoadTableSchema(GetTransformedDatabase(), strTable);
				UpdateAllViews(NULL, HINT_CHANGE_TABLE, pTable);
			}
			else
			{
				pTable->EmptyTable();
			}
		}
	}
	else
	{
		// UI doesn't already exist. Because this is an import refresh, this should never happen
		ASSERT(0);
	}
}

///////////////////////////////////////////////////////////////////////
// searches for a table by name. Returns table if found, NULL if not.
// If odlLocation is odlSplitXXXX, the table must lie in that database
// (as that split or as non-split). If odlLocation is odlNotSplit,
// the table must not be split
COrcaTable * COrcaDoc::FindTable(const CString strTable, odlOrcaDataLocation odlLocation) const
{
	COrcaTable* pTable;
	POSITION pos = m_tableList.GetHeadPosition();
	while (pos)
	{
		pTable = m_tableList.GetNext(pos);
		if (!pTable)
			continue;

		if (pTable->Name() == strTable)
		{
			// if table is not split, return it
			if (!pTable->IsSplitSource())
				return pTable;

			// otherwise it must match the type we are requesting
			if (odlLocation == pTable->GetSplitSource())
				return pTable;
		}
	}
	return NULL;
}

///////////////////////////////////////////////////////////
// FindAndRetrieveTable - finds a specific table and loads
// both schema and data into memory
COrcaTable* COrcaDoc::FindAndRetrieveTable(CString strTable)
{
	COrcaTable* pTable = FindTable(strTable, DoesTransformGetEdit() ? odlSplitTransformed : odlSplitOriginal);

	if (pTable != NULL)	
	{
		// if the table is not retrieved, get it
		pTable->RetrieveTableData();
	}

	return pTable;
}	// end of FindAndRetrieveTable


bool COrcaDoc::WriteStreamToFile(MSIHANDLE hRec, const int iCol, CString &strFilename)
{
	CString strPath;

	// 
	if (strFilename.IsEmpty()) 
	{
		// get a temp path
		::GetTempPath(MAX_PATH, strPath.GetBuffer(MAX_PATH));
		strPath.ReleaseBuffer();
		::GetTempFileName(strPath, _T("ORC"), 0, strFilename.GetBuffer(MAX_PATH));
		strFilename.ReleaseBuffer();
	}

	// allocate the buffer to hold data
	DWORD cchBuffer;
	char pszBuffer[1024];

	// create output file
	HANDLE hOutputFile;
	hOutputFile = ::CreateFile(strFilename, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	// if there is a file
	if (INVALID_HANDLE_VALUE != hOutputFile)
	{
		// write to a buffer file
		DWORD cchWritten;

		cchBuffer = 1024;
		if(ERROR_SUCCESS == MsiRecordReadStream(hRec, iCol + 1, pszBuffer, &cchBuffer))
		{
			while (cchBuffer)
			{
				WriteFile(hOutputFile, pszBuffer, cchBuffer, &cchWritten, NULL);
				ASSERT(cchWritten == cchBuffer);
				cchBuffer = 1024;					
				MsiRecordReadStream(hRec, iCol + 1, pszBuffer, &cchBuffer);
			}
			CloseHandle(hOutputFile);
		}
		else
		{
			CloseHandle(hOutputFile);
			return false;
		}
	}
	else
		return false;

	return true;
}

void COrcaDoc::OnNewTransform() 
{
	NewTransform(/*fSetTitle=*/true);
}

void COrcaDoc::NewTransform(bool fSetTitle) 
{
	CWaitCursor cursor;
	TCHAR *szTempFilename;

	// when a transform is applied, we have to have a temp database to apply the transform to.
	// This allows Orca to selectively apply changes to the transform, database, or both.
	// it also allows us to get old values out. 
	// get a temp path
	DWORD cchTempPath = MAX_PATH;
	TCHAR szTempPath[MAX_PATH];
	if (0 == ::GetTempPath(cchTempPath, szTempPath))
	{
		 CString strPrompt;
		 strPrompt.Format(_T("Error %d while retrieving temporary file path."), GetLastError());
		 AfxMessageBox(strPrompt, MB_ICONSTOP);
		 return;
	}

 	m_strTransformFile = TEXT("");

	// get a temp filename
	szTempFilename = m_strTransformTempDB.GetBuffer(MAX_PATH);
	UINT iResult = 0;
	if (0 == ::GetTempFileName(szTempPath, _T("ODB"), 0, szTempFilename))
	{
		CString strPrompt;
		strPrompt.Format(_T("Error %d while retrieving temporary file name."), GetLastError());
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		return;
	}

	m_strTransformTempDB.ReleaseBuffer();
	if (ERROR_SUCCESS != (iResult = MsiOpenDatabase(szTempFilename, MSIDBOPEN_CREATE, &m_hTransformDB)))
	{
		CString strPrompt;
		strPrompt.Format(_T("Orca was unable to create a new transform. Ensure that the TEMP directory exists and is writable. (MSI Error %d)"), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		return;
	}


	if (ERROR_SUCCESS != (iResult = MsiDatabaseMerge(m_hTransformDB, m_hDatabase, NULL)))
	{
		CString strPrompt;
		strPrompt.Format(_T("Orca was unable to create a new transform. (MSI Error %d)"), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		CloseTransform();
		return;
	}

	// copy the summaryinfo stream, or validation will fail
	CQuery qRead;
	DWORD dwResult = 0;
	PMSIHANDLE hCopyRec;
	dwResult = qRead.FetchOnce(m_hDatabase, 0, &hCopyRec, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'"));
	if (ERROR_SUCCESS == dwResult)
	{
		CQuery qInsert;
		if ((ERROR_SUCCESS != (iResult = qInsert.OpenExecute(m_hTransformDB, 0, TEXT("SELECT `Name`, `Data` FROM `_Streams` WHERE `Name`='\005SummaryInformation'")))) ||
			(ERROR_SUCCESS != (iResult = qInsert.Modify(MSIMODIFY_INSERT, hCopyRec))))
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to create the SummaryInformation for the transformed database. (MSI Error %d)"), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			CloseTransform();
			return;
		}
	}
	else if (ERROR_NO_MORE_ITEMS != dwResult)
	{
		CString strPrompt;
		strPrompt.Format(_T("Orca was unable to read the SummaryInformation from the database. (MSI Error %d)"), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		CloseTransform();
		return;
	}

	// if we don't commit the transformed database, streams are not persisted.
	MsiDatabaseCommit(m_hTransformDB);

	// mark the new transform as unmodified
	m_bTransformModified = false;
	m_bTransformIsPatch = false;
	m_bTransformReadOnly = false;

	m_strTransformFile = _T("Untitled");
	if (fSetTitle)
		SetTitle(m_strPathName);
}


void COrcaDoc::OnUpdateNewTransform(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone &&  !DoesTransformGetEdit()); }
void COrcaDoc::OnUpdateTransformViewPatch(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone && (!DoesTransformGetEdit() || m_bTransformIsPatch)); }
void COrcaDoc::OnUpdateApplyTransform(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone &&  !DoesTransformGetEdit()); }
void COrcaDoc::OnUpdateGenerateTransform(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone && DoesTransformGetEdit()); }
void COrcaDoc::OnUpdateTransformProperties(CCmdUI* pCmdUI) { pCmdUI->Enable(m_eiType != iDocNone && DoesTransformGetEdit() && !m_bTransformIsPatch); }

void COrcaDoc::OnUpdateCloseTransform(CCmdUI* pCmdUI) 
{ 
	ASSERT(pCmdUI);
	if (DoesTransformGetEdit())
	{
		pCmdUI->Enable(TRUE); 
		pCmdUI->SetText(m_bTransformIsPatch ? _T("&Close Patch") : _T("&Close Transform"));
	}
	else
	{
		pCmdUI->Enable(FALSE); 
		pCmdUI->SetText(_T("&Close Transform..."));
	}
}


void COrcaDoc::OnApplyTransform() 
{
	// open the file open dialog
	CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST,
						 _T("Installer Transforms (*.mst)|*.mst|All Files (*.*)|*.*||"), AfxGetMainWnd());
	CString strCaption = _T("Open Transform");

	if (IDOK == dlg.DoModal())
	{
		ApplyTransform(dlg.GetPathName(), dlg.GetReadOnlyPref() != FALSE);
	}
}
		
void COrcaDoc::ApplyTransform(const CString strFileName, bool fReadOnly)
{
	// need a wait cursr
	CWaitCursor cursor;

	NewTransform(/*fSetTitle=*/false);
	
	// get the summary information stream to retrieve the transform error flag values.
	m_strTransformFile = strFileName;
	{
		UINT iResult = ERROR_SUCCESS;
		PMSIHANDLE hSummary;
		if (ERROR_SUCCESS == (iResult = ::MsiGetSummaryInformation(NULL, m_strTransformFile, 0, &hSummary)))
		{	
			UINT iType = 0;
			TCHAR szBuffer[1024];
			DWORD cchBuffer = 1024;

			int iBuffer = 0;

			if (ERROR_SUCCESS != (iResult = MsiSummaryInfoGetProperty(hSummary, PID_CHARCOUNT, &iType, &iBuffer, NULL, szBuffer, &cchBuffer)))
			{
				CString strPrompt;
				strPrompt.Format(_T("Orca was unable to read the validation flags from the transform. The transform can not be applied. (MSI Error %d)"), iResult);
				AfxMessageBox(strPrompt, MB_ICONSTOP);
				CloseTransform();
				return;
			}
			if (VT_I4 != iType)
			{
				m_dwTransformErrFlags = 0;
				m_dwTransformValFlags = 0;
			}
			else
			{
				m_dwTransformErrFlags = iBuffer & 0xFFFF;
				m_dwTransformValFlags = (iBuffer >> 16) & 0xFFFF;
			}
		}
		else
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to read the SummaryInformation from the transform. The transform can not be applied. (MSI Error %d)"), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			CloseTransform();
			return;
		}

	}
	
	UINT iResult = 0;
	switch (iResult = MsiDatabaseApplyTransform(m_hTransformDB, m_strTransformFile, m_dwTransformErrFlags))
	{
	case ERROR_OPEN_FAILED:
		// the storage file did not exist.
		AfxMessageBox(_T("The specified transform file could not be opened."), MB_ICONSTOP);
		return;
	case ERROR_INSTALL_TRANSFORM_FAILURE:
		AfxMessageBox(_T("The specified transform could not be applied."), MB_ICONSTOP);
		return;
	case ERROR_SUCCESS:
		break;
	default:
	{
		CString strPrompt;
		strPrompt.Format(_T("Orca was unable to apply the transform. (MSI Error %d)"), iResult);
		AfxMessageBox(strPrompt, MB_ICONSTOP);
		return;
	}
	}

	m_bTransformReadOnly = fReadOnly;

	// necessary to commit temp DB so streams are persisted and can be accessed
	// independently
	MsiDatabaseCommit(m_hTransformDB);

	// send a hint to change to no table. This cleans up the window
	// and makes it safe to have a UI refresh in the middle of this call.
	UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);

	// clear the UI table list
	UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

	// destroy all of the tables
	DestroyTableList();	

	// rebuild the table list
	BuildTableList(/*fAllowLazyLoad=*/false);

	// reload table list into UI
	UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);

	// set frame title
	SetTitle(m_strPathName);
}

void COrcaDoc::OnGenerateTransform() 
{
	GenerateTransform();
}

int COrcaDoc::GenerateTransform()
{
	UpdateAllViews(NULL, HINT_COMMIT_CHANGES);

	// open the file open dialog
	CFileDialog dlg(FALSE, _T("mst"), (m_bTransformIsPatch ? _T("") : m_strTransformFile), OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
						 _T("Windows Installer Transform (*.mst)|*.mst|All Files (*.*)|*.*||"), AfxGetMainWnd());

	CString strCaption = _T("Save Transform As");
	dlg.m_ofn.lpstrTitle = strCaption;
	if (IDOK == dlg.DoModal())
	{
		CString strPath = dlg.GetPathName();
		CString strExt = dlg.GetFileExt();

		if (strPath.IsEmpty())
			return IDCANCEL;

		// if there is no extension add one
		if (strExt.IsEmpty())
		{
			switch(dlg.m_ofn.nFilterIndex)
			{
			case 1:
				strExt = _T(".mst");
				break;
			default:
				strExt = _T(".mst");
				break;
			}

			strPath += strExt;
		}
		
		UINT iResult = 0;
		switch (iResult = MsiDatabaseGenerateTransform(m_hTransformDB, m_hDatabase, strPath, 0, 0))
		{
		case ERROR_NO_DATA:
			AfxMessageBox(_T("The transformed database is identical to the original database. No transform file was generated."), MB_ICONINFORMATION);
			break;
        case ERROR_SUCCESS:
			break;
		default:
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to generate the transform. (MSI Error %d)"), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return IDCANCEL;
		}
		}

		// next generate the transform summary information
        switch (iResult = MsiCreateTransformSummaryInfo(m_hTransformDB, m_hDatabase, strPath, m_dwTransformErrFlags, m_dwTransformValFlags))
		{
        case ERROR_SUCCESS:
			break;
		case ERROR_INSTALL_PACKAGE_INVALID:
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to set all transform validation flags for the transform."));
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return IDCANCEL;
		}
		default:
		{
			CString strPrompt;
			strPrompt.Format(_T("Orca was unable to generate the transform. (MSI Error %d)"), iResult);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return IDCANCEL;
		}
		}

    
		// transform has been saved and is no longer modified
		m_bTransformModified = false;	
		if (!m_bTransformIsPatch)
			m_strTransformFile = strPath;
		SetTitle(m_strPathName);
		return IDOK;
	}
	return IDCANCEL;
}



DWORD GetSummaryInfoString(MSIHANDLE hSummary, int PID, CString &strValue)
{
	DWORD dwBuffer = 255;
	DWORD dwResult = MsiSummaryInfoGetProperty(hSummary, PID, NULL, NULL, NULL, strValue.GetBuffer(dwBuffer), &dwBuffer);
	if (ERROR_MORE_DATA == dwResult)
	{
		strValue.ReleaseBuffer();
		dwBuffer++;
		dwResult = MsiSummaryInfoGetProperty(hSummary, PID, NULL, NULL, NULL, strValue.GetBuffer(dwBuffer), &dwBuffer);
	}
	strValue.ReleaseBuffer();
	return dwResult;
}


DWORD RecordGetString(MSIHANDLE hRec, int iField, CString &strValue)
{
	DWORD dwBuffer = 255;
	DWORD dwResult = MsiRecordGetString(hRec, iField, strValue.GetBuffer(dwBuffer), &dwBuffer);
	if (ERROR_MORE_DATA == dwResult)
	{
		strValue.ReleaseBuffer();
		dwBuffer++;
		dwResult = MsiRecordGetString(hRec, iField, strValue.GetBuffer(dwBuffer), &dwBuffer);
	}
	strValue.ReleaseBuffer();
	return dwResult;
}

///////////////////////////////////////////////////////////////////////
// enables the viewing of patches. Opens a browse dialog, gets the file
// list, cracks the patch and validates the product code, then saves
// each transform to disk, validates the ones that apply, pops a dialog
// allowing the user to select a greater subset, then applies each 
// transform
void COrcaDoc::OnTransformViewPatch() 
{
	// open the file open dialog
	CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST,
						 _T("Installer Patches (*.msp)|*.msp|All Files (*.*)|*.*||"), AfxGetMainWnd());
	CString strCaption = _T("Open Patch");

	if (IDOK == dlg.DoModal())
	{
		ApplyPatch(dlg.GetPathName());
	}
}
		
void COrcaDoc::ApplyPatch(const CString strFileName) 
{	
	// need a wait cursor
	CWaitCursor cursor;

	CString strTransformList;
	CString strProductCodeList;
	
	// scope to ensure all handles to patch summaryinfo are closed before opening it with IStorage
	{
		////
		// open the summaryinfo of the patch and verify the productcode
		PMSIHANDLE hSummary;
		if (ERROR_SUCCESS != MsiGetSummaryInformation(0, strFileName, 0, &hSummary))
		{
			AfxMessageBox(_T("The patch does not contain a valid SummaryInformation stream."), MB_ICONSTOP);
			return;
		}

		if (ERROR_SUCCESS != GetSummaryInfoString(hSummary, PID_TEMPLATE, strProductCodeList))
		{
			AfxMessageBox(_T("The ProductCode list could not be retrieved from the specified patch."), MB_ICONSTOP);
			return;
		}

		////
		// grab the transform list from the patch summaryinfo
		if (ERROR_SUCCESS != GetSummaryInfoString(hSummary, PID_LASTAUTHOR, strTransformList))
		{
			AfxMessageBox(_T("The transform list could not be retrieved from the specified patch."), MB_ICONSTOP);
			return;
		}
	}

	CQuery qRetrieve;
	PMSIHANDLE hRec;
	CString strProductCode;
	if (ERROR_SUCCESS == qRetrieve.FetchOnce(GetTargetDatabase(), 0, &hRec, _T("SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'")))
	{
		RecordGetString(hRec, 1, strProductCode);
	}
	if (strProductCodeList.Find(strProductCode) == -1)
	{
		AfxMessageBox(_T("This patch can not be applied to packages with the current Product Code."), MB_ICONSTOP);
		return;
	}

	// open the patch as IStorage so we can get embedded transforms
	IStorage *piPatchStorage = 0;
	WCHAR *wzFileName = NULL;
#ifdef UNICODE
	wzFileName = const_cast<WCHAR*>(static_cast<const WCHAR*>(strFileName));
#else
	size_t cchWide = strFileName.GetLength()+1;
	wzFileName = new WCHAR[cchWide];
	if (!wzFileName)
		return;
	AnsiToWide(strFileName, wzFileName, &cchWide);
#endif
	HRESULT hRes = StgOpenStorage(wzFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT, NULL, 0, &piPatchStorage);
#ifndef UNICODE
	delete[] wzFileName;
#endif
	if (hRes != S_OK)
	{
		AfxMessageBox(_T("The patch could not be opened. Verify that the file is not in use."), MB_ICONSTOP);
		return;
	}

	// add the patch to the list of applied patches
	m_strTransformFile = _T("");
	m_lstPatchFiles.AddTail(strFileName);

	// if we are not already set up for difference tracking, perform transform init
	// operations now.
	if (!DoesTransformGetEdit())
	{
		NewTransform(false);	
		m_bTransformReadOnly = true;
		m_bTransformIsPatch = true;
	}

	////
	// ensure that the patch table schema has the latest schema to avoid
	// application problems.
	COrcaTable* pPatchTable = FindTable(L"Patch", odlSplitTransformed);

	// if there is no patch table, the correct schema will be added
	// otherwise verify that the column schema is correct
	bool fCreatePatchTable = false;
	if (!pPatchTable)
	{
		fCreatePatchTable = true;
	}
	else
	{
		int iHeaderColumn = -1;
		for (int iColumn = 0; iColumn < pPatchTable->GetColumnCount(); iColumn++)
		{
   			const COrcaColumn* pColumn = pPatchTable->GetColumn(iColumn);
			if (!pColumn)
				continue;
			if (pColumn->m_strName == TEXT("Header"))
			{
				iHeaderColumn = iColumn;
				break;
			}
		}
		if (iHeaderColumn == -1)
		{
			// header column is missing. Definitely the wrong schema
			fCreatePatchTable = true;
		}
		else
		{
			// if the column is nullable, the schema is already correct
			const COrcaColumn* pColumn = pPatchTable->GetColumn(iHeaderColumn);
			if (pColumn && !pColumn->m_bNullable)
				fCreatePatchTable = true;
		}
	}

	if (fCreatePatchTable)
	{
		// try to generate a temporary table name.
		WCHAR wzTempTable[40] = L"_ORCA0000";
		bool fCopyData = false;
		
		CQuery qTempTable;
		CQuery qPatchTable;

		// drop the existing patch table, saving data if necessary
		if (pPatchTable)
		{
			// if there is already data in the patch table, copy it to a temp table. Need to
			// retrieve any table data to ensure an accurrate row count
			pPatchTable->RetrieveTableData();
			if (pPatchTable->GetRowCount())
			{
				int i = 0;
				for (i=1; i < 0xFFFF; i++)
				{
					wzTempTable[5] = L'A'+((i & 0xF000) >> 12);
					wzTempTable[6] = L'A'+((i & 0x0F00) >> 8);
					wzTempTable[7] = L'A'+((i & 0x00F0) >> 4);
					wzTempTable[8] = L'A'+((i & 0x000F));
					if (MSICONDITION_NONE == MsiDatabaseIsTablePersistentW(GetTransformedDatabase(), wzTempTable))
						break;
				}
				if (i == 0xFFFF)
				{
					piPatchStorage->Release();
					return;
				}

				// duplicate the table schema into the temporary table
				MsiDBUtils::DuplicateTableW(GetTransformedDatabase(), L"Patch", GetTransformedDatabase(), wzTempTable, false);

				// copy the data from the Patch table to the temp table
				fCopyData = true;
				if (ERROR_SUCCESS == qPatchTable.OpenExecute(GetTransformedDatabase(), 0, TEXT("SELECT * FROM `Patch`")) &&
				   (ERROR_SUCCESS == qTempTable.OpenExecute(GetTransformedDatabase(), 0, TEXT("SELECT * FROM `%ls`"), wzTempTable)))
				{
					PMSIHANDLE hRec;
					while (ERROR_SUCCESS == qPatchTable.Fetch(&hRec))
						qTempTable.Modify(MSIMODIFY_INSERT, hRec);

					// slow, but necessary to commit before dropping patch table or the binary
					// objects will become lost
					::MsiDatabaseCommit(GetTransformedDatabase());
				}
				else
					fCopyData = false;
			}

			// drop the patch table
			pPatchTable->DropTable(GetTransformedDatabase());
		}

		// create the new patch table
		CQuery qPatchQuery;
		qPatchQuery.OpenExecute(GetTransformedDatabase(), 0, TEXT("CREATE TABLE `Patch` ( `File_` CHAR(72) NOT NULL, `Sequence` INTEGER NOT NULL, `PatchSize` LONG NOT NULL, `Attributes` INTEGER NOT NULL, `Header` OBJECT, `StreamRef_` CHAR(72)  PRIMARY KEY `File_`, `Sequence`)"));

		if (fCopyData)
		{
			// restart query to read from the temporary table
			qTempTable.Execute(0);

			// re-init the patch table schema to retrieve the new columns
			qPatchTable.OpenExecute(GetTransformedDatabase(), 0, TEXT("SELECT * FROM `Patch`"));
			while (ERROR_SUCCESS == qTempTable.Fetch(&hRec))
				qPatchTable.Modify(MSIMODIFY_MERGE, hRec);

			// slow, but necessary to keep streams in the Header column from becoming lost
			::MsiDatabaseCommit(GetTransformedDatabase());

			// drop the table used for storage
			CQuery qFree;
			qFree.OpenExecute(GetTransformedDatabase(), 0, TEXT("DROP TABLE `%ls`"), wzTempTable);
		}
	}

	////
	// parse the transform list, validate each transform, and apply the transforms in order.
	int iSemicolon = 0;
	bool fError = false;

	CString strTransformFile;		
	do
	{
		// determine the name of the next embedded transform
		CString strTransform;
		iSemicolon = strTransformList.Find(';');
		if (iSemicolon != -1)
		{
			// transform name begins with ':', so strip the first character
			strTransform = strTransformList.Left(iSemicolon);
			strTransformList = strTransformList.Mid(iSemicolon+1);
		}
		else
			strTransform = strTransformList;
		strTransform = strTransform.Mid(1);
		if (strTransform.IsEmpty())
			break;

		// generate a temporary file name
		DWORD cchTempPath = MAX_PATH;
		TCHAR szTempPath[MAX_PATH] = TEXT("");
		if (0 == ::GetTempPath(cchTempPath, szTempPath))
		{
			fError = true;
			CString strPrompt;
			strPrompt.Format(_T("Error %d while retrieving temporary file path."), GetLastError());
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			break;
		}
		if (0 == ::GetTempFileName(szTempPath, _T("ODB"), 0, strTransformFile.GetBuffer(MAX_PATH)))
		{
			fError = true;
			CString strPrompt;
			strPrompt.Format(_T("Error %d while retrieving temporary file name."), GetLastError());
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			break;
		}
		strTransformFile.ReleaseBuffer();

		IStorage *piSourceStorage = NULL;
		IStorage *piNewStorage = NULL;

		WCHAR *wzTransform = NULL;
#ifdef UNICODE
		wzTransform = const_cast<WCHAR*>(static_cast<const WCHAR*>(strTransform));
#else
		cchWide = strTransform.GetLength()+1;
		wzTransform = new WCHAR[cchWide];
		if (!wzTransform)
			return;
		AnsiToWide(strTransform, wzTransform, &cchWide);
#endif
		hRes = piPatchStorage->OpenStorage(wzTransform, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, NULL, 0, &piSourceStorage);
#ifndef UNICODE
		delete[] wzTransform;
#endif
		if (hRes != S_OK)
		{
			AfxMessageBox(_T("The transforms inside the patch could not be opened. The patch may be invalid, or the SummaryInformation may reference a non-existent transform."), MB_ICONSTOP);
			fError = true;
			break;
		}

		WCHAR* wzTransformFile = NULL;
#ifdef UNICODE
		wzTransformFile = const_cast<WCHAR*>(static_cast<const WCHAR*>(strTransformFile));
#else
		cchWide = strTransformFile.GetLength()+1;
		wzTransformFile = new WCHAR[cchWide];
		if (!wzTransformFile)
			return;
		AnsiToWide(strTransformFile, wzTransformFile, &cchWide);
#endif
		hRes = StgCreateDocfile(wzTransformFile, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_DIRECT, 0, &piNewStorage);
#ifndef UNICODE
		delete[] wzTransformFile;
#endif
		if (hRes != S_OK)
		{
			AfxMessageBox(_T("The transforms inside the patch could not be accessed. Verify that the TEMP directory is writable."), MB_ICONSTOP);
			piSourceStorage->Release();
			fError = true;
			break;
		}

		COrcaApp *pApp = (static_cast<COrcaApp *>(AfxGetApp()));
		ASSERT(pApp);
		if (pApp)
			pApp->m_lstTempCleanup.AddTail(strTransformFile);

		hRes = piSourceStorage->CopyTo(NULL, NULL, NULL, piNewStorage);
		if (hRes != S_OK)
		{
			AfxMessageBox(_T("The transforms inside patch could not be read. The patch may be invalid."), MB_ICONSTOP);
			piSourceStorage->Release();
			fError = true;
			break;
		}

		piSourceStorage->Release();
		piNewStorage->Release();

		// retrieve product code, product verison, upgrade code for validation. Each transform can modify these
		// values, so we must requery before every transform in the patch.
		CString strUpgradeCode;
		CString strProductVersion;
		if (ERROR_SUCCESS == qRetrieve.FetchOnce(GetTargetDatabase(), 0, &hRec, _T("SELECT `Value` FROM `Property` WHERE `Property`='ProductVersion'")))
		{
			RecordGetString(hRec, 1, strProductVersion);
		}
		if (ERROR_SUCCESS == qRetrieve.FetchOnce(GetTargetDatabase(), 0, &hRec, _T("SELECT `Value` FROM `Property` WHERE `Property`='UpgradeCode'")))
		{
			RecordGetString(hRec, 1, strUpgradeCode);
		}
		if (ERROR_SUCCESS == qRetrieve.FetchOnce(GetTargetDatabase(), 0, &hRec, _T("SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'")))
		{
			RecordGetString(hRec, 1, strProductCode);
		}

		// determine if this transform can be applied to this package
		int iValidateFlags = 0;
		if (ValidatePatchTransform(strTransformFile, strProductCode, strProductVersion, strUpgradeCode, iValidateFlags))
		{
			UINT iResult = 0;
			switch (iResult = MsiDatabaseApplyTransform(m_hTransformDB, strTransformFile, iValidateFlags))
			{
			case ERROR_OPEN_FAILED:
				// the storage file did not exist.
				AfxMessageBox(_T("The specified transform file could not be opened."), MB_ICONSTOP);
				fError = true;
				break;
			case ERROR_INSTALL_TRANSFORM_FAILURE:
				AfxMessageBox(_T("The specified transform could not be applied."), MB_ICONSTOP);
				fError = true;
				break;
			case ERROR_SUCCESS:
				break;
			default:
			{
				CString strPrompt;
				strPrompt.Format(_T("Orca was unable to apply a transform from the patch. (MSI Error %d)"), iResult);
				AfxMessageBox(strPrompt, MB_ICONSTOP);
				fError = true;
				break;
			}
			}

			if (fError)
				break;
		}

		if (fError)
			break;
	} while (iSemicolon != -1);

	// free the patch
	piPatchStorage->Release();

	if (!fError)
	{	
		// commit the database so future patches can be applied
		MsiDatabaseCommit(m_hTransformDB);

		// send a hint to change to no table. This cleans up the window
		// and makes it safe to have a UI refresh in the middle of this call.
		UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);

		// clear the UI table list
		UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

		// destroy all of the tables
		DestroyTableList();	

		// rebuild the table list
		BuildTableList(/*AllowLazyLoad=*/false);

		// reload table list into UI
		UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);

		// set frame title
		SetTitle(m_strPathName);
	}
	else
		CloseTransform();
}

void COrcaDoc::CloseTransform()
{
	// clean up internal state
	if (m_hTransformDB)
		MsiCloseHandle(m_hTransformDB);
	m_hTransformDB=0;	
	m_bTransformModified = false;
	m_bTransformIsPatch = false;
	m_bTransformReadOnly = false;
	m_strTransformFile = _T("Untitled");
	while (!m_lstPatchFiles.IsEmpty())
		m_lstPatchFiles.RemoveHead();

	// delete temporary files
	if (m_strTransformTempDB.IsEmpty())
		DeleteFile(m_strTransformTempDB);
	
	// clear any pending validation errors
	UpdateAllViews(NULL, HINT_CLEAR_VALIDATION_ERRORS, NULL);
	((CMainFrame*)AfxGetMainWnd())->HideValPane();

	// send a hint to change to no table. This cleans up the window
	// and makes it safe to have a UI refresh in the middle of this call.
	UpdateAllViews(NULL, HINT_CHANGE_TABLE, NULL);

	// clear the UI table list
	UpdateAllViews(NULL, HINT_TABLE_DROP_ALL, NULL);

	// destroy all of the tables
	DestroyTableList();	

	// rebuild the table list.
	BuildTableList(/*fAllowLazyLoad=*/true);

	// reload table list into UI
	UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);
	
	// set window title
	SetTitle(m_strPathName);

	// try cleaning up any temp files
	CStringList *pList = &((static_cast<COrcaApp *>(AfxGetApp()))->m_lstTempCleanup);
	if (pList)
	{
		INT_PTR iMax = pList->GetCount();
		for (INT_PTR i=0; i < iMax; i++)
		{
			CString strFile = pList->RemoveHead();
			if (!strFile.IsEmpty())
			{
				if (!DeleteFile(strFile))
					pList->AddTail(strFile);
			}
		}
	}
}

void COrcaDoc::OnCloseTransform() 
{
	if (m_bTransformModified)
	{
		CString strPrompt;
		strPrompt.Format(_T("Save changes to transform %s?"), m_strTransformFile.IsEmpty() ? _T("Untitled") : m_strTransformFile);
		switch (AfxMessageBox(strPrompt, MB_YESNOCANCEL | MB_ICONEXCLAMATION))
		{
		case IDYES:
			if (IDCANCEL == GenerateTransform())
				return;
			break;
		case IDNO:
			break;
		case IDCANCEL:
		default:
			return;
		}
	}

	CloseTransform();
}



void COrcaDoc::SetModifiedFlag(BOOL fModified)
{
	if (DoesTransformGetEdit())
		m_bTransformModified = (fModified != 0);
	else
		CDocument::SetModifiedFlag(fModified);
}


// sets the window title appropriately
void COrcaDoc::SetTitle(LPCTSTR szTitle)
{
	CString strTitle;
	if (m_strPathName.IsEmpty())
		strTitle = _T("Untitled");
	else
	{
		int nFind = m_strPathName.ReverseFind(_T('\\'));
		if (nFind > -1)
			strTitle = m_strPathName.Mid(nFind + 1);
		else
			strTitle = m_strPathName;
	}

	if (DoesTransformGetEdit())
	{
		strTitle += (m_bTransformIsPatch ? _T(" (patched by ") : _T(" (transformed by "));

		if (m_bTransformIsPatch)
		{
			POSITION pos = m_lstPatchFiles.GetHeadPosition();
			while (pos)
			{
				CString strTransformFile = m_lstPatchFiles.GetNext(pos);
				int nFind = strTransformFile.ReverseFind(_T('\\'));
				if (nFind > -1)
					strTitle += strTransformFile.Mid(nFind + 1);
				else
					strTitle += strTransformFile;

				if (pos != NULL)
					strTitle += _T(", ");
			}
		}
		else
		{
			int nFind = m_strTransformFile.ReverseFind(_T('\\'));
			if (nFind > -1)
				strTitle += m_strTransformFile.Mid(nFind + 1);
			else
				strTitle += m_strTransformFile;
		}

		strTitle += _T(")");
	}

	if (TargetIsReadOnly())
		strTitle += _T(" (Read Only)");

	CDocument::SetTitle(strTitle);
}

///////////////////////////////////////////////////////////////////////
// returns true if the specified transform is valid basaed on the
// validation options 

DWORD ProductVersionStringToInt(const CString strVersion)
{
	DWORD dwVersion = 0;

	dwVersion = _ttoi(strVersion) << 24;

	int iDot = strVersion.Find('.');
	if (iDot == -1)
		return dwVersion;

	dwVersion |= (_ttoi(strVersion.Mid(iDot)) << 16);
	int iNewDot = strVersion.Find(iDot+1, '.');

	if (iNewDot == -1)
		return dwVersion;
	iDot += iNewDot;

	dwVersion |= _ttoi(strVersion.Mid(iDot));
	return dwVersion;
}

 
bool COrcaDoc::ValidatePatchTransform(CString strTransform, const CString strProductCode,
									  const CString strProductVersion, const CString strUpgradeCode, 
									  int& iDesiredFailureFlags)
{

	// get summaryinfo of the transform
	PMSIHANDLE hSummary;
	if (ERROR_SUCCESS != MsiGetSummaryInformation(0, strTransform, 0, &hSummary))
		return false;

	
	// get the summary info properties
	CString strTransTemplate;
	CString strTransRevNumber;

	int iTransRestrictions = 0;

	GetSummaryInfoString(hSummary, PID_TEMPLATE, strTransTemplate);
	GetSummaryInfoString(hSummary, PID_REVNUMBER, strTransRevNumber);
	MsiSummaryInfoGetProperty(hSummary, PID_CHARCOUNT, NULL, &iTransRestrictions, NULL, NULL, NULL);

	// desired failure flags are in the lower word, actual validation checks are in upper
	// word.
	iDesiredFailureFlags = iTransRestrictions & 0xFFFF;
	iTransRestrictions >>= 16;
		
	// validate language
	// ********** what to do here, this is highly runtime dependant
	if (iTransRestrictions & MSITRANSFORM_VALIDATE_LANGUAGE)
	{
/*		strTransLanguage == strTransTemplate;
		int iSemicolon = strTransTemplate.Find(';');
		if (iSemicolon != -1)
			strTransLanguage = strTransTemplate.Right(strTransTemplate.GetLength()-iSemicolon);
		 
		if ((int)istrTransLanguage != GetLanguage())
		{
			return false
		}*/
	}

	// validate productcode
	if (iTransRestrictions & MSITRANSFORM_VALIDATE_PRODUCT)
	{
		CString strTransProductCode = strTransRevNumber.Left(38);
		if (strTransProductCode != strProductCode)
		{
			return false;
		}
	}

	// validate upgrade code
	if (iTransRestrictions & MSITRANSFORM_VALIDATE_UPGRADECODE)
	{
		CString strTransUpgradeCode = strTransRevNumber;
		int iSemicolon = strTransUpgradeCode.Find(';');
		if (iSemicolon == -1)
			return false;
		iSemicolon = strTransUpgradeCode.Find(';', iSemicolon+1);
		// if theres no second semicolon, there is no upgrade code validation
		if (iSemicolon != -1)
		{
			strTransUpgradeCode = strTransUpgradeCode.Mid(iSemicolon+1);
			
			if (strTransUpgradeCode != strUpgradeCode)
			{
				return false;
			}
		}
	}

	// check version numbers
	if ((iTransRestrictions & (MSITRANSFORM_VALIDATE_MAJORVERSION|MSITRANSFORM_VALIDATE_MINORVERSION|MSITRANSFORM_VALIDATE_UPDATEVERSION)) != 0)
	{
		CString strVersion  = strTransRevNumber.Mid(38);
		int iSemicolon = strVersion.Find(';');
		if (iSemicolon != -1)
			strVersion = strVersion.Left(iSemicolon);

		// convert version strings into integers
		int iAppVersion      = ProductVersionStringToInt(strProductVersion);
		int iTransAppVersion = ProductVersionStringToInt(strVersion);

		if(iTransRestrictions & MSITRANSFORM_VALIDATE_MAJORVERSION)
		{
			iAppVersion &= 0xFF000000;
			iTransAppVersion &= 0xFF000000;
		}
		else if(iTransRestrictions & MSITRANSFORM_VALIDATE_MINORVERSION)
		{
			iAppVersion &= 0xFFFF0000;
			iTransAppVersion &= 0xFFFF0000;
		}
		// else itvUpdVer: don't need to mask off bits

		switch (iTransRestrictions & 0x7C)
		{
		case MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION:
			if (!(iAppVersion < iTransAppVersion))
				return false;
			break;
		case MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION:
			if (!(iAppVersion <= iTransAppVersion))
				return false;
			break;
		case MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION:			
			if (!(iAppVersion == iTransAppVersion))
				return false;
			break;
		case MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION:
			if (!(iAppVersion >= iTransAppVersion))
				return false;
			break;
		case MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION:
			if (!(iAppVersion > iTransAppVersion))
				return false;
			break;
		default:
			break;
		}
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\outils.cpp ===
#include "..\common\utils.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\orcadoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// OrcaDoc.h : interface of the COrcaDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ORCADOC_H__C3EDC1AE_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_ORCADOC_H__C3EDC1AE_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "msiquery.h"
#include "Table.h"
#include "valpane.h"

#define MAX_SUMMARY 19

enum DocType
{
	iDocNone,
	iDocDatabase,
};

enum OrcaDocHints {
	HINT_NULL_UPDATE,
	HINT_RELOAD_ALL,
	HINT_ADD_TABLE,
	HINT_ADD_TABLE_QUIET,

	HINT_ADD_ROW,
		// adds a row to the UI control. Refreshes window to show new row and updates status bar with new row count.
		// The schema must match the current control UI schema. pHint is COrcaRow* to the new row.
		
	HINT_ADD_ROW_QUIET,
		// adds a row to the UI control, but does not refresh window or status bar. Used for bulk-adds (such as paste)
		// where the window will be refreshed later. The schema must match the current control UI schema. 
		// pHint is COrcaRow* to the new row.

	HINT_DROP_TABLE,
	HINT_DROP_ROW,
	HINT_REDRAW_ALL,
	HINT_COMMIT_CHANGES,

	HINT_SET_ROW_FOCUS,
		// ensures that a row is visible in the window, scrolling if necessary. pHint is COrcaRow* to a 
		// row that must exist in the current table

	HINT_SET_COL_FOCUS,
		// ensure that column N of the current table is in the viewscreen, scrolling if necessary. pHint is 
		// integer column number
	
	HINT_CHANGE_TABLE,
		// changes from one selected table to another. Completely destroys table view UI and reloads
		// with new table data. Updates status bar for table name and row count. Saves existing column
		// widths if a table is selected. pHint is new COrcaTable* to new table.
	
	HINT_TABLE_DATACHANGE,
		// erases and reloads all rows in the table without reloading the column information. The schema must
		// match the existing objects schema. pHint is COrcaTable* to the target table
		
	HINT_TABLE_REDEFINE,
		// erases and reloads all columns and rows in the table. pHint is COrcaTable* to the target table

	HINT_CELL_RELOAD,
		// refreshes the UI for a row from the COrcaRow object and redraws that item in the list view. 
		// pHint is COrcaRow* to the row to be refreshed

	HINT_REDRAW_TABLE,
		// redraws a single cell in the Table List and ensures that it is visible. pHint is COrcaTabl* to the
		// target table

	HINT_TABLE_DROP_ALL,

	HINT_ADD_VALIDATION_ERROR,
		// adding a validation error result to the current database. pHint is CValidationError*, must be 
		// copied by any table that wants to persist the data.
	
	HINT_CLEAR_VALIDATION_ERRORS,
		// the database is about to be re-validated, dispose of any stored validation results. pHint is
		// ignored.
};

class COrcaDoc : public CDocument
{
protected: // create from serialization only
	COrcaDoc();
	DECLARE_DYNCREATE(COrcaDoc)

// Attributes
public:
	DocType m_eiType;
	CString m_strPathName;
	CTypedPtrList<CObList, COrcaTable*> m_tableList;

	// summary information
	CString m_strTitle;
	CString m_strSubject;
	CString m_strAuthor;
	CString m_strLastSaved;
	CString m_strKeywords;
	CString m_strComments;
	CString m_strPlatform;
	CString m_strLanguage;
	CString m_strProductGUID;
	int m_nSchema;
	int m_nFilenameType;
	int m_nSecurity;
	CString m_strICEsToRun;

// Operations
public:
	static bool WriteStreamToFile(MSIHANDLE hRec, const int iCol, CString &strFilename);

	void DestroyTableList();
	UINT DropOrcaTable(COrcaTable* pTable);
	UINT AddRow(COrcaTable* pTable, CStringList* pstrDataList);
	bool DropRow(COrcaTable* pTable, COrcaRow* pRow);
	UINT WriteBinaryCellToFile(COrcaTable* pTable, COrcaRow* pRow, UINT iCol, CString strFile);
	bool ExportTable(const CString* tablename, const CString *dirname);

	inline bool DoesTransformGetEdit() const { return (m_hTransformDB != 0); };
	inline bool TargetIsReadOnly() { return DoesTransformGetEdit() ? m_bTransformReadOnly : m_bReadOnly; }; 

	// database handle functions. Both relative (target/non-target) and absolute (original/transformed) are
	// available. All return 0 if not available.
	inline MSIHANDLE GetOriginalDatabase() const { return m_hDatabase; };
	inline MSIHANDLE GetTransformedDatabase() const { return m_hTransformDB; };
	inline MSIHANDLE GetTargetDatabase() const { return DoesTransformGetEdit() ? m_hTransformDB : m_hDatabase; };
	
	inline bool IsRowInTargetDB(const COrcaRow *pRow) const {
		return ((DoesTransformGetEdit() &&  (pRow->IsTransformed() != iTransformDrop)) ||
				(!DoesTransformGetEdit() && (pRow->IsTransformed() != iTransformAdd))); };
	inline bool IsColumnInTargetDB(const COrcaColumn *pColumn) const {
		return ((DoesTransformGetEdit() &&  (pColumn->IsTransformed() != iTransformDrop)) ||
				(!DoesTransformGetEdit() && (pColumn->IsTransformed() != iTransformAdd))); };

	void ApplyTransform(const CString strFilename, bool fReadOnly);
	void ApplyPatch(const CString strFilename);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COrcaDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void SetTitle(LPCTSTR lpszTitle);
	//}}AFX_VIRTUAL

	void SetModifiedFlag(BOOL fModified);


// Implementation
public:
	virtual ~COrcaDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	COrcaTable* CreateAndLoadTable(MSIHANDLE hDatabase, CString strTable);
	COrcaTable* CreateAndLoadNewlyAddedTable(CString strTable);
	UINT ReadSummary(MSIHANDLE hSource);
	UINT PersistSummary(MSIHANDLE hTarget, bool bCreate);

// Generated message map functions
public:	
	COrcaTable* FindTable(const CString strTable, odlOrcaDataLocation odlLocation) const;
	COrcaTable* FindAndRetrieveTable(CString strTable);

	void RefreshTableAfterImport(CString strTable);
	bool FillTableList(CStringList *newlist, bool fShadow, bool fTargetOnly) const;

	//{{AFX_MSG(COrcaDoc)
	afx_msg void OnApplyTransform();
	afx_msg void OnFileOpen();
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	afx_msg void OnFileSaveTransformed();
	afx_msg void OnSummaryInformation();
	afx_msg void OnValidator();
	afx_msg void OnMergeMod();
	afx_msg void OnUpdateMergeMod(CCmdUI* pCmdUI);
	afx_msg void OnFileClose();
	afx_msg void OnTableAdd();
	afx_msg void OnRowAdd();
	afx_msg void OnTableDrop();
	afx_msg void OnFileNew();
	afx_msg void OnTablesImport();
	afx_msg void OnNewTransform();
	afx_msg void OnEditTransform();
	afx_msg void OnEditDatabase();
	afx_msg void OnGenerateTransform();
	afx_msg void OnTransformProperties();
	afx_msg void OnCloseTransform();
	afx_msg void OnTransformViewPatch();
	afx_msg void OnUpdateFilePrint(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTableAdd(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTableDrop(CCmdUI* pCmdUI);
	afx_msg void OnUpdateValidator(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRowAdd(CCmdUI* pCmdUI);
	afx_msg void OnUpdateSummaryInformation(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileClose(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileSave(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileSaveAs(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileSaveTransformed(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTablesExport(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTablesImport(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNewTransform(CCmdUI* pCmdUI);
	afx_msg void OnUpdateApplyTransform(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGenerateTransform(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditTransform(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditDatabase(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTransformProperties(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTransformViewPatch(CCmdUI* pCmdUI);
	afx_msg void OnUpdateCloseTransform(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool m_bReadOnly;
	bool m_bTransformReadOnly;

	CString m_strCUBFile;
	CString m_strStoredModuleName;
	CString m_strStoredModuleLanguage;
	bool m_bShowValInfo;

	MSIHANDLE m_hDatabase;	// handle to active MSI database or Merge Module

	// transform information
	bool m_bTransformModified;
	bool m_bTransformIsPatch;
	MSIHANDLE m_hTransformDB;	// handle to temporary transformed DB
	CString m_strTransformTempDB;
	CString m_strTransformFile;

	CStringList m_lstPatchFiles;

	DWORD m_dwTransformValFlags;
	DWORD m_dwTransformErrFlags;

	// private worker functions
	BOOL OpenDocument(LPCTSTR lpszPathName, bool bReadOnly);

	// private functions for maintaining data lists
	UINT BuildTableList(bool fNoLazyDataLoad);

	// private transform functions
	void NewTransform(bool fSetTitle);
	void CloseTransform();
	int  GenerateTransform();

	UINT PersistTables(MSIHANDLE hPersist, MSIHANDLE hSource, bool bCommit);
	bool ValidatePatchTransform(CString strTransform, const CString strProductCode,
								const CString strProductVersion, const CString szUpgradeCode,
								int& iDesiredFailureFlags);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORCADOC_H__C3EDC1AE_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\orcalstv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// OrcaListView.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "OrcaLstV.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COrcaListView

IMPLEMENT_DYNCREATE(COrcaListView, CListView)

COrcaListView::COrcaListView()
{
	m_pfDisplayFont = NULL;
	m_cColumns = 0;
	m_nSelCol = -1;
	m_iRowHeight = 1;
	m_clrFocused = RGB(0,255,255);
	m_clrSelected = RGB(0,0,255);
	m_clrNormal = RGB(255,255,255);
	m_clrTransform = RGB(0, 128, 0);
	m_bDrawIcons = false;
}

COrcaListView::~COrcaListView()
{
	if (m_pfDisplayFont)
		delete m_pfDisplayFont;
}


BEGIN_MESSAGE_MAP(COrcaListView, CListView)
	//{{AFX_MSG_MAP(COrcaListView)
	ON_WM_CREATE()
	ON_WM_ERASEBKGND()
	ON_WM_MEASUREITEM_REFLECT()
	ON_UPDATE_COMMAND_UI(IDM_ERRORS, OnUpdateErrors)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define CELL_BORDER 3

/////////////////////////////////////////////////////////////////////////////
// COrcaListView drawing

void COrcaListView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// COrcaListView diagnostics

#ifdef _DEBUG
void COrcaListView::AssertValid() const
{
	CListView::AssertValid();
}

void COrcaListView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

COrcaDoc* COrcaListView::GetDocument() const // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(COrcaDoc)));
	return (COrcaDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COrcaListView message handlers

COrcaListView::ErrorState COrcaListView::GetErrorState(const void *data, int iColumn) const
{
	return OK;
}

OrcaTransformAction COrcaListView::GetItemTransformState(const void *data) const
{
	return iTransformNone;
}

bool COrcaListView::ContainsTransformedData(const void *data) const
{
	return false;
}

bool COrcaListView::ContainsValidationErrors(const void *data) const
{
	return false;
}

OrcaTransformAction COrcaListView::GetCellTransformState(const void *data, int iColumn) const
{
	return iTransformNone;
}

OrcaTransformAction COrcaListView::GetColumnTransformState(int iColumn) const
{
	return iTransformNone;
}

///////////////////////////////////////////////////////////
// retrieve maximum width for one or more columns based
// on the mask.	If a table is provided, it is used and the
// list control itself is never queried except to get the
// font and DC. If a table is not provided, everything
// is retrieved from the current state of the list control.
void COrcaListView::GetAllMaximumColumnWidths(const COrcaTable* pTable, int rgiMaxWidths[32], DWORD dwMask) const
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// determine the number of columns
	int cColumns = 0;
	if (pTable)
		cColumns = pTable->GetColumnCount();
	else
		cColumns = m_cColumns;

	// initialize all widths to 0.
	for (int iColumn =0; iColumn < cColumns; iColumn++)
		rgiMaxWidths[iColumn] = 0;
	
	// obtain the DC from the list control
	CDC* pDC = rctrlList.GetDC();
	if (pDC)
	{
		// select the font into the DC to ensure that the correct
		// character widths are used.
		if (m_pfDisplayFont)
			pDC->SelectObject(m_pfDisplayFont);

		const CString* pstrText = NULL;

		// check the widths of the column names
		for (int iColumn = 0; iColumn < cColumns; iColumn++)
		{
			// if this column is selected, OK to check width
			if (dwMask & (1 << iColumn))
			{
				LPCTSTR szColumnName = NULL;
				TCHAR szName[72];

				// if a table is provided, the name is retrieved from the 
				// column structures of that table
				if (pTable)
				{
					const COrcaColumn* pColumn = pTable->GetColumn(iColumn);
					if (pColumn)
						szColumnName = pColumn->m_strName;
				}
				else
				{
					// otherwise the table name is retrieved from the list 
					// control header
					LVCOLUMN ColumnInfo;
					ColumnInfo.mask = LVCF_TEXT;
					ColumnInfo.cchTextMax = 72;
					ColumnInfo.pszText = szName;

					if (rctrlList.GetColumn(iColumn, &ColumnInfo))
					{
						szColumnName = ColumnInfo.pszText;
					}
				}
				if (szColumnName)
					rgiMaxWidths[iColumn] = pDC->GetTextExtent(szColumnName).cx;
			}
		}

		// enumerate all data items, either from the table or 
		// the list control
		POSITION pos = pTable ? pTable->GetRowHeadPosition() : NULL;
		int iMaxItems = rctrlList.GetItemCount();
		int iRow = 0;

		// continue looping as long as the position is not NULL (for table)
		// or the count is less than the number of items (for non-table)
		while (pTable ? (pos != NULL) : (iRow < iMaxItems))
		{
			// row pointer is stored in data of column 0 for list control, and
			// is explicitly provided in enumerating the table
			const COrcaRow* pRow = NULL;
			if (pTable)
			{
				pRow = pTable->GetNextRow(pos);
			}
			else 
				pRow = reinterpret_cast<COrcaRow*>(rctrlList.GetItemData(iRow));

			if (pRow)
			{
				// check every column where the mask bit is set
				for (int iColumn = 0; iColumn < m_cColumns; iColumn++)
				{
					if (dwMask & (1 << iColumn))
					{
						const CString* pstrText = NULL;
						
						// if a table is provided, grab the string from the row
						// explicitly. If a table is not provided, use the abstraction
						// of GetOutputText to handle scenarios where the pRow pointer
						// is not actually a row.
						if (pTable)
						{
							const COrcaData* pData = pRow->GetData(iColumn);
							if (pData)
								pstrText = &(pData->GetString());
						}
						else
							pstrText = GetOutputText(pRow, iColumn);
					
						// if there is text in this cell, get the horizontal extent
						// and check against the maximum
						if (pstrText)
						{
							int iWidth = pDC->GetTextExtent(*pstrText).cx;
							if (iWidth > rgiMaxWidths[iColumn])
								rgiMaxWidths[iColumn] = iWidth;
						}
					}
				}
			}

			// increment row counter in non-table case.
			iRow++;
		}

		// select away the font to free resources
		pDC->SelectObject(static_cast<CFont *>(NULL));
		rctrlList.ReleaseDC(pDC);
	}
	
	// add border amount to each column, plus bar margin for first.
	for (iColumn=0; iColumn < m_cColumns; iColumn++)
	{
		rgiMaxWidths[iColumn] += (2*CELL_BORDER)+((m_bDrawIcons && iColumn == 0) ? g_iMarkingBarMargin : 0);
	}		  	
}

///////////////////////////////////////////////////////////
// retrieve maximum width for a column
int COrcaListView::GetMaximumColumnWidth(int iColumn) const
{
	int rgiColumnWidths[32];

	GetAllMaximumColumnWidths(NULL, rgiColumnWidths, 1 << iColumn);

	return rgiColumnWidths[iColumn];
}


///////////////////////////////////////////////////////////
// notification messages from the list view and header control
BOOL COrcaListView::OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult )
{
	NMHEADER* pHDR = reinterpret_cast<NMHEADER*>(lParam);
	switch (pHDR->hdr.code)
	{
	case HDN_DIVIDERDBLCLICK:
	{
		// get list control
		CListCtrl& rctrlList = GetListCtrl();

		int iMaxWidth = GetMaximumColumnWidth(pHDR->iItem);
		if (iMaxWidth > 0x7FFF)
			iMaxWidth = 0x7FFF;
		rctrlList.SetColumnWidth(pHDR->iItem, iMaxWidth);
		return 1;
	}
	default:
		break;
	}
	return CListView::OnNotify(wParam, lParam, pResult);
}

///////////////////////////////////////////////////////////
// DrawItem
void COrcaListView::DrawItem(LPDRAWITEMSTRUCT pDraw)
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	CDC dc;
	dc.Attach(pDraw->hDC);
	if (m_pfDisplayFont)
		dc.SelectObject(m_pfDisplayFont);

	// loop through all the columns
	void* pRowData = reinterpret_cast<void*>(rctrlList.GetItemData(pDraw->itemID));
	ASSERT(pRowData);
	if (!pRowData)
		return;

	int iTextOut = pDraw->rcItem.left;		// position to place first word (in pixels)

	RECT rcArea;
	rcArea.top = pDraw->rcItem.top;
	rcArea.bottom = pDraw->rcItem.bottom;
	
	OrcaTransformAction iRowTransformed = GetItemTransformState(pRowData);
	for (int i = 0; i < m_cColumns; i++)
	{
		
		int iColumnWidth = rctrlList.GetColumnWidth(i);
		// area box to redraw
		rcArea.left = iTextOut;
		iTextOut += iColumnWidth;
		rcArea.right = iTextOut;
		COLORREF clrRect = 0;
		CBrush *pbrshRect = NULL;
		
		// if we are in the focused state, set yellow
		if ((i == m_nSelCol) && (this == GetFocus()) && (pDraw->itemState & ODS_FOCUS))
		{
			dc.SetTextColor(m_clrFocusedT);
			pbrshRect = &m_brshFocused;
			clrRect = m_clrFocused;
		}
		// if we are selected, set blue
		else if ( (pDraw->itemState & ODS_SELECTED) )
		{
			dc.SetTextColor(m_clrSelectedT);
			pbrshRect = &m_brshSelected;
			clrRect = m_clrSelected;
		}
		else	// otherwise normal state
		{
			dc.SetTextColor(m_clrNormalT);
			pbrshRect = &m_brshNormal;
			clrRect = m_clrNormal;
		}

		// fill the background with the right color, we can draw a 
		// border around transformed cells. Row transforms override this, so
		// no need to do this check in that case.
		if ((iRowTransformed == iTransformNone) && (GetCellTransformState(pRowData, i) == iTransformChange))
		{
			RECT rcBorder = rcArea;
			if (i)
				rcBorder.left+=1;
			rcBorder.bottom-=1;
			dc.SelectObject(m_penTransform);
			dc.SelectObject(pbrshRect);
			dc.Rectangle(&rcBorder);
			dc.SelectObject((CPen *)NULL);
			dc.SelectObject((CBrush *)NULL);
		}
		else
		{
			dc.FillSolidRect(&rcArea, clrRect);
		}

		// draw the "marking bars" on the left of the table list
		if (m_bDrawIcons)
		{
			// incrementing the width of these bars requires increasing
			// g_iMarkingBarMargin
			if (ContainsValidationErrors(pRowData))
			{
				RECT rcBlockArea = rcArea;
				rcBlockArea.left = pDraw->rcItem.left + 3;
				rcBlockArea.right = pDraw->rcItem.left + 6;
				dc.FillSolidRect(&rcBlockArea, RGB(255, 0, 0));
			}

			if (ContainsTransformedData(pRowData))
			{
				RECT rcBlockArea = rcArea;
				rcBlockArea.left = pDraw->rcItem.left + 8;
				rcBlockArea.right = pDraw->rcItem.left + 11;
				dc.FillSolidRect(&rcBlockArea, RGB(0, 128, 0));
			}
		}

		// if there is an error
		switch (GetErrorState(pRowData, i)) {
		case ShadowError:
			dc.SetTextColor(RGB(255, 128, 128));
			break;
		case Error:	
			dc.SetTextColor(RGB(255, 0, 0)); 
			break;
		case Warning:
			dc.SetTextColor(RGB(255, 96, 0));
			break;
		default:
			break;
		};

		RECT rcTextArea = rcArea;
		rcTextArea.left = rcArea.left + (m_bDrawIcons ? g_iMarkingBarMargin : 0) + CELL_BORDER;
		rcTextArea.right = rcArea.right - CELL_BORDER;
		dc.DrawText(*GetOutputText(pRowData, i), &rcTextArea, DT_LEFT|DT_VCENTER|DT_NOPREFIX|DT_SINGLELINE|DT_END_ELLIPSIS);

		// and draw column transform
		if (GetColumnTransformState(i) == iTransformAdd)
		{
			RECT rcBorder = rcArea;
			if (i)
				rcBorder.left+=1;
			rcBorder.bottom-=1;
			dc.SelectObject(m_penTransform);
			dc.MoveTo(rcBorder.left, rcBorder.top);
			dc.LineTo(rcBorder.left, rcBorder.bottom);
			dc.MoveTo(rcBorder.right, rcBorder.top);
			dc.LineTo(rcBorder.right, rcBorder.bottom);
			dc.SelectObject((CPen *)NULL);
		}
	}

	// after the text is drawn, strikethrough in transform color for dropped rows
	if (iRowTransformed == iTransformDrop)
	{
		dc.SelectObject(m_penTransform);
		dc.MoveTo(pDraw->rcItem.left,  (pDraw->rcItem.top+pDraw->rcItem.bottom)/2);
		dc.LineTo(pDraw->rcItem.right, (pDraw->rcItem.top+pDraw->rcItem.bottom)/2);
		dc.SelectObject((CPen *)NULL);
	}
	else if (iRowTransformed == iTransformAdd)
	{
		RECT rcBorder = pDraw->rcItem;
		rcBorder.bottom-=1;
		CBrush brshNull;
		brshNull.CreateStockObject(NULL_BRUSH);
		dc.SetBkMode(TRANSPARENT);
		dc.SelectObject((CBrush*)&brshNull);
		dc.SelectObject(m_penTransform);
		dc.Rectangle(&rcBorder);
		dc.SelectObject((CPen *)NULL);
		dc.SelectObject((CBrush *)NULL);
	}

	dc.SelectObject((CFont *)NULL);
	dc.Detach();
}	// end of DrawItem

const CString* COrcaListView::GetOutputText(const void *rowdata, int iColumn) const
{
	return NULL;
}

int COrcaListView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	lpCreateStruct->style |= WS_CLIPCHILDREN;
	if (CListView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	CString strFacename = ::AfxGetApp()->GetProfileString(_T("Font"), _T("Name"));
	int iFontSize = ::AfxGetApp()->GetProfileInt(_T("Font"),_T("Size"), 0);
	if (strFacename.IsEmpty() || iFontSize == 0) 
	{
		m_pfDisplayFont = NULL;
	} 
	else
	{
		m_pfDisplayFont = new CFont();
		m_pfDisplayFont->CreatePointFont( iFontSize, strFacename);
	}
	return 0;
}

void COrcaListView::SwitchFont(CString name, int size)
{
	if (m_pfDisplayFont)
		delete m_pfDisplayFont;
	m_pfDisplayFont = new CFont();
	int iLogicalUnits = MulDiv(size, GetDC()->GetDeviceCaps(LOGPIXELSY), 720);
	m_pfDisplayFont->CreateFont(
		-iLogicalUnits,       // logical height of font 
 		0,                  // logical average character width 
 		0,                  // angle of escapement 
 		0,                  // base-line orientation angle 
 		FW_NORMAL,          // FW_DONTCARE??, font weight 
 		0,                  // italic attribute flag 
 		0,                  // underline attribute flag 
	 	0,                  // strikeout attribute flag 
 		0,                  // character set identifier
 		OUT_DEFAULT_PRECIS, // output precision
 		0x40,               // clipping precision (force Font Association off)
 		DEFAULT_QUALITY,    // output quality
 		DEFAULT_PITCH,      // pitch and family
		name);              // pointer to typeface name string

	RedrawWindow();

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	rctrlList.SetFont(m_pfDisplayFont, TRUE);
	HWND hHeader = ListView_GetHeader(rctrlList.m_hWnd);

	// win95 gold fails ListView_GetHeader.
	if (hHeader)
	{
		::PostMessage(hHeader, WM_SETFONT, (UINT_PTR)HFONT(*m_pfDisplayFont), 1);

		RECT rHeader;
		int res = ::GetWindowRect(hHeader, &rHeader);
		m_iRowHeight = rHeader.bottom-rHeader.top;
	}
	else
	{
		TEXTMETRIC tm;
		GetListCtrl().GetDC()->GetTextMetrics(&tm);
		m_iRowHeight = tm.tmHeight+tm.tmExternalLeading;
	}
	
	CRect rDummy;
	rctrlList.GetWindowRect(&rDummy);

	// now we force the CListCtrl to change its row height. Because its fixed owner draw, 
	// it only asks for item sizes on initialization. It doesn't do it on a WM_SIZE message
	// either, only on WM_WINDOWPOSCHANGED. So we fire off two messages. In the first, we shrink
	// the window by one pixel, but deny a redraw. Then we resize back to what it is supposed to
	// be and ask for a redraw.
	rctrlList.SetWindowPos(this, 0, 0, rDummy.right-rDummy.left, rDummy.bottom-rDummy.top-1, 
		SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);
	rctrlList.SetWindowPos(this, 0, 0, rDummy.right-rDummy.left, rDummy.bottom-rDummy.top, 
		SWP_NOZORDER | SWP_NOMOVE);
};

void COrcaListView::GetFontInfo(LOGFONT *data)
{
	ASSERT(data);
	if (m_pfDisplayFont)
		m_pfDisplayFont->GetLogFont(data);
	else
		GetListCtrl().GetFont()->GetLogFont(data);
}


afx_msg void COrcaListView::MeasureItem ( LPMEASUREITEMSTRUCT lpMeasureItemStruct )
{
	lpMeasureItemStruct->itemHeight = m_iRowHeight;
}

void COrcaListView::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	// try to set full row select
	// add gridlines and full row select
	GetListCtrl().SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);

	m_clrSelected =	::AfxGetApp()->GetProfileInt(_T("Colors"),_T("SelectBg"), RGB(0,0,255));
	m_clrFocused = ::AfxGetApp()->GetProfileInt(_T("Colors"),_T("FocusBg"), RGB(255,255,0));
	m_clrNormal = ::AfxGetApp()->GetProfileInt(_T("Colors"),_T("NormalBg"), RGB(255,255,255));
	m_clrSelectedT =	::AfxGetApp()->GetProfileInt(_T("Colors"),_T("SelectFg"), RGB(255,255,255));
	m_clrFocusedT = ::AfxGetApp()->GetProfileInt(_T("Colors"),_T("FocusFg"), RGB(0,0,0));
	m_clrNormalT = ::AfxGetApp()->GetProfileInt(_T("Colors"),_T("NormalFg"), RGB(0,0,0));
	m_brshNormal.Detach();
	m_brshNormal.CreateSolidBrush(m_clrNormal);
	m_brshSelected.CreateSolidBrush(m_clrSelected);
	m_brshFocused.CreateSolidBrush(m_clrFocused);
	m_penTransform.CreatePen(PS_SOLID | PS_INSIDEFRAME, 2, m_clrTransform);
	GetListCtrl().SetBkColor(m_clrNormal);

	// get list control
	if (m_pfDisplayFont)
		GetListCtrl().SetFont(m_pfDisplayFont, TRUE);
	GetListCtrl().RedrawWindow();
	HWND hHeader = ListView_GetHeader(GetListCtrl().m_hWnd);

	// win9X gold doesn't support ListView_GetHeader. Instead, we'll
	// get the font mentrics and use the height and external leading for the
	// size. This is not as accurate as getting the listview header, because
	// we can't correctly get the size of the 3D outline of the listview header, but
	// its better than crashing (which is what we used to do), and is generally pretty
	// close. We add a couple pixels to the height in the hope of not clobbering 
	// the listview header.
	if (hHeader != 0)
	{
		RECT rHeader;
		int res = ::GetWindowRect(hHeader, &rHeader);
		m_iRowHeight = rHeader.bottom-rHeader.top;
	}
	else
	{
		TEXTMETRIC tm;
		GetListCtrl().GetDC()->GetTextMetrics(&tm);
		m_iRowHeight = tm.tmHeight+tm.tmExternalLeading;
	}
}

void COrcaListView::SetBGColors(COLORREF norm, COLORREF sel, COLORREF focus)
{
	CListCtrl& rctrlList = GetListCtrl();
	rctrlList.SetBkColor(norm);
	m_clrNormal = norm;
	m_clrSelected = sel;
	m_clrFocused = focus;
	m_brshNormal.Detach();
	m_brshNormal.CreateSolidBrush(m_clrNormal);
	m_brshSelected.CreateSolidBrush(m_clrSelected);
	m_brshFocused.CreateSolidBrush(m_clrFocused);
}

void COrcaListView::SetFGColors(COLORREF norm, COLORREF sel, COLORREF focus)
{
	CListCtrl& rctrlList = GetListCtrl();
	rctrlList.SetBkColor(norm);
	m_clrNormalT = norm;
	m_clrSelectedT = sel;
	m_clrFocusedT = focus;	
}

// these functions emulate VC6.0 functionality in VC5.0 or earlier
// these position pointers are NOT compatible with CListCtrl POSITION
// values.
POSITION COrcaListView::GetFirstSelectedItemPosition( ) const 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
#if _MFC_VER >= 0x0600
	return rctrlList.GetFirstSelectedItemPosition();
#else

	if (rctrlList.GetSelectedCount() == 0) return NULL;
	int iMaxItems = rctrlList.GetItemCount();
	for (int i=0; i < iMaxItems; i++) {
		if (rctrlList.GetItemState(i, LVIS_SELECTED))
		{
			return (POSITION)(i+1);
		};
	};
	return NULL;
#endif
}

int COrcaListView::GetNextSelectedItem( POSITION& pos ) const 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

#if _MFC_VER >= 0x0600
	return rctrlList.GetNextSelectedItem(pos);
#else

	int iSelItem = (int)pos - 1;
	int iMaxItems = rctrlList.GetItemCount();
	for (int i=(int)pos; i < iMaxItems; i++) {
		if (rctrlList.GetItemState(i, LVIS_SELECTED))
		{
			pos = (POSITION)(i+1);
			return iSelItem;
		};
	};
	pos = NULL;
	return iSelItem;	
#endif
}

BOOL COrcaListView::PreCreateWindow(CREATESTRUCT& cs) 
{												   
	cs.style = (cs.style | LVS_REPORT | LVS_OWNERDRAWFIXED | LVS_SHOWSELALWAYS) & ~LVS_ICON;
	return CListView::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////
// OnUpdateErrors
// GetErrorState() is virtual, so the same check will work for both
// the list view and the table view. 
void COrcaListView::OnUpdateErrors(CCmdUI* pCmdUI) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the row and data
	int iFocusedItem = GetFocusedItem();
	if ((iFocusedItem < 0) || (m_nSelCol < 0))
		pCmdUI->Enable(FALSE);
	else
	{
		void* pData = reinterpret_cast<void *>(rctrlList.GetItemData(iFocusedItem));
		ASSERT(pData);
		pCmdUI->Enable(OK != GetErrorState(pData, m_nSelCol));
	};
}

///////////////////////////////////////////////////////////////////////
// GetFocusedItem()
// searches the list for the item which currently has the focus
const int COrcaListView::GetFocusedItem() const
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	int iNumItems = rctrlList.GetItemCount();

	for (int i=0; i < iNumItems; i++) {
		if (rctrlList.GetItemState(i, LVIS_FOCUSED) != 0)
			return i;
	}
	return -1;
}

///////////////////////////////////////////////////////////////////////
// each row in the list view is owner draw and fills the entire client
// rectangle for the item. The only background that needs to be erased
// is what is below and to the right of the item areas.
afx_msg BOOL COrcaListView::OnEraseBkgnd( CDC* pDC )
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	
	// determine client window size
	RECT rClientWnd;
	GetClientRect(&rClientWnd);

	// calculate how far over the control will draw
	int iColumnWidth = 0;
	for (int i = 0; i < m_cColumns; i++)
		iColumnWidth += rctrlList.GetColumnWidth(i);

	// if there is still extra space on the right, draw there
	if (iColumnWidth < rClientWnd.right)
	{
		rClientWnd.left = iColumnWidth;

		// Set brush to desired background color and fill the space
		pDC->FillRect(&rClientWnd, &m_brshNormal);
	}

	// check for extra space on the bottom
	int iHeight = (rctrlList.GetItemCount()-GetScrollPos(SB_VERT))*m_iRowHeight;

	// reset the rectangle to paint below the active items, but
	// only as far over as the items would have drawn
	if (iHeight < rClientWnd.bottom)
	{
		rClientWnd.left = 0;
		rClientWnd.right = iColumnWidth;
		rClientWnd.top = iHeight;

		// Set brush to desired background color and fill the space
		pDC->FillRect(&rClientWnd, &m_brshNormal);
	}

	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\orca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// Orca.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Orca.h"

#include "MainFrm.h"
#include "OrcaDoc.h"
#include "TableVw.h"

#include "cmdline.h"
#include "HelpD.h"
#include "cnfgmsmd.h"

#include <initguid.h>

#include "..\common\utils.h"
#include "..\common\query.h"
#include "domerge.h"

#include "version.h"
                                 
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// updates media table
UINT UpdateMediaTable(LPCTSTR szDatabase);

/////////////////////////////////////////////////////////////////////////////
// COrcaApp

BEGIN_MESSAGE_MAP(COrcaApp, CWinApp)
	//{{AFX_MSG_MAP(COrcaApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COrcaApp construction

COrcaApp::COrcaApp()
{
	m_hSchema = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only COrcaApp object

COrcaApp theApp;

/////////////////////////////////////////////////////////////////////////////
// COrcaApp initialization



BOOL COrcaApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// allow COM
	::CoInitialize(NULL);

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Microsoft"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(COrcaDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CTableView));
	AddDocTemplate(pDocTemplate);

	EnableShellOpen();
	RegisterShellFileTypes(FALSE);
	
	// Parse command line for standard shell commands, DDE, file open
	COrcaCommandLine cmdInfo;
	ParseCommandLine(cmdInfo);

	UINT iResult;
	if (cmdInfo.m_nShellCommand == CCommandLineInfo::FileNothing)
	{
		 if (iExecuteMerge == cmdInfo.m_eiDo)
		{
			if (cmdInfo.m_strFileName.IsEmpty())
			{
				AfxMessageBox(_T("A MSI Database must be specifed to merge into."), MB_ICONSTOP);
				return FALSE;
			}

			if (cmdInfo.m_strExecuteModule.IsEmpty())
			{
				AfxMessageBox(_T("You must specify a Merge Module to merge in."), MB_ICONSTOP);
				return FALSE;
			}

			if (cmdInfo.m_strFeatures.IsEmpty())
			{
				AfxMessageBox(_T("A Feature must be specified to Merge Module to."), MB_ICONSTOP);
				return FALSE;
			}

			UINT iResult = ExecuteMergeModule(cmdInfo);

			// if we're good and not quite and we were to commit
			if (!cmdInfo.m_bQuiet &&
				((ERROR_SUCCESS == iResult && cmdInfo.m_bCommit) || cmdInfo.m_bForceCommit))
			{
				if (IDYES == AfxMessageBox(_T("Would you like to open the new MSI Database in Orca?"), MB_YESNO|MB_ICONINFORMATION))
					cmdInfo.m_nShellCommand = CCommandLineInfo::FileOpen;
			}
		}
		else if (iHelp == cmdInfo.m_eiDo)	// show help
		{
			CHelpD dlg;
			dlg.DoModal();
		}
		else
			AfxMessageBox(_T("Unknown command line operation."), MB_ICONSTOP);
	}

	// if command line has been set to do something
	if (cmdInfo.m_nShellCommand != CCommandLineInfo::FileNothing)
	{
		CString strPrompt;
		m_strSchema = cmdInfo.m_strSchema;

		// find the schema database
		iResult = FindSchemaDatabase(m_strSchema);
		if (ERROR_SUCCESS != iResult)
		{
			strPrompt.Format(_T("Fatal Error: Failed to locate schema database: '%s'"), m_strSchema);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return FALSE;
		}

		// open the schema database
		iResult = MsiOpenDatabase(m_strSchema, MSIDBOPEN_READONLY, &m_hSchema);
		if (ERROR_SUCCESS != iResult)
		{
			strPrompt.Format(_T("Fatal Error: Failed to load schema database: '%s'"), m_strSchema);
			AfxMessageBox(strPrompt, MB_ICONSTOP);
			return FALSE;
		}

		// Dispatch commands specified on the command line
		if (!ProcessShellCommand(cmdInfo))
			return FALSE;

		// if we have open a document from the command line and it is read only,
		// we have to manually set the title, because the MFC framework will
		// override what we did in OpenDocument()
		if (m_pMainWnd)
		{
			COrcaDoc *pDoc = static_cast<COrcaDoc *>(static_cast<CMainFrame *>(m_pMainWnd)->GetActiveDocument());
			ASSERT(pDoc);
			if (pDoc)
			{
				if ((pDoc->m_eiType == iDocDatabase) && pDoc->TargetIsReadOnly())
					pDoc->SetTitle(pDoc->GetTitle() + _T(" (Read Only)"));
			}

			// allowthe main window to accept files
			m_pMainWnd->DragAcceptFiles(TRUE);
		
			// The one and only window has been initialized, so show and update it.
			m_pMainWnd->ShowWindow(SW_SHOW);
			if (pDoc)
				pDoc->UpdateAllViews(NULL, HINT_RELOAD_ALL, NULL);
			m_pMainWnd->UpdateWindow();
		}
	}

	return (cmdInfo.m_nShellCommand != CCommandLineInfo::FileNothing);
}	// end of InitInstance

int COrcaApp::ExitInstance() 
{
	// if the schema database is open close it
	if (m_hSchema)
	{
		MsiCloseHandle(m_hSchema);
		m_strSchema = _T("");
	}

	// if any binary data has been placed in temp file, we can remove it because
	// no other app knows what to do with it.
	while (m_lstClipCleanup.GetCount())
		DeleteFile(m_lstClipCleanup.RemoveHead());

	// also cleanup any temporary files possibly left over
	while (m_lstTempCleanup.GetCount())
		DeleteFile(m_lstTempCleanup.RemoveHead());

	::CoUninitialize();	// uninitialize COM
	
	return CWinApp::ExitInstance();
}

///////////////////////////////////////////////////////////
// FindSchemaDatabase
UINT COrcaApp::FindSchemaDatabase(CString& rstrSchema)
{
	UINT iResult = ERROR_FUNCTION_FAILED;	// assume it won't be found
	DWORD dwAttrib;

	// if something was specified on the command line, check there
	if (!rstrSchema.IsEmpty())
	{
		dwAttrib = GetFileAttributes(rstrSchema);

		// if its a directory, look in there 
		if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
		{
			rstrSchema += _T("\\Orca.Dat");
			dwAttrib = GetFileAttributes(rstrSchema);
		}

		// if not a directory and not invalid
		if (!(0xFFFFFFFF == dwAttrib || (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)))
			return ERROR_SUCCESS;
	}

	// either the above failed or nothing was given to us. Try the registry
	rstrSchema = GetProfileString(_T("Path"), _T("OrcaDat"), _T(""));
	if (!rstrSchema.IsEmpty())
	{
		dwAttrib = GetFileAttributes(rstrSchema);

		// if its a directory, look in there 
		if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
		{
			rstrSchema += _T("\\Orca.DAT");
			dwAttrib = GetFileAttributes(rstrSchema);
		}

		// if not a directory and not invalid
		if (0xFFFFFFFF == dwAttrib || (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
			return ERROR_SUCCESS;
	}

	// so far, no luck. Now search the search path.
	TCHAR *strPath = rstrSchema.GetBuffer(MAX_PATH);
	TCHAR *unused;
	DWORD length = SearchPath(NULL, _T("ORCA.DAT"), NULL, MAX_PATH, strPath, &unused);
	if (length > MAX_PATH) {
		strPath = rstrSchema.GetBuffer(MAX_PATH);
		SearchPath(NULL, _T("ORCA.DAT"), NULL, MAX_PATH, strPath, &unused);
	}
	if (length != 0) {
		rstrSchema.ReleaseBuffer();
		return ERROR_SUCCESS;
	}

	// not found
	return ERROR_FUNCTION_FAILED;
}	// end of FindSchemaDatabase

///////////////////////////////////////////////////////////
// ExecuteMergeModule
UINT COrcaApp::ExecuteMergeModule(COrcaCommandLine &cmdInfo) 
{
	short iLanguage = -1;

	// determine what language to use. If specified, use it, otherwise 
	// get from summaryinfo stream
	if (!cmdInfo.m_strLanguage.IsEmpty())
	{
		// parse for the number
		if (_istdigit(cmdInfo.m_strLanguage[0]))
			iLanguage = static_cast<short>(_ttoi(cmdInfo.m_strLanguage));
		
		// if no language specified
		if (iLanguage == -1)
			return ERROR_FUNCTION_FAILED;
	}
	
	CMsmConfigCallback CallbackInfo;
	if (!cmdInfo.m_strConfigFile.IsEmpty())
	{
		if (!CallbackInfo.ReadFromFile(cmdInfo.m_strConfigFile))
		{
			AfxMessageBox(_T("Could not open or read the configuration file."), MB_ICONSTOP);
			return ERROR_FUNCTION_FAILED;
		}
	}

	eCommit_t eCommit = (cmdInfo.m_bForceCommit ? commitForce : (cmdInfo.m_bCommit ? commitYes : commitNo));
	UINT iResult = ::ExecuteMerge(cmdInfo.m_bQuiet ? (LPMERGEDISPLAY)NULL : &OutputMergeDisplay, 
		cmdInfo.m_strFileName, cmdInfo.m_strExecuteModule, cmdInfo.m_strFeatures, iLanguage, 
		cmdInfo.m_strRedirect, cmdInfo.m_strExtractCAB, cmdInfo.m_strExtractDir, cmdInfo.m_strExtractImage, 
		cmdInfo.m_strLogFile, false, cmdInfo.m_bLFN, &CallbackInfo, NULL, eCommit);

	// update the media table real quick
	if (SUCCEEDED(iResult) &&
		(ERROR_SUCCESS != UpdateMediaTable(cmdInfo.m_strFileName)))
		return ERROR_SUCCESS;

	return iResult;
}	// end of ExecuteMergeModule

///////////////////////////////////////////////////////////
// UpdateMediaTable
UINT UpdateMediaTable(LPCTSTR szDatabase)
{
	UINT iResult;
	PMSIHANDLE hDatabase;
	if (ERROR_SUCCESS != (iResult = MsiOpenDatabase(szDatabase, MSIDBOPEN_TRANSACT, &hDatabase)))
		return iResult;

	int iMaxSequence = -1;
	CQuery queryDatabase;
	if (ERROR_SUCCESS != (iResult = queryDatabase.OpenExecute(hDatabase, NULL, _T("SELECT `Sequence` FROM `File`"))))
		return iResult;

	int iSequence;
	PMSIHANDLE hRecFile;
	while (ERROR_SUCCESS == (iResult = queryDatabase.Fetch(&hRecFile)))
	{
		iSequence = MsiRecordGetInteger(hRecFile, 1);

		if (iSequence > iMaxSequence)
			iMaxSequence = iSequence;
	}

	// if something went wrong bail
	if (ERROR_NO_MORE_ITEMS != iResult)
		return iResult;

	// close the query to prepare for the next one
	queryDatabase.Close();

	if (ERROR_SUCCESS != (iResult = queryDatabase.OpenExecute(hDatabase, NULL, _T("SELECT `LastSequence` FROM `Media`"))))
		return iResult;

	PMSIHANDLE hRecMedia;
	iResult = queryDatabase.Fetch(&hRecMedia);

	// if a record was retrieved
	if (hRecMedia)
	{
		MsiRecordSetInteger(hRecMedia, 1, iMaxSequence);
		iResult = queryDatabase.Modify(MSIMODIFY_UPDATE, hRecMedia);
	}

	if (ERROR_SUCCESS == iResult)
		iResult = MsiDatabaseCommit(hDatabase);

	return iResult;
}	// end of UpdateMediaTable

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	CString	m_strVersion;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	m_strVersion = _T("");
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	DDX_Text(pDX, IDC_VERSIONSTRING, m_strVersion);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void COrcaApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.m_strVersion = CString(_T("Orca Version ")) + GetOrcaVersion();
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// COrcaApp commands

void COrcaApp::OutputMergeDisplay(const BSTR bstrOut)
{
	wprintf(bstrOut);
}

CString COrcaApp::GetOrcaVersion()
{
	// create string containing the version number
	CString strVersion;
	strVersion.Format(_T("%d.%2d.%4d.%d"), rmj, rmm, rup, rin);
	return strVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\otrace.cpp ===
#include "..\common\trace.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\orca_res.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Orca.rc
//
#define IDD_ABOUTBOX                    100
#define ID_PAGE_FONT                    106
#define IDR_MAINFRAME                   128
#define IDR_ORCATYPE                    129
#define IDR_MAINFRAME2                  129
#define IDD_HELP_DIALOG                 131
#define IDD_SUMMARY_INFORMATION         132
#define IDD_VALIDATION                  134
#define IDD_ADD_TABLE                   135
#define IDD_ADD_ROW                     136
#define IDR_POPUP_MENU                  138
#define IDD_EXPORT_TABLE                138
#define IDD_TABLE_ERROR                 139
#define IDD_CELL_ERROR                  140
#define IDD_BINARY_EDIT                 141
#define IDD_PAGE_VALIDATION             142
#define IDD_PAGE_PATHS                  143
#define IDB_KEY                         145
#define IDD_DLGPREVIEW                  148
#define IDB_PRVWIMAGES                  150
#define IDB_REQUIRED                    151
#define IDD_IMPORT_TABLE                152
#define IDR_CELL_POPUP                  153
#define IDR_LIST_POPUP                  154
#define IDD_MERGE                       155
#define IDD_CONFIGUREMSM                156
#define IDD_MERGERESULTS                157
#define IDD_PAGE_MSM                    158
#define IDD_MERGEFAILURE                159
#define IDD_TRANSFORM_PROPERTIES        160
#define IDR_HEADER_POPUP                161
#define IDC_OPEN                        1002
#define IDC_TITLE                       1003
#define IDC_SUBJECT                     1004
#define IDC_PLATFORM                    1005
#define IDC_COMMENTS                    1006
#define IDC_TYPE                        1007
#define IDC_LANGUAGES                   1008
#define IDC_OUTPUT                      1008
#define IDC_AUTHOR                      1009
#define IDC_EVALUATION_FILE             1009
#define IDC_KEYWORDS                    1010
#define IDC_GO                          1010
#define IDC_PRODUCTID                   1011
#define IDC_LIST_TABLES                 1011
#define IDC_SCHEMA                      1012
#define IDC_WRITETOFILE                 1013
#define IDC_SECURITY                    1014
#define IDC_VALMINOR                    1014
#define IDC_SHOW_INFO                   1015
#define IDC_VALUPDATE                   1015
#define IDC_OUTPUT_DIR                  1016
#define IDC_BROWSE                      1017
#define IDC_SELECT_ALL                  1018
#define IDC_TABLE_LIST                  1019
#define IDC_TABLE                       1020
#define IDC_ERRORS                      1021
#define IDC_WARNINGS                    1022
#define IDC_ICE                         1023
#define IDC_DESC                        1028
#define IDC_WEB_HELP                    1029
#define IDC_PATH                        1030
#define IDC_ACTION                      1032
#define IDC_CLEAR_ALL                   1033
#define IDC_INVERT                      1034
#define IDC_FONTNAME                    1036
#define IDC_CHFONT                      1037
#define IDC_COLORSEL                    1040
#define IDC_COLORFOCUS                  1041
#define IDC_COLORNORM                   1042
#define IDC_CHECK2                      1043
#define IDC_SUPPRESSINFO                1043
#define IDC_ADMIN                       1043
#define IDC_VALLANGUAGE                 1043
#define IDC_SUPPRESSWARNING             1044
#define IDC_VALPRODUCT                  1044
#define IDC_TEXTNORM                    1045
#define IDC_VALDIRB                     1046
#define IDC_ORCADATB                    1046
#define IDC_EXPORTDIR                   1047
#define IDC_VALDIR                      1048
#define IDC_ORCADAT                     1048
#define IDC_VALUPGRADE                  1048
#define IDC_NORMSAMP                    1049
#define IDC_RUNICE                      1049
#define IDC_VALLESS                     1049
#define IDC_SELSAMP                     1050
#define IDC_VALEQUAL                    1050
#define IDC_FOCSAMP                     1051
#define IDC_VALGREATER                  1051
#define IDC_TEXTSEL                     1052
#define IDC_TEXTFOCUS                   1053
#define IDC_CHECK1                      1054
#define IDC_WARNSUMM                    1054
#define IDC_CASESENSITIVE               1054
#define IDC_COMPRESSED                  1054
#define IDC_ADDEXISTINGROW              1054
#define IDC_PREVIEW                     1055
#define IDC_DELMISSINGROW               1055
#define IDC_ADDEXISTINGTABLE            1056
#define IDC_DIALOGLST                   1057
#define IDC_DELMISSINGTABLE             1057
#define IDC_UPDATEMISSINGROW            1058
#define IDC_CHANGECODEPAGE              1059
#define IDC_PREVIOUS                    1060
#define IDC_NEXT                        1061
#define IDC_EXPORTDIRB                  1064
#define IDC_TABLELIST                   1065
#define IDC_REPLACE                     1066
#define IDC_MERGE                       1067
#define IDC_SKIP                        1068
#define IDC_IMPORT                      1070
#define IDC_SHORT                       1070
#define IDC_CLEARRESULTS                1071
#define IDC_LONG                        1071
#define IDC_ICES                        1072
#define IDC_VERSIONSTRING               1073
#define IDC_CLIPBOARD                   1075
#define IDC_COMPILETEXT                 1076
#define IDC_COMPILEBOX                  1077
#define IDC_FEXTRACTFILES               1078
#define IDC_LANGUAGE                    1079
#define IDC_MAINFEATURE                 1080
#define IDC_MODULE                      1081
#define IDC_MODULEBROWSE                1082
#define IDC_ADDFEATURE                  1083
#define IDC_EXTRACTPATH                 1084
#define IDC_EXTRACTCAB                  1085
#define IDC_FILESBROWSE                 1086
#define IDC_CABBROWSE                   1087
#define IDC_ROOTDIR                     1088
#define IDC_FEXTRACTCAB                 1089
#define IDC_FILESTATIC                  1090
#define IDC_CABSTATIC                   1091
#define IDC_ITEMLIST                    1092
#define IDC_DESCRIPTION                 1093
#define IDC_EDITTEXT                    1094
#define IDC_EDITNUMBER                  1095
#define IDC_EDITCOMBO                   1096
#define IDC_FUSEDEFAULT                 1097
#define IDC_CONFIGUREMODULE             1098
#define IDC_FEXTRACTIMAGE               1099
#define IDC_IMAGESTATIC                 1100
#define IDC_IMAGEBROWSE                 1101
#define IDC_EXTRACTIMAGE                1102
#define IDC_MERGERESULTS                1103
#define IDC_MEMORY                      1104
#define IDC_ALWAYSCONFIG                1105
#define IDC_WATCHLOG                    1106
#define IDC_USELFN                      1107
#define IDC_MERGEFAILURE                1108
#define IDC_VALMAJOR                    1109
#define IDC_TRANSFORMLIST               1110
#define IDC_FORCECOLUMNS                1111
#define IDC_WARNINGSTATIC               1112
#define IDC_ERRORSTATIC                 1113
#define ID_VIEW_DECIMAL_HDR             32766
#define ID_VIEW_HEX_HDR                 32767
#define ID_VIEW_DECIMAL                 32768
#define ID_VIEW_HEX                     32769
#define ID_TOOLS_MERGEMOD               32770
#define ID_VALIDATOR                    32775
#define ID_SUMMARY_INFORMATION          32776
#define ID_TABLE_ADD                    32777
#define ID_ROW_ADD                      32779
#define ID_MENUITEM32780                32780
#define ID_TABLE_DROP                   32781
#define ID_ROW_DROP                     32782
#define ID_FIND                         32783
#define IDM_ADD_TABLE                   32784
#define IDM_DROP_TABLE                  32785
#define IDM_DROP_ROW                    32787
#define IDM_PROPERTIES                  32788
#define IDM_ERRORS                      32789
#define ID_TABLES_EXPORT                32790
#define ID_TABLES_IMPORT                32791
#define IDM_EXPORT_TABLES               32792
#define ID_EDIT_COPY_ROW                32793
#define ID_EDIT_CUT_ROW                 32794
#define ID_EDIT_PASTE_ROW               32795
#define ID_TOOLS_OPTIONS                32796
#define ID_TOOLS_DLGPRV                 32797
#define IDM_IMPORT_TABLES               32798
#define ID_EDIT_FINDNEXT                32801
#define ID_TABLE_COUNT                  32802
#define ID_TABLE_NAME                   32803
#define ID_COLUMN_TYPE                  32804
#define ID_TOOLS_APPLYTRANSFORM         32806
#define ID_TRANSFORM_NEWTRANSFORM       32808
#define ID_TRANSFORM_APPLYTRANSFORM     32809
#define ID_TRANSFORM_GENERATETRANSFORM  32810
#define ID_TRANSFORM_TRANSFORMPROPERTIES 32812
#define ID_TRANSFORM_CLOSETRANSFORM     32814
#define ID_TRANSFORM_VIEWPATCH          32815
#define ID_FILE_SAVE_TRANSFORMED        32816
#define ID_VIEW_VALPANE                 32817

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        162
#define _APS_NEXT_COMMAND_VALUE         32818
#define _APS_NEXT_CONTROL_VALUE         1114
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\orcalstv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_ORCALISTVIEW_H__68AFD211_2594_11D2_8888_00A0C981B015__INCLUDED_)
#define AFX_ORCALISTVIEW_H__68AFD211_2594_11D2_8888_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OrcaListView.h : header file
//

#include "OrcaDoc.h"

/////////////////////////////////////////////////////////////////////////////
// COrcaListView view

class COrcaListView : public CListView
{
protected:
	COrcaListView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(COrcaListView)

// Attributes
public:
	int m_cColumns;
	bool m_bDrawIcons;

// Operations
public:
	void SetBGColors(COLORREF norm, COLORREF sel, COLORREF focus);
	void SetFGColors(COLORREF norm, COLORREF sel, COLORREF focus);
	void GetFontInfo(LOGFONT *data);

	void GetAllMaximumColumnWidths(const COrcaTable* pTable, int rgiMaxWidths[32], DWORD dwMask) const;
	int GetMaximumColumnWidth(int iColumn) const;

	virtual void SwitchFont(CString name, int size);

	enum ErrorState { OK, Error, Warning, ShadowError };
	COLORREF m_clrFocused;
	COLORREF m_clrSelected;
	COLORREF m_clrNormal;
	COLORREF m_clrTransform;
	COLORREF m_clrFocusedT;
	COLORREF m_clrSelectedT;
	COLORREF m_clrNormalT;
	CBrush   m_brshNormal;
	CBrush   m_brshSelected;
	CBrush   m_brshFocused;
	CPen     m_penTransform;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COrcaListView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~COrcaListView();
	virtual void DrawItem(LPDRAWITEMSTRUCT pDraw);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	int m_nSelCol;
	//{{AFX_MSG(COrcaListView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void MeasureItem ( LPMEASUREITEMSTRUCT lpMeasureItemStruct );
	afx_msg void OnUpdateErrors(CCmdUI* pCmdUI);
	afx_msg BOOL OnEraseBkgnd( CDC* pDC );

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	COrcaDoc* GetDocument() const;
	CFont* m_pfDisplayFont;

	POSITION GetFirstSelectedItemPosition( ) const;
	int GetNextSelectedItem( POSITION& pos ) const;
	const int GetFocusedItem() const;

public:
	int m_iRowHeight;
private:

	virtual ErrorState GetErrorState(const void *data, int iColumn) const;
	virtual const CString *GetOutputText(const void *data, int iColumn) const;
	virtual OrcaTransformAction GetItemTransformState(const void *data) const;
	virtual OrcaTransformAction GetCellTransformState(const void *data, int iColumn) const;
	virtual OrcaTransformAction GetColumnTransformState(int iColumn) const;


	virtual bool ContainsTransformedData(const void *data) const;
	virtual bool ContainsValidationErrors(const void *data) const;
};

#ifndef _DEBUG  // debug version in TableVw.cpp
inline COrcaDoc* COrcaListView::GetDocument() const { return (COrcaDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

const int g_iMarkingBarMargin = 13;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORCALISTVIEW_H__68AFD211_2594_11D2_8888_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\pathpp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// PagePaths.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "PathPP.h"
#include "FolderD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPathPropPage property page

IMPLEMENT_DYNCREATE(CPathPropPage, CPropertyPage)

CPathPropPage::CPathPropPage() : CPropertyPage(CPathPropPage::IDD)
{
	//{{AFX_DATA_INIT(CPathPropPage)
	m_strExportDir = _T("");
	m_strOrcaDat = _T("");
	//}}AFX_DATA_INIT
	m_bPathChange = false;
}

CPathPropPage::~CPathPropPage()
{
}

void CPathPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPathPropPage)
	DDX_Text(pDX, IDC_ORCADAT, m_strOrcaDat);
	DDX_Text(pDX, IDC_EXPORTDIR, m_strExportDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPathPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CPathPropPage)
	ON_BN_CLICKED(IDC_ORCADATB, OnOrcaDatb)
	ON_BN_CLICKED(IDC_EXPORTDIRB, OnExportDirb)
	ON_EN_CHANGE(IDC_ORCADAT, OnChangeOrcaDat)
	ON_EN_CHANGE(IDC_EXPORTDIR, OnChangeExportdir)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPathPropPage message handlers

void CPathPropPage::OnOrcaDatb() 
{
	CFileDialog *dCUB = new CFileDialog(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, 
		_T("Orca DAT files (Orca.dat)|Orca.dat|All Files (*.*)|*.*||"), this);

	if (IDOK == dCUB->DoModal()) {
		m_strOrcaDat = dCUB->GetPathName();
		m_bPathChange = true;
		UpdateData(FALSE);
	}
	delete dCUB;
}

void CPathPropPage::OnExportDirb() 
{
	CFolderDialog dlg(this->m_hWnd, _T("Select a directory to Export to."));

	if (IDOK == dlg.DoModal())
	{
		// update the dialog box
		m_strExportDir = dlg.GetPath();
		m_bPathChange = true;
		UpdateData(FALSE);
	}
}

void CPathPropPage::OnExportbr() 
{
/*    BROWSEINFO bi;
	TCHAR szDir[MAX_PATH];
    LPITEMIDLIST pidl;
	LPMALLOC pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
	{
        ZeroMemory(&bi,sizeof(bi));
        bi.hwndOwner = NULL;
        bi.pszDisplayName = 0;
        bi.pidlRoot = 0;
        bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT;
        bi.lpfn = NULL;
        pidl = SHBrowseForFolder(&bi);
        if (pidl) 
		{
           if (SHGetPathFromIDList(pidl,szDir)) 
		   {
              m_strExportDir = szDir;
			  UpdateData(FALSE);
		   }   
			pMalloc->Free(pidl); pMalloc->Release();
		}         
	} 
	return 0;      */
};

void CPathPropPage::OnChangeOrcaDat() 
{
	m_bPathChange = true;	
}

void CPathPropPage::OnChangeExportdir() 
{	
	m_bPathChange = true;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\pathpp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_PAGEPATHS_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_)
#define AFX_PAGEPATHS_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PagePaths.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPagePaths dialog

class CPathPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CPathPropPage)

// Construction
public:
	bool m_bPathChange;
	CPathPropPage();
	~CPathPropPage();

// Dialog Data
	//{{AFX_DATA(CPagePaths)
	enum { IDD = IDD_PAGE_PATHS };
	CString	m_strOrcaDat;
	CString	m_strExportDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPagePaths)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPagePaths)
	afx_msg void OnOrcaDatb();
	afx_msg void OnExportDirb();
	afx_msg void OnExportbr();
	afx_msg void OnChangeOrcaDat();
	afx_msg void OnChangeExportdir();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PAGEPATHS_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\prvwdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// PrvwDlg.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "PrvwDlg.h"
#include "row.h"
#include "data.h"
#include "..\common\query.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPreviewDlg dialog


CPreviewDlg::CPreviewDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPreviewDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPreviewDlg)
	//}}AFX_DATA_INIT
}


void CPreviewDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPreviewDlg)
	DDX_Control(pDX, IDC_PREVIEW, m_ctrlPreviewBtn);
	DDX_Control(pDX, IDC_DIALOGLST, m_ctrlDialogLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPreviewDlg, CDialog)
	//{{AFX_MSG_MAP(CPreviewDlg)
	ON_BN_CLICKED(IDC_PREVIEW, OnPreview)
	ON_WM_DESTROY()
	ON_NOTIFY(TVN_SELCHANGED, IDC_DIALOGLST, OnSelchangedDialoglst)
	ON_NOTIFY(TVN_ITEMEXPANDED, IDC_DIALOGLST, OnItemexpandedDialoglst)
	ON_NOTIFY(NM_DBLCLK, IDC_DIALOGLST, OnDblclkDialoglst)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreviewDlg message handlers

void CPreviewDlg::OnPreview() 
{
	CWaitCursor curWait;
	if (m_hPreview != 0) {
		HTREEITEM hItem = m_ctrlDialogLst.GetSelectedItem();
		if (NULL == hItem) return;

		if (m_ctrlDialogLst.GetItemData(hItem) == 1) {
			CString strName = m_ctrlDialogLst.GetItemText(hItem);
			// get the currently selected Dialog 
			MsiPreviewDialog(m_hPreview, _T(""));
			MsiPreviewDialog(m_hPreview, strName);
		}
	}
}

BOOL CPreviewDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	if (ERROR_SUCCESS != MsiEnableUIPreview(m_hDatabase, &m_hPreview)) {
		m_hPreview = 0;
	}

	PMSIHANDLE hDialogRec;
	PMSIHANDLE hControlRec;
	CQuery qDialog;
	CQuery qControl;

	m_imageList.Create(16,16,ILC_COLOR, 2, 1);
	CBitmap	bmImages;
	bmImages.LoadBitmap(IDB_PRVWIMAGES);
	m_imageList.Add(&bmImages, COLORREF(0));
	m_ctrlDialogLst.SetImageList(&m_imageList, TVSIL_NORMAL);

	qDialog.OpenExecute(m_hDatabase, NULL, _T("SELECT `Dialog`.`Dialog` FROM `Dialog`"));
	qControl.Open(m_hDatabase, _T("SELECT `Control_`,`Event`,`Argument` FROM `ControlEvent` WHERE `Dialog_`=?"));


	while (ERROR_SUCCESS == qDialog.Fetch(&hDialogRec)) 
	{
		UINT iStat;
		// get the dialog name
		CString strName;
		unsigned long cchName = 80;
		LPTSTR pszName = strName.GetBuffer(cchName);
		iStat = ::MsiRecordGetString(hDialogRec, 1, pszName, &cchName);
		strName.ReleaseBuffer();
		if (ERROR_SUCCESS != iStat)	continue;
	
		HTREEITEM hItem = m_ctrlDialogLst.InsertItem(strName, 1, 1, TVI_ROOT, TVI_SORT);

		// set the item data to 1 to enable preview
		m_ctrlDialogLst.SetItemData(hItem, 1);

		qControl.Execute(hDialogRec);
		while (ERROR_SUCCESS == qControl.Fetch(&hControlRec))
		{
			// get the control name
			CString strControl;
			unsigned long cchControl = 80;
			LPTSTR pszControl = strControl.GetBuffer(cchControl);
			iStat = ::MsiRecordGetString(hControlRec, 1, pszControl, &cchControl);
			strControl.ReleaseBuffer();
			if (ERROR_SUCCESS != iStat)	continue;

 			HTREEITEM hControlItem = m_ctrlDialogLst.InsertItem(strControl, 0, 0, hItem, TVI_SORT);			
			m_ctrlDialogLst.SetItemData(hControlItem, 0);

			// get the type of event
			CString strEvent;
			unsigned long cchEvent = 80;
			LPTSTR pszEvent = strEvent.GetBuffer(cchEvent);
			iStat = ::MsiRecordGetString(hControlRec, 2, pszEvent, &cchEvent);
			strEvent.ReleaseBuffer();
			if (ERROR_SUCCESS != iStat)	continue;

			if ((strEvent == CString(_T("NewDialog"))) ||
				(strEvent  == CString(_T("SpawnDialog"))))
			{

				// get the next dialog name
				unsigned long cchName = 80;
				LPTSTR pszName = strName.GetBuffer(cchName);
				iStat = ::MsiRecordGetString(hControlRec, 3, pszName, &cchName);
				strName.ReleaseBuffer();
				if (ERROR_SUCCESS != iStat)	continue;
			
				HTREEITEM hItem2 = m_ctrlDialogLst.InsertItem(strName, 1, 1, hControlItem, TVI_SORT);

				// set the item data to 1 to enable preview
				m_ctrlDialogLst.SetItemData(hItem2, 1);
			}
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPreviewDlg::OnDestroy() 
{
	CWaitCursor curWait;
	if (m_hPreview != 0) {
		::MsiPreviewDialog(m_hPreview, _T(""));
		::MsiCloseHandle(m_hPreview);
	}
	CDialog::OnDestroy();
}

void CPreviewDlg::OnSelchangedDialoglst(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	m_ctrlPreviewBtn.EnableWindow(pNMTreeView->itemNew.lParam == 1);
	*pResult = 0;
}

void CPreviewDlg::OnItemexpandedDialoglst(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	if (pNMTreeView->action == TVE_EXPAND) {
		HTREEITEM hChild = m_ctrlDialogLst.GetChildItem(pNMTreeView->itemNew.hItem);
		while (hChild != NULL) 
		{
			m_ctrlDialogLst.Expand(hChild, TVE_EXPAND);
			hChild = m_ctrlDialogLst.GetNextSiblingItem(hChild);
		}
	}

	*pResult = 0;
}

void CPreviewDlg::OnDblclkDialoglst(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnPreview();
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\prvwdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_PRVWDLG_H__76314876_2815_11D2_888A_00A0C981B015__INCLUDED_)
#define AFX_PRVWDLG_H__76314876_2815_11D2_888A_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PrvwDlg.h : header file
//
#include "table.h"

/////////////////////////////////////////////////////////////////////////////
// CPreviewDlg dialog

class CPreviewDlg : public CDialog
{
// Construction
public:
	CPreviewDlg(CWnd* pParent = NULL);   // standard constructor

	MSIHANDLE m_hDatabase;

// Dialog Data
	//{{AFX_DATA(CPreviewDlg)
	enum { IDD = IDD_DLGPREVIEW };
	CButton	m_ctrlPreviewBtn;
	CTreeCtrl	m_ctrlDialogLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreviewDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPreviewDlg)
	afx_msg void OnPreview();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangedDialoglst(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemexpandedDialoglst(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkDialoglst(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CImageList m_imageList;
	MSIHANDLE m_hPreview;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRVWDLG_H__76314876_2815_11D2_888A_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\row.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Row.cpp
//

#include "stdafx.h"
#include "orca.h"
#include "Row.h"
#include "Table.h"
#include "..\common\query.h"
#include "OrcaDoc.h"

bool ValidateIntegerValue(const CString& strData, DWORD& dwValue)
{
	if (strData.GetLength() > 2 && strData[0] == '0' && (strData[1] == 'x' || strData[1]=='X'))
	{
		// validate and convert hex
		for (int iChar=2; iChar < strData.GetLength(); iChar++)
		{
			// if a high bit is set, the value is too big.
			if (dwValue & 0xF0000000)
				return false;
			dwValue <<= 4;
			if (strData[iChar] >= '0' && strData[iChar] <= '9')
				dwValue |= strData[iChar]-'0';
			else if (strData[iChar] >= 'A' && strData[iChar] <= 'F')
				dwValue |= (strData[iChar] - 'A' + 10);
			else if (strData[iChar] >= 'a' && strData[iChar] <= 'f')
				dwValue |= (strData[iChar] - 'a' + 10);
			else
				return false;
		}
		return true;
	}

	int i=0; 
	if (strData[0] == '-')
	{
		i++;
	}
	for (; i < strData.GetLength(); i++)
	{
		if (strData[i] < '0' || strData[i] > '9')
			return false;
	}
	dwValue = _ttoi(strData);
	return true;
}


///////////////////////////////////////////////////////////
// constructor
COrcaRow::COrcaRow(COrcaTable *pTable, MSIHANDLE hRecord) : m_pTable(pTable), m_iTransform(iTransformNone), m_dataArray()
{
        int cData = pTable->GetColumnCount();
        m_dataArray.SetSize(cData);

        ReadFromRecord(hRecord, cData);
}       // end of constructor

///////////////////////////////////////////////////////////
// constructor -- 2
COrcaRow::COrcaRow(COrcaTable *pTable, CStringList* pstrList) : m_pTable(pTable), m_iTransform(iTransformNone), m_dataArray()
{
        ASSERT(pTable && pstrList);

    // never more than 32 columns, so OK to cast down
        int cData = static_cast<int>(pTable->GetColumnCount());
        m_dataArray.SetSize(cData);

        const COrcaColumn* pColumn = NULL;
        COrcaData* pData = NULL;
        POSITION pos = pstrList->GetHeadPosition();
        for (int i = 0; i < cData; i++)
        {
                pColumn = pTable->GetColumn(i);

                // possible that we didn't get enough data (especially in transformed rows)
                if (pos)
                {
                        CString strValue = pstrList->GetNext(pos);
                        if (iColumnBinary == pColumn->m_eiType)
                        {
							pData = new COrcaStringData;
                                if (strValue.IsEmpty())
                                {
                                        pData->SetData(_T(""));
                                }
                                else
                                {
                                        pData->SetData(_T("[Binary Data]"));
                                }
                        }
                        else if (iColumnString == pColumn->m_eiType || iColumnLocal == pColumn->m_eiType)
                        {
							pData = new COrcaStringData;
							pData->SetData(strValue);
                        }
						else
						{
							pData = new COrcaIntegerData;
							pData->SetData(strValue);
						}
                }
                m_dataArray.SetAt(i, pData);
        }
}       // end of constructor -- 2

///////////////////////////////////////////////////////////
// constructor -- 3
COrcaRow::COrcaRow(const COrcaRow *pOldRow) : m_pTable(NULL), m_iTransform(iTransformNone), m_dataArray()
{
        ASSERT(pOldRow);

        m_dataArray.SetSize(pOldRow->m_dataArray.GetSize());
        m_pTable = pOldRow->m_pTable;
        m_iTransform = iTransformNone;

        for (int i = 0; i < m_dataArray.GetSize(); i++)
        {
			const COrcaColumn* pColumn = m_pTable->GetColumn(i);
			COrcaData *pOldData = pOldRow->GetData(i);
			COrcaData *pData = NULL;
			if (pColumn->m_eiType == iColumnShort || pColumn->m_eiType == iColumnLong)
			{
				pData = new COrcaIntegerData;
				static_cast<COrcaIntegerData*>(pData)->SetIntegerData(static_cast<COrcaIntegerData*>(pOldData)->GetInteger());
			}
			else
			{
                pData = new COrcaStringData;
				pData->SetData(pOldData->GetString());
			}
			m_dataArray.SetAt(i, pData);
        }
}       // end of constructor -- 3

///////////////////////////////////////////////////////////
// destructor
COrcaRow::~COrcaRow()
{
        m_pTable = NULL;
        DestroyRow();
}       // end of destructor


///////////////////////////////////////////////////////////
// GetErrorCount
int COrcaRow::GetErrorCount() const
{
        int cErrors = 0;

        // clear the data array
        COrcaData* pData;
        INT_PTR cData = m_dataArray.GetSize();
        for (INT_PTR i = 0; i < cData; i++)
        {
                pData = m_dataArray.GetAt(i);

                if (iDataError == pData->GetError())
                        cErrors++;
        }

        return cErrors;
}       // end of GetErrorCount

///////////////////////////////////////////////////////////
// GetWarningCount
int COrcaRow::GetWarningCount() const
{
        int cWarnings = 0;

        // clear the data array
        COrcaData* pData;
        INT_PTR cData = m_dataArray.GetSize();
        for (INT_PTR i = 0; i < cData; i++)
        {
                pData = m_dataArray.GetAt(i);

                if (iDataWarning == pData->GetError())
                        cWarnings++;
        }

        return cWarnings;
}       // end of GetWarningCount

///////////////////////////////////////////////////////////
// ClearErrors
void COrcaRow::ClearErrors()
{
        // clear the data array
        COrcaData* pData;
        INT_PTR cData = m_dataArray.GetSize();
        for (INT_PTR i = 0; i < cData; i++)
        {
                pData = m_dataArray.GetAt(i);
                pData->ClearErrors();
        }
}       // end of ClearErrors

///////////////////////////////////////////////////////////
// DestroyRow
void COrcaRow::DestroyRow()
{
        // destroy the data array
        INT_PTR cData = m_dataArray.GetSize();
        for (INT_PTR i = 0; i < cData; i++)
                delete m_dataArray.GetAt(i);
        m_dataArray.RemoveAll();
}       // end of DestroyRow


void COrcaRow::ReadCellFromRecord(MSIHANDLE hRecord, int cRecData, int iColumn, const COrcaColumn* pColumn, COrcaData** pData) const
{
	if (!pColumn || !pData)
		return;

	if (iColumnBinary == pColumn->m_eiType)
	{
		if (!*pData)
			*pData = new COrcaStringData;
		if (!*pData)
			return;
	
		if (iColumn < cRecData)
		{
			// if the binary data is null, don't display anything in the UI
			if (MsiRecordIsNull(hRecord, iColumn+1))
			{
					(*pData)->SetData(_T(""));
			}
			else
			{
					(*pData)->SetData(_T("[Binary Data]"));
			}
		}
		else
			(*pData)->SetData(_T(""));
	}
	else if (iColumnString == pColumn->m_eiType || iColumnLocal == pColumn->m_eiType)
	{
		if (!*pData)
			*pData = new COrcaStringData;
		if (!*pData)
			return;

		if (iColumn < cRecData)
		{
			CString strData;
	
			UINT iResult = RecordGetString(hRecord, iColumn + 1, strData);
			ASSERT(ERROR_SUCCESS == iResult);
			(*pData)->SetData(strData);
		}
		else
			(*pData)->SetData(_T(""));
	}
	else
	{
		if (!*pData)
			*pData = new COrcaIntegerData;
		if (!*pData)
			return;

		if (iColumn < cRecData)
		{
			if (MsiRecordIsNull(hRecord, iColumn+1))
			{
				(*pData)->SetData(_T(""));
			}
			else
			{
				DWORD dwValue = MsiRecordGetInteger(hRecord, iColumn + 1);
				static_cast<COrcaIntegerData*>(*pData)->SetIntegerData(dwValue);
			}
		}
		else
			(*pData)->SetData(_T(""));
	}
}

void COrcaRow::ReadFromRecord(MSIHANDLE hRecord, int cData)
{
        DWORD cchBuffer;

        COrcaData *pData = NULL;
        const COrcaColumn *pColumn = NULL;
		
		int cRecData = MsiRecordGetFieldCount(hRecord);

        for (int i = 0; i < cData; i++)
        {
                pColumn = m_pTable->GetColumn(i);
                pData = m_dataArray.GetAt(i);

				ReadCellFromRecord(hRecord, cRecData, i, pColumn, &pData);
                if (m_dataArray.GetAt(i) == NULL)
                        m_dataArray.SetAt(i, pData);
        }
}

bool COrcaRow::Find(OrcaFindInfo &FindInfo, int &iCol) const
{
        COrcaData *pData;
        INT_PTR iMax = m_dataArray.GetSize();
        if (iCol == COLUMN_INVALID)
                iCol = (int)(FindInfo.bForward ? 0 : iMax-1);
        
        for ( ; (iCol >= 0) && (iCol < iMax); iCol += (FindInfo.bForward ? 1 : -1))
        {
                pData = m_dataArray.GetAt(iCol);
				const COrcaColumn *pColumn = m_pTable->GetColumn(iCol);
				if (!pColumn)
					continue;
                if (pColumn->m_eiType == iColumnString || pColumn->m_eiType == iColumnLocal)
                {
                        CString strData = pData->GetString();
                        if (!FindInfo.bMatchCase) 
                        {
                                // it is the responsibility of the caller to make strFind all uppercase for
                                // case insensitive search
                                strData.MakeUpper();
                        }
                        if (FindInfo.bWholeWord)
                        {
                                if (strData == FindInfo.strFindString) 
                                        return true;
                        } 
                        else 
                                if (-1 != strData.Find(FindInfo.strFindString))
                                        return true;
                }
        }
        
        iCol = COLUMN_INVALID;
        return false;
}


MSIHANDLE COrcaRow::GetRowRecord(MSIHANDLE hDatabase) const
{
        // setup the query
        CString strQuery;

        strQuery.Format(_T("SELECT * FROM `%s` WHERE "), m_pTable->Name());

        // add the where clause for keys to look up this exact row
        strQuery += m_pTable->GetRowWhereClause();

        CQuery qFetch;
        MSIHANDLE hResult = 0;
        PMSIHANDLE hQueryRec = GetRowQueryRecord();
        if (ERROR_SUCCESS != qFetch.FetchOnce(hDatabase, hQueryRec, &hResult, strQuery))
                return 0;
        return hResult;
}

///////////////////////////////////////////////////////////////////////
// since any arbitrary (non-binary) data can be a primary key, we 
// can't make any assumptions about the parseability of a query built
// with a WHERE clause comparing against literal strings. The WHERE
// clause must use parameter queries. GetRowWhereClause in the table 
// builds up the SQL syntax based on column names, and GetRowQueryRecord 
// creates a record consisting of the primary key values.
MSIHANDLE COrcaRow::GetRowQueryRecord() const
{
        ASSERT(m_pTable);
        if (!m_pTable)
                return 0;

        int cKeys = m_pTable->GetKeyCount();
        MSIHANDLE hRec = MsiCreateRecord(cKeys);

        for (int i=0; i<cKeys; i++)
        {
			COrcaData *pData = m_dataArray.GetAt(i);
			const COrcaColumn *pColumn = m_pTable->GetColumn(i);
			if (pData)
			{
				UINT uiResult = ERROR_SUCCESS;
				if (pColumn->m_eiType == iColumnShort || pColumn->m_eiType == iColumnLong)
				{
					if (pData->IsNull())
					{
						// if the column is not nullable, this just won't ever match anything. Should never
						// get into this state anyway because the cell data should never be set to null
						// unless the column is nullable.
						uiResult = MsiRecordSetString(hRec, i+1, _T(""));
					}
					else
					{
						uiResult = MsiRecordSetInteger(hRec, i+1, static_cast<COrcaIntegerData*>(pData)->GetInteger());
					}
				}
				else
				{
					const CString& rString = pData->GetString();
					uiResult = MsiRecordSetString(hRec, i+1, rString);
				}
				if (ERROR_SUCCESS != uiResult)
				{
					MsiCloseHandle(hRec);
					return 0;
				}
			}
        }

        return hRec;
}

UINT COrcaRow::ChangeData(COrcaDoc *pDoc, UINT iCol, CString strData)
{
        ASSERT(pDoc);
        ASSERT(m_pTable);
        if (!m_pTable || !pDoc)
                return ERROR_FUNCTION_FAILED;

        UINT iResult = 0;

        // setup the query
        CString strQueryA;
        COrcaColumn* pColumn = NULL;
        pColumn = m_pTable->ColArray()->GetAt(iCol);
        ASSERT(pColumn);
        if (!pColumn)
                return ERROR_FUNCTION_FAILED;
        strQueryA.Format(_T("SELECT `%s` FROM `%s` WHERE "), pColumn->m_strName, m_pTable->Name());

        // add the where clause
        strQueryA += m_pTable->GetRowWhereClause();
        PMSIHANDLE hQueryRec = GetRowQueryRecord();
        if (!hQueryRec)
                return ERROR_FUNCTION_FAILED;

        // easier to check a few things ourselves
        if ((!pColumn->m_bNullable) && (strData.IsEmpty())) return MSIDBERROR_REQUIRED;
        if (((pColumn->m_eiType == iColumnLocal) || (pColumn->m_eiType == iColumnString)) && 
                (pColumn->m_iSize != 0) && (strData.GetLength() > pColumn->m_iSize))
                return MSIDBERROR_STRINGOVERFLOW;

        // validate well-formed integer
        DWORD dwIntegerValue = 0;
        if ((pColumn->m_eiType != iColumnString) && (pColumn->m_eiType != iColumnLocal))        
                if (!ValidateIntegerValue(strData, dwIntegerValue))
                        return MSIDBERROR_OVERFLOW;

        // get the one cell out of the database. Don't get whole row, because if there is
        // a stream column in the table, we can't have the stream open and rename any of
        // the primary keys, because the stream will be "in use"
        CQuery queryReplace;

        if (ERROR_SUCCESS != (iResult = queryReplace.OpenExecute(pDoc->GetTargetDatabase(), hQueryRec, strQueryA)))
                return iResult; // bail
        // we have to get that one row, or something is very wrong
        PMSIHANDLE hRec;
        if (ERROR_SUCCESS != (iResult = queryReplace.Fetch(&hRec)))
                return iResult; // bail

        // fail if we can't set the data. Column is always 1 because we only selected that 1 column.
        if ((pColumn->m_eiType == iColumnString) || (pColumn->m_eiType == iColumnLocal))
        {
			iResult = MsiRecordSetString(hRec, 1, strData);
        }
        else
        {
			if (strData.IsEmpty())
			{
				if (!pColumn->m_bNullable)
					return ERROR_FUNCTION_FAILED;
				iResult = MsiRecordSetString(hRec, 1, _T(""));
			}
			else
				iResult = MsiRecordSetInteger(hRec, 1, dwIntegerValue);
        }
        if (ERROR_SUCCESS != iResult)
                return iResult; // bail

        COrcaData* pData = GetData(iCol);
        ASSERT(pData);
        if (!pData)
                return ERROR_FUNCTION_FAILED;

        // check for dupe primary keys
        UINT iStat;
        CString strOldData;
        if (pColumn->IsPrimaryKey()) 
        {
                CQuery queryDupe;
                CString strQueryB;
                strQueryB.Format(_T("SELECT `%s` FROM `%s` WHERE %s"), pColumn->m_strName, m_pTable->Name(), m_pTable->GetRowWhereClause());
                PMSIHANDLE hDupeRec;
                if ((pColumn->m_eiType == iColumnString) || (pColumn->m_eiType == iColumnLocal))
                {
                        MsiRecordSetString(hQueryRec, iCol+1, strData);
                }
                else
                {
					if (strData.IsEmpty())
					{
						// if the column is not nullable, this query will just not find a match, and we should have failed
						// above when setting the data anyway.
						MsiRecordSetString(hQueryRec, iCol+1, _T(""));
					}
					else
					{
						MsiRecordSetInteger(hQueryRec, iCol+1, dwIntegerValue);
					}
                }
                iStat = queryDupe.FetchOnce(pDoc->GetTargetDatabase(), hQueryRec, &hDupeRec, strQueryB);
                switch (iStat) {
                case ERROR_NO_MORE_ITEMS :
                        break;
                case ERROR_SUCCESS :
                        return MSIDBERROR_DUPLICATEKEY;
                default:
                        return ERROR_FUNCTION_FAILED;
                }
        } // primary key
        else
        {
                // for non-primary keys, change the UI
                strOldData = pData->GetString();
                pData->SetData(strData);
        }

        // return what ever happens in the replace
        iStat = queryReplace.Modify(MSIMODIFY_REPLACE, hRec); 
        if (ERROR_SUCCESS == iStat)
        {
                // set that the document has changed
                pDoc->SetModifiedFlag(TRUE);

                if (pDoc->DoesTransformGetEdit())
                {
                        // mark that the cell has changed. If the row is an "add" row, this
                        // is not a cell change
                        if (IsTransformed() != iTransformAdd)
                        {
                                PMSIHANDLE hOtherRec = GetRowRecord(pDoc->GetOriginalDatabase());
                                TransformCellAgainstDatabaseRow(pDoc, iCol, 0, hOtherRec);      
                        }
                }
        }
        else if (!strOldData.IsEmpty())
                pData->SetData(strOldData);

        return iStat;
}

///////////////////////////////////////////////////////////////////////
// modifies the binary data in a cell, and if transforms are enabled
// compares the data to the other database to determine transform state
UINT COrcaRow::ChangeBinaryData(COrcaDoc *pDoc, int iCol, CString strFile)
{
        UINT iResult = ERROR_SUCCESS;

        // get the data item we're working with
        COrcaData* pData = GetData(iCol);
        ASSERT(pData);
        if (!pData)
                return ERROR_FUNCTION_FAILED;

        // setup the query
        CString strQuery;
        strQuery.Format(_T("SELECT * FROM `%s` WHERE "), m_pTable->Name());

        // add the key strings to query to do the exact look up
        strQuery += m_pTable->GetRowWhereClause();

        // get the one row out of the database
        CQuery queryReplace;
        PMSIHANDLE hQueryRec = GetRowQueryRecord();
        if (!hQueryRec)
                return ERROR_FUNCTION_FAILED;

        if (ERROR_SUCCESS != (iResult = queryReplace.OpenExecute(pDoc->GetTargetDatabase(), hQueryRec, strQuery)))
                return iResult;

        // we have to get that one row, or something is very wrong
        PMSIHANDLE hRec;
        if (ERROR_SUCCESS != (iResult = queryReplace.Fetch(&hRec)))
                return iResult;

        // bail if we can't set the string (iCol + 1 because MSI Records start at 1)
        if (strFile.IsEmpty())
        {
                MsiRecordSetString(hRec, iCol + 1, _T(""));
        }
        else
        {
                if (ERROR_SUCCESS != (iResult = ::MsiRecordSetStream(hRec, iCol + 1, strFile)))
                        return iResult; // bail
        }

        // return what ever happens in the replace
        iResult = queryReplace.Modify(MSIMODIFY_REPLACE, hRec);

        if (strFile.IsEmpty())
                pData->SetData(_T(""));
        else
                pData->SetData(_T("[Binary Data]"));
        
        if (pDoc->DoesTransformGetEdit() && iResult == ERROR_SUCCESS)
        {
                PMSIHANDLE hOtherRec = GetRowRecord(pDoc->GetOriginalDatabase());
                TransformCellAgainstDatabaseRow(pDoc, iCol, hRec, hOtherRec);
        }

        return iResult;
}

/////////////////////////////////////////////////////////////////////////////
// row level transform ops are interesting because they often arise from
// primary key changes which require on-the-fly comparisons between the two
// databases
void COrcaRow::Transform(COrcaDoc *pDoc, const OrcaTransformAction iAction, MSIHANDLE hOriginalRec, MSIHANDLE hTransformedRec) 
{
        ASSERT(pDoc);
        if (!pDoc)
                return;

        switch (iAction)
        {
                case iTransformAdd:
                case iTransformDrop:
                {
                        ASSERT(m_pTable);
                        if (!m_pTable)
                                return;

                        // when a row is added or dropped, the change states of the individual
                        // cells are irrelevant, but we must refresh from the original state
                        MSIHANDLE hRec = (hOriginalRec ? hOriginalRec : GetRowRecord(pDoc->GetOriginalDatabase()));
                        if (hRec)
                                ReadFromRecord(hRec, m_pTable->GetColumnCount());
                        for (int i = 0; i < m_dataArray.GetSize(); i++)
                        {
                                COrcaData *pData = GetData(i);
                                ASSERT(pData);
                                if (!pData)
                                        continue;
                                pData->Transform(iTransformNone);
                        }

                        // if the row is not already transformed, remove any outstanding
                        // cell-level transform counts and add one for the row
                        if (m_iTransform == iTransformNone)
                        {
                                RemoveOutstandingTransformCounts(pDoc);
                                m_pTable->IncrementTransformedData();
                        }
                        m_iTransform = iAction;

                        if (!hOriginalRec)
                                MsiCloseHandle(hRec);
                        break;
                }
                case iTransformNone:
                        // if a row is given a "none" transform, what should we do?????
                        ASSERT(0);
                        break;
                case iTransformChange:
                {
                        ASSERT(m_pTable);
                        if (!m_pTable)
                                return;

                        // a row-level "change" operation is actually a row-level"none", but
                        // each non-key cell in the row could become a "change". If a primary
                        // key on a record changes to something that collides with an existing 
                        // record, the transform state of each cell is unknown and must be checked.
                        if (m_iTransform != iTransformNone)
                                m_pTable->DecrementTransformedData();
                        m_iTransform = iTransformNone;
                        
                        int cKeys = m_pTable->GetKeyCount();
                        int cCols = GetColumnCount();
                        
                        // if the table consists only of primary keys, we are done
                        if (cKeys == cCols)
                                break;

                        // we need a record from the other database as a basis for 
                        // comparison
                        MSIHANDLE hOtherRow = (hOriginalRec ? hOriginalRec : GetRowRecord(pDoc->GetOriginalDatabase()));

                        // the original DB may actually have fewer columns than the transformed DB. 
                        // in that case we only want to check the columns that exist in both databases
                        int cOriginalCols = m_pTable->GetOriginalColumnCount();

                        // if the original table consists only of primary keys, we are done
                        if (cKeys == cOriginalCols)
                        {
                                if (!hOriginalRec)
                                        MsiCloseHandle(hOtherRow);
                                break;
                        }

                        // the primary keys can not be different or there would be
                        // no collision, so no need to check those columns.
                        for (int i = cKeys; i < cOriginalCols; i++)
                        {                       
                                TransformCellAgainstDatabaseRow(pDoc, i, hTransformedRec, hOtherRow);
                        }

						// anything greater than the number of columns in the original database is simply
						// a load from the transformed record. No need to transform because the original
						// database doesn't have this column, so the column must be added anyway.
						for (i = cOriginalCols; i < cCols; i++)
						{
							COrcaData *pData = GetData(i);
							const COrcaColumn* pColumn = m_pTable->GetColumn(i);
							ASSERT(pData && pColumn);
							if (!pData || !pColumn)
									continue;
							ReadCellFromRecord(hTransformedRec, cCols, i, pColumn, &pData);
						}

                        if (!hOriginalRec)
                                MsiCloseHandle(hOtherRow);
                        break;
                }
                default:
                        ASSERT(0);
                        break;
        }
}

///////////////////////////////////////////////////////////////////////
// given a row record (presumably from the original database when we're
// editing the transform), compare the specified cell against the 
// provided record and mark as transformed if different. Used to 
// reconcile the UI when a cell modification changes a primary key to
// clash with an previously dropped row.
void COrcaRow::TransformCellAgainstDatabaseRow(COrcaDoc *pDoc, int iColumn, MSIHANDLE hTargetRow, MSIHANDLE hOtherRow)
{
        bool fDifferent = false;
        COrcaData *pData = GetData(iColumn);
        ASSERT(pData);
        ASSERT(m_pTable);
        if (!pData || !m_pTable)
                return;
		const COrcaColumn* pColumn = m_pTable->GetColumn(iColumn);
		ASSERT(pColumn);

        CString strData = _T("");

        if (iColumnBinary == pColumn->m_eiType)
        {
                // for binary data, we need to check that this bits are identical to determine whether or
                // not this cell has been transformed
                MSIHANDLE hThisRow = 0;
                hThisRow = (hTargetRow ? hTargetRow : GetRowRecord(pDoc->GetTargetDatabase()));

                unsigned long iOtherSize = 0;
                unsigned long iThisSize = 0;
                MsiRecordReadStream(hOtherRow, iColumn+1, NULL, &iOtherSize);
                MsiRecordReadStream(hThisRow, iColumn+1, NULL, &iThisSize);

                strData = MsiRecordIsNull(hOtherRow, iColumn+1) ? _T("[Binary Data]") : _T("");

                if (iOtherSize != iThisSize)
                {
                        fDifferent = true;
                }
                else
                {
                        fDifferent = false;
                        while (iThisSize > 0)
                        {
                                int iBlock = (iThisSize > 1024) ? 1024 : iThisSize;
                                iThisSize -= iBlock;
                                char OtherBuffer[1024] = "";
                                char ThisBuffer[1024] = "";
                                DWORD dwTemp = iBlock;
                                if (ERROR_SUCCESS != MsiRecordReadStream(hOtherRow, iColumn+1, OtherBuffer, &dwTemp))
                                {
                                        fDifferent = true;
                                        break;
                                }
                                dwTemp = iBlock;
                                if (ERROR_SUCCESS != MsiRecordReadStream(hThisRow, iColumn+1, ThisBuffer, &dwTemp))
                                {
                                        fDifferent = true;
                                        break;
                                }

                                if (memcmp(OtherBuffer, ThisBuffer, iBlock))
                                {
                                        fDifferent = true;
                                        break;
                                }
                        }
                }

                // clean up owned target row
                if (!hTargetRow)
                {
                        MsiCloseHandle(hThisRow);
                }
        }
        else
        {
                UINT iResult = RecordGetString(hOtherRow, iColumn + 1, strData);

                COrcaData *pData = m_dataArray.GetAt(iColumn);
                ASSERT(pData);
                if (!pData)
                        return;

                if (strData != pData->GetString())
                {
                        fDifferent = true;
                }
        }

        if (fDifferent)
        {
                // if the cell is not already transformed, do so
                if (!pData->IsTransformed())
                {
                        pData->Transform(iTransformChange);                             
                        m_pTable->IncrementTransformedData();
                }
        }
        else
        {
                // data is same, if transform, remove change
                if (pData->IsTransformed())
                {
                        pData->Transform(iTransformNone);                               
                        m_pTable->DecrementTransformedData();
                }
        }
}

///////////////////////////////////////////////////////////////////////
// scans through every cell in the row, removing a transform count 
// for each transformed cell. It also removes one count if the row
// itself is transformed. This is used to clean-up counts before
// deleting or re-transforming the row.
void COrcaRow::RemoveOutstandingTransformCounts(COrcaDoc *pDoc)
{
        ASSERT(pDoc);
        ASSERT(m_pTable);
        if (!pDoc || !m_pTable)
                return;

        // if the row as a whole is transformed, there is only one 
        // transform count, not one for each cell.
        if (m_iTransform != iTransformNone)
        {
                m_pTable->DecrementTransformedData();
                return;
        }

        int cKeys = m_pTable->GetKeyCount();
        // never more than 32 columns, so cast OK on Win64
        int cCols = static_cast<int>(m_dataArray.GetSize());

        // if the table consists only of primary keys, we are done because
        // no primary keys can have "change" attributes
        if (cKeys == cCols)
                return;

        // the primary keys can not be different or there would be
        // no collision, so no need to check those columns.
        for (int i = cKeys; i < cCols; i++)
        {                       
                if (m_dataArray.GetAt(i)->IsTransformed())
                        m_pTable->DecrementTransformedData();
        }
}


///////////////////////////////////////////////////////////////////////
// Retrieve the value from a cell in the original database. Very slow
// function, should only be used for rare events.
const CString COrcaRow::GetOriginalItemString(const COrcaDoc *pDoc, int iItem) const
{
	CString strValue;
	ASSERT(pDoc);
	if (pDoc)
	{
		PMSIHANDLE hRec = GetRowRecord(pDoc->GetOriginalDatabase());
		if (hRec)
		{
			if (!MsiRecordIsNull(hRec, iItem+1))
			{
				// determine colomun format.
				const COrcaColumn* pColumn = m_pTable->GetColumn(iItem);
				if (pColumn)
				{
					switch (pColumn->m_eiType)
					{
					case iColumnShort:
					case iColumnLong:
					{
						DWORD dwValue = MsiRecordGetInteger(hRec, iItem+1);
						strValue.Format(pColumn->DisplayInHex() ? TEXT("0x%08X") : TEXT("%d"), dwValue);
						break;
					}
					case iColumnString:
					case iColumnLocal:
						RecordGetString(hRec, iItem+1, strValue);
						break;
					case iColumnBinary:
						strValue = TEXT("[Binary Data]");
						break;
					default:
						ASSERT(0);
						break;
					}
				}
			}
		}
	}
	return strValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C3EDC1AA_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_STDAFX_H__C3EDC1AA_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


// used in the build process
typedef BOOL (WINAPI* LPDISPLAYBUILD)(LPVOID pContext, UINT uiType, LPCTSTR szDisplay);

enum DisplayType
{
	iError,		// error display
	iInfo,		// info display
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C3EDC1AA_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	Orca.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\row.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Row.h
//

#ifndef _ORCA_ROW_H_
#define _ORCA_ROW_H_

#include "msiquery.h"
#include "Column.h"
#include "Data.h"

// forward declaration
class COrcaTable;
class COrcaDoc;

class COrcaRow : public CObject
{

public:
	COrcaRow(COrcaTable *pTable, MSIHANDLE hRecord);
	COrcaRow(COrcaTable *pTable, CStringList* pstrList);
	COrcaRow(const COrcaRow *pRow);
	~COrcaRow();
	
	CString GetRowWhereClause() const;
	bool Find(OrcaFindInfo &FindInfo, int &iCol) const;
	void Transform(COrcaDoc *pDoc, const OrcaTransformAction iAction, MSIHANDLE hNonTargetRec, MSIHANDLE hTargetRec);
	inline const OrcaTransformAction IsTransformed() const { return m_iTransform; };
	void RemoveOutstandingTransformCounts(COrcaDoc *pDoc);

	
	inline COrcaData* GetData(UINT iCol) const { return m_dataArray.GetAt(iCol); };

	// never more than 32 columns, so cast down to int is OK on Win64
	inline int GetColumnCount() const { return static_cast<int>(m_dataArray.GetSize()); };

	UINT ChangeData(COrcaDoc *pDoc, UINT iCol, CString strData);
	UINT ChangeBinaryData(COrcaDoc *pDoc, int iCol, CString strFile);

	MSIHANDLE GetRowRecord(MSIHANDLE hDatabase) const;
	MSIHANDLE GetRowQueryRecord() const;
	int GetErrorCount() const;
	int GetWarningCount() const;
	void ClearErrors();
	void DestroyRow();

	const CString GetOriginalItemString(const COrcaDoc *pDoc, int iItem) const;

private:
	void ReadCellFromRecord(MSIHANDLE hRecord, int cRecData, int iColumn, const COrcaColumn* pColumn, COrcaData** pData) const; 
	void ReadFromRecord(MSIHANDLE hRec, int cData);
	void TransformCellAgainstDatabaseRow(COrcaDoc *pDoc, int iColumn, MSIHANDLE hTargetRow, MSIHANDLE hOtherRow);
	
	CTypedPtrArray<CObArray, COrcaData*> m_dataArray;
	
	COrcaTable* m_pTable;
	OrcaTransformAction m_iTransform;
};	// end of COrcaRow

extern bool ValidateIntegerValue(const CString& strData, DWORD& dwValue);

#endif	// _ORCA_ROW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\sources.inc ===
TARGETNAME=orca
!INCLUDE ..\..\..\MsiMake.inc
                  
TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NTTARGETFILE0=BuiltHeaders

C_DEFINES=-D"_WIN32_MSM=200" $(C_DEFINES)

UMTYPE=windows

TARGETPATH=$(MSI_BUILD_TARGET)


# 
# Fusionized
# 

SXS_ASSEMBLY_NAME=Microsoft.Windows.MSI.Orca
SXS_ASSEMBLY_VERSION=2.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=orca.exe.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1


TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\msi.lib \
	$(SDK_LIB_PATH)\OLE32.lib \
	$(SDK_LIB_PATH)\OLEAUT32.lib \
	$(SDK_LIB_PATH)\mfc42.lib \
	$(SDK_LIB_PATH)\mfcs42.lib \
	$(SDK_LIB_PATH)\shell32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\comctl32.lib \
        $(SDK_LIB_PATH)\comdlg32.lib

USE_MSVCRT=1
USE_NATIVE_EH=1

MSC_OPTIMIZATION=/Odi

!if "$(MSI_BUILD_UNICODE)"=="1"
USE_MFCUNICODE=1
!else
USE_MFC=1
!endif

INCLUDES=$(INC_DIR);$(SDK_INC_PATH);$(O);$(MFC_INCLUDES);$(RES_OBJDIR)

SOURCES=..\addrowd.cpp \
	..\addtbld.cpp \
	..\celledit.cpp \
	..\cellerrd.cpp \
	..\cnfgmsmd.cpp \
	..\column.cpp \
	..\data.cpp \
	..\odbutils.cpp \
	..\displypp.cpp \
	..\domerge.cpp \
	..\editbind.cpp \
	..\exportd.cpp \
	..\folderd.cpp \
	..\helpd.cpp \
	..\imprtdlg.cpp \
	..\orcadoc.cpp \
	..\orcalstv.cpp \
	..\mainfrm.cpp \
	..\merged.cpp \
	..\msmresd.cpp \
	..\orca.cpp \
	..\oquery.cpp \
	..\pathpp.cpp \
	..\prvwdlg.cpp \
	..\row.cpp \
	..\summaryd.cpp \
	..\table.cpp \
	..\tablelst.cpp \
	..\tablevw.cpp \
	..\tblerrd.cpp \
	..\trnpropd.cpp \
	..\otrace.cpp \
	..\outils.cpp \
	..\vald.cpp \
	..\valpane.cpp \
	..\valpp.cpp \
	..\stdafx.cpp \
	..\orca.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\summaryd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// SummaryD.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "SummaryD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSummaryD dialog


CSummaryD::CSummaryD(CWnd* pParent /*=NULL*/)
	: CDialog(CSummaryD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSummaryD)
	m_strAuthor = _T("");
	m_strComments = _T("");
	m_strKeywords = _T("");
	m_strLanguages = _T("");
	m_strPlatform = _T("");
	m_strProductID = _T("");
	m_nSchema = 0;
	m_nSecurity = -1;
	m_strSubject = _T("");
	m_strTitle = _T("");
	m_bAdmin = FALSE;
	m_bCompressed = FALSE;
	m_iFilenames = -1;
	//}}AFX_DATA_INIT
}


void CSummaryD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSummaryD)
	DDX_Text(pDX, IDC_AUTHOR, m_strAuthor);
	DDX_Text(pDX, IDC_COMMENTS, m_strComments);
	DDX_Text(pDX, IDC_KEYWORDS, m_strKeywords);
	DDX_Text(pDX, IDC_LANGUAGES, m_strLanguages);
	DDX_CBString(pDX, IDC_PLATFORM, m_strPlatform);
	DDX_Text(pDX, IDC_PRODUCTID, m_strProductID);
	DDX_Text(pDX, IDC_SCHEMA, m_nSchema);
	DDX_CBIndex(pDX, IDC_SECURITY, m_nSecurity);
	DDX_Text(pDX, IDC_SUBJECT, m_strSubject);
	DDX_Text(pDX, IDC_TITLE, m_strTitle);
	DDX_Check(pDX, IDC_ADMIN, m_bAdmin);
	DDX_Check(pDX, IDC_COMPRESSED, m_bCompressed);
	DDX_Radio(pDX, IDC_SHORT, m_iFilenames);
	DDX_Control(pDX, IDC_PLATFORM, m_ctrlPlatform);
	DDX_Control(pDX, IDC_SCHEMA, m_ctrlSchema);

	DDX_Control(pDX, IDC_AUTHOR, m_ctrlAuthor);
	DDX_Control(pDX, IDC_COMMENTS, m_ctrlComments);
	DDX_Control(pDX, IDC_KEYWORDS, m_ctrlKeywords);
	DDX_Control(pDX, IDC_LANGUAGES, m_ctrlLanguages);
	DDX_Control(pDX, IDC_PRODUCTID, m_ctrlProductID);
	DDX_Control(pDX, IDC_SUBJECT, m_ctrlSubject);
	DDX_Control(pDX, IDC_TITLE, m_ctrlTitle);
	DDX_Control(pDX, IDC_SECURITY, m_ctrlSecurity);
	DDX_Control(pDX, IDC_ADMIN, m_ctrlAdmin);
	DDX_Control(pDX, IDC_COMPRESSED, m_ctrlCompressed);
	DDX_Control(pDX, IDC_SHORT, m_ctrlSFN);
	DDX_Control(pDX, IDC_LONG, m_ctrlLFN);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSummaryD, CDialog)
	//{{AFX_MSG_MAP(CSummaryD)
	ON_EN_KILLFOCUS(IDC_SCHEMA, OnChangeSchema)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


const TCHAR szIntel64[] = _T("Intel64");
const TCHAR szIntel[] = _T("Intel");
const TCHAR szAlpha[] = _T("Alpha");
const TCHAR szIntelAlpha[] = _T("Intel,Alpha");

/////////////////////////////////////////////////////////////////////////////
// CSummaryD message handlers

void CSummaryD::OnChangeSchema() 
{
	CString strText;
	int nOldSchema = m_nSchema;
	m_ctrlSchema.GetWindowText(strText);

	if (!strText.IsEmpty())
	{
		UpdateData(TRUE);
		
		// alpha only supported for schema 100 or less
		if (nOldSchema <= 100 && m_nSchema > 100)
		{
			// drop alpha
			int iIndex = CB_ERR;
			if (CB_ERR != (iIndex = m_ctrlPlatform.FindString(-1, szAlpha)))
				m_ctrlPlatform.DeleteString(iIndex);
			if (CB_ERR != (iIndex = m_ctrlPlatform.FindString(-1, szIntelAlpha)))
				m_ctrlPlatform.DeleteString(iIndex);

			// moving from under 100 to over 100, you are going from Intel, Alpha, 
			// or Both to either Intel or Intel64. Set to Intel
			m_ctrlPlatform.SelectString(-1, szIntel);
		}
		else if (nOldSchema > 100 && m_nSchema <= 100)
		{
			// add alpha back in
			if (CB_ERR == m_ctrlPlatform.FindString(-1, szAlpha))
				m_ctrlPlatform.AddString(szAlpha);
			if (CB_ERR == m_ctrlPlatform.FindString(-1, szIntelAlpha))
				m_ctrlPlatform.AddString(szIntelAlpha);
		}			

		// Intel64 only supported on schemas >= 150
		if (nOldSchema >= 150 && m_nSchema < 150)
		{
			int iIndex = CB_ERR;
			if (CB_ERR != (iIndex = m_ctrlPlatform.FindString(-1, szIntel64)))
				m_ctrlPlatform.DeleteString(iIndex);
			
			// moving from over 150 to under 150, you are going from Intel or Intel64 
			// to Intel, Alpha, or both. Set to Intel.
			m_ctrlPlatform.SelectString(-1, szIntel);
		}
		else if (nOldSchema < 150 && m_nSchema >= 150)
		{
			if (CB_ERR == m_ctrlPlatform.FindString(-1, szIntel64))
				m_ctrlPlatform.AddString(szIntel64);
		}
	}
}

BOOL CSummaryD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	m_ctrlPlatform.AddString(szIntel);
	if (m_nSchema >= 150)
		m_ctrlPlatform.AddString(szIntel64);
	if (m_nSchema <= 100)
	{
		m_ctrlPlatform.AddString(szAlpha);
		m_ctrlPlatform.AddString(szIntelAlpha);
	}
	m_ctrlPlatform.SelectString(-1, m_strPlatform);

	// if the summaryinfo is read-only, disable all controls:
	if (m_bReadOnly)
	{
		SetWindowText(TEXT("View Summary Information"));
		m_ctrlPlatform.EnableWindow(FALSE);
		m_ctrlSchema.EnableWindow(FALSE);
		m_ctrlAuthor.EnableWindow(FALSE);
		m_ctrlComments.EnableWindow(FALSE);
		m_ctrlKeywords.EnableWindow(FALSE);
		m_ctrlLanguages.EnableWindow(FALSE);
		m_ctrlProductID.EnableWindow(FALSE);
		m_ctrlSubject.EnableWindow(FALSE);
		m_ctrlTitle.EnableWindow(FALSE);
		m_ctrlSecurity.EnableWindow(FALSE);
		m_ctrlAdmin.EnableWindow(FALSE);
		m_ctrlCompressed.EnableWindow(FALSE);
		m_ctrlSFN.EnableWindow(FALSE);
		m_ctrlLFN.EnableWindow(FALSE);
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\summaryd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

#if !defined(AFX_SUMMARYD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
#define AFX_SUMMARYD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SummaryD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSummaryD dialog

class CSummaryD : public CDialog
{
// Construction
public:
	CSummaryD(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSummaryD)
	enum { IDD = IDD_SUMMARY_INFORMATION };
	CString	m_strAuthor;
	CString	m_strComments;
	CString	m_strKeywords;
	CString	m_strLanguages;
	CString	m_strPlatform;
	CString	m_strProductID;
	int		m_nSchema;
	int		m_nSecurity;
	CString	m_strSubject;
	CString	m_strTitle;
	BOOL	m_bAdmin;
	BOOL	m_bCompressed;
	int		m_iFilenames;
	CComboBox m_ctrlPlatform;
	CEdit   m_ctrlSchema;

	CEdit   m_ctrlAuthor;
	CEdit   m_ctrlComments;
	CEdit   m_ctrlKeywords;
	CEdit   m_ctrlLanguages;
	CEdit   m_ctrlProductID;
	CEdit   m_ctrlSubject;
	CEdit   m_ctrlTitle;
	CComboBox m_ctrlSecurity;
	CButton m_ctrlAdmin;
	CButton m_ctrlCompressed;
	CButton m_ctrlSFN;
	CButton m_ctrlLFN;
	//}}AFX_DATA

	bool    m_bReadOnly;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSummaryD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSummaryD)
	afx_msg void OnChangeSchema();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUMMARYD_H__0BCCB314_F4B2_11D1_A85A_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\table.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Table.cpp
//

#include "stdafx.h"
#include "Table.h"
#include "..\common\dbutils.h"
#include "..\common\query.h"
#include "orcadoc.h"
#include "mainfrm.h"
#include "row.h"

///////////////////////////////////////////////////////////
// constructor
COrcaTable::COrcaTable(COrcaDoc* pDoc) : m_pDoc(pDoc), m_strName(""), m_bRetrieved(false), m_fShadow(false), 
	m_eiError(iTableNoError), m_iTransform(iTransformNone), m_eiTableLocation(odlInvalid),
	m_iTransformedDataCount(0), m_bContainsValidationErrors(false), m_strWhereClause(_T("")),
	m_cOriginalColumns(0)
{
}

///////////////////////////////////////////////////////////
// destructor
COrcaTable::~COrcaTable()
{
}	// end of destructor


///////////////////////////////////////////////////////////
// DestroyTable
// destroys all rows and columns in the database
void COrcaTable::DestroyTable()
{
	ClearErrors();
	EmptyTable();
	
	m_eiTableLocation = odlInvalid;
	
	// destroy the column array
	int cColumns = static_cast<int>(m_colArray.GetSize());

	for (int i = 0; i < cColumns; i++)
		delete m_colArray.GetAt(i);
	m_colArray.RemoveAll();
	m_cOriginalColumns = 0;
}	// end of DestroyTable

///////////////////////////////////////////////////////////////////////
// given a column name, return the column number (0 based) or -1 if not
// found in the table.
int COrcaTable::FindColumnNumberByName(const CString& strCol) const
{
	// never more than 32 columns, so casting to int OK
	int iCol = -1;
	int cCols = static_cast<int>(m_colArray.GetSize());

	// find the first column that matches names
	for (int i = 0; i < cCols; i++)
	{
		COrcaColumn *pColumn = m_colArray.GetAt(i);
		if (!pColumn)
			continue;
		if (pColumn->m_strName == strCol)
		{
			iCol = i;
			break;
		}
	}
	return iCol;
}

///////////////////////////////////////////////////////////////////////
// GetData - 2
// returns a COrcaData pointer based on a primary key set and a column
// name. Returns NULL if the column or keys couldn't be found
COrcaData* COrcaTable::GetData(CString strCol, CStringArray& rstrKeys, const COrcaRow** pRowOut) const
{
	// never more than 32 columns, so casting to int OK
	int iCol = FindColumnNumberByName(strCol);

	// if we couldn't find the column bail
	if (iCol < 0)
		return NULL;

	COrcaRow* pRow = FindRowByKeys(rstrKeys);

	// if we have a match get the correct data spot
	COrcaData* pData = NULL;
	if (pRow)
	{
		pData = pRow->GetData(iCol);
		if (pRowOut)
			*pRowOut = pRow;
	}
	else
	{
		pData = NULL;
		if (pRowOut)
			*pRowOut = pRow;
	}

	return pData;
}	// end of GetData - 2


COrcaRow* COrcaTable::FindRowByKeys(CStringArray& rstrKeys) const
{
	int cKeys = GetKeyCount();

	// start at the top and look for a matching row
	BOOL bFound = FALSE;
	COrcaData* pData = NULL;
	COrcaRow* pRow = NULL;
	POSITION pos = m_rowList.GetHeadPosition();
	while (pos)
	{
		pRow = m_rowList.GetNext(pos);
		ASSERT(pRow);
		if (!pRow)
			continue;

		// loop through the strings in the passed in array looking for an exact match
		bFound = TRUE;  // assume we'll find a match this time
		for (int j = 0; j < cKeys; j++)
		{
			pData = pRow->GetData(j);
			ASSERT(pData);
			if (!pData)
				continue;

			// if we broke the matches
			if (pData->GetString() != rstrKeys.GetAt(j))
			{
				bFound = FALSE;
				break;
			}
		}

		if (bFound)
			break;
	}
	return pRow;
}

///////////////////////////////////////////////////////////
// FindRow -- finds a row by primary key without querying 
// the database.
COrcaRow* COrcaTable::FindDuplicateRow(COrcaRow* pBaseRow) const
{
	COrcaRow* pRow = NULL;
	int cKeys = GetKeyCount();
	if (pBaseRow->GetColumnCount() < cKeys)
		return NULL;
	
	CStringArray strArray;
	for (int i=0; i < cKeys; i++)
	{
		COrcaData* pBaseData = pBaseRow->GetData(i);
		ASSERT(pBaseData);
		if (!pBaseData)
			return NULL;
		
		// if we broke the matches
		strArray.Add(pBaseData->GetString());
	}

	return FindRowByKeys(strArray);
}

///////////////////////////////////////////////////////////
// CreateTable - builds an MSI table based on this object
// this might be useful when we can add custom tables, 
// but right now its bloat
/* 
UINT COrcaTable::CreateTable(MSIHANDLE hDatabase)
{
	m_fShadow = false;

	UINT iResult;
	CString strSQL;	// sql statement to create table
	strSQL.Format(_T("CREATE TABLE `%s` ("), m_strName);

	// loop through all columns - never more than 32
	COrcaColumn* pCol;
	CString strAdd;
	int cCols = static_cast<int>(m_colArray.GetSize());
	for (int i = 0; i < cCols; i++)
	{
		// get the column
		pCol = m_colArray.GetAt(i);

		switch (pCol->m_eiType)
		{
		case iColumnString:
		case iColumnLocal:
			strAdd.Format(_T("`%s` CHAR(%d)"), pCol->m_strName, pCol->m_iSize);
			break;
		case iColumnShort:
			strAdd.Format(_T("`%s` SHORT"), pCol->m_strName);
			break;
		case iColumnLong:
			strAdd.Format(_T("`%s` LONG"), pCol->m_strName);
			break;
		case iColumnBinary:
			strAdd.Format(_T("`%s` OBJECT"), pCol->m_strName);
			break;
		default:
			ASSERT(FALSE);
		}

		// set the extra flags
		if (!pCol->m_bNullable)
			strAdd += _T(" NOT NULL");
		if (iColumnLocal == pCol->m_eiType)
			strAdd += _T(" LOCALIZABLE");

		strSQL += strAdd;

		// if not last column tack on a comma
		if (i < cCols - 1)
			strSQL += _T(", ");
	}

	// first key HAS to be a primary eky
	strSQL += _T(" PRIMARY KEY `") + m_colArray.GetAt(0)->m_strName;

	// check if any other colums are primary keys
	for (i = 1; i < cCols; i++)
	{
		// get the column
		pCol = m_colArray.GetAt(i);

		// if this is a primary key
		if (pCol->m_bPrimaryKey)
			strSQL += _T("`, `") + pCol->m_strName;
		else
			break;	// no more primary keys
	}

	// close the query with a paren
	strSQL += _T("`)");

	// now execute the create table SQL
	CQuery queryAdd;
	if (ERROR_SUCCESS == (iResult = queryAdd.Open(hDatabase, strSQL)))
		iResult = queryAdd.Execute();
	ASSERT(ERROR_SUCCESS == iResult);

	return iResult;
}	// end of CreateTable
*/


///////////////////////////////////////////////////////////
// GetKeyCount
UINT COrcaTable::GetKeyCount() const
{
	int cKeys = 0;
	int cCols = static_cast<int>(m_colArray.GetSize());

	for (int i = 0; i < cCols; i++)
	{
		if (m_colArray.GetAt(i)->IsPrimaryKey())
			cKeys++;
	}

	return cKeys;
}	// end of GetKeyCount

///////////////////////////////////////////////////////////
// GetErrorCount
int COrcaTable::GetErrorCount()
{
	int cErrors = 0;

	// loop through the rows cleaning up
	POSITION pos = m_rowList.GetHeadPosition();
	while (pos)
		cErrors += m_rowList.GetNext(pos)->GetErrorCount();

	return cErrors;
}	// end of GetErrorCount

///////////////////////////////////////////////////////////
// GetWarningCount
int COrcaTable::GetWarningCount()
{
	int cWarnings = 0;

	// loop through the rows cleaning up
	POSITION pos = m_rowList.GetHeadPosition();
	while (pos)
		cWarnings += m_rowList.GetNext(pos)->GetWarningCount();

	return cWarnings;
}	// end of GetWarningCount

///////////////////////////////////////////////////////////
// ClearErrors
void COrcaTable::ClearErrors()
{
	m_eiError = iTableNoError;	// clear the table's error
	m_bContainsValidationErrors = false;
	m_strErrorList.RemoveAll();

	// loop through the rows cleaning up
	POSITION pos = m_rowList.GetHeadPosition();
	while (pos)
		m_rowList.GetNext(pos)->ClearErrors();
}	// end of ClearErrors

///////////////////////////////////////////////////////////////////////
// Find()
// searches for the specified string in the Table
// if found, returns true and fires an Update with a CHANGE_TABLE
// to the new table, followed by an update with a SET_SEL
// Currently this could find stuff in the original or transformed 
// database
bool COrcaTable::Find(OrcaFindInfo &FindInfo, COrcaRow *&pRow, int &iCol) const {

	INT_PTR iMax = m_rowList.GetCount();
	pRow = NULL;
	iCol = COLUMN_INVALID;

	POSITION pos = FindInfo.bForward ? m_rowList.GetHeadPosition()
							 		 : m_rowList.GetTailPosition();
	while (pos)
	{
		pRow = FindInfo.bForward  ? m_rowList.GetNext(pos)
								  : m_rowList.GetPrev(pos);
		if (pRow->Find(FindInfo, iCol)) {
			return true;
		}
	}
	return false;
}

UINT COrcaTable::DropTable(MSIHANDLE hDatabase)
{
	CQuery queryDrop;
	return queryDrop.OpenExecute(hDatabase, NULL, _T("DROP TABLE `%s`"), m_strName);
}

void COrcaTable::EmptyTable() 
{
	// destroy the row list
	while (!m_rowList.IsEmpty())
		delete m_rowList.RemoveHead();
	m_bRetrieved = false;
	m_iTransformedDataCount = 0;

	// release any database holds
	if (m_eiTableLocation == odlSplitOriginal || m_eiTableLocation == odlNotSplit)
	{
		CQuery qHoldQuery;
		qHoldQuery.OpenExecute(m_pDoc->GetOriginalDatabase(), 0, TEXT("ALTER TABLE `%s` FREE"), m_strName);
	}
	if (m_pDoc->DoesTransformGetEdit() && (m_eiTableLocation == odlSplitTransformed || m_eiTableLocation == odlNotSplit))
	{
		CQuery qHoldQuery;
		qHoldQuery.OpenExecute(m_pDoc->GetTransformedDatabase(), 0, TEXT("ALTER TABLE `%s` FREE"), m_strName);
	}

	ClearErrors();
}

///////////////////////////////////////////////////////////
// RetrieveTable
void COrcaTable::RetrieveTableData()
{
	TRACE(_T("COrcaTable::RetrieveTable - called for table: %s\n"), m_strName);

	// if this table has already been retrieved return
	if (m_bRetrieved)
		return;
	
	// if we ever use the "tranfsormed" attribute of the MSI table, a transform
	// count will exist even before the data is loaded.
	m_iTransformedDataCount = 0;

	// provide scope for marking column
	{
		// if possible, use a temporary marking column in the transformed DB
		// for perf gains when cross-referencing data
		CQuery qMarkColumn;
		bool fMarkingColumn = false;
	
		// a table can exist in one or both databases. Because a transform can
		// completely redefine a table a "retrieve" must not rely on the presence
		// of a table to load the data
		
		// load from the transformed database first, since it will be the primary database 
		// that is displayed.
		if (m_pDoc->DoesTransformGetEdit() && (m_eiTableLocation == odlSplitTransformed || m_eiTableLocation == odlNotSplit))
		{
			UINT iResult = ERROR_SUCCESS;
			
			// only cross-reference with non-transformed database if this is not a split table
			bool fHaveTransform = (m_eiTableLocation == odlNotSplit);
	
			// open query to cross-reference with the original DB now. Much
			// faster than AddRowObject because the SQL doesn't need to be 
			// parsed and resolved every time.
			CQuery qConflictCheck;

			// if this is not a split table, attempt to create a temporary column
			// in the transformed table to speed up conflict checking
			if (m_eiTableLocation != odlSplitTransformed)
			{
				if (ERROR_SUCCESS == qMarkColumn.OpenExecute(m_pDoc->GetOriginalDatabase(), 0, TEXT("ALTER TABLE `%s` ADD `___Orca` INT TEMPORARY"), m_strName))
				{
					fMarkingColumn = true;
				}
			}
	
			if (ERROR_SUCCESS != qConflictCheck.Open(m_pDoc->GetOriginalDatabase(), TEXT("SELECT * FROM `%s` WHERE %s"), m_strName, GetRowWhereClause()))
			{
				return;
			}
	
			// open a query on the transformed table
			CQuery queryRows;
			iResult = queryRows.Open(m_pDoc->GetTransformedDatabase(), _T("SELECT * FROM `%s`"), m_strName);
	
			if (ERROR_SUCCESS == iResult)
				iResult = queryRows.Execute();
	
			// retrieve all rows from the transformed database
			COrcaRow* pRow = NULL;
			PMSIHANDLE hRow;
			while (ERROR_SUCCESS == iResult)
			{
				iResult = queryRows.Fetch(&hRow);
	
				if (ERROR_SUCCESS == iResult)
				{
					pRow = new COrcaRow(this, hRow);
					if (!pRow)
						return;
	
					// if necessary, use the row record to cross-reference this row with the original
					// database table. If there is a corresponding row, we need to diff the two rows, 
					// otherwise this row is transformed to a "add" row.
					if (ERROR_SUCCESS != qConflictCheck.Execute(hRow))
					{
						ASSERT(0);
						return;
					}
	
					PMSIHANDLE hOriginalRow;
					switch (qConflictCheck.Fetch(&hOriginalRow))
					{
					case ERROR_NO_MORE_ITEMS:
					{
						// row does not exist in the original database, this
						// is a "add"
						pRow->Transform(m_pDoc, iTransformAdd, hOriginalRow, hRow);
						break;
					}
					case ERROR_SUCCESS:
					{
						// row DOES exist in the transformed database, need to diff
						// those two rows
						pRow->Transform(m_pDoc, iTransformChange, hOriginalRow, hRow);
						break;
					}
					default:
						ASSERT(0);
						return;
					}
	
					// update the temporary marking column
					if (fMarkingColumn)
					{
						MsiRecordSetInteger(hOriginalRow, GetOriginalColumnCount()+1, 1);
						if (ERROR_SUCCESS != qConflictCheck.Modify(MSIMODIFY_UPDATE, hOriginalRow))
						{
							// if the marking update failed for some reason, we can
							// no longer rely on the column when reading the transformed
							// database.
							fMarkingColumn = false;
						}
					}
	
					// after the row has been appropriately transformed, add it to
					// the list. No UI update required on initial load.
					m_rowList.AddTail(pRow);
				}
			}
		}
		
		// next load from the original database.
		if (m_eiTableLocation == odlSplitOriginal || m_eiTableLocation == odlNotSplit)
		{
			UINT iResult = ERROR_SUCCESS;
			
			// only cross-reference with transformed database if this is not a split table
			bool fCrossReference = m_pDoc->DoesTransformGetEdit() && (m_eiTableLocation == odlNotSplit);
	
			// only concerned with the presence or absence of the row, not the data,
			// so the query doesn't have to return anything.
			CQuery qConflictCheck;
			if (fCrossReference && !fMarkingColumn)
			{
				if (ERROR_SUCCESS != qConflictCheck.Open(m_pDoc->GetTransformedDatabase(), TEXT("SELECT '1' FROM `%s` WHERE %s"), m_strName, GetRowWhereClause()))
				{
					return;
				}
			}
	
			// retrieve all rows from the original database. If we are using a 
			// marking column during retrieval, there is a big perf gain because
			// conflicts are pre-determined.
			CQuery queryRows;
			if (fMarkingColumn)
			{
				iResult = queryRows.Open(m_pDoc->GetOriginalDatabase(), _T("SELECT * FROM `%s` WHERE `___Orca` <> 1"), m_strName);
			}
			else
			{
				iResult = queryRows.Open(m_pDoc->GetOriginalDatabase(), _T("SELECT * FROM `%s`"), m_strName);
			}
	
			if (ERROR_SUCCESS == iResult)
				iResult = queryRows.Execute();
	
			COrcaRow* pRow = NULL;
			PMSIHANDLE hOriginalRow;
			PMSIHANDLE hTransformedRow;
			while (ERROR_SUCCESS == iResult)
			{
				iResult = queryRows.Fetch(&hOriginalRow);
	
				if (ERROR_SUCCESS == iResult)
				{
					// if a cross-reference is required, and conflicting rows are not already
					// marked in the ___Orca column, check for an existing row in the transformed
					// database with the same primary keys
					if (fCrossReference && !fMarkingColumn)
					{
						qConflictCheck.Execute(hOriginalRow);
	
						switch (qConflictCheck.Fetch(&hTransformedRow))
						{
						case ERROR_NO_MORE_ITEMS:
						{
							// does not exist in the other database, so this is a "drop"
							pRow = new COrcaRow(this, hOriginalRow);
							pRow->Transform(m_pDoc, iTransformDrop, hTransformedRow, hOriginalRow);
							break;
						}
						case ERROR_SUCCESS:
						{
							// row does exist, transform was done in previous load
							pRow = NULL;
							break;
						}
						default:
							ASSERT(0);
							return;
						}
					}
					else
					{
						pRow = new COrcaRow(this, hOriginalRow);
	
						// if we skipped conflict checks because a marking column was
						// being used, we can assume that this is a drop row
						if (fMarkingColumn)
						{
							pRow->Transform(m_pDoc, iTransformDrop, 0, hOriginalRow);
						}
					}
	
					// if a new row object was created from the transformed table, add it to
					// the list. No UI update required on initial load.
					if (pRow)
					{
						m_rowList.AddTail(pRow);
					}
				}
			}
		}
	}

	// add HOLDs to the table. Must do this last because the temporary column needs
	// to vanish first
	if (m_eiTableLocation == odlSplitOriginal || m_eiTableLocation == odlNotSplit)
	{
		// add a hold to the table to prevent repeatedly loading and unloading the table
		CQuery qHoldQuery;
		qHoldQuery.OpenExecute(m_pDoc->GetOriginalDatabase(), 0, TEXT("ALTER TABLE `%s` HOLD"), m_strName);
	}
	if (m_pDoc->DoesTransformGetEdit() && (m_eiTableLocation == odlSplitTransformed || m_eiTableLocation == odlNotSplit))
	{
		// add a hold to the table to prevent repeatedly loading and unloading the table
		CQuery qHoldQuery;
		qHoldQuery.OpenExecute(m_pDoc->GetTransformedDatabase(), 0, TEXT("ALTER TABLE `%s` HOLD"), m_strName);
	}

	m_bRetrieved = TRUE;	// set the table as retrieved
}	// end of RetrieveTable

void COrcaTable::ShadowTable(CString strTable)
{
	m_eiError = iTableNoError;
	m_strName = strTable;
	m_bRetrieved = false;
	m_fShadow = true;
	m_eiTableLocation = odlShadow;
}

void COrcaTable::LoadTableSchema(MSIHANDLE hDatabase, CString szTable)
{
	if (!m_colArray.GetSize())
	{
		m_strName = szTable;
		m_eiTableLocation = odlNotSplit;
		m_bRetrieved = FALSE;
		m_fShadow = false;
	}
	else 
	{
		// already have a loaded schema
		ASSERT(szTable == m_strName);
	
		// if we're adding more columns and the table is already loaded, we MUST
		// immediately destroy all of the rows, because they are out of sync and
		// don't contain enough data objects to fill the columns.
		m_bRetrieved = FALSE;
		EmptyTable();
	}

	// get primary keys for table
	PMSIHANDLE hPrimaryKeys;
	if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeys(hDatabase, szTable, &hPrimaryKeys))
		return;

	// query table
	CQuery queryRow;
	if (ERROR_SUCCESS != queryRow.Open(hDatabase, _T("SELECT * FROM `%s`"), szTable))
		return;

	// get the column info then create the table
	PMSIHANDLE hColNames;
	PMSIHANDLE hColTypes;
	queryRow.GetColumnInfo(MSICOLINFO_NAMES, &hColNames);
	queryRow.GetColumnInfo(MSICOLINFO_TYPES, &hColTypes);

	// shadow tables should keep their table errors
	if (!m_fShadow)
	{
		m_eiError = iTableNoError;
	}

	UINT cColumns = ::MsiRecordGetFieldCount(hColNames);
	UINT cKeys = ::MsiRecordGetFieldCount(hPrimaryKeys);

	// set the size of the array then create each new column. Limit of 32 colums, cast OK.
	COrcaColumn* pColumn;
	UINT cOldColumns = static_cast<int>(m_colArray.GetSize());
	if (!m_cOriginalColumns)
		m_cOriginalColumns = cColumns;
	m_colArray.SetSize(cColumns);
	for (UINT i = cOldColumns; i < cColumns; i++)
	{
		pColumn = new COrcaColumn(i, hColNames, hColTypes, (i < cKeys));	// key bool set if index is still in primary key range
		if (!pColumn)
			continue;

		// if we already had columns when we started reading from this database, these are
		// transform-added columns
		if (cOldColumns != 0)
			pColumn->Transform(iTransformAdd);
			
		m_colArray.SetAt(i, pColumn);
	}

	// schema changed, so rebuild the SQL query
	BuildRowWhereClause();
}

// IsSchemaDifferent returns true if the table definition referenced by hDatabase 
// differs from the object's idea of the table definition. If fStrict is
// true, the match must be exact. If fStrict is false, the hDatabase
// table can have more columns at the end and still be considered a match
// (this supports using one object for a transform that adds columns)
// fExact returns true if the match is exact. If fStrict is true, retval==!fExact
bool COrcaTable::IsSchemaDifferent(MSIHANDLE hDatabase, bool fStrict, bool &fExact)
{
	fExact = false;
	
	// get primary keys for table
	PMSIHANDLE hPrimaryKeys;
	if (ERROR_SUCCESS != MsiDatabaseGetPrimaryKeys(hDatabase, m_strName, &hPrimaryKeys))
		return true;

	// query table
	CQuery queryRow;
	if (ERROR_SUCCESS != queryRow.Open(hDatabase, _T("SELECT * FROM `%s`"), m_strName))
		return true;

	// get the column info then create the table
	PMSIHANDLE hColNames;
	PMSIHANDLE hColTypes;
	queryRow.GetColumnInfo(MSICOLINFO_NAMES, &hColNames);
	queryRow.GetColumnInfo(MSICOLINFO_TYPES, &hColTypes);

	int cColumns = ::MsiRecordGetFieldCount(hColNames);
	int cKeys = ::MsiRecordGetFieldCount(hPrimaryKeys);

	// if the number of columns doesn't exactly match, fExact is false
	// and strict fails immediately
	if (cColumns != m_colArray.GetSize())
	{
		fExact = false;
		if (fStrict)
			return true;
	}

	// if the number of columns is too small, even non-strict fails
	if (!fStrict && cColumns < m_colArray.GetSize())
		return true;

	// compare the columns up to the number of columns in the object. 
	// limit of 32 columns, so int cast OK on Win64
	COrcaColumn* pColumn = NULL;
	int cMemColumns = static_cast<int>(m_colArray.GetSize());
	for (int i = 0; i < cMemColumns; i++)
	{
		// now check the column type
		pColumn = m_colArray.GetAt(i);
		if (!pColumn)
			continue;
		if (!pColumn->SameDefinition(i, hColNames, hColTypes, (i < cKeys)))
			return true;
	}	

	// no change or non-strict match
	fExact = (cMemColumns == cColumns);
	return false;
}

UINT COrcaTable::AddRow(CStringList* pstrDataList)
{
	UINT iResult = ERROR_SUCCESS;
	// retrieve column counts. Never greater than 32
	int cData = static_cast<int>(pstrDataList->GetCount());
	int cColumns = static_cast<int>(m_colArray.GetSize());
	int i = 0;

	ASSERT(cData == cColumns);

	COrcaRow* pRow = new COrcaRow(this, pstrDataList);
	if (!pRow)
		return ERROR_OUTOFMEMORY;

	// first query the database to see whether this is a dupe primary key
	CQuery queryDupe;
	CString strDupeQuery;
	strDupeQuery.Format(_T("SELECT '1' FROM `%s` WHERE %s"), Name(), GetRowWhereClause());

	PMSIHANDLE hDupeRec;
	PMSIHANDLE hQueryRec = pRow->GetRowQueryRecord();
	if (!hQueryRec)
	{
		delete pRow;
		return ERROR_FUNCTION_FAILED;
	}

	switch (queryDupe.FetchOnce(m_pDoc->GetTargetDatabase(), hQueryRec, &hDupeRec, strDupeQuery)) 
	{
	case ERROR_NO_MORE_ITEMS :
		// row does not exist in the database, so the add can succeed
		break;
	case ERROR_SUCCESS :
		// row DOES exist in the database so this is a duplicate primary key
		// fall through
	default:
		// this is bad
		delete pRow;
		return ERROR_FUNCTION_FAILED;
	}
				
	COrcaColumn* pColumn = NULL;
	PMSIHANDLE hRec = MsiCreateRecord(cColumns);

	POSITION pos = pstrDataList->GetHeadPosition();
	while (pos)
	{
		pColumn = m_colArray.GetAt(i);
		ASSERT(pColumn);
		if (!pColumn)
		{
			iResult = ERROR_FUNCTION_FAILED;
			break;
		}

		iResult = ERROR_SUCCESS;
		// call the appropriate MSI API to add the data to the record.
		switch(pColumn->m_eiType)
		{
		case iColumnString:
		case iColumnLocal:
			iResult = MsiRecordSetString(hRec, i + 1, pstrDataList->GetNext(pos));
			ASSERT(ERROR_SUCCESS == iResult);
			break;
		case iColumnShort:
		case iColumnLong:
			{
				CString strData = pstrDataList->GetNext(pos);
				DWORD dwData = 0;
				if (strData.IsEmpty())
				{
					if (!pColumn->m_bNullable)
					{
						iResult = ERROR_FUNCTION_FAILED;
						break;
					}
					iResult = MsiRecordSetString(hRec, i+1, _T(""));
				}
				else
				{
					if (!ValidateIntegerValue(strData, dwData))
					{
						iResult = ERROR_FUNCTION_FAILED;
						break;
					}
					iResult = MsiRecordSetInteger(hRec, i+1, dwData);
				}
			}
			break;
		case iColumnBinary:
			{
			CString strFile = pstrDataList->GetNext(pos);
			if (!strFile.IsEmpty())
				iResult = ::MsiRecordSetStream(hRec, i + 1, strFile);
			break;
			}
		default:
			TRACE(_T(">> Error unknown column type.\n"));
			ASSERT(FALSE);
		}

		i++;
	}

	// if everything worked, update the document
	if (ERROR_SUCCESS == iResult)
	{
		CQuery queryTable;
		if (ERROR_SUCCESS == (iResult = queryTable.Open(m_pDoc->GetTargetDatabase(), _T("SELECT * FROM `%s`"), m_strName)))
		{
			if (ERROR_SUCCESS == (iResult = queryTable.Execute()))
				iResult = queryTable.Modify(MSIMODIFY_INSERT, hRec);
		}

		if (ERROR_SUCCESS == iResult)
		{
			// we have been able to add the row to the target database. Now add the row
			// to the UI
			AddRowObject(pRow, true, false, hRec);
			m_pDoc->SetModifiedFlag(TRUE);
		}
	}
	
	if (ERROR_SUCCESS != iResult)
	{
		delete pRow;
	}
	return iResult;
}

bool COrcaTable::DropRow(COrcaRow *pRow, bool fPerformDrop)
{
	ASSERT(m_pDoc);
	ASSERT(pRow);
	CQuery qDrop;
	CString strDrop;
	strDrop = _T("DELETE FROM `")+m_strName+_T("` WHERE") + GetRowWhereClause();
	PMSIHANDLE hQueryRec = pRow->GetRowQueryRecord();
	if (!hQueryRec)
		return false;

	switch (qDrop.OpenExecute(m_pDoc->GetTargetDatabase(), hQueryRec, strDrop)) 
	{
	case ERROR_NO_MORE_ITEMS :
	{
		// row does not exist in the database. Most likely this means we are trying
		// to drop a row that has already been deleted or only exists in the non-target
		// database
		ASSERT(0);
		return false;
	}
	case ERROR_SUCCESS :
	{
		// dropped OK.
		DropRowObject(pRow, /*fPerformDrop=*/true);
		//** pRow has been deleted after this. Don't use it.
		return true;
	}
	default:
		return false;
	}
}


// DropRowObject determines if this object should be removed from the table based on the 
// presence of the row in the non-target database and either removes or changes to an 
// "add" or "drop" row. Call with fPerformDrop false to not actually remove the object from
// the UI (so it can be reused in a primary key change for example). Returns true if row was 
// actually dropped, false if row was just transformed. Deletes the row from memory if removed 
// from table. Returns true if it was actually deleted
bool COrcaTable::DropRowObject(COrcaRow *pRow, bool fPerformDrop)
{
	ASSERT(m_pDoc);
	ASSERT(pRow);

	// if this table is listed as a split source, the object should definitely
	// be deleted because there's no way that it can exist in a non-target database
	if (m_eiTableLocation != odlNotSplit)
	{
		if (fPerformDrop)
		{
 			m_rowList.RemoveAt(m_rowList.Find(const_cast<CObject *>(static_cast<const CObject *>(pRow))));
			pRow->RemoveOutstandingTransformCounts(m_pDoc);
			m_pDoc->UpdateAllViews(NULL, HINT_DROP_ROW, pRow);
			delete pRow;
		}
		return true;
	}
	
	// this query checks to see if the row exists in the opposite database than we are editing
	if (m_pDoc->DoesTransformGetEdit())
	{
		CQuery queryDupe;
		CString strDupe;
		strDupe = _T("SELECT '1' FROM `")+m_strName+_T("` WHERE") + GetRowWhereClause();
		PMSIHANDLE hDupeRec;
		
		PMSIHANDLE hQueryRec = pRow->GetRowQueryRecord();
		if (!hQueryRec)
			return false;
		switch (queryDupe.FetchOnce(m_pDoc->GetOriginalDatabase(), hQueryRec, &hDupeRec, strDupe)) 
		{
		case ERROR_NO_MORE_ITEMS :
		{
			// A does not exist in the opposite database (meaning it now exists nowhere) so 
			// this object can actually be deleted
			if (fPerformDrop)
			{
				// if this row was added, we lose a transform count here
				m_rowList.RemoveAt(m_rowList.Find(const_cast<CObject *>(static_cast<const CObject *>(pRow)))); 	
				pRow->RemoveOutstandingTransformCounts(m_pDoc);
				m_pDoc->UpdateAllViews(NULL, HINT_DROP_ROW, pRow);
				delete pRow;
			}
			return true;
		}
		case ERROR_SUCCESS :
		{
			// A DOES exist in the opposite database, so if transform editing is enabled, convert 
			// the existing row to a "drop", but leave it in the UI.
			pRow->Transform(m_pDoc, iTransformDrop, 0, 0);
			m_pDoc->UpdateAllViews(NULL, HINT_CELL_RELOAD, pRow);
			return false;
		}
		default:
			return false;
		}
	}
	else
	{
		// if no transforms, this is a simple drop
		if (fPerformDrop)
		{
			m_rowList.RemoveAt(m_rowList.Find(const_cast<CObject *>(static_cast<const CObject *>(pRow)))); 	
			m_pDoc->UpdateAllViews(NULL, HINT_DROP_ROW, pRow);
			delete pRow;
		}
	}

	m_pDoc->SetModifiedFlag(TRUE);
	return true;
}

// returns true if it should be added, false if it should be\has been destroyed
// pRow is the row of interest. fUIUpdate is 
// false if the UI should not be updated (allowed to get out of sync). Note: you 
// will still get a UI update on the destruction of an existing row even if
// fUIUpdate is FALSE. This guarantees that a WM_PAINT message won't try to 
// access the deleted memory of the destroyed row
bool COrcaTable::AddRowObject(COrcaRow *pRow, bool fUIUpdate, bool fCleanAdd, MSIHANDLE hNewRowRec)
{
	// if the table is a split table, we can definitely do the add
	if (m_eiTableLocation != odlNotSplit)
	{
		// If we're already in the target state, it means we're just editing the 
		// primary keys of a row of that type without changing the type, so don't add 
		// it to the UI again.
		OrcaTransformAction iAction = m_pDoc->DoesTransformGetEdit() ? iTransformAdd : iTransformDrop;
		if (pRow->IsTransformed() != iAction)
		{
			pRow->Transform(m_pDoc, iAction, 0, hNewRowRec);
			m_rowList.AddTail(pRow);
			if (fUIUpdate)
				m_pDoc->UpdateAllViews(NULL, HINT_ADD_ROW, pRow);
		}
		return true;
	}
	
	// if transforms are enabled, and we haven't been explicitly told to do a clean add, adding 
	// to the row becomes a bit more complicated, because a row could exist in-memory already 
	// with the same primary keys.
	if (!fCleanAdd && m_pDoc->DoesTransformGetEdit())
	{
		CQuery queryDupe;
		CString strDupe;
		PMSIHANDLE hDupeRec;
		strDupe = _T("SELECT '1' FROM `")+m_strName+_T("` WHERE") + GetRowWhereClause();
		
		// this query checks to see if a row with the same primary keys already exists in the 
		// non-target database.
		PMSIHANDLE hQueryRecord = pRow->GetRowQueryRecord();
		switch (queryDupe.FetchOnce(m_pDoc->GetOriginalDatabase(), hQueryRecord, &hDupeRec, strDupe)) 
		{
		case ERROR_BAD_QUERY_SYNTAX:
		case ERROR_NO_MORE_ITEMS :
		{
			// row does not exist in the opposite database, so this becomes an "add". If we're already
			// in the target state, it means we're just editing the primary keys of a row
			// of that type without changing the type, so don't add it to the UI again.
			if (pRow->IsTransformed() != iTransformAdd)
			{
				pRow->Transform(m_pDoc, iTransformAdd, hDupeRec, hNewRowRec);
				m_rowList.AddTail(pRow);
				if (fUIUpdate)
					m_pDoc->UpdateAllViews(NULL, HINT_ADD_ROW, pRow);
			}
			return true;
		}
		case ERROR_SUCCESS :
		{
			queryDupe.Close();
			MsiCloseHandle(hDupeRec);

			// new row DOES exist in the opposite database. If it has an in-memory
			// representation already, the existing record becomes a "change" record 
			// and the new record is destroyed. Otherwise its just an add (this happens
			// when initially loading the tables while a transform is active)
			COrcaRow* pOldRow = FindDuplicateRow(pRow);

			if (pOldRow)
			{
				for (int iCol = 0; iCol < pOldRow->GetColumnCount(); iCol++)
				{
					pOldRow->GetData(iCol)->SetData(pRow->GetData(iCol)->GetString());
				}
				pOldRow->Transform(m_pDoc, iTransformChange, 0, hNewRowRec);
				if (fUIUpdate)
					m_pDoc->UpdateAllViews(NULL, HINT_CELL_RELOAD, pOldRow);

				// the row we are adding already exists in the UI (ex: changing an "add" row key
				// to match a dropped row.) so it needs to be dropped before it is destroyed.
				POSITION pos = NULL;
				if (NULL != (pos = m_rowList.Find(static_cast<CObject *>(pRow))))
				{
					m_rowList.RemoveAt(pos); 	
					pRow->RemoveOutstandingTransformCounts(m_pDoc);
					m_pDoc->UpdateAllViews(NULL, HINT_DROP_ROW, pRow);
				}
				delete pRow;
			}
			else
			{
				// this should only happen while initially loading a table into the UI (otherwise the UI
				// state should always track the row existence in the databases.) In this case, if
				// transforms get edits, it means that the non-target database is the original DB.
				// Since it exists in the original DB, its a "Drop" if transforms get edits
				OrcaTransformAction iAction = m_pDoc->DoesTransformGetEdit() ? iTransformDrop : iTransformAdd;
				if (pRow->IsTransformed() != iAction)
				{
					pRow->Transform(m_pDoc, iAction, 0, hNewRowRec);
					m_rowList.AddTail(pRow);
					if (fUIUpdate)
						m_pDoc->UpdateAllViews(NULL, HINT_ADD_ROW, pRow);
				}
				return true;
			}

			return false;
		}
		default:
			// this is just as bad as above
			return false;;
		}
	}
	else
	{
		// if no transforms, this is a simple add
		m_rowList.AddTail(pRow);
		if (fUIUpdate)
			m_pDoc->UpdateAllViews(NULL, HINT_ADD_ROW, pRow);
	}

	return true;
}

UINT COrcaTable::ChangeData(COrcaRow *pRow, UINT iCol, CString strData)
{
	ASSERT(m_pDoc && pRow);
	if (!m_pDoc || !pRow)
		return ERROR_FUNCTION_FAILED;

	// if changing a primary key, this becomes a drop and add from a UI point of view,
	// with the possibility that everything is a change.
	if (m_colArray.GetAt(iCol)->IsPrimaryKey())
	{
		UINT iStat = ERROR_SUCCESS;
		// make the actual database change. For primary keys, this does NOT change
		// the UI representation of this row
		if (ERROR_SUCCESS == (iStat = pRow->ChangeData(m_pDoc, iCol, strData)))
		{
			// drop the old primay keys. If DropRowObject returns false, it means that the row
			// was not dropped, just transformed. So it won't work for the add.
			bool fNeedCopy = !DropRowObject(pRow, false);

			if (fNeedCopy)
			{
				COrcaRow *pNewRow = new COrcaRow(pRow);
				pNewRow->GetData(iCol)->SetData(strData);

				// will destroy copy if its not needed
				AddRowObject(pNewRow, true, false, 0);			
			}
			else
			{
				pRow->GetData(iCol)->SetData(strData);
				if (m_pDoc->DoesTransformGetEdit())
				{
					AddRowObject(pRow, true, false, 0);
				}
			}
			m_pDoc->SetModifiedFlag(TRUE);
		}
		return iStat;
	}
	else
	{
		// make the actual database change. For non-primary keys, this changes the UI as well.
		return pRow->ChangeData(m_pDoc, iCol, strData);
	}
}

/////////////////////////////////////////////////////////////////////////////
// table level transform ops are interesting because they often arise from
// adds and drops which require on-the-fly comparisons between the two
// databases or reversions to DB versions
void COrcaTable::Transform(const OrcaTransformAction iAction) 
{	
	ASSERT(m_pDoc);
	if (!m_pDoc)
		return;

	switch (iAction)
	{
		case iTransformAdd:
		{
			// set the table-level action
			m_iTransform = iAction;

			// when a table is "add"ed, it means it didn't exist in the opposite database,
			// otherwise we would have "untransformed" or split-sourced the existing table.
			// thus nothing is required except to mark the table and all of its
			// data as "add"
			RetrieveTableData();
			POSITION rowPos = GetRowHeadPosition();
			while (rowPos)
			{
				COrcaRow *pRow = const_cast<COrcaRow *>(GetNextRow(rowPos));
				if (!pRow)
					continue;

				pRow->Transform(m_pDoc, iTransformAdd, 0, 0);
			}
			break;
		}
		case iTransformDrop:
		{
			// set the table-level action
			m_iTransform = iAction;

			// when a table is dropped, it means that it exists in the non-target
			// database (otherwise it would have been simply deleted). This means
			// that we need to "clean house" in this table and reload in case
			// any edits were made before the drop. This ensures that the "dropped"
			// UI accurately reflects the contents of the other database and not
			// the contents of the target database before the drop.
			bool fSchemaChanged = false;

	
			// for split-source tables, a transform operation doesn't require any schema
			// work. Transform ops on split sources only happen when the table is first
			// created, so no reload is necessary either
			if (!IsSplitSource())
			{

				// if the schema of the remaining table is not exactly the same as what our object
				// thinks, it means that the dropped table has more columns than the remaining table
				// in this case, we have to do a reload in the UI because one or more columns is
				// now useless

				//!!future: in the future we can do a non-strict comparison and selectively delete
				//!!future: the columns so that a UI refresh is sufficient (don't lose width settings)
				bool fExact = false;
				if (IsSchemaDifferent(m_pDoc->GetOriginalDatabase(), true, fExact))
				{
					LoadTableSchema(m_pDoc->GetOriginalDatabase(), Name());
					fSchemaChanged = true;
				}
				else
				{
					// otherwise there is no need to load the schema, but we still need
					// to empty out the table and reload the rows
					EmptyTable();
				}

			}
			// now retrieve the table data
			RetrieveTableData();

			// and all data in the existing table is "dropped" because the new table is empty
			POSITION rowPos = GetRowHeadPosition();
			while (rowPos)
			{
				COrcaRow *pRow = const_cast<COrcaRow *>(GetNextRow(rowPos));
				if (!pRow)
					continue;

				pRow->Transform(m_pDoc, iAction, 0, 0);
			}

			if (fSchemaChanged)
			{
				// refresh the UI in the table list
				m_pDoc->UpdateAllViews(NULL, HINT_TABLE_REDEFINE, this);
			}
			else
			{
				// refresh the UI in the table list
				m_pDoc->UpdateAllViews(NULL, HINT_REDRAW_TABLE, this);
				
				// refresh the UI in the table list
				m_pDoc->UpdateAllViews(NULL, HINT_TABLE_DATACHANGE, this);
			}
			break;
		}
		case iTransformNone:
			m_iTransform = iTransformNone;
			break;
		case iTransformChange:
		default:
			ASSERT(0);
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////
// fills the provided array with the column names, either full or non-transformed
void COrcaTable::FillColumnArray(CTypedPtrArray<CObArray, COrcaColumn*>* prgColumn, bool fIncludeAdded) const
{
	// 32 columns max, so cast OK.
	int cColumns = static_cast<int>(m_colArray.GetSize());
	int i = 0;

	prgColumn->SetSize(cColumns);
	for (i = 0; i < cColumns; i++)
	{
		if (!fIncludeAdded && m_colArray.GetAt(i)->IsTransformed())
			break;
		prgColumn->SetAt(i, m_colArray.GetAt(i));
	}
	prgColumn->SetSize(i);
}


void COrcaTable::IncrementTransformedData() 
{	
	if (++m_iTransformedDataCount == 1)
	{
		ASSERT(m_pDoc);
		if (!m_pDoc)
			return;

		// refresh the UI in the table list
		m_pDoc->UpdateAllViews(NULL, HINT_REDRAW_TABLE, this);
	}
}

void COrcaTable::DecrementTransformedData()
{
	if (--m_iTransformedDataCount == 0)
	{
		ASSERT(m_pDoc);
		if (!m_pDoc)
			return;

		// refresh the UI in the table list
		m_pDoc->UpdateAllViews(NULL, HINT_REDRAW_TABLE, this);
	}
}

const CString COrcaTable::GetRowWhereClause() const
{
	return m_strWhereClause;
}

void COrcaTable::BuildRowWhereClause()
{
	// add the key strings to query to do the exact look up
	m_strWhereClause = _T("(");
	UINT cKeys = GetKeyCount();
	for (UINT i = 0; i < cKeys; i++)
	{
		CString strAddQuery;
		// get the column
		COrcaColumn *pColumn = ColArray()->GetAt(i);
		ASSERT(pColumn);

		strAddQuery.Format(_T("`%s`=?"), pColumn->m_strName);
			
		// if this is not the last row
		if (i < (cKeys - 1))
			m_strWhereClause  += strAddQuery + _T(" AND ");
		else	// it is the last row so close with a paren
			m_strWhereClause  += strAddQuery + _T(")");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\tblerrd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// TblErrD.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "TblErrD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTableErrorD dialog


CTableErrorD::CTableErrorD(CWnd* pParent /*=NULL*/)
	: CDialog(CTableErrorD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTableErrorD)
	m_strErrors = _T("");
	m_strWarnings = _T("");
	m_strTable = _T("");
	//}}AFX_DATA_INIT
}


void CTableErrorD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTableErrorD)
	DDX_Text(pDX, IDC_ERRORS, m_strErrors);
	DDX_Text(pDX, IDC_WARNINGS, m_strWarnings);
	DDX_Text(pDX, IDC_TABLE, m_strTable);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTableErrorD, CDialog)
	//{{AFX_MSG_MAP(CTableErrorD)
	ON_WM_DESTROY()
	ON_WM_DRAWITEM()
	ON_NOTIFY(NM_CLICK, IDC_TABLE_LIST, OnClickTableList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTableErrorD message handlers

BOOL CTableErrorD::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_TABLE_LIST);
//	pList->ModifyStyle(NULL, LVS_REPORT EDLISTVIEWSTYLE, 0, LVS_EX_F| LVS_SHOWSELALWAYS | LVS_OWNERDRAWFIXED | LVS_SINGLESEL);
	pList->SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

	RECT rcSize;
	pList->GetWindowRect(&rcSize);
	pList->InsertColumn(0, _T("ICE"), LVCFMT_LEFT, 50);
	pList->InsertColumn(1, _T("Description"), LVCFMT_LEFT, rcSize.right - 50 - rcSize.left - 4);
	pList->SetBkColor(RGB(255, 255, 255));

	int nAddedAt;
	TableErrorS* pError;
	while (m_errorsList.GetHeadPosition())
	{
		pError = m_errorsList.RemoveHead();
		nAddedAt = pList->InsertItem(LVIF_TEXT | LVIF_PARAM | LVIF_STATE, 
											  pList->GetItemCount(),
											  pError->strICE,
											  LVIS_SELECTED|LVIS_FOCUSED, 
											  0, 0,
											  (LPARAM)pError);
		pList->SetItem(nAddedAt, 
							1, 
							LVIF_TEXT, 
							pError->strDescription, 
							0, 0, 0, 0);
	}

	m_bHelpEnabled = AfxGetApp()->GetProfileInt(_T("Validation"), _T("EnableHelp"), 0)==1;
		
	return TRUE;  // return TRUE unless you set the focus to a control
}

///////////////////////////////////////////////////////////
// DrawItem
void CTableErrorD::DrawItem(LPDRAWITEMSTRUCT pDraw)
{
	// get list control
	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_TABLE_LIST);
	OrcaTableError iError = ((TableErrorS*)pList->GetItemData(pDraw->itemID))->iError;

	CDC dc;
	dc.Attach(pDraw->hDC);

	// loop through all the columns
	int iColumnWidth;
	int iTextOut = pDraw->rcItem.left;		// position to place first word (in pixels)
	RECT rcArea;

	rcArea.top = pDraw->rcItem.top;
	rcArea.bottom = pDraw->rcItem.bottom;

	CPen penBlue(PS_SOLID, 1, RGB(0, 0, 255));
	CPen* ppenOld = dc.SelectObject(&penBlue);

	CString strText;
	for (int i = 0; i < 2; i++)
	{
		iColumnWidth = pList->GetColumnWidth(i);

		// area box to redraw
		rcArea.left = iTextOut;
		iTextOut += iColumnWidth;
		rcArea.right = iTextOut;

		dc.SetTextColor(RGB(0, 0, 255));

		// get text
		strText = pList->GetItemText(pDraw->itemID, i);

		rcArea.left = rcArea.left + 2;
		rcArea.right = rcArea.right - 2;
		dc.DrawText(strText, &rcArea, DT_LEFT|DT_NOPREFIX|DT_SINGLELINE);

		// draw an underline
		if (m_bHelpEnabled)
		{
			dc.MoveTo(rcArea.left, rcArea.bottom - 2);
			dc.LineTo(rcArea.right + 2, rcArea.bottom - 2);
		}
	}

	dc.SelectObject(ppenOld);
	dc.Detach();
}	// end of DrawItem

void CTableErrorD::OnDestroy() 
{
	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_TABLE_LIST);
	int cItems =  pList->GetItemCount();
	for (int i = 0; i < cItems; i++)
	{
		delete (TableErrorS*)pList->GetItemData(i);
	}

	CDialog::OnDestroy();
}

void CTableErrorD::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	if (IDC_TABLE_LIST == nIDCtl)
		DrawItem(lpDrawItemStruct);

	CDialog::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

void CTableErrorD::OnClickTableList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	if (!m_bHelpEnabled)
		return;

	// find the selected list control
	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_TABLE_LIST);

	CString strURL = _T("");
	int cItems = pList->GetItemCount();
	for (int i = 0; i < cItems; i++)
	{
		if (pList->GetItemState(i, LVIS_SELECTED) & LVIS_SELECTED)
		{
			strURL = ((TableErrorS*)pList->GetItemData(i))->strURL;
			break;
		}
	}

	if(!strURL.IsEmpty())
	{
		if (32 >= (const INT_PTR)ShellExecute(AfxGetMainWnd()->m_hWnd, _T("open"), strURL, _T(""), _T(""), SW_SHOWNORMAL)) 
			AfxMessageBox(_T("There was an error opening your browser. Web help is not available."));
	}
	else
		AfxMessageBox(_T("There is no help associated with this ICE at this time."));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\tablevw.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// TableVw.cpp : implementation of the CTableView class
//

#include "stdafx.h"
#include "Orca.h"
#include "OrcaDoc.h"
#include "MainFrm.h"

#include "TableVw.h"
#include "EditBinD.h"
#include "CellErrD.h"

#include "..\common\utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define WM_SAVECOLWIDTH WM_USER+1

/////////////////////////////////////////////////////////////////////////////
// CTableView

IMPLEMENT_DYNCREATE(CTableView, COrcaListView)

BEGIN_MESSAGE_MAP(CTableView, COrcaListView)
	//{{AFX_MSG_MAP(CTableView)
	ON_WM_KILLFOCUS()
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDOWN()
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_WM_RBUTTONDOWN()
	ON_COMMAND(ID_ROW_DROP, OnDropRowConfirm)
	ON_COMMAND(IDM_ERRORS, OnErrors)
	ON_COMMAND(IDM_PROPERTIES, OnProperties)
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_UPDATE_COMMAND_UI(ID_ROW_DROP, OnUpdateRowDrop)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_COPY_ROW, OnEditCopyRow)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY_ROW, OnUpdateEditCopyRow)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT_ROW, OnUpdateEditCutRow)
	ON_COMMAND(ID_EDIT_CUT_ROW, OnEditCutRow)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_ROW, OnUpdateEditPasteRow)
	ON_COMMAND(ID_EDIT_PASTE_ROW, OnEditPasteRow)
	ON_WM_KEYUP()
	ON_WM_CHAR()
	ON_WM_SIZE()
	ON_COMMAND(ID_VIEW_HEX, OnViewColumnHex)
	ON_COMMAND(ID_VIEW_DECIMAL, OnViewColumnDecimal)
	ON_COMMAND(ID_VIEW_HEX_HDR, OnViewColumnHexHdr)
	ON_COMMAND(ID_VIEW_DECIMAL_HDR, OnViewColumnDecimalHdr)
	ON_UPDATE_COMMAND_UI(ID_VIEW_HEX, OnUpdateViewColumnFormat)
	ON_UPDATE_COMMAND_UI(ID_VIEW_DECIMAL, OnUpdateViewColumnFormat)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnclick)
	ON_COMMAND(ID_FILE_PRINT, COrcaListView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, COrcaListView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, COrcaListView::OnFilePrintPreview)
	ON_NOTIFY_EX(TTN_NEEDTEXTW, 0, OnToolTipNotify)
	ON_NOTIFY_EX(TTN_NEEDTEXTA, 0, OnToolTipNotify)

	ON_WM_MOUSEMOVE( )
	ON_WM_CTLCOLOR( )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTableView construction/destruction

CTableView::CTableView()
{
	m_pTable = NULL;
	m_cColumns = 0;
	m_nSelCol = -1;

	m_bCtrlDown = FALSE;

	m_pctrlToolTip = NULL;
	m_iToolTipItem = -1;
	m_iToolTipColumn = -1;
	m_iHeaderClickColumn = -1;
}

CTableView::~CTableView()
{
	m_pTable = NULL;
}

BOOL CTableView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return COrcaListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CTableView drawing

void CTableView::OnDraw(CDC* pDC)
{
}

void CTableView::OnInitialUpdate()
{
	COrcaListView::OnInitialUpdate();

	m_pctrlToolTip = new CToolTipCtrl();
	if (m_pctrlToolTip)
	{
		m_pctrlToolTip->Create(this);
		m_pctrlToolTip->AddTool(this);
		m_pctrlToolTip->Activate(FALSE);
	}

	CListCtrl& rctrlList = GetListCtrl();
	
	// if the edit box is not created yet
	if (!m_editData.m_hWnd)
	{
		RECT rcEdit;
		rcEdit.left = 0;
		rcEdit.top = 0;
		rcEdit.right = 10;
		rcEdit.bottom = 10;

		m_editData.Create(WS_CHILD|ES_AUTOHSCROLL|ES_LEFT|WS_BORDER, rcEdit, this, 0);
		m_editData.SetFont(this->GetFont());

		// allow maximum possible text size. Limit will vary by OS
		m_editData.SetLimitText(0);
	}
	if (!m_ctrlStatic.m_hWnd)
	{
		RECT rcStatic = {0,0,10,10};
		m_ctrlStatic.Create(TEXT("This table does not actually exist in your database. It appears in the table list because one or more validators has indicated an error in this table."), WS_CHILD|WS_MAXIMIZE|SS_CENTER, rcStatic, this);		
		m_ctrlStatic.SetFont(this->GetFont());
	}

	// clear out any left over tables
	m_pTable = NULL;
	while (rctrlList.DeleteColumn(0))
		;
}

/////////////////////////////////////////////////////////////////////////////
// CTableView printing

BOOL CTableView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CTableView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CTableView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CTableView diagnostics

#ifdef _DEBUG
void CTableView::AssertValid() const
{
	COrcaListView::AssertValid();
}

void CTableView::Dump(CDumpContext& dc) const
{
	COrcaListView::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTableView message handlers

///////////////////////////////////////////////////////////
// OnUpdate
void CTableView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// if this is the sender bail
	if (this == pSender)
		return;

	// set the row and column selections to nothing
	CListCtrl& rctrlList = GetListCtrl();

	switch (lHint) {
	case HINT_REDRAW_ALL:
	{
		rctrlList.RedrawItems(0, rctrlList.GetItemCount());
		break;
	}
	case HINT_DROP_TABLE:	// if this is a "drop table" hint
	{
		COrcaTable* pTable = (COrcaTable*)pHint;

		// clear the selection
		m_nSelCol = -1;

		// if droping the current viewed table
		if (pTable == m_pTable)
		{
			// empty out the list control
			rctrlList.DeleteAllItems();
		
			// delete all the columns
			while(rctrlList.DeleteColumn(0))
				;
			m_cColumns = 0;

			m_pTable = NULL;

			// kill the edit box no matter what
			CommitEdit(FALSE);	// but don't save, too late for that probably
		}
		break;
	}
	case HINT_DROP_ROW:	// if this is a request to drop a row
	{
		// pHint may be freed memory already. DO NOT dereference it within
		// this block!
		COrcaRow* pRowHint = (COrcaRow*)pHint;
		COrcaRow* pRow = NULL;

		// clear the selection
		m_nSelCol = -1;

		// make sure this row is actually in the list control
		int iFound = -1;
		int cItems = rctrlList.GetItemCount();
		for (int i = 0; i < cItems; i++)
		{
			pRow = (COrcaRow*)rctrlList.GetItemData(i);
			if (pRow == pRowHint)
			{
				iFound = i;
				break;
			}
		}
		ASSERT(iFound > -1);	// make sure we found something
		rctrlList.DeleteItem(iFound);

		// kill the edit box no matter what
		CommitEdit(FALSE);	// but don't save, too late for that probably

		// update the row count in the status bar
		((CMainFrame*)AfxGetMainWnd())->SetTableName(m_pTable->Name(), rctrlList.GetItemCount());

		return;	// bail now
	}
	case HINT_ADD_ROW_QUIET:
	case HINT_ADD_ROW:
	{
		ASSERT(pHint);
		// kill the edit box no matter what
		CommitEdit(FALSE);	// but don't save, too late for that probably

		COrcaRow* pRowHint = (COrcaRow*)pHint;
#ifdef _DEBUG
		COrcaRow* pRow;

		// make sure this row in NOT the list control already
		int cItems = rctrlList.GetItemCount();
		for (int i = 0; i < cItems; i++)
		{
			pRow = (COrcaRow*)rctrlList.GetItemData(i);
			ASSERT(pRow != pRowHint);
		}
#endif	// debug only

		int m_cColumns = m_pTable->GetColumnCount();
		COrcaData* pData = pRowHint->GetData(0);

		UnSelectAll();

		// add the item filling in the first column for free
		int iNewRow = rctrlList.InsertItem(LVIF_PARAM  | LVIF_STATE, 
													rctrlList.GetItemCount(),
													NULL,
													LVIS_SELECTED|LVIS_FOCUSED,
													0, 0,
													(LPARAM)pRowHint);
		ASSERT(-1 != iNewRow);

		m_nSelCol = 0;

		// when adding quietly, don't redraw
		if (lHint != HINT_ADD_ROW_QUIET)
		{
			rctrlList.RedrawItems(iNewRow, iNewRow);
			
			// update the row count in the status bar
			((CMainFrame*)AfxGetMainWnd())->SetTableName(m_pTable->Name(), rctrlList.GetItemCount());
		}

		break;
	}
	case HINT_TABLE_REDEFINE:
	case HINT_RELOAD_ALL:
	case HINT_CHANGE_TABLE:
	{
		// clear the selection
		m_nSelCol = -1;

		// save the existing column widths, unless the table is not loaded, is a shadow
		// table, or is a same-table redefinition
		if (m_pTable != NULL && !m_pTable->IsShadow() && (m_pTable != pHint)) 
		{
			m_cColumns = m_pTable->GetColumnCount();
			for (int i = 0; i < m_cColumns; i++)
			{
				const COrcaColumn* pColumn = m_pTable->GetColumn(i);
				pColumn->m_nWidth = rctrlList.GetColumnWidth(i);
			}
		}

		// if we are showing a different table, or the same table that has been redefined
		if ((pHint == NULL) || (m_pTable != pHint) || (m_pTable == pHint && lHint == HINT_TABLE_REDEFINE))
		{		
			rctrlList.DeleteAllItems();

			// delete all the columns
			while(rctrlList.DeleteColumn(0))
				;
			m_cColumns = 0;

			if (NULL != m_pTable)
			{
				// kill the edit box no matter what
				CommitEdit(FALSE);	// but don't save, too late for that probably
			}

			// if no hint was passed, we're clearing the table, so bail
			if (NULL == pHint)
			{
				m_pTable = NULL;
				m_ctrlStatic.ShowWindow(SW_HIDE);
				UpdateWindow();
				break;
			}

			// get the number of columns in the table
			m_pTable = (COrcaTable*) pHint;

			// if a shadow table, don't create any columns and don't try
			// to load any data, but do destroy previous data by 
			// falling through to a table reload
			if (m_pTable->IsShadow())
			{
				m_ctrlStatic.ShowWindow(SW_SHOW);
			}
			else 
			{
				m_ctrlStatic.ShowWindow(SW_HIDE);
				m_cColumns = m_pTable->GetColumnCount();

				// storage for actual desired column widths
				int rgiColumnActual[32];

				// if the table doesn't have saved 
				// column widths,determine the best widths
				const COrcaColumn* pColumn = m_pTable->GetColumn(0);
				if (pColumn && pColumn->m_nWidth < 0)
				{
					int rgiColumnMax[32];
					int iTotalWidth = 0;
	
					// grab the window dimensions to calculate maximum column widths
					CRect rClient;
					GetClientRect(&rClient);
					int iWindowWidth = rClient.right;

					// retrieve the table if necessary to determine row count
					m_pTable->RetrieveTableData();

					// try to determine if a scroll bar is going to show up 
					if (m_pTable->GetRowCount()*m_iRowHeight > rClient.bottom)
					{
						iWindowWidth -= GetSystemMetrics(SM_CXVSCROLL);
					}
	
					// retreive the desired column widths for the table
					GetAllMaximumColumnWidths(m_pTable, rgiColumnMax, 0xFFFFFFFF);
	
					// check the system settings to see if we should force columns to fit in the view
					bool fForceColumns = AfxGetApp()->GetProfileInt(_T("Settings"), _T("ForceColumnsToFit"), 1) == 1;

					// start out giving every column everything that it is requesting
					for (int iCol=0; iCol < m_cColumns; iCol++)
					{
						rgiColumnActual[iCol] = rgiColumnMax[iCol];
						iTotalWidth += rgiColumnMax[iCol];
					}

					if (!fForceColumns)
					{
						// if not forcing to fit, just verify that none of the numbers are outrageous
						for (int iCol=0; iCol < m_cColumns; iCol++)
						{
							if (rgiColumnActual[iCol] > iWindowWidth)
								rgiColumnActual[iCol] = iWindowWidth;;
						}
					}
					else
					{
						// if all of the column widths together add up to less than the window width, the maximum
						// widths will do. 
						if (iTotalWidth > iWindowWidth)
						{
							int cPrimaryKeys = m_pTable->GetKeyCount();
							int cUnSatisfiedColumns = 0;
							int cUnSatisfiedKeys = 0;
		
							// otherwise, set all columns to an equal part of the window or their requested max, 
							// whichever is less. After this the sum of all widths is known to be <= the window
							int iColumnAverage = iWindowWidth/m_cColumns;
							iTotalWidth = 0;
							for (iCol=0; iCol < m_cColumns; iCol++)
							{
								if (rgiColumnActual[iCol] > iColumnAverage)
								{
									rgiColumnActual[iCol] = iColumnAverage;
									cUnSatisfiedColumns++;
									if (iCol < cPrimaryKeys)
										cUnSatisfiedKeys++;
								}
								iTotalWidth += rgiColumnActual[iCol];
							}
							
							// give any extra space to unhappy columns. Start with just the primary keys. 
							// If they can be given enough space and there is still space left over,
							// distribute the remaining space evenly between all remaning unhappy columns,
							// Earlier columns have higher priority on leftovers. Repeat until everybody 
							// is happy or all space has been taken up.
							while (cUnSatisfiedColumns && (iTotalWidth != iWindowWidth))
							{
								int iRemainingUnSatisfied = cUnSatisfiedKeys ? cUnSatisfiedKeys : cUnSatisfiedColumns;
		
								for (iCol = (cUnSatisfiedKeys ? cPrimaryKeys : m_cColumns)-1; iCol >= 0; iCol--)
								{
									if (rgiColumnActual[iCol] >= rgiColumnMax[iCol])
										continue;
			
									// give this column an equal share of what's left.
									int iAddToColumn = (iWindowWidth-iTotalWidth)/iRemainingUnSatisfied;
									iRemainingUnSatisfied--;
			
									// again, if we would be setting the column larger than it needs,
									// set it to the maximum. This gives more space for earlier columns
									if (rgiColumnActual[iCol]+iAddToColumn > rgiColumnMax[iCol])
									{
										iTotalWidth = iTotalWidth - rgiColumnActual[iCol] + rgiColumnMax[iCol];
										rgiColumnActual[iCol] = rgiColumnMax[iCol];
										cUnSatisfiedColumns--;
										if (iCol < cPrimaryKeys)
											cUnSatisfiedKeys--;
									}
									else
									{
										iTotalWidth += iAddToColumn;
										rgiColumnActual[iCol] += iAddToColumn;
									}
								}
							}
						}
					}
				}			

				// add all the columns
				for (int i = 0; i < m_cColumns; i++)
				{
					pColumn = m_pTable->GetColumn(i);

					int iWidth = pColumn->m_nWidth < 0 ? rgiColumnActual[i] : pColumn->m_nWidth;
					rctrlList.InsertColumn(i, pColumn->m_strName, LVCFMT_LEFT, iWidth, i);
				}
			}
		}
		else
		{
			// showing the same table, so 
			break;
		}
		// otherwise fall through to reload data
	}
	case HINT_TABLE_DATACHANGE:
	{
		rctrlList.DeleteAllItems();
		int cItems = 0;

		if (m_pTable)
		{
			// if a shadow table don't try to load any data, just the message
			if (!m_pTable->IsShadow())
			{
    			// retrieve the table if necessary
				m_pTable->RetrieveTableData();

				// set the number of items into the list control
				// control apparently can't handle more than MAX_INT, so 
				// casting down isn't too bad
				rctrlList.SetItemCount(static_cast<int>(m_pTable->GetRowCount()));
				const COrcaRow* pRow = NULL;
				const COrcaData* pData = NULL;
				int nAddedRow;
				POSITION pos = m_pTable->GetRowHeadPosition();
				while (pos)
				{
					pRow = m_pTable->GetNextRow(pos);
					if (!pRow)
						continue;

					pData = pRow->GetData(0);
					if (!pData)
						continue;

					// add the item filling in the first column for free
					nAddedRow = rctrlList.InsertItem(LVIF_PARAM, 
																cItems,
																NULL,
																0, 0, 0,
																(LPARAM)pRow);
					
					cItems++;
				}
			}
			((CMainFrame*)AfxGetMainWnd())->SetTableName(m_pTable->Name(), cItems);
			UpdateWindow();
		}
		break;
	}
	case HINT_COMMIT_CHANGES:
	{
		CommitEdit(TRUE);
		break;
	}
	case HINT_SET_ROW_FOCUS:
	{
		UnSelectAll();
		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);

		// this didn't come from us, so we have to set the selection state manually
		int iItem = rctrlList.FindItem(&findInfo);
		if (iItem < 0) break;
		rctrlList.SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		rctrlList.EnsureVisible(iItem, FALSE);
		break;
	}
	case HINT_SET_COL_FOCUS:
	{
		UINT iItem = GetFocusedItem();
        // max column id is 32
		m_nSelCol = static_cast<int>(reinterpret_cast<INT_PTR>(pHint));
		EnsureVisibleCol(m_nSelCol);
		rctrlList.RedrawItems(iItem, iItem);
		break;
	}
	case HINT_CELL_RELOAD:
	{
		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);
		int iItem = rctrlList.FindItem(&findInfo);
		if (iItem < 0)
			break;
		
		rctrlList.EnsureVisible(iItem, FALSE);
		break;
	}
	default:
		break;
	}
}	// end of OnUpdate

void CTableView::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	TRACE(_T("CTableView::OnColumnclick - called.\n"));
	TRACE(_T("Item: %d, Subitem: %d, OldState: %d, NewState: %d, Changed: %d, Param: %d\n"), 
			pNMListView->iItem, 
			pNMListView->iSubItem, 
			pNMListView->uNewState, 
			pNMListView->uOldState,
			pNMListView->uChanged,
			pNMListView->lParam);

	// set the param with the column in it (the highest bit sets the column type)
	LPARAM lParam = pNMListView->iSubItem;

	const COrcaColumn* pColumn = m_pTable->GetColumn(pNMListView->iSubItem);
	ASSERT(pColumn);
	if (pColumn)
	{
		OrcaColumnType eiColType = pColumn->m_eiType;
	
		// if this is a numeric column
		if (iColumnShort == eiColType || iColumnLong == eiColType)
		{
			lParam |= 0x80000000;	// make the top bit a 1
			if (pColumn->DisplayInHex())
				lParam |= 0x40000000;
		}
	
		// now sort since the column bit is set
		GetListCtrl().SortItems(SortView, lParam);
	
		// ensure that the item is still visible
		GetListCtrl().EnsureVisible(GetFocusedItem(), /*partialOK=*/false);
	}

	*pResult = 0;	
}

void CTableView::OnKillFocus(CWnd* pNewWnd) 
{
	CommitEdit(TRUE);
	if (m_pctrlToolTip)
	{
		m_pctrlToolTip->Activate(FALSE);
		m_iToolTipItem = -1;
		m_iToolTipColumn = -1;
	}
	COrcaListView::OnKillFocus(pNewWnd);
}

BOOL CTableView::CommitEdit(BOOL bSave /*= TRUE*/)
{
	if (m_editData.IsWindowVisible())
	{
		// hide the edit box real quick
		m_editData.ShowWindow(SW_HIDE);

		if (bSave)
		{
			// get the cell
			CListCtrl& rctrlList = GetListCtrl();
			COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(m_editData.m_nRow);
			ASSERT(pRow);
			COrcaData* pData = pRow->GetData(m_editData.m_nCol);
			ASSERT(pData);

			// update the data
			CString strData;
			m_editData.GetWindowText(strData);

			const COrcaColumn* pColumn = m_pTable->GetColumn(m_editData.m_nCol);
			ASSERT(pColumn);

			if (pColumn && strData != pData->GetString(pColumn->m_dwDisplayFlags))
			{
				UINT iResult = m_pTable->ChangeData(pRow, m_editData.m_nCol, strData);

				// if we succeeded in changing the document
				if (ERROR_SUCCESS == iResult)
				{
					// update the list control
					rctrlList.RedrawItems(m_editData.m_nRow, m_editData.m_nRow);
				}
				else	// tell the user that what they are doing is not valid
				{
					CString strPrompt;
					strPrompt.Format(_T("Could not change this cell to \'%s\'"), strData);
					switch (iResult) {
					case MSIDBERROR_REQUIRED: 
						strPrompt += _T(". Null values are not allowed in this column.");
						break;
					case MSIDBERROR_DUPLICATEKEY:
						strPrompt += _T(". because it would result in two records having the same primary key(s).");
						break;
					case MSIDBERROR_STRINGOVERFLOW:
						strPrompt += _T(". because the string is too long for this cell.");
						break;
					case MSIDBERROR_OVERFLOW:
						strPrompt += _T(". The string does not represent a number.");
						break;
					default:
						strPrompt += _T(". The data was rejected by the database.\nIt may be out of the valid range or formatted incorrectly.");
					}
					AfxMessageBox(strPrompt, MB_ICONINFORMATION);
				}
			}
		}
	}

	return TRUE;
}

void CTableView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	TRACE(_T("CTableView::OnKeyDown - called\n"));

	// if the edit box is open it probably sent the message. We don't want
	// to handle any of those right now. 
	//!! FUTURE: Might be nice at some point to have Up and Down commit the 
	// edit and move you up or down one row.)
	if (!m_editData.IsWindowVisible())
	{
		if (VK_LEFT == nChar)
		{
			// left arrow key we must update the column, the list ctrl will take care of row.
			if (m_nSelCol > 0)
			{
				m_nSelCol--;

				// get list control
				CListCtrl& rctrlList = GetListCtrl();

				int iItem = GetFocusedItem();
				rctrlList.RedrawItems( iItem, iItem);
				UpdateColumn(m_nSelCol);
			}
		}
		else if (VK_RIGHT == nChar)
		{
			// left arrow key we must update the column, the list ctrl will take care of row.
			if ((m_nSelCol < m_cColumns - 1) && (m_nSelCol > -1))
			{
				m_nSelCol++;

				// get list control
				CListCtrl& rctrlList = GetListCtrl();
				
				int iItem = GetFocusedItem();				
				rctrlList.RedrawItems( iItem, iItem);
				UpdateColumn(m_nSelCol);
			}
		}
		else if (VK_HOME == nChar)
		{		
			// home key we must update the column,
			m_nSelCol= 0;

			// get list control
			CListCtrl& rctrlList = GetListCtrl();
				
			int iItem = GetFocusedItem();				
			rctrlList.RedrawItems( iItem, iItem);
			if (m_bCtrlDown) {

				UnSelectAll();
				rctrlList.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, 
					LVIS_SELECTED | LVIS_FOCUSED);
				rctrlList.EnsureVisible(0, FALSE);
			};
			UpdateColumn(m_nSelCol);
		}
		else if (VK_END == nChar)
		{
			// end key we must update the column,
			m_nSelCol = m_cColumns-1;

			// get list control
			CListCtrl& rctrlList = GetListCtrl();
				
			int iItem = GetFocusedItem();				
			rctrlList.RedrawItems( iItem, iItem);
			if (m_bCtrlDown) {

				UnSelectAll();
				int iLastItem = rctrlList.GetItemCount()-1; 
				rctrlList.SetItemState(iLastItem, LVIS_SELECTED | LVIS_FOCUSED, 
					LVIS_SELECTED | LVIS_FOCUSED);
				rctrlList.EnsureVisible(iLastItem, FALSE);
			};
			UpdateColumn(m_nSelCol);
		}
		else if (VK_DELETE == nChar)
		{
			// get list control
			CListCtrl& rctrlList = GetListCtrl();
			
			// if some row(s) are selected
			if (rctrlList.GetSelectedCount() > 0)
				OnDropRowConfirm();	// drop the row
		}
		else if (VK_INSERT == nChar)
		{
			GetDocument()->OnRowAdd();
		}
		else if (VK_CONTROL == nChar)
		{
			m_bCtrlDown = TRUE;
		}
		else
			COrcaListView::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}

void CTableView::OnLButtonDown(UINT nFlags, CPoint point) 
{
//	TRACE(_T("CTableView::OnLButtonDown - called at: %d,%d.\n"), point.x, point.y);

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get if any item was hit
	UINT iState;
	int iItem = rctrlList.HitTest(point, &iState);
	int iCol = -1;

	// shift by the scroll point
	int nScrollPos = GetScrollPos(SB_HORZ);
	point.x += nScrollPos;

	// if missed an item
	if (iItem < 0 || !(iState & LVHT_ONITEM))
	{
		m_nSelCol = -1;
		UpdateColumn(m_nSelCol);
		COrcaListView::OnLButtonDown(nFlags, point);
	}
	else
	{
		// get the column of the hit
		int nX = 0;
		int nWidth;
		for (int i = 0; i < m_cColumns; i++)
		{
			nWidth = rctrlList.GetColumnWidth(i);

			if (point.x >= nX && point.x < nX + nWidth)
			{
				iCol = i;
				break;		// found the column break
			}

			nX += nWidth;	// move x over to the next column
		}

		// if the user clicked outside of the items
		if (iCol < 0)
		{
			// if something was selected try and commit the edit box
			if ((rctrlList.GetSelectedCount() == 1) && m_nSelCol >= 0)
				CommitEdit(TRUE);

			m_nSelCol = -1;
			UpdateColumn(m_nSelCol);
			return;
		}

		// store the previous selections and update to the new ones
		int nPrevCol = m_nSelCol;

		// set the new selected items
		m_nSelCol = iCol;
		UpdateColumn(m_nSelCol);

		// find out if the clicked on item has the focus
		bool bFocused = (0 != rctrlList.GetItemState(iItem, LVIS_FOCUSED));

		if (bFocused) 
		{
			// need to manually set selection state 
			rctrlList.SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
			rctrlList.RedrawItems(iItem, iItem);
		}
		else 
		{
			COrcaListView::OnLButtonDown(nFlags, point);
		} 

		// if item that was clicked already had the focus, and the column was the same
		if (bFocused && (nPrevCol == m_nSelCol))
		{
			EditCell(FALSE);
		}
		else	// commit the editbox
			CommitEdit(TRUE);
	}
}	// end of OnLButtonDown();

///////////////////////////////////////////////////////////////////////
// responsible for handling the creation of the cell edit box if 
// the document can be edited.
void CTableView::EditCell(BOOL bSelectAll /*= TRUE*/) 
{
	if (GetDocument()->TargetIsReadOnly())
		return;

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	int nSelRow = GetFocusedItem();
	ASSERT(nSelRow >= 0);
	ASSERT(m_nSelCol >= 0);

	// get the row and data
	COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(nSelRow);
	ASSERT(pRow);
	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);

	// if the row doesn't exist in the currently active database, you can't edit it
	if (!GetDocument()->IsRowInTargetDB(pRow))
		return;

	// if the column doesn't exist in the target DB, you can't edit it either
	const COrcaColumn* pColumn = m_pTable->GetColumn(m_nSelCol);
	if (!pColumn)
		return;
	if (!GetDocument()->IsColumnInTargetDB(pColumn))
		return;


	// if the colum is a binary type, you can't edit it
	if (iColumnBinary == pColumn->m_eiType)
	{
		CEditBinD dlg;

		dlg.m_fNullable = (m_pTable->GetColumn(m_nSelCol)->m_bNullable != 0);
		dlg.m_fCellIsNull = pData->IsNull();
		if (IDOK == dlg.DoModal())
		{
			COrcaDoc* pDoc = GetDocument();
			UINT iResult;
			if (dlg.m_nAction == 0)
			{
				iResult = pRow->ChangeBinaryData(pDoc, m_nSelCol, dlg.m_strFilename);
			}
			else
				iResult = pDoc->WriteBinaryCellToFile(m_pTable, pRow, m_nSelCol, dlg.m_strFilename);

			// if we succeeded in changing the document
			if (ERROR_SUCCESS == iResult)
			{
				// if we were importing
				if (0 == dlg.m_nAction)
					pDoc->SetModifiedFlag(TRUE);	// set that the document has changed

            	// update the list control
				rctrlList.RedrawItems(nSelRow, nSelRow);

				// else exporting should have no affect on document
			}
			else	// tell the user that what they are doing is not valid
			{
				CString strPrompt;
				strPrompt.Format(_T("Failed to update the cell"));
				AfxMessageBox(strPrompt, MB_ICONINFORMATION);
			}
		}

		return;	// all done
	}

	int nScrollPos = GetScrollPos(SB_HORZ);

	// get the column start and width
	// shift back by the scroll point
	int nX = -nScrollPos;
	int nWidth = 0;
	for (int i = 0; i <= m_nSelCol; i++)
	{
		nX += nWidth;	// move x over to the next column
		nWidth = rctrlList.GetColumnWidth(i);
	}

	// change the size of the edit box appropriately
	RECT rcCell;
	BOOL bResult = rctrlList.GetItemRect(nSelRow, &rcCell, LVIR_BOUNDS);
	ASSERT(bResult);

	// move the edit box to the correct coordinates
	m_editData.MoveWindow(nX, rcCell.top, nWidth + 1, rcCell.bottom - rcCell.top + 1, FALSE);
	m_editData.SetFont(m_pfDisplayFont, FALSE);

	// put the text from this cell in the edit box
	m_editData.SetWindowText(pData->GetString(pColumn->m_dwDisplayFlags));
	if (bSelectAll)
		m_editData.SetSel(0, -1);
	else
		m_editData.SetSel(pData->GetString().GetLength(), pData->GetString().GetLength());

	// set the cell position of the edit box
	m_editData.m_nRow = nSelRow;
	m_editData.m_nCol = m_nSelCol;

	// finally show the window and set focus
	m_editData.SetFocus();
	m_editData.ShowWindow(SW_SHOW);
	m_editData.BringWindowToTop();
}	// end of EditCell


void CTableView::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// if the user is not clicking in bounds
	if (GetFocusedItem() < 0 || m_nSelCol < 0)
	{
		// if there is a table selected
		if (m_pTable && !m_pTable->IsShadow() && !(m_pTable->IsTransformed() == iTransformDrop))
			GetDocument()->OnRowAdd();		// bring up the add row dialog box
		return;
	}

	// otherwise edit the cell (read only handled by EditCell())
	EditCell();
	*pResult = 0;
}


///////////////////////////////////////////////////////////
// SortView
int CALLBACK SortView(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	BOOL bNumeric = FALSE;
	bool bNumericHex = false;

	// if any of the top bits of lParamSort is TRUE it's a numeric column
	if (0 != (lParamSort & 0xF0000000))
	{
		bNumeric = TRUE;	// set the numeric flag try
		bNumericHex = (lParamSort & 0x40000000) ? true : false;
		lParamSort = lParamSort & ~0xF0000000;
	}

	// get the rows
	COrcaRow* pRow1 = (COrcaRow*)lParam1;
	COrcaRow* pRow2 = (COrcaRow*)lParam2;
	COrcaData* pData1 = pRow1->GetData(static_cast<int>(lParamSort));
	COrcaData* pData2 = pRow2->GetData(static_cast<int>(lParamSort));

	// if it is a numeric column
	if (bNumeric)
	{
		DWORD lData1 = static_cast<COrcaIntegerData*>(pData1)->GetInteger();
		DWORD lData2 = static_cast<COrcaIntegerData*>(pData2)->GetInteger();

		if (lData1 == lData2)
			return 0;
		else
		{
			// in hex view, sort absolute, otherwise sort signed
			if (bNumericHex)
				return (static_cast<unsigned int>(lData1) > static_cast<unsigned int>(lData2)) ?  1 : -1;
			else
				return (static_cast<int>(lData1) > static_cast<int>(lData2)) ? 1 : -1;
		}
	}
	else	// non-numeric
		return ((CMainFrame *)AfxGetMainWnd())->m_bCaseSensitiveSort ? pData1->GetString().Compare(pData2->GetString()) : 
					pData1->GetString().CompareNoCase(pData2->GetString());
}	// end of SortView


void CTableView::OnRButtonDown(UINT nFlags, CPoint point) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	
	// get if any item was hit
	UINT iState;
	int iItem = rctrlList.HitTest(point, &iState);
	int iCol = -1;

	// shift by the scroll point
	int nScrollPos = GetScrollPos(SB_HORZ);
	point.x += nScrollPos;

	BOOL bGoodHit = TRUE;		// assume the hit was inbounds

	// if missed an item
	if (iItem < 0 || !(iState & LVHT_ONITEM))
	{
		
		bGoodHit = FALSE;	// not even close to in bounds
	}
	else	// something was hit with the mouse button
	{
		// get the column of the hit
		int nX = 0;
		int nWidth;
		for (int i = 0; i < m_cColumns; i++)
		{
			nWidth = rctrlList.GetColumnWidth(i);

			if (point.x >= nX && point.x < nX + nWidth)
			{
				iCol = i;
				break;		// found the column break
			}

			nX += nWidth;	// move x over to the next column
		}

		// if the user clicked outside of the items
		if (iCol < 0)
		{
			CommitEdit(TRUE);
			m_nSelCol = -1;
			bGoodHit = FALSE;	// hit was actually out of bounds
		}
		else 
		{
			// set the new selected items
			m_nSelCol = iCol;
		}
		UpdateColumn(m_nSelCol);

		// list control won't redraw if the same row is selected so force it to redraw
		rctrlList.RedrawItems(iItem, iItem);

		// now commit the edit box just incase it was left open
		CommitEdit(TRUE);


	}

	ClientToScreen(&point);


	COrcaRow* pRow = NULL;
	COrcaData* pData = NULL;

	if (!bGoodHit)
	{
		// clear the focus 
		int iFocusItem = GetFocusedItem();
		if (iFocusItem >= 0) {
			rctrlList.SetItemState(iFocusItem, 0, LVIS_FOCUSED);
		}
	}
	else
	{
		// set the focus to the right location
		UnSelectAll();
		rctrlList.SetItemState(iItem, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
		rctrlList.RedrawItems(iItem, iItem);
		UpdateWindow();
	
		// get the item data
		pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
		ASSERT(pRow);
		if (!pRow)
			return;
		pData = pRow->GetData(iCol);
		ASSERT(pData);
		if (!pData)
			return;
	}

	// create and track the pop up menu
	CMenu menuContext;
	menuContext.LoadMenu(IDR_CELL_POPUP);
	if (m_pTable && iCol > 0 && iCol <= m_pTable->GetColumnCount())
	{
		const COrcaColumn* pColumn = m_pTable->GetColumn(iCol);
		if (pColumn)
		{
			if (pColumn->m_eiType == iColumnShort || pColumn->m_eiType == iColumnLong)
			{
				menuContext.CheckMenuRadioItem(ID_VIEW_DECIMAL, ID_VIEW_HEX, pColumn->DisplayInHex() ? ID_VIEW_HEX : ID_VIEW_DECIMAL, MF_BYCOMMAND);
			}
		}
	}
	menuContext.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, point.x - nScrollPos, point.y, AfxGetMainWnd());
}

void CTableView::OnDropRowConfirm() {
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	CString strPrompt;

	int iNumRows = rctrlList.GetSelectedCount();

	strPrompt.Format(_T("This will permanently remove %d rows from this database.\nDo you wish to continue?"),
		iNumRows);

	if (IDOK == AfxMessageBox(strPrompt, MB_OKCANCEL, 0)) {
		DropRows();
	};
};

void CTableView::DropRows() 
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	COrcaTable* pTable = pFrame->GetCurrentTable();

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// find first item
	POSITION pos = GetFirstSelectedItemPosition();

	ASSERT(pos != NULL);
	
	// repeat for every selected row. Because we are dropping rows in the midle of this 
	// selection iterator, we have to reset it every time. 
	while (pos) 
	{
		UINT iItem = GetNextSelectedItem(pos);
		// get the row and data
		COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
		ASSERT(pRow);
		if (!pRow)
			continue;

		// if the row doesn't exist in the active database, we can't really drop it
		if (!GetDocument()->IsRowInTargetDB(pRow))
			continue;

		// we need to mark this row as not selected before we drop it, because if the drop 
		// actually applies to a transform, the entry in the view will not actually go
		// away and GetFirstSelectedItemPosition will return the exact same row again
		// we can't do this afterwards because this view doesn't know whats going on under
		// the hood. pRow could point to freed memory.
		rctrlList.SetItemState(iItem, 0, LVIS_SELECTED);
		
		// drop row 
		GetDocument()->DropRow(pTable, pRow);
		pos = GetFirstSelectedItemPosition();
	}
}

void CTableView::OnErrors() 
{
	// get the item data
	CListCtrl& rctrlList = GetListCtrl();
	int iItem = GetFocusedItem();
	ASSERT(iItem >= 0);
	COrcaRow* pRow = (COrcaRow *)rctrlList.GetItemData(iItem);
	ASSERT(pRow);
	if (!pRow)
		return;

	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);
	if (!pData)
		return;

	ASSERT(iDataNoError != pData->m_eiError);

	pData->ShowErrorDlg();
}

void CTableView::OnProperties() 
{
	AfxMessageBox(_T("What Properties do you want to see?"), MB_ICONINFORMATION);
}

BOOL CTableView::OnScrollBy(CSize sizeScroll, BOOL bDoScroll) 
{
	TRACE(_T("CTableView::OnScrollBy - called: %d, %d, and %d\n"), sizeScroll.cx, sizeScroll.cy, bDoScroll);
	
	if (bDoScroll && m_editData.IsWindowVisible())
	{
		RECT rcEdit;
		m_editData.GetWindowRect(&rcEdit);
		rcEdit.left += sizeScroll.cx;
		rcEdit.top += sizeScroll.cy;
		rcEdit.right += sizeScroll.cx;
		rcEdit.bottom += sizeScroll.cy;
		m_editData.MoveWindow(&rcEdit, FALSE);
	}

	return COrcaListView::OnScrollBy(sizeScroll, bDoScroll);
}

void CTableView::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	TRACE(_T("CTableView::OnHScroll - called, nPos: %d\n"), nPos);

	if (m_editData.IsWindowVisible())
	{
		CommitEdit(TRUE);
	}

	COrcaListView::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CTableView::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	TRACE(_T("CTableView::OnVScroll - called, nPos: %d\n"), nPos);

	if (m_editData.IsWindowVisible())
	{
		CommitEdit(TRUE);
	}

	COrcaListView::OnVScroll(nSBCode, nPos, pScrollBar);
}

///////////////////////////////////////////////////////////
// OnEditCopy
void CTableView::OnEditCopy() 
{
	// if any binary data has been placed in temp file, we can remove it because
	// it is no longer on the clipboard after this
	CStringList *pList = &((static_cast<COrcaApp *>(AfxGetApp()))->m_lstClipCleanup);
	while (pList->GetCount())
		DeleteFile(pList->RemoveHead());

	// if the edit control is currently active, it should handle the
	// copy message, it will handle bad data quietly
	if (m_editData.IsWindowVisible()) {
		m_editData.Copy();
		return;
	}

	ASSERT(m_nSelCol >= 0);

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the row and data
	int iFocusedItem = GetFocusedItem();
	COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iFocusedItem);
	ASSERT(pRow);
	if (!pRow)
		return;

	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);
	if (!pData)
		return;

	const COrcaColumn* pColumn = m_pTable->GetColumn(m_nSelCol);
	ASSERT(pColumn);
	if (!pColumn)
		return;

	// allocate memory for the string on the clipboard (+ 3 for \r\n and null)
	DWORD cchString = (pData->GetString(pColumn->m_dwDisplayFlags).GetLength() + 3)*sizeof(TCHAR);
	HANDLE hString = ::GlobalAlloc(GHND|GMEM_DDESHARE, cchString);
	if (hString)
	{
		LPTSTR szString = (LPTSTR)::GlobalLock(hString);
		if (szString)
		{
			lstrcpy(szString, pData->GetString(pColumn->m_dwDisplayFlags));
			lstrcat(szString, _T("\r\n"));
			::GlobalUnlock(hString);

			OpenClipboard();	
			::EmptyClipboard();
#ifdef _UNICODE
			::SetClipboardData(CF_UNICODETEXT, hString);
#else
			::SetClipboardData(CF_TEXT, hString);
#endif
			::CloseClipboard();
		}
	}
}	// end of OnEditCopy

///////////////////////////////////////////////////////////
// OnEditCut
void CTableView::OnEditCut() 
{
	// if the edit control is currently active, it should handle the
	// cut message, it will handle bad data quietly
	if (m_editData.IsWindowVisible()) {
		m_editData.Cut();
		return;
	}

	if (GetDocument()->TargetIsReadOnly())
		return;

	ASSERT(m_nSelCol >= 0);

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the row and data
	int iFocusedItem = GetFocusedItem();
	COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iFocusedItem);
	ASSERT(pRow);
	if (!pRow)
		return;

	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);
	if (!pData)
		return;

	// if the row doesn't exist in the currently active database, you can't edit it
	if (!GetDocument()->IsRowInTargetDB(pRow))
		return;

	const COrcaColumn* pColumn = m_pTable->GetColumn(m_nSelCol);
	ASSERT(pColumn);
	if (!pColumn)
		return;

	// allocate memory for the string on the clipboard (+ 3 for \r\n and null)
	DWORD cchString = (pData->GetString(pColumn->m_dwDisplayFlags).GetLength() + 3)*sizeof(TCHAR);
	HANDLE hString = ::GlobalAlloc(GHND|GMEM_DDESHARE, cchString);
	if (hString)
	{
		LPTSTR szString = (LPTSTR)::GlobalLock(hString);
		if (szString)
		{
			lstrcpy(szString, pData->GetString(pColumn->m_dwDisplayFlags));
			lstrcat(szString, _T("\r\n"));
			::GlobalUnlock(hString);

			OpenClipboard();	
			::EmptyClipboard();
#ifdef _UNICODE
			::SetClipboardData(CF_UNICODETEXT, hString);
#else
			::SetClipboardData(CF_TEXT, hString);
#endif
			::CloseClipboard();
		
			// if the cell wasn't empty before it will be soon
			if (!pData->GetString().IsEmpty())
			{
				UINT iResult = m_pTable->ChangeData(pRow, m_nSelCol, _T(""));
	
				// if we succeeded in changing the document
				if (ERROR_SUCCESS == iResult)
				{
					// update the list control
					rctrlList.RedrawItems(iFocusedItem,iFocusedItem);
				}
			}
		}
	}
}	// end of OnEditCut

///////////////////////////////////////////////////////////
// OnEditPaste
void CTableView::OnEditPaste() 
{
	// if the edit control is currently active, it should handle the
	// paste message, it will handle bad data quietly
	if (m_editData.IsWindowVisible()) {
		m_editData.Paste();
		return;
	}

	ASSERT(m_nSelCol >= 0);

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the row and data
	int iFocusedItem = GetFocusedItem();
	COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iFocusedItem);
	ASSERT(pRow);
	if (!pRow)
		return;

	COrcaData* pData = pRow->GetData(m_nSelCol);
	ASSERT(pData);
	if (!pData)
		return;

	// copy the text out of the clipboard real fast
	CString strNewData;
	OpenClipboard();
#ifdef _UNICODE
	HANDLE hString = ::GetClipboardData(CF_UNICODETEXT);
#else
	HANDLE hString = ::GetClipboardData(CF_TEXT);
#endif
	::CloseClipboard();
	ASSERT(hString);
	strNewData = (LPTSTR)::GlobalLock(hString);
	::GlobalUnlock(hString);

	// if clipboard data ends in new line chop it off
	if (_T("\r\n") == strNewData.Right(2))
		strNewData = strNewData.Left(strNewData.GetLength() - 2);

	// if the pasted text isn't the same as the cell data
	if (strNewData != pData->GetString())
	{
		UINT iResult = m_pTable->ChangeData(pRow, m_nSelCol, strNewData);

		// if we succeeded in changing the document
		if (ERROR_SUCCESS == iResult)
		{
			// update the list control
			rctrlList.RedrawItems(iFocusedItem, iFocusedItem);
		}
		else	// tell the user that what they are doing is not valid
		{
			CString strPrompt;
			strPrompt.Format(_T("Could not paste `%s` into this cell."), strNewData);
			AfxMessageBox(strPrompt, MB_ICONINFORMATION);
		}
	}
}	// end of OnEditPaste


///////////////////////////////////////////////////////////
// OnUpdateEditCopy
void CTableView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	if (m_editData.IsWindowVisible()) {
		int nBeg, nEnd;
        m_editData.GetSel( nBeg, nEnd );         
		pCmdUI->Enable( nBeg != nEnd );
	} 
	else if (m_pTable && !m_pTable->IsShadow() && (m_nSelCol >= 0) && (GetFocusedItem() >= 0))
	{
		// enable only if the column is not binary
		const COrcaColumn* pCol = m_pTable->GetColumn(m_nSelCol);
		pCmdUI->Enable(iColumnBinary != pCol->m_eiType);
	}
	else	// nothing is selected
		pCmdUI->Enable(FALSE);
}	// end of OnUpdateEditCopy


///////////////////////////////////////////////////////////
// OnUpdateEditCut
void CTableView::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
	int iItem = 0;
	if (m_editData.IsWindowVisible()) {
		int nBeg, nEnd;
        m_editData.GetSel( nBeg, nEnd );         
		pCmdUI->Enable( nBeg != nEnd );
	} 
	else if (m_pTable && !m_pTable->IsShadow() && (m_nSelCol >= 0) && ((iItem = GetFocusedItem()) >= 0) )
	{
		// get list control
		CListCtrl& rctrlList = GetListCtrl();

		// disable if the currently selected row is not in the current database, otherwise
		// enable only if the column is nullable and not binary
		const COrcaColumn* pCol = m_pTable->GetColumn(m_nSelCol);
		COrcaRow *pRow = (COrcaRow *)rctrlList.GetItemData(iItem);
		ASSERT(pRow);

		pCmdUI->Enable(!pRow || (GetDocument()->IsRowInTargetDB(pRow) && pCol->m_bNullable && 
							iColumnBinary != pCol->m_eiType));
	}
	else	// nothing is selected
		pCmdUI->Enable(FALSE);
}	// end of OnUpdateEditCut

///////////////////////////////////////////////////////////
// OnUpdateEditPaste
void CTableView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
	if (GetDocument()->TargetIsReadOnly()) 
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	if (m_editData.IsWindowVisible()) {
#ifdef _UNICODE
		pCmdUI->Enable(::IsClipboardFormatAvailable(CF_UNICODETEXT));
#else
		pCmdUI->Enable(::IsClipboardFormatAvailable(CF_TEXT));
#endif
		return;
	} 
	else if (m_pTable && !m_pTable->IsShadow() && (m_nSelCol >= 0))
	{
		// for speed, check to see if column is pastable first (non-binary)
		const COrcaColumn* pCol = m_pTable->GetColumn(m_nSelCol);
		int iItem = 0;
		if ((iColumnBinary != pCol->m_eiType) && ((iItem = GetFocusedItem()) >= 0)) 
		{
			// get list control
			CListCtrl& rctrlList = GetListCtrl();

			// disable if the currently selected row is not in the current database, otherwise
			// enable only if there is text in the database
			COrcaRow *pRow = (COrcaRow *)rctrlList.GetItemData(iItem);
			ASSERT(pRow);

			if (!pRow || !GetDocument()->IsRowInTargetDB(pRow))
			{
				pCmdUI->Enable(FALSE);
			}
			else
			{
				OpenClipboard();
#ifdef _UNICODE
				HANDLE hAnyText = ::GetClipboardData(CF_UNICODETEXT);
#else
				HANDLE hAnyText = ::GetClipboardData(CF_TEXT);
#endif
				::CloseClipboard();
				pCmdUI->Enable(NULL != hAnyText);
			}
			return;
		}
	}
	pCmdUI->Enable(FALSE);

}	// end of OnUpdateEditPaste


///////////////////////////////////////////////////////////
// OnEditCopyRow
void CTableView::OnEditCopyRow() 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	ASSERT(rctrlList.GetSelectedCount() > 0);

	// if any binary data has been placed in temp file, we can remove it because
	// it is no longer on the clipboard after this
	CStringList *pList = &((static_cast<COrcaApp *>(AfxGetApp()))->m_lstClipCleanup);
	while (pList->GetCount())
		DeleteFile(pList->RemoveHead());

	CString strCopy;		// string to copy to clipboard
	int iItem;
	POSITION pos = GetFirstSelectedItemPosition();
	ASSERT(pos != NULL);
	
	// repeat for every selected row
	while (pos) 
	{
		iItem = GetNextSelectedItem(pos);

		// get the row and data
		COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
		ASSERT(pRow);
		if (!pRow)
			continue;

		if (!GetDocument()->IsRowInTargetDB(pRow))
			continue;

		const COrcaColumn* pColumn = NULL;
		COrcaData* pData = NULL;
		int cColumns = m_pTable->GetColumnCount();
		for (int i = 0; i < cColumns; i++)
		{
			pColumn = m_pTable->GetColumn(i);
			pData = pRow->GetData(i);
			ASSERT(pData);
			if (pData)
			{
				// if this is a binary column
				if (iColumnBinary == pColumn->m_eiType)
				{
					if (!pData->IsNull())
					{
						PMSIHANDLE hRow = pRow->GetRowRecord(GetDocument()->GetTargetDatabase());
						CString strTempFile;
						GetDocument()->WriteStreamToFile(hRow, i, strTempFile);
		
						// add the file to the current row, and the list of files to cleanup
						// at exit time
						(static_cast<COrcaApp *>(AfxGetApp()))->m_lstClipCleanup.AddTail(strTempFile);
						strCopy += strTempFile;
					}
				}
				else	// some other column, just add it to the list of columsn
				{
					strCopy += pData->GetString(pColumn->m_dwDisplayFlags);
				}
			}

			// if not last column
			if (i < (cColumns - 1))
				strCopy += _T('\t');
		}

		strCopy += _T("\r\n");	// tack on the last return character
	}

	// allocate memory for the string on the clipboard
	DWORD cchString = (strCopy.GetLength() + 1)*sizeof(TCHAR);
	HANDLE hString = ::GlobalAlloc(GHND|GMEM_DDESHARE, cchString);
	if (hString)
	{
		LPTSTR szString = (LPTSTR)::GlobalLock(hString);
		if (szString)
		{
			lstrcpy(szString, strCopy);
			::GlobalUnlock(hString);

			OpenClipboard();	
			::EmptyClipboard();
#ifdef _UNICODE
			::SetClipboardData(CF_UNICODETEXT, hString);
#else
			::SetClipboardData(CF_TEXT, hString);
#endif
			::CloseClipboard();
		}
	}
}	// end of OnEditCopyRow

///////////////////////////////////////////////////////////
// OnEditCutRow
void CTableView::OnEditCutRow() 
{
	ASSERT(!GetDocument()->TargetIsReadOnly());

	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	CString strPrompt;

	int iNumRows = rctrlList.GetSelectedCount();

	strPrompt.Format(_T("This will remove %d rows from this database and place them on the clipbard.\nDo you wish to continue?"),
		iNumRows);

	if (IDOK == AfxMessageBox(strPrompt, MB_OKCANCEL, 0)) {
		OnEditCopyRow();
		DropRows();
	};

}	// end of OnEditCutRow

///////////////////////////////////////////////////////////
// OnEditPasteRow
void CTableView::OnEditPasteRow() 
{
	ASSERT(!GetDocument()->TargetIsReadOnly());

	// get the clipboard junk
	OpenClipboard();
#ifdef _UNICODE
	HANDLE hString = ::GetClipboardData(CF_UNICODETEXT);
#else
	HANDLE hString = ::GetClipboardData(CF_TEXT);
#endif
	ASSERT(hString);
	CString strClipped = (LPTSTR)::GlobalLock(hString);
	::GlobalUnlock(hString);
	::CloseClipboard();

	int cColumns = m_pTable->GetColumnCount();

	// if the string isn't empty
	if (!strClipped.IsEmpty())
	{
		COrcaDoc* pDoc = GetDocument();
		UINT iResult;

		CStringList strListColumns;
		CString strParse;

		UnSelectAll();

		int nFind = strClipped.Find(_T("\r\n"));
		int nFind2;

		while (-1 != nFind)
		{
			// get the string to parse for tabs and move to tne next string after the return character
			strParse = strClipped.Left(nFind);
			strClipped = strClipped.Mid(nFind + 2);	// skip \r\n

			// empty out the list
			strListColumns.RemoveAll();

			nFind2 = strParse.Find(_T('\t'));
			while (-1 != nFind2)
			{
				// add the string to the list
				strListColumns.AddTail(strParse.Left(nFind2));

				// move the parse after the tab then find the next tab
				strParse = strParse.Mid(nFind2 + 1);
				nFind2 = strParse.Find(_T('\t'));
			}
			
			// add the last string to the list
			strListColumns.AddTail(strParse);

			// if we don't have the number of columns to fill a row bail
			if (strListColumns.GetCount() != cColumns)
				break;

			// try to add the row now
			if (ERROR_SUCCESS != (iResult = pDoc->AddRow(m_pTable, &strListColumns)))
			{
				iResult = ERROR_SUCCESS;// assume the error cna be fixed

				// do a loop through to make sure the rows match the column types
				const COrcaColumn* pColumn;
				POSITION pos = strListColumns.GetHeadPosition();
				for (int i = 0; i < cColumns; i++)
				{
					pColumn = m_pTable->GetColumn(i);
					strParse = strListColumns.GetNext(pos);

					// if the string is null and the column can't handle nulls
					// giveup
					if (strParse.IsEmpty())
						if (pColumn->m_bNullable)
							continue;
						else
						{
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
			
					// if this is a binary column
					if (iColumnBinary == pColumn->m_eiType)
					{
						if (!FileExists(strParse))
						{
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
					}
					else if (iColumnShort == pColumn->m_eiType ||
								iColumnLong == pColumn->m_eiType)
					{
						DWORD dwValue = 0;
						// if failed to convert
						if (!ValidateIntegerValue(strParse, dwValue))
						{
							iResult = ERROR_FUNCTION_FAILED;
							break;
						}
					}
					// else all strings should go through no problem (if they passed nullabe at the top
				}

				// if the row passed the above checks it should be fixable
				if (ERROR_SUCCESS == iResult)
				{
					pos = strListColumns.GetHeadPosition();
					CString strFirstKey = strListColumns.GetAt(pos);
					int cLoop = 0;
					do
					{
						// try changing the primary key and add again
						strParse.Format(_T("%s%d"), strFirstKey, cLoop++);
						strListColumns.SetAt(pos, strParse);

						iResult = m_pTable->AddRow(&strListColumns);
					} while (ERROR_SUCCESS != iResult);
				}
			}

			
			if (ERROR_SUCCESS != iResult)
			{
				CString strPrompt;
				strPrompt.Format(_T("Cannot to paste row(s) into table[%s]."), m_pTable->Name());
				AfxMessageBox(strPrompt);
			}

			nFind = strClipped.Find(_T("\r\n"));
		}
	}
}	// end of OnEditPasteRow

///////////////////////////////////////////////////////////
// OnUpdateEditCutCopyRow
void CTableView::OnUpdateEditCutRow(CCmdUI* pCmdUI) 
{
	if (GetDocument()->TargetIsReadOnly()) 
	{
		pCmdUI->Enable(FALSE);
		return;
	}
	
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	pCmdUI->Enable(m_pTable && !m_pTable->IsShadow() && (rctrlList.GetSelectedCount() > 0) && AnySelectedItemIsActive());
}	// end of OnUpdateEditCutCopyRow

///////////////////////////////////////////////////////////
// OnUpdateEditCutCopyRow
void CTableView::OnUpdateEditCopyRow(CCmdUI* pCmdUI) 
{
	CListCtrl& rctrlList = GetListCtrl();
	pCmdUI->Enable(m_pTable && !m_pTable->IsShadow() && (rctrlList.GetSelectedCount() > 0) && AnySelectedItemIsActive());
}	// end of OnUpdateEditCutCopyRow

///////////////////////////////////////////////////////////
// OnUpdateEditPasteRow
// only activate command if clipboard has stuff that can
// be parsed into valid row(s) for this table
void CTableView::OnUpdateEditPasteRow(CCmdUI* pCmdUI) 
{
	if (GetDocument()->TargetIsReadOnly()) 
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	if (m_pTable && !m_pTable->IsShadow())
	{
		// get the clipboard junk
		OpenClipboard();
#ifdef _UNICODE
		HANDLE hString = ::GetClipboardData(CF_UNICODETEXT);
#else
		HANDLE hString = ::GetClipboardData(CF_TEXT);
#endif
		::CloseClipboard();

		// if there's no text on the clipboard don't enable
		if (!hString)
			pCmdUI->Enable(FALSE);
		else	// check the text
		{
			// get the text
			CString strClipped = (LPTSTR)::GlobalLock(hString);
			::GlobalUnlock(hString);

			int cColumns = m_pTable->GetColumnCount();
			int cWords = 0;

			// if the string isn't empty
			if (!strClipped.IsEmpty())
			{
				cWords++; // there must be one word in there (it's not empty)
				int cString = strClipped.GetLength();
				for (int i = 0; i < cString; i++)
				{
					if (_T('\t') == strClipped.GetAt(i))
						cWords++;
					else if (_T('\n') == strClipped.GetAt(i))
						break;	// quit when hit a new line
				}
			}

			pCmdUI->Enable(cColumns == cWords);
		}
	}
	else	// nothing is selected
		pCmdUI->Enable(FALSE);
}	// end of OnUpdateEditPasteRow

void CTableView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView) 
{
	if (m_pTable)
	{
		// get list control
		CListCtrl& rctrlList = GetListCtrl();

		if (rctrlList.GetItemCount() > 0 && rctrlList.GetSelectedCount() == 0)
		{
			m_nSelCol = 0;
		}
	}

	COrcaListView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

void CTableView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// if the ctrl key was relese
	if (VK_CONTROL == nChar)
		m_bCtrlDown = FALSE;

	COrcaListView::OnKeyUp(nChar, nRepCnt, nFlags);
}

void CTableView::UnSelectAll()
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// clear any existing row selections
	POSITION pos = GetFirstSelectedItemPosition();
	if (pos != NULL)
	{   
		while (pos) 
		{
			int nItem = GetNextSelectedItem(pos);
			rctrlList.SetItemState(nItem, 0, LVIS_SELECTED); 
			rctrlList.RedrawItems(nItem, nItem);
		}
	}
	rctrlList.UpdateWindow();
}

void CTableView::OnUpdateRowDrop(CCmdUI* pCmdUI) 
{
	if (GetDocument()->TargetIsReadOnly()) 
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (!pFrame)
		pCmdUI->Enable(FALSE);
	else	// if there is an active row enable it
		pCmdUI->Enable(rctrlList.GetSelectedCount() && AnySelectedItemIsActive());
}

bool CTableView::AnySelectedItemIsActive() const
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	POSITION pos = GetFirstSelectedItemPosition();
	ASSERT(pos != NULL);
	COrcaDoc *pDoc = GetDocument();
	
	// repeat for every selected row
	while (pos) 
	{
		int iItem = GetNextSelectedItem(pos);

		// get the row and data
		COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
		ASSERT(pRow);
		if (!pRow)
			continue;

		if (pDoc->IsRowInTargetDB(pRow))
			return true;
	}
	return false;
}

OrcaTransformAction CTableView::GetColumnTransformState(int iColumn) const
{
	return m_pTable->GetColumn(iColumn)->IsTransformed();
}

OrcaTransformAction CTableView::GetCellTransformState(const void *row, int iColumn) const
{
	const COrcaData *pItemData = static_cast<const COrcaRow *>(row)->GetData(iColumn);
	if (!pItemData)
		return iTransformNone;
	return pItemData->IsTransformed();
}

OrcaTransformAction CTableView::GetItemTransformState(const void *row) const
{
	return static_cast<const COrcaRow *>(row)->IsTransformed();
}

COrcaListView::ErrorState CTableView::GetErrorState(const void *row, int iColumn) const
{
	const COrcaData *pItemData = static_cast<const COrcaRow *>(row)->GetData(iColumn);
	// if there is an error
	if (iDataError == pItemData->GetError())
		return Error;
	if (iDataWarning == pItemData->GetError())
		return Warning;
	return OK;
}

const CString* CTableView::GetOutputText(const void *rowdata, int iColumn) const
{
	const COrcaColumn *pColumn = m_pTable->GetColumn(iColumn);
	ASSERT(pColumn);
	return &(static_cast<const COrcaRow *>(rowdata)->GetData(iColumn)->GetString(pColumn->m_dwDisplayFlags));
}

void CTableView::UpdateColumn(int i)
{
	if (i < 0) return;

	// this is the select column so update the status bar
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	if (pFrame)
	{
		const COrcaColumn* pColumn = m_pTable->GetColumn(i);
		ASSERT(pColumn);
		if (!pColumn)
			return;

		pFrame->SetColumnType(pColumn->m_strName, pColumn->m_eiType, pColumn->m_iSize, pColumn->m_bNullable, pColumn->IsPrimaryKey());
	}
}

////////////////////////////////////////////////////////////////////////
// Searches using the FindInfo structure, beginning with one cell after
// (or before if backwards) the cell with the focus (if none focused, 
// search entire table)
bool CTableView::Find(OrcaFindInfo &FindInfo)
{
	// if there is no selected table, return false (not found)
	if (!m_pTable)
		return false;

	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	COrcaRow *pRow;

	// start searching one cell past the focus
	int iChangeVal = (FindInfo.bForward ? 1 : -1);
	int iCol = m_nSelCol + iChangeVal;
	int iRow = GetFocusedItem();
	if (iRow < 0) iRow = (FindInfo.bForward ? 0 : rctrlList.GetItemCount()-1);

	for ( ; (iRow >= 0) && (iRow < rctrlList.GetItemCount()); iRow += iChangeVal) 
	{
		pRow = (COrcaRow *)rctrlList.GetItemData(iRow);
		ASSERT(pRow);

		// if iCol == COLUMN_INVALID, search whole thing
		if (pRow->Find(FindInfo, iCol))
		{
			// pass NULL as window so that this view also gets the message
			GetDocument()->UpdateAllViews(NULL, HINT_SET_ROW_FOCUS, pRow);
			GetDocument()->UpdateAllViews(NULL, HINT_SET_COL_FOCUS, reinterpret_cast<CObject *>(static_cast<INT_PTR>(iCol)));
			return true;
		}
	}
	return false;
}

///////////////////////////////////////////////////////////////////////
// scrolls the control by enough to see the specified column.
// right now, scrolls just enough to be visible. Might want to consider
// scrolling full left and right if still valid 
void CTableView::EnsureVisibleCol(const int iCol)
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// find the horizontal position of the column
	int iScrollL = 0;
	int iScrollR = 0;
	for (int i=0; i < iCol; i++)
		iScrollL += rctrlList.GetColumnWidth(i);
	iScrollR = iScrollL + rctrlList.GetColumnWidth(iCol);

	// if its not visible, scroll horizontally so that it is visible
	CRect rWin;
	rctrlList.GetClientRect(&rWin);
	int iWinWidth = rWin.right-rWin.left;
	int iCurScrollPos = rctrlList.GetScrollPos(SB_HORZ);

	if ((iScrollL > iCurScrollPos) &&
		(iScrollR < (iCurScrollPos+iWinWidth))) 
		return;

	CSize size;
	size.cy = 0;
	size.cx = (iScrollR > (iCurScrollPos + iWinWidth)) ?
			iScrollR-iWinWidth : // off right
			iScrollL; // off left
	size.cx -= iCurScrollPos;
	rctrlList.Scroll(size);
}

void CTableView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	TRACE(_T("CTableView::OnChar - called\n"));

	// if the edit box is open it probably sent the message
	if (m_editData.IsWindowVisible())
	{
		if (VK_ESCAPE == nChar)
		{
			CommitEdit(FALSE);
			return;
		}
		else if (VK_RETURN == nChar)
		{
			CommitEdit(TRUE);
			return;
		}
	}
	else
	{
		// there is no cell edit conttrol active. A CR means activate
		// the cell edit. 
		if (VK_F2 == nChar || VK_RETURN == nChar)
		{
			if ((GetFocusedItem() >= 0) && (m_nSelCol >= 0))
			{
				EditCell();
				return;
			}
		} 
	}
	
	COrcaListView::OnChar(nChar, nRepCnt, nFlags);
}

afx_msg void CTableView::OnSize( UINT nType, int cx, int cy ) 
{
	if (::IsWindow(m_ctrlStatic.m_hWnd) && m_ctrlStatic.IsWindowVisible())
	{
		m_ctrlStatic.MoveWindow(0,0, cx, cy);
	}
}

afx_msg HBRUSH CTableView::OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	pDC->SetBkColor(m_clrNormal);
	pDC->SetTextColor(m_clrNormalT);
	return m_brshNormal;
}

void CTableView::SwitchFont(CString name, int size)
{
	COrcaListView::SwitchFont(name, size);
	m_ctrlStatic.SetFont(m_pfDisplayFont, TRUE);
}

///////////////////////////////////////////////////////////////////////
// Handles requests for tip text from the ToolTip control. Returns the 
// old untransformed value from cell under the mouse cursor.
BOOL CTableView::OnToolTipNotify( UINT id, NMHDR * pNMHDR, LRESULT * pResult )
{
	if (!m_pctrlToolTip)
		return FALSE;

	// because of the MFC message routing system, this window could get 
	// tooltip notifications from other controls. Only need to handle
	// requests from our manually managed tip.
	if (pNMHDR->hwndFrom == m_pctrlToolTip->m_hWnd)
	{
		CPoint CursorPos;
		VERIFY(::GetCursorPos(&CursorPos));
		ScreenToClient(&CursorPos);
	
		// Another safety check to ensure we don't incorrectly handle the wrong
		// notification messages. Verify that the cursor is inside the client
		// area of this window
		CRect ClientRect;
		GetClientRect(ClientRect);
	
		if (ClientRect.PtInRect(CursorPos))
		{
			// init the structure to empty strings
			TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *)pNMHDR;
			pTTT->hinst = 0;
			pTTT->lpszText = NULL;
			pTTT->szText[0] = '\0';
	
			int iItem = -1;
			int iColumn = -1;
			if (GetRowAndColumnFromCursorPos(CursorPos, iItem, iColumn))
			{
				CListCtrl& rctrlList = GetListCtrl();
				COrcaRow* pRow = (COrcaRow*)rctrlList.GetItemData(iItem);
				ASSERT(pRow);
				if (!pRow)
					return FALSE;

				COrcaData* pData = pRow->GetData(iColumn);
				ASSERT(pData);
				if (!pData)
					return FALSE;

				// only cells with a "transform change" operation have previous data.
				// adds don't have old data, and drops don't hide the old data.
				if (pData->IsTransformed() != iTransformChange)
					return FALSE;

				// update the data
				CString strData = _T("Old Value: ");
				strData += pRow->GetOriginalItemString(GetDocument(), iColumn); 
				pTTT->lpszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(strData));
			}

			return TRUE;
		}
	}
    return FALSE;
} 

///////////////////////////////////////////////////////////////////////
// since the tool tip is manually managed (not by the CWnd), it is 
// necessary to feed mouse events received by this window to the 
// control. The control will peek at the messages it is concerned about
// and ignore the rest.
BOOL CTableView::PreTranslateMessage(MSG* pMsg) 
{
   if (NULL != m_pctrlToolTip)            
      m_pctrlToolTip->RelayEvent(pMsg);
   
   return COrcaListView::PreTranslateMessage(pMsg);
}

///////////////////////////////////////////////////////////////////////
// given a cursor position, returns the item and column containing
// the position. Item is handled by the control, column is detected 
// manually from our stored column widths. Returns true if the hit
// is valid, false otherwise.
bool CTableView::GetRowAndColumnFromCursorPos(CPoint point, int &iItem, int &iCol)
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get if any item was hit
	UINT iState;
	iItem = rctrlList.HitTest(point, &iState);
	iCol = -1;

	// if missed an item
	if (iItem < 0 || !(iState & LVHT_ONITEM))
	{
		return false;
	}

	// shift by the scroll point
	int nScrollPos = GetScrollPos(SB_HORZ);
	point.x += nScrollPos;

	// get the column of the hit
	int nX = 0;
	int nWidth;
	for (int i = 0; i < m_cColumns; i++)
	{
		nWidth = rctrlList.GetColumnWidth(i);

		if (point.x >= nX && point.x < nX + nWidth)
		{
			// hit lies in this column
			iCol = i;
			break;
		}

		// move x over to the next column
		nX += nWidth;
	}

	// if the user clicked outside of the items
	if (iCol < 0)
	{
		return false;
	}
	return true;
}

///////////////////////////////////////////////////////////////////////
// because the tool tip views the list view as one tool, we need to
// check if a mouse move has changed the cursor from one cell to another. 
// If so, deactivate and re-activate the tooltip to force a string
// refresh. If transforms are not enabled, this is a no-op.
void CTableView::OnMouseMove(UINT nFlags, CPoint point) 
{
    if (m_pctrlToolTip && ::IsWindow(m_pctrlToolTip->m_hWnd))
    {
		// get the document
		COrcaDoc* pDoc = GetDocument();
		ASSERT(pDoc);

		if (pDoc && pDoc->DoesTransformGetEdit())
		{
			int iItem = 0;
			int iColumn = 0;
	
			// currently don't handle situation where right pane gets mouse messages but left pane has focus
			// (thus handles WM_NOTIFY messages from the tool tip.) Once that support is added, remove focus
			// check here.
			bool fItemHit = (this == GetFocus()) && GetRowAndColumnFromCursorPos(point, iItem, iColumn);
	
			// if different item, deactivate
			if (!fItemHit || iItem != m_iToolTipItem || iColumn != m_iToolTipColumn)
			{
				// Use Activate() to hide the tooltip.
				m_pctrlToolTip->Activate(FALSE);
			}
	
			if (fItemHit)
			{
				m_pctrlToolTip->Activate(TRUE);
				m_iToolTipItem = iItem;
				m_iToolTipColumn = iColumn;
			}
			else
			{
				m_iToolTipItem = -1;
				m_iToolTipColumn = -1;
			}
		}
    }
    COrcaListView::OnMouseMove(nFlags, point);
}

////
// change the view of the currently selected column to Hex. Resizes the
// column if needed, unless doing so would push the total width of the
// columns beyond the window width.
void CTableView::OnViewColumnHex()
{
	if (!m_pTable || m_nSelCol == -1)
		return;
	ChangeColumnView(m_nSelCol, true);
}

////
// swith the view of the currently selected column to decimal. Does not
// resize the columns.
void CTableView::OnViewColumnDecimal()
{
	if (!m_pTable || m_nSelCol == -1)
		return;
	ChangeColumnView(m_nSelCol, false);
}

////
// change the view of the whose header was right-clicked to Hex,
// even if that column is not selected. Resizes the
// column if needed, unless doing so would push the total width of the
// columns beyond the window width.
void CTableView::OnViewColumnHexHdr()
{
	if (!m_pTable || m_iHeaderClickColumn == -1)
		return;
	ChangeColumnView(m_iHeaderClickColumn, true);
}

////
// swith the view of the column whose header was right-clicked, even
// if that column is not selected. Does not resize the columns.
void CTableView::OnViewColumnDecimalHdr()
{
	if (!m_pTable || m_iHeaderClickColumn == -1)
		return;
	ChangeColumnView(m_iHeaderClickColumn, false);
}

////
// does the actual work of switching a column view from hex to decimal
// and back.
void CTableView::ChangeColumnView(int iColumn, bool fHex)
{
	ASSERT(m_pTable);
	if (!m_pTable || iColumn < 0 || iColumn >= m_pTable->GetColumnCount())
		return;
	const COrcaColumn* pColumn=m_pTable->GetColumn(iColumn);
	if (!pColumn)
		return;

	// verify integer column
	if (pColumn->m_eiType != iColumnShort && pColumn->m_eiType != iColumnLong)
		return;

	pColumn->SetDisplayInHex(fHex);
	
	if (fHex)
	{
		CListCtrl& rctrlList = GetListCtrl();
		
		// if all of the columns together add up to less than the window width,
		// expand the resized column to show all characters
		int iTotalWidth = 0;
		for (int iCol=0; iCol < m_pTable->GetColumnCount(); iCol++)
		{
			iTotalWidth += rctrlList.GetColumnWidth(iCol);
		}
	
		// grab the window dimensions to calculate maximum column widths
		CRect rClient;
		GetClientRect(&rClient);
		int iWindowWidth = rClient.right;
	
		// try to determine if a scroll bar is going to show up 
		if (m_pTable->GetRowCount()*m_iRowHeight > rClient.bottom)
		{
			iWindowWidth -= GetSystemMetrics(SM_CXVSCROLL);
		}
	
		// retreive the current and desired column widths for this column
		int iDesiredWidth = GetMaximumColumnWidth(iColumn);
		int iCurrentWidth = rctrlList.GetColumnWidth(iColumn);
	
		// check the system settings to see if we should force columns to fit in the view
		bool fForceColumns = AfxGetApp()->GetProfileInt(_T("Settings"), _T("ForceColumnsToFit"), 1) == 1;
	
		// only resize the column if it is not big enough. If it is too big, 
		// leave it alone.
		if (iDesiredWidth > iCurrentWidth)
		{
			// ensure that resizing this column won't push beyond the window boundary
			// unless we're already beyond the window boundary
			if ((iTotalWidth > iWindowWidth) || (iTotalWidth - iCurrentWidth + iDesiredWidth < iWindowWidth))
			{
				pColumn->m_nWidth = iDesiredWidth;
				rctrlList.SetColumnWidth(iColumn, iDesiredWidth);
			}
		}
	}

	// pass NULL as window so that this view also gets the message
	GetDocument()->UpdateAllViews(NULL, HINT_REDRAW_ALL, NULL);
}

///////////////////////////////////////////////////////////
// OnUpdateViewColumnFormat
void CTableView::OnUpdateViewColumnFormat(CCmdUI* pCmdUI) 
{
	if (m_nSelCol > 0 && m_pTable && m_nSelCol <= m_pTable->GetColumnCount()) 
	{
		const COrcaColumn* pColumn = m_pTable->GetColumn(m_nSelCol);
		if (pColumn && (pColumn->m_eiType == iColumnLong || pColumn->m_eiType == iColumnShort))
		{
			pCmdUI->Enable(TRUE);
			return;
		}
	}

	pCmdUI->Enable(FALSE);
}	// end of OnUpdateEditPaste

///////////////////////////////////////////////////////////
// notification messages from the list view and header control
BOOL CTableView::OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult )
{
	NMHEADER* pHDR = reinterpret_cast<NMHEADER*>(lParam);
	switch (pHDR->hdr.code)
	{
	case NM_RCLICK:
	{
		// get list control and header
		CListCtrl& rctrlList = GetListCtrl();
		HWND hHeader = ListView_GetHeader(rctrlList.m_hWnd);

		// win95 gold fails ListView_GetHeader.
		if (!hHeader || pHDR->hdr.hwndFrom != hHeader)
		{
			break;
		}

		// ensure there is a table
		if (!m_pTable)
			break;

		CHeaderCtrl* pCtrl = rctrlList.GetHeaderCtrl();
		if (!pCtrl)
			break;

		// get the position of the click
		DWORD dwPos = GetMessagePos();
		CPoint ptClick(LOWORD(dwPos), HIWORD(dwPos));
		CPoint ptScreen(ptClick);
		pCtrl->ScreenToClient(&ptClick);

		// determine which column was clicked by sending the header
		// control a hittest message
		HD_HITTESTINFO hdhti;
		hdhti.pt = ptClick;
		pCtrl->SendMessage(HDM_HITTEST, (WPARAM)0, (LPARAM)&hdhti);
		int iColumn = hdhti.iItem;

		// determine if the column is integer
		const COrcaColumn* pColumn = m_pTable->GetColumn(iColumn);
		if (!pColumn)
			break;
		if (pColumn->m_eiType != iColumnShort && pColumn->m_eiType != iColumnLong)
			break;

		// create a popup menu
		m_iHeaderClickColumn = iColumn;
		CMenu menuContext;
		menuContext.LoadMenu(IDR_HEADER_POPUP);
		menuContext.CheckMenuRadioItem(ID_VIEW_DECIMAL_HDR, ID_VIEW_HEX_HDR, pColumn->DisplayInHex() ? ID_VIEW_HEX_HDR : ID_VIEW_DECIMAL_HDR, MF_BYCOMMAND);
		menuContext.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());

		return 1;
	}
	default:
		break;
	}
	return COrcaListView::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\tablevw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// TableVw.h : interface of the CTableView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_TABLEVW_H__C3EDC1B0_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_TABLEVW_H__C3EDC1B0_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "CellEdit.h"
#include "OrcaLstV.h"

class CTableView : public COrcaListView
{
protected: // create from serialization only
	CTableView();
	DECLARE_DYNCREATE(CTableView)

// Attributes
public:
	COrcaTable* m_pTable;
	CCellEdit m_editData;
	CStatic m_ctrlStatic;

// Operations
public:
	void OnClose();

	friend int CALLBACK SortView(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTableView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	virtual BOOL PreTranslateMessage( MSG* pMsg );

	virtual BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );

	//}}AFX_VIRTUAL

// Implementation
public:
	bool Find(OrcaFindInfo &FindInfo);
	virtual void UpdateColumn(int i);
	virtual ~CTableView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void SwitchFont(CString name, int size);

protected:

	BOOL m_bCtrlDown;

	void EditCell(BOOL bSelectAll = TRUE);
	BOOL CommitEdit(BOOL bSave = TRUE);

// Generated message map functions
protected:
	//{{AFX_MSG(CTableView)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDropRowConfirm();
	afx_msg void OnErrors();
	afx_msg void OnProperties();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRowDrop(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditCopyRow();
	afx_msg void OnUpdateEditCopyRow(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCutRow(CCmdUI* pCmdUI);
	afx_msg void OnEditCutRow();
	afx_msg void OnUpdateEditPasteRow(CCmdUI* pCmdUI);
	afx_msg void OnEditPasteRow();
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSize( UINT nType, int cx, int cy );
	afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor); 
	afx_msg BOOL OnToolTipNotify( UINT id, NMHDR * pNMHDR, LRESULT * pResult );
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);

	afx_msg void OnViewColumnHex();
	afx_msg void OnViewColumnDecimal();
	afx_msg void OnViewColumnHexHdr();
	afx_msg void OnViewColumnDecimalHdr();
	afx_msg void OnUpdateViewColumnFormat(CCmdUI* pCmdUI);


	//}}AFX_MSG
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUpdateRowAdd(CCmdUI* pCmdUI);
	DECLARE_MESSAGE_MAP()
private:
	void ChangeColumnView(int iColumn, bool fHex);
	void EnsureVisibleCol(const int iCol);
	void UnSelectAll();
	void DropRows();

	virtual ErrorState GetErrorState(const void *row, int iColumn) const;
	virtual const CString *GetOutputText(const void *data, int iColumn) const;

	virtual OrcaTransformAction GetCellTransformState(const void *data, int iColumn) const;
	virtual OrcaTransformAction GetItemTransformState(const void *data) const;
	virtual OrcaTransformAction GetColumnTransformState(int iColumn) const;
	
	bool GetRowAndColumnFromCursorPos(CPoint point, int &iItem, int &iCol);
	bool AnySelectedItemIsActive() const;

	CToolTipCtrl* m_pctrlToolTip;
	int m_iToolTipItem;
	int m_iToolTipColumn;

	int m_iHeaderClickColumn;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABLEVW_H__C3EDC1B0_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\tablelst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_TABLELST_H__C3EDC1B8_E506_11D1_A856_006097ABDE17__INCLUDED_)
#define AFX_TABLELST_H__C3EDC1B8_E506_11D1_A856_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TableLst.h : header file
//

#include "OrcaLstV.h"

/////////////////////////////////////////////////////////////////////////////
// CTableList view

class CTableList : public COrcaListView
{
protected:
	CTableList();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CTableList)

// Attributes
public:
	int m_nPreviousItem;

// Operations
public:
	bool m_bDisableAutoSize;
	bool Find(OrcaFindInfo &FindInfo);
	void OnClose();

	friend int CALLBACK SortList(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTableList)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CTableList();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CTableList)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnAddTable();
	afx_msg void OnDropTable();
	afx_msg void OnProperties();
	afx_msg void OnErrors();
	afx_msg void OnContextTablesExport();
	afx_msg void OnContextTablesImport();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	virtual ErrorState GetErrorState(const void *data, int iColumn) const;
	virtual const CString *GetOutputText(const void *data, int iColumn) const;
	virtual OrcaTransformAction GetItemTransformState(const void *data) const;

	virtual bool ContainsValidationErrors(const void *data) const;
	virtual bool ContainsTransformedData(const void *data) const;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABLELST_H__C3EDC1B8_E506_11D1_A856_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\trnpropd.cpp ===
// TransformPropDlg.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "Trnpropd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTransformPropDlg dialog


CTransformPropDlg::CTransformPropDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTransformPropDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTransformPropDlg)
	m_bValAddExistingRow = FALSE;
	m_bValAddExistingTable = FALSE;
	m_bValChangeCodepage = FALSE;
	m_bValDelMissingRow = FALSE;
	m_bValDelMissingTable = FALSE;
	m_bValUpdateMissingRow = FALSE;
	m_bValLanguage = FALSE;
	m_bValProductCode = FALSE;
	m_bValUpgradeCode = FALSE;
	m_iVersionCheck = -1;
	m_bValGreaterVersion = FALSE;
	m_bValLowerVersion = FALSE;
	m_bValEqualVersion = FALSE;
	//}}AFX_DATA_INIT
}


void CTransformPropDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTransformPropDlg)
	DDX_Control(pDX, IDC_VALGREATER, m_btnValGreater);
	DDX_Control(pDX, IDC_VALLESS, m_btnValLess);
	DDX_Check(pDX, IDC_ADDEXISTINGROW, m_bValAddExistingRow);
	DDX_Check(pDX, IDC_ADDEXISTINGTABLE, m_bValAddExistingTable);
	DDX_Check(pDX, IDC_CHANGECODEPAGE, m_bValChangeCodepage);
	DDX_Check(pDX, IDC_DELMISSINGROW, m_bValDelMissingRow);
	DDX_Check(pDX, IDC_DELMISSINGTABLE, m_bValDelMissingTable);
	DDX_Check(pDX, IDC_UPDATEMISSINGROW, m_bValUpdateMissingRow);
	DDX_Check(pDX, IDC_VALLANGUAGE, m_bValLanguage);
	DDX_Check(pDX, IDC_VALPRODUCT, m_bValProductCode);
	DDX_Check(pDX, IDC_VALUPGRADE, m_bValUpgradeCode);
	DDX_Radio(pDX, IDC_VALMAJOR, m_iVersionCheck);
	DDX_Check(pDX, IDC_VALGREATER, m_bValGreaterVersion);
	DDX_Check(pDX, IDC_VALLESS, m_bValLowerVersion);
	DDX_Check(pDX, IDC_VALEQUAL, m_bValEqualVersion);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTransformPropDlg, CDialog)
	//{{AFX_MSG_MAP(CTransformPropDlg)
	ON_BN_CLICKED(IDC_VALGREATER, OnValGreater)
	ON_BN_CLICKED(IDC_VALLESS, OnValLess)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTransformPropDlg message handlers


void CTransformPropDlg::OnValGreater() 
{
	if (m_btnValGreater.GetCheck())
		m_btnValLess.SetCheck(FALSE);
	m_btnValLess.EnableWindow(!m_btnValGreater.GetCheck());
}

void CTransformPropDlg::OnValLess() 
{
	if (m_btnValLess.GetCheck())
		m_btnValGreater.SetCheck(FALSE);
	m_btnValGreater.EnableWindow(!m_btnValLess.GetCheck());
}

BOOL CTransformPropDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// set the enable/disable state of the greater/less controls
	OnValGreater();
	OnValLess();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\tablelst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// TableLst.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"
#include "OrcaDoc.h"
#include "MainFrm.h"

#include "TableLst.h"
#include "TblErrD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTableList

IMPLEMENT_DYNCREATE(CTableList, COrcaListView)

CTableList::CTableList()
{
	m_cColumns = 1;
	m_nPreviousItem = -1;
}

CTableList::~CTableList()
{
}


BEGIN_MESSAGE_MAP(CTableList, COrcaListView)
	//{{AFX_MSG_MAP(CTableList)
	ON_WM_SIZE()
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemchanged)
	ON_WM_RBUTTONDOWN()
	ON_COMMAND(IDM_ADD_TABLE, OnAddTable)
	ON_COMMAND(IDM_DROP_TABLE, OnDropTable)
	ON_COMMAND(IDM_PROPERTIES, OnProperties)
	ON_COMMAND(IDM_ERRORS, OnErrors)
	ON_COMMAND(IDM_EXPORT_TABLES, OnContextTablesExport)
	ON_COMMAND(IDM_IMPORT_TABLES, OnContextTablesImport)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTableList drawing

void CTableList::OnDraw(CDC* pDC)
{
}

/////////////////////////////////////////////////////////////////////////////
// CTableList diagnostics

#ifdef _DEBUG
void CTableList::AssertValid() const
{
	COrcaListView::AssertValid();
}

void CTableList::Dump(CDumpContext& dc) const
{
	COrcaListView::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTableList message handlers

void CTableList::OnInitialUpdate() 
{
	m_bDrawIcons = true;
	m_bDisableAutoSize = false;
	COrcaListView::OnInitialUpdate();
	
	CListCtrl& rctrlList = GetListCtrl();

	// empty any previous columns
	while (rctrlList.DeleteColumn(0))
		;

	// add the table list
	m_nSelCol = 0;
	RECT rcSize;
	GetWindowRect(&rcSize);
	rctrlList.InsertColumn(0, _T("Tables"), LVCFMT_LEFT, rcSize.right - rcSize.left + 1);

	CSplitterWnd *wndParent = static_cast<CSplitterWnd *>(GetParent());
	if (wndParent)
		wndParent->RecalcLayout();
}

void CTableList::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// if this is the sender bail
	if (this == pSender)
		return;

	CListCtrl& rctrlList = GetListCtrl();

	switch (lHint) {
	case HINT_REDRAW_ALL:	// simple redraw request
	{
		rctrlList.RedrawItems(0, rctrlList.GetItemCount());
		break;
	}
	case HINT_REDRAW_TABLE:
	{
		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);
		
		int iItem = rctrlList.FindItem(&findInfo);
		if (iItem < 0)
			break;
		rctrlList.RedrawItems(iItem, iItem);
		rctrlList.EnsureVisible(iItem, FALSE);
	}
	case HINT_ADD_ROW:
	case HINT_DROP_ROW:
		break; // do nothing
	case HINT_ADD_TABLE_QUIET:
	case HINT_ADD_TABLE:
	{
		ASSERT(pHint);

		COrcaTable* pTableHint = (COrcaTable*)pHint;		
		COrcaTable* pTable;

		// see if this table is in the list control already
		int iFound = -1;	// assume not going to find it
		int cItems = rctrlList.GetItemCount();
		for (int i = 0; i < cItems; i++)
		{
			pTable = (COrcaTable*)rctrlList.GetItemData(i);

			if (pTable == pTableHint)
			{
				iFound = i;
				break;
			}
		}

		// if it was not found add it and select it
		if (iFound < 0)
		{
			rctrlList.InsertItem(LVIF_PARAM | LVIF_STATE, 
									  rctrlList.GetItemCount(),
									  NULL,
									  (lHint == HINT_ADD_TABLE_QUIET) ? 0 : LVIS_SELECTED|LVIS_FOCUSED, 
									  0, 0,
									  (LPARAM)pTableHint);

			// sort the items now to put this new table in the right place
			rctrlList.SortItems(SortList, (LPARAM)this);
		}
		else if (lHint != HINT_ADD_TABLE_QUIET)
		{
			// item is already in the list so select

			// if there was a previously selected item
			if (m_nPreviousItem >= 0)
				pTable = (COrcaTable*)rctrlList.GetItemData(m_nPreviousItem);
			else	// nothing was selected
				pTable = NULL;

			// if this is a newly selected item
			if (pTableHint != pTable)
			{
				rctrlList.SetItemState(iFound, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
			}

			// update status bar
			((CMainFrame*)AfxGetMainWnd())->SetTableCount(cItems+1);
		}
		break;
	}
	case HINT_DROP_TABLE:
	{
		ASSERT(pHint);

		COrcaTable* pTableHint = (COrcaTable*)pHint;		
		COrcaTable* pTable;

		// see if this table is in the list control already
		int iFound = -1;	// assume not going to find it
		int cItems = rctrlList.GetItemCount();
		for (int i = 0; i < cItems; i++)
		{
			pTable = (COrcaTable*)rctrlList.GetItemData(i);

			if (pTable == pTableHint)
			{
				iFound = i;
				break;
			}
		}
		ASSERT(iFound > -1);	// make sure something was found

		rctrlList.DeleteItem(iFound);

		// if there are items set the selected item
		if (rctrlList.GetItemCount() > 0)
		{
			if (rctrlList.GetItemCount() != (m_nPreviousItem + 1))
				m_nPreviousItem--;
			rctrlList.SetItemState(m_nPreviousItem, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
		}

		// update status bar
		((CMainFrame*)AfxGetMainWnd())->SetTableCount(cItems-1);
		
		break;
	}
	case HINT_TABLE_REDEFINE:
	{
		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);

		// this didn't come from us, so we have to set the selection state manually
		int iItem = rctrlList.FindItem(&findInfo);
		ASSERT(iItem >= 0);
		rctrlList.RedrawItems(iItem, iItem);
		rctrlList.EnsureVisible(iItem, FALSE);
		break;
	}
	case HINT_CHANGE_TABLE:
	{
		// if an item is currently selected
		if (m_nPreviousItem >= 0)
		{
			// and we're switching to the same item, just ensure that it is visible
			if (reinterpret_cast<COrcaTable*>(rctrlList.GetItemData(m_nPreviousItem)) == static_cast<COrcaTable*>(pHint))
			{
				rctrlList.EnsureVisible(m_nPreviousItem, FALSE);
				break;
			}
		}

		LVFINDINFO findInfo;
		findInfo.flags = LVFI_PARAM;
		findInfo.lParam = reinterpret_cast<INT_PTR>(pHint);

		// this didn't come from us, so we have to set the selection state manually
		int iItem = rctrlList.FindItem(&findInfo);
		if (iItem < 0) break;
		rctrlList.SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		rctrlList.EnsureVisible(iItem, FALSE);
		break;
	}
	case HINT_TABLE_DROP_ALL:
	{
		// empty out the list control
		rctrlList.DeleteAllItems();
		break;
	}
	case HINT_RELOAD_ALL:
	{
		// empty out the list control
		rctrlList.DeleteAllItems();

		// if there is no table open in the document
		COrcaDoc* pDoc = GetDocument();
		if (iDocNone == pDoc->m_eiType)
		{
			break;
		}

		// refill from document
		int cTables = 0;
		RECT rClient;
		RECT rWindow;
		
		COrcaTable* pTable;
		POSITION pos = pDoc->m_tableList.GetHeadPosition();
		while (pos)
		{
			pTable = pDoc->m_tableList.GetNext(pos);

			rctrlList.InsertItem(LVIF_PARAM, 
									  rctrlList.GetItemCount(),
									  NULL,
									  0, 0, 0,
									  (LPARAM)pTable);
			cTables++;
		}

		int iMinWidth = 0;
		int iDummy = 0;
		CSplitterWnd *wndParent = (CSplitterWnd *)GetParent();

		// set the width to the maximum string width
		// set the minimum (arbitrarily) to 10.
		TRACE(_T("AutoSizing Table list - called.\n"));

		// Set this to true to not automatically size the control when the window is
		// resized. Otherwise, when we set the column width, any ColumnWidth messages floating
		// around in the queue will muck with things before we have a chance to fix the size
		// (at least I think thats what was happening).
		m_bDisableAutoSize = true;
		int cColumnWidth = 0;
		if (cTables)
		{
			cColumnWidth = GetMaximumColumnWidth(0);
		}
		else
		{
			rctrlList.SetColumnWidth(0, LVSCW_AUTOSIZE_USEHEADER);
			cColumnWidth = rctrlList.GetColumnWidth(0);
		}
		rctrlList.SetColumnWidth(0, cColumnWidth);
		wndParent->SetColumnInfo(0, cColumnWidth + GetSystemMetrics(SM_CXVSCROLL), 10);

		// make the changes
		m_bDisableAutoSize = false;

		wndParent->RecalcLayout();

		((CMainFrame*)AfxGetMainWnd())->SetTableCount(cTables);

		// sort
		rctrlList.SortItems(SortList, (LPARAM)this);

		m_nPreviousItem = -1;
		break;
	}
	default:
		break;
	}
}

// the cx value coming in is the client size.
void CTableList::OnSize(UINT nType, int cx, int cy) 
{
	TRACE(_T("CTableList::OnSize - called.\n"));

	// minimum width is 1. Status bar controls don't like 0 width panes
	if (cx < 1) cx = 1;

	CRect rWindow;
	int iScrollWidth;

	// adjust the status bar. Because cx is client, we have to get the 
	// NC area in order to set the status bar correctly.
	GetWindowRect(&rWindow);
	iScrollWidth = (rWindow.right-rWindow.left);
	CMainFrame* pFrame = ((CMainFrame*)AfxGetMainWnd());
	if (pFrame)
		pFrame->SetStatusBarWidth(iScrollWidth);

	// unless told not to (see reload hint for discussion) adujust 
	// the list control.
	if (!m_bDisableAutoSize) GetListCtrl().SetColumnWidth(0, cx);
	COrcaListView::OnSize(nType, cx, cy);
}



///////////////////////////////////////////////////////////
// SortList
int CALLBACK SortList(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	COrcaTable* pTable1 = (COrcaTable*)lParam1;
	COrcaTable* pTable2 = (COrcaTable*)lParam2;
	
	return pTable1->Name().Compare(pTable2->Name());
}	// end of SortList

void CTableList::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	if (pNMListView->iItem != m_nPreviousItem)
	{
		CWaitCursor cursorWait;	// switch to an hour glass real quick
		// need to manually set selection state 
//		rctrlList.SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		rctrlList.RedrawItems(pNMListView->iItem, pNMListView->iItem);
		rctrlList.UpdateWindow();

		// get the document
		COrcaDoc* pDoc = GetDocument();
		pDoc->UpdateAllViews(this, HINT_CHANGE_TABLE, (COrcaTable*)pNMListView->lParam);

		m_nPreviousItem = pNMListView->iItem;
	}

	*pResult = 0;
}

void CTableList::OnRButtonDown(UINT nFlags, CPoint point) 
{
	// get list control
	CListCtrl& rctrlList = GetListCtrl();
	
	// if there are no items in this list
	if (rctrlList.GetItemCount() < 1)
		return;	// bail

	// get if any item was hit
	UINT iState;
	int iItem = rctrlList.HitTest(point, &iState);
	int iCol = -1;

	// if missed an item
	if (iItem < 0 || !(iState & LVHT_ONITEM))
	{
		COrcaListView::OnRButtonDown(nFlags, point);
	}
	else	// something was hit with the mouse button
	{
		// select the item
		rctrlList.SetItemState(iItem, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
	}
	ClientToScreen(&point);

	// create and track the pop up menu
	CMenu menuContext;
	menuContext.LoadMenu(IDR_LIST_POPUP);
	menuContext.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, point.x, point.y, AfxGetMainWnd());
}

void CTableList::OnAddTable() 
{
	GetDocument()->OnTableAdd();
}

void CTableList::OnDropTable() 
{
	GetDocument()->OnTableDrop();
}

void CTableList::OnContextTablesExport() 
{
	((CMainFrame *)AfxGetMainWnd())->ExportTables(true);
}

void CTableList::OnContextTablesImport() 
{
	GetDocument()->OnTablesImport();
}

void CTableList::OnProperties() 
{
	AfxMessageBox(_T("What Properties do you want to see?"), MB_ICONINFORMATION);
}

void CTableList::OnErrors() 
{
	CListCtrl& rctrlList = GetListCtrl();
	COrcaTable* pTable = ((CMainFrame*)AfxGetMainWnd())->GetCurrentTable();

	CTableErrorD dlg;
	dlg.m_strTable = pTable->Name();
	dlg.m_strErrors.Format(_T("%d"), pTable->GetErrorCount());
	dlg.m_strWarnings.Format(_T("%d",), pTable->GetWarningCount());

	const CStringList *pErrorList = pTable->ErrorList();
	POSITION pos = pErrorList->GetHeadPosition();
	if (pos)
	{
		TableErrorS* pError;
		while (pos)
		{
			pError  = new TableErrorS;
			dlg.m_errorsList.AddTail(pError);

			pError->strICE = pErrorList->GetNext(pos);
			pError->strDescription = pErrorList->GetNext(pos);
			pError->strURL = pErrorList->GetNext(pos);
			pError->iError = iTableError;
		}
	}

	dlg.DoModal();
}

COrcaListView::ErrorState CTableList::GetErrorState(const void *data, int iColumn) const
{
	ASSERT(data);
	if (iTableError == ((const COrcaTable *)data)->Error()) 
		return ((const COrcaTable *)data)->IsShadow() ? ShadowError : Error;
	return OK;
}

OrcaTransformAction CTableList::GetItemTransformState(const void *data) const
{
	ASSERT(data);
	return ((const COrcaTable *)data)->IsTransformed();
}

const CString* CTableList::GetOutputText(const void *rowdata, int iColumn) const
{
	ASSERT(rowdata);
	return &((const COrcaTable *)rowdata)->Name();
}

bool CTableList::ContainsTransformedData(const void *data) const
{
	ASSERT(data);
	return ((const COrcaTable *)data)->ContainsTransformedData();
}

bool CTableList::ContainsValidationErrors(const void *data) const
{
	ASSERT(data);
	return ((const COrcaTable *)data)->ContainsValidationErrors();
}

bool CTableList::Find(OrcaFindInfo &FindInfo)
{
	int iItem;
	int iChangeVal = FindInfo.bForward ? 1 : -1;

	CListCtrl& rctrlList = GetListCtrl();

	POSITION pos = GetFirstSelectedItemPosition();

	int iMaxItems = rctrlList.GetItemCount();
	// if nothing is selected or we are set to wholedoc, start at the very beginning
	if (FindInfo.bWholeDoc || (pos == NULL)) {
		iItem = FindInfo.bForward ? 0 : iMaxItems-1;
		// and if we start at 0, we ARE searching the whole document
		FindInfo.bWholeDoc = true;
	}
	else
	{   
		iItem = GetNextSelectedItem(pos)+iChangeVal;
	}
	
	for ( ; (iItem >= 0) && (iItem < iMaxItems); iItem += iChangeVal) {
		COrcaTable *pTable = (COrcaTable *)rctrlList.GetItemData(iItem);
		COrcaRow *pRow = NULL;
		int iCol = 0;
	
		// retrieve the table if necessary
		pTable->RetrieveTableData();

		if (pTable->Find(FindInfo, pRow, iCol)) 
		{
			// pass Null as sender so we get the message tooe
			GetDocument()->UpdateAllViews(NULL, HINT_CHANGE_TABLE, pTable);
			GetDocument()->UpdateAllViews(this, HINT_SET_ROW_FOCUS, pRow);
			GetDocument()->UpdateAllViews(this, HINT_SET_COL_FOCUS, reinterpret_cast<CObject*>(static_cast<INT_PTR>(iCol)));
			return true;
		}
	}
	return false;
}

BOOL CTableList::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
	cs.style |= LVS_SINGLESEL | LVS_SORTASCENDING;
	
	return COrcaListView::PreCreateWindow(cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\table.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// Table.h
//

#ifndef _ORCA_TABLE_H_
#define _ORCA_TABLE_H_

#include "msiquery.h"
#include "Column.h"
#include "Row.h"

enum OrcaTableError
{
	iTableNoError,
	iTableError,
	iTableWarning
};

enum odlOrcaDataLocation
{
	odlInvalid,
	odlShadow,
	odlSplitOriginal,
	odlSplitTransformed,
	odlNotSplit,
};

class COrcaDoc;

class COrcaTable : public CObject
{

public:
	COrcaTable(COrcaDoc* pDoc);
	~COrcaTable();

	// LoadTableSchema loads the schema from the database
	void LoadTableSchema(MSIHANDLE hDatabase, CString szTable);

	// RetrieveTable loads data from both databases
	void RetrieveTableData();

	// IsSchemaDifferent returns true if the schema of the database doesn't match the memory schema
	bool IsSchemaDifferent(MSIHANDLE hDatabase, bool fStrict, bool &fExact);

	// checks current memory object against database and marks extra columns as "added"
	void MarkAddedColumnsBasedOnDB(MSIHANDLE hDatabase);

	// object can come from one database or both
	inline bool IsSplitSource() const { return (m_eiTableLocation == odlSplitOriginal || m_eiTableLocation == odlSplitTransformed); };
	inline void SetSplitSource(odlOrcaDataLocation location)  { m_eiTableLocation = location; };
	inline odlOrcaDataLocation GetSplitSource() const { return m_eiTableLocation;};
	
	void EmptyTable();
	UINT DropTable(MSIHANDLE hDatabase);
	void DestroyTable();
	void Transform(const OrcaTransformAction iAction);

	bool Find(OrcaFindInfo &FindInfo, COrcaRow *&pRow, int &iCol) const;

	COrcaData* GetData(UINT nRow, UINT nCol);
	COrcaData* GetData(CString strCol, CStringArray& rstrRows, const COrcaRow** pRow=NULL) const;
//	COrcaRow* FindRow(CStringList& rstrRows);
	
//	UINT CreateTable(MSIHANDLE hDatabase);

	UINT GetKeyCount() const;
	int GetErrorCount();
	int GetWarningCount();
	void ClearErrors();
	void Release();

	// modification functions
	UINT ChangeData(COrcaRow *pRow, UINT iCol, CString strData);
	UINT AddRow(CStringList* pstrDataList);
	UINT AddRow(COrcaRow *pRow);

	// transform information
	inline const OrcaTransformAction IsTransformed() const { return m_iTransform; };
	inline bool ContainsTransformedData() const { return m_iTransformedDataCount != 0; };
	void IncrementTransformedData();
	void DecrementTransformedData();

	// shadow table information
	void ShadowTable(CString szTable);
	inline bool IsShadow() const { return m_fShadow; };

	inline const CStringList* ErrorList() const { return &m_strErrorList; };
	inline const CString& Name() const { return m_strName; };
	inline CTypedPtrArray<CObArray, COrcaColumn*>* ColArray() { return &m_colArray; };
	inline CTypedPtrList<CObList, COrcaRow*>* RowList() { return &m_rowList; };
	bool   DropRow(COrcaRow *pRow, bool fPerformDrop);

	// column information
	inline int GetColumnCount() const { return static_cast<int>(m_colArray.GetSize()); };
	inline int GetOriginalColumnCount() const { return m_cOriginalColumns; };
	inline const COrcaColumn *GetColumn(const int iColumn) const { return m_colArray.GetAt(iColumn); };
	int FindColumnNumberByName(const CString& strColumn) const;
	COrcaRow* FindRowByKeys(CStringArray& rstrKeys) const;

	void FillColumnArray(CTypedPtrArray<CObArray, COrcaColumn*>* prgColumn, bool fIncludeAdded) const;

	// row information
	inline INT_PTR GetRowCount() const { return m_rowList.GetCount(); };
	inline POSITION GetRowHeadPosition() const { return m_rowList.GetHeadPosition(); };
	inline const COrcaRow *GetNextRow(POSITION &pos) const { return m_rowList.GetNext(pos); };
	const CString GetRowWhereClause() const;

	// error information
	inline void SetContainsValidationErrors(bool bError) { m_bContainsValidationErrors = bError; };
	inline bool ContainsValidationErrors() const { return m_bContainsValidationErrors; };
	inline const OrcaTableError Error() const { return m_eiError; };
	inline void SetError(const OrcaTableError iError) { m_eiError = iError; };
	inline void AddError(const CString& strICE, const CString& strDescription, const CString&strURL)
	{
		m_strErrorList.AddTail(strICE);
		m_strErrorList.AddTail(strDescription);
		m_strErrorList.AddTail(strURL);
	}

private:
	COrcaDoc* m_pDoc;
	CString m_strName;
	BOOL m_bRetrieved;		// flag if have retrieved rows from database yet
	bool m_fShadow;

	int m_cOriginalColumns;
	CTypedPtrArray<CObArray, COrcaColumn*> m_colArray;
	CTypedPtrList<CObList, COrcaRow*> m_rowList;

	bool m_bContainsValidationErrors;
	int m_iTransformedDataCount;

	OrcaTableError m_eiError;
	CStringList m_strErrorList;
	OrcaTransformAction m_iTransform;
	odlOrcaDataLocation m_eiTableLocation;
	
	// store a SQL query WHERE clause against the primary keys for perf
	CString m_strWhereClause;
	void BuildRowWhereClause();

	bool DropRowObject(COrcaRow *pRow, bool fPerformDrop);
	bool AddRowObject(COrcaRow *pRow, bool fUIUpdate, bool fCleanAdd, MSIHANDLE hNewRowRec);
	COrcaRow* FindDuplicateRow(COrcaRow* pBaseRow) const;

};	// end of CTable

#endif	// _ORCA_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\tblerrd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

#if !defined(AFX_TBLERRD_H__25468EE3_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
#define AFX_TBLERRD_H__25468EE3_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TblErrD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTableErrorD dialog

#include "Table.h"

struct TableErrorS
{
	CString strICE;
	CString strDescription;
	CString strURL;
	OrcaTableError iError;
};

class CTableErrorD : public CDialog
{
// Construction
public:
	CTableErrorD(CWnd* pParent = NULL);   // standard constructor
	void DrawItem(LPDRAWITEMSTRUCT);

	CTypedPtrList<CPtrList, TableErrorS*> m_errorsList;

// Dialog Data
	//{{AFX_DATA(CTableErrorD)
	enum { IDD = IDD_TABLE_ERROR };
	CString	m_strErrors;
	CString	m_strWarnings;
	CString	m_strTable;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTableErrorD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTableErrorD)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnClickTableList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool m_bHelpEnabled;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TBLERRD_H__25468EE3_FC84_11D1_AD45_00A0C9AF11A6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\trnpropd.h ===
#if !defined(AFX_TRANSFORMPROPDLG_H__E703BE7D_6CF3_45E4_A27F_4CC0E1890631__INCLUDED_)
#define AFX_TRANSFORMPROPDLG_H__E703BE7D_6CF3_45E4_A27F_4CC0E1890631__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TransformPropDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTransformPropDlg dialog

class CTransformPropDlg : public CDialog
{
// Construction
public:
	CTransformPropDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTransformPropDlg)
	enum { IDD = IDD_TRANSFORM_PROPERTIES };
	CButton	m_btnValGreater;
	CButton	m_btnValLess;
	BOOL	m_bValAddExistingRow;
	BOOL	m_bValAddExistingTable;
	BOOL	m_bValChangeCodepage;
	BOOL	m_bValDelMissingRow;
	BOOL	m_bValDelMissingTable;
	BOOL	m_bValUpdateMissingRow;
	BOOL	m_bValLanguage;
	BOOL	m_bValProductCode;
	BOOL	m_bValUpgradeCode;
	int		m_iVersionCheck;
	BOOL	m_bValGreaterVersion;
	BOOL	m_bValLowerVersion;
	BOOL	m_bValEqualVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTransformPropDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTransformPropDlg)
	afx_msg void OnValGreater();
	afx_msg void OnValLess();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRANSFORMPROPDLG_H__E703BE7D_6CF3_45E4_A27F_4CC0E1890631__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\valpp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// ValPage.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "ValPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CValPropPage property page

IMPLEMENT_DYNCREATE(CValPropPage, CPropertyPage)

CValPropPage::CValPropPage() : CPropertyPage(CValPropPage::IDD)
{
	//{{AFX_DATA_INIT(CValPropPage)
	m_strICEs = _T("");
	m_bSuppressInfo = FALSE;
	m_bSuppressWarn = FALSE;
	m_bClearResults = FALSE;
	//}}AFX_DATA_INIT
	m_bValChange = false;
}

CValPropPage::~CValPropPage()
{
}

extern bool InitCUBCombo(CComboBox *pBox, CString strDefault);
extern bool FreeCUBCombo(CComboBox *pBox);

void CValPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CValPropPage)
	DDX_Text(pDX, IDC_RUNICE, m_strICEs);
	DDX_Check(pDX, IDC_SUPPRESSINFO, m_bSuppressInfo);
	DDX_Check(pDX, IDC_SUPPRESSWARNING, m_bSuppressWarn);
	DDX_Control(pDX, IDC_VALDIR, m_ctrlCUBFile);
	DDX_Check(pDX, IDC_CLEARRESULTS, m_bClearResults);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CValPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CValPropPage)
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_RUNICE, OnChange)
	ON_BN_CLICKED(IDC_SUPPRESSINFO, OnChange)
	ON_BN_CLICKED(IDC_SUPPRESSWARNING, OnChange)
	ON_CBN_SELCHANGE(IDC_VALDIR, OnChange)
	ON_CBN_EDITCHANGE(IDC_VALDIR, OnChange)
	ON_BN_CLICKED(IDC_WARNSUMM, OnChange)
	ON_BN_CLICKED(IDC_CLEARRESULTS, OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValPropPage message handlers

void CValPropPage::OnChange() 
{
	m_bValChange = true;
}

BOOL CValPropPage::OnInitDialog() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_VALDIR);
	InitCUBCombo(pBox, m_strCUBFile);
	return TRUE;  
}

BOOL CValPropPage::OnKillActive() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_VALDIR);
	int iIndex = pBox->GetCurSel();
	if (CB_ERR == iIndex)
	{
		// no qualified component was chosen, explicit path
		pBox->GetWindowText(m_strCUBFile);
	}
	else
	{
		// qualified component was chosen. Get the qualifier
		DWORD cchCUBFile = MAX_PATH;
		TCHAR *szQualifier = static_cast<TCHAR*>(pBox->GetItemDataPtr(iIndex));
		m_strCUBFile = TEXT(":");
		m_strCUBFile += szQualifier;
	}
	return CPropertyPage::OnKillActive();
}

void CValPropPage::OnDestroy() 
{
	FreeCUBCombo(&m_ctrlCUBFile);
	CWnd::OnDestroy();
}


IMPLEMENT_DYNCREATE(CMsmPropPage, CPropertyPage)

CMsmPropPage::CMsmPropPage() : CPropertyPage(CMsmPropPage::IDD)
{
	//{{AFX_DATA_INIT(CMsmPropPage)
	m_iMemoryCount = 3;
	m_bWatchLog = FALSE;
	m_bAlwaysConfig = FALSE;
	//}}AFX_DATA_INIT
	m_bMSMChange = false;
}

CMsmPropPage::~CMsmPropPage()
{
}

void CMsmPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMsmPropPage)
	DDX_Text(pDX, IDC_MEMORY, m_iMemoryCount);
	DDX_Check(pDX, IDC_WATCHLOG, m_bWatchLog);
	DDX_Check(pDX, IDC_ALWAYSCONFIG, m_bAlwaysConfig);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMsmPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMsmPropPage)
	ON_EN_CHANGE(IDC_MEMORY, OnChange)
	ON_BN_CLICKED(IDC_WATCHLOG, OnChange)
	ON_BN_CLICKED(IDC_ALWAYSCONFIG, OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMsmPropPage::OnChange() 
{
	m_bMSMChange = true;
}


BOOL CMsmPropPage::OnInitDialog() 
{
	// can't watch the merge log on Win9X due to lack of pipe support.
	OSVERSIONINFOA osviVersion;
	osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	::GetVersionExA(&osviVersion); // fails only if size set wrong
	if (osviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
	{
		CButton* pCheck = (CButton*)GetDlgItem(IDC_WATCHLOG);
		if (pCheck)
			pCheck->EnableWindow(FALSE);
	}
	UpdateData(FALSE);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\vald.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_VALD_H__EEDCAAA4_F4EC_11D1_A85A_006097ABDE17__INCLUDED_)
#define AFX_VALD_H__EEDCAAA4_F4EC_11D1_A85A_006097ABDE17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ValD.h : header file
//

#include "iface.h"
#include "msiquery.h"
#include <afxmt.h>

/////////////////////////////////////////////////////////////////////////////
// CValD dialog

class CValD : public CDialog
{
// Construction
public:
	CMutex m_mtxDisplay;
	CValD(CWnd* pParent = NULL);   // standard constructor
	~CValD();

// Dialog Data
	//{{AFX_DATA(CValD)
	enum { IDD = IDD_VALIDATION };
	CComboBox	m_ctrlCUBFile;
	CListCtrl	m_ctrlOutput;
	CButton     m_ctrlGo;
	CString	m_strEvaluation;
	CString	m_strICE;
	BOOL	m_bShowInfo;
	//}}AFX_DATA

	MSIHANDLE m_hDatabase;
	IEnumEvalResult* m_pIResults;
	ULONG m_cResults;
	bool m_bShowWarn;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CValD)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	friend BOOL WINAPI DisplayFunction(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation);
// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CValD)
	virtual BOOL OnInitDialog();
	afx_msg void OnGo();
	afx_msg void OnColumnclickOutput(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnShowInfo();
	afx_msg void OnClipboard();
	afx_msg void OnDestroy();
    afx_msg void OnCUBEditChange( );
    afx_msg void OnCUBSelChange( );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	int m_iSortColumn;
	static int CALLBACK SortOutput(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VALD_H__EEDCAAA4_F4EC_11D1_A85A_006097ABDE17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\vald.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//--------------------------------------------------------------------------

// ValD.cpp : implementation file
//

#include "stdafx.h"
#include "Orca.h"

#include <initguid.h>
#include "ValD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CValD dialog

bool InitCUBCombo(CComboBox* pBox, CString strDefault);
bool FreeCUBCombo(CComboBox* pBox);

CValD::CValD(CWnd* pParent /*=NULL*/)
	: CDialog(CValD::IDD, pParent)
{
	//{{AFX_DATA_INIT(CValD)
	m_strICE = "";
	m_bShowInfo = FALSE;
	//}}AFX_DATA_INIT

	m_pIResults = NULL;
	m_cResults = 0;
}

CValD::~CValD()
{
	// if there were any results retrieved release them
	if (m_pIResults)
		m_pIResults->Release();
}

void CValD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CValD)
	DDX_Control(pDX, IDC_EVALUATION_FILE, m_ctrlCUBFile);
	DDX_Control(pDX, IDC_OUTPUT, m_ctrlOutput);
	DDX_Control(pDX, IDC_GO, m_ctrlGo);
	DDX_Text(pDX, IDC_ICES, m_strICE);
	DDX_Check(pDX, IDC_SHOW_INFO, m_bShowInfo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CValD, CDialog)
	//{{AFX_MSG_MAP(CValD)
	ON_BN_CLICKED(IDC_GO, OnGo)
	ON_WM_DESTROY()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_OUTPUT, OnColumnclickOutput)
	ON_BN_CLICKED(IDC_SHOW_INFO, OnShowInfo)
	ON_BN_CLICKED(IDC_CLIPBOARD, OnClipboard)
	ON_CBN_EDITCHANGE(IDC_EVALUATION_FILE, OnCUBEditChange)
	ON_CBN_SELCHANGE(IDC_EVALUATION_FILE, OnCUBSelChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValD message handlers

#ifdef _WIN64
static const TCHAR CUB_QUALIFIED_GUID[] = TEXT("{17C2BAD5-F32B-4A0D-B5E1-813FF88DA1C5}");
#else
static const TCHAR CUB_QUALIFIED_GUID[] = TEXT("{DC441E1D-3ECB-4DCF-B0A5-791F9C0F4F5B}");
#endif

BOOL CValD::OnInitDialog() 
{
	CDialog::OnInitDialog();

	CSingleLock lkUILock(&m_mtxDisplay);
	lkUILock.Lock();

	CListCtrl* pList = (CListCtrl*)GetDlgItem(IDC_OUTPUT);
	pList->SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);

	// add the table list
	RECT rcSize;
	pList->GetWindowRect(&rcSize);
	pList->InsertColumn(0, _T("ICE"), LVCFMT_LEFT, 50);
	pList->InsertColumn(1, _T("Type"), LVCFMT_LEFT, 50);
	pList->InsertColumn(2, _T("Description"), LVCFMT_LEFT, rcSize.right - 100 - rcSize.left - 4);
	m_bShowWarn = ::AfxGetApp()->GetProfileInt(_T("Validation"), _T("SuppressWarn"), 0) != 1;

	// init the CUB file combo box
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_EVALUATION_FILE);

	InitCUBCombo(pBox, m_strEvaluation);
	UpdateData(FALSE);
	m_iSortColumn = 99999;
	if (m_ctrlCUBFile.GetCount() == 0)
	{
		CString strText;
		m_ctrlCUBFile.GetWindowText(strText);
		if (strText.IsEmpty())
			m_ctrlGo.EnableWindow(FALSE);
	}
	SetDefID(IDC_GO);	// set the default button to the GO button in the beginning

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CValD::OnGo() 
{
	HRESULT hResult;

	// clear results
	if (AfxGetApp()->GetProfileInt(_T("Validation"),_T("ClearResults"), 1))
	{
		CSingleLock lkUILock(&m_mtxDisplay);
		lkUILock.Lock();
		m_ctrlOutput.DeleteAllItems();
	}

	// get the path to the cub file. If a qualified component was used, call Darwin to get the path
	// otherwise, the path is explicitly provided
	CString strCUBFile;
	int iIndex = m_ctrlCUBFile.GetCurSel();
	if (CB_ERR == iIndex)
	{
		// no qualified component was chosen, explicit path
		m_ctrlCUBFile.GetWindowText(strCUBFile);
		m_strEvaluation = strCUBFile;
	}
	else
	{
		// qualified component was chosen. Get the component path (try to repair if necessary).
		DWORD cchCUBFile = MAX_PATH;
		TCHAR *szCUBFile = strCUBFile.GetBuffer(cchCUBFile);
		TCHAR *szQualifier = static_cast<TCHAR*>(m_ctrlCUBFile.GetItemDataPtr(iIndex));
		UINT iStat = MsiProvideQualifiedComponent(CUB_QUALIFIED_GUID, szQualifier, INSTALLMODE_DEFAULT,
			szCUBFile, &cchCUBFile);
		strCUBFile.ReleaseBuffer();
		if (ERROR_SUCCESS != iStat)
		{
			// could not find or install the CUB File
			AfxMessageBox(_T("Error: The Validation Suite you selected could not be found, and Orca could not repair the problem."), MB_ICONSTOP);
			return;
		}
		m_strEvaluation = TEXT(":");
		m_strEvaluation += szQualifier;
	}
	
	// create an EvalCom object
	IEval* pIEval;
	hResult = ::CoCreateInstance(CLSID_EvalCom, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
											  IID_IEval, (void**)&pIEval);

	// if failed to create the object
	if (FAILED(hResult))
	{
		GetDlgItem(IDC_GO)->EnableWindow(FALSE);
		AfxMessageBox(_T("Error: Failed to instantiate EvalCom Object.\n\n"), MB_ICONSTOP);
		return;	// bail
	}
	else	// rock and roll
	{
		// disable controls
		GetDlgItem(IDC_GO)->EnableWindow(FALSE);
		GetDlgItem(IDC_CLIPBOARD)->EnableWindow(FALSE);
		GetDlgItem(IDOK)->EnableWindow(FALSE);
		CMenu *pSysMenu = GetSystemMenu(FALSE);
		pSysMenu->EnableMenuItem(SC_CLOSE, MF_GRAYED | MF_BYCOMMAND);

		CWaitCursor cursorWait;

		// open the database
		WCHAR szwBuffer[16];
		swprintf(szwBuffer, L"#%d", m_hDatabase);
		hResult = pIEval->OpenDatabase(szwBuffer);
		if (FAILED(hResult))
		{
			AfxMessageBox(_T("Error: Failed to open database.\n\n"), MB_ICONSTOP);
		}
		else
		{
			UpdateData(TRUE);	// update the evaluation file

			WCHAR szwEvaluations[1024];
#ifndef UNICODE
			DWORD cchBuffer;
			cchBuffer = ::MultiByteToWideChar(CP_ACP, 0, strCUBFile, -1, NULL, 0);
			::MultiByteToWideChar(CP_ACP, 0, strCUBFile, -1, szwEvaluations, cchBuffer);
#else
			wcscpy(szwEvaluations, strCUBFile);
#endif

			// open the evaluations
			hResult = pIEval->OpenEvaluations(szwEvaluations);
			if (FAILED(hResult))
			{
				AfxMessageBox(_T("Error: Failed to open evaluation file.\n\n"), MB_ICONSTOP);
			}
			else
			{
				pIEval->SetDisplay(DisplayFunction, this);
				WCHAR szwICEs[1024];
				
#ifndef UNICODE
				cchBuffer = ::MultiByteToWideChar(CP_ACP, 0, m_strICE, -1, NULL, 0);
				::MultiByteToWideChar(CP_ACP, 0, m_strICE, -1, szwICEs, cchBuffer);
#else
				wcscpy(szwICEs, m_strICE);
#endif
				
				hResult = pIEval->Evaluate((*szwICEs == L'\0') ? NULL : szwICEs);
				if(FAILED(hResult))
					AfxMessageBox(_T("Failed to run all of the evaluations.\r\n"), MB_ICONINFORMATION);

				pIEval->CloseEvaluations();
			}
		}			

		// get any results
		pIEval->GetResults(&m_pIResults, &m_cResults);

		// release the object
		pIEval->Release();

		// re-enable buttons/menu
		pSysMenu->EnableMenuItem(SC_CLOSE, MF_ENABLED | MF_BYCOMMAND);
		GetDlgItem(IDC_GO)->EnableWindow(TRUE);
		GetDlgItem(IDOK)->EnableWindow(TRUE);
		GetDlgItem(IDC_CLIPBOARD)->EnableWindow(m_ctrlOutput.GetItemCount() > 0);
	}

	m_iSortColumn = 99999;

	GotoDlgCtrl(GetDlgItem(IDOK));
	SetDefID(IDOK);	// set the default button to OK now
	AfxMessageBox(_T("Validations complete."));
}

///////////////////////////////////////////////////////////
// DisplayFunction
// pre:	called from Evaluation COM Object
// pos:	displays output from COM Object
BOOL WINAPI DisplayFunction(LPVOID pContext, UINT uiType, LPCWSTR szwVal, LPCWSTR szwDescription, LPCWSTR szwLocation)
{
	// try to change the context into a validation dialog box
	CValD* pDlg = (CValD*)pContext;

	if (ieInfo == uiType && !pDlg->m_bShowInfo)
		 return TRUE;
	if (ieWarning == uiType && !pDlg->m_bShowWarn)
		 return TRUE;
	
	// set the type correctly
	LPTSTR szType;
	switch (uiType)
	{
	case ieError:
		szType = _T("ERROR");
		break;
	case ieWarning:
		szType = _T("WARNING");
		break;
	case ieInfo:
		szType = _T("INFO");
		break;
	case ieUnknown:
		szType = _T("FAIL");
		break;
	default:
		szType = _T("UNKNOWN");
		break;
	}

	CString strICE;
#ifndef _UNICODE
	int cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, szwVal, -1, NULL, 0, NULL, NULL);
	::WideCharToMultiByte(CP_ACP, 0, szwVal, -1, strICE.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
	strICE.ReleaseBuffer();
#else
	strICE = szwVal;
#endif

	CString strDescription;
#ifndef _UNICODE
	cchBuffer = ::WideCharToMultiByte(CP_ACP, 0, szwDescription, -1, NULL, 0, NULL, NULL);
	::WideCharToMultiByte(CP_ACP, 0, szwDescription, -1, strDescription.GetBuffer(cchBuffer), cchBuffer, NULL, NULL);
	strDescription.ReleaseBuffer();
#else
	strDescription = szwDescription;
#endif

	TRACE(_T("%s\t%s\t%s\n"), strICE, szType, strDescription);
	
	// add line to list control
	int nAddedAt;

	CSingleLock lkUILock(&(pDlg->m_mtxDisplay));
	lkUILock.Lock();

	nAddedAt = pDlg->m_ctrlOutput.InsertItem(LVIF_TEXT, pDlg->m_ctrlOutput.GetItemCount(),
										  strICE, 0, 0, 0, NULL);
	pDlg->m_ctrlOutput.SetItem(nAddedAt, 1, LVIF_TEXT, szType, 0, 0, 0, 0);
	pDlg->m_ctrlOutput.SetItem(nAddedAt, 2, LVIF_TEXT, strDescription, 0, 0, 0, 0);
	pDlg->m_ctrlOutput.SetItemData(nAddedAt, nAddedAt);
	lkUILock.Unlock();

	return FALSE;
}

void CValD::OnColumnclickOutput(NMHDR* pNMHDR, LRESULT* pResult) 
{
	CWaitCursor curWait;

	CSingleLock lkUILock(&m_mtxDisplay);
	lkUILock.Lock();

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	// set the lparam values of each item to the item number
	int iMaxItem = m_ctrlOutput.GetItemCount();
	for (int i=0; i < iMaxItem; i++) 
		m_ctrlOutput.SetItemData(i, i);

	// column numbers are offset by 1 (so that column 0 can be 
	// sorted in either order.)
	int iNewSortColumn = pNMListView->iSubItem+1;
	if (iNewSortColumn == m_iSortColumn) 
		m_iSortColumn = -m_iSortColumn;
	else
		m_iSortColumn = iNewSortColumn;

	// now sort since the column bit is set
	m_ctrlOutput.SortItems(CValD::SortOutput, reinterpret_cast<ULONG_PTR>(this));
	*pResult = 0;
	lkUILock.Unlock();
}

//////////////////////////////////////////////////////////
// SortView
int CALLBACK CValD::SortOutput(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	CValD *pThis = reinterpret_cast<CValD *>(lParamSort);

	// get the data
	int iCol = pThis->m_iSortColumn < 0 ? -pThis->m_iSortColumn : pThis->m_iSortColumn;

	CString str1 = pThis->m_ctrlOutput.GetItemText(static_cast<int>(lParam1), iCol-1);
	CString str2 = pThis->m_ctrlOutput.GetItemText(static_cast<int>(lParam2), iCol-1);

	return (pThis->m_iSortColumn > 0) ? str1.Compare(str2) : -str1.Compare(str2);
}	// end of SortView

void CValD::OnShowInfo() 
{
	// TODO: Add your control notification handler code here
	m_bShowInfo = (static_cast<CButton *>(GetDlgItem(IDC_SHOW_INFO))->GetCheck() == 1);
}

void CValD::OnClipboard() 
{
	CWaitCursor curWait;

	CSingleLock lkUILock(&m_mtxDisplay);
	lkUILock.Lock();
	CString strItem;

	// loop over all items in the listview control
	int cItems = m_ctrlOutput.GetItemCount();
	for (int i=0; i < cItems; i++) 
	{
		strItem += m_ctrlOutput.GetItemText(i, 0);
		strItem += _T("\t");
		strItem += m_ctrlOutput.GetItemText(i, 1);
		strItem += _T("\t");
		strItem += m_ctrlOutput.GetItemText(i, 2);
		strItem += _T("\r\n");
	}
	lkUILock.Unlock();

	if (0 != OpenClipboard())
	{
		::EmptyClipboard();
		
		// allocate memory for the string on the clipboard (+ 1 for null)
		DWORD cchString = (strItem.GetLength()+1)*sizeof(TCHAR);
		HANDLE hString = ::GlobalAlloc(GHND|GMEM_DDESHARE, cchString);

		LPTSTR szString = (LPTSTR)::GlobalLock(hString);
		_tcscpy(szString, strItem);
		::GlobalUnlock(hString);

		// open and clear clipboard
#ifdef _UNICODE
		::SetClipboardData(CF_UNICODETEXT, hString);
#else
		::SetClipboardData(CF_TEXT, hString);
#endif

		// release held objects
		CloseClipboard();
	}
}


void CValD::OnDestroy() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_EVALUATION_FILE);
	FreeCUBCombo(pBox);
	CDialog::OnDestroy();
}
 

////
// disable the "go" button any time the CUB file edit box becomes empty. Enable it if the
// edit box is not empty or an item is selected
void CValD::OnCUBEditChange( )
{
	CString strCUBFile;
	m_ctrlCUBFile.GetWindowText(strCUBFile);
	m_ctrlGo.EnableWindow(!strCUBFile.IsEmpty());
}

void CValD::OnCUBSelChange( )
{
	m_ctrlGo.EnableWindow(TRUE);
}

bool InitCUBCombo(CComboBox* pBox, CString strDefault)
{
	bool fSuccess = true;
	bool fDefaultQualifier = (strDefault[0] == TEXT(':'));
	if (fDefaultQualifier)
		strDefault = strDefault.Right(strDefault.GetLength()-1);
	else
		pBox->SetWindowText(strDefault);
			
	int iCompNum = 0;
	for (iCompNum = 0; true ; iCompNum++)
	{
		DWORD cchQualifier = 72;
		DWORD cchText = 128;
		TCHAR *szQualifier = new TCHAR[cchQualifier];
		CString strText;
		TCHAR *szText = strText.GetBuffer(cchText);
		
		UINT iStat = MsiEnumComponentQualifiers(CUB_QUALIFIED_GUID, iCompNum, szQualifier, &cchQualifier, szText, &cchText);

		if (ERROR_NO_MORE_ITEMS == iStat)
		{
			delete[] szQualifier;
			break;
		}
		
		if (ERROR_MORE_DATA == iStat)
		{
			delete[] szQualifier;
			szQualifier = new TCHAR[++cchQualifier];
			strText.ReleaseBuffer();
			szText = strText.GetBuffer(++cchText);
			iStat = MsiEnumComponentQualifiers(CUB_QUALIFIED_GUID, iCompNum, 
				szQualifier, &cchQualifier, szText, &cchText);
		}		
		strText.ReleaseBuffer();

		if (ERROR_SUCCESS == iStat)
		{			
			int iIndex = pBox->AddString(strText);
			if (CB_ERR != iIndex)
			{
				pBox->SetItemDataPtr(iIndex, szQualifier);
				if (fDefaultQualifier && 0==_tcscmp(strDefault, szQualifier))
				{
					pBox->SetCurSel(iIndex);
				}
			}
		}
		// API not guaranteed to return ERROR_NO_MORE_ITEMS in all cases
		// can continue with ERROR_BAD_CONFIGURATION
		else if (ERROR_BAD_CONFIGURATION != iStat)
			break; // break on all other errors (UNKNOWN_COMPONENT, INVALID_PARAMETER, etc.)
	}

	if (strDefault.IsEmpty() && pBox->GetCount() > 0)
		pBox->SetCurSel(0);

	return fSuccess;
}

bool FreeCUBCombo(CComboBox* pBox)
{
	for (int i=0; i < pBox->GetCount(); i++)
	{
		void *szTemp = pBox->GetItemDataPtr(i);
		if (szTemp)
			delete[] szTemp;
		pBox->SetItemDataPtr(i, NULL);
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\valpane.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

// PagePaths.cpp : implementation file
//

#include "stdafx.h"
#include "orca.h"
#include "Valpane.h"
#include "orcadoc.h"
#include "mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CValidationPane property page

IMPLEMENT_DYNCREATE(CValidationPane, CListView)

CValidationPane::CValidationPane() : CListView()
{
	m_pfDisplayFont = NULL;
	m_nSelRow = -1;
	m_fSendNotifications = false;
}

CValidationPane::~CValidationPane()
{
}

BEGIN_MESSAGE_MAP(CValidationPane, CListView)
	//{{AFX_MSG_MAP(CValidationPane)
	ON_WM_CREATE()
	ON_WM_CHAR()
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemChanged)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValidationPane message handlers
int CValidationPane::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CListView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	CString strFacename = ::AfxGetApp()->GetProfileString(_T("Font"), _T("Name"));
	int iFontSize = ::AfxGetApp()->GetProfileInt(_T("Font"),_T("Size"), 0);
	if (strFacename.IsEmpty() || iFontSize == 0) 
	{
		m_pfDisplayFont = NULL;
	} 
	else
	{
		m_pfDisplayFont = new CFont();
		m_pfDisplayFont->CreatePointFont( iFontSize, strFacename);
	}
	return 0;
}


BOOL CValidationPane::PreCreateWindow(CREATESTRUCT& cs) 
{												   
	cs.style = (cs.style | LVS_REPORT | LVS_SHOWSELALWAYS | LVS_SINGLESEL) & ~LVS_ICON;
	return CListView::PreCreateWindow(cs);
}


void CValidationPane::SwitchFont(CString name, int size)
{
	if (m_pfDisplayFont)
		delete m_pfDisplayFont;
	m_pfDisplayFont = new CFont();
	int iLogicalUnits = MulDiv(size, GetDC()->GetDeviceCaps(LOGPIXELSY), 720);
	m_pfDisplayFont->CreateFont(
		-iLogicalUnits,       // logical height of font 
 		0,                  // logical average character width 
 		0,                  // angle of escapement 
 		0,                  // base-line orientation angle 
 		FW_NORMAL,          // FW_DONTCARE??, font weight 
 		0,                  // italic attribute flag 
 		0,                  // underline attribute flag 
	 	0,                  // strikeout attribute flag 
 		0,                  // character set identifier
 		OUT_DEFAULT_PRECIS, // output precision
 		0x40,               // clipping precision (force Font Association off)
 		DEFAULT_QUALITY,    // output quality
 		DEFAULT_PITCH,      // pitch and family
		name);              // pointer to typeface name string

	RedrawWindow();

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	rctrlList.SetFont(m_pfDisplayFont, TRUE);
	HWND hHeader = ListView_GetHeader(rctrlList.m_hWnd);

	// win95 gold fails ListView_GetHeader.
	if (hHeader)
	{
		::PostMessage(hHeader, WM_SETFONT, (UINT_PTR)HFONT(*m_pfDisplayFont), 1);
	}
};



///////////////////////////////////////////////////////////
// OnUpdate
void CValidationPane::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// if this is the sender window, nothing to do
	if (this == pSender)
		return;

	CListCtrl& rctrlList = GetListCtrl();
	switch (lHint) {
	case HINT_DROP_TABLE:
	{
		COrcaTable* pTable = static_cast<COrcaTable*>(pHint);

		// turn off notifications, as deletions may change the selected item and
		// the table may already be gone
		m_fSendNotifications = false;

		for (int iItem=0; iItem < rctrlList.GetItemCount(); )
		{
			CValidationError* pError = reinterpret_cast<CValidationError*>(rctrlList.GetItemData(iItem));
			if (pError && pError->m_pTable == pTable)
			{
				// delete the item, do NOT increment iItem because we just shifted the next item
				// into this slot.
				rctrlList.DeleteItem(iItem);
			}
			else
				iItem++;
		}

		// re-enable item selections
		m_fSendNotifications = true;

		break;
	}
	case HINT_DROP_ROW:
	{
		// pHint may be freed memory already. DO NOT dereference it within
		// this block!
		COrcaRow* pRow = static_cast<COrcaRow*>(pHint);

		// turn off notifications, as deletions may change the selected item and
		// the table may already be gone
		m_fSendNotifications = false;

		for (int iItem=0; iItem < rctrlList.GetItemCount(); )
		{
			CValidationError* pError = reinterpret_cast<CValidationError*>(rctrlList.GetItemData(iItem));
			if (pError && pError->m_pRow == pRow)
			{
				// delete the item, do NOT increment iItem because we just shifted the next item
				// into this slot.
				rctrlList.DeleteItem(iItem);
			}
			else
				iItem++;
		}

		// re-enable item selections
		m_fSendNotifications = true;

		break;
	}
	case HINT_CLEAR_VALIDATION_ERRORS:
	{
		ClearAllValidationErrors();
		break;
	}
	case HINT_ADD_VALIDATION_ERROR:
	{
		CValidationError* pError = static_cast<CValidationError*>(pHint);
		if (pError && pError->m_pstrICE)
		{
			CValidationError* pNewError = new CValidationError(NULL, pError->m_eiType, NULL, pError->m_pTable, pError->m_pRow, pError->m_iColumn);
			int iItem = rctrlList.InsertItem(LVIF_TEXT | LVIF_PARAM, rctrlList.GetItemCount(), static_cast<LPCTSTR>(*pError->m_pstrICE), 0, 0, 0, reinterpret_cast<LPARAM>(pNewError));

			switch (pError->m_eiType)
			{
			case ieError:
				rctrlList.SetItemText(iItem, 1, TEXT("Error"));
				break;
			case ieWarning:
				rctrlList.SetItemText(iItem, 1, TEXT("Warning"));
				break;
			case ieInfo:
				// should never happen.
				rctrlList.SetItemText(iItem, 1, TEXT("Info"));
				break;
			default:
				rctrlList.SetItemText(iItem, 1, TEXT("ICE Failure"));
				break;
			}
			rctrlList.SetItemText(iItem, 2, static_cast<LPCTSTR>(*pError->m_pstrDescription));
		}
		// size only on first error
		if (rctrlList.GetItemCount() == 1)
		{
			rctrlList.SetColumnWidth(0, LVSCW_AUTOSIZE);
			rctrlList.SetColumnWidth(1, LVSCW_AUTOSIZE);
			rctrlList.SetColumnWidth(2, LVSCW_AUTOSIZE_USEHEADER);
		}

		break;
	}
	default:
		break;
	}
}	// end of OnUpdate


void CValidationPane::GetFontInfo(LOGFONT *data)
{
	ASSERT(data);
	if (m_pfDisplayFont)
		m_pfDisplayFont->GetLogFont(data);
	else
		GetListCtrl().GetFont()->GetLogFont(data);
}


///////////////////////////////////////////////////////////////////////
// initial update sets the list view styles and prepares the columns
// for the control
void CValidationPane::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	CListCtrl& rctrlErrorList = GetListCtrl();

   	// empty any previous columns
	while (rctrlErrorList.DeleteColumn(0))
		;

	// add gridlines and full row select
	rctrlErrorList.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_GRIDLINES);
	rctrlErrorList.InsertColumn(0, TEXT("ICE"), LVCFMT_LEFT, -1, 0);
	rctrlErrorList.InsertColumn(1, TEXT("Type"), LVCFMT_LEFT, -1, 1);
	rctrlErrorList.InsertColumn(2, TEXT("Description"), LVCFMT_LEFT, -1, 2);
	rctrlErrorList.SetFont(m_pfDisplayFont);
	rctrlErrorList.SetColumnWidth(0, LVSCW_AUTOSIZE_USEHEADER);
	rctrlErrorList.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
	rctrlErrorList.SetColumnWidth(2, LVSCW_AUTOSIZE_USEHEADER);
	m_fSendNotifications = true;
	m_nSelRow = -1;
}

///////////////////////////////////////////////////////////////////////
// on destruction, be sure to release any validation error structures 
// managed by the list control
void CValidationPane::OnDestroy( )
{
	ClearAllValidationErrors();
	m_fSendNotifications = false;
}

///////////////////////////////////////////////////////////////////////
// on destruction, be sure to release any validation error structures 
// managed by the list control
void CValidationPane::ClearAllValidationErrors()
{
	// turn off notifications so that deleting the items won't cause the other window
	// to jump all over the place as the items are deleted.
	m_fSendNotifications = false;

	CListCtrl& rctrlErrorList = GetListCtrl();

   	// empty out any items, deleting validation target information as we go 
	while (rctrlErrorList.GetItemCount())
	{
		CValidationError* pError = reinterpret_cast<CValidationError*>(rctrlErrorList.GetItemData(0));
		if (pError)
			delete pError;
		rctrlErrorList.DeleteItem(0);
	}

	// reactivate notifications
	m_fSendNotifications = true;
}


///////////////////////////////////////////////////////////////////////
// send the hints to the rest of the windows to switch to the table
// and row indicated by the error.
bool CValidationPane::SwitchViewToRowTarget(int iItem) 
{
	if (iItem == -1)
		return true;

	if (!m_fSendNotifications)
		return true;

	CWaitCursor cursorWait;

	// get list control
	CListCtrl& rctrlList = GetListCtrl();

	// get the document
	CDocument* pDoc = GetDocument();
	CValidationError* pError = reinterpret_cast<CValidationError*>(rctrlList.GetItemData(iItem)); 
	
	// set the focus as specifically as we can
	if (pError->m_pTable)
	{
		pDoc->UpdateAllViews(this, HINT_CHANGE_TABLE, const_cast<COrcaTable*>(pError->m_pTable));
		if (pError->m_pRow)
		{
			pDoc->UpdateAllViews(this, HINT_SET_ROW_FOCUS, const_cast<COrcaRow*>(pError->m_pRow));
			if (pError->m_iColumn >= 0)
				pDoc->UpdateAllViews(this, HINT_SET_COL_FOCUS, reinterpret_cast<CObject*>(static_cast<INT_PTR>(pError->m_iColumn)));
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////////
// when the selected item changes, force the table list and view to 
// switch to that exact location
void CValidationPane::OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	if (pNMListView->uNewState & LVIS_FOCUSED)
	{
		m_nSelRow = pNMListView->iItem;
		SwitchViewToRowTarget(m_nSelRow);
	}
	*pResult = 0;
}


void CValidationPane::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// the view of the main pane should already have been switched by the first click
	// so no need to reset the view

	// this relies on the window tree staying in the same form
	CSplitterWnd* pSplitter = static_cast<CSplitterWnd*>(GetParent());
	CSplitterView* pDatabaseView = static_cast<CSplitterView*>(pSplitter->GetPane(0,0));
	CWnd* pTableView = pDatabaseView->m_wndSplitter.GetPane(0,1);
	pTableView->SetFocus();
}


///////////////////////////////////////////////////////////////////////
// when the list control receives an CR, switch the main view to the
// selected row
void CValidationPane::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (VK_RETURN == nChar)
	{
		CSplitterWnd* pSplitter = static_cast<CSplitterWnd*>(GetParent());
		CSplitterView* pDatabaseView = static_cast<CSplitterView*>(pSplitter->GetPane(0,0));
		CWnd* pTableView = pDatabaseView->m_wndSplitter.GetPane(0,1);
		pTableView->SetFocus();
		return;
	}
	CListView::OnChar(nChar, nRepCnt, nFlags);
}


///////////////////////////////////////////////////////////////////////
// CValidationError, class that maintains information about a validation
// error.
CValidationError::CValidationError(const CString* pstrICE, RESULTTYPES eiType, const CString* pstrDescription, 
	const COrcaTable* pTable, const COrcaRow* pRow, int iColumn)
{
	m_pstrICE = pstrICE ? new CString(*pstrICE) : NULL;
	m_pstrDescription = pstrDescription ? new CString(*pstrDescription) : NULL;
	m_iColumn = iColumn;
	m_eiType = eiType;
	m_pTable = pTable;
	m_pRow = pRow;
}


CValidationError::~CValidationError()
{
	if (m_pstrDescription)
		delete m_pstrDescription;
	if (m_pstrICE)
		delete m_pstrICE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\valpane.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_VALPANE_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_)
#define AFX_VALPANE_H__AB9A409F_2658_11D2_8889_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
//

#include "stdafx.h"
#include "orca.h"
#include "table.h"
#include "row.h"
#include "iface.h"

/////////////////////////////////////////////////////////////////////////////
// CPagePaths dialog

class CValidationPane : public CListView
{
	DECLARE_DYNCREATE(CValidationPane)

// Construction
public:
	CValidationPane();
	~CValidationPane();

// Implementation
public:
	virtual void SwitchFont(CString name, int size);
	void GetFontInfo(LOGFONT *data);

	
protected:
	virtual void OnInitialUpdate();
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	
	//{{AFX_MSG(COrcaListView)
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy( );
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	bool SwitchViewToRowTarget(int iItem);
	void ClearAllValidationErrors();

	CFont* m_pfDisplayFont;
	int m_nSelRow;
	bool m_fSendNotifications;
};


class CValidationError : public CObject
{
public:
	CValidationError(const CString* strICE, RESULTTYPES eiType, const CString* strDescription, const COrcaTable* pTable, const COrcaRow* pRow, int strColumn);
	~CValidationError();

	CString*    m_pstrICE;
	RESULTTYPES m_eiType;
	CString*    m_pstrDescription;

	const COrcaTable* m_pTable;
	const COrcaRow*   m_pRow;
	int m_iColumn;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\orca\valpp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//--------------------------------------------------------------------------

#if !defined(AFX_VALPAGE_H__2D9D6C93_3EDA_11D2_8893_00A0C981B015__INCLUDED_)
#define AFX_VALPAGE_H__2D9D6C93_3EDA_11D2_8893_00A0C981B015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ValPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CValPropPage dialog

class CValPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CValPropPage)

// Construction
public:
	bool m_bValChange;
	CValPropPage();
	~CValPropPage();

// Dialog Data
	//{{AFX_DATA(CValPropPage)
	enum { IDD = IDD_PAGE_VALIDATION };
	CString	m_strICEs;
	BOOL	m_bSuppressInfo;
	BOOL	m_bSuppressWarn;
	BOOL	m_bClearResults;
	CString m_strCUBFile;
	CComboBox m_ctrlCUBFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CValPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL OnInitDialog();
	virtual BOOL OnKillActive();
	virtual void OnDestroy(); 

	// Generated message map functions
	//{{AFX_MSG(CValPropPage)
	afx_msg void OnChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CMsmPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMsmPropPage)

// Construction
public:
	CMsmPropPage();
	~CMsmPropPage();

// Dialog Data
	//{{AFX_DATA(CValPropPage)
	enum { IDD = IDD_PAGE_MSM };
	int m_iMemoryCount;
	BOOL m_bAlwaysConfig;
	BOOL m_bWatchLog;
	//}}AFX_DATA
	
	bool m_bMSMChange;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CValPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL OnInitDialog();

	// Generated message map functions
	//{{AFX_MSG(CValPropPage)
	afx_msg void OnChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VALPAGE_H__2D9D6C93_3EDA_11D2_8893_00A0C981B015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\patchcache.h ===
#ifndef PATCHCACHE_H
#define PATCHCACHE_H

//need this #include for MSIHANDLE
#include "msiquery.h"

UINT PatchCacheEntryPoint( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName );

//new globals used in existing patchwiz code for new algorithm...
extern BOOL  g_bPatchCacheEnabled;

extern TCHAR g_szPatchCacheDir[MAX_PATH];

extern TCHAR g_szSourceLFN[MAX_PATH];
extern TCHAR g_szDestLFN[MAX_PATH];

//existing API's used in existing MSI PatchWiz.dll code and in the new patch caching code...
void  GetFileVersion ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow );
UINT  UiGenerateOnePatchFile ( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\fileptch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

  /* FILEPTCH.CPP -- File Patch stuff */

#pragma warning (disable:4553)

#include "patchdll.h"
#include "patchres.h"

//header file for new patch caching mechanism for perf...
#include "patchcache.h"

EnableAsserts


static MSIHANDLE g_hdbInput     = NULL;
static LPTSTR    g_szTempFolder = szNull;
static LPTSTR    g_szTempFName  = szNull;
static BOOL      g_bUsedMsiPatchHeadersTable = FALSE;

#ifdef UNICODE
static PATCH_OLD_FILE_INFO_W* g_ppofi        = NULL;
#else
static PATCH_OLD_FILE_INFO_A* g_ppofi        = NULL;
#endif
static LPSTR*               g_pszaSymPaths = NULL;  // ANSI strings only
static ULONG                g_cpofiMax     = 0;

static ULONG UlMaxExtFiles ( MSIHANDLE hdbInput );

static UINT IdsCountTargetImages                     ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsCreatePatchFilesMSTsCabinetsForFamily ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT UiStuffCabsAndMstsIntoPackage            ( MSIHANDLE hdbInput, LPTSTR szPatchPath );
static BOOL FSetPatchPackageSummaryInfo              ( MSIHANDLE hdbInput, LPTSTR szPatchPath );

/* ********************************************************************** */
UINT UiMakeFilePatchesCabinetsTransformsAndStuffIntoPatchPackage ( MSIHANDLE hdbInput, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szPatchPath));
	Assert(!FFolderExist(szPatchPath));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);

	g_hdbInput     = hdbInput;
	g_szTempFolder = szTempFolder;
	g_szTempFName  = szTempFName;

	Assert(g_ppofi == NULL);
	Assert(g_pszaSymPaths == NULL);
	Assert(g_cpofiMax == 0);
	
	UINT ids = IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`"), szNull, IdsCountTargetImages,
					0L, 0L);
	Assert(ids == IDS_OKAY);
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);
	g_cpofiMax += UlMaxExtFiles(hdbInput);
	Assert(g_cpofiMax < 256);

#ifdef UNICODE
	g_ppofi = (PATCH_OLD_FILE_INFO_W*)LocalAlloc(LPTR, g_cpofiMax*sizeof(PATCH_OLD_FILE_INFO_W));
#else
	g_ppofi = (PATCH_OLD_FILE_INFO_A*)LocalAlloc(LPTR, g_cpofiMax*sizeof(PATCH_OLD_FILE_INFO_A));
#endif
	Assert(g_ppofi != NULL);

	g_pszaSymPaths = (LPSTR*)LocalAlloc(LPTR, g_cpofiMax*sizeof(LPSTR));
	Assert(g_pszaSymPaths != NULL);

	for (ULONG ipofi = g_cpofiMax; ipofi-- > 0; )
		{
#ifdef UNICODE
		PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[ipofi]);
		ppofi->SizeOfThisStruct = sizeof(PATCH_OLD_FILE_INFO_W);
#else
		PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[ipofi]);
		ppofi->SizeOfThisStruct = sizeof(PATCH_OLD_FILE_INFO_A);
#endif
		ppofi->OldFileName      = szNull;
		ppofi->IgnoreRangeCount = 0;
		ppofi->IgnoreRangeArray = NULL;
		ppofi->RetainRangeCount = 0;
		ppofi->RetainRangeArray = NULL;

		g_pszaSymPaths[ipofi] = NULL;
		}

	ids = IdsMsiEnumTable(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`,`MediaDiskId`,`FileSequenceStart`"),
					szNull, IdsCreatePatchFilesMSTsCabinetsForFamily,
					0L, 0L);

	LocalFree((HLOCAL)g_ppofi);
	g_ppofi = NULL;
	LocalFree((HLOCAL)g_pszaSymPaths);
	g_pszaSymPaths = NULL;
	g_cpofiMax = 0;

	if (ids != IDS_OKAY)
		return (ids);

	lstrcpy(szTempFName, TEXT("tempcopy.msp"));
	Assert(!FFileExist(szTempFolder));
	Assert(!FFolderExist(szTempFolder));

	TCHAR rgchTempMspPath[MAX_PATH];
	lstrcpy(rgchTempMspPath, szTempFolder);
	*szTempFName = TEXT('\0');

	ids = UiStuffCabsAndMstsIntoPackage(hdbInput, rgchTempMspPath);
	if (ids != ERROR_SUCCESS)
		return (ids);

	if (!FSetPatchPackageSummaryInfo(hdbInput, rgchTempMspPath))
		return (UiLogError(ERROR_PCW_WRITE_SUMMARY_PROPERTIES, szNull, szNull));

	if (FFileExist(szPatchPath))
		{
		SetFileAttributes(szPatchPath, FILE_ATTRIBUTE_NORMAL);
		DeleteFile(szPatchPath);
		if (FFileExist(szPatchPath))
			return (UiLogError(ERROR_PCW_CANT_OVERWRITE_PATCH, szPatchPath, NULL));
		}
	if (!CopyFile(rgchTempMspPath, szPatchPath, fTrue))
		return (UiLogError(ERROR_PCW_CANT_OVERWRITE_PATCH, rgchTempMspPath, NULL));

	return (ERROR_SUCCESS);
}


/* ********************************************************************** */
static UINT IdsCountTargetImages ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	g_cpofiMax++;
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);

	return (IDS_OKAY);
}


static UINT IdsCountExtFiles ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static ULONG UlMaxExtFiles ( MSIHANDLE hdbInput )
{
	Assert(hdbInput != NULL);

	ULONG ulRet = 0L;

	EvalAssert( MSI_OKAY == IdsMsiEnumTable(hdbInput,
					TEXT("`ExternalFiles`"), TEXT("`Family`,`FTK`"),
					szNull, IdsCountExtFiles,
					(LPARAM)(hdbInput), (LPARAM)(&ulRet)) );

	Assert(ulRet >= 0L);
	Assert(ulRet < 250L);

	return (ulRet);
}


static UINT IdsIncrExtFilesCount ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT IdsCountExtFiles ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdbInput = (MSIHANDLE)lp1;
	Assert(hdbInput != NULL);

	ULONG* pulMax = (ULONG*)lp2;
	Assert(pulMax != NULL);

	TCHAR rgchFamily[16];
	DWORD dwcch = 16;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFamily));

	TCHAR rgchFTK[128];
	dwcch = 128;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFTK));

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Family`='%s' AND `FTK`='%s'"), rgchFamily, rgchFTK);
	Assert(lstrlen(rgchWhere) < sizeof(rgchWhere)/sizeof(TCHAR));

	ULONG ulRet = 0L;
	EvalAssert( MSI_OKAY == IdsMsiEnumTable(hdbInput,
					TEXT("`ExternalFiles`"), TEXT("`Family`,`FTK`"),
					rgchWhere, IdsIncrExtFilesCount,
					(LPARAM)(&ulRet), 0L) );

	Assert(ulRet >= 1L);
	Assert(ulRet < 250L);

	if (ulRet > *pulMax)
		*pulMax = ulRet;

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsIncrExtFilesCount ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	ULONG* pulCount = (ULONG*)lp1;
	Assert(pulCount != NULL);

	(*pulCount)++;

	return (IDS_OKAY);
}


static UINT UiMakeFilePatches ( LPTSTR szFamily, int iDiskId, int* piSequenceNumCur );
static UINT UiMakeTransforms  ( LPTSTR szFamily, int iSequenceNumCur );
static UINT UiCreateCabinet   ( LPTSTR szFamily, int iSequenceNumStart, int iSequenceNumCur );

/* ********************************************************************** */
static UINT IdsCreatePatchFilesMSTsCabinetsForFamily ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	TCHAR rgchFamily[32];
	DWORD dwcch = 32;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchFamily));

	lstrcpy(g_szTempFName, rgchFamily);
	lstrcat(g_szTempFName, TEXT("\\"));
	if (!FEnsureFolderExists(g_szTempFolder))
		return (UiLogError(ERROR_PCW_CANT_CREATE_TEMP_FOLDER, g_szTempFolder, szNull));
	Assert(FFolderExist(g_szTempFolder));

	int iDiskId, iSeqNumStart;

	if (MsiRecordIsNull(hrec, 2))
		{
		// patch targeting Windows Installer 2.0 or greater; sequence conflict management will take care of this

		// we don't validate that MinimumRequiredMsiVersion >= iWindowsInstallerXP since IdsValidateFamilyRecords
		// should already have taken care of this
			iDiskId = 2;
		}
	else
		{
		iDiskId = MsiRecordGetInteger(hrec, 2);
		}
	Assert(iDiskId > 1);

	if (MsiRecordIsNull(hrec, 3))
		{
		// patch targeting Windows Installer 2.0 or greater; sequence conflict management will take care of this

		// we don't validate that MinimumRequiredMsiVersion >= iWindowsInstallerXP since IdsValidateFamilyRecords
		// should already have taken care of this
			iSeqNumStart = 2;
		}
	else
		{
		iSeqNumStart = MsiRecordGetInteger(hrec, 3);
		}
	Assert(iSeqNumStart > 1);

	int iSeqNumCur = iSeqNumStart;

	UpdateStatusMsg(IDS_STATUS_CREATE_FILE_PATCHES, rgchFamily, szEmpty);
	uiRet = UiMakeFilePatches(rgchFamily, iDiskId, &iSeqNumCur);
	if (uiRet != ERROR_SUCCESS)
		return (uiRet);

	UpdateStatusMsg(IDS_STATUS_CREATE_TRANSFORMS, rgchFamily, szEmpty);
	uiRet = UiMakeTransforms(rgchFamily, iSeqNumCur);
	if (uiRet != ERROR_SUCCESS)
		return (uiRet);
			
	UpdateStatusMsg(IDS_STATUS_CREATE_CABINET, rgchFamily, szEmpty);
	uiRet = UiCreateCabinet(rgchFamily, iSeqNumStart, iSeqNumCur);
	if (uiRet != ERROR_SUCCESS)
		return (uiRet);

	return (IDS_OKAY);
}


static int    g_iSeqNumCur       = 0;
static LPTSTR g_szFamily         = szNull;
static BOOL   g_fDontUsePatching = fFalse;

static UINT IdsMakeFilePatchesForUpgradedImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsUpdateLastSeqNumForTargetImage  ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT UiMakeFilePatches ( LPTSTR szFamily, int iDiskId, int* piSequenceNumCur )
{
	Assert(!FEmptySz(szFamily));
	Assert(iDiskId > 1);
	Assert(piSequenceNumCur != NULL);
	Assert(*piSequenceNumCur > 0);

	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);
	Assert(g_ppofi != NULL);
	Assert(g_pszaSymPaths != NULL);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	g_iSeqNumCur = *piSequenceNumCur;
	g_szFamily   = szFamily;

	TCHAR rgchWhere[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(g_hdbInput, TEXT("Properties"), TEXT("Name"), TEXT("Value"), TEXT("IncludeWholeFilesOnly"), rgchWhere, MAX_PATH) );

	TCHAR rgchPatchCacheEnabled[4];
	HRESULT hrret;
	hrret = IdsMsiGetTableString(g_hdbInput, TEXT("Properties"), TEXT("Name"), TEXT("Value"), TEXT("PATCH_CACHE_ENABLED"), rgchPatchCacheEnabled, 4);

	if (S_OK == hrret)
		{
		if (rgchPatchCacheEnabled[0] == '1')
		{
			g_bPatchCacheEnabled = TRUE;

			HRESULT hrret2;
			TCHAR rgchPatchCacheDir[MAX_PATH];
			hrret2 = IdsMsiGetTableString(g_hdbInput, TEXT("Properties"), TEXT("Name"), TEXT("Value"), TEXT("PATCH_CACHE_DIR"), rgchPatchCacheDir, MAX_PATH);
			if (S_OK == hrret2)
				{
				if (!FEmptySz(rgchPatchCacheDir))
					{
					TCHAR rgchOptimizePatchSizeBuf[64];
					if (*SzLastChar(rgchPatchCacheDir) != TEXT('\\'))
						{
							_tcscat(rgchPatchCacheDir, TEXT("\\"));
						}

					//are we doing a 1.2 or 1.1 compatible patch?
					UINT iRet = IdsMsiGetPcwPropertyString(g_hdbInput, TEXT("OptimizePatchSizeForLargeFiles"), rgchOptimizePatchSizeBuf, 64);
				 
					if (iRet == IDS_OKAY) //ok, found it, is it on or off?
						{
							if (rgchOptimizePatchSizeBuf[0] == TEXT('1')) //1.2 feature on?
								_tcscat(rgchPatchCacheDir, TEXT("1.2\\"));  //set cache dir to 1.2 compatible only!  Won't work on less than 1.2 engine!
							else
								_tcscat(rgchPatchCacheDir, TEXT("1.1\\")); //not using 1.2 feature, so cache dir can be 1.1 compatible...
						}
					else
						{
							_tcscat(rgchPatchCacheDir, TEXT("1.1\\"));
						}

					// must be sure trailing backslash '\' is the last char in rgchPatchCacheDir

					if (!FEnsureFolderExists(rgchPatchCacheDir))
						{
						Assert(1); //dir creation failed!
						g_bPatchCacheEnabled = FALSE; //no dir, can't use caching
						}
					else
						_tcscpy(g_szPatchCacheDir, rgchPatchCacheDir);
					}
				else //no dir, can't use caching
					{
					EvalAssert( FWriteLogFile(TEXT("    Patch cache could not be used!  Need to set PATCH_CACHE_DIR in Properties table in .pcp file\r\n")) );
					g_bPatchCacheEnabled = FALSE;
					}
				}
			}
		}
	
	g_fDontUsePatching = ((!FEmptySz(rgchWhere)) && (*rgchWhere != TEXT('0')));

	wsprintf(rgchWhere, TEXT("`Family`='%s'"), szFamily);

	UINT ids = IdsMsiEnumTable(g_hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`,`MsiPath`,`LFN`"),
					rgchWhere, IdsMakeFilePatchesForUpgradedImage,
					(LPARAM)(g_hdbInput), 0L);
	if (ids != IDS_OKAY)
		return (ids);
	*piSequenceNumCur = g_iSeqNumCur;

	ids = IdsMsiEnumTable(g_hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`"), rgchWhere,
					IdsUpdateLastSeqNumForTargetImage, (LPARAM)iDiskId, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	return (ERROR_SUCCESS);
}


/* ********************************************************************** */
static UINT IdsUpdateLastSeqNumForTargetImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	int iDiskId = (int)(lp1);
	Assert(iDiskId > 1);

	Assert(g_hdbInput != NULL);
	Assert(g_iSeqNumCur > 1);

	TCHAR rgchTarget[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTarget));

	MSIHANDLE hdbCopyOfUpgradedImage = HdbReopenMsi(g_hdbInput, rgchTarget, fFalse, fTrue);
	Assert(hdbCopyOfUpgradedImage != NULL);

	uiRet = IdsMsiUpdateTableRecordIntPkeyInt(hdbCopyOfUpgradedImage, TEXT("Media"),
				TEXT("LastSequence"), g_iSeqNumCur, TEXT("DiskId"), iDiskId);

	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdbCopyOfUpgradedImage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbCopyOfUpgradedImage) );

	return (uiRet);
}


static LPTSTR g_szUpgradedImage     = szNull;
static BOOL   g_fLfn                = fFalse;
static LPTSTR g_szUpgradedSrcFolder = szNull;
static LPTSTR g_szUpgradedSrcFName  = szNull;

static UINT IdsHandleOneFilePatch ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT IdsMakeFilePatchesForUpgradedImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	MSIHANDLE hdbInput = (MSIHANDLE)(lp1);
	Assert(hdbInput != NULL);

	Assert(g_szFamily     != szNull);
	Assert(g_szTempFolder != szNull);
	Assert(g_szTempFName  != szNull);
	Assert(g_iSeqNumCur   > 0);

	TCHAR rgchSrcRoot[MAX_PATH+MAX_PATH];
	DWORD dwcch = MAX_PATH+MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgchSrcRoot, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchSrcRoot));
	Assert(FFileExist(rgchSrcRoot));
	g_szUpgradedSrcFolder = rgchSrcRoot;
	g_szUpgradedSrcFName  = SzFindFilenameInPath(g_szUpgradedSrcFolder);
	Assert(!FEmptySz(g_szUpgradedSrcFName));

	TCHAR rgch[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 3, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgch));
	Assert(!lstrcmp(rgch, TEXT("Yes")) || !lstrcmp(rgch, TEXT("No")));
	g_fLfn = (*rgch == TEXT('Y'));

	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 1, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgch));
	g_szUpgradedImage = rgch;

	UpdateStatusMsg(0, rgch, TEXT(""));

	MSIHANDLE hdbUpgradedImage = HdbReopenMsi(hdbInput, rgch, fTrue, fFalse);
	Assert(hdbUpgradedImage != NULL);

	uiRet = IdsMsiEnumTable(hdbUpgradedImage, TEXT("`File`"),
					TEXT("`File`,`Component_`,`FileName`"),
					szNull, IdsHandleOneFilePatch,
					lp1, (LPARAM)hdbUpgradedImage);

	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbUpgradedImage) );

	return (uiRet);
}


static TCHAR g_rgchFNameToCompare[MAX_PATH] = TEXT("");
static TCHAR g_rgchSubFolderToCompare[MAX_PATH+ MAX_PATH] = TEXT("");

static BOOL FFamilyFileProcessed      ( MSIHANDLE hdb, LPTSTR szFamily, LPTSTR szFTK );
static BOOL FFamilyFileIgnored        ( MSIHANDLE hdb, LPTSTR szUpgraded, LPTSTR szFTK );
static void ClearAttributeField       ( MSIHANDLE hdb, LPTSTR szTable );
static void DoTargetFileComparesForUpgradedsInFamilyThatHaveFile ( MSIHANDLE hdbInput, LPTSTR szFTK );
static void DoFileComparesForExternalFiles ( MSIHANDLE hdbInput, LPTSTR szWhere );
static void GetFileSizeSz             ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow );
static UINT IdsUpdateMsiForNewSeqNum  ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT IdsHandleOneFilePatch ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdbInput         = (MSIHANDLE)(lp1);
	MSIHANDLE hdbUpgradedImage = (MSIHANDLE)(lp2);
	Assert(hdbInput         != NULL);
	Assert(g_hdbInput       == hdbInput);
	Assert(hdbUpgradedImage != NULL);

	Assert(g_szFamily     != szNull);
	Assert(g_szTempFolder != szNull);
	Assert(g_szTempFName  != szNull);
	Assert(g_iSeqNumCur   > 0);

	Assert(g_szUpgradedImage != szNull);
	// g_fLfn is set appropriately
	Assert(!FEmptySz(g_szUpgradedSrcFolder));
	Assert(g_szUpgradedSrcFName != szNull);

	TCHAR rgchFTK[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchFTK, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFTK));        // File.File

	if (FFamilyFileProcessed(hdbInput, g_szFamily, rgchFTK))
		return (IDS_OKAY); // no work here

	if (FFamilyFileIgnored(hdbInput, g_szUpgradedImage, rgchFTK))
		return (IDS_OKAY); // no work here

	UpdateStatusMsg(0, szNull, rgchFTK);

	TCHAR rgchComponent[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchComponent, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchComponent));  // File.Component_

	TCHAR rgchFName[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchFName, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFName));      // File.FileName
	lstrcpy(g_rgchFNameToCompare, rgchFName);

	uiRet = IdsResolveSrcFilePathSzs(hdbUpgradedImage, g_szUpgradedSrcFName,
				rgchComponent, rgchFName, g_fLfn, g_rgchSubFolderToCompare);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(g_szUpgradedSrcFName));
	if (!FFileExist(g_szUpgradedSrcFolder))
		return (IDS_OKAY); // no work here

	ClearAttributeField(hdbInput, TEXT("TargetImages"));

	DoTargetFileComparesForUpgradedsInFamilyThatHaveFile(hdbInput, rgchFTK);

	BOOL fNeedWholeFile = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
				TEXT("`TargetImages`"), TEXT("`Target`"),
				TEXT("WHERE `Attributes` = 2"), &fNeedWholeFile) );
	BOOL fFilesDiffer = fNeedWholeFile;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
				TEXT("`TargetImages`"), TEXT("`Target`"),
				TEXT("WHERE `Attributes` = 1"), &fFilesDiffer) );

#define rgchWhere rgchComponent // reuse buffer
	if (!fNeedWholeFile)
		{
		wsprintf(rgchWhere, TEXT("`FTK` = '%s' AND `Family` = '%s'"), rgchFTK, g_szFamily);
		DoFileComparesForExternalFiles(hdbInput, rgchWhere);
		}

	if (!fFilesDiffer)
		{
		wsprintf(rgchWhere, TEXT("WHERE `FTK` = '%s' AND `Family` = '%s'"), rgchFTK, g_szFamily);
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
				TEXT("`ExternalFiles`"), TEXT("`FilePath`"),
				rgchWhere, &fFilesDiffer) );
		}

	if (!fFilesDiffer)
		return (IDS_OKAY); // no work here

	if (g_fDontUsePatching)
		fNeedWholeFile = fTrue;
	else if (!fNeedWholeFile)
		{
		BOOL fExists;

		fExists = fFalse;
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
						TEXT("`UpgradedFiles_OptionalData`"),
						TEXT("`Upgraded`"), TEXT("WHERE `IncludeWholeFile` is null"), &fExists) );
		Assert(!fExists);

		/* single backslashes (`) eliminated to shorten query length */
		wsprintf(rgchWhere, TEXT("WHERE UpgradedImages.Upgraded = UpgradedFiles_OptionalData.Upgraded AND Family = '%s' AND FTK = '%s' AND IncludeWholeFile <> 0"),
				g_szFamily, rgchFTK);
//		wsprintf(rgchWhere, TEXT("WHERE UpgradedImages.Upgraded = UpgradedFiles_OptionalData.Upgraded AND Family = '%s' AND FTK = '%s' AND IncludeWholeFile is not null AND IncludeWholeFile <> 0"),
//				g_szFamily, rgchFTK);
		fExists = fFalse;
		/* single backslashes (`) eliminated to shorten query length */
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput,
						TEXT("UpgradedImages,UpgradedFiles_OptionalData"),
						TEXT("Family"), rgchWhere, &fExists) );
		if (fExists)
			fNeedWholeFile = fTrue;
		}


	wsprintf(rgchWhere, TEXT("`Family` = '%s' AND `FTK` = '%s'"),
				g_szFamily, rgchFTK);
	int iSeqNumNew = 0;
	uiRet = IdsMsiGetTableIntegerWhere(hdbInput, TEXT("`NewSequenceNums`"),
				TEXT("`SequenceNum`"), rgchWhere, &iSeqNumNew);
	Assert(uiRet == IDS_OKAY);

	if (iSeqNumNew == MSI_NULL_INTEGER || iSeqNumNew <= 0)
		{
		iSeqNumNew = g_iSeqNumCur++;
		Assert(iSeqNumNew <= 32767);
		if (!fNeedWholeFile)
			{
			lstrcpy(g_szTempFName, g_szFamily);
			lstrcat(g_szTempFName, TEXT("\\"));
			
			//Only do this for non-full files as full files is NOT 
			//slow...
			if (g_bPatchCacheEnabled) //use new algorithm???
				{
				UINT ui = PatchCacheEntryPoint(hdbInput, rgchFTK, g_szUpgradedSrcFolder, iSeqNumNew,
												g_szTempFolder, g_szTempFName + lstrlen(g_szTempFName));

				if (ui != IDS_OKAY)
				     return (ui);
				}
			else //caching not enabled, using existing way of doing patches...
				{
				UINT ui = UiGenerateOnePatchFile(hdbInput, rgchFTK, g_szUpgradedSrcFolder, iSeqNumNew,
													g_szTempFolder, g_szTempFName + lstrlen(g_szTempFName));

				if (ui != IDS_OKAY)
				   return (ui);
	
				}
			}

		DWORD dwNewHi = 0L, dwNewLow = 0L;
		wsprintf(g_szTempFName, TEXT("%s\\%05i.PAT"), g_szFamily, iSeqNumNew);
		if (!FFileExist(g_szTempFolder))
			{
			EvalAssert( FWriteLogFile(TEXT("    Patch API could not create a small patch; using whole upgraded file.\r\n")) );
			fNeedWholeFile = fTrue;
			}
		else
			{
			GetFileSizeSz(g_szTempFolder, &dwNewHi, &dwNewLow);
			wsprintf(g_szTempFName, TEXT("%s\\%05i.HDR"), g_szFamily, iSeqNumNew);
			if (dwNewHi > 0L || dwNewLow > 2147483647L || !FFileExist(g_szTempFolder))
				{
				EvalAssert( FWriteLogFile(TEXT("    Patch API could not create a small patch header; using whole upgraded file.\r\n")) );
				fNeedWholeFile = fTrue;
				}
			else
				{
				GetFileSizeSz(g_szTempFolder, &dwNewHi, &dwNewLow);

				Assert(FFileExist(g_szUpgradedSrcFolder));
				DWORD dwSrcHi = 0L, dwSrcLow = 0L;
				GetFileSizeSz(g_szUpgradedSrcFolder, &dwSrcHi, &dwSrcLow);

				if (dwNewHi > dwSrcHi || (dwNewHi == dwSrcHi && dwNewLow >= dwSrcLow))
					{
					EvalAssert( FWriteLogFile(TEXT("    Patch API results are bigger than upgraded file; using whole upgraded file.\r\n")) );
					fNeedWholeFile = fTrue;
					}
				}
			}

		if (fNeedWholeFile)
			{
			wsprintf(g_szTempFName, TEXT("%s\\%05i.PAT"), g_szFamily, iSeqNumNew);
			if (FFileExist(g_szTempFolder))
				{
				SetFileAttributes(g_szTempFolder, FILE_ATTRIBUTE_NORMAL);
				DeleteFile(g_szTempFolder);
				Assert(!FFileExist(g_szTempFolder));
				}
			wsprintf(g_szTempFName, TEXT("%s\\%05i.HDR"), g_szFamily, iSeqNumNew);
			if (FFileExist(g_szTempFolder))
				{
				SetFileAttributes(g_szTempFolder, FILE_ATTRIBUTE_NORMAL);
				DeleteFile(g_szTempFolder);
				Assert(!FFileExist(g_szTempFolder));
				}
			wsprintf(g_szTempFName, TEXT("%s\\%05i.FLE"), g_szFamily, iSeqNumNew);
			if (FFileExist(g_szTempFolder))
				{
				SetFileAttributes(g_szTempFolder, FILE_ATTRIBUTE_NORMAL);
				DeleteFile(g_szTempFolder);
				Assert(!FFileExist(g_szTempFolder));
				}
			EvalAssert( FSprintfToLog(TEXT("  Including entire file: '%s';\r\n           FTK=%s; temp location=%s."), g_szUpgradedSrcFolder, rgchFTK, g_szTempFName, szEmpty) );
			if (!CopyFile(g_szUpgradedSrcFolder, g_szTempFolder, fTrue))
				{
				return (UiLogError(ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER,
						g_szUpgradedSrcFolder, g_szTempFolder));
				}
			}
		else
			{
			if (!g_bPatchCacheEnabled) //if cache is used, don't write out stuff to log...
				{
				EvalAssert( FSprintfToLog(TEXT("  Patch file created: FTK=%s; temp location=%s."), rgchFTK, g_szTempFName, szEmpty, szEmpty) );
				}
			}

#define rgchQuery rgchComponent // reuse buffer
		wsprintf(rgchQuery, TEXT("INSERT INTO `NewSequenceNums` ( `Family`, `FTK`, `SequenceNum` ) VALUES ( '%s', '%s', %d )"),
				g_szFamily, rgchFTK, iSeqNumNew);
		Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

		MSIHANDLE hviewNew = NULL;
		EvalAssert( MSI_OKAY == MsiDatabaseOpenView(hdbInput, rgchQuery, &hviewNew) );
		Assert(hviewNew != NULL);
		EvalAssert( MSI_OKAY == MsiViewExecute(hviewNew, 0) );
		EvalAssert( MSI_OKAY == MsiCloseHandle(hviewNew) );

		Assert(g_hdbInput == hdbInput);

		EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput,
						TEXT("`TargetImages`"),
						TEXT("`Target`,`Upgraded`"),
						TEXT("Attributes <> 0"), IdsUpdateMsiForNewSeqNum,
						(LPARAM)rgchFTK, (LPARAM)iSeqNumNew) );
		}

#undef rgchQuery
#undef rgchWhere

	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FFamilyFileProcessed ( MSIHANDLE hdb, LPTSTR szFamily, LPTSTR szFTK )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szFamily));
	Assert(!FEmptySz(szFTK));

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Upgraded` = '%s' AND `FTK` = '%s'"), szFamily, szFTK);

	TCHAR rgch[64];
	EvalAssert( IDS_OKAY == IdsMsiGetTableStringWhere(hdb, TEXT("`UpgradedFiles_OptionalData`"),
					TEXT("`Upgraded`"), rgchWhere, rgch, 64) );

	return (!FEmptySz(rgch));
}


static UINT IdsMatchIgnoreFTK ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FFamilyFileIgnored ( MSIHANDLE hdb, LPTSTR szUpgraded, LPTSTR szFTK )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szUpgraded));
	Assert(!FEmptySz(szFTK));

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Upgraded` = '*' OR `Upgraded` = '%s'"), szUpgraded);

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`UpgradedFilesToIgnore`"),
						TEXT("`FTK`"), rgchWhere, IdsMatchIgnoreFTK,
						(LPARAM)szFTK, 0L);
	Assert(ids == IDS_OKAY || ids == IDS_CANCEL);

	return (ids != IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsMatchIgnoreFTK ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0l);

	LPTSTR szFTK = (LPTSTR)(lp1);
	Assert(!FEmptySz(szFTK));

	TCHAR rgchFTK[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFTK, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFTK));

	if (*SzLastChar(rgchFTK) != TEXT('*'))
		return ((!lstrcmp(szFTK, rgchFTK)) ? IDS_CANCEL : IDS_OKAY);

	*SzLastChar(rgchFTK) = TEXT('\0');

	return ((FMatchPrefix(szFTK, rgchFTK)) ? IDS_CANCEL : IDS_OKAY);
}


/* ********************************************************************** */
static void ClearAttributeField ( MSIHANDLE hdb, LPTSTR szTable )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!lstrcmp(szTable, TEXT("TargetImages")));

	TCHAR rgchQuery[MAX_PATH];
	wsprintf(rgchQuery, TEXT("UPDATE `%s` SET `Attributes` = 0"), szTable);
	Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

	MSIHANDLE hview;
	EvalAssert( MSI_OKAY == MsiDatabaseOpenView(hdb, rgchQuery, &hview) );
	EvalAssert( MSI_OKAY == MsiViewExecute(hview, 0) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hview) );  /* calls MsiViewClose() internally */
}


static void DoTargetFileComparesForThisUpgradedImage ( MSIHANDLE hdbInput, LPTSTR szUpgraded, LPTSTR szFTK );
static UINT IdsDoTargetFileComparesIfFileExists ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static void DoTargetFileComparesForUpgradedsInFamilyThatHaveFile ( MSIHANDLE hdbInput, LPTSTR szFTK )
{
	Assert(hdbInput != NULL);
	Assert(g_hdbInput == hdbInput);
	Assert(!FEmptySz(szFTK));

	Assert(!FEmptySz(g_szFamily));
	Assert(!FEmptySz(g_szUpgradedImage));
	Assert(!FEmptySz(g_szUpgradedSrcFolder));
	Assert(FFileExist(g_szUpgradedSrcFolder)); // NOTE: true but expensive test

	DoTargetFileComparesForThisUpgradedImage(hdbInput, g_szUpgradedImage, szFTK);

	TCHAR rgchWhere[128];
	wsprintf(rgchWhere, TEXT("`Family` = '%s' AND `Upgraded` <> '%s'"), g_szFamily, g_szUpgradedImage);
	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`,`MsiPath`,`LFN`"),
					rgchWhere, IdsDoTargetFileComparesIfFileExists,
					(LPARAM)hdbInput, (LPARAM)szFTK) );
}


static UINT IdsMarkIfSrcFileDiffers ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static void DoTargetFileComparesForThisUpgradedImage ( MSIHANDLE hdbInput, LPTSTR szUpgraded, LPTSTR szFTK )
{
	Assert(hdbInput != NULL);
	Assert(g_hdbInput == hdbInput);
	Assert(!FEmptySz(szUpgraded));
	Assert(!FEmptySz(szFTK));

	Assert(!FEmptySz(g_szUpgradedSrcFolder));
	Assert(FFileExist(g_szUpgradedSrcFolder)); // NOTE: true but expensive test

	TCHAR rgchWhere[128];
	wsprintf(rgchWhere, TEXT("`Upgraded` = '%s'"), szUpgraded);
	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`,`MsiPath`,`LFN`,`Attributes`,`IgnoreMissingSrcFiles`"),
					rgchWhere, IdsMarkIfSrcFileDiffers,
					(LPARAM)g_szUpgradedSrcFolder, (LPARAM)szFTK) );
}


static BOOL FDoFilesDiffer    ( LPTSTR szFile1, LPTSTR szFile2 );
static BOOL FComponentInImage ( MSIHANDLE hdb, LPTSTR szComp );

/* ********************************************************************** */
static UINT IdsDoTargetFileComparesIfFileExists ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdbInput = (MSIHANDLE)lp1;
	Assert(hdbInput != NULL);
	Assert(g_hdbInput == hdbInput);
	
	LPTSTR szFTK = (LPTSTR)lp2;
	Assert(!FEmptySz(szFTK));

	Assert(!FEmptySz(g_szUpgradedSrcFolder));
	Assert(FFileExist(g_szUpgradedSrcFolder)); // NOTE: true but expensive test

	TCHAR rgchUpgraded[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchUpgraded, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchUpgraded));

	MSIHANDLE hdbUpgradedImage = HdbReopenMsi(hdbInput, rgchUpgraded, fTrue, fFalse);
	Assert(hdbUpgradedImage != NULL);

	TCHAR rgchComponent[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbUpgradedImage, TEXT("`File`"),
					TEXT("`File`"), TEXT("`Component_`"), szFTK,
					rgchComponent, MAX_PATH);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	if (FEmptySz(rgchComponent))
		goto LEarlyReturn; // file not in this Upgraded image
	if (!FComponentInImage(hdbUpgradedImage, rgchComponent))
		goto LEarlyReturn;

	TCHAR rgchFName[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbUpgradedImage, TEXT("`File`"),
					TEXT("`File`"), TEXT("`FileName`"), szFTK,
					rgchFName, MAX_PATH);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFName));

	TCHAR rgchPath[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchPath, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchPath));        // LFN
	Assert(!lstrcmp(rgchPath, TEXT("Yes")) || !lstrcmp(rgchPath, TEXT("No")));
	BOOL fLfn;
	fLfn = (*rgchPath == TEXT('Y'));

	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchPath, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchPath));        // MsiPath
	Assert(FFileExist(rgchPath)); // NOTE: true but expensive test

	LPTSTR szFNameBuf;
	szFNameBuf = SzFindFilenameInPath(rgchPath);
	Assert(!FEmptySz(szFNameBuf));

	uiRet = IdsResolveSrcFilePathSzs(hdbUpgradedImage, szFNameBuf,
				rgchComponent, rgchFName, fLfn, g_rgchSubFolderToCompare);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(szFNameBuf));

	if (FFileExist(rgchPath))
		{
		Assert(!FDoFilesDiffer(g_szUpgradedSrcFolder, rgchPath)); // NOTE: true but expensive test
		DoTargetFileComparesForThisUpgradedImage(hdbInput, rgchUpgraded, szFTK);
		}

LEarlyReturn:
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbUpgradedImage) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsMarkIfSrcFileDiffers ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	Assert(g_hdbInput != NULL);

	LPTSTR szUpgradedImageSrcFile = (LPTSTR)(lp1);
	Assert(!FEmptySz(szUpgradedImageSrcFile));
	Assert(FFileExist(szUpgradedImageSrcFile)); // NOTE: true but expensive test

	LPTSTR szFTK = (LPTSTR)(lp2);
	Assert(!FEmptySz(szFTK));


	TCHAR rgchTargetImage[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTargetImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTargetImage));

	MSIHANDLE hdbTargetImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fFalse);
	Assert(hdbTargetImage != NULL);

	TCHAR rgchComponent[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbTargetImage, TEXT("`File`"),
					TEXT("`File`"), TEXT("`Component_`"), szFTK,
					rgchComponent, MAX_PATH);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	if (FEmptySz(rgchComponent)) // file is missing completely from this image
		goto LMarkAsNeedingEntireFile;
	if (!FComponentInImage(hdbTargetImage, rgchComponent))
		goto LMarkAsNeedingEntireFile;

	TCHAR rgchFName[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbTargetImage, TEXT("`File`"),
					TEXT("`File`"), TEXT("`FileName`"), szFTK,
					rgchFName, MAX_PATH);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFName));

	if (lstrcmpi(g_rgchFNameToCompare, rgchFName))
		{
		EvalAssert( FSprintfToLog(TEXT("WARNING (11): File.FileName mismatch between Upgraded ('%s') and Target ('%s') Images means old files may be orphaned.  File Table Key: %s"),
				g_rgchFNameToCompare, rgchFName, szFTK, szEmpty) );
		goto LMarkAsNeedingEntireFile;
		}

	TCHAR rgchPath[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchPath, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchPath));        // LFN
	Assert(!lstrcmp(rgchPath, TEXT("Yes")) || !lstrcmp(rgchPath, TEXT("No")));
	BOOL fLfn;
	fLfn = (*rgchPath == TEXT('Y'));

	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchPath, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchPath));        // Path_To_Msi
	Assert(FFileExist(rgchPath)); // NOTE: true but expensive test

	LPTSTR szFNameBuf;
	szFNameBuf = SzFindFilenameInPath(rgchPath);
	Assert(!FEmptySz(szFNameBuf));

	TCHAR rgchSubFolder[MAX_PATH + MAX_PATH];
	uiRet = IdsResolveSrcFilePathSzs(hdbTargetImage, szFNameBuf,
				rgchComponent, rgchFName, fLfn, rgchSubFolder);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(szFNameBuf));

	if (!FFileExist(rgchPath))
		{
		int iRet = MsiRecordGetInteger(hrec, 5); // IgnoreMissingSrcFiles
		if (iRet == MSI_NULL_INTEGER || iRet == 0)
			{
			EvalAssert( FSprintfToLog(TEXT("    Src file missing: '%s'."), rgchPath, szEmpty, szEmpty, szEmpty) );
			goto LMarkAsNeedingEntireFile;
			}
		}
	else if (lstrcmpi(g_rgchSubFolderToCompare, rgchSubFolder))
		{
		EvalAssert( FSprintfToLog(TEXT("WARNING (12): SubFolder mismatch between Upgraded ('%s') and Target ('%s') Images means old files may be orphaned.  File Table Key: %s\r\n"),
				g_rgchSubFolderToCompare, rgchSubFolder, szFTK, szEmpty) );

LMarkAsNeedingEntireFile:
		EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 4, 2) );
		EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );
		}
	else if (FDoFilesDiffer(szUpgradedImageSrcFile, rgchPath))
		{
		if (!g_bPatchCacheEnabled)
			{
			EvalAssert( FSprintfToLog(TEXT("     Files differ: '%s',\r\n                   '%s'."), szUpgradedImageSrcFile, rgchPath, szEmpty, szEmpty) );
			}
		EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 4, 1) );
		EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );
		
		if (g_bPatchCacheEnabled) //only do for caching option set...
			{
			_tcscpy(g_szSourceLFN, rgchPath);
			_tcscpy(g_szDestLFN, szUpgradedImageSrcFile);
			}
		}

	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbTargetImage) );

	return (IDS_OKAY);
}


static UINT IdsMarkIfFileMatches ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static void DoFileComparesForExternalFiles ( MSIHANDLE hdbInput, LPTSTR szWhere )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szWhere));

	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`ExternalFiles`"),
					TEXT("`FilePath`,`FTK`"), szWhere,
					IdsMarkIfFileMatches, (LPARAM)g_szUpgradedSrcFolder, 0L) );
}


/* ********************************************************************** */
static UINT IdsMarkIfFileMatches ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	LPTSTR szUpgradedImageSrcFile = (LPTSTR)(lp1);
	Assert(!FEmptySz(szUpgradedImageSrcFile));
	Assert(FFileExist(szUpgradedImageSrcFile)); // NOTE: true but expensive test


	TCHAR rgch[MAX_PATH+MAX_PATH];
	DWORD dwcch = MAX_PATH+MAX_PATH;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgch));
	Assert(FFileExist(rgch)); // NOTE: true but expensive test

	if (!FDoFilesDiffer(szUpgradedImageSrcFile, rgch))
		{
		TCHAR rgchNewFTK[MAX_PATH];
		lstrcpy(rgchNewFTK, TEXT("<matches> "));
		dwcch = MAX_PATH - lstrlen(rgchNewFTK);
		LPTSTR szFTK = rgchNewFTK + lstrlen(rgchNewFTK);
		uiRet = MsiRecordGetString(hrec, 2, szFTK, &dwcch);
		Assert(uiRet != ERROR_MORE_DATA);
		Assert(uiRet == IDS_OKAY);
		Assert(!FEmptySz(szFTK));

		if (!g_bPatchCacheEnabled) //try to speed up more by not writing to log...
			{
			EvalAssert( FSprintfToLog(TEXT("     External file matched, ignoring; FTK = '%s',\r\n                   : '%s',\r\n                   '%s'."), szFTK, szUpgradedImageSrcFile, rgch, szEmpty) );
			}

		EvalAssert( MSI_OKAY == MsiRecordSetString(hrec, 2, rgchNewFTK) );
		EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );
		}
	else
		{
			if (!g_bPatchCacheEnabled) //don't write to log if we want speed...
			{
			EvalAssert( FSprintfToLog(TEXT("     Files differ: '%s',\r\n                   <ExtFile>: '%s'."), szUpgradedImageSrcFile, rgch, szEmpty, szEmpty) );
			}
		}

	return (IDS_OKAY);
}


TCHAR g_szLastFile1[MAX_PATH] = TEXT("");
TCHAR g_szLastFile2[MAX_PATH] = TEXT("");

#define READ_SIZE 8192

/* ********************************************************************** */
static BOOL FDoFilesDiffer ( LPTSTR szFile1, LPTSTR szFile2 )
{
	Assert(!FEmptySz(szFile1));
	Assert(FFileExist(szFile1)); // NOTE: true but expensive test
	Assert(!FEmptySz(szFile2));
	Assert(FFileExist(szFile2)); // NOTE: true but expensive test

	static BOOL bLastRet = FALSE;

	if (g_bPatchCacheEnabled) //using fastest possible code?  if so, do checks below
		{
		if (0 == _tcsicmp(szFile1, g_szLastFile1) && 0 == _tcsicmp(szFile2, g_szLastFile2))
			{
			// same files just looked at...
			return bLastRet;
			}
		}

   DWORD dw1Hi, dw1Low, dw2Hi, dw2Low;
	GetFileVersion(szFile1, &dw1Hi, &dw1Low);
	GetFileVersion(szFile2, &dw2Hi, &dw2Low);

	if (dw1Hi > dw2Hi || (dw1Hi == dw2Hi && dw1Low > dw2Low))
		return (fTrue);

	TCHAR rgchVer1[64], rgchVer2[64];
	wsprintf(rgchVer1, TEXT("%u.%u.%u.%u"), HIWORD(dw1Hi), LOWORD(dw1Hi), HIWORD(dw1Low), LOWORD(dw1Low));
	Assert(lstrlen(rgchVer1) < 64);
	wsprintf(rgchVer2, TEXT("%u.%u.%u.%u"), HIWORD(dw2Hi), LOWORD(dw2Hi), HIWORD(dw2Low), LOWORD(dw2Low));
	Assert(lstrlen(rgchVer2) < 64);

	if (dw1Hi < dw2Hi || dw1Low < dw2Low)
		{
		EvalAssert( FSprintfToLog(TEXT("WARNING (13): File versions are reversed.  Upgraded: '%s' ver=%s;  Target: '%s' ver=%s."), szFile1, rgchVer1, szFile2, rgchVer2) );
		return (fTrue);
		}

	Assert(dw1Hi  == dw2Hi);
	Assert(dw1Low == dw2Low);
	BOOL fNonZeroVersions = (dw1Hi != 0L || dw1Low != 0L);

	HANDLE hf1 = CreateFile(szFile1, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	Assert(hf1 != INVALID_HANDLE_VALUE);

	HANDLE hf2 = CreateFile(szFile2, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	Assert(hf2 != INVALID_HANDLE_VALUE);

	dw1Low = GetFileSize(hf1, &dw1Hi);
	Assert(dw1Low != 0xffffffff || GetLastError() == NO_ERROR);

	dw2Low = GetFileSize(hf2, &dw2Hi);
	Assert(dw2Low != 0xffffffff || GetLastError() == NO_ERROR);

	BOOL fRet = fFalse;
	if (dw1Low != dw2Low || dw1Hi != dw2Hi)
		fRet = fTrue;
	else
		{
		BOOL fDone = fFalse;
		while (!fDone)
			{
			BYTE rgb1[READ_SIZE], rgb2[READ_SIZE];

			EvalAssert( ReadFile(hf1, (LPVOID)rgb1, READ_SIZE, &dw1Low, NULL) );
			EvalAssert( ReadFile(hf2, (LPVOID)rgb2, READ_SIZE, &dw2Low, NULL) );
			if (dw1Low != dw2Low)
				fDone = fRet = fTrue;
			else if (dw1Low == 0)
				fDone = fTrue;
			else
				{
				while (dw1Low > 0 && !fDone)
					{
					dw1Low--;
					if (rgb1[dw1Low] != rgb2[dw1Low])
						fDone = fRet = fTrue;
					}
				}
			}
		}

	CloseHandle(hf1);
	CloseHandle(hf2);

	if (fRet && fNonZeroVersions)
		{
		EvalAssert( FSprintfToLog(TEXT("WARNING (14): File versions are equal.  Upgraded: '%s' ver=%s;  Target: '%s' ver=%s."), szFile1, rgchVer1, szFile2, rgchVer2) );
		}

	if (g_bPatchCacheEnabled) //if using cache, save state for this compare for later...
		{
		bLastRet = fRet;
		_tcscpy(g_szLastFile1, szFile1);
		_tcscpy(g_szLastFile2, szFile2);
		}

	return (fRet);
}


/* ********************************************************************** */
void GetFileVersion ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow )
{
	Assert(!FEmptySz(szFile));
	Assert(FFileExist(szFile)); // NOTE: true but expensive test
	Assert(pdwHi != NULL);
	Assert(pdwLow != NULL);

	*pdwHi = *pdwLow = 0L;

	BYTE *rgbBuf;
	DWORD dwSize;
	DWORD dwDummy;

	dwSize = GetFileVersionInfoSize(szFile,&dwDummy);

	if (dwSize == 0 || (rgbBuf = (BYTE *)malloc(dwSize)) == NULL)
		return;

	if (GetFileVersionInfo(szFile, 0L, dwSize, (LPVOID)rgbBuf))
		{
		VS_FIXEDFILEINFO* pffi = NULL;
		UINT cchRet = 0;
		if (VerQueryValue((LPVOID)rgbBuf, TEXT("\\"), (LPVOID*)(&pffi), &cchRet))
			{
			Assert(pffi != NULL);
			Assert(cchRet * sizeof(TCHAR) == sizeof(VS_FIXEDFILEINFO));
			*pdwHi  = pffi->dwFileVersionMS;
			*pdwLow = pffi->dwFileVersionLS;
			}
		}
	free(rgbBuf);
}


static UINT IdsIsFeatureInImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FComponentInImage ( MSIHANDLE hdb, LPTSTR szComp )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szComp));

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Feature`.`Feature` = `FeatureComponents`.`Feature_` AND `FeatureComponents`.`Component_` = '%s'"), szComp);
	UINT ids = IdsMsiEnumTable(hdb, TEXT("`Feature`,`FeatureComponents`"),
					TEXT("`Feature`.`Feature`,`Feature`.`Feature_Parent`,`Feature`.`Level`"),
					rgchWhere, IdsIsFeatureInImage, (LPARAM)hdb, 0L);

	Assert(ids == IDS_OKAY             // component NOT in image
			|| ids == IDS_CANCEL);     // component IS  in image

	return (ids == IDS_CANCEL);
}


/* ********************************************************************** */
static UINT IdsIsFeatureInImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	MSIHANDLE hdb = (MSIHANDLE)lp1;
	Assert(hdb != NULL);

	int iLevel = MsiRecordGetInteger(hrec, 3);
	if (iLevel <= 0 || iLevel == MSI_NULL_INTEGER)
		return (IDS_OKAY);  // is NOT in image

	TCHAR rgchFeature[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFeature, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFeature));

	TCHAR rgchParent[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 2, rgchParent, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);

	if (FEmptySz(rgchParent) || !lstrcmp(rgchFeature, rgchParent))
		return (IDS_CANCEL);  // root feature IS in image

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Feature` = '%s'"), rgchParent);
	uiRet = IdsMsiEnumTable(hdb, TEXT("`Feature`"),
					TEXT("`Feature`,`Feature_Parent`,`Level`"),
					rgchWhere, IdsIsFeatureInImage, lp1, 0L);

	Assert(uiRet == IDS_OKAY             // component NOT in image
			|| uiRet == IDS_CANCEL);     // component IS  in image

	return (uiRet);
}



static void   LogAndIgnoreRetainRangeMismatches ( ULONG ulTargets, LPTSTR szFamily, LPTSTR szFTK );
static LPCSTR SzaGetUpgradedSymPaths ( LPTSTR szFTK );
static UINT   IdsFillG_pofi ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT   IdsFillG_pofiForExtFile ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static BOOL   FCatSymPath   ( MSIHANDLE hdb, LPTSTR szImage, LPTSTR szFTK, LPTSTR szBuf, UINT cch, BOOL fTarget );

static ULONG UlGetApiPatchFlags ( MSIHANDLE hdbInput, BOOL fOption );
#define UlGetApiPatchOptionFlags(hdb)  UlGetApiPatchFlags(hdb,fTrue)
#define UlGetApiPatchSymbolFlags(hdb)  UlGetApiPatchFlags(hdb,fFalse)

/* ********************************************************************** */
UINT UiGenerateOnePatchFile ( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szFTK));
	Assert(!FEmptySz(szSrcPath));
	Assert(FFileExist(szSrcPath)); // NOTE: true but expensive
	Assert(iFileSeqNum > 1);
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	Assert(szTempFName > szTempFolder);

	Assert(g_ppofi != NULL);
	Assert(g_pszaSymPaths != NULL);
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);

	g_hdbInput = hdbInput;

	wsprintf(szTempFName, TEXT("%05i.PAT"), iFileSeqNum);
	Assert(!FFileExist(szTempFolder));
		
	Assert(iOrderMax > 0);
	ULONG ulTargets = 0;
	int   iOrderCur = 0;
	for (; iOrderCur < iOrderMax; iOrderCur++)
		{
		TCHAR rgchWhere[MAX_PATH];
		wsprintf(rgchWhere, TEXT("`Attributes` = 1 AND `Order` = %i"), iOrderCur);

		UINT ids = IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
						TEXT("`Target`,`MsiPath`,`LFN`"),
						rgchWhere, IdsFillG_pofi,
						(LPARAM)(&ulTargets), (LPARAM)szFTK);
		if (ids != IDS_OKAY)
			return (ids);

		wsprintf(rgchWhere, TEXT("`Order` = %i AND `Family` = '%s' AND `FTK` = '%s'"), iOrderCur, g_szFamily, szFTK);
		ids = IdsMsiEnumTable(hdbInput, TEXT("`ExternalFiles`"),
						TEXT("`FilePath`,`SymbolPaths`,`IgnoreCount`,`IgnoreOffsets`,`IgnoreLengths`,`RetainOffsets`"),
						rgchWhere, IdsFillG_pofiForExtFile,
						(LPARAM)(&ulTargets), (LPARAM)szFTK);
		if (ids != IDS_OKAY)
			return (ids);
		}

	LogAndIgnoreRetainRangeMismatches(ulTargets, g_szFamily, szFTK);

	Assert(ulTargets > 0);
	Assert(ulTargets < 256);
	Assert(ulTargets <= g_cpofiMax);

	PATCH_OPTION_DATA pod;
	pod.SizeOfThisStruct       = sizeof(PATCH_OPTION_DATA);
	pod.SymbolOptionFlags      = UlGetApiPatchSymbolFlags(hdbInput);
	pod.NewFileSymbolPath      = SzaGetUpgradedSymPaths(szFTK);
	pod.OldFileSymbolPathArray = (LPCSTR*)g_pszaSymPaths;
	pod.ExtendedOptionFlags    = 0;    // TODO - what is allowable here?
	pod.SymLoadCallback        = NULL;
	pod.SymLoadContext         = NULL;

	BOOL fRet = CreatePatchFileEx(ulTargets, g_ppofi, szSrcPath, szTempFolder,
					UlGetApiPatchOptionFlags(hdbInput), &pod, NULL, NULL);

	while (ulTargets-- > 0)
		{
#ifdef UNICODE
		PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[ulTargets]);
#else
		PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[ulTargets]);
#endif
		Assert(!FEmptySz(ppofi->OldFileName));
		LocalFree((HLOCAL)(ppofi->OldFileName));
		ppofi->OldFileName = szNull;

		LPSTR* psza = &(g_pszaSymPaths[ulTargets]);
		if (*psza != NULL)
			{
			LocalFree((HLOCAL)(*psza));
			*psza = NULL;
			}

		if (ppofi->IgnoreRangeCount > 0)
			{
			Assert(ppofi->IgnoreRangeArray != NULL);
			LocalFree((HLOCAL)(ppofi->IgnoreRangeArray));

			ppofi->IgnoreRangeCount = 0;
			ppofi->IgnoreRangeArray = NULL;
			}

		if (ppofi->RetainRangeCount > 0)
			{
			Assert(ppofi->RetainRangeArray != NULL);
			LocalFree((HLOCAL)(ppofi->RetainRangeArray));

			ppofi->RetainRangeCount = 0;
			ppofi->RetainRangeArray = NULL;
			}
		}

	if (pod.NewFileSymbolPath != NULL)
		{
		LocalFree((HLOCAL)(pod.NewFileSymbolPath));
		pod.NewFileSymbolPath = NULL;
		}

	if (!fRet)
		{
		DWORD dwError = GetLastError();
		Assert(dwError == ERROR_PATCH_ENCODE_FAILURE
					|| dwError == ERROR_PATCH_BIGGER_THAN_COMPRESSED
					|| dwError == ERROR_EXTENDED_ERROR); // Retain/Ignore Range problems
		Assert(dwError != ERROR_PATCH_INVALID_OPTIONS);
		Assert(dwError != ERROR_PATCH_SAME_FILE);
		Assert(dwError != ERROR_PATCH_RETAIN_RANGES_DIFFER);
		Assert(dwError != ERROR_PATCH_IMAGEHLP_FAILURE);

		if (dwError == ERROR_PATCH_BIGGER_THAN_COMPRESSED)
			return (IDS_OKAY);

		return (UiLogError(ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE, szSrcPath, szTempFolder));
		}


	Assert(lstrlen(szTempFolder) < MAX_PATH);
	TCHAR rgchPatchFile[MAX_PATH];
	lstrcpy(rgchPatchFile, szTempFolder);

	wsprintf(szTempFName, TEXT("%05i.HDR"), iFileSeqNum);
	Assert(!FFileExist(szTempFolder));

	Assert(FFileExist(rgchPatchFile));
	EvalAssert( ExtractPatchHeaderToFile(rgchPatchFile, szTempFolder) );
	Assert(FFileExist(szTempFolder));

	return (IDS_OKAY);
}


/* ********************************************************************** */
static void LogAndIgnoreRetainRangeMismatches ( ULONG ulTargets, LPTSTR szFamily, LPTSTR szFTK )
{
	Assert(ulTargets > 0);
	Assert(ulTargets < 256);
	Assert(ulTargets <= g_cpofiMax);
	Assert(!FEmptySz(szFamily));
	Assert(!FEmptySz(szFTK));

	ULONG ulSav = ulTargets;
	ULONG RetainRangeCountFirst = (g_ppofi[0]).RetainRangeCount;

	while (ulTargets-- > 0)
		{
#ifdef UNICODE
		PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[ulTargets]);
#else
		PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[ulTargets]);
#endif

		if (ppofi->RetainRangeCount != RetainRangeCountFirst)
			{
			EvalAssert( FSprintfToLog(TEXT("  Mismatch in RetainRangeCounts - ignoring them: Family=%s; FTK=%s."), szFamily, szFTK, szEmpty, szEmpty) );
			while (ulSav-- > 0)
				{
				ppofi = &(g_ppofi[ulSav]);

				if (ppofi->RetainRangeCount > 0)
					{
					Assert(ppofi->RetainRangeArray != NULL);
					LocalFree((HLOCAL)(ppofi->RetainRangeArray));

					ppofi->RetainRangeCount = 0;
					ppofi->RetainRangeArray = NULL;
					}
				}
			return;
			}
		}
}


static UINT IdsFillSymPaths ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static LPCSTR SzaGetUpgradedSymPaths ( LPTSTR szFTK )
{
	Assert(!FEmptySz(szFTK));

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szFamily));

	TCHAR rgchSymPaths[MAX_PATH*10];
	*rgchSymPaths = TEXT('\0');

	TCHAR rgchWhere[64];
	wsprintf(rgchWhere, TEXT("`Family` = '%s'"), g_szFamily);
	UINT ids = IdsMsiEnumTable(g_hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), rgchWhere, IdsFillSymPaths,
					(LPARAM)rgchSymPaths, (LPARAM)szFTK);
	Assert(ids == IDS_OKAY);

	LPCSTR szaRet = NULL;
	if (!FEmptySz(rgchSymPaths))
		{
		szaRet = SzaDupSz(rgchSymPaths);
		Assert(szaRet != NULL);
		Assert(*szaRet != '\0');
		}

	return (szaRet);
}


/* ********************************************************************** */
static UINT IdsFillSymPaths ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	LPTSTR szSymPaths = (LPTSTR)(lp1);
	Assert(szSymPaths != szNull);

	LPTSTR szFTK = (LPTSTR)lp2;
	Assert(!FEmptySz(szFTK));

	Assert(g_hdbInput != NULL);

	TCHAR rgchTarget[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTarget));

	EvalAssert( FCatSymPath(g_hdbInput, rgchTarget, szFTK, szSymPaths, MAX_PATH*10, fFalse) );

	return (IDS_OKAY);
}


static UINT IdsResolveSrcFilePathFtk ( MSIHANDLE hdb, LPTSTR szBuf, LPTSTR szFtk, BOOL fLfn, LPTSTR szFullSubFolder );

#ifdef UNICODE
static void FillIgnoreRangeArray ( PATCH_OLD_FILE_INFO_W* ppofi, int cRanges, LPTSTR szOffsets, LPTSTR szLengths );
static void FillRetainRangeArray ( PATCH_OLD_FILE_INFO_W* ppofi, int cRanges, LPTSTR szOldOffsets, LPTSTR szNewOffsets, LPTSTR szLengths );
#else
static void FillIgnoreRangeArray ( PATCH_OLD_FILE_INFO_A* ppofi, int cRanges, LPTSTR szOffsets, LPTSTR szLengths );
static void FillRetainRangeArray ( PATCH_OLD_FILE_INFO_A* ppofi, int cRanges, LPTSTR szOldOffsets, LPTSTR szNewOffsets, LPTSTR szLengths );
#endif

/* ********************************************************************** */
static UINT IdsFillG_pofi ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	ULONG* pulTargets = (ULONG*)(lp1);
	Assert(pulTargets != NULL);
	Assert(*pulTargets >= 0);

	LPTSTR szFTK = (LPTSTR)lp2;
	Assert(!FEmptySz(szFTK));

	Assert(g_ppofi != NULL);
	Assert(g_pszaSymPaths != NULL);
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);
	Assert(*pulTargets < g_cpofiMax);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szFamily));

	TCHAR rgchSrcRoot[MAX_PATH+MAX_PATH];
	DWORD dwcch = MAX_PATH+MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgchSrcRoot, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchSrcRoot));
	Assert(FFileExist(rgchSrcRoot));

	TCHAR rgchLFN[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 3, rgchLFN, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchLFN));
	Assert(!lstrcmp(rgchLFN, TEXT("Yes")) || !lstrcmp(rgchLFN, TEXT("No")));
	BOOL fLfn = (*rgchLFN == TEXT('Y'));

#define rgchTargetImage rgchLFN // reuse buffer
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 1, rgchTargetImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTargetImage));

	MSIHANDLE hdbTargetImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fFalse);
	Assert(hdbTargetImage != NULL);
#undef rgchTargetImage

	uiRet = IdsResolveSrcFilePathFtk(hdbTargetImage,
				SzFindFilenameInPath(rgchSrcRoot), szFTK, fLfn, szNull);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(SzFindFilenameInPath(rgchSrcRoot)));
	Assert(FFileExist(rgchSrcRoot));

	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbTargetImage) );

#ifdef UNICODE
	PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[*pulTargets]);
	Assert(ppofi != NULL);
	Assert(ppofi->SizeOfThisStruct == sizeof(PATCH_OLD_FILE_INFO_W));
#else
	PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[*pulTargets]);
	Assert(ppofi != NULL);
	Assert(ppofi->SizeOfThisStruct == sizeof(PATCH_OLD_FILE_INFO_A));
#endif
	Assert(ppofi->OldFileName == szNull);
	Assert(ppofi->IgnoreRangeCount == 0);
	Assert(ppofi->IgnoreRangeArray == NULL);
	Assert(ppofi->RetainRangeCount == 0);
	Assert(ppofi->RetainRangeArray == NULL);

	ppofi->OldFileName = SzDupSz(rgchSrcRoot);
	Assert(!FEmptySz(ppofi->OldFileName));

	TCHAR rgchTarget[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTarget));

#define rgchSymPaths  rgchSrcRoot // reuse buffer
	*rgchSymPaths = TEXT('\0');
	EvalAssert( FCatSymPath(g_hdbInput, rgchTarget, szFTK, rgchSymPaths, MAX_PATH+MAX_PATH, fTrue) );

	if (!FEmptySz(rgchSymPaths))
		{
		LPSTR* psza = &(g_pszaSymPaths[*pulTargets]);
		*psza = SzaDupSz(rgchSymPaths);
		Assert(*psza != NULL);
		Assert(**psza != '\0');
		}
#undef rgchSymPaths

	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("`Target`='%s' AND `FTK`='%s'"), rgchTarget, szFTK);

	int cIgnoreRanges;
	uiRet = IdsMsiGetTableIntegerWhere(g_hdbInput, TEXT("`TargetFiles_OptionalData`"),
				TEXT("`IgnoreCount`"), rgchWhere, &cIgnoreRanges);
	Assert(uiRet == MSI_OKAY);

#define rgchIgnoreOffsets  rgchSrcRoot // reuse buffer
	if (cIgnoreRanges > 0)
		{
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`TargetFiles_OptionalData`"),
					TEXT("`IgnoreOffsets`"), rgchWhere, rgchIgnoreOffsets, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchIgnoreOffsets));

		TCHAR rgchIgnoreLengths[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`TargetFiles_OptionalData`"),
					TEXT("`IgnoreLengths`"), rgchWhere, rgchIgnoreLengths, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchIgnoreLengths));

		FillIgnoreRangeArray(ppofi, cIgnoreRanges, rgchIgnoreOffsets, rgchIgnoreLengths);

		Assert(ppofi->IgnoreRangeCount == (ULONG)cIgnoreRanges);
		Assert(ppofi->IgnoreRangeArray != NULL);
		}
#undef rgchIgnoreOffsets

#define rgchRetainOldOffsets  rgchSrcRoot // reuse buffer
	uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`TargetFiles_OptionalData`"),
				TEXT("`RetainOffsets`"), rgchWhere, rgchRetainOldOffsets, MAX_PATH);
	Assert(uiRet == MSI_OKAY);
	if (!FEmptySz(rgchRetainOldOffsets))
		{
		wsprintf(rgchWhere, TEXT("`Family`='%s' AND `FTK`='%s'"), g_szFamily, szFTK);
		
		int cRetainRanges;
		uiRet = IdsMsiGetTableIntegerWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainCount`"), rgchWhere, &cRetainRanges);
		Assert(uiRet == MSI_OKAY);
		Assert(cRetainRanges > 0);

		TCHAR rgchRetainNewOffsets[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainOffsets`"), rgchWhere, rgchRetainNewOffsets, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchRetainNewOffsets));

		TCHAR rgchRetainLengths[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainLengths`"), rgchWhere, rgchRetainLengths, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchRetainLengths));

		FillRetainRangeArray(ppofi, cRetainRanges, rgchRetainOldOffsets, rgchRetainNewOffsets, rgchRetainLengths);

		Assert(ppofi->RetainRangeCount == (ULONG)cRetainRanges);
		Assert(ppofi->RetainRangeArray != NULL);
		}
#undef rgchRetainOldOffsets

	(*pulTargets)++;

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsFillG_pofiForExtFile ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	ULONG* pulTargets = (ULONG*)(lp1);
	Assert(pulTargets != NULL);
	Assert(*pulTargets >= 0);

	LPTSTR szFTK = (LPTSTR)(lp2);
	Assert(!FEmptySz(szFTK));

	Assert(g_ppofi != NULL);
	Assert(g_pszaSymPaths != NULL);
	Assert(g_cpofiMax > 0);
	Assert(g_cpofiMax < 256);
	Assert(*pulTargets < g_cpofiMax);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szFamily));

	TCHAR rgchSrcRoot[MAX_PATH+MAX_PATH];
	DWORD dwcch = MAX_PATH+MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchSrcRoot, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchSrcRoot));
	Assert(FFileExist(rgchSrcRoot));

#ifdef UNICODE
	PATCH_OLD_FILE_INFO_W* ppofi = &(g_ppofi[*pulTargets]);
	Assert(ppofi != NULL);
	Assert(ppofi->SizeOfThisStruct == sizeof(PATCH_OLD_FILE_INFO_W));
#else
	PATCH_OLD_FILE_INFO_A* ppofi = &(g_ppofi[*pulTargets]);
	Assert(ppofi != NULL);
	Assert(ppofi->SizeOfThisStruct == sizeof(PATCH_OLD_FILE_INFO_A));
#endif
	Assert(ppofi->OldFileName == szNull);
	Assert(ppofi->IgnoreRangeCount == 0);
	Assert(ppofi->IgnoreRangeArray == NULL);
	Assert(ppofi->RetainRangeCount == 0);
	Assert(ppofi->RetainRangeArray == NULL);

	ppofi->OldFileName = SzDupSz(rgchSrcRoot);
	Assert(!FEmptySz(ppofi->OldFileName));

#define rgchSymPaths  rgchSrcRoot // reuse buffer
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchSymPaths, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);

	if (!FEmptySz(rgchSymPaths))
		{
		LPSTR* psza = &(g_pszaSymPaths[*pulTargets]);
		*psza = SzaDupSz(rgchSymPaths);
		Assert(*psza != NULL);
		Assert(**psza != '\0');
		}
#undef rgchSymPaths

#define rgchIgnoreOffsets  rgchSrcRoot // reuse buffer
	int cIgnoreRanges = MsiRecordGetInteger(hrec, 3);
	if (cIgnoreRanges > 0)
		{
		dwcch = MAX_PATH+MAX_PATH;
		uiRet = MsiRecordGetString(hrec, 4, rgchIgnoreOffsets, &dwcch);
		Assert(uiRet != ERROR_MORE_DATA);
		Assert(uiRet == IDS_OKAY);
		Assert(!FEmptySz(rgchIgnoreOffsets));

		TCHAR rgchIgnoreLengths[MAX_PATH];
		dwcch = MAX_PATH;
		uiRet = MsiRecordGetString(hrec, 5, rgchIgnoreLengths, &dwcch);
		Assert(uiRet != ERROR_MORE_DATA);
		Assert(uiRet == IDS_OKAY);
		Assert(!FEmptySz(rgchIgnoreLengths));

		FillIgnoreRangeArray(ppofi, cIgnoreRanges, rgchIgnoreOffsets, rgchIgnoreLengths);

		Assert(ppofi->IgnoreRangeCount == (ULONG)cIgnoreRanges);
		Assert(ppofi->IgnoreRangeArray != NULL);
		}
#undef rgchIgnoreOffsets

#define rgchRetainOldOffsets  rgchSrcRoot // reuse buffer
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 6, rgchRetainOldOffsets, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	if (!FEmptySz(rgchRetainOldOffsets))
		{
		TCHAR rgchWhere[MAX_PATH];
		wsprintf(rgchWhere, TEXT("`Family`='%s' AND `FTK`='%s'"), g_szFamily, szFTK);
		
		int cRetainRanges;
		uiRet = IdsMsiGetTableIntegerWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainCount`"), rgchWhere, &cRetainRanges);
		Assert(uiRet == MSI_OKAY);
		Assert(cRetainRanges > 0);

		TCHAR rgchRetainNewOffsets[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainOffsets`"), rgchWhere, rgchRetainNewOffsets, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchRetainNewOffsets));

		TCHAR rgchRetainLengths[MAX_PATH];
		uiRet = IdsMsiGetTableStringWhere(g_hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainLengths`"), rgchWhere, rgchRetainLengths, MAX_PATH);
		Assert(uiRet == MSI_OKAY);
		Assert(!FEmptySz(rgchRetainLengths));

		FillRetainRangeArray(ppofi, cRetainRanges, rgchRetainOldOffsets, rgchRetainNewOffsets, rgchRetainLengths);

		Assert(ppofi->RetainRangeCount == (ULONG)cRetainRanges);
		Assert(ppofi->RetainRangeArray != NULL);
		}
#undef rgchRetainOldOffsets

	(*pulTargets)++;

	return (IDS_OKAY);
}


/* ********************************************************************** */
#ifdef UNICODE
static void FillIgnoreRangeArray ( PATCH_OLD_FILE_INFO_W* ppofi, int cRanges, LPTSTR szOffsets, LPTSTR szLengths )
#else
static void FillIgnoreRangeArray ( PATCH_OLD_FILE_INFO_A* ppofi, int cRanges, LPTSTR szOffsets, LPTSTR szLengths )
#endif
{
	Assert(ppofi != NULL);
	Assert(cRanges > 0);
	Assert(cRanges < 256);
	Assert(!FEmptySz(szOffsets));
	Assert(!FEmptySz(szLengths));

	Assert(ppofi->IgnoreRangeCount == 0);
	Assert(ppofi->IgnoreRangeArray == NULL);

	ppofi->IgnoreRangeArray = (_PATCH_IGNORE_RANGE*)LocalAlloc(LPTR, sizeof(_PATCH_IGNORE_RANGE)*cRanges);
	Assert(ppofi->IgnoreRangeArray != NULL);
	ppofi->IgnoreRangeCount = cRanges;

	_PATCH_IGNORE_RANGE* ppir = ppofi->IgnoreRangeArray;
	for (int i = 0; i < cRanges; i++, ppir++)
		{
		Assert(!FEmptySz(szOffsets));
		ULONG ulOffset = UlGetRangeElement(&szOffsets);
		Assert(ulOffset != (ULONG)(-1));

		Assert(!FEmptySz(szLengths));
		ULONG ulLength = UlGetRangeElement(&szLengths);
		Assert(ulLength != (ULONG)(-1));
		Assert(ulLength > 0);

		ppir->OffsetInOldFile = ulOffset;
		ppir->LengthInBytes   = ulLength;
		}
}


/* ********************************************************************** */
#ifdef UNICODE
static void FillRetainRangeArray ( PATCH_OLD_FILE_INFO_W* ppofi, int cRanges, LPTSTR szOldOffsets, LPTSTR szNewOffsets, LPTSTR szLengths )
#else
static void FillRetainRangeArray ( PATCH_OLD_FILE_INFO_A* ppofi, int cRanges, LPTSTR szOldOffsets, LPTSTR szNewOffsets, LPTSTR szLengths )
#endif
{
	Assert(ppofi != NULL);
	Assert(cRanges > 0);
	Assert(cRanges < 256);
	Assert(!FEmptySz(szOldOffsets));
	Assert(!FEmptySz(szNewOffsets));
	Assert(!FEmptySz(szLengths));

	Assert(ppofi->RetainRangeCount == 0);
	Assert(ppofi->RetainRangeArray == NULL);

	ppofi->RetainRangeArray = (_PATCH_RETAIN_RANGE*)LocalAlloc(LPTR, sizeof(_PATCH_RETAIN_RANGE)*cRanges);
	Assert(ppofi->RetainRangeArray != NULL);
	ppofi->RetainRangeCount = cRanges;

	_PATCH_RETAIN_RANGE* ppir = ppofi->RetainRangeArray;
	for (int i = 0; i < cRanges; i++, ppir++)
		{
		Assert(!FEmptySz(szOldOffsets));
		ULONG ulOldOffset = UlGetRangeElement(&szOldOffsets);
		Assert(ulOldOffset != (ULONG)(-1));

		Assert(!FEmptySz(szNewOffsets));
		ULONG ulNewOffset = UlGetRangeElement(&szNewOffsets);
		Assert(ulNewOffset != (ULONG)(-1));

		Assert(!FEmptySz(szLengths));
		ULONG ulLength = UlGetRangeElement(&szLengths);
		Assert(ulLength != (ULONG)(-1));
		Assert(ulLength > 0);

		ppir->OffsetInOldFile = ulOldOffset;
		ppir->OffsetInNewFile = ulNewOffset;
		ppir->LengthInBytes   = ulLength;
		}
}


/* ********************************************************************** */
static BOOL FCatSymPath ( MSIHANDLE hdb, LPTSTR szImage, LPTSTR szFTK, LPTSTR szBuf, UINT cch, BOOL fTarget )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szImage));
	Assert(!FEmptySz(szFTK));
	Assert(szBuf != szNull);
	Assert(cch >= MAX_PATH);

	LPTSTR szTail = szBuf;
	if (!FEmptySz(szBuf))
		{
		Assert(!fTarget);
		lstrcat(szBuf, TEXT(";"));
		szTail += lstrlen(szBuf);
		cch -= lstrlen(szBuf);
		Assert(cch >= 64);
		}

	TCHAR rgchWhere[128];
	wsprintf(rgchWhere, TEXT("`%s` = '%s' AND `FTK` = '%s'"), (fTarget) ? TEXT("Target") : TEXT("Upgraded"), szImage, szFTK);
	EvalAssert( IDS_OKAY == IdsMsiGetTableStringWhere(hdb, (fTarget) ? TEXT("`TargetFiles_OptionalData`") : TEXT("`UpgradedFiles_OptionalData`"),
					TEXT("`SymbolPaths`"), rgchWhere, szTail, cch) );

	if (!FEmptySz(szTail))
		{
		lstrcat(szTail, TEXT(";"));
		cch -= lstrlen(szTail);
		Assert(cch >= 64);
		szTail += lstrlen(szTail);
		}
	wsprintf(rgchWhere, TEXT("`%s` = '%s'"), (fTarget) ? TEXT("Target") : TEXT("Upgraded"), szImage);
	EvalAssert( IDS_OKAY == IdsMsiGetTableStringWhere(hdb, (fTarget) ? TEXT("`TargetImages`") : TEXT("`UpgradedImages`"),
					TEXT("`SymbolPaths`"), rgchWhere, szTail, cch) );

	if (!FEmptySz(szBuf) && *(szTail = SzLastChar(szBuf)) == TEXT(';'))
		*szTail = TEXT('\0');

	return (fTrue);
}


/* ********************************************************************** */
static UINT IdsResolveSrcFilePathFtk ( MSIHANDLE hdb, LPTSTR szBuf, LPTSTR szFtk, BOOL fLfn, LPTSTR szFullSubFolder )
{
	Assert(hdb != NULL);
	Assert(szBuf != szNull);
	Assert(!FEmptySz(szFtk));

	TCHAR rgchComponent[MAX_PATH];
	UINT  uiRet = IdsMsiGetTableString(hdb, TEXT("`File`"), TEXT("`File`"),
					TEXT("`Component_`"), szFtk, rgchComponent, MAX_PATH);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchComponent));

	TCHAR rgchFName[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdb, TEXT("`File`"), TEXT("`File`"),
					TEXT("`FileName`"), szFtk, rgchFName, MAX_PATH);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFName));

	uiRet = IdsResolveSrcFilePathSzs(hdb, szBuf, rgchComponent,
						rgchFName, fLfn, szFullSubFolder);
	Assert(uiRet == IDS_OKAY);

	return (uiRet);
}


/* ********************************************************************** */
static void GetFileSizeSz ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow )
{
	Assert(!FEmptySz(szFile));
	Assert(FFileExist(szFile));
	Assert(pdwHi  != NULL);
	Assert(pdwLow != NULL);

	HANDLE hf = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	Assert(hf != INVALID_HANDLE_VALUE);

	DWORD dwHi = 0L, dwLow = 0L;
	dwLow = GetFileSize(hf, &dwHi);
	Assert(dwLow != 0xffffffff || GetLastError() == NO_ERROR);
	CloseHandle(hf);

	*pdwHi  += dwHi;
	*pdwLow += dwLow;
}


/* ********************************************************************** */
static UINT IdsUpdateMsiForNewSeqNum ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec != NULL);

	LPTSTR szFTK = (LPTSTR)(lp1);
	Assert(!FEmptySz(szFTK));

	int iSeqNumNew = (int)(lp2);
	Assert(iSeqNumNew > 1);
	Assert(iSeqNumNew < 32767);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szFamily));

	TCHAR rgchTargetImage[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTargetImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTargetImage));

	MSIHANDLE hdbCopyOfUpgradedImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fTrue);
	Assert(hdbCopyOfUpgradedImage != NULL);

	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

#ifdef DEBUG
	wsprintf(g_szTempFName, TEXT("%s\\%05i.PAT"), g_szFamily, iSeqNumNew);
	BOOL fPatExist = FFileExist(g_szTempFolder);
	wsprintf(g_szTempFName, TEXT("%s\\%05i.HDR"), g_szFamily, iSeqNumNew);
	BOOL fHdrExist = FFileExist(g_szTempFolder);
	wsprintf(g_szTempFName, TEXT("%s\\%05i.FLE"), g_szFamily, iSeqNumNew);
	BOOL fFleExist = FFileExist(g_szTempFolder);

	Assert(fPatExist == fHdrExist);
	Assert(fPatExist || fFleExist);
	Assert(!fPatExist || !fFleExist);
#endif /* DEBUG */

	wsprintf(g_szTempFName, TEXT("%s\\%05i.PAT"), g_szFamily, iSeqNumNew);
	if (FFileExist(g_szTempFolder))
		{
		DWORD dwHi = 0L, dwLow = 0L;
		GetFileSizeSz(g_szTempFolder, &dwHi, &dwLow);
		Assert(dwHi == 0L);
		Assert(dwLow <= 2147483647L);

		int iPatchSize = (int)dwLow;
		Assert((DWORD)(iPatchSize) == dwLow);

#define rgchUpgradedImage rgchTargetImage  // reuse buffer
		dwcch = 64;
		uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
		Assert(uiRet != ERROR_MORE_DATA);
		Assert(uiRet == IDS_OKAY);
		Assert(!FEmptySz(rgchUpgradedImage));

		TCHAR rgchWhere[MAX_PATH];
		wsprintf(rgchWhere, TEXT("`Upgraded` = '%s' AND `FTK` = '%s'"),
					rgchUpgradedImage, szFTK);
#undef rgchUpgradedImage
		
		int iAttributes;
		EvalAssert( IDS_OKAY == IdsMsiGetTableIntegerWhere(g_hdbInput,
						TEXT("`UpgradedFiles_OptionalData`"),
						TEXT("`AllowIgnoreOnPatchError`"), rgchWhere, &iAttributes) );
		if (iAttributes != 0)
			iAttributes = 1;

		wsprintf(g_szTempFName, TEXT("%s\\%05i.HDR"), g_szFamily, iSeqNumNew);
		Assert(FFileExist(g_szTempFolder));

		//
		// OLE has a stream name limitation of 31 characters (32 if you include '\0'). The Installer can support up to 62
		//  characters due to a special compression algorithm. But, the limit is easily reached when attempting to generate
		//  the stream name for the Patch.Header column as the stream name formula is:
		//			"{table}" + "." + "{primary key 1}" [+ "." + "{primary key 2}" + ...]"
		//
		// Packages built using merge modules more commonly see this problem due to the merge module naming convention for
		//  primary keys.  To guarantee uniqueness, the primary keys are generally very lengthy. In the case of the Patch
		//  table, the stream name is:
		//			"Patch" + "." + szFTK + "." + sequence
		//
		// To get around this limit, the MsiPatchHeaders table is used. The header is written to the MsiPatchHeaders table
		//  using a primary key that is an autogenerated Guid.  The total concatenation in this case comes well under the
		//  62 character limit. A link is made to the MsiPatchHeaders table via the Patch.StreamRef_ column.
		//
		// Since the MsiPatchHeaders table will only work with Windows Installer version 2.0 or later, the table is only
		//  used in those cases that warrant it.  In all other cases, backwards compatible patches will be created.
		//

		TCHAR szSeqNum[MAX_PATH] = {0};
		wsprintf(szSeqNum, TEXT("%d"), iSeqNumNew);
		int cchStreamName = lstrlen(TEXT("Patch")) + lstrlen(TEXT(".")) + lstrlen(szFTK) + lstrlen(TEXT(".")) + lstrlen(szSeqNum);
		if (cchStreamName > cchMaxStreamName)
			{
				//
				// must use MsiPatchHeaders table
				//

				if (!g_bUsedMsiPatchHeadersTable)
					{
						//
						// this is the first time we've encountered this, ask the user if s/he wants to continue; patch can only
						// work with Windows Installer version 2.0 or greater
						//

						int iMinimumMsiVersion = 100;
						EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(g_hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

						if (iMinMsiPatchHeadersVersion <= iMinimumMsiVersion)
							{
								FWriteLogFile(TEXT("  Patch header stream name limitation reached. Continuing creation since .PCP authored to require a minimum Windows Installer version that supports the new format -.\r\n"));
							}
						else if (IDNO == IMessageBoxIds(HdlgStatus(), IDS_STREAM_NAME_LIMIT_REACHED, MB_YESNO | MB_ICONQUESTION))
							{
								FWriteLogFile(TEXT("  Patch header stream name limitation reached. File table key was too long and user did not want to create a patch that requires Windows Installer version 2.0 or later - .\r\n"));
								return IDS_CANCEL;
							}
						else
							{
								FWriteLogFile(TEXT("  Patch header stream name limitation reached. User chose to bypass limit by creating a patch that requires Windows Installer version 2.0 or later.\r\n"));
							}
					}

				GUID guidKey;
				EvalAssert( S_OK == ::CoCreateGuid(&guidKey) );
				TCHAR szPHK[cchMaxGuid] = {0};
				wsprintf(szPHK, TEXT("_%08lX_%04X_%04x_%02X%02X_%02X%02X%02X%02X%02X%02X"), guidKey.Data1, guidKey.Data2, guidKey.Data3,
							guidKey.Data4[0], guidKey.Data4[1], guidKey.Data4[2], guidKey.Data4[3], guidKey.Data4[4], guidKey.Data4[5], guidKey.Data4[6], guidKey.Data4[7]);

				MSIHANDLE hrecPatch = MsiCreateRecord(6);
				Assert(hrecPatch != NULL);
				EvalAssert( MSI_OKAY == MsiRecordClearData(hrecPatch) );
				EvalAssert( MSI_OKAY == MsiRecordSetString( hrecPatch, 1, szFTK) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 2, iSeqNumNew) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 3, iPatchSize) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 4, iAttributes) );
				// field 5 is left NULL
				EvalAssert( MSI_OKAY == MsiRecordSetString( hrecPatch, 6, szPHK) );

				EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbCopyOfUpgradedImage, TEXT("`Patch`"),
								TEXT("`File_`,`Sequence`,`PatchSize`,`Attributes`,`Header`,`StreamRef_`"),
								TEXT("`File_`"), szFTK, hrecPatch) );

				MSIHANDLE hrecPatchHeader = MsiCreateRecord(2);
				Assert(hrecPatchHeader != NULL);
				EvalAssert( MSI_OKAY == MsiRecordSetString( hrecPatchHeader, 1, szPHK) );
				EvalAssert( MSI_OKAY == MsiRecordSetStream( hrecPatchHeader, 2, g_szTempFolder) );

				EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbCopyOfUpgradedImage, TEXT("`MsiPatchHeaders`"),
								TEXT("`StreamRef`,`Header`"),
								TEXT("`StreamRef`"), szPHK, hrecPatchHeader) );

				g_bUsedMsiPatchHeadersTable = TRUE;
			}
		else
			{
				//
				// normal Patch table should work
				//

				MSIHANDLE hrecPatch = MsiCreateRecord(6);
				Assert(hrecPatch != NULL);
				EvalAssert( MSI_OKAY == MsiRecordClearData(hrecPatch) );
				EvalAssert( MSI_OKAY == MsiRecordSetString( hrecPatch, 1, szFTK) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 2, iSeqNumNew) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 3, iPatchSize) );
				EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrecPatch, 4, iAttributes) );
				EvalAssert( MSI_OKAY == MsiRecordSetStream( hrecPatch, 5, g_szTempFolder) );
				// field 6 is left NULL

				EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbCopyOfUpgradedImage, TEXT("`Patch`"),
								TEXT("`File_`,`Sequence`,`PatchSize`,`Attributes`,`Header`,`StreamRef_`"),
								TEXT("`File_`"), szFTK, hrecPatch) );
			}
		}
	else
		{
		EvalAssert( IDS_OKAY == IdsMsiUpdateTableRecordInt(hdbCopyOfUpgradedImage,
						TEXT("File"), TEXT("Sequence"), iSeqNumNew,
						TEXT("File"), szFTK) );
		int iAttributes;
		EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdbCopyOfUpgradedImage,
						TEXT("`File`"), TEXT("`File`"),
						TEXT("`Attributes`"), szFTK, &iAttributes) );
		if (iAttributes == MSI_NULL_INTEGER)
			iAttributes = 0;
#define msidbFileAttributesPatchAdded      0x00001000
#define msidbFileAttributesNoncompressed   0x00002000
		iAttributes |= msidbFileAttributesPatchAdded;
		iAttributes &= ~msidbFileAttributesNoncompressed;
		EvalAssert( IDS_OKAY == IdsMsiUpdateTableRecordInt(hdbCopyOfUpgradedImage,
						TEXT("File"), TEXT("Attributes"), iAttributes,
						TEXT("File"), szFTK) );
		}

	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdbCopyOfUpgradedImage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbCopyOfUpgradedImage) );

	return (IDS_OKAY);
}


#define PATCH_OPTION_DEFAULT  (PATCH_OPTION_USE_LZX_BEST + PATCH_OPTION_FAIL_IF_BIGGER)
#define PATCH_OPTION_DEFAULT_LARGE (PATCH_OPTION_DEFAULT + PATCH_OPTION_USE_LZX_LARGE)
#define PATCH_SYMBOL_DEFAULT  0x00000000

/* ********************************************************************** */
static ULONG UlGetApiPatchFlags ( MSIHANDLE hdbInput, BOOL fOption )
{
	Assert(hdbInput != NULL);

	TCHAR rgch[64];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					(fOption) ? TEXT("OptimizePatchSizeForLargeFiles") : TEXT("ApiPatchingSymbolFlags"),
					rgch, 64) );

	if (FEmptySz(rgch) && fOption)
		return (PATCH_OPTION_DEFAULT);
	if (FEmptySz(rgch))
		return (PATCH_SYMBOL_DEFAULT);
	
	Assert(fOption || FValidHexValue(rgch));
	Assert(fOption || FValidApiPatchSymbolFlags(UlFromHexSz(rgch)));

	if (fOption)
		return (lstrcmp(rgch, TEXT("0")) == 0) ? PATCH_OPTION_DEFAULT : PATCH_OPTION_DEFAULT_LARGE;
	else	
		return (UlFromHexSz(rgch));
}




static UINT IdsGenerateTransformsForTargetImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT UiMakeTransforms ( LPTSTR szFamily, int iSequenceNumCur )
{
	Assert(!FEmptySz(szFamily));
	Assert(iSequenceNumCur > 0);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	g_iSeqNumCur = iSequenceNumCur;

	UINT ids = IdsMsiEnumTable(g_hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`ProductValidateFlags`"),
					szNull, IdsGenerateTransformsForTargetImage, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	return (ERROR_SUCCESS);
}


/* ********************************************************************** */
static UINT IdsGenerateTransformsForTargetImage ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);
	Assert(g_iSeqNumCur > 1);

	TCHAR rgchTargetImage[64];
	DWORD dwcch = 64;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTargetImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTargetImage));

	TCHAR rgchUpgradedImage[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchUpgradedImage));

	MSIHANDLE hdbUpgradedImage = HdbReopenMsi(g_hdbInput, rgchUpgradedImage, fTrue, fFalse);
	Assert(hdbUpgradedImage != NULL);

	MSIHANDLE hdbTargetImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fFalse);
	Assert(hdbTargetImage != NULL);

	MSIHANDLE hdbCopyOfUpgradedImage = HdbReopenMsi(g_hdbInput, rgchTargetImage, fFalse, fTrue);
	Assert(hdbCopyOfUpgradedImage != NULL);

	wsprintf(g_szTempFName, TEXT("%sTo%s.MST"), rgchTargetImage, rgchUpgradedImage);
	// this will fail if transforms are equal -- will that ever happen?
	UINT idsRet = ERROR_PCW_CANT_GENERATE_TRANSFORM;
	uiRet = MsiDatabaseGenerateTransform(hdbUpgradedImage,
					hdbTargetImage, g_szTempFolder, 0, 0);
	Assert(uiRet == MSI_OKAY);
	if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

	TCHAR rgchFlags[32];
	dwcch = 32;
	uiRet = MsiRecordGetString(hrec, 3, rgchFlags, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFlags));

	ULONG ulValidationFlags;
	ulValidationFlags = UlFromHexSz(rgchFlags);

#define iSuppressedErrors   (MSITRANSFORM_ERROR_ADDEXISTINGROW | MSITRANSFORM_ERROR_DELMISSINGROW | MSITRANSFORM_ERROR_UPDATEMISSINGROW | MSITRANSFORM_ERROR_ADDEXISTINGTABLE)
	int iValidationFlags;
	iValidationFlags = (int)(LOWORD((DWORD)ulValidationFlags));

	uiRet = MsiCreateTransformSummaryInfo(hdbUpgradedImage,
					hdbTargetImage, g_szTempFolder, iSuppressedErrors,
					iValidationFlags);
	Assert(uiRet == MSI_OKAY);
	idsRet = ERROR_PCW_CANT_CREATE_SUMMARY_INFO;
	if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

	// per Whistler bug 381320, we need to drop the Patch table from the reference database to ensure that the transform has an
	// add table entry for the Patch table. This is only necessary if the Patch table is present in the reference database.
	// This ensures that we can successfully handle the new schema change to bypass the FTK limit (transforms don't handle
	// changes in column nullability gracefully)
	MSICONDITION ePatchTablePresent = MsiDatabaseIsTablePersistent(hdbUpgradedImage, TEXT("Patch"));
	if (MSICONDITION_TRUE == ePatchTablePresent)
		{
		MSIHANDLE hViewPatch = NULL;
		EvalAssert( MSI_OKAY == MsiDatabaseOpenView(hdbUpgradedImage, TEXT("DROP TABLE `Patch`"), &hViewPatch) );
		EvalAssert( MSI_OKAY == MsiViewExecute(hViewPatch, 0) );
		EvalAssert( MSI_OKAY == MsiViewClose(hViewPatch) );
		EvalAssert( MSI_OKAY == MsiCloseHandle(hViewPatch) );
		}

	wsprintf(g_szTempFName, TEXT("#%sTo%s.MST"), rgchTargetImage, rgchUpgradedImage);
	// this will fail if transforms are equal -- will that ever happen?
	uiRet = MsiDatabaseGenerateTransform(hdbCopyOfUpgradedImage,
					hdbUpgradedImage, g_szTempFolder, 0, 0);
	Assert(uiRet == MSI_OKAY);
	idsRet = ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND;
	if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

#define iValidationFlagsMax 0x0927
	uiRet = MsiCreateTransformSummaryInfo(hdbCopyOfUpgradedImage,
					hdbUpgradedImage, g_szTempFolder, iSuppressedErrors,
					iValidationFlags);
	Assert(uiRet == MSI_OKAY);
	idsRet = ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND;
	if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

	idsRet = IDS_OKAY;

LEarlyReturn:
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbUpgradedImage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbTargetImage) );
	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdbCopyOfUpgradedImage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbCopyOfUpgradedImage) );

	if (IDS_OKAY != idsRet)
		return (UiLogError(idsRet, NULL, NULL));

	return (idsRet);
}


static BOOL FInitializeDdf   ( LPTSTR szFamily, LPTSTR szTempFolder, LPTSTR szTempFName );
static BOOL FWriteSzToDdf    ( LPTSTR sz );
static void CloseDdf         ( void );
static BOOL FCreateSmallFile ( LPTSTR szPath );
static BOOL FRunMakeCab      ( LPTSTR szFamily, LPTSTR szTempFolder );

/* ********************************************************************** */
static UINT UiCreateCabinet ( LPTSTR szFamily, int iSequenceNumStart, int iSequenceNumCur )
{
	Assert(!FEmptySz(szFamily));
	Assert(iSequenceNumStart > 0);
	Assert(iSequenceNumCur > 0);
	Assert(iSequenceNumCur >= iSequenceNumStart);

	Assert(g_hdbInput != NULL);
	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	UINT uiRet = ERROR_SUCCESS;
	if (!FInitializeDdf(szFamily, g_szTempFolder, g_szTempFName))
		uiRet = ERROR_PCW_CANNOT_WRITE_DDF;

	if (uiRet == ERROR_SUCCESS && iSequenceNumStart >= iSequenceNumCur)
		{
		wsprintf(g_szTempFName, TEXT("%s\\filler"), szFamily);
		if (!FCreateSmallFile(g_szTempFolder) || !FWriteSzToDdf(TEXT("filler filler\r\n")))
			uiRet = ERROR_PCW_CANNOT_WRITE_DDF;
		*g_szTempFName = TEXT('\0');
		}

	lstrcpy(g_szTempFName, szFamily);
	lstrcat(g_szTempFName, TEXT("\\"));
	LPTSTR szTail = g_szTempFName + lstrlen(g_szTempFName);
	while (uiRet == ERROR_SUCCESS && iSequenceNumStart < iSequenceNumCur)
		{
		wsprintf(szTail, TEXT("%05i.FLE"), iSequenceNumStart);
		if (!FFileExist(g_szTempFolder))
			{
			wsprintf(szTail, TEXT("%05i.HDR"), iSequenceNumStart);
			Assert(FFileExist(g_szTempFolder));
			wsprintf(szTail, TEXT("%05i.PAT"), iSequenceNumStart);
			Assert(FFileExist(g_szTempFolder));
			}

		TCHAR rgchDdfLine[MAX_PATH+MAX_PATH];
		wsprintf(rgchDdfLine, TEXT("`SequenceNum` = %i AND `Family` = '%s'"),
					iSequenceNumStart, szFamily);

		TCHAR rgchFTK[MAX_PATH];
		EvalAssert( IDS_OKAY == IdsMsiGetTableStringWhere(g_hdbInput,
						TEXT("`NewSequenceNums`"), TEXT("`FTK`"), rgchDdfLine,
						rgchFTK, MAX_PATH) );
		Assert(!FEmptySz(rgchFTK));

		wsprintf(rgchDdfLine, TEXT("%s %s\r\n"), szTail, rgchFTK);
		if (!FWriteSzToDdf(rgchDdfLine))
			uiRet = ERROR_PCW_CANNOT_WRITE_DDF;
		iSequenceNumStart++;
		}
	CloseDdf();

	if (uiRet == ERROR_SUCCESS)
		{
		*g_szTempFName = TEXT('\0');
		if (!FRunMakeCab(szFamily, g_szTempFolder))
			return (UiLogError(ERROR_PCW_CANNOT_RUN_MAKECAB, szNull, szNull));

		return (ERROR_SUCCESS);
		}

	Assert(uiRet == ERROR_PCW_CANNOT_WRITE_DDF);

	return (UiLogError(uiRet, szNull, szNull));
}


static HANDLE g_hfDdf = INVALID_HANDLE_VALUE;

#define WriteDDF(sz)  if (!FWriteSzToDdf(sz)) { fRet=fFalse; }

/* ********************************************************************** */
static BOOL FInitializeDdf ( LPTSTR szFamily, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(!FEmptySz(szFamily));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);

	Assert(g_hfDdf == INVALID_HANDLE_VALUE);

	lstrcpy(szTempFName, szFamily);
	lstrcat(szTempFName, TEXT(".DDF"));
	Assert(!FFileExist(szTempFolder));
	Assert(!FFolderExist(szTempFolder));

	g_hfDdf = CreateFile(szTempFolder, GENERIC_WRITE, 0, NULL,
				CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (g_hfDdf == INVALID_HANDLE_VALUE)
		return (fFalse);

	BOOL fRet = fTrue;

	WriteDDF(TEXT(".Set DiskDirectoryTemplate=.\r\n"));
	WriteDDF(TEXT(".Set InfFileName=nul\r\n"));
	WriteDDF(TEXT(".Set RptFileName=nul\r\n"));
	WriteDDF(TEXT(".Set Compress=on\r\n"));
	WriteDDF(TEXT(".Set Cabinet=on\r\n"));
	WriteDDF(TEXT(".Set CompressionType=LZX\r\n"));
	WriteDDF(TEXT(".Set MaxDiskSize=0\r\n"));

	TCHAR rgch[MAX_PATH];
	wsprintf(rgch, TEXT(".Set CabinetNameTemplate=%s.CAB\r\n\r\n"), szFamily);
	WriteDDF(rgch);

	*szTempFName = TEXT('\0');
	wsprintf(rgch, TEXT(".Set SourceDir=%s%s\\\r\n\r\n"), szTempFolder, szFamily);
	WriteDDF(rgch);

	return (fRet);
}


/* ********************************************************************** */
static BOOL FWriteSzToDdf ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(g_hfDdf != INVALID_HANDLE_VALUE);

	DWORD dwWritten = 0;
	DWORD dwSize = lstrlen(sz)*sizeof(TCHAR);

	return (WriteFile(g_hfDdf, (LPVOID)sz, dwSize, &dwWritten, NULL) && dwWritten == dwSize);
}


/* ********************************************************************** */
static void CloseDdf ( void )
{
	if (g_hfDdf != INVALID_HANDLE_VALUE)
		{
		CloseHandle(g_hfDdf);
		g_hfDdf = INVALID_HANDLE_VALUE;
		}
}


/* ********************************************************************** */
static BOOL FCreateSmallFile ( LPTSTR szPath )
{
	Assert(!FEmptySz(szPath));
	Assert(!FFileExist(szPath));
	Assert(!FFolderExist(szPath));

	BOOL   fRet  = fTrue;
	HANDLE hfSav = g_hfDdf;
	g_hfDdf = CreateFile(szPath, GENERIC_WRITE, 0, NULL,
				CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (g_hfDdf == INVALID_HANDLE_VALUE || !FWriteSzToDdf(TEXT("filler")))
		fRet = fFalse;
	CloseDdf();

	g_hfDdf = hfSav;

	return (fRet);
}


/* ********************************************************************** */
static BOOL FRunMakeCab ( LPTSTR szFamily, LPTSTR szTempFolder )
{
	Assert(!FEmptySz(szFamily));
	Assert(!FEmptySz(szTempFolder));
	Assert(*SzLastChar(szTempFolder) == TEXT('\\'));

	TCHAR rgchCmdLine[MAX_PATH+20];
	wsprintf(rgchCmdLine, TEXT("MAKECAB.EXE /f %s.DDF"), szFamily);

	STARTUPINFO si;
	si.cb               = sizeof(si);
	si.lpReserved       = NULL;
	si.lpDesktop        = NULL;
	si.lpTitle          = NULL;
	si.dwX              = 0;
	si.dwY              = 0;
	si.dwXSize          = 0;
	si.dwYSize          = 0;
	si.dwXCountChars    = 0;
	si.dwYCountChars    = 0;
	si.dwFillAttribute  = 0;
	si.dwFlags          = STARTF_FORCEONFEEDBACK | STARTF_USESHOWWINDOW;
	si.wShowWindow      = SW_SHOW;
	si.cbReserved2      = 0;
	si.lpReserved2      = NULL;

	PROCESS_INFORMATION pi;
	if (!CreateProcess(NULL, rgchCmdLine, NULL, NULL, FALSE,
				NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE, NULL,
				szTempFolder, &si, &pi))
		{
		return (fFalse);
		}

	DWORD dw = WaitForSingleObject(pi.hProcess, INFINITE);
	CloseHandle(pi.hThread);

	if (dw == WAIT_FAILED
			|| !GetExitCodeProcess(pi.hProcess, &dw)
			|| dw != 0)
		{
		Assert(CloseHandle(pi.hProcess));
		return (fFalse);
		}

	return (fTrue);
}


static UINT IdsStuffFamilyCabs ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsStuffTargetMsts ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static UINT UiStuffCabsAndMstsIntoPackage ( MSIHANDLE hdbInput, LPTSTR szPatchPath )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szPatchPath));
	Assert(!FFileExist(szPatchPath));

	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	MSIHANDLE hdbPackage;
	UINT ids = MsiOpenDatabase(szPatchPath,
					MSIDBOPEN_CREATEDIRECT + MSIDBOPEN_PATCHFILE, &hdbPackage);
	if (ids != MSI_OKAY)
		return (UiLogError(ERROR_PCW_CANT_CREATE_PATCH_FILE, szPatchPath, NULL));
	Assert(hdbPackage != NULL);

	ids = IdsMsiEnumTable(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), szNull, IdsStuffFamilyCabs,
					(LPARAM)hdbPackage, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	Assert(iOrderMax > 0);
	ids = IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`"), TEXT("`Target`<>'' ORDER BY `Order`"),
					IdsStuffTargetMsts, (LPARAM)hdbPackage, (LPARAM)hdbInput);
	if (ids != IDS_OKAY)
		return (ids);

	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdbPackage) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdbPackage) );

	return (ERROR_SUCCESS);
}


static UINT UiStuffFileIntoStream  ( LPTSTR szFile, LPTSTR szStream,  MSIHANDLE hdbPackage );
static UINT UiStuffFileIntoStorage ( LPTSTR szFile, LPTSTR szStorage, MSIHANDLE hdbPackage );

/* ********************************************************************** */
static UINT IdsStuffFamilyCabs ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	MSIHANDLE hdbPackage = (MSIHANDLE)lp1;
	Assert(hdbPackage != NULL);

	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	TCHAR rgchFamily[32];
	DWORD dwcch = 32;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchFamily));

	wsprintf(g_szTempFName, TEXT("%s.CAB"), rgchFamily);
	Assert(FFileExist(g_szTempFolder));

	TCHAR rgchStreamName[32];
	wsprintf(rgchStreamName, TEXT("PCW_CAB_%s"), rgchFamily);

	return (UiStuffFileIntoStream(g_szTempFolder, rgchStreamName, hdbPackage));
}


static void AppendStorageNamesToProp ( MSIHANDLE hdbInput, LPTSTR szStorage );

/* ********************************************************************** */
static UINT IdsStuffTargetMsts ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdbPackage = (MSIHANDLE)lp1;
	Assert(hdbPackage != NULL);

	MSIHANDLE hdbInput = (MSIHANDLE)lp2;
	Assert(hdbInput != NULL);

	Assert(!FEmptySz(g_szTempFolder));
	Assert(g_szTempFName != szNull);

	TCHAR rgchTarget[32];
	DWORD dwcch = 32;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchTarget));

	TCHAR rgchUpgraded[32];
	dwcch = 32;
	uiRet = MsiRecordGetString(hrec, 2, rgchUpgraded, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == IDS_OKAY);
	Assert(!FEmptySz(rgchUpgraded));

	TCHAR rgchStorageName[64];
	wsprintf(rgchStorageName, TEXT("#%sTo%s"), rgchTarget, rgchUpgraded);

	AppendStorageNamesToProp(hdbInput, rgchStorageName);

	wsprintf(g_szTempFName, TEXT("%s.MST"), rgchStorageName+1);
	Assert(FFileExist(g_szTempFolder));

	UINT ui = UiStuffFileIntoStorage(g_szTempFolder, rgchStorageName+1, hdbPackage);
	if (ui != ERROR_SUCCESS)
		return (ui);

	wsprintf(g_szTempFName, TEXT("%s.MST"), rgchStorageName);
	Assert(FFileExist(g_szTempFolder));

	return (UiStuffFileIntoStorage(g_szTempFolder, rgchStorageName, hdbPackage));
}


/* ********************************************************************** */
static UINT UiStuffFileIntoStream ( LPTSTR szFile, LPTSTR szStream, MSIHANDLE hdbPackage )
{
	Assert(!FEmptySz(szFile));
	Assert(FFileExist(szFile));
	Assert(!FEmptySz(szStream));
	Assert(lstrlen(szStream) < 64);
	Assert(hdbPackage != NULL);

	MSIHANDLE hrecNew = MsiCreateRecord(2);
	Assert(hrecNew != NULL);
	EvalAssert( MSI_OKAY == MsiRecordSetString( hrecNew, 1, szStream) );
	EvalAssert( MSI_OKAY == MsiRecordSetStream( hrecNew, 2, szFile) );

	EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbPackage, TEXT("`_Streams`"),
						TEXT("`Name`,`Data`"), TEXT("`Name`"), szStream, hrecNew) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT UiStuffFileIntoStorage ( LPTSTR szFile, LPTSTR szStorage, MSIHANDLE hdbPackage )
{
	Assert(!FEmptySz(szFile));
	Assert(FFileExist(szFile));
	Assert(!FEmptySz(szStorage));
	Assert(lstrlen(szStorage) < 64);
	Assert(hdbPackage != NULL);

	MSIHANDLE hrecNew = MsiCreateRecord(2);
	Assert(hrecNew != NULL);
	EvalAssert( MSI_OKAY == MsiRecordSetString( hrecNew, 1, szStorage) );
	EvalAssert( MSI_OKAY == MsiRecordSetStream( hrecNew, 2, szFile) );

	EvalAssert( IDS_OKAY == IdsMsiSetTableRecord(hdbPackage, TEXT("`_Storages`"),
						TEXT("`Name`,`Data`"), TEXT("`Name`"), szStorage, hrecNew) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static void AppendStorageNamesToProp ( MSIHANDLE hdbInput, LPTSTR szStorage )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szStorage));
	Assert(*szStorage == TEXT('#'));

	TCHAR rgch[1024*8];

	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("StorageNamesForMSTs"), rgch, 1024*8) );

	if (!FEmptySz(rgch))
		lstrcat(rgch, TEXT(";"));

	lstrcat(rgch, TEXT(":"));
	lstrcat(rgch, szStorage+1);
	lstrcat(rgch, TEXT(";:"));
	lstrcat(rgch, szStorage);

	EvalAssert( IDS_OKAY == IdsMsiSetPcwPropertyString(hdbInput,
					TEXT("StorageNamesForMSTs"), rgch) );
}


/* ********************************************************************** */
static BOOL FSetPatchPackageSummaryInfo ( MSIHANDLE hdbInput, LPTSTR szPatchPath )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szPatchPath));
	Assert(FFileExist(szPatchPath));

	MSIHANDLE hSummaryInfo = NULL;
	if (MSI_OKAY != MsiGetSummaryInformation(NULL, szPatchPath, 20, &hSummaryInfo))
		return (fFalse);
	Assert(hSummaryInfo != NULL);


	UINT cchBuf, cchCur;
	cchBuf = CchMsiPcwPropertyString(hdbInput, TEXT("PatchGUID"));
	Assert(cchBuf > 0);
	Assert(cchBuf < 50*1024);
	cchCur = CchMsiPcwPropertyString(hdbInput, TEXT("ListOfPatchGUIDsToReplace"));
//	Assert(cchCur > 0);
	Assert(cchCur < 50*1024);
	if (cchCur < 63)
		cchCur = 63;
	cchBuf += cchCur;
	Assert(cchBuf < 50*1024);

	cchCur = CchMsiPcwPropertyString(hdbInput, TEXT("ListOfTargetProductCodes"));
	Assert(cchCur > 0);
	Assert(cchCur < 50*1024);
	if (cchCur > cchBuf)
		cchBuf = cchCur;

	cchCur = CchMsiPcwPropertyString(hdbInput, TEXT("StorageNamesForMSTs"));
	Assert(cchCur > 0);
	Assert(cchCur < 50*1024);
	if (cchCur > cchBuf)
		cchBuf = cchCur;

	cchCur = CchMsiPcwPropertyString(hdbInput, TEXT("PatchSourceList"));
	Assert(cchCur > 0);
	Assert(cchCur < 50*1024);
	if (cchCur > cchBuf)
		cchBuf = cchCur;

	if (cchBuf < 63)
		cchBuf = 64;
	else
		cchBuf++; // for terminating Null char

	LPTSTR szBuf = (LPTSTR)LocalAlloc(LPTR, cchBuf*sizeof(TCHAR));
	Assert(szBuf != szNull);
	if (szBuf == szNull)
		return (fFalse);


	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("PatchGUID"), szBuf, cchBuf) );
	Assert(!FEmptySz(szBuf));
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("ListOfPatchGUIDsToReplace"), szBuf+lstrlen(szBuf), cchBuf-lstrlen(szBuf)) );
	CharUpper(szBuf);
	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_REVNUMBER, VT_LPTSTR, 0, NULL, szBuf))
		{
LEarlyReturn:
		EvalAssert( NULL == LocalFree((HLOCAL)szBuf) );
		return (fFalse);
		}

	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("ListOfTargetProductCodes"), szBuf, cchBuf) );
	Assert(!FEmptySz(szBuf));
	CharUpper(szBuf);
	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_TEMPLATE, VT_LPTSTR, 0, NULL, szBuf))
		goto LEarlyReturn;

	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("StorageNamesForMSTs"), szBuf, cchBuf) );
	Assert(!FEmptySz(szBuf));
	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_LASTAUTHOR, VT_LPTSTR, 0, NULL, szBuf))
		goto LEarlyReturn;

	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput,
					TEXT("PatchSourceList"), szBuf, cchBuf) );
	Assert(!FEmptySz(szBuf));
	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_KEYWORDS, VT_LPTSTR, 0, NULL, szBuf))
		goto LEarlyReturn;

	EvalAssert( NULL == LocalFree((HLOCAL)szBuf) );

	int iWordCount = UlGetApiPatchOptionFlags(hdbInput) == PATCH_OPTION_DEFAULT_LARGE ? 2 : 1;

	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	if (iMinimumMsiVersion >= iWindowsInstallerME && iMinimumMsiVersion < iWindowsInstallerXP)
		iWordCount = 2;
	if (iMinimumMsiVersion >= iWindowsInstallerXP || g_bUsedMsiPatchHeadersTable)
		iWordCount = 3;

	if (MSI_OKAY != MsiSummaryInfoSetProperty(hSummaryInfo, PID_WORDCOUNT, VT_I4, iWordCount, NULL, NULL))
		return (fFalse);

	if (MSI_OKAY != MsiSummaryInfoPersist(hSummaryInfo))
		return (fFalse);

	EvalAssert( MSI_OKAY == MsiCloseHandle(hSummaryInfo) );

	return (fTrue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\myassrtc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

#ifndef MYASSERT_H
#define MYASSERT_H

#ifdef _DEBUG
#define  EnableAsserts  // static TCHAR rgchFile[] = TEXT(__FILE__);
#define  EvalAssert(x)  Assert(x)
/* NOTE - this definition of Assert() includes 'Patch Creation Wizard' in the msgbox title */
#define  Assert(x) \
        { \
        if (!(x)) \
            { \
            TCHAR rgch[128]; \
            wsprintf(rgch, TEXT("File: %s, Line: %d"), __FILE__, __LINE__); \
            MessageBox(hwndNull, rgch, TEXT("Patch Creation Wizard Assert"), MB_OK); \
            } \
        }
#define  AssertFalse() \
        { \
        TCHAR rgch[128]; \
        wsprintf(rgch, TEXT("File: %s, Line: %d"), __FILE__, __LINE__); \
        MessageBox(hwndNull, rgch, TEXT("Patch Creation Wizard AssertFalse"), MB_OK); \
        }
#define  DebugMsg() \
        { \
        TCHAR rgch[128]; \
        wsprintf(rgch, TEXT("File: %s, Line: %d"), __FILE__, __LINE__); \
        MessageBox(hwndNull, rgch, TEXT("Patch Creation Wizard Debug Msg"), MB_OK); \
        }
#else
#define  EnableAsserts
#define  EvalAssert(x)  if (x) 1;
#define  Assert(x)
#define  AssertFalse()
#define  DebugMsg()
#endif

#define  Unused(x)  x = x;


#endif /* !MYASSERT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\patchres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       patchres.h
//
//--------------------------------------------------------------------------

#ifndef __PATCHRES_H_119F5B1A_5737_4069_AEFD_E9EFFEF07C28
#define __PATCHRES_H_119F5B1A_5737_4069_AEFD_E9EFFEF07C28

#define IDS_STATUS_VALIDATE_INPUT           100
#define IDS_STATUS_VALIDATE_IMAGES          101
#define IDS_STATUS_VALIDATE_FILE_RANGES     102
#define IDS_STATUS_DETERMINE_SEQUENCE_START 103
#define IDS_STATUS_EXPAND_OVERLAP_RECORDS   104
#define IDS_STATUS_COPY_UPGRADED_MSI        105
#define IDS_STATUS_CREATE_FILE_PATCHES      106
#define IDS_STATUS_CREATE_TRANSFORMS        107
#define IDS_STATUS_CREATE_CABINET           108
#define IDS_STATUS_CLEANUP                  109

#define IDS_TITLE                           116
#define IDS_PRODUCTCODES_DONT_MATCH         117
#define IDS_PRODUCTVERSIONS_DONT_MATCH      118
#define IDS_PRODUCTVERSION_INVERSION        119
#define IDS_STREAM_NAME_LIMIT_REACHED       120

#endif //__PATCHRES_H_119F5B1A_5737_4069_AEFD_E9EFFEF07C28
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\msistuff.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

  /* MSISTUFF.CPP -- MSI stuff */

#pragma warning (disable:4553)

#include "patchdll.h"

EnableAsserts

#define iSchemaMin  0
#define iSchemaMax  1

enum pteEnum // Patch table enum
	{
	pteFirstEnum,
	ptePatch,
	ptePatchPackage,
	pteMsiPatchHeaders,
	pteNextEnum
	};

int iOrderMax = 0;

static BOOL g_fValidateProductCodeIncluded = FALSE;

static BOOL FValidSummInfoVersion   ( LPTSTR szPcp, INT iMin, INT iMax );
static BOOL FValidateInputMsiSchema ( MSIHANDLE hdb );
static BOOL FAddColumnToTable       ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fSz, BOOL fTemporary );

/* ********************************************************************** */
UINT UiOpenInputPcp ( LPTSTR szPcpPath, LPTSTR szTempFldrBuf, LPTSTR szTempFName, MSIHANDLE* phdbInput )
{
	Assert(!FEmptySz(szPcpPath));

	TCHAR rgchPcpPath[MAX_PATH];
	EvalAssert( FFixupPathEx(szPcpPath, rgchPcpPath) );

	Assert(FFileExist(rgchPcpPath));
	Assert(!FEmptySz(szTempFldrBuf));
	Assert(szTempFName != szNull);
	Assert(phdbInput != NULL);
	
	*phdbInput = NULL;
	if (FEmptySz(rgchPcpPath) || !FFileExist(rgchPcpPath))
		return (UiLogError(ERROR_PCW_PCP_DOESNT_EXIST, rgchPcpPath, NULL));

	lstrcpy(szTempFName, TEXT("inputcpy.pcp"));
	if (FFileExist(szTempFldrBuf))
		SetFileAttributes(szTempFldrBuf, FILE_ATTRIBUTE_NORMAL);

	EvalAssert( CopyFile(rgchPcpPath, szTempFldrBuf, fFalse) );
	// CopyFile preserves FILE_ATTRIBUTE_READONLY so we'll remove it from our copy
	SetFileAttributes(szTempFldrBuf, FILE_ATTRIBUTE_NORMAL); 

	if (!FValidSummInfoVersion(szTempFldrBuf, iSchemaMin, iSchemaMax))
		return (UiLogError(ERROR_PCW_PCP_BAD_FORMAT, rgchPcpPath, NULL));

	MSIHANDLE hdb;
	UINT ui = MsiOpenDatabase(szTempFldrBuf, MSIDBOPEN_DIRECT, &hdb);
	if (ui != MSI_OKAY)
		return (UiLogError(ERROR_PCW_PCP_BAD_FORMAT, rgchPcpPath, NULL));

#define STRING     fTrue
#define INTEGER    fFalse
#define TEMPORARY  fTrue
#define PERSIST    fFalse
	if (!FValidateInputMsiSchema(hdb)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`LFN`"),             STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`ProductCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`ProductVersion`"),  STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`UpgradeCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`PackageCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`SummSubject`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`UpgradedImages`"),   TEXT("`SummComments`"),    STRING,  PERSIST)

			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`LFN`"),             STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`ProductCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`ProductVersion`"),  STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`UpgradeCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`PackageCode`"),     STRING,  PERSIST)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`Family`"),          STRING,  TEMPORARY)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`MsiPathUpgradedCopy`"), STRING,  TEMPORARY)
			|| !FAddColumnToTable(hdb, TEXT("`TargetImages`"),     TEXT("`Attributes`"),      INTEGER, TEMPORARY)

			|| !FAddColumnToTable(hdb, TEXT("`FamilyFileRanges`"), TEXT("`RetainCount`"),     INTEGER, TEMPORARY)

			|| !FAddColumnToTable(hdb, TEXT("`ExternalFiles`"),    TEXT("`IgnoreCount`"),     INTEGER, TEMPORARY)
			|| !FAddColumnToTable(hdb, TEXT("`TargetFiles_OptionalData`"), TEXT("`IgnoreCount`"),     INTEGER, TEMPORARY)

			|| !FExecSqlCmd(hdb, TEXT("CREATE TABLE `NewSequenceNums` ( `Family` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `SequenceNum` INTEGER NOT NULL PRIMARY KEY `Family`, `FTK` )"))

			|| !FExecSqlCmd(hdb, TEXT("CREATE TABLE `TempPackCodes`   ( `PackCode`  CHAR(63) NOT NULL PRIMARY KEY `PackCode` )"))

			|| !FExecSqlCmd(hdb, TEXT("CREATE TABLE `TempImageNames`  ( `ImageName` CHAR(63) NOT NULL PRIMARY KEY `ImageName` )"))
					)
		{
		MsiCloseHandle(hdb);
		return (UiLogError(ERROR_PCW_PCP_BAD_FORMAT, szTempFldrBuf, NULL));
		}

	*phdbInput = hdb;

	return (ERROR_SUCCESS);
}


/* ********************************************************************** */
static BOOL FValidSummInfoVersion ( LPTSTR szPcp, INT iMin, INT iMax )
{
	Assert(!FEmptySz(szPcp));
	Assert(FFileExist(szPcp));
	Assert(iMin >= 0);
	Assert(iMin <= iMax);

	MSIHANDLE hSummaryInfo = NULL;
	UINT uiRet = MsiGetSummaryInformation(NULL, szPcp, 0, &hSummaryInfo);
	if (uiRet != MSI_OKAY || hSummaryInfo == NULL)
		return (fFalse);

	UINT uiType;
	INT  intRet;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_PAGECOUNT, &uiType, &intRet, NULL, NULL, NULL);
	if (uiRet != MSI_OKAY || (uiType != VT_I4 && uiType != VT_EMPTY))
		return (fFalse);
	if (uiType == VT_EMPTY)
		intRet = 0;

	EvalAssert( MsiCloseHandle(hSummaryInfo) == MSI_OKAY );

	return (intRet >= iMin && intRet <= iMax);
}


/* ********************************************************************** */
static BOOL FAddColumnToTable ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fSz, BOOL fTemporary )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szColumn));

	TCHAR rgchQuery[MAX_PATH];
	wsprintf(rgchQuery, TEXT("ALTER TABLE %s ADD %s %s"), szTable, szColumn, (fSz) ? TEXT("CHAR(32)") : TEXT("INTEGER"));

//	if (fTemporary)
//		lstrcat(rgchQuery, TEXT(" TEMPORARY"));

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		AssertFalse();
		return (fFalse);
		}

	UINT ids = MsiViewExecute(hview, 0);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */
	Assert(ids == IDS_OKAY);

	return (ids == IDS_OKAY);
}



/* Generic Table stuff */

/* return value does NOT include terminating null; zero if error */
/* ********************************************************************** */
UINT CchMsiTableString ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szPKey));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szPKeyValue));

	const TCHAR szWhereSzPattern[] = TEXT("%s = '%s'");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szWhereSzPattern) + lstrlen(szPKey) + lstrlen(szPKeyValue) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchWhere)
		return IDS_OOM;

	// don't use wsprintf because of 1024 buffer length limitation
	lstrcpy(rgchWhere, szPKey);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szPKeyValue);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = CchMsiTableStringWhere(hdb, szTable, szFieldName, rgchWhere);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* return value does NOT include terminating null; zero if error */
/* ********************************************************************** */
UINT CchMsiTableStringWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szWhere));

	UINT cchBufNeeded = 0;

	static const TCHAR szSelectWherePattern[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szSelectWherePattern) + lstrlen(szTable) + lstrlen(szFieldName) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// don't use wsprintf because of 1024 buffer length limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFieldName);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		goto LEarlyReturn;

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		goto LEarlyReturn;

	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	if (uiRet == ERROR_NO_MORE_ITEMS)
		goto LEarlyReturn;
	else if (uiRet != MSI_OKAY)
		goto LEarlyReturn;

	TCHAR rgchBuf[1];
	DWORD dwcch;
	dwcch = 0;
	uiRet = MsiRecordGetString(hrec, 1, rgchBuf, &dwcch);
	Assert(uiRet != MSI_OKAY);
	if (uiRet == ERROR_MORE_DATA)
		{
		Assert(dwcch < 50*1024);
		cchBufNeeded = (UINT)dwcch;
		}

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (cchBufNeeded);
}


/* ********************************************************************** */
UINT IdsMsiGetTableString ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue, LPTSTR szBuf, UINT cch )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szPKey));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szPKeyValue));
	Assert(szBuf != szNull);
	Assert(cch > 1);

	const TCHAR szWhereSzPattern[] = TEXT("%s = '%s'");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szWhereSzPattern) + lstrlen(szPKey) + lstrlen(szPKeyValue) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchWhere)
		return IDS_OOM;

	// don't use wsprintf because of 1024 buffer length limitation
	lstrcpy(rgchWhere, szPKey);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szPKeyValue);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiGetTableStringWhere(hdb, szTable, szFieldName, rgchWhere, szBuf, cch);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiGetTableStringWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere, LPTSTR szBuf, UINT cch )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szWhere));
	Assert(szBuf != szNull);
	Assert(cch > 1);

	*szBuf = TEXT('\0');

	UINT idsRet = IDS_OKAY;

	const TCHAR szSelectWherePattern[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szSelectWherePattern) + lstrlen(szFieldName) + lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// don't use wsprintf because of 1024 buffer length limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFieldName);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		idsRet = IDS_CANT_OPEN_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		idsRet = IDS_CANT_EXECUTE_VIEW;
		goto LEarlyReturn;
		}

	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	if (uiRet == ERROR_NO_MORE_ITEMS)
		goto LEarlyReturn;
	else if (uiRet != MSI_OKAY)
		{
		idsRet = IDS_CANT_FETCH_RECORD;
		goto LEarlyReturn;
		}

	DWORD dwcch;
	dwcch = (DWORD)cch;
	uiRet = MsiRecordGetString(hrec, 1, szBuf, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		idsRet = IDS_BUFFER_IS_TOO_SHORT;
	else if (uiRet != MSI_OKAY)
		idsRet = IDS_CANT_GET_RECORD_FIELD;

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiGetTableInteger ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue, int * pi )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szPKey));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szPKeyValue));
	Assert(pi != NULL);

	const TCHAR szWherePattern[] = TEXT("%s = '%s'");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szWherePattern) + lstrlen(szPKey) + lstrlen(szPKeyValue) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchWhere)
		return IDS_OOM;

	// don't use wsprintf due to 1024 buffer limitation
	lstrcpy(rgchWhere, szPKey);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szPKeyValue);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiGetTableIntegerWhere(hdb, szTable, szFieldName, rgchWhere, pi);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiGetTableIntegerWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere, int * pi )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFieldName));
	Assert(!FEmptySz(szWhere));
	Assert(pi != NULL);

	*pi = 0;

	UINT idsRet = IDS_OKAY;

	const TCHAR szSelectQuery[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szSelectQuery) + lstrlen(szFieldName) + lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// don't use wsprintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFieldName);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		idsRet = IDS_CANT_OPEN_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		idsRet = IDS_CANT_EXECUTE_VIEW;
		goto LEarlyReturn;
		}

	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	if (uiRet == ERROR_NO_MORE_ITEMS)
		goto LEarlyReturn;
	else if (uiRet != MSI_OKAY)
		{
		idsRet = IDS_CANT_FETCH_RECORD;
		goto LEarlyReturn;
		}

	*pi = MsiRecordGetInteger(hrec, 1);

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiSetTableRecordWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields, LPTSTR szWhere, MSIHANDLE hrec )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFields));
	Assert(!FEmptySz(szWhere));
	Assert(hrec != NULL);

	UINT idsRet = IDS_OKAY;

	const TCHAR szSelectQuery[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szSelectQuery) + lstrlen(szFields)+ lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// avoid wsprintf due to 1024 limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFields);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		idsRet = IDS_CANT_OPEN_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		idsRet = IDS_CANT_EXECUTE_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewModify(hview, MSIMODIFY_ASSIGN, hrec) != MSI_OKAY)
		idsRet = IDS_CANT_ASSIGN_RECORD_IN_VIEW;

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiSetTableRecord ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields, LPTSTR szPrimaryField, LPTSTR szKey, MSIHANDLE hrec )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFields));
	Assert(!FEmptySz(szPrimaryField));
	Assert(!FEmptySz(szKey));
	Assert(hrec != NULL);

	const TCHAR szWherePattern[] = TEXT("%s = '%s'");
	UINT cchWhere = 0;

	cchWhere = lstrlen(szWherePattern) + lstrlen(szPrimaryField) + lstrlen(szKey) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchWhere * sizeof(TCHAR));

	if (!rgchWhere)
		return IDS_OOM;

	// avoid wsprintf due to 1024 limitation
	lstrcpy(rgchWhere, szPrimaryField);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szKey);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiSetTableRecordWhere(hdb, szTable, szFields, rgchWhere, hrec);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);

}


/* ********************************************************************** */
UINT IdsMsiUpdateTableRecordSz ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szValue, LPTSTR szPKeyField, LPTSTR szPKeyValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(*szTable != TEXT('`'));
	Assert(!FEmptySz(szField));
	Assert(*szField != TEXT('`'));
	Assert(szValue != szNull);
	Assert(!FEmptySz(szPKeyField));
	Assert(*szPKeyField != TEXT('`'));
	Assert(!FEmptySz(szPKeyValue));

	UINT cchQuery;
	// keep szUpdateSQLPatern for easy understanding of the SQL statement
	static const TCHAR szUpdateSQLPatern[] = TEXT("UPDATE `%s` SET `%s` = '%s' WHERE `%s` = '%s'");

	// TCHAR rgchQuery[MAX_PATH];
	cchQuery =	lstrlen(szUpdateSQLPatern) + 
				(szTable ? lstrlen(szTable) : 0) +
				(szField ? lstrlen(szField) : 0) +
				(szValue ? lstrlen(szValue) : 0) +
				(szPKeyField ? lstrlen(szPKeyField) : 0) +
				(szPKeyValue ? lstrlen(szPKeyValue) : 0) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// don't use wsprintf because of 1024 buffer length limitation
	lstrcpy(rgchQuery, TEXT("UPDATE `"));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT("` SET `"));
	lstrcat(rgchQuery, szField);
	lstrcat(rgchQuery, TEXT("` = '"));
	lstrcat(rgchQuery, szValue);
	lstrcat(rgchQuery, TEXT("' WHERE `"));
	lstrcat(rgchQuery, szPKeyField);
	lstrcat(rgchQuery, TEXT("` = '"));
	lstrcat(rgchQuery, szPKeyValue);
	lstrcat(rgchQuery, TEXT("'"));

	UINT idsRet = IDS_OKAY;

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		Assert(hview == NULL);
		idsRet = IDS_CANT_OPEN_VIEW;
		}

	if (hview != NULL && MsiViewExecute(hview, 0) != MSI_OKAY)
		idsRet = IDS_CANT_EXECUTE_VIEW;

	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiUpdateTableRecordInt ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, int iValue, LPTSTR szPKeyField, LPTSTR szPKeyValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(*szTable != TEXT('`'));
	Assert(!FEmptySz(szField));
	Assert(*szField != TEXT('`'));
	Assert(!FEmptySz(szPKeyField));
	Assert(*szPKeyField != TEXT('`'));
	Assert(!FEmptySz(szPKeyValue));

	const TCHAR szUpdatePattern[] = TEXT("UPDATE `%s` SET `%s` = %d WHERE `%s` = '%s'");
	UINT cchQuery = 0;

	TCHAR szInt[32] = {0};
	wsprintf(szInt, TEXT("%d"), iValue);

	cchQuery = lstrlen(szUpdatePattern) + lstrlen(szTable) + lstrlen(szField) + lstrlen(szInt) + lstrlen(szPKeyField) + lstrlen(szPKeyValue) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return IDS_OOM;

	// avoid wsprintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("UPDATE `"));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT("` SET `"));
	lstrcat(rgchQuery, szField);
	lstrcat(rgchQuery, TEXT("` = "));
	lstrcat(rgchQuery, szInt);
	lstrcat(rgchQuery, TEXT(" WHERE `"));
	lstrcat(rgchQuery, szPKeyField);
	lstrcat(rgchQuery, TEXT("` = '"));
	lstrcat(rgchQuery, szPKeyValue);
	lstrcat(rgchQuery, TEXT("'"));

	UINT idsRet = IDS_OKAY;

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		Assert(hview == NULL);
		idsRet = IDS_CANT_OPEN_VIEW;
		}

	if (hview != NULL && MsiViewExecute(hview, 0) != MSI_OKAY)
		idsRet = IDS_CANT_EXECUTE_VIEW;

	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiUpdateTableRecordIntPkeyInt ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, int iValue, LPTSTR szPKeyField, int iPKeyValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(*szTable != TEXT('`'));
	Assert(!FEmptySz(szField));
	Assert(*szField != TEXT('`'));
	Assert(!FEmptySz(szPKeyField));
	Assert(*szPKeyField != TEXT('`'));

	const TCHAR szQueryPattern[] = TEXT("UPDATE `%s SET `%s` = %d WHERE `%s` = %d");
	UINT cchQuery = 0;

	TCHAR szInt1[32] = {0};
	wsprintf(szInt1, TEXT("%d"), iValue);
	TCHAR szInt2[32] = {0};
	wsprintf(szInt2, TEXT("%d"), iPKeyValue);

	cchQuery = lstrlen(szQueryPattern) + lstrlen(szTable) + lstrlen(szField) + lstrlen(szInt1) + lstrlen(szPKeyField) + lstrlen(szInt2) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return (IDS_OOM);

	// avoid wsprintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("UPDATE `"));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT("` SET `"));
	lstrcat(rgchQuery, szField);
	lstrcat(rgchQuery, TEXT("` = "));
	lstrcat(rgchQuery, szInt1);
	lstrcat(rgchQuery, TEXT(" WHERE `"));
	lstrcat(rgchQuery, szPKeyField);
	lstrcat(rgchQuery, TEXT("` = "));
	lstrcat(rgchQuery, szInt2);

	UINT idsRet = IDS_OKAY;

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		Assert(hview == NULL);
		idsRet = IDS_CANT_OPEN_VIEW;
		}

	if (hview != NULL && MsiViewExecute(hview, 0) != MSI_OKAY)
		idsRet = IDS_CANT_EXECUTE_VIEW;

	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiDeleteTableRecords ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szKey )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szField));
	Assert(!FEmptySz(szKey));

	const TCHAR szWherePattern[] = TEXT("%s = '%s'");
	UINT cchWhere = 0;

	cchWhere = lstrlen(szWherePattern) + lstrlen(szField) + lstrlen(szKey) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchWhere * sizeof(TCHAR));

	if (!rgchWhere)
		return (IDS_OOM);

	// avoid wsprintf due to 1024 buffer limitation
	lstrcpy(rgchWhere, szField);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szKey);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiDeleteTableRecordsWhere(hdb, szTable, rgchWhere);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiDeleteTableRecordsWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szWhere )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szWhere));

	const TCHAR szDeletePattern[] = TEXT("DELETE FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szDeletePattern) + lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return (IDS_OOM);

	// avoid wsprintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("DELETE FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" WHERE "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		return (IDS_CANT_OPEN_VIEW);

	UINT ids = IDS_OKAY;
	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		ids = IDS_CANT_EXECUTE_VIEW;

	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (ids);
}


/* ********************************************************************** */
UINT IdsMsiEnumTable ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields,
			LPTSTR szWhere, PIEMTPROC pIemtProc, LPARAM lp1, LPARAM lp2 )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szFields));
	Assert(pIemtProc != NULL);

	UINT idsRet = IDS_OKAY;

	const TCHAR szEnumQueryPattern[] = TEXT("SELECT %s FROM %s WHERE %s");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szEnumQueryPattern)
				+ lstrlen(szFields)
				+ lstrlen(szTable)
				+ (szWhere ? lstrlen(szWhere) : 0)
				+ 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return (IDS_OOM);

	// avoid wsprintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szFields);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	if (szWhere != szNull)
		{
		lstrcat(rgchQuery, TEXT(" WHERE "));
		lstrcat(rgchQuery, szWhere);
		}

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
		idsRet = IDS_CANT_OPEN_VIEW;
		goto LEarlyReturn;
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		idsRet = IDS_CANT_EXECUTE_VIEW;
		goto LEarlyReturn;
		}

	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	while (uiRet != ERROR_NO_MORE_ITEMS)
		{
		if (uiRet != MSI_OKAY)
			{
			idsRet = IDS_CANT_FETCH_RECORD;
			goto LEarlyReturn;
			}

		idsRet = (*pIemtProc)(hview, hrec, lp1, lp2);
		if (idsRet != IDS_OKAY)
			goto LEarlyReturn;
		
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
		hrec = NULL;
		uiRet = MsiViewFetch(hview, &hrec);
		}

LEarlyReturn:
	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	if (hview != NULL)
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiExistTableRecords ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szValue, PBOOL pf )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szValue));
	Assert(pf != pfNull);

	if (*pf != fFalse)
		return (IDS_OKAY);

	if (szField == szNull)
		szField = TEXT("`Component_`");
	Assert(*szField != TEXT('\0'));

	const TCHAR szWherePattern[] = TEXT("WHERE %s = '%s'");
	UINT cchWhere = 0;

	cchWhere = lstrlen(szWherePattern) + lstrlen(szField) + lstrlen(szValue) + 1;
	LPTSTR rgchWhere = (LPTSTR)LocalAlloc(LPTR, cchWhere * sizeof(TCHAR));

	if (!rgchWhere)
		return (IDS_OOM);

	// avoid wsprintf due to 1024 buffer limitation
	lstrcpy(rgchWhere, TEXT("WHERE "));
	lstrcat(rgchWhere, szField);
	lstrcat(rgchWhere, TEXT(" = '"));
	lstrcat(rgchWhere, szValue);
	lstrcat(rgchWhere, TEXT("'"));

	UINT idsRet = IdsMsiExistTableRecordsWhere(hdb, szTable, szField, rgchWhere, pf);

	EvalAssert( NULL == LocalFree((HLOCAL)rgchWhere) );

	return (idsRet);
}


/* ********************************************************************** */
UINT IdsMsiExistTableRecordsWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szWhere, PBOOL pf )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(szWhere != szNull);
//	Assert(!FEmptySz(szWhere));
	Assert(pf != pfNull);

	if (*pf != fFalse)
		return (IDS_OKAY);

	if (szField == szNull)
		szField = TEXT("`Component_`");
	Assert(*szField != TEXT('\0'));

	const TCHAR szQueryPattern[] = TEXT("SELECT %s FROM %s ");
	UINT cchQuery = 0;

	cchQuery = lstrlen(szQueryPattern) + lstrlen(szField) + lstrlen(szTable) + lstrlen(szWhere) + 1;
	LPTSTR rgchQuery = (LPTSTR)LocalAlloc(LPTR, cchQuery * sizeof(TCHAR));

	if (!rgchQuery)
		return (IDS_OOM);

	// avoid wsprintf due to 1024 buffer limitation
	lstrcpy(rgchQuery, TEXT("SELECT "));
	lstrcat(rgchQuery, szField);
	lstrcat(rgchQuery, TEXT(" FROM "));
	lstrcat(rgchQuery, szTable);
	lstrcat(rgchQuery, TEXT(" "));
	lstrcat(rgchQuery, szWhere);

	MSIHANDLE hview = NULL;
	MSIHANDLE hrec  = NULL;
	if (MsiDatabaseOpenView(hdb, rgchQuery, &hview) != MSI_OKAY)
		{
//		AssertFalse(); FSz/IntColumnExists() expects this to fail
		return (IDS_CANT_OPEN_VIEW);
		}

	if (MsiViewExecute(hview, 0) != MSI_OKAY)
		{
		AssertFalse();
		EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */
		return (IDS_CANT_EXECUTE_VIEW);
		}

	UINT idsRet = IDS_OKAY;
	UINT uiRet;
	uiRet = MsiViewFetch(hview, &hrec);
	if (uiRet != ERROR_NO_MORE_ITEMS)
		{
		if (uiRet != MSI_OKAY)
			idsRet = IDS_CANT_FETCH_RECORD;
		else
			*pf = fTrue;
		}

	if (hrec != NULL)
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	Assert(hview != NULL);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);  /* calls MsiViewClose() internally */

	EvalAssert( NULL == LocalFree((HLOCAL)rgchQuery) );

	return (idsRet);
}



/* PROPERTY TABLES */

/* ********************************************************************** */
UINT IdsMsiGetPropertyString ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue, UINT cch )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(szValue != szNull);
	Assert(cch > 1);

	return (IdsMsiGetTableString(hdb, TEXT("`Property`"),
			TEXT("`Property`"), TEXT("`Value`"), szName, szValue, cch));
}


/* ********************************************************************** */
UINT IdsMsiSetPropertyString ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(!FEmptySz(szValue));

	MSIHANDLE hrec = MsiCreateRecord(2);
	if (hrec == NULL)
		return (IDS_CANT_CREATE_RECORD);

	if (MsiRecordSetString(hrec, 1, szName) != MSI_OKAY
			|| MsiRecordSetString(hrec, 2, szValue) != MSI_OKAY)
		{
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
		return (IDS_CANT_SET_RECORD_FIELD);
		}

	return (IdsMsiSetTableRecord(hdb, TEXT("`Property`"), TEXT("`Property`,`Value`"), TEXT("`Property`"), szName, hrec));
}


/* return value does NOT include terminating null; zero if error */
/* ********************************************************************** */
UI