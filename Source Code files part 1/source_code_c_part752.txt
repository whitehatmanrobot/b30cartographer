FO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNumLicenseCodes )( 
            ISBSLicensing * This,
            INT *pNumLicenseCodes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNumLicenses )( 
            ISBSLicensing * This,
            INT *pNumLicenses);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InBypassMode )( 
            ISBSLicensing * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ValidateProductKey )( 
            ISBSLicensing * This,
            BSTR bszProductKey,
            INT *piNumLicenses);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSingleLicenseHistory )( 
            ISBSLicensing * This,
            UINT uiIndex,
            BSTR *pbszProductKey,
            INT *piNumLicenses,
            SYSTEMTIME *pstActivationDate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMaxLicenseUsage )( 
            ISBSLicensing * This,
            UINT *puiMaxLicenseUsage);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ActivateUsingInternet )( 
            ISBSLicensing * This,
            WCHAR *wszPid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateInstallationId )( 
            ISBSLicensing * This,
            BSTR bszProductKey,
            BSTR *pbszInstallationId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DepositConfirmationId )( 
            ISBSLicensing * This,
            BSTR bszProductKey,
            BSTR bszConfirmationId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BackupLicenseStore )( 
            ISBSLicensing * This,
            WCHAR *wszFilename);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreLicenseStore )( 
            ISBSLicensing * This,
            WCHAR *wszFilename);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsLicenseStoreValid )( 
            ISBSLicensing * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OverwriteLicenseStore )( 
            ISBSLicensing * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreRegKeys )( 
            ISBSLicensing * This,
            INT iNumLicenses);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetCustomData )( 
            ISBSLicensing * This,
            INT iField,
            BSTR bszData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCustomData )( 
            ISBSLicensing * This,
            INT iField,
            BSTR *pbszData);
        
        END_INTERFACE
    } ISBSLicensingVtbl;

    interface ISBSLicensing
    {
        CONST_VTBL struct ISBSLicensingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBSLicensing_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISBSLicensing_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISBSLicensing_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISBSLicensing_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISBSLicensing_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISBSLicensing_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISBSLicensing_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISBSLicensing_GetNumLicenseCodes(This,pNumLicenseCodes)	\
    (This)->lpVtbl -> GetNumLicenseCodes(This,pNumLicenseCodes)

#define ISBSLicensing_GetNumLicenses(This,pNumLicenses)	\
    (This)->lpVtbl -> GetNumLicenses(This,pNumLicenses)

#define ISBSLicensing_InBypassMode(This)	\
    (This)->lpVtbl -> InBypassMode(This)

#define ISBSLicensing_ValidateProductKey(This,bszProductKey,piNumLicenses)	\
    (This)->lpVtbl -> ValidateProductKey(This,bszProductKey,piNumLicenses)

#define ISBSLicensing_GetSingleLicenseHistory(This,uiIndex,pbszProductKey,piNumLicenses,pstActivationDate)	\
    (This)->lpVtbl -> GetSingleLicenseHistory(This,uiIndex,pbszProductKey,piNumLicenses,pstActivationDate)

#define ISBSLicensing_GetMaxLicenseUsage(This,puiMaxLicenseUsage)	\
    (This)->lpVtbl -> GetMaxLicenseUsage(This,puiMaxLicenseUsage)

#define ISBSLicensing_ActivateUsingInternet(This,wszPid)	\
    (This)->lpVtbl -> ActivateUsingInternet(This,wszPid)

#define ISBSLicensing_GenerateInstallationId(This,bszProductKey,pbszInstallationId)	\
    (This)->lpVtbl -> GenerateInstallationId(This,bszProductKey,pbszInstallationId)

#define ISBSLicensing_DepositConfirmationId(This,bszProductKey,bszConfirmationId)	\
    (This)->lpVtbl -> DepositConfirmationId(This,bszProductKey,bszConfirmationId)

#define ISBSLicensing_BackupLicenseStore(This,wszFilename)	\
    (This)->lpVtbl -> BackupLicenseStore(This,wszFilename)

#define ISBSLicensing_RestoreLicenseStore(This,wszFilename)	\
    (This)->lpVtbl -> RestoreLicenseStore(This,wszFilename)

#define ISBSLicensing_IsLicenseStoreValid(This)	\
    (This)->lpVtbl -> IsLicenseStoreValid(This)

#define ISBSLicensing_OverwriteLicenseStore(This)	\
    (This)->lpVtbl -> OverwriteLicenseStore(This)

#define ISBSLicensing_RestoreRegKeys(This,iNumLicenses)	\
    (This)->lpVtbl -> RestoreRegKeys(This,iNumLicenses)

#define ISBSLicensing_SetCustomData(This,iField,bszData)	\
    (This)->lpVtbl -> SetCustomData(This,iField,bszData)

#define ISBSLicensing_GetCustomData(This,iField,pbszData)	\
    (This)->lpVtbl -> GetCustomData(This,iField,pbszData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_GetNumLicenseCodes_Proxy( 
    ISBSLicensing * This,
    INT *pNumLicenseCodes);


void __RPC_STUB ISBSLicensing_GetNumLicenseCodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_GetNumLicenses_Proxy( 
    ISBSLicensing * This,
    INT *pNumLicenses);


void __RPC_STUB ISBSLicensing_GetNumLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_InBypassMode_Proxy( 
    ISBSLicensing * This);


void __RPC_STUB ISBSLicensing_InBypassMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_ValidateProductKey_Proxy( 
    ISBSLicensing * This,
    BSTR bszProductKey,
    INT *piNumLicenses);


void __RPC_STUB ISBSLicensing_ValidateProductKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_GetSingleLicenseHistory_Proxy( 
    ISBSLicensing * This,
    UINT uiIndex,
    BSTR *pbszProductKey,
    INT *piNumLicenses,
    SYSTEMTIME *pstActivationDate);


void __RPC_STUB ISBSLicensing_GetSingleLicenseHistory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_GetMaxLicenseUsage_Proxy( 
    ISBSLicensing * This,
    UINT *puiMaxLicenseUsage);


void __RPC_STUB ISBSLicensing_GetMaxLicenseUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_ActivateUsingInternet_Proxy( 
    ISBSLicensing * This,
    WCHAR *wszPid);


void __RPC_STUB ISBSLicensing_ActivateUsingInternet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_GenerateInstallationId_Proxy( 
    ISBSLicensing * This,
    BSTR bszProductKey,
    BSTR *pbszInstallationId);


void __RPC_STUB ISBSLicensing_GenerateInstallationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_DepositConfirmationId_Proxy( 
    ISBSLicensing * This,
    BSTR bszProductKey,
    BSTR bszConfirmationId);


void __RPC_STUB ISBSLicensing_DepositConfirmationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_BackupLicenseStore_Proxy( 
    ISBSLicensing * This,
    WCHAR *wszFilename);


void __RPC_STUB ISBSLicensing_BackupLicenseStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_RestoreLicenseStore_Proxy( 
    ISBSLicensing * This,
    WCHAR *wszFilename);


void __RPC_STUB ISBSLicensing_RestoreLicenseStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_IsLicenseStoreValid_Proxy( 
    ISBSLicensing * This);


void __RPC_STUB ISBSLicensing_IsLicenseStoreValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_OverwriteLicenseStore_Proxy( 
    ISBSLicensing * This);


void __RPC_STUB ISBSLicensing_OverwriteLicenseStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_RestoreRegKeys_Proxy( 
    ISBSLicensing * This,
    INT iNumLicenses);


void __RPC_STUB ISBSLicensing_RestoreRegKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_SetCustomData_Proxy( 
    ISBSLicensing * This,
    INT iField,
    BSTR bszData);


void __RPC_STUB ISBSLicensing_SetCustomData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISBSLicensing_GetCustomData_Proxy( 
    ISBSLicensing * This,
    INT iField,
    BSTR *pbszData);


void __RPC_STUB ISBSLicensing_GetCustomData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISBSLicensing_INTERFACE_DEFINED__ */



#ifndef __SBSLICENSINGLib_LIBRARY_DEFINED__
#define __SBSLICENSINGLib_LIBRARY_DEFINED__

/* library SBSLICENSINGLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_SBSLICENSINGLib;

EXTERN_C const CLSID CLSID_SBSLicensing;

#ifdef __cplusplus

class DECLSPEC_UUID("2469B4DF-C6AE-48CC-9C51-0E85DEE17243")
SBSLicensing;
#endif
#endif /* __SBSLICENSINGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\scioctl.h ===
/*

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    scioctl.h

Abstract:

    This module defines the I/O control codes used to redirect the Smart Card Subsystem
    for Terminal Services.

Revision History:

--*/

#define SCARD_IOCTL_SMARTCARD_ONLINE           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 1,  METHOD_BUFFERED, FILE_ANY_ACCESS)

#define SCARD_IOCTL_ESTABLISHCONTEXT           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 5,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_RELEASECONTEXT             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 6,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ISVALIDCONTEXT             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 7,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LISTREADERGROUPSA          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 8,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LISTREADERGROUPSW          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 9,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LISTREADERSA               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LISTREADERSW               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_INTRODUCEREADERGROUPA      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_INTRODUCEREADERGROUPW      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_FORGETREADERGROUPA         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_FORGETREADERGROUPW         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_INTRODUCEREADERA           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_INTRODUCEREADERW           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_FORGETREADERA              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_FORGETREADERW              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ADDREADERTOGROUPA          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ADDREADERTOGROUPW          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_REMOVEREADERFROMGROUPA     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_REMOVEREADERFROMGROUPW     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 31,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LOCATECARDSA               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LOCATECARDSW               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_GETSTATUSCHANGEA           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_GETSTATUSCHANGEW           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_CANCEL                     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_CONNECTA                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_CONNECTW                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_RECONNECT                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_DISCONNECT                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_BEGINTRANSACTION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ENDTRANSACTION             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_STATE                      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_STATUSA                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_STATUSW                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_TRANSMIT                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_CONTROL                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_GETATTRIB                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_SETATTRIB                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ACCESSSTARTEDEVENT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_RELEASETARTEDEVENT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LOCATECARDSBYATRA          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LOCATECARDSBYATRW          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\scesetup.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scesetup.h

Abstract:

    This module defines the exported data structures for system setup and
    network/oem/component setup

Author:

    Jin Huang (jinhuang) 21-Aug-1997

Revision History:

--*/

#ifndef _scesetup_
#define _scesetup_

#ifdef __cplusplus
extern "C"{
#endif

#include "setupapi.h"

#ifndef SCE_AREA_DEFINED
#define SCE_AREA_DEFINED

typedef DWORD  AREA_INFORMATION;

#define AREA_SECURITY_POLICY     0x0001L
#define AREA_USER_SETTINGS       0x0002L
#define AREA_GROUP_MEMBERSHIP    0x0004L
#define AREA_PRIVILEGES          0x0008L
#define AREA_DS_OBJECTS          0x0010L
#define AREA_REGISTRY_SECURITY   0x0020L
#define AREA_FILE_SECURITY       0x0040L
#define AREA_SYSTEM_SERVICE      0x0080L
#define AREA_ATTACHMENTS         0x8000L
#define AREA_ALL                 0xFFFFL

#endif

typedef
BOOL(CALLBACK *PSCE_NOTIFICATION_CALLBACK_ROUTINE)(
    IN HANDLE NotificationHandle,
    IN UINT   NotificationCode,
    IN UINT   NotificationSpecificValue,
    IN LPARAM lParam
    );

#define SCESETUP_CONFIGURE_SECURITY     0x0
#define SCESETUP_UPGRADE_SYSTEM         0x1
#define SCESETUP_UPDATE_FILE_KEY        0x2
#define SCESETUP_QUERY_TICKS            0x4
#define SCESETUP_RECONFIG_SECURITY      0x8
#define SCESETUP_BIND_NO_AUTH           0x80

#define SCESETUP_NOTIFICATION_TICKS     1

DWORD
WINAPI
SceSetupSystemByInfName(
    IN PWSTR InfFullName,
    IN PCWSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area,
    IN UINT nFlag,
    IN PSCE_NOTIFICATION_CALLBACK_ROUTINE pSceNotificationCallBack OPTIONAL,
    IN OUT PVOID pValue OPTIONAL
    );

DWORD
WINAPI
SceSetupUpdateSecurityFile(
    IN PWSTR FileFullName,
    IN UINT nFlag,
    IN PWSTR SDText
    );

DWORD
WINAPI
SceSetupMoveSecurityFile(
    IN PWSTR FileToSetSecurity,
    IN PWSTR FileToSaveInDB OPTIONAL,
    IN PWSTR SDText OPTIONAL
    );

DWORD
WINAPI
SceSetupUnwindSecurityFile(
    IN PWSTR FileFullName,
    IN PSECURITY_DESCRIPTOR pSDBackup
    );

DWORD
WINAPI
SceSetupUpdateSecurityKey(
    IN HKEY hKeyRoot,
    IN PWSTR KeyPath,
    IN UINT nFlag,
    IN PWSTR SDText
    );

DWORD
WINAPI
SceSetupUpdateSecurityService(
     IN PWSTR ServiceName,
     IN DWORD StartType,
     IN PWSTR SDText
     );

DWORD
WINAPI
SceSetupBackupSecurity(
    IN LPTSTR LogFileName OPTIONAL   // default to %windir%\security\logs\backup.log
    );

DWORD
WINAPI
SceSetupConfigureServices(
    IN UINT SetupProductType
    );

typedef
DWORD(CALLBACK *PSCE_PROMOTE_CALLBACK_ROUTINE)(
    IN PWSTR StringUpdate
    );

#define SCE_DCPROMO_LOG_PATH    TEXT("%windir%\\security\\logs\\scedcpro.log")

#define SCE_PROMOTE_FLAG_UPGRADE        0x01L
#define SCE_PROMOTE_FLAG_REPLICA        0x02L
#define SCE_PROMOTE_FLAG_DEMOTE         0x04L

DWORD
WINAPI
SceDcPromoteSecurity(
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

DWORD
WINAPI
SceDcPromoteSecurityEx(
    IN HANDLE ClientToken,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

#define STR_DEFAULT_DOMAIN_GPO_GUID                 TEXT("31B2F340-016D-11D2-945F-00C04FB984F9")
#define STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID      TEXT("6AC1786C-016F-11D2-945F-00C04fB984F9")

DWORD
WINAPI
SceDcPromoCreateGPOsInSysvol(
    IN LPTSTR DomainDnsName,
    IN LPTSTR SysvolRoot,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

DWORD
WINAPI
SceDcPromoCreateGPOsInSysvolEx(
    IN HANDLE ClientToken,
    IN LPTSTR DomainDnsName,
    IN LPTSTR SysvolRoot,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

DWORD
WINAPI
SceSetupRootSecurity();

DWORD
WINAPI
SceEnforceSecurityPolicyPropagation();

/*
NTSTATUS
WINAPI
SceNotifyPolicyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER SerialNumber,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA MemberId
    );
*/
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\sclogon.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ScLogon

Abstract:

    This header defines APIs for use by GINA and LSA during WinLogon via a
    smart card

Author:

    Amanda Matlosz (amatlosz) 10/23/1997

Environment:

    Win32

Revision History:

Notes:

--*/

#ifndef __SCLOGON_H__
#define __SCLOGON_H__

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// defines
#ifndef NT_INCLUDED
    typedef LONG NTSTATUS;
    typedef NTSTATUS *PNTSTATUS;

    typedef struct _UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;
#endif


//////////////////////////////////////////////////////////////////////////////
//
// Structs


// this entire struct is opaque, and is used by the helper APIs to contain
// information about the card currently in use
struct LogonInfo
{
    DWORD dwLogonInfoLen;
    PVOID ContextInformation;
    ULONG nCardNameOffset;
    ULONG nReaderNameOffset;
    ULONG nContainerNameOffset;
    ULONG nCSPNameOffset;

    // LogonInfo may include further information, like:
    // crypt context, useful handles, pid...

    TCHAR bBuffer[sizeof(DWORD)]; // expandable place for strings
};


typedef struct _ScHelper_RandomCredBits
{
        BYTE bR1[32]; // TBD: is 32 appropriate?
        BYTE bR2[32];
} ScHelper_RandomCredBits;

//////////////////////////////////////////////////////////////////////////////
//
// Functions
//

// helpers to access to items in opaque LogonInfo, such as:
LPCTSTR WINAPI GetReaderName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetCardName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetContainerName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetCSPName(PBYTE pbLogonInfo);

// Helper for error translations
NTSTATUS ScNtStatusTranslation(NTSTATUS NtErr, DWORD *pdwErr);

//
// Calls used by GINA to construct the blob that kerberos
// and sclogon share.
//

PBYTE
WINAPI
ScBuildLogonInfo(
    LPCTSTR szCard,
    LPCTSTR szReader,
    LPCTSTR szContainer,
    LPCTSTR szCSP);

//
// Calls used by LSA
//

NTSTATUS WINAPI
ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    );

VOID WINAPI
ScHelperRelease(
    IN PBYTE ppbLogonInfo
    );

NTSTATUS WINAPI
ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    );


// ScHelperGetCertFromLogonInfo may need the PIN to get a cert off certain SCs
NTSTATUS WINAPI
ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT * CertificateContext
    );


// ScHelperVerifyCard uses SignMessage() and VerifyMessage() to verify the
// card's integrity (that it has the keys it says it has)
NTSTATUS WINAPI
ScHelperVerifyCard(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo
    );

// ScHelper*Cred* functions provide for a more secure offline experience

NTSTATUS WINAPI
ScHelperGenRandBits
(
        IN PBYTE pbLogonInfo,
        IN ScHelper_RandomCredBits* psc_rcb
);

NTSTATUS WINAPI
ScHelperCreateCredKeys
(
    IN PUNICODE_STRING pucPIN,
        IN PBYTE pbLogonInfo,
        IN ScHelper_RandomCredBits* psc_rcb,
        IN OUT HCRYPTKEY* phHmacKey,
        IN OUT HCRYPTKEY* phRc4Key,
        IN OUT HCRYPTPROV* phProv
);

NTSTATUS WINAPI
ScHelperCreateCredHMAC
(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hHmacKey,
        IN PBYTE CleartextData,
        IN ULONG CleartextDataSize,
        IN OUT PBYTE* ppbHmac,
        IN OUT DWORD* pdwHmacLen
);

NTSTATUS WINAPI
ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE SignedEncryptedData,
    IN ULONG SignedEncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    );

NTSTATUS WINAPI
ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize
    );

NTSTATUS WINAPI
ScHelperDecryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    );


//
// The following two functions may be called in any order, and return a basic
// "success" or "failure"
//
// ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
// that will do the signing...
//
NTSTATUS WINAPI
ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    );

NTSTATUS WINAPI
ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN OPTIONAL DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    );

//
// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.
//

NTSTATUS WINAPI
ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    );

NTSTATUS WINAPI
ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    );


//
// ScHelperEncryptMessage and ScHelperDecryptMessage
// encrypt and decrypt buffer/cipher text using PKCS7 crypto stuff.
//
NTSTATUS WINAPI
ScHelperEncryptMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN PBYTE Buffer,                        // The data to encrypt
    IN ULONG BufferLength,                  // The length of that data
    OUT PBYTE CipherText,                   // Receives the formatted CipherText
    IN PULONG pCipherLength                 // Supplies size of CipherText buffer
    );                                       // Receives length of actual CipherText

NTSTATUS WINAPI
ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    );


/////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif

#endif // __SCLOGON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\sclgntfy.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    sclgntfy.h

Abstract:

    This module defines the exported function prototype
    for generating the EFS recovery policy.
    
Author:

    Tarek Kamel (tarekk) April-2002

Revision History:

--*/

#ifndef _sclgntfy_h_
#define _sclgntfy_h_

#include <wincrypt.h>

#ifdef __cplusplus
extern "C"{
#endif

DWORD
WINAPI
GenerateDefaultEFSRecoveryPolicy(
    OUT PUCHAR *pRecoveryPolicyBlob,
    OUT ULONG *pBlobSize,
    OUT PCCERT_CONTEXT *ppCertContext
    );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\sddlp.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    sddlp.h

Abstract:

    This module defines private headers for SDDL conversions routines

Revision History:

--*/

#include <sddl.h>

#ifndef __SDDLP_H__
#define __SDDLP_H__


#ifdef __cplusplus
extern "C" {
#endif

#if(_WIN32_WINNT >= 0x0500)

WINADVAPI
BOOL
WINAPI
ConvertStringSDToSDRootDomainA(
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

WINADVAPI
BOOL
WINAPI
ConvertStringSDToSDRootDomainW(
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

#ifdef UNICODE
#define ConvertStringSDToSDRootDomain  ConvertStringSDToSDRootDomainW
#else
#define ConvertStringSDToSDRootDomain  ConvertStringSDToSDRootDomainA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ConvertSDToStringSDRootDomainA(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );

WINADVAPI
BOOL
WINAPI
ConvertSDToStringSDRootDomainW(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );


#ifdef UNICODE
#define ConvertSDToStringSDRootDomain  ConvertSDToStringSDRootDomainW
#else
#define ConvertSDToStringSDRootDomain  ConvertSDToStringSDRootDomainA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ConvertStringSDToSDDomainA(
    IN  PSID DomainSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

WINADVAPI
BOOL
WINAPI
ConvertStringSDToSDDomainW(
    IN  PSID DomainSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

NTSTATUS
SddlpAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString
    );

#ifdef UNICODE
#define ConvertStringSDToSDDomain  ConvertStringSDToSDDomainW
#else
#define ConvertStringSDToSDDomain  ConvertStringSDToSDDomainA
#endif // !UNICODE

#endif /* _WIN32_WINNT >=  0x0500 */

#ifdef __cplusplus
}
#endif
#endif  // endif __SDDLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\secedit.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    secedit.h

Abstract:

    This module defines the exported data structures and function prototypes
    for the security managment utility

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#ifndef _secedit_
#define _secedit_

#ifdef __cplusplus
extern "C"{
#endif

//
// definition for areas
//
#ifndef SCE_AREA_DEFINED
#define SCE_AREA_DEFINED
typedef DWORD  AREA_INFORMATION;

#define AREA_SECURITY_POLICY     0x0001L
#define AREA_USER_SETTINGS       0x0002L
#define AREA_GROUP_MEMBERSHIP    0x0004L
#define AREA_PRIVILEGES          0x0008L
#define AREA_DS_OBJECTS          0x0010L
#define AREA_REGISTRY_SECURITY   0x0020L
#define AREA_FILE_SECURITY       0x0040L
#define AREA_SYSTEM_SERVICE      0x0080L
#define AREA_ATTACHMENTS         0x8000L
#define AREA_ALL                 0xFFFFL

#endif
//
// Other constants
//
#define AREA_PASSWORD_POLICY     0x0100L
#define AREA_LOCKOUT_POLICY      0x0200L
#define AREA_KERBEROS_POLICY     0x0400L
#define AREA_ACCOUNT_POLICY      (AREA_PASSWORD_POLICY | \
                                  AREA_LOCKOUT_POLICY | \
                                  AREA_KERBEROS_POLICY)

#define AREA_AUDIT_POLICY        0x0800L
#define AREA_SECURITY_OPTIONS    0x1000L
#define AREA_LOCAL_POLICY        (AREA_AUDIT_POLICY |\
                                  AREA_PRIVILEGES |\
                                  AREA_SECURITY_OPTIONS)

#define AREA_LOG_POLICY          0x2000L


#define SCE_STATUS_CHECK             0
#define SCE_STATUS_IGNORE            1
#define SCE_STATUS_OVERWRITE         2
#define SCE_STATUS_NO_AUTO_INHERIT   4

#define SCE_STATUS_IN                0
#define SCE_STATUS_NOT_IN            1

#define SCE_STATUS_NO_ACL_SUPPORT        3

#define SCE_STATUS_GOOD                  0
#define SCE_STATUS_MISMATCH              1
#define SCE_STATUS_CHILDREN_CONFIGURED   2
#define SCE_STATUS_NOT_CONFIGURED        4
#define SCE_STATUS_ERROR_NOT_AVAILABLE   5
#define SCE_STATUS_NEW_SERVICE           6
#define SCE_STATUS_NOT_ANALYZED          7

#define SCE_STATUS_PERMISSION_MISMATCH   0x40
#define SCE_STATUS_AUDIT_MISMATCH        0x80

#define SCE_SETUP_32KEY   0x2000L
#ifndef _WIN64
#define SCE_SETUP_64KEY   0x4000L
#endif // _WIN64

typedef enum _SCE_TYPE {

    SCE_ENGINE_SYSTEM=300,
    SCE_ENGINE_GPO,
    SCE_ENGINE_SCP,         // effective table
    SCE_ENGINE_SAP,         // analysis table
    SCE_ENGINE_SCP_INTERNAL,
    SCE_ENGINE_SMP_INTERNAL,
    SCE_ENGINE_SMP,         // local table
    SCE_STRUCT_INF,
    SCE_STRUCT_PROFILE,
    SCE_STRUCT_USER,
    SCE_STRUCT_NAME_LIST,
    SCE_STRUCT_NAME_STATUS_LIST,
    SCE_STRUCT_PRIVILEGE,
    SCE_STRUCT_GROUP,
    SCE_STRUCT_OBJECT_LIST,
    SCE_STRUCT_OBJECT_CHILDREN,
    SCE_STRUCT_OBJECT_SECURITY,
    SCE_STRUCT_OBJECT_ARRAY,
    SCE_STRUCT_ERROR_LOG_INFO,
    SCE_STRUCT_SERVICES,
    SCE_STRUCT_PRIVILEGE_VALUE_LIST,
    SCE_ENGINE_RBK

} SCETYPE;

typedef enum _SCE_FORMAT_TYPE_ {

    SCE_INF_FORMAT=1,
    SCE_JET_FORMAT,
    SCE_JET_ANALYSIS_REQUIRED

} SCE_FORMAT_TYPE, *PSCE_FORMAT_TYPE;

static const WCHAR szMembers[]             = L"__Members";
static const WCHAR szMemberof[]            = L"__Memberof";
static const WCHAR szPrivileges[]          = L"__Privileges";

#define SCE_BUF_LEN              1024

#define SCE_FOREVER_VALUE        (DWORD)-1
#define SCE_NO_VALUE             (DWORD)-2
#define SCE_KERBEROS_OFF_VALUE   (DWORD)-3
#define SCE_DELETE_VALUE         (DWORD)-4
#define SCE_SNAPSHOT_VALUE       (DWORD)-5
#define SCE_NOT_ANALYZED_VALUE   (DWORD)-6
#define SCE_ERROR_VALUE          (DWORD)-7

#ifndef _SCE_SHARED_HEADER
#define _SCE_SHARED_HEADER

typedef DWORD                   SCESTATUS;

#define SCESTATUS_SUCCESS              0L
#define SCESTATUS_INVALID_PARAMETER    1L
#define SCESTATUS_RECORD_NOT_FOUND     2L
#define SCESTATUS_INVALID_DATA         3L
#define SCESTATUS_OBJECT_EXIST         4L
#define SCESTATUS_BUFFER_TOO_SMALL     5L
#define SCESTATUS_PROFILE_NOT_FOUND    6L
#define SCESTATUS_BAD_FORMAT           7L
#define SCESTATUS_NOT_ENOUGH_RESOURCE  8L
#define SCESTATUS_ACCESS_DENIED        9L
#define SCESTATUS_CANT_DELETE          10L
#define SCESTATUS_PREFIX_OVERFLOW      11L
#define SCESTATUS_OTHER_ERROR          12L
#define SCESTATUS_ALREADY_RUNNING      13L
#define SCESTATUS_SERVICE_NOT_SUPPORT  14L
#define SCESTATUS_MOD_NOT_FOUND        15L
#define SCESTATUS_EXCEPTION_IN_SERVER  16L
#define SCESTATUS_NO_TEMPLATE_GIVEN    17L
#define SCESTATUS_NO_MAPPING           18L
#define SCESTATUS_TRUST_FAIL           19L
#define SCESTATUS_JET_DATABASE_ERROR   20L
#define SCESTATUS_TIMEOUT              21L
#define SCESTATUS_PENDING_IGNORE       22L
#define SCESTATUS_SPECIAL_ACCOUNT      23L

//
// defined for services
//
typedef struct _SCESVC_CONFIGURATION_LINE_ {

    LPTSTR  Key;
    LPTSTR  Value;
    DWORD   ValueLen; // number of bytes

} SCESVC_CONFIGURATION_LINE, *PSCESVC_CONFIGURATION_LINE;

typedef struct _SCESVC_CONFIGURATION_INFO_ {

    DWORD   Count;
    PSCESVC_CONFIGURATION_LINE Lines;

} SCESVC_CONFIGURATION_INFO, *PSCESVC_CONFIGURATION_INFO;

typedef PVOID SCE_HANDLE;
typedef ULONG SCE_ENUMERATION_CONTEXT, *PSCE_ENUMERATION_CONTEXT;

#define SCESVC_ENUMERATION_MAX  100L

typedef enum _SCESVC_INFO_TYPE {

    SceSvcConfigurationInfo,
    SceSvcMergedPolicyInfo,
    SceSvcAnalysisInfo,
    SceSvcInternalUse                   // !!!do not use this type!!!

} SCESVC_INFO_TYPE;

// root path for SCE key
#define SCE_ROOT_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SeCEdit")

#define SCE_ROOT_SERVICE_PATH   \
            SCE_ROOT_PATH TEXT("\\SvcEngs")
#endif

//
// All section names defined in the SCP/SAP profiles.
//

static const WCHAR szDescription[]             = L"Profile Description";
static const WCHAR szAttachments[]             = L"Attachment Sections";
static const WCHAR szSystemAccess[]            = L"System Access";
static const WCHAR szPrivilegeRights[]         = L"Privilege Rights";
static const WCHAR szGroupMembership[]         = L"Group Membership";
static const WCHAR szAccountProfiles[]         = L"Account Profiles";
static const WCHAR szRegistryKeys[]            = L"Registry Keys";
static const WCHAR szFileSecurity[]            = L"File Security";
static const WCHAR szDSSecurity[]              = L"DS Security";
static const WCHAR szAuditSystemLog[]          = L"System Log";
static const WCHAR szAuditSecurityLog[]        = L"Security Log";
static const WCHAR szAuditApplicationLog[]     = L"Application Log";
static const WCHAR szAuditEvent[]              = L"Event Audit";
static const WCHAR szUserList[]                = L"User List";
static const WCHAR szServiceGeneral[]          = L"Service General Setting";
static const WCHAR szKerberosPolicy[]          = L"Kerberos Policy";
static const WCHAR szRegistryValues[]          = L"Registry Values";


//
// A list of names (e.g., users, groups, machines, and etc)
//

typedef struct _SCE_NAME_LIST {
    PWSTR                  Name;
    struct _SCE_NAME_LIST   *Next;
}SCE_NAME_LIST, *PSCE_NAME_LIST;

//
// a list of accounts with privileges held
//
typedef struct _SCE_PRIVILEGE_VALUE_LIST {
    PWSTR                  Name;
    DWORD                  PrivLowPart;
    DWORD                  PrivHighPart;
    struct _SCE_PRIVILEGE_VALUE_LIST   *Next;
}SCE_PRIVILEGE_VALUE_LIST, *PSCE_PRIVILEGE_VALUE_LIST;

//
// structure for error info
//

typedef struct _SCE_ERROR_LOG_INFO{
    PWSTR  buffer;
    DWORD   rc;
    struct _SCE_ERROR_LOG_INFO *next;
} SCE_ERROR_LOG_INFO, *PSCE_ERROR_LOG_INFO;

//
// The privileges/rights each user/group holds are saved into a INT field -
// PrivilegeRights. The first bit in this field is the first right defined
// in the SCE_Privileges array as above. The second bit is the second right
// defined in that array, and so on.
//
#define cPrivCnt    39
#define cPrivW2k    34

typedef struct _SCE_PRIVILEGE_ASSIGNMENT {
    PWSTR                           Name;
    DWORD                           Value;
    // This value could be translated by SceLookupPrivByValue
    // The reason we define another set of privilege values is
    // we include both privilege and user rights into one set
    // (user rights do not have priv value on NT system).
    PSCE_NAME_LIST                   AssignedTo;
    // SCE_STATUS_GOOD
    // SCE_STATUS_MISMATCH
    // SCE_STATUS_NOT_CONFIGURED
    // SCE_DELETE_VALUE indicates that this priv is deleted from local table
    DWORD                           Status;
    struct _SCE_PRIVILEGE_ASSIGNMENT *Next;
} SCE_PRIVILEGE_ASSIGNMENT, *PSCE_PRIVILEGE_ASSIGNMENT;

//
// A list of log on hours range
//

typedef struct _SCE_LOGON_HOUR {
    DWORD                  Start;
    DWORD                  End;
    struct _SCE_LOGON_HOUR  *Next;
}SCE_LOGON_HOUR, *PSCE_LOGON_HOUR;

//
// A list of names (e.g., users, groups, machines, and etc)
// with a status (e.g., disabled )
//

typedef struct _SCE_NAME_STATUS_LIST {
    PWSTR                       Name;
    DWORD                       Status;
    struct _SCE_NAME_STATUS_LIST *Next;
}SCE_NAME_STATUS_LIST, *PSCE_NAME_STATUS_LIST;

//
// Structure definition for service list (service dll)
//


#define SCE_STARTUP_BOOT             0x00
#define SCE_STARTUP_SYSTEM           0x01
#define SCE_STARTUP_AUTOMATIC        0x02
#define SCE_STARTUP_MANUAL           0x03
#define SCE_STARTUP_DISABLED         0x04

typedef struct _SCE_SERVICES_ {
    PWSTR               ServiceName;
    PWSTR               DisplayName;

    BYTE                Status;
    BYTE                Startup;

    union {

        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        PWSTR                ServiceEngineName;

    } General;

    SECURITY_INFORMATION SeInfo;

    struct _SCE_SERVICES_ *Next;

}SCE_SERVICES, *PSCE_SERVICES;

//
// Group memberships
//

#define SCE_GROUP_STATUS_MEMBERS_MISMATCH      0x01
#define SCE_GROUP_STATUS_MEMBEROF_MISMATCH     0x02
#define SCE_GROUP_STATUS_NC_MEMBERS            0x04
#define SCE_GROUP_STATUS_NC_MEMBEROF           0x08
#define SCE_GROUP_STATUS_NOT_ANALYZED          0x10
#define SCE_GROUP_STATUS_ERROR_ANALYZED        0x20


typedef struct _SCE_GROUP_MEMBERSHIP {
    PWSTR                        GroupName;
    PSCE_NAME_LIST                pMembers;
    PSCE_NAME_LIST                pMemberOf;

    DWORD                         Status;
    //
    // pPrivilegesHeld is for analysis only.
    // The format of each entry in this list is:
    //    [PrivValue NULL] (directly assigned), or
    //    [PrivValue Name] (via group "Name")
    // To configure privileges, use AREA_PRIVILEGES area
    //
    // This PrivValue could be translated by SceLookupPrivByValue
    // The reason we define another set of privilege values is
    // we include both privilege and user rights into one set
    // (user rights do not have priv value on NT system).
    PSCE_NAME_STATUS_LIST         pPrivilegesHeld;
    struct _SCE_GROUP_MEMBERSHIP  *Next;
}SCE_GROUP_MEMBERSHIP, *PSCE_GROUP_MEMBERSHIP;

//
// Definition of Registry and file security
//

typedef struct _SCE_OBJECT_SECURITY {
    PWSTR   Name;
    BYTE    Status;
    BOOL    IsContainer;
    PSECURITY_DESCRIPTOR  pSecurityDescriptor;
    SECURITY_INFORMATION  SeInfo;
//    PWSTR   SDspec;
//    DWORD   SDsize;
}SCE_OBJECT_SECURITY, *PSCE_OBJECT_SECURITY;

//
// A list of objects (e.g., files, registry keys, and etc)
//

typedef struct _SCE_OBJECT_LIST {
    PWSTR                       Name;
    BYTE                        Status;
    // Status could be the status (mismatched/unknown) of the object
    // or, it could be a flag to ignore/check this ojbect
    //
    BOOL                        IsContainer;
    DWORD                       Count;
    //  Total count of mismatched/unknown objects under this object
    struct _SCE_OBJECT_LIST *Next;
}SCE_OBJECT_LIST, *PSCE_OBJECT_LIST;

typedef struct _SCE_OBJECT_ARRAY_ {

    DWORD               Count;
    PSCE_OBJECT_SECURITY *pObjectArray;

} SCE_OBJECT_ARRAY, *PSCE_OBJECT_ARRAY;

typedef union _SCE_OBJECTS_ {
    // for Jet databases
    PSCE_OBJECT_LIST      pOneLevel;
    // for Inf files
    PSCE_OBJECT_ARRAY     pAllNodes;
} SCE_OBJECTS, *PSCE_OBJECTS;

typedef struct _SCE_OBJECT_CHILDREN_NODE {

    PWSTR               Name;
    BYTE                Status;
    BOOL                IsContainer;
    DWORD               Count;

} SCE_OBJECT_CHILDREN_NODE, *PSCE_OBJECT_CHILDREN_NODE;

typedef struct _SCE_OBJECT_CHILDREN {

    DWORD               nCount;
    DWORD               MaxCount;
    PSCE_OBJECT_CHILDREN_NODE arrObject;

} SCE_OBJECT_CHILDREN, *PSCE_OBJECT_CHILDREN;

typedef struct _SCE_KERBEROS_TICKET_INFO_ {
    DWORD   MaxTicketAge;    // in hours (default 10), SCE_NO_VALUE, SCE_FOREVER_VALUE, no 0

    DWORD   MaxRenewAge;     // in days (default 7), SCE_NO_VALUE, SCE_FOREVER_VALUE, no 0

    DWORD   MaxServiceAge;   // in minutes (default 60), SCE_NO_VALUE, 10-MaxTicketAge
    DWORD   MaxClockSkew;    // in minutes (default 5), SCE_NO_VALUE

    // options
    DWORD   TicketValidateClient; // 0, 1, or SCE_NO_VALUE

    //
    // all other options are not configurable.
    //

} SCE_KERBEROS_TICKET_INFO, *PSCE_KERBEROS_TICKET_INFO;

typedef struct _SCE_REGISTRY_VALUE_INFO_ {
    LPTSTR  FullValueName;
    LPTSTR  Value;
    DWORD   ValueType;
    DWORD   Status;  // match, mismatch, not analyzed, error

} SCE_REGISTRY_VALUE_INFO, *PSCE_REGISTRY_VALUE_INFO;

//
// Profile structure
//
typedef struct _SCE_PROFILE_INFO {

// Type is used to free the structure by SceFreeMemory
    SCETYPE      Type;
//
// Area: System access
//
    DWORD       MinimumPasswordAge;
    DWORD       MaximumPasswordAge;
    DWORD       MinimumPasswordLength;
    DWORD       PasswordComplexity;
    DWORD       PasswordHistorySize;
    DWORD       LockoutBadCount;
    DWORD       ResetLockoutCount;
    DWORD       LockoutDuration;
    DWORD       RequireLogonToChangePassword;
    DWORD       ForceLogoffWhenHourExpire;
    PWSTR       NewAdministratorName;
    PWSTR       NewGuestName;
    DWORD       SecureSystemPartition;
    DWORD       ClearTextPassword;
    DWORD       LSAAnonymousNameLookup;
    union {
        struct {
            // Area : user settings (scp)
            PSCE_NAME_LIST   pAccountProfiles;
            // Area: privileges
            // Name field is the user/group name, Status field is the privilege(s)
            //     assigned to the user/group
            union {
//                PSCE_NAME_STATUS_LIST        pPrivilegeAssignedTo;
                PSCE_PRIVILEGE_VALUE_LIST   pPrivilegeAssignedTo;
                PSCE_PRIVILEGE_ASSIGNMENT    pInfPrivilegeAssignedTo;
            } u;
        } scp;
        struct {
            // Area: user settings (sap)
            PSCE_NAME_LIST        pUserList;
            // Area: privileges
            PSCE_PRIVILEGE_ASSIGNMENT    pPrivilegeAssignedTo;
        } sap;
        struct {
            // Area: user settings (smp)
            PSCE_NAME_LIST        pUserList;
            // Area: privileges
            // See sap structure for pPrivilegeAssignedTo
            PSCE_PRIVILEGE_ASSIGNMENT    pPrivilegeAssignedTo;
        } smp;
    } OtherInfo;

// Area: group membership
    PSCE_GROUP_MEMBERSHIP        pGroupMembership;

// Area: Registry
    SCE_OBJECTS            pRegistryKeys;

// Area: System Services
    PSCE_SERVICES                pServices;

// System storage
    SCE_OBJECTS            pFiles;
//
// ds object
//
    SCE_OBJECTS            pDsObjects;
//
// kerberos policy settings
//
    PSCE_KERBEROS_TICKET_INFO pKerberosInfo;
//
// System audit 0-system 1-security 2-application
//
    DWORD                 MaximumLogSize[3];
    DWORD                 AuditLogRetentionPeriod[3];
    DWORD                 RetentionDays[3];
    DWORD                 RestrictGuestAccess[3];
    DWORD                 AuditSystemEvents;
    DWORD                 AuditLogonEvents;
    DWORD                 AuditObjectAccess;
    DWORD                 AuditPrivilegeUse;
    DWORD                 AuditPolicyChange;
    DWORD                 AuditAccountManage;
    DWORD                 AuditProcessTracking;
    DWORD                 AuditDSAccess;
    DWORD                 AuditAccountLogon;
    DWORD                 CrashOnAuditFull;

//
// registry values
//
    DWORD                       RegValueCount;
    PSCE_REGISTRY_VALUE_INFO    aRegValues;
    DWORD                 EnableAdminAccount;
    DWORD                 EnableGuestAccount;

}SCE_PROFILE_INFO, *PSCE_PROFILE_INFO;

//
// The definition for security user profile which is used to assign common
// user settings to a group of users/groups in the security manager.
//

typedef struct _SCE_USER_PROFILE {
    SCETYPE     Type;
// Type is used to free the structure by SceFreeMemory
    DWORD      ForcePasswordChange;
    DWORD      DisallowPasswordChange;
    DWORD      NeverExpirePassword;
    DWORD      AccountDisabled;
    PWSTR      UserProfile;
    PWSTR      LogonScript;
    PWSTR      HomeDir;
    PSCE_LOGON_HOUR             pLogonHours;
    UNICODE_STRING             pWorkstations;
    PSCE_NAME_LIST              pGroupsBelongsTo;
    PSCE_NAME_LIST              pAssignToUsers;
    PSECURITY_DESCRIPTOR       pHomeDirSecurity;
    SECURITY_INFORMATION       HomeSeInfo;
    PSECURITY_DESCRIPTOR       pTempDirSecurity;
    SECURITY_INFORMATION       TempSeInfo;
} SCE_USER_PROFILE, *PSCE_USER_PROFILE;

//
// The definition for each user's setting
//

typedef struct _SCE_USER_SETTING {
    SCETYPE                  Type;
// Type is used to free the structure by SceFreeMemory
    DWORD                   ForcePasswordChange;
    DWORD                   DisallowPasswordChange;
    DWORD                   NeverExpirePassword;
    DWORD                   AccountDisabled;
    PSCE_NAME_LIST           pGroupsBelongsTo;
    PWSTR                   UserProfile;
    PSECURITY_DESCRIPTOR    pProfileSecurity;
    PWSTR                   LogonScript;
    PSECURITY_DESCRIPTOR    pLogonScriptSecurity;
    PWSTR                   HomeDir;
    PSECURITY_DESCRIPTOR    pHomeDirSecurity;
    SECURITY_INFORMATION    HomeDirSeInfo;
    PWSTR                   TempDir;
    PSECURITY_DESCRIPTOR    pTempDirSecurity;
    SECURITY_INFORMATION    TempDirSeInfo;
    PSCE_LOGON_HOUR          pLogonHours;
    UNICODE_STRING          pWorkstations;
    PSCE_NAME_STATUS_LIST    pPrivilegesHeld;
    DWORD                   BadPasswordAttempt;
} SCE_USER_SETTING, *PSCE_USER_SETTING;


//
// prototypes defined in sceclnt.cpp
//

SCESTATUS
WINAPI
SceGetSecurityProfileInfo(
    IN  PVOID               hProfile OPTIONAL,
    IN  SCETYPE             ProfileType,
    IN  AREA_INFORMATION    Area,
    IN OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
WINAPI
SceGetObjectChildren(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    OUT PSCE_OBJECT_CHILDREN *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
WINAPI
SceOpenProfile(
    IN PCWSTR ProfileName,
    IN SCE_FORMAT_TYPE  ProfileFormat,
    OUT PVOID *hProfile
    );

SCESTATUS
WINAPI
SceCloseProfile(
    IN PVOID *hProfile
    );

SCESTATUS
WINAPI
SceGetScpProfileDescription(
    IN PVOID hProfile,
    OUT PWSTR *Description
    );

SCESTATUS
WINAPI
SceGetTimeStamp(
    IN PVOID hProfile,
    OUT PWSTR *ConfigTimeStamp,
    OUT PWSTR *AnalyzeTimeStamp
    );

SCESTATUS
WINAPI
SceGetDbTime(
    IN PVOID hProfile,
    OUT SYSTEMTIME *ConfigTime,
    OUT SYSTEMTIME *AnalyzeTime
    );

SCESTATUS
WINAPI
SceGetObjectSecurity(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    OUT PSCE_OBJECT_SECURITY *ObjSecurity
    );

SCESTATUS
WINAPI
SceGetAnalysisAreaSummary(
    IN PVOID hProfile,
    IN AREA_INFORMATION Area,
    OUT PDWORD pCount
    );

SCESTATUS
WINAPI
SceCopyBaseProfile(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR InfFileName,
    IN AREA_INFORMATION Area,
    OUT PSCE_ERROR_LOG_INFO *pErrlog OPTIONAL
    );


#define SCE_OVERWRITE_DB        0x01L
#define SCE_UPDATE_DB           0x02L
#define SCE_CALLBACK_DELTA      0x04L
#define SCE_CALLBACK_TOTAL      0x08L
#define SCE_VERBOSE_LOG         0x10L
#define SCE_DISABLE_LOG         0x20L
#define SCE_NO_CONFIG           0x40L
#define SCE_DEBUG_LOG           0x80L

typedef
BOOL(CALLBACK *PSCE_AREA_CALLBACK_ROUTINE)(
    IN HANDLE CallbackHandle,
    IN AREA_INFORMATION Area,
    IN DWORD TotalTicks,
    IN DWORD CurrentTicks
    );

typedef
BOOL(CALLBACK *PSCE_BROWSE_CALLBACK_ROUTINE)(
    IN LONG GpoID,
    IN PWSTR KeyName OPTIONAL,
    IN PWSTR GpoName OPTIONAL,
    IN PWSTR Value OPTIONAL,
    IN DWORD Len
    );

SCESTATUS
WINAPI
SceConfigureSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    );

SCESTATUS
WINAPI
SceAnalyzeSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD AnalyzeOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    );

SCESTATUS
WINAPI
SceGenerateRollback(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName,
    IN PCWSTR InfRollback,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD Options,
    IN AREA_INFORMATION Area,
    OUT PDWORD pdWarning OPTIONAL
    );

#define SCE_UPDATE_LOCAL_POLICY     0x1L
#define SCE_UPDATE_DIRTY_ONLY       0x2L
#define SCE_UPDATE_SYSTEM           0x4L

SCESTATUS
WINAPI
SceUpdateSecurityProfile(
    IN PVOID hProfile OPTIONAL,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD dwMode
    );

SCESTATUS
WINAPI
SceUpdateObjectInfo(
    IN PVOID hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    IN DWORD NameLen, // number of characters
    IN BYTE ConfigStatus,
    IN BOOL  IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    );

SCESTATUS
WINAPI
SceStartTransaction(
    IN PVOID cxtProfile
    );

SCESTATUS
WINAPI
SceCommitTransaction(
    IN PVOID cxtProfile
    );

SCESTATUS
WINAPI
SceRollbackTransaction(
    IN PVOID cxtProfile
    );

typedef enum _SCE_SERVER_TYPE_ {

   SCESVR_UNKNOWN = 0,
   SCESVR_DC_WITH_DS,
   SCESVR_DC,
   SCESVR_NT5_SERVER,
   SCESVR_NT4_SERVER,
   SCESVR_NT5_WKS,
   SCESVR_NT4_WKS

} SCE_SERVER_TYPE, *PSCE_SERVER_TYPE;

SCESTATUS
WINAPI
SceGetServerProductType(
   IN LPTSTR SystemName OPTIONAL,
   OUT PSCE_SERVER_TYPE pServerType
   );

SCESTATUS
WINAPI
SceLookupPrivRightName(
    IN INT Priv,
    OUT PWSTR Name,
    OUT PINT NameLen
    );

SCESTATUS
WINAPI
SceSvcUpdateInfo(
    IN PVOID       hProfile,
    IN PCWSTR      ServiceName,
    IN PSCESVC_CONFIGURATION_INFO Info
    );

//
// prototype defined in infget.c
//

SCESTATUS
WINAPI
SceSvcGetInformationTemplate(
    IN LPCTSTR              TemplateName,
    IN LPCTSTR              ServiceName,
    IN LPCTSTR              Key OPTIONAL,
    OUT PSCESVC_CONFIGURATION_INFO   *ServiceInfo
    );

//
// prototypes defined in infwrite.c
//
SCESTATUS
WINAPI
SceWriteSecurityProfileInfo(
    IN  PCWSTR             InfProfileName,
    IN  AREA_INFORMATION   Area,
    IN  PSCE_PROFILE_INFO   ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
WINAPI
SceAppendSecurityProfileInfo(
    IN  PCWSTR             InfProfileName,
    IN  AREA_INFORMATION   Area,
    IN  PSCE_PROFILE_INFO   ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
WINAPI
SceSvcSetInformationTemplate(
    IN LPCTSTR          TemplateName,
    IN LPCTSTR          ServiceName,
    IN BOOL             bExact,
    IN PSCESVC_CONFIGURATION_INFO ServiceInfo
    );

//
// prototypes defined in common.cpp
//

SCESTATUS
WINAPI
SceFreeMemory(
   IN PVOID smInfo,
   IN DWORD Category
   );

BOOL
WINAPI
SceCompareNameList(
    IN PSCE_NAME_LIST pList1,
    IN PSCE_NAME_LIST pList2
    );

SCESTATUS
WINAPI
SceCompareSecurityDescriptors(
    IN AREA_INFORMATION Area,
    IN PSECURITY_DESCRIPTOR pSD1,
    IN PSECURITY_DESCRIPTOR pSD2,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBOOL IsDifferent
    );

SCESTATUS
WINAPI
SceCreateDirectory(
    IN PCWSTR ProfileLocation,
    IN BOOL FileOrDir,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

SCESTATUS
WINAPI
SceFreeProfileMemory(
    PSCE_PROFILE_INFO pProfile
    );

SCESTATUS
WINAPI
SceAddToNameStatusList(
    IN OUT PSCE_NAME_STATUS_LIST *pNameStatusList,
    IN PWSTR Name,
    IN ULONG Len,
    IN DWORD Status
    );

SCESTATUS
WINAPI
SceAddToNameList(
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR Name,
    IN ULONG Len
    );

#define SCE_CHECK_DUP  0x01
#define SCE_INCREASE_COUNT 0x02

SCESTATUS
WINAPI
SceAddToObjectList(
    IN OUT PSCE_OBJECT_LIST  *pObjectList,
    IN PWSTR  Name,
    IN ULONG  Len,
    IN BOOL  IsContainer,
    IN BYTE  Status,
    IN BYTE  byFlags
    );

DWORD
WINAPI
SceEnumerateServices(
    OUT PSCE_SERVICES *pServiceList,
    IN BOOL bServiceNameOnly
    );

DWORD
WINAPI
SceSetupGenerateTemplate(
    IN LPTSTR SystemName OPTIONAL,
    IN LPTSTR JetDbName OPTIONAL,
    IN BOOL bFromMergedTable,
    IN LPTSTR InfTemplateName,
    IN LPTSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area
    );


#define SCE_REG_DISPLAY_NAME    TEXT("DisplayName")
#define SCE_REG_DISPLAY_TYPE    TEXT("DisplayType")
#define SCE_REG_VALUE_TYPE      TEXT("ValueType")
#define SCE_REG_DISPLAY_UNIT    TEXT("DisplayUnit")
#define SCE_REG_DISPLAY_CHOICES TEXT("DisplayChoices")
#define SCE_REG_DISPLAY_FLAGLIST   TEXT("DisplayFlags")

#define SCE_REG_DISPLAY_ENABLE      0
#define SCE_REG_DISPLAY_NUMBER      1
#define SCE_REG_DISPLAY_STRING      2
#define SCE_REG_DISPLAY_CHOICE      3
#define SCE_REG_DISPLAY_MULTISZ     4
#define SCE_REG_DISPLAY_FLAGS       5

DWORD
WINAPI
SceRegisterRegValues(
    IN LPTSTR InfFileName
    );

//
// for service attachments
//

SCESTATUS
WINAPI
SceSvcQueryInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    OUT PVOID               *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
    );

SCESTATUS
WINAPI
SceSvcSetInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    IN PVOID                pvInfo
    );

SCESTATUS
WINAPI
SceSvcFree(
    IN PVOID pvServiceInfo
    );

SCESTATUS
WINAPI
SceSvcConvertTextToSD (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pulSDSize,
    OUT PSECURITY_INFORMATION   psiSeInfo
    );

SCESTATUS
WINAPI
SceSvcConvertSDToText (
    IN PSECURITY_DESCRIPTOR   pSD,
    IN SECURITY_INFORMATION   siSecurityInfo,
    OUT PWSTR                  *ppwszTextSD,
    OUT PULONG                 pulTextSize
    );

//
// check service.cpp if the following constants are changed because
// it has a buffer length dependency
//
#define SCE_ROOT_POLICY_PATH   \
            SCE_ROOT_PATH TEXT("\\Policies")
#define SCE_ROOT_REGVALUE_PATH   \
            SCE_ROOT_PATH TEXT("\\Reg Values")

// define for GPT integration
#define GPTSCE_PATH   TEXT("Software\\Policies\\Microsoft\\Windows NT\\SecEdit")
#define GPTSCE_PERIOD_NAME  TEXT("ConfigurePeriod")
#define GPTSCE_TEMPLATE  TEXT("Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf")

AREA_INFORMATION
SceGetAreas(
    LPTSTR InfName
    );

BOOL
SceIsSystemDatabase(
    IN LPCTSTR DatabaseName
    );

SCESTATUS
SceBrowseDatabaseTable(
    IN PWSTR       DatabaseName OPTIONAL,
    IN SCETYPE     ProfileType,
    IN AREA_INFORMATION Area,
    IN BOOL        bDomainPolicyOnly,
    IN PSCE_BROWSE_CALLBACK_ROUTINE pCallback OPTIONAL
    );

SCESTATUS
WINAPI
SceGetDatabaseSetting(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR SectionName,
    IN PWSTR KeyName,
    OUT PWSTR *Value,
    OUT DWORD *pnBytes OPTIONAL
    );

SCESTATUS
WINAPI
SceSetDatabaseSetting(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR SectionName,
    IN PWSTR KeyName,
    IN PWSTR Value OPTIONAL,
    IN DWORD nBytes
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\seclogon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for seclogon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __seclogon_h__
#define __seclogon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ISeclogon_INTERFACE_DEFINED__
#define __ISeclogon_INTERFACE_DEFINED__

/* interface ISeclogon */
/* [auto_handle][unique][version][uuid] */ 

typedef struct _SECL_STRING
    {
    /* [range] */ unsigned short ccLength;
    /* [range] */ unsigned short ccSize;
    /* [length_is][size_is] */ wchar_t *pwsz;
    } 	SECL_STRING;

typedef struct _SECL_STRING *PSECL_STRING;

typedef struct _SECL_BLOB
    {
    /* [range] */ unsigned long cb;
    /* [size_is] */ unsigned char *pb;
    } 	SECL_BLOB;

typedef struct _SECL_BLOB *PSECL_BLOB;

typedef struct _SECL_SLI
    {
    SECL_STRING ssUsername;
    SECL_STRING ssDomain;
    SECL_STRING ssPassword;
    SECL_STRING ssApplicationName;
    SECL_STRING ssCommandLine;
    SECL_STRING ssCurrentDirectory;
    SECL_STRING ssTitle;
    SECL_STRING ssDesktop;
    SECL_BLOB sbEnvironment;
    unsigned long ulProcessId;
    unsigned long ulLogonIdLowPart;
    long lLogonIdHighPart;
    unsigned long ulLogonFlags;
    unsigned long ulCreationFlags;
    unsigned long ulSeclogonFlags;
    unsigned __int64 hWinsta;
    unsigned __int64 hDesk;
    unsigned __int64 hToken;
    } 	SECL_SLI;

typedef struct _SECL_SLI *PSECL_SLI;

typedef struct _SECL_SLRI
    {
    unsigned __int64 hProcess;
    unsigned __int64 hThread;
    unsigned long ulProcessId;
    unsigned long ulThreadId;
    unsigned long ulErrorCode;
    } 	SECL_SLRI;

typedef struct _SECL_SLRI *PSECL_SLRI;

void SeclCreateProcessWithLogonW( 
    /* [in] */ handle_t hRPCBinding,
    /* [ref][in] */ SECL_SLI *psli,
    /* [ref][out] */ SECL_SLRI *pslri);



extern RPC_IF_HANDLE ISeclogon_v1_0_c_ifspec;
extern RPC_IF_HANDLE ISeclogon_v1_0_s_ifspec;
#endif /* __ISeclogon_INTERFACE_DEFINED__ */

/* interface __MIDL_itf_seclogon_0001 */
/* [local] */ 

#define wszSeclogonSharedProcEndpointName L"SECLOGON"
#define wszSvcName                        L"seclogon"
#define SECLOGON_CALLER_SPECIFIED_DESKTOP   0x00000001
#pragma warning(disable:4211) // nonstandard extension used : redefined extern to static
#pragma warning(disable:4232) // nonstandard extension used : 'x' : address of dllimport 'y' is not static, identity not guaranteed
#pragma warning(disable:4310) // cast truncates constant value


extern RPC_IF_HANDLE __MIDL_itf_seclogon_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_seclogon_0001_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\secobj.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    secobj.h

Abstract:

    This header file defines the structures and function prototypes of
    routines which simplify the creation of security descriptors for
    user-mode objects.

Author:

    Rita Wong (ritaw) 27-Feb-1991

Revision History:

--*/

#ifndef _SECOBJ_INCLUDED_
#define _SECOBJ_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

//
// Global declarations
//

//
// NT well-known SIDs
//

extern PSID NullSid;                   // No members SID
extern PSID WorldSid;                  // All users SID
extern PSID LocalSid;                  // NT local users SID
extern PSID NetworkSid;                // NT remote users SID
extern PSID LocalSystemSid;            // NT system processes SID
extern PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain
extern PSID AuthenticatedUserSid;      // Authenticated user SID
extern PSID AnonymousLogonSid;         // Anonymous Logon SID
extern PSID LocalServiceSid;           // NT service processes SID
extern PSID OtherOrganizationSid;      // Other org SID

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

extern PSID LocalAdminSid;             // NT local admins SID
extern PSID AliasAdminsSid;            // Administrator Sid
extern PSID AliasUsersSid;             // User Sid
extern PSID AliasGuestsSid;            // Guest Sid
extern PSID AliasPowerUsersSid;        // Power User Sid
extern PSID AliasAccountOpsSid;        // Account Operator Sid
extern PSID AliasSystemOpsSid;         // System Operator Sid
extern PSID AliasPrintOpsSid;          // Print Operator Sid
extern PSID AliasBackupOpsSid;         // Backup Operator Sid


//
// Structure to hold information about an ACE to be created
//

typedef struct {
    UCHAR AceType;
    UCHAR InheritFlags;
    UCHAR AceFlags;
    ACCESS_MASK Mask;
    PSID *Sid;
} ACE_DATA, *PACE_DATA;

//
// Function prototypes
//

NTSTATUS
NetpCreateWellKnownSids(
    PSID DomainId
    );

VOID
NetpFreeWellKnownSids(
    VOID
    );

NTSTATUS
NetpAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
);

NET_API_STATUS
NetpDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    );

NTSTATUS
NetpCreateSecurityDescriptor(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

NTSTATUS
NetpCreateSecurityObject(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

NTSTATUS
NetpDeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    );

NET_API_STATUS
NetpAccessCheckAndAudit(
    IN  LPTSTR SubsystemName,
    IN  LPTSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

NET_API_STATUS
NetpAccessCheck(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

NET_API_STATUS
NetpGetBuiltinDomainSID(
    PSID *BuiltinDomainSID
    );

#ifdef __cplusplus
}       // extern "C"
#endif

#endif // ifndef _SECOBJ_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\secint.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991-1999
//
// File:        Secint.h
//
// Contents:    Toplevel include file for security aware system components
//
//
// History:     14-April-1998   MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __SECINT_H__
#define __SECINT_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// NOTE:  Update this section if you add new files:
//
// SECURITY_PACKAGE     Include defines necessary for security packages
// SECURITY_KERBEROS    Include everything needed to talk to the kerberos pkg.
// SECURITY_NTLM        Include everything to talk to ntlm package.

//
// Each of the files included here are surrounded by guards, so you don't
// need to worry about including this file multiple times with different
// flags defined
//



#if !defined(_NTSRV_) && !defined(_NTIFS_)
// begin_ntifs

#ifndef SECURITY_USER_DATA_DEFINED
#define SECURITY_USER_DATA_DEFINED

typedef struct _SECURITY_USER_DATA {
    SECURITY_STRING UserName;           // User name
    SECURITY_STRING LogonDomainName;    // Domain the user logged on to
    SECURITY_STRING LogonServer;        // Server that logged the user on
    PSID            pSid;               // SID of user
} SECURITY_USER_DATA, *PSECURITY_USER_DATA;

typedef SECURITY_USER_DATA SecurityUserData, * PSecurityUserData;


#define UNDERSTANDS_LONG_NAMES  1
#define NO_LONG_NAMES           2

#endif // SECURITY_USER_DATA_DEFINED

HRESULT SEC_ENTRY
GetSecurityUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserInformation
    );

SECURITY_STATUS SEC_ENTRY
MapSecurityError( SECURITY_STATUS SecStatus );

// end_ntifs

#endif //  !define(_NTSRV_) && !defined(_NTIFS_)


// Include security package headers:

#ifdef SECURITY_PACKAGE

#include <secpkg.h>

#endif  // SECURITY_PACKAGE


#ifdef SECURITY_KERBEROS

#include <kerberos.h>

#endif

#ifdef SECURITY_NTLM

#include <ntlmsp.h>

#endif // SECURITY_NTLM


SECURITY_STATUS
SEC_ENTRY
KSecValidateBuffer(
    PUCHAR Buffer,
    ULONG Length
    );

SECURITY_STATUS
SEC_ENTRY
SecpSetIPAddress(
    PUCHAR  lpIpAddress,
    ULONG   cchIpAddress
    );

#define MAX_BUFFERS_IN_CALL 8

//
// Private, internal SECBUFFER_* type used by kernel-mode components
// that want to pass along an IP address as part of an ASC call.
//

#define SECBUFFER_IPADDRESS  129

#endif // __SECINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\shutimp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    shutimp.h

Abstract:

    This file allows us to include standard system header files in the
    shutinit.idl file.  The shutinit.idl file imports a file called
    shutimp.idl.  This allows the shutinit.idl file to use the types defined
    in these header files.  It also causes the following line to be added
    in the MIDL generated header file:

    #include "shutimp.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dragos C. Sambotin (dragoss) 21-May-1999

--*/

#ifndef __SHUTIMP_H__
#define __SHUTIMP_H__

#include <windef.h>

#define SHUTDOWN_INTERFACE_NAME  L"InitShutdown"

#endif //__SHUTIMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\shutinit.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for shutinit.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __shutinit_h__
#define __shutinit_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "shutimp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __InitShutdown_INTERFACE_DEFINED__
#define __InitShutdown_INTERFACE_DEFINED__

/* interface InitShutdown */
/* [auto_handle][version][unique][uuid] */ 

typedef /* [handle] */ PWCHAR PREGISTRY_SERVER_NAME;

typedef struct _REG_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ USHORT *Buffer;
    } 	*PREG_UNICODE_STRING;

ULONG BaseInitiateShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown);

ULONG BaseAbortShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName);

ULONG BaseInitiateShutdownEx( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown,
    /* [in] */ DWORD dwReason);



extern RPC_IF_HANDLE InitShutdown_ClientIfHandle;
extern RPC_IF_HANDLE InitShutdown_ServerIfHandle;
#endif /* __InitShutdown_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER PREGISTRY_SERVER_NAME_bind  ( PREGISTRY_SERVER_NAME );
void     __RPC_USER PREGISTRY_SERVER_NAME_unbind( PREGISTRY_SERVER_NAME, handle_t );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\setup_browser.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    setup_browser.c

Abstract:

    This is used by syssetup to enable net browser.  It's generated from various files under
    ds\netapi\svcdlls\bworser\common.  Do not edit by hand.

Revision History:

--*/

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <ntddbrow.h>
#include <netlibnt.h>               // NetpNtStatusToApiStatus
#include <align.h>

#define NetpAssert(x)



//
// Buffer allocation size for enumeration output buffer.
//
#define INITIAL_ALLOCATION_SIZE  48*1024  // First attempt size (48K)
#define FUDGE_FACTOR_SIZE        1024  // Second try TotalBytesNeeded
                                       //     plus this amount

//
// prototypes
//

#ifdef ENABLE_PSEUDO_BROWSER
DWORD
IsBrowserEnabled(
    IN  OPTIONAL    LPTSTR  Section,
    IN              LPTSTR  Key,
    IN              BOOL    fDefault
    );

DWORD
GetBrowserValue(
    IN  OPTIONAL    LPTSTR  Section,
    IN              LPTSTR  Key,
    OUT             PDWORD pdwValue
    );
#endif


//
// Implementation
//

NET_API_STATUS
BrDgReceiverIoControlEx(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL,
	IN BOOLEAN WaitForCompletion
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    DgReceiverControlCode - Supplies the NtDeviceIoControlFile function code
        given to the datagram receiver.

    Drp - Supplies the datagram receiver request packet.

    DrpSize - Supplies the length of the datagram receiver request packet.

    SecondBuffer - Supplies the second buffer in call to NtDeviceIoControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET RealDrp;
    HANDLE CompletionEvent;
    LPBYTE Where;

    if (FileHandle == NULL) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Allocate a copy of the request packet where we can put the transport and
    //  emulated domain name in the packet itself.
    //
    RealDrp = (PLMDR_REQUEST_PACKET) MIDL_user_allocate(DrpSize+
                                 Drp->TransportName.Length+sizeof(WCHAR)+
                                 Drp->EmulatedDomainName.Length+sizeof(WCHAR) );

    if (RealDrp == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the request packet into the local copy.
    //
    RtlCopyMemory(RealDrp, Drp, DrpSize);

    Where = (LPBYTE)RealDrp+DrpSize;
    if (Drp->TransportName.Length != 0) {
        RealDrp->TransportName.Buffer = (LPWSTR)Where;
        RealDrp->TransportName.MaximumLength = Drp->TransportName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->TransportName, &Drp->TransportName);
        Where += RealDrp->TransportName.MaximumLength;
    }

    if (Drp->EmulatedDomainName.Length != 0) {
        RealDrp->EmulatedDomainName.Buffer = (LPWSTR)Where;
        RealDrp->EmulatedDomainName.MaximumLength = Drp->EmulatedDomainName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->EmulatedDomainName, &Drp->EmulatedDomainName);
        Where += RealDrp->EmulatedDomainName.MaximumLength;
    }



    //
    // Create a completion event
    //
    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {

        MIDL_user_free(RealDrp);

        return(GetLastError());
    }

    //
    // Send the request to the Datagram Receiver DD.
    //

    ntstatus = NtDeviceIoControlFile(
                   FileHandle,
                   CompletionEvent,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DgReceiverControlCode,
                   RealDrp,
                   (ULONG)(Where-(LPBYTE)RealDrp),
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (NT_SUCCESS(ntstatus)) {

        //
		//  If we need to wait for completion (synchronous) and 
        //  If pending was returned, then wait until the request completes.
        //

        if ( WaitForCompletion && (ntstatus == STATUS_PENDING) ) {

            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }


        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = (ULONG)IoStatusBlock.Information;
    }

    MIDL_user_free(RealDrp);

    CloseHandle(CompletionEvent);

    return NetpNtStatusToApiStatus(ntstatus);
}

NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
{
	return BrDgReceiverIoControlEx(
		FileHandle,
		DgReceiverControlCode,
		Drp,
		DrpSize,
		SecondBuffer,
		SecondBufferLength,
		Information,
		TRUE
    );
}

NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the datagram receiver.

Arguments:

    DeviceDriverType - Supplies the value which indicates whether to call
        the datagram receiver.

    FileHandle - Supplies a handle to the file or device of which to get
        information about.

    DeviceControlCode - Supplies the NtFsControlFile or NtIoDeviceControlFile
        function control code.

    RequestPacket - Supplies a pointer to the device request packet.

    RrequestPacketLength - Supplies the length of the device request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This pointer is set to
         NULL if return code is not NERR_Success.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

    Information - Returns the information code from the NtFsControlFile or
        NtIoDeviceControlFile call.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;
    HANDLE CompletionEvent;

    OriginalResumeKey = Drrp->Parameters.EnumerateNames.ResumeHandle;

    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //
    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ?
                             BufferHintSize :
                             INITIAL_ALLOCATION_SIZE;
    }
    else {
        OutputBufferLength = PreferedMaximumLength;
    }

    OutputBufferLength = ROUND_UP_COUNT(OutputBufferLength, ALIGN_WCHAR);

    if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {
        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;
        return(GetLastError());
    }

    Drrp->Parameters.EnumerateServers.EntriesRead = 0;

    //
    // Make the request of the Datagram Receiver
    //

    ntstatus = NtDeviceIoControlFile(
                     FileHandle,
                     CompletionEvent,
                     NULL,              // APC routine
                     NULL,              // APC context
                     &IoStatusBlock,
                     DeviceControlCode,
                     Drrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength
                     );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {
            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }

        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    //
    // Map NT status to Win error
    //
    status = NetpNtStatusToApiStatus(ntstatus);

    if (status == ERROR_MORE_DATA) {

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        TotalBytesNeeded = Drrp->Parameters.EnumerateNames.TotalBytesNeeded;
    }

    if ((TotalBytesNeeded > OutputBufferLength) &&
        (PreferedMaximumLength == MAXULONG)) {
        PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        MIDL_user_free(*OutputBuffer);

        OutputBufferLength =
            ROUND_UP_COUNT((TotalBytesNeeded + FUDGE_FACTOR_SIZE),
                           ALIGN_WCHAR);

        if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);


        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.ResumeHandle
                    )
                );

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.ResumeHandle
                    )
                );

        Drrp->Parameters.EnumerateNames.ResumeHandle = OriginalResumeKey;
        Drrp->Parameters.EnumerateServers.EntriesRead = 0;

        //
        //  Make the request of the Datagram Receiver
        //

        ntstatus = NtDeviceIoControlFile(
                         FileHandle,
                         CompletionEvent,
                         NULL,              // APC routine
                         NULL,              // APC context
                         &IoStatusBlock,
                         DeviceControlCode,
                         Drrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength
                         );

        if (NT_SUCCESS(ntstatus)) {

            //
            //  If pending was returned, then wait until the request completes.
            //

            if (ntstatus == STATUS_PENDING) {
                do {
                    ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
                } while ( ntstatus == WAIT_IO_COMPLETION );
            }

            if (NT_SUCCESS(ntstatus)) {
                ntstatus = IoStatusBlock.Status;
            }
        }

        status = NetpNtStatusToApiStatus(ntstatus);

    }


    //
    // If not successful in getting any data, or if the caller asked for
    // all available data with PreferedMaximumLength == MAXULONG and
    // our buffer overflowed, free the output buffer and set its pointer
    // to NULL.
    //
    if ((status != NERR_Success && status != ERROR_MORE_DATA) ||
        (TotalBytesNeeded == 0) ||
        (PreferedMaximumLength == MAXULONG && status == ERROR_MORE_DATA) ||
        (Drrp->Parameters.EnumerateServers.EntriesRead == 0)) {

        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (status == ERROR_MORE_DATA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    CloseHandle(CompletionEvent);

    return status;

    UNREFERENCED_PARAMETER(Information);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\shutinit_c.c ===
/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for shutinit.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>

#include "shutinit.h"

#define TYPE_FORMAT_STRING_SIZE   51                                
#define PROC_FORMAT_STRING_SIZE   181                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   1            


/* Standard interface: InitShutdown, ver. 1.0,
   GUID={0x894de0c0,0x0d55,0x11d3,{0xa3,0x22,0x00,0xc0,0x4f,0xa3,0x21,0xa1}} */



static const RPC_CLIENT_INTERFACE InitShutdown___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x894de0c0,0x0d55,0x11d3,{0xa3,0x22,0x00,0xc0,0x4f,0xa3,0x21,0xa1}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE InitShutdown_ClientIfHandle = (RPC_IF_HANDLE)& InitShutdown___RpcClientInterface;

extern const MIDL_STUB_DESC InitShutdown_StubDesc;

static RPC_BINDING_HANDLE InitShutdown__MIDL_AutoBindHandle;


ULONG BaseInitiateShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )&ServerName);
    return ( ULONG  )_RetVal.Simple;
    
}


ULONG BaseAbortShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[66],
                  ( unsigned char * )&ServerName);
    return ( ULONG  )_RetVal.Simple;
    
}


ULONG BaseInitiateShutdownEx( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown,
    /* [in] */ DWORD dwReason)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[108],
                  ( unsigned char * )&ServerName);
    return ( ULONG  )_RetVal.Simple;
    
}

extern const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure BaseInitiateShutdown */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x2c ),	/* 44 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 22 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x1 ),	/* 1 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 30 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 32 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter lpMessage */

/* 36 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 38 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 40 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter dwTimeout */

/* 42 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 44 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 46 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bForceAppsClosed */

/* 48 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 50 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 52 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bRebootAfterShutdown */

/* 54 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 56 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 58 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 60 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 62 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 64 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BaseAbortShutdown */

/* 66 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 68 */	NdrFcLong( 0x0 ),	/* 0 */
/* 72 */	NdrFcShort( 0x1 ),	/* 1 */
/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 76 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 78 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 80 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 82 */	NdrFcShort( 0x1a ),	/* 26 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 88 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 96 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 98 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 100 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BaseInitiateShutdownEx */

/* 108 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x2 ),	/* 2 */
/* 116 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 118 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 120 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 122 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 124 */	NdrFcShort( 0x34 ),	/* 52 */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 130 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x1 ),	/* 1 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 138 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 140 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter lpMessage */

/* 144 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 146 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 148 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter dwTimeout */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bForceAppsClosed */

/* 156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 158 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 160 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bRebootAfterShutdown */

/* 162 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 164 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 166 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter dwReason */

/* 168 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 170 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 174 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 176 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x0,	/* FC_UP */
/*  8 */	NdrFcShort( 0x14 ),	/* Offset= 20 (28) */
/* 10 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 16 */	NdrFcShort( 0x2 ),	/* 2 */
/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 20 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 26 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 28 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 34 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 36 */	NdrFcShort( 0x4 ),	/* 4 */
/* 38 */	NdrFcShort( 0x4 ),	/* 4 */
/* 40 */	0x12, 0x0,	/* FC_UP */
/* 42 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (10) */
/* 44 */	
			0x5b,		/* FC_END */

			0x6,		/* FC_SHORT */
/* 46 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 48 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */

			0x0
        }
    };

static const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ] = 
        {
        {
            (GENERIC_BINDING_ROUTINE)PREGISTRY_SERVER_NAME_bind,
            (GENERIC_UNBIND_ROUTINE)PREGISTRY_SERVER_NAME_unbind
         }
        
        };


static const unsigned short InitShutdown_FormatStringOffsetTable[] =
    {
    0,
    66,
    108
    };


static const MIDL_STUB_DESC InitShutdown_StubDesc = 
    {
    (void *)& InitShutdown___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &InitShutdown__MIDL_AutoBindHandle,
    0,
    BindingRoutines,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for shutinit.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>

#include "shutinit.h"

#define TYPE_FORMAT_STRING_SIZE   47                                
#define PROC_FORMAT_STRING_SIZE   187                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   1            


/* Standard interface: InitShutdown, ver. 1.0,
   GUID={0x894de0c0,0x0d55,0x11d3,{0xa3,0x22,0x00,0xc0,0x4f,0xa3,0x21,0xa1}} */



static const RPC_CLIENT_INTERFACE InitShutdown___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x894de0c0,0x0d55,0x11d3,{0xa3,0x22,0x00,0xc0,0x4f,0xa3,0x21,0xa1}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE InitShutdown_ClientIfHandle = (RPC_IF_HANDLE)& InitShutdown___RpcClientInterface;

extern const MIDL_STUB_DESC InitShutdown_StubDesc;

static RPC_BINDING_HANDLE InitShutdown__MIDL_AutoBindHandle;


ULONG BaseInitiateShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ServerName,
                  lpMessage,
                  dwTimeout,
                  bForceAppsClosed,
                  bRebootAfterShutdown);
    return ( ULONG  )_RetVal.Simple;
    
}


ULONG BaseAbortShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[68],
                  ServerName);
    return ( ULONG  )_RetVal.Simple;
    
}


ULONG BaseInitiateShutdownEx( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown,
    /* [in] */ DWORD dwReason)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[112],
                  ServerName,
                  lpMessage,
                  dwTimeout,
                  bForceAppsClosed,
                  bRebootAfterShutdown,
                  dwReason);
    return ( ULONG  )_RetVal.Simple;
    
}

extern const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure BaseInitiateShutdown */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x2c ),	/* 44 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 22 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x1 ),	/* 1 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 32 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 34 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 36 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter lpMessage */

/* 38 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 40 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 42 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter dwTimeout */

/* 44 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 46 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bForceAppsClosed */

/* 50 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 52 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 54 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bRebootAfterShutdown */

/* 56 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 58 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 60 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 62 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 64 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 66 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BaseAbortShutdown */

/* 68 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 70 */	NdrFcLong( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x1 ),	/* 1 */
/* 76 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 78 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 80 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 82 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 84 */	NdrFcShort( 0x1a ),	/* 26 */
/* 86 */	NdrFcShort( 0x8 ),	/* 8 */
/* 88 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 90 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 100 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 102 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 104 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BaseInitiateShutdownEx */

/* 112 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x2 ),	/* 2 */
/* 120 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 122 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 124 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 126 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 128 */	NdrFcShort( 0x34 ),	/* 52 */
/* 130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 132 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 134 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x1 ),	/* 1 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 144 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 146 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 148 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter lpMessage */

/* 150 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 152 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 154 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter dwTimeout */

/* 156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 158 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bForceAppsClosed */

/* 162 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 164 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 166 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bRebootAfterShutdown */

/* 168 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 170 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 172 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter dwReason */

/* 174 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 176 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 182 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x0,	/* FC_UP */
/*  8 */	NdrFcShort( 0x14 ),	/* Offset= 20 (28) */
/* 10 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 16 */	NdrFcShort( 0x2 ),	/* 2 */
/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 20 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 26 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 28 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 30 */	NdrFcShort( 0x10 ),	/* 16 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x8 ),	/* Offset= 8 (42) */
/* 36 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 38 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x12, 0x0,	/* FC_UP */
/* 44 */	NdrFcShort( 0xffde ),	/* Offset= -34 (10) */

			0x0
        }
    };

static const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ] = 
        {
        {
            (GENERIC_BINDING_ROUTINE)PREGISTRY_SERVER_NAME_bind,
            (GENERIC_UNBIND_ROUTINE)PREGISTRY_SERVER_NAME_unbind
         }
        
        };


static const unsigned short InitShutdown_FormatStringOffsetTable[] =
    {
    0,
    68,
    112
    };


static const MIDL_STUB_DESC InitShutdown_StubDesc = 
    {
    (void *)& InitShutdown___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &InitShutdown__MIDL_AutoBindHandle,
    0,
    BindingRoutines,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\ssi.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    ssi.h

Abstract:

    Definition of Netlogon service APIs and structures used for SAM database
    replication.

    This file is shared by the Netlogon service and the XACT server.

Author:

    Cliff Van Dyke (cliffv) 27-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    27-Jun-1991 (cliffv)
        Ported from LanMan 2.1.

    04-Apr-1992 (madana)
        Added support for LSA replication.

--*/

#ifndef _NET_SSI_H_
#define _NET_SSI_H_

//**************************************************************
//
//              Data structure template - AUTHENTICATION
//
// ***************************************************************//

typedef struct _NETLOGON_VALIDATION_UAS_INFO {
#ifdef MIDL_PASS
     [string] wchar_t * usrlog1_eff_name;
#else // MIDL_PASS
     LPWSTR usrlog1_eff_name;
#endif // MIDL_PASS
     DWORD usrlog1_priv;
     DWORD usrlog1_auth_flags;
     DWORD usrlog1_num_logons;
     DWORD usrlog1_bad_pw_count;
     DWORD usrlog1_last_logon;
     DWORD usrlog1_last_logoff;
     DWORD usrlog1_logoff_time;
     DWORD usrlog1_kickoff_time;
     DWORD usrlog1_password_age;
     DWORD usrlog1_pw_can_change;
     DWORD usrlog1_pw_must_change;
#ifdef MIDL_PASS
     [string] wchar_t * usrlog1_computer;
     [string] wchar_t * usrlog1_domain;
     [string] wchar_t * usrlog1_script_path;
#else // MIDL_PASS
     LPWSTR usrlog1_computer;
     LPWSTR usrlog1_domain;
     LPWSTR usrlog1_script_path;
#endif // MIDL_PASS
     DWORD usrlog1_reserved1;
} NETLOGON_VALIDATION_UAS_INFO, *PNETLOGON_VALIDATION_UAS_INFO ;

typedef struct _NETLOGON_LOGOFF_UAS_INFO {
     DWORD Duration;
     USHORT LogonCount;
} NETLOGON_LOGOFF_UAS_INFORMATION, *PNETLOGON_LOGOFF_UAS_INFO;

// ***************************************************************
//
//      Function prototypes - AUTHENTICATION
//
// ***************************************************************

NTSTATUS
I_NetServerReqChallenge(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientChallenge,
    OUT PNETLOGON_CREDENTIAL ServerChallenge
);

NTSTATUS
I_NetServerAuthenticate(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential
);

NTSTATUS
I_NetServerAuthenticate2(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential,
    IN OUT PULONG NegotiatedFlags
);

NTSTATUS
I_NetServerAuthenticate3(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential,
    IN OUT PULONG NegotiatedFlags,
    OUT PULONG AccountRid
    );

//
// Values of I_NetServerAuthenticate2 NegotiatedFlags
//

#define NETLOGON_SUPPORTS_ACCOUNT_LOCKOUT   0x00000001
#define NETLOGON_SUPPORTS_PERSISTENT_BDC    0x00000002
#define NETLOGON_SUPPORTS_RC4_ENCRYPTION    0x00000004
#define NETLOGON_SUPPORTS_PROMOTION_COUNT   0x00000008
#define NETLOGON_SUPPORTS_BDC_CHANGELOG     0x00000010
#define NETLOGON_SUPPORTS_FULL_SYNC_RESTART 0x00000020
#define NETLOGON_SUPPORTS_MULTIPLE_SIDS     0x00000040
#define NETLOGON_SUPPORTS_REDO              0x00000080

//
// For NT 3.51, the mask was 0xFF.
//

#define NETLOGON_SUPPORTS_NT351_MASK        0x000000FF

#define NETLOGON_SUPPORTS_REFUSE_CHANGE_PWD 0x00000100

//
// For NT 4.0, the mask was 0x1FF.
// For NT 4 SP 4, the machine might have NETLOGON_SUPPORTS_AUTH_RPC or'd in
//

#define NETLOGON_SUPPORTS_NT4_MASK          0x400001FF

#define NETLOGON_SUPPORTS_PDC_PASSWORD      0x00000200
#define NETLOGON_SUPPORTS_GENERIC_PASSTHRU  0x00000400
#define NETLOGON_SUPPORTS_CONCURRENT_RPC    0x00000800
#define NETLOGON_SUPPORTS_AVOID_SAM_REPL    0x00001000
#define NETLOGON_SUPPORTS_AVOID_LSA_REPL    0x00002000
#define NETLOGON_SUPPORTS_STRONG_KEY        0x00004000  // Added after NT 5 Beta 2
#define NETLOGON_SUPPORTS_TRANSITIVE        0x00008000  // Added after NT 5 Beta 2
#define NETLOGON_SUPPORTS_DNS_DOMAIN_TRUST  0x00010000
#define NETLOGON_SUPPORTS_PASSWORD_SET_2    0x00020000
#define NETLOGON_SUPPORTS_GET_DOMAIN_INFO   0x00040000
#define NETLOGON_SUPPORTS_LSA_AUTH_RPC      0x20000000  // Added after NT 5 Beta 2
#define NETLOGON_SUPPORTS_AUTH_RPC          0x40000000

//
// Masks added after Windows 2000
//

#define NETLOGON_SUPPORTS_CROSS_FOREST      0x00080000  // Added for XP (Whistler client)
#define NETLOGON_SUPPORTS_NT4EMULATOR_NEUTRALIZER   0x00100000  // Added for XP (Whistler client) and ported into win2k SP2

//
// For Windows 2000, the mask was 0x6007FFFF
//  NETLOGON_SUPPORTS_NT4EMULATOR_NEUTRALIZER was added in win2k SP2
//

#define NETLOGON_SUPPORTS_WIN2000_MASK      (0x6007FFFF | NETLOGON_SUPPORTS_NT4EMULATOR_NEUTRALIZER)

//
// For Windows XP, NETLOGON_SUPPORTS_CROSS_FOREST was added
//

#define NETLOGON_SUPPORTS_XP_MASK      (NETLOGON_SUPPORTS_WIN2000_MASK & NETLOGON_SUPPORTS_CROSS_FOREST)

//
// Mask of bits always supported by current build (regardless of options)
//
#define NETLOGON_SUPPORTS_MASK ( \
            NETLOGON_SUPPORTS_ACCOUNT_LOCKOUT | \
            NETLOGON_SUPPORTS_PERSISTENT_BDC | \
            NETLOGON_SUPPORTS_RC4_ENCRYPTION | \
            NETLOGON_SUPPORTS_PROMOTION_COUNT | \
            NETLOGON_SUPPORTS_BDC_CHANGELOG | \
            NETLOGON_SUPPORTS_FULL_SYNC_RESTART | \
            NETLOGON_SUPPORTS_MULTIPLE_SIDS | \
            NETLOGON_SUPPORTS_REDO | \
            NETLOGON_SUPPORTS_REFUSE_CHANGE_PWD | \
            NETLOGON_SUPPORTS_PDC_PASSWORD | \
            NETLOGON_SUPPORTS_GENERIC_PASSTHRU | \
            NETLOGON_SUPPORTS_CONCURRENT_RPC | \
            NETLOGON_SUPPORTS_TRANSITIVE | \
            NETLOGON_SUPPORTS_DNS_DOMAIN_TRUST | \
            NETLOGON_SUPPORTS_PASSWORD_SET_2 | \
            NETLOGON_SUPPORTS_GET_DOMAIN_INFO | \
            NETLOGON_SUPPORTS_CROSS_FOREST )


NTSTATUS
I_NetServerPasswordSet(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PENCRYPTED_LM_OWF_PASSWORD UasNewPassword
);

//
// Values of QueryLevel
#define NETLOGON_QUERY_DOMAIN_INFO      1
#define NETLOGON_QUERY_LSA_POLICY_INFO  2

NTSTATUS
I_NetLogonGetDomainInfo(
    IN LPWSTR ServerName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD QueryLevel,
    IN LPBYTE InBuffer,
    OUT LPBYTE *OutBuffer
    );



NET_API_STATUS NET_API_FUNCTION
I_NetLogonUasLogon (
    IN LPWSTR UserName,
    IN LPWSTR Workstation,
    OUT PNETLOGON_VALIDATION_UAS_INFO *ValidationInformation
);

NET_API_STATUS
I_NetLogonUasLogoff (
    IN LPWSTR UserName,
    IN LPWSTR Workstation,
    OUT PNETLOGON_LOGOFF_UAS_INFO LogoffInformation
);

// **************************************************************
//
//      Special values and constants - AUTHENTICATION
//
// **************************************************************

// **************************************************************
//
//              Data structure template - UAS/SAM REPLICATION
//
// **************************************************************

typedef struct _UAS_INFO_0 {
    CHAR ComputerName[LM20_CNLEN+1];
    ULONG TimeCreated;
    ULONG SerialNumber;
} UAS_INFO_0, *PUAS_INFO_0 ;

// **************************************************************
//
//      Function prototypes - UAS/SAM REPLICATION
//
// **************************************************************

NET_API_STATUS NET_API_FUNCTION
I_NetAccountDeltas (
    IN LPWSTR primaryname,
    IN LPWSTR computername,
    IN PNETLOGON_AUTHENTICATOR authenticator,
    OUT PNETLOGON_AUTHENTICATOR ret_auth,
    IN PUAS_INFO_0 record_id,
    IN DWORD count,
    IN DWORD level,
    OUT LPBYTE buffer,
    IN DWORD buffer_len,
    OUT PULONG entries_read,
    OUT PULONG total_entries,
    OUT PUAS_INFO_0 next_record_id
    );

NET_API_STATUS NET_API_FUNCTION
I_NetAccountSync (
    IN LPWSTR primaryname,
    IN LPWSTR computername,
    IN PNETLOGON_AUTHENTICATOR authenticator,
    OUT PNETLOGON_AUTHENTICATOR ret_auth,
    IN DWORD reference,
    IN DWORD level,
    OUT LPBYTE buffer,
    IN DWORD buffer_len,
    OUT PULONG entries_read,
    OUT PULONG total_entries,
    OUT PULONG next_reference,
    OUT PUAS_INFO_0 last_record_id
);

typedef enum _NETLOGON_DELTA_TYPE {
    AddOrChangeDomain = 1,
    AddOrChangeGroup,
    DeleteGroup,
    RenameGroup,
    AddOrChangeUser,
    DeleteUser,
    RenameUser,
    ChangeGroupMembership,
    AddOrChangeAlias,
    DeleteAlias,
    RenameAlias,
    ChangeAliasMembership,
    AddOrChangeLsaPolicy,
    AddOrChangeLsaTDomain,
    DeleteLsaTDomain,
    AddOrChangeLsaAccount,
    DeleteLsaAccount,
    AddOrChangeLsaSecret,
    DeleteLsaSecret,
    // The following deltas require NETLOGON_SUPPORTS_BDC_CHANGELOG to be
    // negotiated.
    DeleteGroupByName,
    DeleteUserByName,
    SerialNumberSkip,
    DummyChangeLogEntry
} NETLOGON_DELTA_TYPE;


//
// Group and User account used for SSI.
//

#define SSI_ACCOUNT_NAME_POSTFIX        L"$"
#define SSI_ACCOUNT_NAME_POSTFIX_CHAR   L'$'
#define SSI_ACCOUNT_NAME_POSTFIX_LENGTH 1
#define SSI_ACCOUNT_NAME_LENGTH         (CNLEN + SSI_ACCOUNT_NAME_POSTFIX_LENGTH)

#define SSI_SERVER_GROUP_W              L"SERVERS"

//
// Structure to pass an encrypted password over the wire.  The Length is the
// length of the password, which should be placed at the end of the buffer.
//

#define NL_MAX_PASSWORD_LENGTH 256
typedef struct _NL_TRUST_PASSWORD {
    WCHAR Buffer[NL_MAX_PASSWORD_LENGTH];
    ULONG Length;
} NL_TRUST_PASSWORD, *PNL_TRUST_PASSWORD;

//
// Structure to be prefixed before the password in the Buffer of NL_TRUST_PASSWORD
// structure passed over the wire.  It will be used to distinguish between diferent
// versions of information passed in the buffer. Begining with RC1 NT5, the presence
// of the structure in the buffer and the equality of PasswordVersionPresent to
// PASSWORD_VERSION_PRESENT indicates that the password version number is present
// and is stored in PasswordVersionNumber; the value of ReservedField is set to 0.
// RC0 NT5 clients will generate random numbers in place of NL_PASSWORD_VERSION; it
// is highly unlikely that they will generate PASSWORD_VERSION_PRESENT sequence of
// bits in place where the PasswordVersionPresent would be present.  This (very week)
// uncertainty will exist only between RC0 NT5 and RC1 NT5 machines.  A server running
// RC1 NT5 will check the PasswordVersionPresent field only for RC0 NT5 and higher
// clients. The ReservedField will be used in future versions to indicate the version
// of the information stored in the buffer.
//

#define PASSWORD_VERSION_NUMBER_PRESENT 0x02231968
typedef struct _NL_PASSWORD_VERSION {
    DWORD ReservedField;
    DWORD PasswordVersionNumber;
    DWORD PasswordVersionPresent;
} NL_PASSWORD_VERSION, *PNL_PASSWORD_VERSION;

NTSTATUS
I_NetServerPasswordSet2(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PNL_TRUST_PASSWORD NewPassword
);

NTSTATUS
I_NetServerPasswordGet(
    IN LPWSTR PrimaryName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
I_NetServerTrustPasswordsGet(
    IN LPWSTR TrustedDcName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNewOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword
    );

NTSTATUS
I_NetLogonSendToSam(
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN LPBYTE Buffer,
    IN ULONG BufferSize
    );


//
// Only define this API if the caller has #included the pre-requisite ntlsa.h

#ifdef _NTLSA_

NTSTATUS
I_NetGetForestTrustInformation (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD Flags,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    );

#endif // _NTLSA_

#endif // _NET_SSI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\uascache.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    UASCache.h

Abstract:

    Data structures for logged on user cache.

Author:

    Shanku Niyogi (W-SHANKN)  24-Oct-1991

Revision History:

    24-Oct-1991     w-shankn
        Ported from LM2.0 code.
    07-Feb-1992 JohnRo
        Made changes suggested by PC-LINT.
    18-Mar-1992 JohnRo
        Allow inclusion multiple times.

--*/


#ifndef _UASCACHE_
#define _UASCACHE_


#include <packon.h>                     // Needed to avoid alignment

//
// Forward declarations for recursive structures.
//

typedef struct _UAS_USER_CACHE_0 UAS_USER_CACHE_0, *LPUAS_USER_CACHE_0;

//
// Structure of a Global User IDentifier
//

typedef struct _UAS_GUID {

    WORD guid_uid;                      // LM10 style user id
    DWORD guid_serial;                  // user record serial number
    BYTE guid_rsvd[10];                 // pad out to 16 bytes for now

} UAS_GUID;


//
// Structure of a logon record in the UAS cache
//

struct _UAS_USER_CACHE_0 {  // typedef'ed above.

    UAS_GUID uc0_guid;                  // GUID for this user
    DWORD uc0_auth_flags;               // operator privilege flag
    WORD uc0_priv;                      // bit0-1: 0 guest, 1 user, 2 admin
    WORD uc0_num_reqs;                  // use count for this record
    BYTE uc0_groups[32];                // group membership bit map
    LPUAS_USER_CACHE_0 uc0_next;        // pointer to the next

};

typedef UAS_USER_CACHE_0 UAS_USER, *LPUAS_USER;

//
// Structure of a group record in the UAS cache
//

typedef struct _UAS_GROUP_CACHE_0 {

    UAS_GUID gc0_guid;                  // GUID for this group

} UAS_GROUP_CACHE_0, *LPUAS_GROUP_CACHE_0;


//
// UAS info struct for SSI and update APIs
//

typedef struct _UAS_INFO_0 {

    BYTE uas0_computer[LM20_CNLEN+1];
    DWORD uas0_time_created;
    DWORD uas0_serial_number;

} UAS_INFO_0, *LPUAS_INFO_0;

#include <packoff.h>


#endif // _UASCACHE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\usrprop.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    usrprop.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _USRPROP_H_
#define _USRPROP_H_

//
//  These are exported by netapi32.dll.
//

NTSTATUS
NetpParmsSetUserProperty (
    IN LPWSTR             UserParms,
    IN LPWSTR             Property,
    IN UNICODE_STRING     PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,       // memory has to be freed afer use.
    OUT BOOL *            Update
    );

NTSTATUS
NetpParmsSetUserPropertyWithLength (
    IN PUNICODE_STRING    UserParms,
    IN LPWSTR             Property,
    IN UNICODE_STRING     PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,       // memory has to be freed afer use.
    OUT BOOL *            Update
    );

NTSTATUS
NetpParmsQueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

NTSTATUS
NetpParmsQueryUserPropertyWithLength (
    IN  PUNICODE_STRING UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

//
//  Call NetpParmsUserertyPropFree on new Parameters block returned by
//  NetpParmsSetUserProperty above after you're done writing it out.
//

VOID
NetpParmsUserPropertyFree (
    LPWSTR NewUserParms
    );

#endif // _USRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\tstring.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    tstring.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    13-Jan-1992 JohnRo
        Oops, I missed from NetpAlloc{type}From{type} macros
        Also added STRNCMPI as an alias for STRNICMP.
    16-Jan-1992 Danl
        Moved the macros to \private\inc\tstr.h
    23-Mar-1992 JohnRo
        Added NetpCopy{Str,TStr,WStr}ToUnalignedWStr().
    27-Apr-1992 JohnRo
        Changed NetpNCopy{type}From{type} to return NET_API_STATUS.
    03-Aug-1992 JohnRo
        RAID 1895: Net APIs and svcs should use OEM char set.
    14-Apr-1993 JohnRo
        RAID 6113 ("PortUAS: dangerous handling of Unicode").
        Made changes suggested by PC-LINT 5.0

--*/

#ifndef _TSTRING_H_INCLUDED
#define _TSTRING_H_INCLUDED


#include <lmcons.h>     // NET_API_STATUS.
// Don't complain about "unneeded" includes of these files:
/*lint -efile(764,tstr.h,winerror.h) */
/*lint -efile(766,tstr.h,winerror.h) */
#include <tstr.h>       // tstring stuff, used in macros below.
#include <winerror.h>   // NO_ERROR.


//
// Eventually, most uses of non-UNICODE strings should refer to the default
// codepage for the LAN.  The NetpCopy functions support the default codepage.
// The other STR macros may not.
//
VOID
NetpCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src              // string in default LAN codepage
    );

NET_API_STATUS
NetpNCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src,             // string in default LAN codepage
    IN  DWORD  CharCount
    );

VOID
NetpCopyWStrToStr(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src
    );

NET_API_STATUS
NetpNCopyWStrToStr(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src,
    IN  DWORD  CharCount
    );

VOID
NetpCopyWStrToStrDBCS(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src
    );

ULONG
NetpUnicodeToDBCSLen(
    IN  LPWSTR Src
    );


#ifdef UNICODE

#define NetpCopyStrToTStr(Dest,Src)  NetpCopyStrToWStr((Dest),(Src))
#define NetpCopyTStrToStr(Dest,Src)  NetpCopyWStrToStr((LPSTR)(Dest),(LPWSTR)(Src))
#define NetpCopyTStrToWStr(Dest,Src) (void) wcscpy((Dest),(Src))

#define NetpNCopyTStrToWStr(Dest,Src,Len) \
                        (wcsncpy((Dest),(Src),(Len)), NO_ERROR)

#endif // UNICODE


//
// Define a set of allocate and copy functions.  These all return NULL if
// unable to allocate memory.  The memory must be freed with NetApiBufferFree.
//

LPSTR
NetpAllocStrFromWStr (
    IN LPWSTR Src
    );

LPWSTR
NetpAllocWStrFromStr (
    IN LPSTR Src
    );

LPWSTR
NetpAllocWStrFromWStr (
    IN LPWSTR Src
    );

//
// As of 03-Aug-1992, people are still arguing over whether there should
// be an RtlInitOemString.  So I'm inventing NetpInitOemString in the
// meantime.  --JR
//

#ifdef _NTDEF_   // POEM_STRING typedef visible?

VOID
NetpInitOemString(
    OUT POEM_STRING DestinationString,
    IN  PCSZ        SourceString
    );

#endif // _NTDEF_


//
//
// ANSI versions of the API.
//

LPWSTR
NetpAllocWStrFromAStr (
    IN LPCSTR Src
    );

LPSTR
NetpAllocAStrFromWStr (
    IN LPCWSTR Src
    );

#endif  // _TSTRING_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\wlnotify.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :
	
    wlnotify.h

Abstract:

    Shared wlnotify header.

Revision History:
--*/

#ifndef _WLNOTIFY_
#define _WLNOTIFY_

//
//	Resource string IDs
//
//
#define IDS_TSSESSION_STRING           2001
#define IDS_TSERRORDIALOG_STRING       2002
#define IDS_TSPTEMPLATE_FROM           2003
#define IDS_TSPTEMPLATE_FROM_IN        2004
#define IDS_TSPTEMPLATE_ON_FROM        2005
#define IDS_TSPTEMPLATE_ON_FROM_IN     2006
#define IDS_ON                         2007
#define IDS_DRIVE_INFO_TIP             2008

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\winsaferp.h ===
#ifdef __cplusplus
extern "C" {
#endif
#define SAFER_SCOPEID_REGISTRY 3
#define SAFER_LEVEL_DELETE 2
#define SAFER_LEVEL_CREATE 4

//
// Private registry key locations.
//

#define SAFER_HKLM_REGBASE L"Software\\Policies\\Microsoft\\Windows\\Safer"
#define SAFER_HKCU_REGBASE L"Software\\Policies\\Microsoft\\Windows\\Safer"

//
// default winsafer executable file types as a multisz string 
//

#define  SAFER_DEFAULT_EXECUTABLE_FILE_TYPES L"ADE\0ADP\0BAS\0BAT\0CHM\0\
CMD\0COM\0CPL\0CRT\0EXE\0HLP\0HTA\0INF\0INS\0ISP\0LNK\0MDB\0MDE\0MSC\0\
MSI\0MSP\0MST\0OCX\0PCD\0PIF\0REG\0SCR\0SHS\0URL\0VB\0WSC\0"


//
// name of the objects sub-branch.
//

#define SAFER_OBJECTS_REGSUBKEY L"LevelObjects"

//
// names of the values under each of the object sub-branches.
//

#define SAFER_OBJFRIENDLYNAME_REGVALUEW L"FriendlyName"
#define SAFER_OBJDESCRIPTION_REGVALUEW  L"Description"
#define SAFER_OBJDISALLOW_REGVALUE      L"DisallowExecution"

//
// name of the code identifiers sub-branch
//

#define SAFER_CODEIDS_REGSUBKEY L"CodeIdentifiers"

//
// name of the value under the top level code identifier branch.
//

#define SAFER_DEFAULTOBJ_REGVALUE         L"DefaultLevel"
#define SAFER_TRANSPARENTENABLED_REGVALUE L"TransparentEnabled"
#define SAFER_HONORUSER_REGVALUE          L"HonorUserIdentities"
#define SAFER_EXETYPES_REGVALUE           L"ExecutableTypes"
#define SAFER_POLICY_SCOPE                L"PolicyScope"
#define SAFER_LOGFILE_NAME                L"LogFileName"
#define SAFER_HIDDEN_LEVELS               L"Levels"
#define SAFER_AUTHENTICODE_REGVALUE       L"AuthenticodeEnabled"

//
// names of the various subkeys under the code identifier sub-branches
//

#define SAFER_PATHS_REGSUBKEY     L"Paths"
#define SAFER_HASHMD5_REGSUBKEY   L"Hashes"
#define SAFER_SOURCEURL_REGSUBKEY L"UrlZones"

//
// names of the various values under each code identifiery sub-branch.
//

#define SAFER_IDS_LASTMODIFIED_REGVALUE L"LastModified"
#define SAFER_IDS_DESCRIPTION_REGVALUE  L"Description"
#define SAFER_IDS_ITEMSIZE_REGVALUE     L"ItemSize"
#define SAFER_IDS_ITEMDATA_REGVALUE     L"ItemData"
#define SAFER_IDS_SAFERFLAGS_REGVALUE   L"SaferFlags"
#define SAFER_IDS_FRIENDLYNAME_REGVALUE L"FriendlyName"
#define SAFER_IDS_HASHALG_REGVALUE      L"HashAlg"
#define SAFER_VALUE_NAME_DEFAULT_LEVEL  L"DefaultLevel"
#define SAFER_VALUE_NAME_HASH_SIZE      L"HashSize"

//
// registry values
//

#define SAFER_IDS_LEVEL_DESCRIPTION_FULLY_TRUSTED   L"DescriptionFullyTrusted"
#define SAFER_IDS_LEVEL_DESCRIPTION_NORMAL_USER     L"DescriptionNormalUser"
#define SAFER_IDS_LEVEL_DESCRIPTION_CONSTRAINED     L"DescriptionConstrained"
#define SAFER_IDS_LEVEL_DESCRIPTION_UNTRUSTED       L"DescriptionUntrusted"
#define SAFER_IDS_LEVEL_DESCRIPTION_DISALLOWED      L"DescriptionDisallowed"

//
// defines for OOB rules
//
//#define SAFER_DEFAULT_OLK_RULE_PATH L"%USERPROFILE%\\Local Settings\\Temporary Internet Files\\OLK\\"

#define SAFER_LEVEL_ZERO    L"0"
#define SAFER_REGKEY_SEPERATOR    L"\\"
#define SAFER_DEFAULT_RULE_GUID L"{dda3f824-d8cb-441b-834d-be2efd2c1a33}"



#define SAFERP_WINDOWS_GUID {0x191cd7fa, 0xf240, 0x4a17, 0x89, 0x86, 0x94, 0xd4, 0x80, 0xa6, 0xc8, 0xca}

#define SAFERP_WINDOWS_EXE_GUID {0x7272edfb, 0xaf9f, 0x4ddf, 0xb6, 0x5b, 0xe4, 0x28, 0x2f, 0x2d, 0xee, 0xfc}

#define SAFERP_SYSTEM_EXE_GUID {0x8868b733, 0x4b3a, 0x48f8, 0x91, 0x36, 0xaa, 0x6d, 0x05, 0xd4, 0xfc, 0x83}

#define SAFERP_PROGRAMFILES_GUID {0xd2c34ab2, 0x529a, 0x46b2, 0xb2, 0x93, 0xfc, 0x85, 0x3f, 0xce, 0x72, 0xea}


#define SAFER_GUID_RESULT_TRUSTED_CERT       \
      { 0xc59e7b5a,                         \
        0xaf71,                             \
        0x4595,                             \
        {0xb8, 0xdb, 0x46, 0xb4, 0x91, 0xe8, 0x90, 0x07} }

#define SAFER_GUID_RESULT_DEFAULT_LEVEL      \
      { 0x11015445,                         \
        0xd282,                             \
        0x4f86,                             \
        {0x96, 0xa2, 0x9e, 0x48, 0x5f, 0x59, 0x33, 0x02} }



// 
// The following is a private function that is exported
// for WinVerifyTrust to call to determine if a given hash has a
// WinSafer policy associated with it.
//

BOOL WINAPI
SaferiSearchMatchingHashRules(
    IN  ALG_ID HashAlgorithm       OPTIONAL,
    IN  PBYTE  pHashBytes,
    IN  DWORD  dwHashSize,
    IN  DWORD  dwOriginalImageSize OPTIONAL,
    OUT PDWORD pdwFoundLevel,
    OUT PDWORD pdwSaferFlags
    );

//
// The following is a private function exported to allow the current
// registry scope to be altered.  This has the effect of changing
// how AUTHZSCOPEID_REGISTRY is interepreted.
//

WINADVAPI
BOOL WINAPI
SaferiChangeRegistryScope(
    IN HKEY  hKeyCustomRoot OPTIONAL,
    IN DWORD dwKeyOptions
    );

//
// The following is a private function provided to try to empiracally
// determine if the two access token have been restricted with comparable
// WinSafer authorization Levels.  When TRUE is returned, the pdwResult
// output parameter will receive any of the following values:
//      -1 = Client's access token is more authorized than Server's.
//       0 = Client's access token is comparable level to Server's.
//       1 = Server's access token is more authorized than Clients's.
//

WINADVAPI
BOOL WINAPI
SaferiCompareTokenLevels (
    IN  HANDLE ClientAccessToken,
    IN  HANDLE ServerAccessToken,
    OUT PDWORD pdwResult
    );


//
// The following is a private function exported to allow population if defaults in 
// the registry.
//
BOOL WINAPI
SaferiPopulateDefaultsInRegistry(
        IN HKEY     hKeyBase,
        OUT BOOL *pbSetDefaults
        );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\w32timep.h ===
//--------------------------------------------------------------------
// w32timep - interface
//
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Duncan Bryce (duncanb), 12-07-00
//
// Contains methods to configure or query the windows time service
// 

#ifndef __W32TIMEP_H__
#define __W32TIMEP_H__ 1

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------------------------------
// Configurable / queryable properties for the windows time service:
//
#ifndef MIDL_PASS
#define W32TIME_CONFIG_SPECIAL_POLL_INTERVAL  0
#define W32TIME_CONFIG_MANUAL_PEER_LIST       1
#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeQueryConfig
//
// Queries configuration information for the windows time service.  The semantics
// of the parameters depend on which property is being query:
//  
// dwProperty:   W32TIME_CONFIG_SPECIAL_POLL_INTERVAL   
// pdwType:      REG_DWORD  
// pbConfig:     a DWORD-sized buffer, containing the special polling interval (in seconds).
//               The special polling interval can be specified as an alternative to 
//               using the standard, automatically-computed polling intervals specified by
//               NTP.  NOTE: The special polling interval applies only to microsoft time 
//               providers.
// pdwSize:      sizeof(DWORD)
//     
// 
// dwProperty:   W32TIME_CONFIG_MANUAL_PEER_LIST
// pdwType:      REG_SZ
// pbConfig:     a space-delimited unicode string containing the list of time sources which the
//               microsoft time providers should sync from.  Each is an IP address
//               or DNS name of an NTP server, optionally followed by a "flags" parameter.
//               For example: 
// 
//               time.windows.com,0x3 gproxy,0x2 ntdsdc9
//
//               The following flags are available:
// 
//                   0x1  --  use the special polling interval for this source, instead of the
//                            standard NTP polling
//                   0x2  --  use this source only when no domain hierarchy sources are available
//
// pdwSize:      sizeof(WCHAR) * (wcslen(pbConfig) + 1)
//
#ifndef MIDL_PASS
HRESULT W32TimeQueryConfig(IN       DWORD   dwProperty, 
                           OUT      DWORD  *pdwType, 
                           IN OUT   BYTE   *pbConfig, 
                           IN OUT   DWORD  *pdwSize); 
#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeSetConfig
//
// Sets configuration information for the windows time service.  The semantics
// of the parameters depend on which property is being query.  For a description 
// of the properties, see W32TimeQueryConfig(). 
//  
#ifndef MIDL_PASS
HRESULT  W32TimeSetConfig(IN  DWORD   dwProperty, 
                          IN  DWORD   dwType, 
                          IN  BYTE   *pbConfig, 
                          IN  DWORD   dwSize);
#endif // MIDL_PASS


//-------------------------------------------------------------------------------------
//
// Client-side wrappers for the w32time RPC interface
//
//-------------------------------------------------------------------------------------

#ifndef MIDL_PASS

#define TimeSyncFlag_SoftResync         0x00
#define TimeSyncFlag_HardResync         0x01
#define TimeSyncFlag_ReturnResult       0x02
#define TimeSyncFlag_Rediscover         0x04
#define TimeSyncFlag_UpdateAndResync    0x08

#define ResyncResult_Success            0x00
#define ResyncResult_NoData             0x01
#define ResyncResult_StaleData          0x02
#define ResyncResult_Shutdown           0x03
#define ResyncResult_ChangeTooBig       0x04

#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeSyncNow
//
// Sends an RPC request to the windows time service to attempt to synchronize time with
// its configured time sources. 
//
// wszServer:    The name of the computer which should resync. 
// ulWaitFlag:   if 0 is specified, the call will be asynchronous.  Passing non-zero value
//               causes the call to block until time synchronization completes, or fails.
// ulFlags:      One of the resync types, or'd with any of the other flags.  
//               NOTE: these flags are ignored by the Windows 2000 time service.  Only
//                     Windows XP and later servers will use them.  
//
//     Resync Types:
//
//         TimeSyncFlag_SoftResync    -- the time service will synchronize the computer clock with
//                                       whatever time samples it currently has available.  It will
//                                       not poll the network, or hardware providers, for more data. 
//         TimeSyncFlag_HardResync    -- tells the time service that a time slip has occured. 
//                                       causing the time service will discard its time data.  
//                                       Microsoft default providers will attempt to acquire more 
//                                       network samples, if possible. 
//         TimeSyncFlag_Rediscover    -- tells the time service that it needs to re-resolve its
//                                       network sources, and attempt to acquire network time data. 
//                                       
//
//     Flags:
//
//         TimeSyncFlag_ReturnResult  -- used only for asynchronous calls, causes the function
//                                       to return one of its possible return status codes, or an error.
//                                       See "Return Values".
//
// Return Values:
//
//     ResyncResult_Success      --  indicates that the time synchronization has succeeded.  For asynchronous
//                                   calls, this does not guarantee that the server has acquired more data, 
//                                   merely that the request has been successfully dispatched.  
//     ResyncResult_NoData       --  Windows XP and later.  For synchronous requests, or when the 
//                                   TimeSyncFlag_ReturnResult is set, indicates that the time service couldn't
//                                   synchronize time because it failed to acquire time data. 
//     ResyncResult_StaleData    --  Windows XP and later.  For synchronous requests, or when the 
//                                   TimeSyncFlag_ReturnResult is set, indicates that the time service couldn't
//                                   synchronize time because the data it received was stale (time stamped
//                                   as received earlier than the last good sample)
//     ResyncResult_Shutdown     --  Windows XP and later.  For synchronous requests, or when the 
//                                   TimeSyncFlag_ReturnResult is set, indicates that the time service couldn't
//                                   synchronize because the service was shutting down
//     ResyncResult_ChangeTooBig --  Windows XP and later.  For synchronous requests, or when the 
//                                   TimeSyncFlag_ReturnResult is set, indicates that the time service couldn't
//                                   synchronize because it would've required a change larger than that allowed
//                                   by the w32time policy
//
//     Otherwise, the function returns a standard windows error.
// 
#ifndef MIDL_PASS
DWORD W32TimeSyncNow(IN  const WCHAR    *wszServer, 
                     IN  unsigned long   ulWaitFlag, 
                     IN  unsigned long   ulFlags);

#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeGetNetlogonServiceBits
//
// Queries the specified time service to determine what it advertises itself as in the
// DS.  
//
// wszServer:    The name of the computer which should resync. 
// pulBits:      A set of flags indicating what the specified time service is 
//               advertised as.  Can be the OR of the following values:
// 
//      DS_TIMESERV_FLAG:        if the service is advertising as a time service
//      DS_GOOD_TIMESERV_FLAG:   if the service is advertising as a reliable time service
//
// Return Values:
// 
//      ERROR_SUCCESS if the call succeeds, otherwise, the function returns a standard
//      windows error. 
//
#ifndef MIDL_PASS
DWORD W32TimeGetNetlogonServiceBits(IN   const WCHAR    *wszServer, 
                                    OUT  unsigned long  *pulBits);
#endif // MIDL_PASS

//--------------------------------------------------------------------------------
//
// NTP provider information structures
//
//--------------------------------------------------------------------------------

// 
// W32TIME_NTP_PEER_INFO
// 
// Represents the current state of a network provider's peer.  
//
// Fields:
//
//     ulSize                 --  sizeof(W32TIME_NTP_PEER_INFO), used for versioning
//     ulResolveAttempts      --  the number of times the NTP provider has attempted to 
//                                resolve this peer unsuccessfully.  Setting this 
//                                value to 0 indicates that the peer has been successfully
//                                resolved. 
//     u64TimeRemaining       --  the number of 100ns intervals until the provider will
//                                poll this peer again
//     u64LastSuccessfulSync  --  the number of 100ns intervals since (0h 1-Jan 1601) (in UTC). 
//     ulLastSyncError        --  S_OK if the last sync with this peer was successful, otherwise, 
//                                the error that occured attempting to sync
//     ulLastSyncErrorMsgId   --  the resource identifier of a string representing the last
//                                error that occured syncing from this peer.  0 if there is no
//                                string associated with this error.  The strings are stored in
//                                the DLL in which this provider is implemented. 
//     ulValidDataCount       --  the number of valid samples from this peer the provider 
//                                currently has in its clock filter
//     ulAuthTypeMsgId        --  the resource identifier of a string representing the 
//                                authentication mechanism used by the NTP provider to 
//                                secure communications with this peer.  0 if none. 
//                                The strings are stored in the DLL in which this 
//                                provider is implemented. 
//     wszUniqueName          --  a name uniquely identifying this peer (usually the peers
//                                dns name). 
//     ulMode                 --  one of the NTP modes specified in the NTPv3 spec:
//
//     +------------------+---+
//     | Reserved         | 0 |
//     | SymmetricActive  | 1 |
//     | SymmetricPassive | 2 |
//     | Client           | 3 |
//     | Server           | 4 |
//     | Broadcast        | 5 |
//     | Control          | 6 |
//     | PrivateUse       | 7 |
//     +------------------+---+
//                  
//     ulStratum              --  this peer's stratum
//     ulreachability         --  this peer's 1-byte reachability register.  Each bit represents
//                                whether or not a poll attempt returned valid data (set == success, 
//                                unset == failure).  The low bit indicates the most recent sync, 
//                                the second bit represents the previous sync, etc.  When this register
//                                is 0, the peer is assumed to be unreachable. 
//     ulPeerPollInterval     --  the poll interval which this peer returned to the NTP provider (in log (base 2) seconds). 
//     ulHostPollInterval     --  the interval at which the NTP provider is polling this peer (in log (base 2) seconds). 
// 
typedef struct _W32TIME_NTP_PEER_INFO { 
    unsigned __int32    ulSize; 
    unsigned __int32    ulResolveAttempts;
    unsigned __int64    u64TimeRemaining;
    unsigned __int64    u64LastSuccessfulSync; 
    unsigned __int32    ulLastSyncError; 
    unsigned __int32    ulLastSyncErrorMsgId; 
    unsigned __int32    ulValidDataCounter;
    unsigned __int32    ulAuthTypeMsgId; 
#ifdef MIDL_PASS
    [string, unique]
    wchar_t            *wszUniqueName; 
#else // MIDL_PASS
    LPWSTR              wszUniqueName;
#endif // MIDL_PASS
    unsigned   char     ulMode;
    unsigned   char     ulStratum; 
    unsigned   char     ulReachability;
    unsigned   char     ulPeerPollInterval;
    unsigned   char     ulHostPollInterval;
}  W32TIME_NTP_PEER_INFO, *PW32TIME_NTP_PEER_INFO; 

//
// W32TIME_NTP_PROVIDER_DATA
//
// Represents the state of an NTP provider.
// 
//     ulSize      --  sizeof(W32TIME_NTP_PROVIDER_DATA), used for versioning
//     ulError                  --  S_OK if the provider is functioning correctly, 
//                                  otherwise, the error which caused it to fail. 
//     ulErrorMsgId             --  the resource identifier of a string representing the
//                                  error that caused this provider to fail. 
//     cPeerInfo   --  the number of active peers used by this provider
//     pPeerInfo   --  an array of W32TIME_NTP_PEER_INFO structures, representing 
//                     the active peers this provider is currently synchronizing with
//
typedef struct _W32TIME_NTP_PROVIDER_DATA { 
    unsigned __int32        ulSize; 
    unsigned __int32        ulError; 
    unsigned __int32        ulErrorMsgId; 
    unsigned __int32        cPeerInfo; 
#ifdef MIDL_PASS
    [size_is(cPeerInfo)]
#endif // MIDL_PASS
    W32TIME_NTP_PEER_INFO  *pPeerInfo; 
} W32TIME_NTP_PROVIDER_DATA, *PW32TIME_NTP_PROVIDER_DATA;

//--------------------------------------------------------------------------------
//
// HARDWARE provider structures
//
//--------------------------------------------------------------------------------

// W32TIME_HARDWARE_PROVIDER_DATA
//
// Represents the state of a HARDWARE provider.
// 
//     ulSize                   --  sizeof(W32TIME_HARDWARE_PROVIDER_DATA), used for versioning
//     ulError                  --  S_OK if the provider is functioning correctly, 
//                                  otherwise, the error which caused it to fail. 
//     ulErrorMsgId             --  the resource identifier of a string representing the
//                                  error that caused this provider to fail. 
//     wszReferenceIdentifier   --  the synchronization source (usually, the provider's
//                                  suggested 4-byte reference ID).
//                                     
typedef struct _W32TIME_HARDWARE_PROVIDER_DATA { 
    unsigned __int32   ulSize; 
    unsigned __int32   ulError; 
    unsigned __int32   ulErrorMsgId; 
#ifdef MIDL_PASS
    [string, unique]
    wchar_t           *wszReferenceIdentifier; 
#else // MIDL_PASS
    LPWSTR             wszReferenceIdentifier; 
#endif // MIDL_PASS 
} W32TIME_HARDWARE_PROVIDER_DATA, *PW32TIME_HARDWARE_PROVIDER_DATA;


//-------------------------------------------------------------------------------------
// W32TimeQueryHardwareProviderStatus
//
// Queries the specified time service for information about one of its installed 
// time providers. 
// 
// wszServer:               The name of the computer which should resync. 
// dwFlags:                 Reserved, must be 0. 
// pwszProvider:            The name of the provider to query.  
// ppHardwareProviderData:  A structure representing the current state of this hardware provider. 
//                          The returned buffer is allocated by the system, and should be
//                          freed with W32TimeBufferFree(). 
//                         
// Return Values:
//    
//      ERROR_SUCCESS if the call succeeds, otherwise, the function returns a standard
//      windows error. 
//
#ifndef MIDL_PASS
DWORD W32TimeQueryHardwareProviderStatus(IN   const WCHAR                      *wszServer, 
                                         IN   DWORD                             dwFlags, 
                                         IN   LPWSTR                            pwszProvider, 
                                         OUT  W32TIME_HARDWARE_PROVIDER_DATA  **ppHardwareProviderData);
#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeQueryNTPProviderStatus
//
// Queries the specified time service for information about one of its installed 
// time providers. 
// 
// wszServer:          The name of the computer which should resync. 
// dwFlags:            Reserved, must be 0. 
// pwszProvider:       The name of the provider to query.  
// ppNTPProviderData:  A structure representing the current state of this hardware provider. 
//                     The returned buffer is allocated by the system, and should be
//                     freed with W32TimeBufferFree(). 
//                         
// Return Values:
//    
//      ERROR_SUCCESS if the call succeeds, otherwise, the function returns a standard
//      windows error. 
//
#ifndef MIDL_PASS
DWORD W32TimeQueryNTPProviderStatus(IN   LPCWSTR                      pwszServer, 
                                    IN   DWORD                        dwFlags, 
                                    IN   LPWSTR                       pwszProvider, 
                                    OUT  W32TIME_NTP_PROVIDER_DATA  **ppNTPProviderData); 
#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeBufferFree
//
// Frees a buffer allocated by the w32time client API. 
// 
// pvBuffer:  the buffer to free.
//
#ifndef MIDL_PASS
void W32TimeBufferFree(IN LPVOID pvBuffer); 
#endif // MIDL_PASS

//
//-------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------
//
// W32Time named events.  
// These events are ACL'd such that LocalSystem has full access.  
//
//-------------------------------------------------------------------------------------

//
// Signaling this event tells w32time that its time is off, causing the windows time
// service to attempt resynchronization.  This does not guarantee that the time service
// will successfully adjust the system clock, or that resynchronization will occur
// in a timely manner. 
// 
#define W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT    L"W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT"


#ifdef __cplusplus
}  // balance extern "C" { 
#endif
 
#endif // #ifndef __W32TIMEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\userenvp.h ===
//=============================================================================
//  userenv.h   -   Header file for user environment API.
//                  User Profiles, environment variables, and Group Policy
//
//  Copyright (c) Microsoft Corporation 1995-2002
//  All rights reserved
//
//=============================================================================


#ifndef _INC_USERENVP
#define _INC_USERENVP

#ifdef __cplusplus
extern "C" {
#endif
#define PI_LITELOAD     0x00000004      // Lite load of the profile (for system use only)
#define PI_HIDEPROFILE  0x00000008      // Mark the profile as super hidden

#ifndef _USERENV_NO_LINK_APIS_

//=============================================================================
//
// Internal flags for RSoP WMI providers
//
//=============================================================================

// planning mode provider flags
#define FLAG_INTERNAL_MASK      0x01FFFFFF

//=============================w================================================
//
// CreateGroup
//
// Creates a program group on the start menu
//
// lpGroupName  - Name of group
// bCommonGroup - Common or personal group
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
CreateGroupA(
     IN LPCSTR lpGroupName,
     IN BOOL    bCommonGroup);
USERENVAPI
BOOL
WINAPI
CreateGroupW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup);
#ifdef UNICODE
#define CreateGroup  CreateGroupW
#else
#define CreateGroup  CreateGroupA
#endif // !UNICODE


//=============================================================================
//
// CreateGroupEx
//
// Creates a program group on the start menu
//
// lpGroupName  - Name of group
// bCommonGroup - Common or personal group
// lpResourceModuleName - Name of the resource module.
// uResourceID - Resource ID for the MUI display name.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
CreateGroupExA(
     IN LPCSTR  lpGroupName,
     IN BOOL      bCommonGroup,
     IN LPCSTR  lpResourceModuleName,
     IN UINT      uResourceID);
USERENVAPI
BOOL
WINAPI
CreateGroupExW(
     IN LPCWSTR  lpGroupName,
     IN BOOL      bCommonGroup,
     IN LPCWSTR  lpResourceModuleName,
     IN UINT      uResourceID);
#ifdef UNICODE
#define CreateGroupEx  CreateGroupExW
#else
#define CreateGroupEx  CreateGroupExA
#endif // !UNICODE


//=============================================================================
//
// DeleteGroup
//
// Deletes a program group on the start menu and all of its contents
//
// lpGroupName  - Name of group
// bCommonGroup - Common or personal group
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:  This function uses a delnode routine.  Make sure you really want
//        to delete the group before you call this function.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
DeleteGroupA(
     IN LPCSTR lpGroupName,
     IN BOOL    bCommonGroup);
USERENVAPI
BOOL
WINAPI
DeleteGroupW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup);
#ifdef UNICODE
#define DeleteGroup  DeleteGroupW
#else
#define DeleteGroup  DeleteGroupA
#endif // !UNICODE


//=============================================================================
//
// AddItem
//
// Creates an item on the Programs portion of the Start Menu in the
// requested group.
//
// lpGroupName        - Name of group
// bCommonGroup       - Common or personal group
// lpFileName         - Name of link without the .lnk extension (eg:  Notepad)
// lpCommandLine      - Command line of target path (eg:  notepad.exe)
// lpIconPath         - Optional icon path, can be NULL.
// iIconIndex         - Optional icon index, default to 0.
// lpWorkingDirectory - Working directory when target is invoked, can be NULL
// wHotKey            - Hot key for the link file, default to 0
// iShowCmd           - Specifies how the application should be launched.
//                      Use a default of SW_SHOWNORMAL
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Notes:    New applications should use the CreateLinkFile() function instead
//           of AddItem.  This allows for friendly tooltip descriptions.
//
//           The lpFileName argument should not include the .lnk extension.
//           This function will add the extension.
//
//           If the lpWorkingDirectory parameter is NULL, this function will
//           insert the home directory environment variables
//
//           If the requested group doesn't exist, it will be created.
//
//           If the lpCommandLine target is located below the system root,
//           the SystemRoot environment variable will be inserted into the path
//
//           Here's a sample of how this function is typically called:
//
//           AddItem (TEXT("Accessories"), FALSE, TEXT("Notepad"),
//                    TEXT("notepad.exe"), NULL, 0, NULL, 0, SW_SHOWNORMAL);
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
AddItemA(
     IN LPCSTR lpGroupName,
     IN BOOL    bCommonGroup,
     IN LPCSTR lpFileName,
     IN LPCSTR lpCommandLine,
     IN LPCSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd);
USERENVAPI
BOOL
WINAPI
AddItemW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd);
#ifdef UNICODE
#define AddItem  AddItemW
#else
#define AddItem  AddItemA
#endif // !UNICODE


//=============================================================================
//
// DeleteItem
//
// Deletes an item on the Programs portion of the Start Menu in the
// requested group.
//
// lpGroupName        - Name of group
// bCommonGroup       - Common or personal group
// lpFileName         - Name of link without the .lnk extension (eg:  Notepad)
// bDeleteGroup       - After deleting the link, delete the group if its empty.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Notes:    New applications should use the DeleteLinkFile() function instead
//           of DeleteItem.
//
//           The lpFileName argument should not include the .lnk extension.
//           This function will add the extension.
//
//           Here's a sample of how this function is typically called:
//
//           DeleteItem (TEXT("Accessories"), FALSE, TEXT("Notepad"), TRUE);
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files and DeleteFile to delete them.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
DeleteItemA(
     IN LPCSTR lpGroupName,
     IN BOOL     bCommonGroup,
     IN LPCSTR lpFileName,
     IN BOOL     bDeleteGroup);
USERENVAPI
BOOL
WINAPI
DeleteItemW(
     IN LPCWSTR lpGroupName,
     IN BOOL     bCommonGroup,
     IN LPCWSTR lpFileName,
     IN BOOL     bDeleteGroup);
#ifdef UNICODE
#define DeleteItem  DeleteItemW
#else
#define DeleteItem  DeleteItemA
#endif // !UNICODE


//=============================================================================
//
// AddDesktopItem
//
// Creates an item on desktop.  This function is very similar to AddItem()
// documented above.  See that function for more information.
//
// Notes:    New applications should use the CreateLinkFile() function instead
//           of AddItem.  This allows for friendly tooltip descriptions.
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
AddDesktopItemA(
     IN BOOL    bCommonItem,
     IN LPCSTR lpFileName,
     IN LPCSTR lpCommandLine,
     IN LPCSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd);
USERENVAPI
BOOL
WINAPI
AddDesktopItemW(
     IN BOOL    bCommonItem,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd);
#ifdef UNICODE
#define AddDesktopItem  AddDesktopItemW
#else
#define AddDesktopItem  AddDesktopItemA
#endif // !UNICODE


//=============================================================================
//
// DeleteDesktopItem
//
// Deletes an item from the desktop.  This function is very similar to DeleteItem()
// documented above.  See that function for more information.
//
// Notes:    New applications should use the DeleteLinkFile() function instead
//           of DeleteDesktopItem.
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files and DeleteFile to delete them.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
DeleteDesktopItemA(
     IN BOOL     bCommonItem,
     IN LPCSTR lpFileName);
USERENVAPI
BOOL
WINAPI
DeleteDesktopItemW(
     IN BOOL     bCommonItem,
     IN LPCWSTR lpFileName);
#ifdef UNICODE
#define DeleteDesktopItem  DeleteDesktopItemW
#else
#define DeleteDesktopItem  DeleteDesktopItemA
#endif // !UNICODE


//=============================================================================
//
// CreateLinkFile
//
// Creates a link file (aka shortcut) in the requested special folder or
// subdirectory of a special folder.
//
// csidl              - CSIDL_* constant of special folder.  See shlobj.h
// lpSubDirectory     - Subdirectory name.  See note below
// lpFileName         - Name of link without the .lnk extension (eg:  Notepad)
// lpCommandLine      - Command line of target path (eg:  notepad.exe)
// lpIconPath         - Optional icon path, can be NULL.
// iIconIndex         - Optional icon index, default to 0.
// lpWorkingDirectory - Working directory when target is invoked, can be NULL
// wHotKey            - Hot key for the link file, default to 0
// iShowCmd           - Specifies how the application should be launched.
//                      Use a default of SW_SHOWNORMAL
// lpDescription      - Friendly description of shortcut, can be NULL.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Notes:    New applications should use this function instead of AddItem or
//           AddDesktopItem.  This allows for friendly tooltip descriptions.
//
//           The link file name is a combination of the first three
//           parameters.  If a csidl is given, that special folder is
//           looked up first, and then the lpSubDirectory is appended to
//           it followed by the lpFileName.  If csidl is equal to 0, then
//           lpSubDirectory should contain the fully qualified path to the
//           directory the link file is to be placed in.  This allows
//           for link files to be be created outside of the scope of a
//           shell special folder.  The csidl constants are listed in
//           shlobj.h or in the Win32 documentation for SHGetSpecialFolderPath.
//           Commonly used csidl's will be:
//
//               CSIDL_PROGRAMS                 - Personal Program folder on Start Menu
//               CSIDL_COMMON_PROGRAMS          - Common Program folder on Start Menu
//               CSIDL_DESKTOPDIRECTORY         - Personal desktop folder
//               CSIDL_COMMON_DESKTOPDIRECTORY  - Common desktop folder
//
//           The lpFileName argument should not include the .lnk extension.
//           This function will add the extension.
//
//           If the lpWorkingDirectory parameter is NULL, this function will
//           insert home directory environment variables.
//
//           If the requested subdirectory doesn't exist, it will be created.
//
//           If the lpCommandLine target is located below the system root,
//           the SystemRoot environment variable will be inserted into the path
//
//           Here's a sample of how this function is typically called:
//
//           CreateLinkFile (CSIDL_PROGRAMS, TEXT("Accessories"), TEXT("Notepad"),
//                           TEXT("notepad.exe"), NULL, 0, NULL, 0, SW_SHOWNORMAL,
//                           TEXT("A simple word processor."));
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
CreateLinkFileA(
     IN INT csidl,
     IN LPCSTR lpSubDirectory,
     IN LPCSTR lpFileName,
     IN LPCSTR lpCommandLine,
     IN LPCSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd,
     IN LPCSTR lpDescription);
USERENVAPI
BOOL
WINAPI
CreateLinkFileW(
     IN INT csidl,
     IN LPCWSTR lpSubDirectory,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd,
     IN LPCWSTR lpDescription);
#ifdef UNICODE
#define CreateLinkFile  CreateLinkFileW
#else
#define CreateLinkFile  CreateLinkFileA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// CreateLinkFileEx
//
// Creates a link file (aka shortcut) in the requested special folder or
// subdirectory of a special folder.
//
// csidl                - CSIDL_* constant of special folder.  See shlobj.h
// lpSubDirectory       - Subdirectory name.  See note below
// lpFileName           - Name of link without the .lnk extension (eg:  Notepad)
// lpCommandLine        - Command line of target path (eg:  notepad.exe)
// lpIconPath           - Optional icon path, can be NULL.
// iIconIndex           - Optional icon index, default to 0.
// lpWorkingDirectory   - Working directory when target is invoked, can be NULL
// wHotKey              - Hot key for the link file, default to 0
// iShowCmd             - Specifies how the application should be launched.
//                       Use a default of SW_SHOWNORMAL
// lpDescription        - Friendly description of shortcut, can be NULL.
// lpResourceModuleName - Name of the resource module. Can be NULL
// uResourceID          - Resource ID for the MUI display name.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// for additional descriptions look in the description of Createlinkfile above.
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
CreateLinkFileExA(
     IN INT csidl,
     IN LPCSTR lpSubDirectory,
     IN LPCSTR lpFileName,
     IN LPCSTR lpCommandLine,
     IN LPCSTR lpIconPath,
     IN INT      iIconIndex,
     IN LPCSTR lpWorkingDirectory,
     IN WORD     wHotKey,
     IN INT      iShowCmd,
     IN LPCSTR lpDescription,
     IN LPCSTR lpResourceModuleName, 
     IN UINT     uResourceID);
USERENVAPI
BOOL
WINAPI
CreateLinkFileExW(
     IN INT csidl,
     IN LPCWSTR lpSubDirectory,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT      iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD     wHotKey,
     IN INT      iShowCmd,
     IN LPCWSTR lpDescription,
     IN LPCWSTR lpResourceModuleName, 
     IN UINT     uResourceID);
#ifdef UNICODE
#define CreateLinkFileEx  CreateLinkFileExW
#else
#define CreateLinkFileEx  CreateLinkFileExA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// DeleteLinkFile
//
// Deletes a link file (aka shortcut) in the requested special folder or
// subdirectory of a special folder.
//
// csidl               - CSIDL_* constant of special folder.  See shlobj.h
// lpSubDirectory      - Subdirectory name.  See note below
// lpFileName          - Name of link without the .lnk extension (eg:  Notepad)
// bDeleteSubDirectory - After deleting the link, delete the subdirectory if its empty.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Notes:    New applications should use this function instead DeleteItem or
//           DeleteDesktopItem.
//
//           The link file name is a combination of the first three
//           parameters.  If a csidl is given, that special folder is
//           looked up first, and then the lpSubDirectory is appended to
//           it followed by the lpFileName.  If csidl is equal to 0, then
//           lpSubDirectory should contain the fully qualified path to the
//           directory the link file is to be placed in.  This allows
//           for link files to be be deleted outside of the scope of a
//           shell special folder.  The csidl constants are listed in
//           shlobj.h or in the Win32 documentation for SHGetSpecialFolderPath.
//           Commonly used csidl's will be:
//
//               CSIDL_PROGRAMS                 - Personal Program folder on Start Menu
//               CSIDL_COMMON_PROGRAMS          - Common Program folder on Start Menu
//               CSIDL_DESKTOPDIRECTORY         - Personal desktop folder
//               CSIDL_COMMON_DESKTOPDIRECTORY  - Common desktop folder
//
//           The lpFileName argument should not include the .lnk extension.
//           This function will add the extension.
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files and DeleteFile to delete them.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
DeleteLinkFileA(
     IN INT csidl,
     IN LPCSTR lpSubDirectory,
     IN LPCSTR lpFileName,
     IN BOOL bDeleteSubDirectory);
USERENVAPI
BOOL
WINAPI
DeleteLinkFileW(
     IN INT csidl,
     IN LPCWSTR lpSubDirectory,
     IN LPCWSTR lpFileName,
     IN BOOL bDeleteSubDirectory);
#ifdef UNICODE
#define DeleteLinkFile  DeleteLinkFileW
#else
#define DeleteLinkFile  DeleteLinkFileA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

#endif // _USERENV_NO_LINK_APIS_


//=============================================================================
//
// InitializeProfiles
//
// This function is used by GUI mode setup only and setup repair.  It initializes
// the Default User and All User profiles and converts any common groups from
// Program Manager.
//
// bGuiModeSetup  - Gui Mode setup or not.
//
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
InitializeProfiles(
     IN BOOL bGuiModeSetup);


//*************************************************************
//
//  CopySystemProfile()
//
//  Purpose:    Create the system profile information under 
//              ProfileList entry.
//              In case of upgrade copy system profile from older
//              location to new location and delete the old system 
//              profile
//              
//  Parameters:
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError()
//
//  Comments:   This should only be called by GUI mode setup!
//
//*************************************************************

USERENVAPI
BOOL 
WINAPI 
CopySystemProfile(
    IN BOOL bCleanInstall);


//=============================================================================
//
// DetermineProfilesLocation
//
// This function is used by winlogon when GUI mode setup is about to start.
// It sets the correct user profile location in the registry.
//
// bCleanInstall    -  True if setup is performing a clean install
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
DetermineProfilesLocation(
     BOOL bCleanInstall);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// CreateUserProfile(Ex)
//
// Creates a user profile for the given user.  Used by the Win95 -> NT5
// migration code.
//
// pSid         - SID of new user
// lpUserName   - User name of new user
// lpUserHive   - Registry hive to use (optional, can be NULL)
// lpProfileDir - Receives the user's profile directory (can be NULL)
// dwDirSize    - Size of lpProfileDir
// bWin9xUpg    -   Flag to say whether it is win9x upgrade
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
CreateUserProfileA(
     IN  PSID pSid,
     IN  LPCSTR lpUserName,
     IN  LPCSTR lpUserHive,
     OUT LPSTR lpProfileDir,
     IN  DWORD dwDirSize);
USERENVAPI
BOOL
WINAPI
CreateUserProfileW(
     IN  PSID pSid,
     IN  LPCWSTR lpUserName,
     IN  LPCWSTR lpUserHive,
     OUT LPWSTR lpProfileDir,
     IN  DWORD dwDirSize);
#ifdef UNICODE
#define CreateUserProfile  CreateUserProfileW
#else
#define CreateUserProfile  CreateUserProfileA
#endif // !UNICODE

USERENVAPI
BOOL
WINAPI
CreateUserProfileExA(
     IN  PSID pSid,
     IN  LPCSTR lpUserName,
     IN  LPCSTR lpUserHive,
     OUT LPSTR lpProfileDir,
     IN  DWORD dwDirSize,
     IN  BOOL bWin9xUpg);
USERENVAPI
BOOL
WINAPI
CreateUserProfileExW(
     IN  PSID pSid,
     IN  LPCWSTR lpUserName,
     IN  LPCWSTR lpUserHive,
     OUT LPWSTR lpProfileDir,
     IN  DWORD dwDirSize,
     IN  BOOL bWin9xUpg);
#ifdef UNICODE
#define CreateUserProfileEx  CreateUserProfileExW
#else
#define CreateUserProfileEx  CreateUserProfileExA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// CopyProfileDirectory(Ex)
//
// Multi-threaded user profile coping algorithm.
//
// lpSourceDir       - Source directory
// lpDestinationDir  - Destination directory
// dwFlags           - Flags (defined below)
// ftDelRefTime      - Reference time used when deleted extra files
//                     in a CPD_SYNCHRONIZE operation
// lpExclusionList   - List of directories to exclude when copying the
//                     profile
//
// Returns:  TRUE if successful
//           FALSE if not.
//
// Notes:    When CPD_SYNCHRONIZE is used to copy a profile from one
//           location to another, all the files / directories are copied first
//           and then extra files in the target directory are deleted.  In the
//           case of 2 machines using the same roaming profile, it doesn't make
//           sense to delete the extra files everytime.  If the CPD_USEDELREFTIME
//           flag is set, then before deleting a file or directory, the
//           time on that file or directory is compared with ftDelRefTime.
//           If the time is newer, the file / directory is not deleted because
//           it is probably a new file from a different machine.  If the
//           time is older, the file / directory is deleted.
//
//           CopyProfileDirectoryEx can also exclude certain directories
//           from the copy.  If the CPD_USEEXCLUSIONLIST flag is set and
//           lpExclusionList is non-null, the specified directories (and
//           their children) will be excuded from the copy.  The format
//           of this parameter is a semi-colon separated list of directories
//           relative to the root of the source profile. For example:
//
//               Temporary Internet Files;Temp;Foo\Bar
//
//=============================================================================

//
// Flags for CopyProfileDirectory(Ex)
//

#define CPD_FORCECOPY            0x00000001  // Ignore time stamps and always copy the file
#define CPD_IGNORECOPYERRORS     0x00000002  // Ignore errors and keep going
#define CPD_IGNOREHIVE           0x00000004  // Don't copy registry hive
#define CPD_WIN95HIVE            0x00000008  // Looking for Win 9x registry hive instead of NT registry hive
#define CPD_COPYIFDIFFERENT      0x00000010  // If a file exists in both src and dest with different time stamps, always copy it.
#define CPD_SYNCHRONIZE          0x00000020  // Make dest directory structure indentical to src directory structure (delete extra files and directories)
#define CPD_SLOWCOPY             0x00000040  // Don't use multiple thread.  Copy one file at a time.
#define CPD_SHOWSTATUS           0x00000080  // Show progress dialog
#define CPD_CREATETITLE          0x00000100  // Change progress dialog title to Creating... rather than Copying...
#define CPD_COPYHIVEONLY         0x00000200  // Only copy the hive, no other files
#define CPD_USEDELREFTIME        0x00000400  // Use ftDelRefTime parameter in CopyProfileDirectoryEx
#define CPD_USEEXCLUSIONLIST     0x00000800  // Use lpExclusionList parameter in CopyProfileDirectoryEx
#define CPD_SYSTEMFILES          0x00001000  // Only copy files and directories with the system file attribute set
#define CPD_DELDESTEXCLUSIONS    0x00002000  // If a directory that is excluded in the source already exists in the destination, delete it
#define CPD_NONENCRYPTEDONLY     0x00004000  // Copy only non encrypted files
#define CPD_IGNORESECURITY       0x00008000  // Ignore the ACLs etc. on the source files
#define CPD_NOERRORUI            0x00010000  // Do not show the UI if error occurs
#define CPD_SYSTEMDIRSONLY       0x00020000  // Only copy directories with the system file attribute set
#define CPD_IGNOREENCRYPTEDFILES 0x00040000  // Ignore Encrypted files
#define CPD_IGNORELONGFILENAMES  0x00080000  // Ignore files with long file names
#define CPD_USETMPHIVEFILE       0x00100000  // user hive is still loaded


USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryA(
     IN  LPCSTR lpSourceDir,
     IN  LPCSTR lpDestinationDir,
     IN  DWORD dwFlags);
USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryW(
     IN  LPCWSTR lpSourceDir,
     IN  LPCWSTR lpDestinationDir,
     IN  DWORD dwFlags);
#ifdef UNICODE
#define CopyProfileDirectory  CopyProfileDirectoryW
#else
#define CopyProfileDirectory  CopyProfileDirectoryA
#endif // !UNICODE


USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryExA(
     IN  LPCSTR lpSourceDir,
     IN  LPCSTR lpDestinationDir,
     IN  DWORD dwFlags,
     IN  LPFILETIME ftDelRefTime,
     IN  LPCSTR lpExclusionList);
USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryExW(
     IN  LPCWSTR lpSourceDir,
     IN  LPCWSTR lpDestinationDir,
     IN  DWORD dwFlags,
     IN  LPFILETIME ftDelRefTime,
     IN  LPCWSTR lpExclusionList);
#ifdef UNICODE
#define CopyProfileDirectoryEx  CopyProfileDirectoryExW
#else
#define CopyProfileDirectoryEx  CopyProfileDirectoryExA
#endif // !UNICODE


//=============================================================================
//
// MigrateNT4ToNT5
//
// Migrates a user's profile from NT4 to NT5.  This function should
// only be called by shmgrate.exe
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
MigrateNT4ToNT5();

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// ResetUserSpecialFolderPaths
//
// Sets all of the user special folder paths back to their defaults
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
ResetUserSpecialFolderPaths();

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetSystemTempDirectory
//
// Gets the system wide temp directory in short form
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GetSystemTempDirectoryA(
    OUT LPSTR lpDir,
    IN OUT LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetSystemTempDirectoryW(
    OUT LPWSTR lpDir,
    IN OUT LPDWORD lpcchSize);
#ifdef UNICODE
#define GetSystemTempDirectory  GetSystemTempDirectoryW
#else
#define GetSystemTempDirectory  GetSystemTempDirectoryA
#endif // !UNICODE


//=============================================================================
//
// ApplySystemPolicy
//
//
// Entry point for Windows NT4 System Policy.
//
// dwFlags         - Flags
// hToken          - User's token
// hKeyCurrentUser - Registry to the root of the user's hive
// lpUserName      - User's name
// lpPolicyPath    - Path to the policy file (ntconfig.pol). Can be NULL.
// lpServerName    - Domain controller name used for group
//                   membership look up.  Can be NULL.
//
//
// Returns:  TRUE if successful
//           FALSE if not
//
//=============================================================================

#if(WINVER >= 0x0500)

#define SP_FLAG_APPLY_MACHINE_POLICY    0x00000001
#define SP_FLAG_APPLY_USER_POLICY       0x00000002

USERENVAPI
BOOL
WINAPI
ApplySystemPolicyA(
    IN DWORD dwFlags,
    IN HANDLE hToken,
    IN HKEY hKeyCurrentUser,
    IN LPCSTR lpUserName,
    IN LPCSTR lpPolicyPath,
    IN LPCSTR lpServerName);
USERENVAPI
BOOL
WINAPI
ApplySystemPolicyW(
    IN DWORD dwFlags,
    IN HANDLE hToken,
    IN HKEY hKeyCurrentUser,
    IN LPCWSTR lpUserName,
    IN LPCWSTR lpPolicyPath,
    IN LPCWSTR lpServerName);
#ifdef UNICODE
#define ApplySystemPolicy  ApplySystemPolicyW
#else
#define ApplySystemPolicy  ApplySystemPolicyA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0500)

//=============================================================================
//
// Data types and data structures for foreground policy refresh info.
//
//=============================================================================

typedef enum _tagFgPolicyRefreshReason
{
    GP_ReasonUnknown = 0,
    GP_ReasonFirstPolicy,
    GP_ReasonCSERequiresSync,
    GP_ReasonCSESyncError,
    GP_ReasonSyncForced,
    GP_ReasonSyncPolicy,
    GP_ReasonNonCachedCredentials,
    GP_ReasonSKU
} FgPolicyRefreshReason;

typedef enum _tagFgPolicyRefreshMode
{
    GP_ModeUnknown = 0,
    GP_ModeSyncForeground,
    GP_ModeAsyncForeground,
} FgPolicyRefreshMode;

typedef struct _tagFgPolicyRefreshInfo
{
    FgPolicyRefreshReason   reason;
    FgPolicyRefreshMode     mode;
} FgPolicyRefreshInfo, *LPFgPolicyRefreshInfo;

//=============================================================================
//
// SetNextFgPolicyRefreshInfo
//
// Sets information about the next foreground policy
//
// szUserSid    - user's SID for user's info, 0 for machine info
// info         - FgPolicyRefreshInfo structure with the reason and mode info
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
SetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                            FgPolicyRefreshInfo info );

//=============================================================================
//
// GetPreviousFgPolicyRefreshInfo
//
// Gets information about the previous foreground policy
//
// szUserSid    - user's SID for user's info, 0 for machine info
// pInfo        - pointer to the FgPolicyRefreshInfo structure; returns the info
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
GetPreviousFgPolicyRefreshInfo( LPWSTR szUserSid,
                                FgPolicyRefreshInfo* pInfo );

//=============================================================================
//
// GetNextFgPolicyRefreshInfo
//
// Gets information about the previous foreground policy
//
// szUserSid    - user's SID for user's info, 0 for machine info
// pInfo        - pointer to the FgPolicyRefreshInfo structure; returns info
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
GetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                            FgPolicyRefreshInfo* pInfo );

//=============================================================================
//
// ForceSyncFgPolicy
//
// Forces the next foreground policy to be Synchronous
//
// szUserSid    - user's SID for user's info, 0 for machine info
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
ForceSyncFgPolicy( LPWSTR szUserSid );

//=============================================================================
//
// WaitForUserPolicyForegroundProcessing
//
// Blocks the caller until the user foreground policy is finished
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
WaitForUserPolicyForegroundProcessing();

//=============================================================================
//
// WaitForMachinePolicyForegroundProcessing
//
// Blocks the caller until the machine foreground policy is finished
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
WaitForMachinePolicyForegroundProcessing();

//=============================================================================
//
// IsSyncForegroundPolicyRefresh
//
// Called during foreground refresh to determine whether the refresh is sync or
// async
//
// bMachine             - user or machine
// hToken               - User or machine token
//
// Returns:  TRUE if foreground  policy should be applied synchronously,
//           FALSE otherwise
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
IsSyncForegroundPolicyRefresh(  BOOL bMachine,
                                HANDLE hToken );

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// ApplyGroupPolicy
//
//
// Entry point for Group Policy.  Causes either machine or user
// policy to be applied.
//
// dwFlags         - Flags defined below
// hToken          - User or machine token
// hEvent          - Handle to an event which causes the policy thread to
//                   terminate when signaled.
// hKeyRoot        - Registry to the root of the correspond hive
//                   eg: HKLM or HKCU for the user that matches hToken
// pStatusCallback - Callback function for displaying status messages
//
//
// Returns:  If GP_BACKGROUND_REFRESH is set, a thread handle
//           the process can wait until after signaling for policy
//           to stop. If GPT_BACKGROUND_REFRESH is not set, the
//           return value is 1.
//
//           In the case of failure, NULL will be returned.
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Flags to the ApplyGroupPolicy() function
//

#define GP_MACHINE             0x00000001  // Process for machine (vs user)
#define GP_BACKGROUND_REFRESH  0x00000002  // Use background thread
#define GP_APPLY_DS_POLICY     0x00000004  // Apply policy from the DS also
#define GP_ASYNC_FOREGROUND    0x00000008  // don't wait on network services

//
// Flags set by ApplyGroupPolicy() function (do not pass these in)
//

#define GP_BACKGROUND_THREAD          0x00010000  // Background thread processing
#define GP_REGPOLICY_CPANEL           0x00020000  // Something changed in the CP settings
#define GP_SLOW_LINK                  0x00040000  // Slow network connection
#define GP_VERBOSE                    0x00080000  // Verbose output to eventlog
#define GP_FORCED_REFRESH             0x00100000  // Forced Refresh
// The 2 bit values were briefly used. 
#define GP_PLANMODE                   0x00800000  // Planning mode flag

USERENVAPI
HANDLE
WINAPI
ApplyGroupPolicy(
    IN DWORD dwFlags,
    IN HANDLE hToken,
    IN HANDLE hEvent,
    IN HKEY hKeyRoot,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback);


//=============================================================================
//
//  GenerateRsopPolicy
//
//  Generates planning mode Rsop policy for specified target
//
//  dwFlags          - Processing flags
//  bstrMachName     - Target computer name
//  bstrNewMachSOM   - New machine domain or OU
//  psaMachSecGroups - New machine security groups
//  bstrUserName     - Target user name
//  psaUserSecGroups - New user security groups
//  bstrSite         - Site of target computer
//  pwszNameSpace    - Namespace to write Rsop data
//  pProgress        - Progress indicator info
//  pMachGpoFilter   - GPO Filters that pass in machine processing
//  pUserGpoFilter   - GPO Filters that pass in user processing
//
//  Return:     True if successful, False otherwise
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GenerateRsopPolicy(
    IN DWORD dwFlags,
    IN BSTR bstrMachName,
    IN BSTR bstrNewMachSOM,
    IN SAFEARRAY *psaMachSecGroups,
    IN BSTR bstrUserName,
    IN BSTR bstrNewUserSOM,
    IN SAFEARRAY *psaUserSecGroups,
    IN BSTR bstrSite,
    IN WCHAR *pwszNameSpace,
    IN LPVOID pProgress,
    IN LPVOID pMachGpoFilter,
    IN LPVOID pUserGpoFilter);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  ShutdownGPOProcessing()
//
//  Entry point for aborting GPO processing
//
//  bMachine    -  Shutdown machine or user processing ?
//
//  Returns:    void
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
void
WINAPI
ShutdownGPOProcessing(
    IN BOOL bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  PingComputer()
//
//  Pings the specified computer
//
//  ipaddr    -  IP address of the computer in unsigned long form
//  ulSpeed   -  Data transfer rate
//
//  Notes:      For fast connections (eg: LAN), it isn't possible
//              to get accurate transfer rates since the response
//              time from the computer is less than 10ms.  In
//              this case, the function returns ERROR_SUCCESS
//              and ulSpeed is set to 0.  If the function returns
//              ERROR_SUCCESS and the ulSpeed argument is non-zero
//              the connections is slower
//
//  Returns:    ERROR_SUCCESS if successful
//              Win32 error code if not
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
PingComputer(
    IN ULONG ipaddr,
    OUT ULONG *ulSpeed);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  InitializeUserProfile()
//
//  Called by winlogon to initialize userenv.dll for loading/unloading user
//  profiles.
//
//  Returns:    fvoid
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
void
WINAPI
InitializeUserProfile();

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  EnterUserProfileLock()
//
//  Get the user profile synchronization lock for a user
//
//  Returns:    HRESULT
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
EnterUserProfileLock(LPTSTR pSid);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  LeaveUserProfileLock()
//
//  Release the user profile synchronization lock for a user
//
//  Returns:    HRESULT
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
LeaveUserProfileLock(LPTSTR pSid);

#endif /* WINVER >= 0x0500 */

//*************************************************************************
//
// SecureUserProfiles()
//
// Routine Description : 
//          This function secures user profiles during FAT->NTFS conversion.
//          The function loops through all profiles registered under current 
//          OS and sets the security for the corresponding profile directory  
//          and  nested subdirs. Assumption is the  function will be called 
//          only during FAT->NTFS conversion.
//
// Arguments : 
//          None.
//
// Return Value : 
//          None.
//
// History:    Date        Author     Comment
//             8/8/00      santanuc   Created
//
//*************************************************************************

#if(WINVER >= 0x0500)

USERENVAPI
void
WINAPI
SecureUserProfiles(void);

#endif /* WINVER >= 0x0500 */

//*************************************************************************
//
// CheckAccessForPolicyGeneration()
//
// Routine Description : 
//          This function checks whether the given user represented by the token
//          has access to generate rsop data (planning or logging)
//
// Arguments : 
//          hToken      -       Token of the user
//          szContainer	-       Container for which access needs to be checked. 
//                              Should be OU or domain container
//          szDomain    -       Domaindns where the container exists
//          bLogging    -       True if the rsop data is to be genearated for 
//                              logging mode
//          pbAccessGranted -   Access Granted or not
//                        
//
// Return Value : 
//        ERROR_SUCCESS on success. Appropriate error code otherwise
//
//*************************************************************************

#if(WINVER >= 0x0500)

USERENVAPI
DWORD 
WINAPI
CheckAccessForPolicyGeneration( HANDLE hToken, 
                                LPCWSTR szContainer,
				LPWSTR  szDomain,
                                BOOL    bLogging,
                                BOOL*   pbAccessGranted);

#endif /* WINVER >= 0x0500 */

//*************************************************************************
//
// GetGroupPolicyNetworkName()
//
// Routine Description : 
//          This function returns the name of the network from which policy
//          was applied.
//
// Arguments : 
//          szNetworkName - unicode string buffer representing the network name
//          pdwByteCount - size in bytes of the unicode string buffer
//
// Return Value : 
//          ERROR_SUCCESS if successful, error code otherwise.
//
//*************************************************************************

#if(WINVER >= 0x0500)

USERENVAPI
DWORD 
WINAPI
GetGroupPolicyNetworkName( LPWSTR szNetworkName, LPDWORD pdwByteCount );

#endif /* WINVER >= 0x0500 */

//*************************************************************
//
//  GetUserAppDataPath()
//
//  Purpose:    Returns the path for user's Appdata.
//
//  Parameters: hToken          -   User's token
//              lpFolderPath    -   Output buffer
//
//  Return:     ERROR_SUCCESS if successful
//              otherwise the error code
//
//  Comments:   If error occurs then lpFolderPath set to empty.
//              Used by Crypto guys to avoid calling SHGetFolderPath.
//
//*************************************************************

#if(WINVER >= 0x0500)

USERENVAPI
DWORD 
WINAPI
GetUserAppDataPathA(
    IN HANDLE hToken, 
    IN BOOL fLocalAppData,
    OUT LPSTR lpFolderPath
    );
USERENVAPI
DWORD 
WINAPI
GetUserAppDataPathW(
    IN HANDLE hToken, 
    IN BOOL fLocalAppData,
    OUT LPWSTR lpFolderPath
    );
#ifdef UNICODE
#define GetUserAppDataPath  GetUserAppDataPathW
#else
#define GetUserAppDataPath  GetUserAppDataPathA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetUserProfileDirFromSid
//
// Returns the path to the root of the requested user's profile
//
// pSid           -  User's SID returned from LookupAccountName()
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Documents and Settings\Joe
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
GetUserProfileDirFromSidA(
    IN PSID pSid,
    OUT LPSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetUserProfileDirFromSidW(
    IN PSID pSid,
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
#ifdef UNICODE
#define GetUserProfileDirFromSid  GetUserProfileDirFromSidW
#else
#define GetUserProfileDirFromSid  GetUserProfileDirFromSidA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  CheckXForestLogon()
//
//  Purpose:    Check if the user is logged on to a different forest, if yes, we
//              should disable roaming user profile for the user because of 
//              protential security risks. Administrator can set a policy
//              "AllowX-ForestPolicy-and-RUP" to disable this check.
//
//  Parameters: 
//              hTokenUser - user's token
//
//  Return:     S_OK on not x-forest logon, S_FALSE on x-forest logon,
//              else for failure
//
//  Comments:
//
//  History:    Date        Author     Comment
//              05/08/2002  mingzhu    Created
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HRESULT
WINAPI
CheckXForestLogon(IN HANDLE hTokenUser);

#endif /* WINVER >= 0x0500 */

#ifdef __cplusplus
}
#endif

#endif // _INC_USERENVP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\xom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       xom.h
//
//--------------------------------------------------------------------------

/* <BANNER> */

#include <wtypes.h> // Including LARGE_INTEGERS [rajnath]
/*
** Header file for the X/OPEN Object Management (XOM) Interface and Package.
*/

#ifndef XOM_HEADER
#define XOM_HEADER

/* insure that all pointers are _far and that all interface APIs follow  */
/* the PASCAL calling convention for 8088 to 80286 machines, and stdcall */
/* convention on 32-bit platforms.                                       */

#if defined(M_I8086) || defined(M_I286)
# ifndef FAR
#  define FAR _far
# endif
# ifndef NEAR
#  define NEAR _near
# endif
# ifndef XOMAPI
#  if defined(M_I286)
#   define XOMAPI _far _pascal _loadds
#  else
#   define XOMAPI _far _pascal
#  endif
# endif
#else
# ifdef FAR
#  undef FAR
# endif
# define FAR
# ifdef NEAR
#  undef NEAR
# endif
# define NEAR
#endif

#if defined(_M_IX86) && (_M_IX86 >= 300)
# define XOMAPI __stdcall
#endif

#if defined(_M_IA64)
# define XOMAPI __stdcall
#endif

#if defined(_M_AMD64)
# define XOMAPI
#endif

#pragma pack(1)

#if !defined(XOMAPI)
# error -- TARGET MACHINE TYPE NOT SUPPORTED --
#endif

/* $Workfile:   XOM.H  $ $Revision:   1.1  $ */
/* BEGIN SERVICE INTERFACE */

/* INTERMEDIATE DATA TYPES */



typedef short           OM_sint;
typedef short           OM_sint16;
typedef long int        OM_sint32;
typedef short unsigned  OM_uint;
typedef short unsigned  OM_uint16;
typedef long unsigned   OM_uint32;


typedef LARGE_INTEGER   OM_sint64;


/* PRIMARY DATA TYPES */

/* Boolean */

typedef OM_uint32 OM_boolean;

/* Element Position */

typedef OM_uint32 OM_string_length;

/* Enumeration */

typedef OM_sint32 OM_enumeration;

/* Exclusions */

typedef OM_uint OM_exclusions;

/* Integer */

typedef OM_sint32 OM_integer;

/* Large Integer */

typedef OM_sint64   OM_i8;

/* DWORD_PTR */

typedef DWORD_PTR OM_dword_ptr;

/* Modification */

typedef OM_uint OM_modification;

/* Object */

typedef struct OM_descriptor_struct FAR *OM_object;

/* String */

#ifndef OM_STRING_DEFINED
#define OM_STRING_DEFINED
typedef struct {
        OM_string_length length;
        void        FAR *elements;
} OM_string;
#endif

#define OM_STRING(string)       \
        { (OM_string_length)(sizeof(string)-1), (string) }

/* Workspace */

typedef void FAR *OM_workspace;

/* SECONDARY DATA TYPES */

/* Object Identifier */

typedef OM_string OM_object_identifier;

/* Private Object */

typedef OM_object OM_private_object;

/* Public Object */

typedef OM_object OM_public_object;

/* Return Code */

typedef OM_uint OM_return_code;

/* Syntax */

typedef OM_uint16 OM_syntax;

/* Type */

typedef OM_uint16 OM_type;

/* Type List */

typedef OM_type FAR *OM_type_list;

/* Value */

typedef struct {
        OM_uint32       padding;
        OM_object       object;
} OM_padded_object;

typedef union OM_value_union {
        OM_string         string;
        OM_boolean        boolean;
        OM_enumeration    enumeration;
        OM_integer        integer;
        OM_padded_object  object;
        OM_i8             i8;
        OM_dword_ptr      dword_ptr;
} OM_value;

/* Value Length */

typedef OM_uint32 OM_value_length;

/* Value Position */

typedef OM_uint32 OM_value_position;

/* TERTIARY DATA TYPES */

/* Descriptor */
#include <pshpack4.h>
typedef struct OM_descriptor_struct {
        OM_type                 type;
        OM_syntax               syntax;
        union OM_value_union    value;
} OM_descriptor;
#include <poppack.h>

/* SYMBOLIC CONSTANTS */

/* Boolean */

#define OM_FALSE        ( (OM_boolean) 0 )
#define OM_TRUE         ( (OM_boolean) 1 )

/* Element Position */

#define OM_LENGTH_UNSPECIFIED   ( (OM_string_length) 0xFFFFFFFF )

/* Exclusions */

#define OM_NO_EXCLUSIONS                        ( (OM_exclusions) 0 )
#define OM_EXCLUDE_ALL_BUT_THESE_TYPES          ( (OM_exclusions) 1 )
#define OM_EXCLUDE_ALL_BUT_THESE_VALUES         ( (OM_exclusions) 2 )
#define OM_EXCLUDE_MULTIPLES                    ( (OM_exclusions) 4 )
#define OM_EXCLUDE_SUBOBJECTS                   ( (OM_exclusions) 8 )
#define OM_EXCLUDE_VALUES                       ( (OM_exclusions) 16 )
#define OM_EXCLUDE_DESCRIPTORS                  ( (OM_exclusions) 32 )

/* Modification */

#define OM_INSERT_AT_BEGINNING                  ( (OM_modification) 1 )
#define OM_INSERT_AT_CERTAIN_POINT              ( (OM_modification) 2 )
#define OM_INSERT_AT_END                        ( (OM_modification) 3 )
#define OM_REPLACE_ALL                          ( (OM_modification) 4 )
#define OM_REPLACE_CERTAIN_VALUES               ( (OM_modification) 5 )

/* Object Identifiers */

/*  NOTE: These macros rely on the ## token-pasting operator of ANSI C.
 *  On many pre-ANSI compilers the same effect can be obtained by
 *  replacing ## with /**/

/* Private macro to calculate length of an object identifier
 */
#define OMP_LENGTH(oid_string)  (sizeof(OMP_O_##oid_string)-1)


/* Macro to initialise the syntax and value of an object identifier
 */
#define OM_OID_DESC(type, oid_name)                                     \
        { (type), OM_S_OBJECT_IDENTIFIER_STRING,                        \
         { { OMP_LENGTH(oid_name) , OMP_D_##oid_name } } }


/* Macro to mark the end of a public object
 */
#define OM_NULL_DESCRIPTOR                                              \
        { OM_NO_MORE_TYPES, OM_S_NO_MORE_SYNTAXES,                      \
         { 0, OM_ELEMENTS_UNSPECIFIED } }


/* Macro to make class constants available within a compilation unit
 */
#define OM_IMPORT(class_name)                                           \
                extern char  FAR    OMP_D_##class_name[] ;                 \
                extern OM_string FAR class_name;


/* Macro to allocate memory for class constants within a compilation unit
 */
#define OM_EXPORT(class_name)                                           \
        char FAR OMP_D_##class_name[] = OMP_O_##class_name ;                \
        OM_string FAR class_name =                                          \
            { OMP_LENGTH(class_name), OMP_D_##class_name } ;


/* Constant for the OM package
 */
#define OMP_O_OM_OM             "\126\006\001\002\004"

/* Constant for the Encoding class
 */
#define OMP_O_OM_C_ENCODING     "\126\006\001\002\004\001"

/* Constant for the External class
 */
#define OMP_O_OM_C_EXTERNAL     "\126\006\001\002\004\002"

/* Constant for the Object class
 */
#define OMP_O_OM_C_OBJECT       "\126\006\001\002\004\003"

/* Constant for the BER Object Identifier
 */
#define OMP_O_OM_BER            "\121\001"

/* Constant for the Canonical-BER Object Identifier
 */
#define OMP_O_OM_CANONICAL_BER  "\126\006\001\002\005"

/* Return Code */

#define OM_SUCCESS                      ( (OM_return_code) 0 )
#define OM_ENCODING_INVALID             ( (OM_return_code) 1 )
#define OM_FUNCTION_DECLINED            ( (OM_return_code) 2 )
#define OM_FUNCTION_INTERRUPTED         ( (OM_return_code) 3 )
#define OM_MEMORY_INSUFFICIENT          ( (OM_return_code) 4 )
#define OM_NETWORK_ERROR                ( (OM_return_code) 5 )
#define OM_NO_SUCH_CLASS                ( (OM_return_code) 6 )
#define OM_NO_SUCH_EXCLUSION            ( (OM_return_code) 7 )
#define OM_NO_SUCH_MODIFICATION         ( (OM_return_code) 8 )
#define OM_NO_SUCH_OBJECT               ( (OM_return_code) 9 )
#define OM_NO_SUCH_RULES                ( (OM_return_code) 10 )
#define OM_NO_SUCH_SYNTAX               ( (OM_return_code) 11 )
#define OM_NO_SUCH_TYPE                 ( (OM_return_code) 12 )
#define OM_NO_SUCH_WORKSPACE            ( (OM_return_code) 13 )
#define OM_NOT_AN_ENCODING              ( (OM_return_code) 14 )
#define OM_NOT_CONCRETE                 ( (OM_return_code) 15 )
#define OM_NOT_PRESENT                  ( (OM_return_code) 16 )
#define OM_NOT_PRIVATE                  ( (OM_return_code) 17 )
#define OM_NOT_THE_SERVICES             ( (OM_return_code) 18 )
#define OM_PERMANENT_ERROR              ( (OM_return_code) 19 )
#define OM_POINTER_INVALID              ( (OM_return_code) 20 )
#define OM_SYSTEM_ERROR                 ( (OM_return_code) 21 )
#define OM_TEMPORARY_ERROR              ( (OM_return_code) 22 )
#define OM_TOO_MANY_VALUES              ( (OM_return_code) 23 )
#define OM_VALUES_NOT_ADJACENT          ( (OM_return_code) 24 )
#define OM_WRONG_VALUE_LENGTH           ( (OM_return_code) 25 )
#define OM_WRONG_VALUE_MAKEUP           ( (OM_return_code) 26 )
#define OM_WRONG_VALUE_NUMBER           ( (OM_return_code) 27 )
#define OM_WRONG_VALUE_POSITION         ( (OM_return_code) 28 )
#define OM_WRONG_VALUE_SYNTAX           ( (OM_return_code) 29 )
#define OM_WRONG_VALUE_TYPE             ( (OM_return_code) 30 )

/* String (Elements component) */

#define OM_ELEMENTS_UNSPECIFIED         ( (void *) 0 )

/* Syntax */

#define OM_S_NO_MORE_SYNTAXES           ( (OM_syntax) 0 )
#define OM_S_BIT_STRING                 ( (OM_syntax) 3 )
#define OM_S_BOOLEAN                    ( (OM_syntax) 1 )
#define OM_S_ENCODING_STRING            ( (OM_syntax) 8 )
#define OM_S_ENUMERATION                ( (OM_syntax) 10 )
#define OM_S_GENERAL_STRING             ( (OM_syntax) 27 )
#define OM_S_GENERALISED_TIME_STRING    ( (OM_syntax) 24 )
#define OM_S_GRAPHIC_STRING             ( (OM_syntax) 25 )
#define OM_S_IA5_STRING                 ( (OM_syntax) 22 )
#define OM_S_INTEGER                    ( (OM_syntax) 2 )
#define OM_S_NULL                       ( (OM_syntax) 5 )
#define OM_S_NUMERIC_STRING             ( (OM_syntax) 18 )
#define OM_S_OBJECT                     ( (OM_syntax) 127 )
#define OM_S_OBJECT_DESCRIPTOR_STRING   ( (OM_syntax) 7 )
#define OM_S_OBJECT_IDENTIFIER_STRING   ( (OM_syntax) 6 )
#define OM_S_OCTET_STRING               ( (OM_syntax) 4 )
#define OM_S_PRINTABLE_STRING           ( (OM_syntax) 19 )
#define OM_S_TELETEX_STRING             ( (OM_syntax) 20 )
#define OM_S_UTC_TIME_STRING            ( (OM_syntax) 23 )
#define OM_S_VIDEOTEX_STRING            ( (OM_syntax) 21 )
#define OM_S_VISIBLE_STRING             ( (OM_syntax) 26 )
#define OM_S_UNICODE_STRING                 ( (OM_syntax) 64 )
#define OM_S_I8                         ( (OM_syntax) 65 )
#define OM_S_OBJECT_SECURITY_DESCRIPTOR ( (OM_syntax) 66 )
#define OM_S_LONG_STRING                ((OM_syntax) 0x8000)
#define OM_S_NO_VALUE                   ((OM_syntax) 0x4000)
#define OM_S_LOCAL_STRING               ((OM_syntax) 0x2000)
#define OM_S_SERVICE_GENERATED          ((OM_syntax) 0x1000)
#define OM_S_PRIVATE                    ((OM_syntax) 0x0800)
#define OM_S_SYNTAX                     ((OM_syntax) 0x03FF)

/* Type */

#define OM_NO_MORE_TYPES                ( (OM_type) 0 )
#define OM_ARBITRARY_ENCODING           ( (OM_type) 1 )
#define OM_ASN1_ENCODING                ( (OM_type) 2 )
#define OM_CLASS                        ( (OM_type) 3 )
#define OM_DATA_VALUE_DESCRIPTOR        ( (OM_type) 4 )
#define OM_DIRECT_REFERENCE             ( (OM_type) 5 )
#define OM_INDIRECT_REFERENCE           ( (OM_type) 6 )
#define OM_OBJECT_CLASS                 ( (OM_type) 7 )
#define OM_OBJECT_ENCODING              ( (OM_type) 8 )
#define OM_OCTET_ALIGNED_ENCODING       ( (OM_type) 9 )
#define OM_PRIVATE_OBJECT               ( (OM_type) 10 )
#define OM_RULES                        ( (OM_type) 11 )

/* Value Position */

#define OM_ALL_VALUES                   ( (OM_value_position) 0xFFFFFFFF)


/* WORKSPACE INTERFACE */

#include <xomi.h>

#pragma pack()

/* END SERVICE INTERFACE */

#endif  /* XOM_HEADER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\benaloh.h ===
#ifndef __BENALOH_H__
#define __BENALOH_H__

#ifdef __cplusplus
extern "C" {
#endif

struct BenalohData
{
    DWORD N;            /* length of modulus */
    LPDWORD M;          /* a multiple of modulus, with highest bit set */
    LPDWORD U;          /* base**(N+1) mod modulus */
    LPDWORD V;          /* modulus - U */
    LPDWORD product;
};

BOOL BenalohSetup(struct BenalohData *context, LPDWORD M, DWORD N);
void BenalohTeardown(struct BenalohData *context);
void BenalohMod(struct BenalohData *context, LPDWORD T, LPDWORD X);
void BenalohModSquare(struct BenalohData *context, LPDWORD A, LPDWORD B);
void BenalohModMultiply(struct BenalohData *context, LPDWORD A, LPDWORD B, LPDWORD C);
BOOL BenalohModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);
BOOL BenalohModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize);
DWORD BenalohEstimateQuotient(DWORD a1, DWORD a2, DWORD m1);

#ifdef __cplusplus
}
#endif

#endif // __BENALOH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\aes.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aes.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the low-level AES encryption routines


Author:

    Scott Field (SField) 09-October-2000

Revision History:

--*/


#ifndef __AES_H__
#define __AES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif



#define AES_ROUNDS_128  (10)
#define AES_ROUNDS_192  (12)
#define AES_ROUNDS_256  (14)

#define AES_MAXROUNDS   AES_ROUNDS_256


typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_MAXROUNDS+1][4][4];
    unsigned char   keytabdec[AES_MAXROUNDS+1][4][4];
} AESTable;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_128+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_128+1][4][4];
} AESTable_128;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_192+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_192+1][4][4];
} AESTable_192;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_256+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_256+1][4][4];
} AESTable_256;

#define AES_TABLESIZE   (sizeof(AESTable))
#define AES_TABLESIZE_128   (sizeof(AESTable_128))
#define AES_TABLESIZE_192   (sizeof(AESTable_192))
#define AES_TABLESIZE_256   (sizeof(AESTable_256))


#define AES_BLOCKLEN    (16)
#define AES_KEYSIZE     (32)

#define AES_KEYSIZE_128 (16)
#define AES_KEYSIZE_192 (24)
#define AES_KEYSIZE_256 (32)


void
RSA32API
aeskey(
    AESTable    *KeyTable,
    BYTE        *Key,
    int         rounds
    );

//
// generic AES crypt function -- caller can pass in keyin corresponding
// to any valid keysize.
//

void
RSA32API
aes(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );

//
// AES crypt functions that can be used by a caller that passes in a keyin
// corresponding to a known keysize.
//

void
RSA32API
aes128(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );

void
RSA32API
aes256(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );



#ifdef __cplusplus
}
#endif

#endif // __AES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\bignum.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    bignum.h

Abstract:

    bignum package routines and defines.

--*/

#include <windows.h>
#include <math.h>

#ifndef RADIX_BITS              /* If not previously #included */

#define MP_LONGEST_BITS  4096
                        /*
                           Multiple precision moduli can have up to
                           MP_LONGEST_BITS bits, which is
                           MP_LONGEST words.  Some routines allow
                           longer operands.
                        */


                        /*
                           Error messages are not printed in the
                           production version of the code.
                           In the test version, compiled
                           by MSCV with ENABLE_ERROR_MESSAGES
                           listed under PREPROCESSOR DEFINITIONS
                           in the project workspace, they are printed,
                        */

#ifndef PRINT_ERROR_MESSAGES
    #ifdef ENABLE_ERROR_MESSAGES
        #define PRINT_ERROR_MESSAGES 1
    #else
        #define PRINT_ERROR_MESSAGES 0
    #endif
#endif

#if PRINT_ERROR_MESSAGES
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#endif

#define COMPILER_GCC 1
#define COMPILER_VC  2

#ifndef COMPILER
    #ifdef __GNUC__
        #define COMPILER COMPILER_GCC
                        /* GNU compiler */
    #endif
    #ifdef _MSC_VER
        #define COMPILER COMPILER_VC
    #endif              /* Microsoft Visual C compiler */
#endif

#if !defined(COMPILER) || COMPILER <= 0
    #error -- "Unknown COMPILER"
#endif

#define COMPILER_NAME  ( \
        COMPILER == COMPILER_GCC ? "GCC compiler" \
      : COMPILER == COMPILER_VC  ? "Microsoft Visual C++ compiler" \
      : "Unknown compiler")
/*
        Major Windows operating systems
*/

#define OS_WCE 1
#define OS_WNT 2


#if defined(_WIN32_WCE)
    #define TARGET_OS OS_WCE
    #define assert(exp) 0 // or ASSERT(exp)
                 // No assert.h in Windows CE
#elif defined(WIN32)
    #define TARGET_OS OS_WNT
#else
    #error "Unknown OS target"
#endif

/*
        List of architectures on which code has been run.
        The SPARC code was used only during development,
        and is not a deliverable.
*/

#define TARGET_AMD64 1
#define TARGET_IX86 2
#define TARGET_MIPS 3
#define TARGET_PPC 4
#define TARGET_SPARC 5
#define TARGET_IA64 6
#define TARGET_ARM 7
#define TARGET_SHX 8



#ifndef TARGET
    #if defined(_M_AMD64)               // AMD 64-bit
        #define TARGET TARGET_AMD64
    #endif
    #if defined(_M_IX86) || defined(_x86)  // Intel X86 (e.g., 486, Pentium)
        #define TARGET TARGET_IX86
    #endif
    #if defined(_M_MRX000) || defined(_MIPS_) // MIPS 32-bit systems
        #define TARGET TARGET_MIPS
    #endif
    #if defined(_M_PPC)       // Motorola/Macintosh Power PC
        #define TARGET TARGET_PPC
    #endif
    #if defined(__sparc__)    // Sun SPARC
        #define TARGET TARGET_SPARC
    #endif
    #if defined(_M_IA64)      // Intel IA-64 (e.g., Merced, McKinley)
        #define TARGET TARGET_IA64
    #endif
    #if defined(_ARM_)
        #define TARGET TARGET_ARM
    #endif
    #if defined(_SH3_) || defined(_SH4_)   // Hitachi SH-3 or SH-4
        #define TARGET TARGET_SHX
    #endif
#endif

#if !defined(TARGET) || TARGET <= 0
    #error -- "Unknown TARGET"
#endif

#define TARGET_NAME ( \
          TARGET == TARGET_AMD64   ? "AMD64" \
        : TARGET == TARGET_IX86    ? "Intel x86 (x >= 3) and Pentium" \
        : TARGET == TARGET_MIPS    ? "MIPS R2000/R3000" \
        : TARGET == TARGET_PPC     ? "Macintosh/Motorola PowerPC" \
        : TARGET == TARGET_SPARC   ? "Sun SPARC" \
        : TARGET == TARGET_IA64    ? "Intel IA-64" \
        : TARGET == TARGET_ARM     ? "ARM" \
        : TARGET == TARGET_SHX     ? "Hitachi SHx" \
        : "Unknown target architecture")

/*
        USEASM_AMD64, ... specify whether to use assembly language,
        if it has been written for a platform.
*/
#ifndef USEASM
    #if TARGET == TARGET_IX86
        #define USEASM 1
    #elif TARGET == TARGET_MIPS
        #define USEASM 1
    #elif TARGET == TARGET_SHX
        #define USEASM 1
    #else
        #define USEASM 0
    #endif
#endif

#if !defined(USEASM) || (USEASM != 0 && USEASM != 1)
    #error "USEASM not defined"
#endif

#define USEASM_AMD64    (USEASM && TARGET == TARGET_AMD64)
#define USEASM_IX86     (USEASM && TARGET == TARGET_IX86)
#define USEASM_MIPS     (USEASM && TARGET == TARGET_MIPS)
#define USEASM_PPC      (USEASM && TARGET == TARGET_PPC)
#define USEASM_SPARC    (USEASM && TARGET == TARGET_SPARC)
#define USEASM_IA64     (USEASM && TARGET == TARGET_IA64)
#define USEASM_ARM      (USEASM && TARGET == TARGET_ARM)
#define USEASM_SHX      (USEASM && TARGET == TARGET_SHX)


#if USEASM_SHX
void __asm(const char*, ...);    // this declartion needed to allow inline of asm
#endif

#if COMPILER == COMPILER_VC
        /*
           Visual C recognizes _inline but not inline.
        */
    #define inline _inline

    #pragma intrinsic(abs, labs, memcpy)

    #if TARGET != TARGET_SHX
    #pragma intrinsic(memset)
    #endif

    #pragma warning(disable: 4146 4514)
         /* 4146 -- unary minus operator applied
            to unsigned type, result still unsigned.
            4514 -- unreferenced inline function
          */
#endif


#if TARGET_OS == OS_WCE
    #define assert(exp) 0 // or ASSERT(exp)
                 // No assert.h in Windows CE
    #define CEstatic static
                 // Windows CE stack limited to 64K
                 // CEstatic should be used only in
                 // test codes and other
                 // single-threaded, non-recursive. codes.
#else
    #define CEstatic
#endif

/*
        x86 assembly routines are declared naked,
        so they do their own stack management and
        register saving.

        When using a DLL on Intel platforms, all functions use
        the __stdcall convention, so the assembly routines use it too.
        To ensure they are called with the __stdcall
        conventions always (i.e., even when compiled under Microsoft
        Developer Studio), we put __stdcall explicitly in the prototypes.
*/

#if USEASM_IX86
    #define Naked86 __declspec(naked)
    #define Stdcall86 __stdcall
#else
    #define Naked86
    #define Stdcall86
#endif


#if (TARGET == TARGET_AMD64) || (TARGET == TARGET_IA64)
    #define RADIX_BITS 64
    #define RADIX_BYTES 8
    typedef   signed __int64 sdigit_t;
    typedef unsigned __int64  digit_t;
#else
    #define RADIX_BITS 32
    #define RADIX_BYTES 4
    typedef   signed __int32 sdigit_t;
    typedef unsigned __int32 digit_t;
#endif

#define MP_LONGEST (MP_LONGEST_BITS/RADIX_BITS)

#if MP_LONGEST_BITS == RADIX_BITS
    #define LG2_MP_LONGEST 0
#elif MP_LONGEST_BITS == 2*RADIX_BITS
    #define LG2_MP_LONGEST 1
#elif MP_LONGEST_BITS == 4*RADIX_BITS
    #define LG2_MP_LONGEST 2
#elif MP_LONGEST_BITS == 8*RADIX_BITS
    #define LG2_MP_LONGEST 3
#elif MP_LONGEST_BITS == 16*RADIX_BITS
    #define LG2_MP_LONGEST 4
#elif MP_LONGEST_BITS == 32*RADIX_BITS
    #define LG2_MP_LONGEST 5
#elif MP_LONGEST_BITS == 64*RADIX_BITS
    #define LG2_MP_LONGEST 6
#elif MP_LONGEST_BITS == 128*RADIX_BITS
    #define LG2_MP_LONGEST 7
#elif MP_LONGEST_BITS == 256*RADIX_BITS
    #define LG2_MP_LONGEST 8
#else
    #define LG2_MP_LONGEST 0
#endif

#if MP_LONGEST_BITS != RADIX_BITS << LG2_MP_LONGEST
    #error "Unrecognized value of MP_LONGEST_BITS"
#endif


/*
        The letter 'c' following a type name identifies
        a const entity of that type.
*/
typedef const char charc;
typedef const  digit_t  digit_tc;
typedef const sdigit_t sdigit_tc;
typedef const int intc;


typedef int BOOL;       /* Same as windef.h */
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif


#define DIGIT_ZERO ((digit_t)0)
#define DIGIT_ONE  ((digit_t)1)
#define RADIX_HALF (DIGIT_ONE << (RADIX_BITS - 1))
#define RADIXM1 (-DIGIT_ONE)
#define F_RADIX ((double)RADIXM1 + 1.0)

#define HALF_RADIX_BITS (RADIX_BITS/2)
#if (RADIX_BITS != 2*HALF_RADIX_BITS)
    #error -- "RADIX_BITS must be even"
#endif
#define RADIX_HALFMASK_BOTTOM (RADIXM1 >> HALF_RADIX_BITS)



//          Multiple-precision data is normally represented
//      in radix 2^RADIX_BITS, with RADIX_BITS bits per word.
//      Here ``word'' means type digit_t.  RADIX_BITS
//      is 32 on some architectures (Intel, MIPS, PowerPC)
//      and 64 bits on other architectures (Alpha).

//          Within Windows NT, the data type DWORD predominates.
//      DWORD is a 32-bit unsigned datatype on all platforms
//      (Intel, Alpha, MIPS, PowerPC).  DWORD data can safely be
//      written to disk on one architecture and read back on another,
//      unlike digit_t.


//      [CAUTION -- Even DWORD is not safe when sending data to
//      big-endian architectures, such as Office products for the Macintosh.]



typedef unsigned char BYTE;
typedef unsigned long DWORD;
typedef const DWORD DWORDC;


#define DWORD_BITS 32
#define DWORD_LEFT_BIT 0x80000000UL

#if RADIX_BITS % DWORD_BITS != 0
    #error "RADIX_BITS not a multiple of 32"
#endif

#define DWORDS_PER_DIGIT (RADIX_BITS/DWORD_BITS)

//      DWORDS_TO_DIGITS(lng_dwords) computes the number of digit_t
//      elements required to store an array with -lng_dwords- DWORDs.
//      DIGITS_TO_DWORDS converts in the opposite direction.


#define DWORDS_TO_DIGITS(lng_dwords) \
                ( ((lng_dwords) + DWORDS_PER_DIGIT - 1)/DWORDS_PER_DIGIT)

#define DIGITS_TO_DWORDS(lng_digits) ((lng_digits) * DWORDS_PER_DIGIT)

#define BITS_TO_DIGITS(nb) (((nb) + RADIX_BITS - 1)/RADIX_BITS)



/*
        DOUBLE_SHIFT_LEFT(n1, n0, amt) returns
        n1 shifted left by amt bits,
        with new bits coming in from the top of n0.

        DOUBLE_SHIFT_RIGHT(n1, n0, amt) returns n0 shifted right
        by amt bits, with new bits coming from the bottom of n1.

        The shift counts must satisfy 0 <= amt <= RADIX_BITS - 1.
        The shift by    RADIX_BITS - amt   is done in two stages
        (first by 1, then by RADIX_BITS - 1 - amt),
        to avoid an illegal shift count of RADIX_BITS if amt = 0.

        DOUBLE_SHIFT_LEFT_NONZERO and DOUBLE_SHIFT_RIGHT_NONZERO
        are similar, but disallow a zero shift count, allowing the
        RADIX_BITS - amt shift to be done in one stage,
        DOUBLE_SHIFT_LEFT_NONZERO(n1, n0, amt) is the same as
        DOUBLE_SHIFT_RIGHT_NONZERO(n1, n0, RADIX_BITS - amt).

        TBD -- If the x86 VC compiler optimizes __int64 shifts,
        (6.0 SP3 does not), try to rewrite these definitions to generate
        SHLD and SHRD instructions..
*/

#define DOUBLE_SHIFT_LEFT(n1, n0, amt)  \
        (((n1) << (amt)) | (((n0) >> 1) >> (RADIX_BITS - 1 - (amt))))

#define DOUBLE_SHIFT_LEFT_NONZERO(n1, n0, amt)  \
        (((n1) << (amt)) | ((n0) >> (RADIX_BITS - (amt))))

#define DOUBLE_SHIFT_RIGHT(n1, n0, amt)  \
        (((n0) >> (amt)) | (((n1) << 1) << (RADIX_BITS - 1 - (amt))))

#define DOUBLE_SHIFT_RIGHT_NONZERO(n1, n0, amt)  \
        (((n0) >> (amt)) | ((n1) << (RADIX_BITS - (amt))))

#include "dblint.h"

#define digit_getbit(iword, ibit) (((iword) >> (ibit)) & 1)
#define dword_getbit(iword, ibit) digit_getbit(iword, ibit)
                        /* Extract bit from a word.
                        // 0 <= ibit <= RADIX_BITS - 1.
                        // Rightmost (i.e., least significant) bit is bit 0.
                        */

/*
        Test whether a number is odd or even.
*/
#define IS_EVEN(n) (~(n) & 1)
#define IS_ODD(n) ((n) & 1)

/*
        Maximum and minimum of two arguments
        (no side effects in arguments)
*/

#if 0
    #define MAX _max
    #define MIN _min
#else
    #define MAX(x, y) ((x) > (y) ? (x) : (y))
    #define MIN(x, y) ((x) > (y) ? (y) : (x))
#endif

#if 0
/*
        If we are building a DLL, use __declspec before certain variable
        declarations (and out procedure names in a .def file).
        _PM_DLL should be #defined when compiling bignum but not the application.

        If we are building a static library, use normal C declarations.
*/
    #ifdef _PM_DLL
        #define exportable_var __declspec( dllexport )
        #define exportable_var_declaration __declspec (dllexport)
    #else
        #define exportable_var __declspec( dllimport )
    #endif
#else
    #define exportable_var extern
    #define exportable_var_declaration
#endif
#



/*
        Macro to return 3^i (exponentiation), for 0 <= i <= 15.
        Intended for use with constant argument, such as
        in array dimensions.  The POWER3 array should
        be used if the argument is variable.
*/

#define POWER3CON(i) (   ((i) & 1 ?  3 : 1)  *  ((i) & 2 ?    9 : 1) \
                       * ((i) & 4 ? 81 : 1)  *  ((i) & 8 ? 6561 : 1) )

exportable_var DWORDC POWER3[16];   /* See mpglobals.c */
/*
        kara.c repeatedly replaces an operand by three
        half-length operands and a sign.  The sign has
        type kara_sign_t.  The operands are partitioned
        in half until their size at most VMUL_MAX_LNG_SINGLE,
        and sometimes further (see padinfo_initialization in kara.c)
        This may require up to KARA_MAX_HALVINGS halvings,
        giving 3^KARA_MAX_HALVINGS outputs each with size
        as large as VMUL_MAX_SINGLE words.  The signs
        array has length (3^KARA_MAX_HALVINGS - 1)/2.
*/
#if TARGET == TARGET_ALPHA
    typedef int kara_sign_t;
                        /* Try to avoid char data on Alpha */
#else
    typedef unsigned char kara_sign_t;
                        /* Values SIGN_PLUS, SIGN_MINUS.  See kara.c. */
#endif

typedef const kara_sign_t kara_sign_tc;
#define VMUL_MAX_LNG_SINGLE 12
#define KARA_MAX_HALVINGS (LG2_MP_LONGEST - 2)
#if KARA_MAX_HALVINGS > 15
    #error -- "Extend POWER3CON macro"
#endif
#define KARA_MAX_LNG_DIFS ((MP_LONGEST >> KARA_MAX_HALVINGS) * POWER3CON(KARA_MAX_HALVINGS))
#define KARA_MAX_LNG_SIGNS ((POWER3CON(KARA_MAX_HALVINGS) - 1)/2)
#define MEMORY_BANK_ALLOWANCE 1

typedef struct  {
                  digit_t     difs[KARA_MAX_LNG_DIFS + MEMORY_BANK_ALLOWANCE];
                  kara_sign_t signs[KARA_MAX_LNG_SIGNS];
                } kara_longest_t;   /* For MP_LONGEST or less */
                       /* On the Pentium P5 and P6,
                          the two arguments to vmulnn
                          should lie in different memory banks
                          (i.e., different addresses mod 32 bytes).
                          We make the .difs arrays one digit_t entry
                          larger than essential, in an attempt to reduce
                          data cache conflicts.  Look for the
                          MEMORY_BANK_ALLOWANCE symbol in the source code.
                        */


#define kara_longest_NULL ((kara_longest_t*)0)
typedef struct  {
                  digit_t     difs[KARA_MAX_LNG_DIFS/3 + MEMORY_BANK_ALLOWANCE];
                  kara_sign_t signs[KARA_MAX_LNG_SIGNS/3];
                } kara_half_longest_t;  /* For MP_LONGEST/2 or less */

typedef const kara_half_longest_t kara_half_longest_tc;
typedef const kara_longest_t      kara_longest_tc;

typedef struct {      /* Constants relating to padding lengths. */
                  DWORD  length;
                                /* length = length3[0] * 2^nhalving */
                  DWORD  nhalving;
                  DWORD  length3[KARA_MAX_HALVINGS+1];
                                /* length3[0] is 1, 2, 3, or 4 */
                                /* length3[i] is length3[0] * 3^i */
               } padinfo_t;

typedef const padinfo_t padinfo_tc;
#define padinfo_NULL ((padinfo_t*)0)

/*
        The reciprocal_1_t type is used when div21
        or divide or divide_immediate would otherwise
        divide by the same number repeatedly.  See file divide.c.
*/

typedef struct {
                digit_t multiplier;
                DWORD   shiftamt;
               } reciprocal_1_t;

typedef const reciprocal_1_t reciprocal_1_tc;

/*
        mp_modulus_t struct has modulus-dependent constants
        used for fast reduction (typically for a fixed modulus,
        which will be used several times, as in modular exponentiation).
        These constants are initialized by function create_modulus:

        modulus -- Modulus used for computations.  Must be nonzero.

        length  -- Length of the modulus, without leading zeros.
                   Operands to mod_add, mod_mul, mod_sub, ...
                   are assumed to have this length.

        padinfo -- Pointer to a padinfo_t struct.  For fast arithmetic,
                   operands are padded to a length
                   length_padded >= length (see find_padinfo in kara.c).
                   The value of length_padded is stored in padinfo->length.
                   The present implementation requires length_padded be either
                   a power of 2, or 3 times a power of 2.
                   For example, if length = 19, then length_padded = 24,
                   and the operands are treated as 24-word
                   operands for Karatsuba.

        half_padinfo -- Pointer to a padinfo_t struct for length
                   CEIL(length/2).  Used in modular_reduce to
                   use Karatsuba multiplication on half-length operands.
                   We denote half_length_padded = half_padinfo->length.

        reddir  -- Equal to FROM_LEFT if reductions of
                   products are done from the left (traditional
                   division), and to FROM_RIGHT if reductions of
                   products are done from the right (Montgomery reduction).

                   When using FROM_RIGHT, the modulus must be odd.
                   Arguments to mod_mul should be pre-scaled by
                   RADIX^scaling_power (mod modulus).
                   The product will be similarly scaled.

        scaling_power --  Equal to 2*half_length_padded when
                   reddir = FROM_RIGHT.  Undefined
                   if reddir = FROM_LEFT.

        one --     Constant 1 (length length), scaled if reddir = FROM_RIGHT.
                   When reddir = FROM_RIGHT, this is
                   RADIX^scaling_power (mod modulus).

        left_multiplier_first -- The first multiplier when reducing from the
                   left.  Length length.

-RADIX^(length + half_length_padded)/2^(left_reciprocal_1.shiftamt) mod modulus

        left_reciprocal_1 -- Reciprocal of the divisor starting at the
                   leftmost digit (i.e., modulus[length-1]);

        right_reciprocal_1 -- If modulus is odd, this holds
                   1/modulus (mod RADIX), for use in mod_shift.
                   Otherwise the field is zero.

        right_multiplier_second -- If reddir = FROM_RIGHT,
                   then this has 1/modulus mod RADIX^(half_length_padded).

        right_multiplier_first --   -1/RADIX^half_length_padded mod modulus.
                   Equal to

        left_multiplier_second -- Contains the half_length_padded*RADIX_BITS

            (modulus * right_multiplier_second - 1)/RADIX^half_length_padded.
                   most significant bits of (high power of 2)/modulus
                   (excluding the leading -1-).  More precisely, this has

        RADIX^(length + half_length_padded) - 1
 FLOOR( --------------------------------------- ) - RADIX^(half_length_padded)
        modulus * 2^(left_reciprocal_1.shiftamt)


                   See file divide.c for an explanation
                   about how this constant is used to get accurate
                   quotients when dividing from the left.

        left_multiplier_second_over2 -- Left_multiplier_second/2.
*/


typedef enum {FROM_LEFT, FROM_RIGHT} reddir_t;
typedef const reddir_t reddir_tc;

typedef struct {
                  digit_t   modulus[MP_LONGEST];
                  DWORD     length;      /* Length passed to create_modulus */
                  DWORD     scaling_power; /* 2*half_padinfo->length */
                  padinfo_tc *padinfo;   /* Pointer to struct containing
                                            padded length and related info */
                  padinfo_tc *half_padinfo;
                                         /* Padinfo info for CEIL(length/2) */
                  reddir_t  reddir;      /* FROM_LEFT or FROM_RIGHT */
                  reciprocal_1_t  left_reciprocal_1;
                  digit_t  right_reciprocal_1;
                                        /* 1/modulus[0] mod RADIX,
                                           if modulus is odd */

                  kara_half_longest_t modulus_kara2[2];
                                        /*
                                            Copy of modulus.

                                            Lower half_length_padded
                                            and upper
                                            length - half_length_padded
                                            words separately passed
                                            to to_kara.
                                         */
                  kara_half_longest_t left_multiplier_first_kara2[2];
                                /* Remainder when dividing
                                     -RADIX^(length + half_length_padded)
                                   / 2^(left_reciprocal_1.shiftamt)
                                   by modulus.

                                   Lower and upper halvves separately
                                   passed to to_kara.
                                */

                  kara_half_longest_t left_multiplier_second_kara;
                                /* half_length_padded*RADIX_BITS
                                   most significant bits of (left)
                                   reciprocal of modulus,
                                   excluding the leading -1-. */

                  digit_t  left_multiplier_second_over2[MP_LONGEST/2];
                                /* left_multiplier_second/2 */
                  kara_half_longest_t right_multiplier_first_kara2[2];
                                        /*  -1/RADIX^half_length_padded
                                            mod modulus.
                                        */
                  digit_t             right_multiplier_second[MP_LONGEST/2];
                  kara_half_longest_t right_multiplier_second_kara;
                              /* 1/modulus mod RADIX^(half_length_padded) */
                  digit_t  cofactor[MP_LONGEST];
                  DWORD    lng_cofactor;
                             /*
                                In factorization programs, this
                                holds the cofactor after dividing
                                modulus by any factors found.
                                Used by gcdex_jacobi.
                             */
                  digit_t  one[MP_LONGEST];
                } mp_modulus_t;


typedef const mp_modulus_t mp_modulus_tc;
/*
       The modular multiplication code and its
       relatives (e.g., modular_reduce, to_kara)
       need large amounts of temporary space
       during processing.  All big temporaries
       are gathered into a modmultemp_t struct.
       Users of these routines can allocate the
       storage themselves, and pass a pointer
       to the temporary storage (fastest), or can pass
       a null pointer (modmultemp_NULL).

*/
typedef struct {
                   // mmul fields are for mod_mul,
                   // mod_mul_kara, mod_mul_kara1

        digit_t             mmul_adifs[KARA_MAX_LNG_DIFS];
        kara_sign_t         mmul_asigns[KARA_MAX_LNG_SIGNS];
        digit_t             mmul_bdifs[KARA_MAX_LNG_DIFS
                                       + MEMORY_BANK_ALLOWANCE];
        kara_sign_t         mmul_bsigns[KARA_MAX_LNG_SIGNS];

                   // mr_ fields are for modular_reduce.
                   // The input to modular_reduce can be stored
                   // in mr_dividend -- this will save a mp_copy call.

        digit_t             mr_dividend[MAX(2*MP_LONGEST,
                                            2*KARA_MAX_LNG_DIFS+1)];

        digit_t             mr_prd1[2*MP_LONGEST];
        digit_t             mr_prd2[2*MP_LONGEST];
        digit_t             mr_mptemp[2*MP_LONGEST];

                   // htk_ fields are for half_times_kara
                   // and half_times_kara2

        digit_t             htk_abprd[2][2*KARA_MAX_LNG_DIFS/3];
        kara_half_longest_t htk_ak;
        } modmultemp_t;


/*
        mod_exp2000 returns statistics on what happened during the
        exponentiation.
*/

typedef struct {              // Statistics from mod_exp2000
                              // This struct may grow in future versions.
        DWORD cnt_mod_mul_kara;      // Calls to mod_mul_kara
        DWORD cnt_mp_copy;           // Calls to mp_copy
        DWORD cnt_to_kara;           // Calls to to_kara
    } mod_exp_stats_t;


/*
        When an error is detected, variable mp_errno is set
        to the error number and execution continues.
        If the library was compiled with #define PRINT_ERROR_MESSAGES,
        then a message is written to file mp_errfil.

        The application program should occasionally check mp_errno.

        Except for MP_ERRNO_NO_ERROR, the error numbers are
        in alphabetical order by name.  The routine issuing
        each error number is part of the name.
*/

typedef enum {
        MP_ERRNO_NO_ERROR = 0,
        MP_ERRNO_CREATE_MODULUS_LEADING_ZERO,
        MP_ERRNO_CREATE_MODULUS_MONTGOMERY_EVEN,
        MP_ERRNO_CREATE_MODULUS_TOO_LONG,
        MP_ERRNO_DIGIT_JACOBI_EVEN_DENOMINATOR,
        MP_ERRNO_DIGIT_MOD_DIVIDE_ODD_EVEN_MODULUS,
        MP_ERRNO_DIGIT_MOD_DIVIDE_ODD_NONTRIVIAL_GCD,
        MP_ERRNO_DIGIT_MOD_DIVIDE_ODD_ZERO_DENOMINATOR,
        MP_ERRNO_DIGIT_NEXT_PRIME_TOO_HIGH,
        MP_ERRNO_DIV21_INVALID_ARGUMENT,
        MP_ERRNO_DIVIDE_ESTIMATION_ERROR,
        MP_ERRNO_DIVIDE_INVALID_LENGTHS,
        MP_ERRNO_DIVIDE_LEADING_ZERO,
        MP_ERRNO_DSA_KEY_GENERATION_INVALID_SIZES,
        MP_ERRNO_DSA_PRECOMPUTE_BAD_G,
        MP_ERRNO_DSA_PRECOMPUTE_INVALID_KEY,
        MP_ERRNO_DSA_PRECOMPUTE_PQ_NONPRIME,
        MP_ERRNO_DSA_PRECOMPUTE_WRONG_SC,
        MP_ERRNO_DSA_SIGNATURE_VERIFICATION_NONTRIVIAL_GCD,
        MP_ERRNO_FIND_BIG_PRIME_BAD_CONGRUENCE_CLASS,
        MP_ERRNO_FIND_BIG_PRIME_CONG_MOD_TOO_LARGE,
        MP_ERRNO_FIND_BIG_PRIME_CONG_TO_TOO_LARGE,
        MP_ERRNO_GCDEX_JACOBI_EVEN_MODULUS,
        MP_ERRNO_KP_TOO_SHORT,
        MP_ERRNO_KPDIV_ZERO_DENOMINATOR,
        MP_ERRNO_MOD_ADD_CARRY_NONZERO,
        MP_ERRNO_MOD_SHIFT_LEFT_CARRY_NONZERO,
        MP_ERRNO_MOD_SHIFT_RIGHT_CARRY_NONZERO,
        MP_ERRNO_MOD_SHIFT_RIGHT_EVEN,
        MP_ERRNO_MOD_SUB_BORROW_NONZERO,
        MP_ERRNO_MODULAR_REDUCE_BOTTOM_BITS_DIFFERENT,
        MP_ERRNO_MODULAR_REDUCE_TOO_LONG,
        MP_ERRNO_MODULAR_REDUCE_UNEXPECTED_CARRY,
        MP_ERRNO_MP_DECIMAL_INPUT_NONDIGIT,
        MP_ERRNO_MP_DECIMAL_INPUT_OVERFLOW,
        MP_ERRNO_MP_GCD_INTERMEDIATE_EVEN,
        MP_ERRNO_MP_GCD_TOO_LONG,
        MP_ERRNO_MP_GCDEX_INTERNAL_ERROR,
        MP_ERRNO_MP_GCDEX_NONZERO_REMAINDER,
        MP_ERRNO_MP_GCDEX_ZERO_OPERAND,
        MP_ERRNO_MP_SHIFT_INVALID_SHIFT_COUNT,
        MP_ERRNO_MP_TRAILING_ZERO_COUNT_ZERO_ARG,
        MP_ERRNO_MULTIPLY_LOW_INVALID_LENGTH,
        MP_ERRNO_NO_MEMORY,      // From mp_alloc_temp
        MP_ERRNO_PADINFO_INITIALIZATION_BAD_CUTOFF,
        MP_ERRNO_RANDOM_DIGIT_INTERVAL_INVALID_PARAMETERS,
        MP_ERRNO_RANDOM_MOD_INVALID_PARAMETERS,
        MP_ERRNO_RANDOM_MOD_INVERSE_NOT_PRIME,
        MP_ERRNO_RANDOM_MOD_NONZERO_INVALID_PARAMETERS,
        MP_ERRNO_SELECT_A0B0_BAD_COFACTOR,
        MP_ERRNO_SELECT_A0B0_BAD_MU,
        MP_ERRNO_SELECT_A0B0_NON_CONSTANT_QUOTIENT,
        MP_ERRNO_SELECT_A0B0_NONZERO_REMAINDER,
        MP_ERRNO_SELECT_CURVE_BAD_FIELD_TYPE,
        MP_ERRNO_SELECT_D_UNSUCCESSFUL,
        MP_ERRNO_TO_KARA_INVALID_LENGTH,
        MP_ERRNO_TO_KARA2_INVALID_LENGTH,
        MP_ERRNO_COUNT      // Number of entries above
    } mp_errno_t;

exportable_var mp_errno_t mp_errno;

#if defined(WIN32)
#define SetMpErrno(x) SetLastError((DWORD)(mp_errno = (x)))
#define GetMpErrno()  ((mp_errno_t)GetLastError())
#else
#define SetMpErrno(x) mp_errno = (x)
#define GetMpErrno()  mp_errno
#endif

#define inadequate_memory (GetMpErrno() == MP_ERRNO_NO_MEMORY)
extern const char* mp_errno_name(const mp_errno_t);
       // Update table in mperrnam.c when adding new error message


/*
        Some routine allow an argument of digit_NULL or
        reciprocal_1_NULL when the corresponding argument
        is not otherwise used.  For example, the division
        routine allows but does not require a
        reciprocal structure as argument,
        and allows the quotient to be suppressed.
*/

#define digit_NULL ((digit_t*)0)
#define reciprocal_1_NULL ((reciprocal_1_t*)0)
#define modmultemp_NULL ((modmultemp_t*)0)

/*
        The next several #defines are used in function prototypes.
*/

#define MP_INPUT      digit_tc[]
#define MP_OUTPUT     digit_t[]
#define MP_MODIFIED   digit_t[]
#define DIFS_INPUT    MP_INPUT
#define DIFS_OUTPUT   MP_OUTPUT
#define DIFS_MODIFIED MP_MODIFIED
#define SIGNS_INPUT   kara_sign_tc[]
#define SIGNS_MODIFIED kara_sign_t[]
#define SIGNS_OUTPUT  kara_sign_t[]

extern digit_t accumulate(MP_INPUT, digit_tc, MP_MODIFIED, DWORDC);

extern digit_t Stdcall86 add_diff(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern DWORD add_full(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern digit_t Stdcall86 add_same(MP_INPUT, MP_INPUT, MP_OUTPUT, DWORDC);

extern DWORD add_signed(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern int compare_diff(MP_INPUT, DWORDC, MP_INPUT, DWORDC);

extern int compare_sum_diff(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_INPUT, DWORDC);

BOOL create_modulus(MP_INPUT, DWORDC, reddir_tc, mp_modulus_t*);

extern dblint_t dblint_gcd(dblint_tc, dblint_tc);

extern dblint_t dblint_ogcd(dblint_tc, dblint_tc);

extern digit_t dblint_sqrt(dblint_tc);

extern digit_t decumulate(MP_INPUT, digit_tc, MP_MODIFIED, DWORDC);

extern DWORD digit_factor(digit_tc, digit_t[], DWORD[]);

extern digit_t digit_gcd(digit_tc, digit_tc);

extern int digit_jacobi(digit_tc, digit_tc);

extern digit_t digit_least_prime_divisor(digit_tc);

extern digit_t digit_mod_divide_odd(digit_tc, digit_tc, digit_tc);

extern digit_t digit_ogcd(digit_tc, digit_tc);

extern char* digit_out(digit_tc);

extern digit_t digit_sqrt(digit_tc);

/*
       digit2_aligned(array) checks that _array_ is
       aligned on a 2*sizeof(digit_t) boundary.

       Assembly code versions of the software sometimes load
       or store two digit_t values with one instruction.
       Specifically, MMX code on X86 can load or store two 32-bit
       digit_t values with one 64-bit MOVQ instruction.
       IA-64 and AMD64 code can load two 64-bit values to the floating
       point registers with a load pair instruction.

       The digit2_aligned macro checks whether its operand is
       appropriately aligned.  The required alignment is never
       worse than that returned by mp_alloc_temp.


*/
#if TARGET == TARGET_IX86 || TARGET == TARGET_IA64 || TARGET == TARGET_AMD64
#define digit2_aligned(array) (((DWORD)(array) & (2*sizeof(digit_t) - 1)) == 0)
#else
#define digit2_aligned(array) (TRUE)
#endif


extern void div21(dblint_tc, digit_tc, digit_t*, digit_t*);

extern void div21_fast(dblint_tc, digit_tc,
                       reciprocal_1_tc*, digit_t*, digit_t*);

extern DWORD divide(MP_INPUT, DWORDC, MP_INPUT, DWORDC,
                       reciprocal_1_tc*, MP_OUTPUT, MP_OUTPUT);

extern DWORD divide_rounded(MP_INPUT, DWORDC, MP_INPUT, DWORDC,
                       reciprocal_1_tc*, MP_OUTPUT, MP_OUTPUT);

extern void divide_precondition_1(MP_INPUT, DWORDC, reciprocal_1_t*);

extern digit_t divide_immediate(MP_INPUT, digit_tc,
                         reciprocal_1_tc*, MP_OUTPUT, DWORDC);

extern digit_t estimated_quotient_1(digit_tc, digit_tc,
                                    digit_tc, reciprocal_1_tc*);

extern BOOL find_big_prime(DWORDC, MP_INPUT, DWORDC,
                           MP_INPUT, DWORDC, MP_OUTPUT);

extern padinfo_tc *find_padinfo(DWORDC);

DWORD from_modular(MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern int gcdex_jacobi(MP_INPUT, mp_modulus_tc*, MP_OUTPUT, MP_OUTPUT);

extern void mod_add(MP_INPUT, MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern DWORD mod_exp(MP_INPUT, MP_INPUT, DWORDC, MP_OUTPUT,
                        mp_modulus_tc*);

extern BOOL mod_exp2000(MP_INPUT, MP_INPUT, DWORDC, MP_OUTPUT,
                        mp_modulus_tc*, mod_exp_stats_t*);

extern DWORD mod_exp_immediate(MP_INPUT, digit_tc, MP_OUTPUT,
                                  mp_modulus_tc*);

extern int mod_jacobi_immediate(const signed long, mp_modulus_tc*);

extern void mod_Lucas(MP_INPUT, MP_INPUT, DWORDC, MP_OUTPUT,
                      mp_modulus_tc*);

extern void mod_LucasUV(MP_INPUT, MP_INPUT, MP_INPUT, DWORDC,
                        MP_OUTPUT, MP_OUTPUT, mp_modulus_tc*);

extern void mod_mul(MP_INPUT, MP_INPUT, MP_OUTPUT,
                    mp_modulus_tc*, modmultemp_t*);

extern void mod_mul_immediate(MP_INPUT, digit_tc,
                              MP_OUTPUT, mp_modulus_tc*);

extern void mod_mul_kara1(MP_INPUT, DIFS_INPUT, SIGNS_INPUT,
                          MP_OUTPUT, mp_modulus_tc*, modmultemp_t*);

extern void mod_mul_kara(DIFS_INPUT, SIGNS_INPUT,
                         DIFS_INPUT, SIGNS_INPUT,
                         MP_OUTPUT, mp_modulus_tc*, modmultemp_t*);

extern void mod_negate(MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern void mod_shift(MP_INPUT, intc, MP_OUTPUT, mp_modulus_tc*);

extern BOOL mod_sqrt(MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern void mod_sub(MP_INPUT, MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern BOOL modular_reduce(MP_INPUT, DWORDC, reddir_tc,
                           MP_OUTPUT, mp_modulus_tc*, modmultemp_t*);

extern void* mp_alloc_temp(DWORDC);
#define Allocate_Temporaries(typename, ptr) \
               ptr = (typename*)mp_alloc_temp(sizeof(typename))

#define Allocate_Temporaries_Multiple(nelmt, typename, ptr) \
               ptr = (typename*)mp_alloc_temp((nelmt)*sizeof(typename))


#if USEASM_ALPHA || USEASM_MIPS
extern void mp_copy(MP_INPUT, MP_OUTPUT, DWORDC);
#else
#define mp_copy(src, dest, lng) \
            memcpy((void *)(dest), (const void *)(src), (lng)*sizeof(digit_t))
#endif

extern char* mp_decimal(MP_INPUT, DWORDC);

extern long mp_decimal_input(charc*, MP_OUTPUT, DWORDC, charc**);

extern char* mp_dword_decimal(DWORDC*, DWORDC);

extern int mp_format(MP_MODIFIED, DWORDC,
                     digit_tc, charc*, char*, DWORDC);

extern void mp_free_temp(void*);
#define Free_Temporaries(ptr)    mp_free_temp((void*)ptr)

extern DWORD mp_gcd(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern DWORD mp_gcdex(MP_INPUT, DWORDC, MP_INPUT, DWORDC,
                      MP_OUTPUT, MP_OUTPUT, MP_OUTPUT, MP_OUTPUT);

extern void mp_initialization(void);

extern void mp_longshift(MP_INPUT, intc, MP_OUTPUT, DWORDC);

extern void Stdcall86 mp_mul22s(digit_tc[4], MP_MODIFIED, MP_MODIFIED, DWORDC, sdigit_t[2]);

extern void Stdcall86 mp_mul22u(digit_tc[4], MP_MODIFIED, MP_MODIFIED, DWORDC,  digit_t[2]);

extern DWORD mp_remove2(MP_MODIFIED, DWORDC);

extern digit_t mp_shift(MP_INPUT, intc, MP_OUTPUT, DWORDC);

extern DWORD mp_significant_bit_count(MP_INPUT, DWORDC);

extern BOOL mp_sqrt(MP_INPUT, MP_OUTPUT, DWORDC);

extern DWORD mp_trailing_zero_count(MP_INPUT, DWORDC);

extern void mul_kara(DIFS_INPUT, SIGNS_INPUT,
                     DIFS_INPUT, SIGNS_INPUT,
                     MP_OUTPUT,  padinfo_tc*);

extern void mul_kara_know_low(DIFS_INPUT, SIGNS_INPUT,
                              DIFS_INPUT, SIGNS_INPUT,
                              MP_INPUT, MP_OUTPUT,
                              padinfo_tc*);

extern void mul_kara_squaring(MP_INPUT, DWORDC,
                              DIFS_MODIFIED, SIGNS_MODIFIED,
                              MP_OUTPUT, padinfo_tc*,
                              modmultemp_t*);

extern void multiply(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern digit_t multiply_immediate(MP_INPUT, digit_tc, MP_OUTPUT, DWORDC);

extern void Stdcall86 multiply_low(MP_INPUT, MP_INPUT, MP_OUTPUT, DWORDC);

extern DWORD multiply_signed(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern DWORD multiply_signed_immediate(MP_INPUT, DWORDC,
                                       signed long, MP_OUTPUT);
#if TARGET_OS == OS_WCE
    #define PRIME_SIEVE_LENGTH 300
#else
    #define PRIME_SIEVE_LENGTH 3000
#endif
          // Must be multiple of 3
#if PRIME_SIEVE_LENGTH % 3 != 0
    #error "PRIME_SIEVE_LENGTH must be a multiple of 3"
#endif

extern digit_t next_prime(
    digit_tc pstart,
    digit_t *lpsievbeg,
    digit_t sieve[PRIME_SIEVE_LENGTH],
    digit_t *lpmax_sieved_squared
    );

extern void padinfo_initialization(DWORDC);

extern BOOL probable_prime(MP_INPUT, DWORDC, MP_INPUT, DWORDC, DWORDC);

extern BOOL remove_small_primes(MP_INPUT, DWORDC, digit_tc,
                                digit_t[], DWORD[], DWORD*,
                                MP_OUTPUT, DWORD*);

#if USEASM_IX86
    #define SIGNIFICANT_BIT_COUNT_DEFINED 1
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 1
    #pragma warning(disable : 4035)      /* No return value */
    static inline DWORD significant_bit_count(digit_tc pattern)
    {
    _asm {
            mov  eax,pattern        ; Nonzero pattern
            bsr  eax,eax            ; eax = index of leftmost nonzero bit
                                         ; BSR is slow on Pentium
                                         ; but fast on Pentium Pro
            inc  eax                ; Add one to get significant bit count
         }
    }
    #pragma warning(default : 4035)
#elif USEASM_ALPHA
    #define SIGNIFICANT_BIT_COUNT_DEFINED 1
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 1
    extern const BYTE half_byte_significant_bit_count[128];  /* See mpmisc.c */
            /*
                The Alpha code uses the CMPBGE instruction to
                identify which bytes are nonzero.  The most significant
                bit must occur within the leftmost nonzero byte.
                We use the CMPBGE output to identify which byte that is.
                After we extract that byte, we identify its most significant bit.
            */
    static inline DWORD significant_bit_count(digit_tc pattern)
    {
        DWORDC zero_byte_pattern = __asm("cmpbge  zero, %0, v0", pattern);

        DWORDC byte_offset_plus_1
                = 8*half_byte_significant_bit_count[127 - (zero_byte_pattern >> 1)] + 1;

        return byte_offset_plus_1
                + half_byte_significant_bit_count[pattern >> byte_offset_plus_1];
    }
#else
    #define SIGNIFICANT_BIT_COUNT_DEFINED 0
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 0
           /* Algorithm faster for larger inputs.  See mpmisc.c */
    extern DWORD significant_bit_count(digit_tc);
#endif


extern digit_t Stdcall86 sub_diff(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern digit_t Stdcall86 sub_same(MP_INPUT, MP_INPUT, MP_OUTPUT, DWORDC);

#define sub_signed(a, lnga, b, lngb, c) add_signed(a, lnga, b, -(lngb), c)

extern BOOL test_primality(MP_INPUT, DWORDC);

extern BOOL test_primality_check_low(MP_INPUT, DWORDC);

extern BOOL get_prime(MP_OUTPUT, DWORDC);

extern BOOL get_generator(DWORD*, DWORD*, DWORDC);

extern void to_kara(MP_INPUT, DWORDC, DIFS_OUTPUT, SIGNS_OUTPUT,
                    padinfo_tc*);

extern BOOL to_modular(MP_INPUT, DWORDC, MP_OUTPUT, mp_modulus_tc*);


//     The following functions are indexed indirectly via pointers.
//     Also see GF2_get_funcs in field.h.

#if TARGET == TARGET_IX86
exportable_var BOOL  MMX_available;   /* See mpglobal.c */
#endif

typedef void Stdcall86 vmul_t(DIFS_INPUT, DIFS_INPUT, DIFS_OUTPUT, DWORDC);

exportable_var vmul_t *vmulnn[VMUL_MAX_LNG_SINGLE];
                /* Addresses for 1 x 1 to 12 x 12 products */
                /* Defined at end of vmul.c */


#if PRINT_ERROR_MESSAGES
    extern void mp_display(FILE*, charc*, MP_INPUT, DWORDC);
    exportable_var FILE* mp_errfil;       /* Set to stdout in mp_global.c */
    extern void mp_print_allocation_statistics(FILE*);
#endif /* PRINT_ERROR_MESSAGES */


/****************************************************************************/
static inline digit_t add_immediate(digit_tc  a[],
                                    digit_tc iadd,
                                    digit_t   b[],
                                    DWORDC    lng)
/*
        Compute b = a + iadd, where iadd has length 1.
        Both a and b have length lng.
        Function value is carry out of leftmost digit in b.
*/
{
    if (lng == 0) {
        return iadd;
    } else if (a == b && b[0] <= RADIXM1 - iadd) {
        b[0] += iadd;
        return 0;
    } else {
        return add_diff(a, lng, &iadd, 1, b);
    }
}
/***************************************************************************/
static inline int compare_immediate(digit_tc  a[],
                                    digit_tc  ivalue,
                                    DWORDC    lng)
/*
        Compare a multiple-precision number to a scalar.
*/
{
    return compare_diff(a, lng, &ivalue, 1);
}
/****************************************************************************/
#if USEASM_MIPS
extern int compare_same(MP_INPUT, MP_INPUT, DWORDC);
#else
static inline int compare_same(digit_tc  a[],
                               digit_tc  b[],
                               DWORDC    lng)
/*
        Compare two multiple precision numbers a and b each of length lng.
        Function value is the sign of a - b, namely

                          +1 if a > b
                           0 if a = b
                          -1 if a < b
*/
#if USEASM_IX86
    #pragma warning(disable : 4035)      /* No return value */
{
                    /*
                            We could use REPE CMPSD,
                            but REPE is slow (4 cycles)
                            on the Pentium.  Plus we
                            would need std and cld
                            to adjust the direction flag.
                            We anticipate that most loops
                            will have either 1 or 2 iterations,
                            and use RISC instructions.
                    */

    _asm {
        mov  eax,lng
        mov  esi,a
        mov  edi,b
     label1:
        test eax,eax
        jz   label2              ; If nothing left, exit with eax = 0

        mov  ecx,[esi+4*eax-4]   ;
        mov  edx,[edi+4*eax-4]

        dec  eax                 ; Decrement remaining loop count
        cmp  ecx,edx             ; Test a[i] - b[i]

        je   label1

        sbb  eax,eax             ; eax = 0 if a > b,   -1 if a < b
        or   eax,1               ; eax = 1 if a > b,   -1 if a < b
     label2:
    }
}
    #pragma warning(default : 4035)
#else
{
    DWORD i;
    for (i = lng-1; i != -1; i--) {
        if (a[i] != b[i]) return (a[i] > b[i] ? +1 : -1);
    }
    return 0;
}  /* compare_same */
#endif
#endif
/****************************************************************************/
#if USEASM_ALPHA || USEASM_MIPS
    extern void mp_clear(MP_OUTPUT, DWORDC);
#elif 0
static inline void mp_clear(digit_t a[],
                            DWORDC  lnga)
/*
        Zero a multiple-precision number.
*/
{
    DWORD i;
    for (i = 0; i != lnga; i++) a[i] = 0;
}
#else
#define mp_clear(dest, lng) (void)memset((void *)(dest), 0, (lng)*sizeof(digit_t))
#endif
/****************************************************************************/
#if USEASM_ALPHA || USEASM_MIPS
    extern void mp_extend(MP_INPUT, DWORDC, MP_OUTPUT, DWORDC);
        // See alpha.s
#else
static inline void mp_extend(digit_tc  a[],
                             DWORDC    lnga,
                             digit_t   b[],
                             DWORDC    lngb)
/*
        Copy a to b, while changing its length from
        lnga to lngb (zero fill).  Require lngb >= lnga.
*/
{
    mp_copy(a, b, lnga);
    mp_clear(b + lnga, lngb - lnga);
}
#endif
/****************************************************************************/
static inline digit_t mp_getbit(digit_tc a[],
                                DWORDC ibit)
                /* Extract bit of multiple precision number */
{
    return digit_getbit(a[ibit/RADIX_BITS],  ibit % RADIX_BITS);
}

/******************************************************************************/
static inline int mp_jacobi_wrt_immediate(digit_tc  numer[],
                                          DWORD     lnumer,
                                          digit_tc  denom)
// Return jacobi(numer, denom), where denom is single precision
{
   digit_tc rem = divide_immediate(numer, denom,
                                   reciprocal_1_NULL,
                                   digit_NULL, lnumer);
   return digit_jacobi(rem, denom);
} /* mp_jacobi_wrt_immediate */
/****************************************************************************/
static inline void mp_setbit(digit_t   a[],
                             DWORDC    ibit,
                             digit_tc  new_value)
/*
        Set a bit to 0 or 1,
        when the number is viewed as a bit array.
*/

{
    DWORDC j       = ibit / RADIX_BITS;
    DWORDC ishift  = ibit % RADIX_BITS;

    digit_tc mask1 = (DIGIT_ONE &  new_value) << ishift;
    digit_tc mask2 = (DIGIT_ONE & ~new_value) << ishift;

    a[j] = (a[j] & ~mask2) | mask1;
} // end mp_setbit
/****************************************************************************/
#if MEMORY_BANK_ALLOWANCE == 0
#define Preferred_Memory_Bank(new_array, old_array) new_array
#else
static inline digit_t* Preferred_Memory_Bank(digit_t  *new_array,
                                             digit_tc *old_array)
/*
        To avoid memory bank conflicts, it is desirable
        that (input) arguments to vmulxx assembly routines start
        on distinct memory banks, when not doing a squaring.
        If MEMORY_BANK_ALLOWANCE > 0,
        then new_array should have MEMORY_BANK_ALLOWANCE
        extra entries at the end.  We return either
        new_array or new_array + 1, whichever ensures the
        addresses are distinct.

        CAUTION -- This routine does non-portable pointer manipulations.
*/
{
    return new_array + (1 & ~(old_array - new_array));
}
#endif
/****************************************************************************/
static inline void set_immediate(digit_t  a[],
                                 digit_tc ivalue,
                                 DWORDC   lnga)
{
   a[0] = ivalue;
   mp_clear(a + 1, lnga - 1);
}
/****************************************************************************/
static inline DWORD set_immediate_signed(digit_t     a[],
                                         signed long ivalue)
{
    a[0] = labs(ivalue);
    return (ivalue > 0) - (ivalue < 0);     /* Sign of result  -- -1, 0, +1  */
}
/****************************************************************************/

#if USEASM_MIPS
extern DWORD significant_digit_count(MP_INPUT, DWORDC);
#else
static inline DWORD significant_digit_count(digit_tc  a[],
                                            DWORDC    lng)
/*
        Return the number of significant digits in a.
        Function value is zero precisely when a == 0.
*/
#if USEASM_IX86
    #pragma warning(disable : 4035)      /* No return value */
{
                /*
                   We could use REPE SCASD,
                   but the REPE overhead is
                   four cycles/compare on the Pentium.
                   We would also need sld and cld.
                   It is shorter to use RISC instructions.
                   We anticipate that the leading term a[lng-1]
                   will usually be nonzero.
                */

    _asm {
        mov  eax,lng
        mov  edx,a
     label1:
        test eax,eax
        jz   label2             ; If nothing left in number, return 0

        mov  ecx,[edx+4*eax-4]
        dec  eax

        test ecx,ecx            ; Test leading digit
        jz   label1

        inc  eax                ; Nonzero element found; return old eax
     label2:
    }
}
    #pragma warning(default : 4035)
#else
{
    DWORD i = lng;

    while (i != 0 && a[i-1] == 0) i--;
    return i;
}  /* significant_digit_count */
#endif
#endif
#define all_zero(a, lng) (significant_digit_count(a, lng) == 0)
/****************************************************************************/
static inline digit_t sub_immediate(digit_tc  a[],
                                    digit_tc  isub,
                                    digit_t   b[],
                                    DWORDC    lng)
/*
        Compute b = a - isub, where isub has length 1.
        Both a and b have length lng.
        Function value is borrow out of leftmost digit in b.
*/
{
    return (lng == 0 ? isub : sub_diff(a, lng, &isub, 1, b));
}
/****************************************************************************/
#if USEASM_IX86
#define TRAILING_ZERO_COUNT_DEFINED 1
static inline DWORD trailing_zero_count(digit_tc d)
    #pragma warning(disable : 4035)      /* No return value */
{
    _asm {
            mov  eax,d
            bsf  eax,eax            ; eax = index of rightmost nonzero bit
                                    ; BSF is slow on Pentium,
                                    ; but fast on Pentium Pro.
         }

}
    #pragma warning(default : 4035)
#elif UNIFORM_SIGNIFICANT_BIT_COUNT
#define TRAILING_ZERO_COUNT_DEFINED 1
static inline DWORD trailing_zero_count(digit_tc d)
/*
        Given a nonzero integer d, this routine computes
        the largest integer n such that 2^n divides d.

        If d = 2^n * (2k + 1), then

                        d =     k *2^(n+1) + 2^n
                       -d = (-1-k)*2^(n+1) + 2^n

        The integers k and -1 - k are one's complements of
        each other, so d & (-d) = 2^n.  Once we determine
        2^n from d, we can get n via significant_bit_count.
*/
{
    return significant_bit_count(d & (-d)) - 1;
}  /* trailing_zero_count */
#else
#define TRAILING_ZERO_COUNT_DEFINED 0
extern DWORD trailing_zero_count(digit_tc);   /* See mpmisc.c */
#endif
/****************************************************************************/
static inline void digits_to_dwords(digit_tc  pdigit[],
                                    DWORD     pdword[],
                                    DWORDC    lng_dwords)
{
#if DWORDS_PER_DIGIT == 1
    mp_copy(pdigit, (digit_t*)pdword, lng_dwords);
#elif DWORDS_PER_DIGIT == 2
    DWORDC lng_half = lng_dwords >> 1;
    DWORD i;

    if (IS_ODD(lng_dwords)) {
        pdword[lng_dwords-1] = (DWORD)pdigit[lng_half];
    }
    for (i = 0; i != lng_half; i++) {
        digit_tc dig = pdigit[i];
        pdword[2*i    ] = (DWORD)dig;
        pdword[2*i + 1] = (DWORD)(dig >> DWORD_BITS);
    }
#else
    #error "Unexpected DWORDS_PER_DIGIT"
#endif
}  /* digits_to_dwords */
/****************************************************************************/
static inline void dwords_to_digits(DWORDC  pdword[],
                                    digit_t pdigit[],
                                    DWORDC  lng_dwords)
{
#if DWORDS_PER_DIGIT == 1
    mp_copy((digit_t*)pdword, pdigit, lng_dwords);
#elif DWORDS_PER_DIGIT == 2
    DWORDC lng_half = lng_dwords >> 1;
    DWORD i;

    if (IS_ODD(lng_dwords)) {
        pdigit[lng_half] = (digit_t)pdword[lng_dwords - 1];  // Zero fill
    }
    for (i = 0; i != lng_half; i++) {
        pdigit[i] =    ((digit_t)pdword[2*i+1] << DWORD_BITS)
                     |  (digit_t)pdword[2*i];
    }
#else
    #error "Unexpected DWORDS_PER_DIGIT"
#endif
}  /* dwords_to_digits */

#endif // RADIX_BITS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\xomi.h ===
/* $Workfile:   xomi.h  $ $Revision:   1.1  $ */

/* WORKSPACE INTERFACE */

typedef OM_descriptor        OMP_object_header[2];

typedef OMP_object_header    FAR * OMP_object;

typedef OM_return_code
(XOMAPI *OMP_copy) (
        OM_private_object          original,
        OM_workspace               workspace,
        OM_private_object    FAR * copy
);

typedef OM_return_code
(XOMAPI *OMP_copy_value) (
        OM_private_object          source,
        OM_type                    source_type,
        OM_value_position          source_value_position,
        OM_private_object          destination,
        OM_type                    destination_type,
        OM_value_position          destination_value_position
);

typedef OM_return_code
(XOMAPI *OMP_create) (
        OM_object_identifier       _class,
        OM_boolean                 initialise,
        OM_workspace               workspace,
        OM_private_object    FAR * object
);

typedef OM_return_code
(XOMAPI *OMP_decode) (
        OM_private_object          encoding,
        OM_private_object    FAR * original
);

typedef OM_return_code
(XOMAPI *OMP_delete) (
        OM_object                  subject
);

typedef OM_return_code
(XOMAPI *OMP_encode) (
        OM_private_object          original,
        OM_object_identifier       rules,
        OM_private_object    FAR * encoding
);

typedef OM_return_code
(XOMAPI *OMP_get) (
        OM_private_object          original,
        OM_exclusions              exclusions,
        OM_type_list               included_types,
        OM_boolean                 local_strings,
        OM_value_position          initial_value,
        OM_value_position          limiting_value,
        OM_public_object     FAR * copy,
        OM_value_position    FAR * total_number
);

typedef OM_return_code
(XOMAPI *OMP_instance) (
        OM_object                  subject,
        OM_object_identifier       _class,
        OM_boolean           FAR * instance
);

typedef OM_return_code
(XOMAPI *OMP_put) (
        OM_private_object          destination,
        OM_modification            modification,
        OM_object                  source,
        OM_type_list               included_types,
        OM_value_position          initial_value,
        OM_value_position          limiting_value
);

typedef OM_return_code
(XOMAPI *OMP_read) (
        OM_private_object          subject,
        OM_type                    type,
        OM_value_position          value_position,
        OM_boolean                 local_string,
        OM_string_length     FAR * string_offset,
        OM_string            FAR * elements
);

typedef OM_return_code
(XOMAPI *OMP_remove) (
        OM_private_object          subject,
        OM_type                    type,
        OM_value_position          initial_value,
        OM_value_position          limiting_value
);

typedef OM_return_code
(XOMAPI *OMP_write) (
        OM_private_object          subject,
        OM_type                    type,
        OM_value_position          value_position,
        OM_syntax                  syntax,
        OM_string_length     FAR * string_offset,
        OM_string                  elements
);

/* C++ doesn't do very well with the structures	*/
/* and macros that follow here.			*/

#ifndef __cplusplus

typedef struct OMP_functions_body {
        OM_uint32       function_number;
        OMP_copy        copy;
        OMP_copy_value  copy_value;
        OMP_create      create;
        OMP_decode      decode;
        OMP_delete      delete;
        OMP_encode      encode;
        OMP_get         get;
        OMP_instance    instance;
        OMP_put         put;
        OMP_read        read;
        OMP_remove      remove;
        OMP_write       write;
} OMP_functions;
typedef struct OMP_workspace_body {
        struct OMP_functions_body    FAR * functions;
} FAR * OMP_workspace;

#define OMP_EXTERNAL(internal)  ((OM_object)((OM_descriptor FAR *)(internal) + 1))

#define OMP_INTERNAL(external)  ((OM_descriptor FAR *)(external) - 1)

#define OMP_TYPE(external)      (((OM_descriptor FAR *)(external))->type)

#define OMP_WORKSPACE(external) ((OMP_workspace)(OMP_INTERNAL(external)->value.string.elements))

#define OMP_FUNCTIONS(external) (OMP_WORKSPACE(external)->functions)

#define om_copy(ORIGINAL,WORKSPACE,COPY) ((ORIGINAL)->type == OM_PRIVATE_OBJECT ? ((OMP_workspace)(WORKSPACE))->functions->copy((ORIGINAL),(WORKSPACE),(COPY)) : OM_NOT_PRIVATE)


#define om_copy_value(SOURCE, SOURCE_TYPE, SOURCE_POSITION, DEST, DEST_TYPE, DEST_POSITION) \
((((SOURCE)->type == OM_PRIVATE_OBJECT) && ((DEST)->type == OM_PRIVATE_OBJECT)) ? OMP_FUNCTIONS(DEST)->copy_value((SOURCE), (SOURCE_TYPE), (SOURCE_POSITION), (DEST), (DEST_TYPE), (DEST_POSITION)) : OM_NOT_PRIVATE)


#ifdef PIMPORT_DLL_DATA
#define om_create(CLASS,INITIALISE,WORKSPACE,OBJECT) (((OMP_workspace)(WORKSPACE))->functions->create(*(CLASS),(INITIALISE),(WORKSPACE),(OBJECT)))
#else
#define om_create(CLASS,INITIALISE,WORKSPACE,OBJECT) (((OMP_workspace)(WORKSPACE))->functions->create((CLASS),(INITIALISE),(WORKSPACE),(OBJECT)))
#endif


#define om_decode(ENCODING,ORIGINAL) ((ENCODING)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ENCODING)->decode((ENCODING),(ORIGINAL)) : OM_NOT_PRIVATE)


#define om_delete(SUBJECT) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->delete((SUBJECT)) : OM_NOT_THE_SERVICES)


#define om_encode(ORIGINAL,RULES,ENCODING) ((ORIGINAL)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ORIGINAL)->encode((ORIGINAL),(RULES),(ENCODING)) : OM_NOT_PRIVATE)


#define om_get(ORIGINAL,EXCLUSIONS,TYPES,LOCAL_STRINGS,INITIAL,LIMIT,COPY,TOTAL_NUMBER) \
((ORIGINAL)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ORIGINAL)->get((ORIGINAL),(EXCLUSIONS),(TYPES),(LOCAL_STRINGS),(INITIAL),(LIMIT),(COPY),(TOTAL_NUMBER)) : OM_NOT_PRIVATE)


#ifdef PIMPORT_DLL_DATA
#define om_instance(SUBJECT,CLASS,INSTANCE) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->instance((SUBJECT),*(CLASS),(INSTANCE)) : OM_NOT_THE_SERVICES)
#else
#define om_instance(SUBJECT,CLASS,INSTANCE) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->instance((SUBJECT),(CLASS),(INSTANCE)) : OM_NOT_THE_SERVICES)
#endif


#define om_put(DESTINATION,MODIFICATION,SOURCE,INCLUDED_TYPES,INITIAL,LIMIT) ((DESTINATION)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(DESTINATION)->put((DESTINATION),(MODIFICATION),(SOURCE),(INCLUDED_TYPES),(INITIAL),(LIMIT)) : OM_NOT_PRIVATE)


#define om_read(SUBJECT,TYPE,VALUE_POS,LOCAL_STRING,STRING_OFFSET,ELEMENTS) ((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->read((SUBJECT),(TYPE),(VALUE_POS),(LOCAL_STRING),(STRING_OFFSET),(ELEMENTS)) : OM_NOT_PRIVATE)


#define om_remove(SUBJECT,TYPE,INITIAL,LIMIT) ((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->remove((SUBJECT),(TYPE),(INITIAL),(LIMIT)) : OM_NOT_PRIVATE)


#define om_write(SUBJECT,TYPE,VALUE_POS,SYNTAX,STRING_OFFSET,ELEMENTS) \
((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->write((SUBJECT),(TYPE),(VALUE_POS),(SYNTAX),(STRING_OFFSET),(ELEMENTS)) : OM_NOT_PRIVATE)


#else /*_cplusplus*/

typedef struct OMP_functions_body {
        OM_uint32       _function_number;
        OMP_copy        _copy;
        OMP_copy_value  _copy_value;
        OMP_create      _create;
        OMP_decode      _decode;
        OMP_delete      _delete;
        OMP_encode      _encode;
        OMP_get         _get;
        OMP_instance    _instance;
        OMP_put         _put;
        OMP_read        _read;
        OMP_remove      _remove;
        OMP_write       _write;
} OMP_functions;
typedef struct OMP_workspace_body {
        struct OMP_functions_body    FAR * _functions;
} FAR * OMP_workspace;

#define OMP_EXTERNAL(internal)  ((OM_object)((OM_descriptor FAR *)(internal) + 1))

#define OMP_INTERNAL(external)  ((OM_descriptor FAR *)(external) - 1)

#define OMP_TYPE(external)      (((OM_descriptor FAR *)(external))->type)

#define OMP_WORKSPACE(external) ((OMP_workspace)(OMP_INTERNAL(external)->value.string.elements))

#define OMP_FUNCTIONS(external) (OMP_WORKSPACE(external)->_functions)


#define om_copy(ORIGINAL,WORKSPACE,COPY) ((ORIGINAL)->type == OM_PRIVATE_OBJECT ? ((OMP_workspace)(WORKSPACE))->_functions->_copy((ORIGINAL),(WORKSPACE),(COPY)) : OM_NOT_PRIVATE)


#define om_copy_value(SOURCE, SOURCE_TYPE, SOURCE_POSITION, DEST, DEST_TYPE, DEST_POSITION) \
((((SOURCE)->type == OM_PRIVATE_OBJECT) && ((DEST)->type == OM_PRIVATE_OBJECT)) ? OMP_FUNCTIONS(DEST)->_copy_value((SOURCE), (SOURCE_TYPE), (SOURCE_POSITION), (DEST), (DEST_TYPE), (DEST_POSITION)) : OM_NOT_PRIVATE)


#define om_create(CLASS,INITIALISE,WORKSPACE,OBJECT) (((OMP_workspace)(WORKSPACE))->_functions->_create((CLASS),(INITIALISE),(WORKSPACE),(OBJECT)))


#define om_decode(ENCODING,ORIGINAL) ((ENCODING)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ENCODING)->_decode((ENCODING),(ORIGINAL)) : OM_NOT_PRIVATE)


#define om_delete(SUBJECT) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->_delete((SUBJECT)) : OM_NOT_THE_SERVICES)


#define om_encode(ORIGINAL,RULES,ENCODING) ((ORIGINAL)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ORIGINAL)->_encode((ORIGINAL),(RULES),(ENCODING)) : OM_NOT_PRIVATE)


#define om_get(ORIGINAL,EXCLUSIONS,TYPES,LOCAL_STRINGS,INITIAL,LIMIT,COPY,TOTAL_NUMBER) \
((ORIGINAL)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ORIGINAL)->_get((ORIGINAL),(EXCLUSIONS),(TYPES),(LOCAL_STRINGS),(INITIAL),(LIMIT),(COPY),(TOTAL_NUMBER)) : OM_NOT_PRIVATE)


#define om_instance(SUBJECT,CLASS,INSTANCE) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->_instance((SUBJECT),(CLASS),(INSTANCE)) : OM_NOT_THE_SERVICES)


#define om_put(DESTINATION,MODIFICATION,SOURCE,INCLUDED_TYPES,INITIAL,LIMIT) ((DESTINATION)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(DESTINATION)->_put((DESTINATION),(MODIFICATION),(SOURCE),(INCLUDED_TYPES),(INITIAL),(LIMIT)) : OM_NOT_PRIVATE)


#define om_read(SUBJECT,TYPE,VALUE_POS,LOCAL_STRING,STRING_OFFSET,ELEMENTS) ((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->_read((SUBJECT),(TYPE),(VALUE_POS),(LOCAL_STRING),(STRING_OFFSET),(ELEMENTS)) : OM_NOT_PRIVATE)


#define om_remove(SUBJECT,TYPE,INITIAL,LIMIT) ((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->_remove((SUBJECT),(TYPE),(INITIAL),(LIMIT)) : OM_NOT_PRIVATE)


#define om_write(SUBJECT,TYPE,VALUE_POS,SYNTAX,STRING_OFFSET,ELEMENTS) \
((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->_write((SUBJECT),(TYPE),(VALUE_POS),(SYNTAX),(STRING_OFFSET),(ELEMENTS)) : OM_NOT_PRIVATE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\dblint.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dblint.h

Abstract:

    Support primitives for bignum package.


--*/

/*
        File: dblint.h.  Supplement to bignum.h

        This file has declarations related to 
        double-precision integers,
        such as typedefs, constants, and primitive operations.

        Before #including this, one should #define

                digit_t -- typedef for single-precision integers.
                RADIX_BITS -- Number of bits per digit_t.

        and identify which compiler one is using.

        Constants defined herein include

                DBLINT_BUILTIN -- 1 if compiler directly
                                  supports double integers, 0 if not.

                DBLINT_HIGH_INDEX (optional)  -- When DBLINT_BUILTIN == 1,
                                  this is 0 if compiler stores
                                  the most significant half of a
                                  dblint_t datum first, and 1
                                  if compiler stores the least
                                  significant half first.  See
                                  HIGH_DIGIT and MAKE_DBLINT below.

                                  If this is not defined, then HIGH_DIGIT
                                  and MAKE_DBLINT are defined using
                                  shifts by RADIX_BITS.  If the compiler
                                  optimizes such shifts, then
                                  leave DBLINT_HIGH_INDEX undefined.


        The dblint_t type is unsigned and holds 
        twice as many bits as a digit_t datum.
        If (DBLINT_BUILTIN = 1),
        then use the type already in the language.
        Otherwise (DBLINT_BUILTIN = 0) 
        construct one of our own, 
        using a struct with two digit_t fields.

        Let u, u1, u2 have type digit_t and
        d, d1, d2 have type dblint_t.  
        The following primitives are defined, 
        whether we use the built-in type or our own type:

                DBLINT(u) -- Convert u from type digit_t to type dblint_t.             
                DBLINT_ADD(d1, d2) -- Sum d1 + d2.
                DBLINT_EQ(d1, d2)  -- Test whether d1 == d2.
                DBLINT_GE(d1, d2)  -- Test whether d1 >= d2.
                DBLINT_GT(d1, d2)  -- Test whether d1 > d2.
                DBLINT_LE(d1, d2)  -- Test whether d1 >= d2.
                DBLINT_LT(d1, d2)  -- Test whether d1 > d2.
                DBLINT_NE(d1, d2)  -- Test whether d1 <> d2.
                DBLINT_SUB(d1, d2) -- Difference d1 - d2.
                DPRODUU(u1, u2) -- Product of u1 and u2, as a dblint_t.
                HPRODUU(u1, u2) -- Most significant half of product
                                   of u1 and u2, as a digit_t.
                HIGH_DIGIT(d) -- Most significant half of d.
                LOW_DIGIT(d) -- Least significant half of d.
                MAKE_DBLINT(u1, u2) -- Construct a dblint_t
                        whose most significant half is u1 and
                        whose least significant half is u2.
*/

#if COMPILER == COMPILER_GCC

    #define DBLINT_BUILTIN 1
    typedef unsigned long long dblint_t;
    #define DBLINT_HIGH_INDEX 0  
                /* GCC on SPARC stores high half of dblint_t first */
#endif

#if COMPILER == COMPILER_VC && RADIX_BITS == 32  
    #define DBLINT_BUILTIN 1
    typedef unsigned __int64 dblint_t;
#if TARGET == TARGET_ALPHA
				/* If the Alpha is using RADIX_BITS == 32,
				   then use the shift instruction 
	               for HIGH_DIGIT and MAKE_DBLINT */ 
#else
    #define DBLINT_HIGH_INDEX 1
                /* Visual C++ on ix86 stores low half of dblint_t first */
#endif
#endif

#ifndef DBLINT_BUILTIN
                        /* No language support -- simulate using structs */
    #define DBLINT_BUILTIN 0
    typedef struct {
                     digit_t high;
                     digit_t low;
                   } dblint_t;
#endif

typedef const dblint_t dblint_tc;


#if DBLINT_BUILTIN
/*
        If language has support for double-length integers, use it.
        Good compilers will inline these simple operations.
*/

#define DBLINT(u) ((dblint_t)(u))


#define DBLINT_ADD(d1, d2) ((d1) + (d2))
#define DBLINT_EQ( d1, d2) ((d1) == (d2))
#define DBLINT_GE( d1, d2) ((d1) >= (d2))
#define DBLINT_GT( d1, d2) ((d1) > (d2))
#define DBLINT_LE( d1, d2) ((d1) <= (d2))
#define DBLINT_LT( d1, d2) ((d1) < (d2))
#define DBLINT_NE( d1, d2) ((d1) != (d2))
#define DBLINT_SUB(d1, d2) ((d1) - (d2))

#if COMPILER == COMPILER_GCC
#define DPRODUU(u1, u2) (DBLINT(u1) * DBLINT(u2))
#endif

#if COMPILER == COMPILER_VC
/*
        A problem in Visual C/C++ 4.0 (x86 version, 1995)
        prevents proper inlining of the DPRODUU function
        if we code it in a straightforward way.  Specifically,
        if we have two nearby references DPRODUU(x, y)
        and DPRODUU(x, z), where one argument (here x) is
        repeated, then the compiler calls library function
        __allmul rather than emit a MUL instruction.
        The -volatile- keyword inhibits the compiler from
        recognizing the repeated subexpression DBLINT(x),
        and circumvents the problem, alas with extra memory
        references.

		x86 version of VC 4.1 adds an __emulu function
*/
static inline dblint_t DPRODUU(digit_tc u1, digit_tc u2)
{
#if TARGET == TARGET_IX86

    #if _MFC_VER < 0x0410
        volatile digit_tc u1copy = u1, u2copy = u2;
	    return DBLINT(u1copy) * DBLINT(u2copy);
    #else
        #pragma intrinsic(__emulu)
		return __emulu(u1, u2);
    #endif
#elif TARGET == TARGET_MIPS 
        #pragma intrinsic(__emulu)
		return __emulu(u1, u2);
#else
		return DBLINT(u1) * DBLINT(u2);
#endif
}
#endif

#define LOW_DIGIT(d)   ((digit_t)(d))

#ifdef DBLINT_HIGH_INDEX
    #if DBLINT_HIGH_INDEX < 0 || DBLINT_HIGH_INDEX > 1
        #error "Illegal value of DBLINT_HIGH_INDEX"
    #endif

    static inline digit_t HIGH_DIGIT(dblint_tc d)
    {
        dblint_tc dcopy = d;
        return ((digit_tc*)&dcopy)[DBLINT_HIGH_INDEX];
    }

    static inline dblint_t MAKE_DBLINT(digit_tc high, digit_tc low)
    {
        dblint_t build = low;
        ((digit_t*)&build)[DBLINT_HIGH_INDEX] = high;
        return build;
    }
#else /* DBLINT_HIGH_INDEX */
    #define HIGH_DIGIT(d)  ((digit_t)((d) >> RADIX_BITS))

    #define MAKE_DBLINT(high, low) \
       ( (DBLINT(high) << RADIX_BITS) | DBLINT(low) )

#endif /* DBLINT_HIGH_INDEX */

#else  /* DBLINT_BUILTIN */
    

static inline dblint_t DBLINT(digit_tc d)
{
    dblint_t answer;
    answer.low = d;
    answer.high = 0;
    return answer;
}

static inline dblint_t DBLINT_ADD(dblint_tc d1, dblint_tc d2)
{
    dblint_t answer;
    answer.low = d1.low + d2.low;
    answer.high = d1.high + d2.high + (answer.low < d1.low);
    return answer;
}

static inline BOOL DBLINT_EQ(dblint_tc d1, dblint_tc d2)
{
   return (d1.high == d2.high && d1.low == d2.low);
}

static inline BOOL DBLINT_GE(dblint_tc d1, dblint_tc d2)
{
   return (d1.high == d2.high ? d1.low  >= d2.low
                              : d1.high >= d2.high);
}

static inline BOOL DBLINT_GT(dblint_tc d1, dblint_tc d2)
{
   return (d1.high == d2.high ? d1.low  > d2.low
                              : d1.high > d2.high);
}

#define DBLINT_LE(d1, d2) DBLINT_GE(d2, d1)
#define DBLINT_LT(d1, d2) DBLINT_GT(d2, d1)

static inline BOOL DBLINT_NE(dblint_tc d1, dblint_tc d2)
{
   return (d1.high != d2.high || d1.low != d2.low);
}

static inline dblint_t DBLINT_SUB(dblint_tc d1, dblint_tc d2)
{    
    dblint_t answer;
    answer.low = d1.low - d2.low;
    answer.high = d1.high - d2.high - (d1.low < d2.low);
    return answer;
}

#define HIGH_DIGIT(d) ((d).high)
#define LOW_DIGIT(d)  ((d).low)

static inline dblint_t MAKE_DBLINT(digit_tc high, digit_tc low)
{
     dblint_t answer;
     answer.low = low; 
     answer.high = high;
     return answer;
}

#if TARGET == TARGET_ALPHA
    #pragma intrinsic(__UMULH)
    #define HPRODUU(u1, u2) __UMULH(u1, u2)
    static inline dblint_t DPRODUU(digit_tc u1, digit_tc u2)
	{
		dblint_t answer;

		answer.high = HPRODUU(u1, u2);   /* Upper product */
		answer.low = u1*u2;			 	 /* Lower product */
		return answer;
	}
#else
static inline dblint_t DPRODUU(digit_tc u1, digit_tc u2)
/*                            
        Multiply two single-precision operands,
        return double precision product.
        This will normally be replaced by an assembly language routine.
        unless the top half of the product is available in C.
*/
{
    dblint_t answer;
    digit_tc u1bot = u1 & RADIX_HALFMASK_BOTTOM,  u1top = u1 >> HALF_RADIX_BITS;
    digit_tc u2bot = u2 & RADIX_HALFMASK_BOTTOM,  u2top = u2 >> HALF_RADIX_BITS;

    digit_tc low  = u1bot * u2bot;
    digit_t  mid1 = u1bot * u2top;
    digit_tc mid2 = u1top * u2bot;
    digit_tc high = u1top * u2top;
/*
        Each half-word product is bounded by
        (SQRT(RADIX) - 1)^2 = RADIX - 2*SQRT(RADIX) + 1,
        so we can add two half-word operands
        to any product without risking integer overflow.
*/
    mid1 += (mid2 & RADIX_HALFMASK_BOTTOM) + (low >> HALF_RADIX_BITS);

    answer.high = high + (mid1 >> HALF_RADIX_BITS) 
                       + (mid2 >> HALF_RADIX_BITS);
    answer.low = (low & RADIX_HALFMASK_BOTTOM) + (mid1 << HALF_RADIX_BITS);
    return answer;
}
#endif /* multiplication */ 

#endif  /* DBLINT_BUILTIN */

#ifndef HPRODUU
    #define HPRODUU(u1, u2) HIGH_DIGIT(DPRODUU(u1, u2))
#endif

/*
    The DBLINT_SUM, MULTIPLY_ADD1. MULTIPLY_ADD2
    functions take single-length (digit_t) operands and
    return double-length (dblint_t) results.
    Overflow is impossible.
*/

#if TARGET == TARGET_ALPHA && RADIX_BITS == 64 && !DBLINT_BUILT_IN
	static inline dblint_t DBLINT_SUM(digit_tc d1, digit_tc d2)
	{
        dblint_t answer;
		answer.low = d1 + d2;
		answer.high = (answer.low < d1);
		return answer;
	}
    static inline dblint_t MULTIPLY_ADD1(digit_tc d1, digit_tc d2, digit_tc d3)
	{
        dblint_t answer;
		digit_t ah, al;

        al = d1*d2;
		ah = __UMULH(d1, d2);
		al += d3;
		answer.high = ah + (al < d3);
		answer.low = al;
		return answer;
	}
	static inline dblint_t MULTIPLY_ADD2(digit_tc d1, digit_tc d2, 
		                                 digit_tc d3, digit_tc d4)
	{
		dblint_t answer;
		digit_t ah, al, bh, bl;

		al = d1*d2;
		ah = __UMULH(d1, d2);
		bl = d3 + d4;
		bh = (bl < d3);
        answer.low = al + bl;
		answer.high = ah + bh + (answer.low < al);
		return answer;
	}

#else
    #define DBLINT_SUM(d1, d2) DBLINT_ADD(DBLINT(d1), DBLINT(d2))
            /* d1 + d2 */

    #define MULTIPLY_ADD1(d1, d2, d3) \
        DBLINT_ADD(DPRODUU(d1, d2), DBLINT(d3));
           /* d1*d2 + d3 */

    #define MULTIPLY_ADD2(d1, d2, d3, d4) \
        DBLINT_ADD(DBLINT_ADD(DPRODUU(d1, d2), DBLINT(d3)), \
                   DBLINT(d4))
          /* d1*d2 + d3 + d4 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\des3.h ===
#ifndef __DES3_H__
#define __DES3_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

// In des2key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API des2key(PDES3TABLE pDES3Table, PBYTE pbKey);

// In des3key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API des3key(PDES3TABLE pDES3Table, PBYTE pbKey);

//
//   Encrypt or decrypt with the key in pKey
//

void RSA32API des3(PBYTE pbIn, PBYTE pbOut, void *pKey, int op);

//
// set the parity on the DES key to be odd
//

void RSA32API desparity(PBYTE pbKey, DWORD cbKey);

#ifdef __cplusplus
}
#endif

#endif // __DES3_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\des.h ===
#ifndef __DES_H__
#define __DES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,unsigned char *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(UCHAR *pbOut, UCHAR *pbIn, void *key, int op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(UCHAR *pbKey, ULONG cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(UCHAR *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(UCHAR *pbKey, UCHAR *pbExpanded_key);


void
RSA32API
desexpand128to192(
    UCHAR *pbKey,        // input 128bit or 192bit buffer
    UCHAR *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, UCHAR *key);

void RSA32API desx(UCHAR *pbOut, UCHAR *pbIn, void *keyin, int op);


extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\descrypt.h ===
#ifndef __DESCRYPT_H__
#define __DESCRYPT_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DECR_KEY
#define DECR_KEY  0
#define ENCR_KEY  1
#define ENCR_STD  2
#define ENCR_SES  4
#endif

#define CRYPT_ERR 1
#define CRYPT_OK  0


unsigned FAR __cdecl
DES_ECB_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);

#ifdef __cplusplus
}
#endif

#endif // __DESCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\engine.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    engine.h

Abstract:

    Defines public structures and APIs necessary to use the encryption engine

Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include "md4.h"

// This header file comes to use with FAR in it.
// Kill the FAR keyword within the file
#ifndef FAR
#define FAR
#include "descrypt.h"
#undef  FAR
#else
#include "descrypt.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\md2.h ===
#ifndef __MD2_H__
#define __MD2_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
   rights reserved.

   License to copy and use this software is granted for
   non-commercial Internet Privacy-Enhanced Mail provided that it is
   identified as the "RSA Data Security, Inc. MD2 Message Digest
   Algorithm" in all material mentioning or referencing this software
   or this function.

   RSA Data Security, Inc. makes no representations concerning either
   the merchantability of this software or the suitability of this
   software for any particular purpose. It is provided "as is"
   without express or implied warranty of any kind.

   These notices must be retained in any copies of any part of this
   documentation and/or software.
 */


typedef struct {
  unsigned char state[16];                                 /* state */
  unsigned char checksum[16];                           /* checksum */
  unsigned int count;                 /* number of bytes, modulo 16 */
  unsigned char buffer[16];                         /* input buffer */
} MD2_CTX;

int RSA32API MD2Update(MD2_CTX *, unsigned char *, unsigned int);
int RSA32API MD2Final(MD2_CTX *);
void RSA32API MD2Transform(unsigned char [16], unsigned char [16],
                  unsigned char [16]);


#ifdef __cplusplus
}
#endif

#endif // __MD2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\md5.h ===
#ifndef __MD5_H__
#define __MD5_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
} MD5_CTX;


#define MD5DIGESTLEN    16
#define MD5_LEN         MD5DIGESTLEN    // second def for WinNT source compatibility

#define PROTO_LIST(list)    list


/*
 * MTS: Each of these assumes MD5_CTX is locked against simultaneous use.
 */
void RSA32API MD5Init PROTO_LIST ((MD5_CTX *));
void RSA32API MD5Update PROTO_LIST ((MD5_CTX *, const unsigned char *, unsigned int));
void RSA32API MD5Final PROTO_LIST ((MD5_CTX *));

#ifdef __cplusplus
}
#endif

#endif // __MD5_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\md4.h ===
#ifndef __MD4_H__
#define __MD4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
** ********************************************************************
** md4.h -- Header file for implementation of                        **
** MD4 Message Digest Algorithm                                      **
** Updated: 2/13/90 by Ronald L. Rivest                              **
** (C) 1990 RSA Data Security, Inc.                                  **
** ********************************************************************
*/

#ifdef __cplusplus
extern "C" {
#endif

// MD4Update Errors
#define MD4_SUCCESS         0
#define MD4_TOO_BIG         1
#define MD4_ALREADY_DONE    2

// MD4 Digest length -- 4 word result == 16 bytes
#define MD4DIGESTLEN 16

// Block size of MD4 -- Assumes 8 bits per byte
#define MD4BLOCKSIZE 64
#define MD4BYTESTOBITS(bytes) ((bytes)*8)   // MDupdate wants bits

/* MDstruct is the data structure for a message digest computation.
*/
typedef struct {
  unsigned long buffer[4]; /* Holds 4-word result of MD computation */
  unsigned char count[8]; /* Number of bits processed so far */
  unsigned int done;      /* Nonzero means MD computation finished */
} MDstruct, *MDptr;

/* MDbegin(MD)
** Input: MD -- an MDptr
** Initialize the MDstruct prepatory to doing a message digest
** computation.
**
** MTS: Assumes MDPtr is locked against simultaneous use.
*/
extern void MDbegin(MDptr);

/* MDupdate(MD,X,count)
** Input: MD -- an MDptr
**     X -- a pointer to an array of unsigned characters.
**        count -- the number of bits of X to use (an unsigned int).
** Updates MD using the first "count" bits of X.
** The array pointed to by X is not modified.
** If count is not a multiple of 8, MDupdate uses high bits of
** last byte.
** This is the basic input routine for a user.
** The routine terminates the MD computation when count < MD4BLOCKSIZE, so
** every MD computation should end with one call to MDupdate with a
** count less than MD4BLOCKSIZE.  Zero is OK for a count.
**
** Return values:
**      MD4_SUCCESS:        success
**      MD4_TOO_LONG:       Hash is already terminated
**      MD4_ALREADY_DONE:   Length is invalid (too big)
**
** MTS: Assumes MDPtr is locked against simultaneous use.
**
**
** NOTE: MDupdate wants the length in BITS
*/
extern int MDupdate(MDptr, const unsigned char *pbData, int wLen);



/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Scott Field (sfield)    21-Oct-97

*/


#ifndef UINT4
#define UINT4   unsigned long
#endif

/* Data structure for MD4 (Message Digest) computation */
typedef struct {
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
  unsigned char digest[16];    /* actual digest after MD4Final call */
} MD4_CTX;

#define MD4_LEN 16

void RSA32API MD4Init (MD4_CTX *);
void RSA32API MD4Update (MD4_CTX *, unsigned char *, unsigned int);
void RSA32API MD4Final (MD4_CTX * );

#ifdef __cplusplus
}
#endif

#endif __MD4_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\hmac.h ===
#ifndef __HMAC_H__
#define __HMAC_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

// include "md5.h" before this

typedef struct {
    MD5_CTX context_ipad;
    MD5_CTX context_opad;
} HMACMD5_CTX;

// Initialize an HMAC context with a session key
//  Afterword, context can be used to sign messages with the session key
//
void
RSA32API
HMACMD5Init(
    HMACMD5_CTX * pCtx,                 // IN, OUT -- the context to initialize
    unsigned char *pKey,                // IN -- the session key
    unsigned int cKey                   // IN -- session key length
    );

// Update the signature of a message
//  takes a fragment of a message, updates signature for that fragment
void
RSA32API
HMACMD5Update(
  HMACMD5_CTX * pCtx,                   // IN, OUT -- context of signature to update
  unsigned char *pMsg,                  // IN -- message fragment
  unsigned int cMsg                     // IN -- message length
  );

// Get the signature out of the context, reset for next message
//
void
RSA32API
HMACMD5Final(
    HMACMD5_CTX * pCtx,                 // IN, OUT -- the context
    unsigned char Hash[MD5DIGESTLEN]    // OUT -- the signature
    );

#ifdef __cplusplus
}
#endif


#endif // __HMAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\modes.h ===
#ifndef __MODES_H__
#define __MODES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* modes.h

    Defines the generic routines used to do chaining modes with a
    block cipher.
*/


#ifdef __cplusplus
extern "C" {
#endif

// constants for operations
#define ENCRYPT     1
#define DECRYPT     0

/* CBC()
 *
 * Performs a XOR on the plaintext with the previous ciphertext
 *
 * Parameters:
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CBC(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );


/* CFB (cipher feedback)
 *
 *
 * Parameters:
 *
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CFB(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );


#ifdef __cplusplus
}
#endif

#endif // __MODES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\rc2.h ===
#ifndef __RC2_H__
#define __RC2_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1990.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Actual table size to use */
#define RC2_TABLESIZE 128

/* number of bytes in an RC2 block */
#define RC2_BLOCKLEN    8

/* RC2Key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *      pwKT        Pointer to a key table that will be initialized.
 *                      MUST be RC2_TABLESIZE.
 *      pbKey       Pointer to the key.
 *      dwLen       Size of the key, in bytes.
 *                      MUST be <= RC2_TABLESIZE.
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */
int
RSA32API
RC2Key (
    WORD *pwKT,
    BYTE *pbKey,
    DWORD dwLen
    );

/* RC2KeyEx()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *      pwKT        Pointer to a key table that will be initialized.
 *                      MUST be RC2_TABLESIZE.
 *      pbKey       Pointer to the key.
 *      dwLen       Size of the key, in bytes.
 *                      MUST be <= RC2_TABLESIZE.
 *      eSpace      effective key space in bits, 0 < n <= 1024
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */

int
RSA32API
RC2KeyEx (
    WORD *keyTable,
    BYTE *key,
    DWORD keyLen,
    DWORD eSpace
    );


/* RC2()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *      pbIn        Input buffer    -- MUST be RC2_BLOCKLEN
 *      pbOut       Output buffer   -- MUST be RC2_BLOCKLEN
 *      pwKT        Pointer to an initialized (by RC2Key) key table.
 *      op          ENCRYPT, or DECRYPT
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */
void RSA32API RC2 (BYTE *pbIn, BYTE *pbOut, void *pwKT, int op);

#ifdef __cplusplus
}
#endif

#endif // __RC2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\randlib.h ===
/*++

Copyright (c) 1993, 1998  Microsoft Corporation

Module Name:

    randlib.h

Abstract:

    Exported procedures for core cryptographic random number generation.

Author:

    Scott Field (sfield)    27-Oct-98

Revision History:

      Oct 11 1996 jeffspel moved from ntagimp1.h
      Aug 27 1997 sfield   Increase RAND_CTXT_LEN
      Aug 15 1998 sfield   Kernel mode and general cleanup

--*/

#ifndef __RANDLIB_H__
#define __RANDLIB_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif


typedef struct {
    unsigned long   cbSize;
    unsigned long   Flags;
    unsigned char   *pbRandSeed;
    unsigned long   cbRandSeed;
} RNG_CONTEXT, *PRNG_CONTEXT, *LPRNG_CONTEXT;

#define RNG_FLAG_REKEY_ONLY 1


//
// primary random number generation interface
// Functions return TRUE for success, FALSE for failure.
//

unsigned int
RSA32API
NewGenRandomEx(
    IN      RNG_CONTEXT *pRNGContext,
    IN  OUT unsigned char *pbRandBuffer,
    IN      unsigned long cbRandBuffer
    );


unsigned int
RSA32API
NewGenRandom(
    IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
    IN      unsigned long *pcbRandSeed,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    );

//
// RNG seed set and query
//

unsigned int
RSA32API
InitRand(
    IN  OUT unsigned char **ppbRandSeed,    // new seed value to set (over-writes current)
    IN      unsigned long *pcbRandSeed
    );

unsigned int
RSA32API
DeInitRand(
    IN  OUT unsigned char *pbRandSeed,      // output of current seed
    IN      unsigned long cbRandSeed
    );


//
// RNG initializers for DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH
//

unsigned int
RSA32API
InitializeRNG(
    VOID *pvReserved
    );

void
RSA32API
ShutdownRNG(
    VOID *pvReserved
    );



//
// RC4 thread safe primitives, for the bold users who stream data from RC4
// themselves.
//


//
// rc4_safe_startup called to initialize internal structures.
// typically called during DLL_PROCESS_ATTACH type initialiation code.
//

unsigned int
RSA32API
rc4_safe_startup(
    IN OUT  void **ppContext
    );

unsigned int
RSA32API
rc4_safe_startup_np(
    IN OUT  void **ppContext
    );


//
// typically call rc4_safe_shutdown during DLL_PROCESS_DETACH, with the
// value obtained during rc4_safe_startup
//

void
RSA32API
rc4_safe_shutdown(
    IN      void *pContext
    );

void
RSA32API
rc4_safe_shutdown_np(
    IN      void *pContext
    );


//
// select a safe entry.
// outputs: entry index
//          bytes used for specified index.  0xffffffff indicates caller
//          MUST call rc4_safe_key to initialize the key.
//          caller decides when to rekey based on non-zero output of pBytesUsed
//          example is RNG re-keying when pBytesUsed >= 16384
//


void
RSA32API
rc4_safe_select(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

void
RSA32API
rc4_safe_select_np(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

//
// initialize the key specified by Entry index.
//  key material is size cb, pointer to key is pv.
// this routine is the safe version of rc4_key()
//

void
RSA32API
rc4_safe_key(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    );

void
RSA32API
rc4_safe_key_np(
    IN      void *pContext,
    IN      unsigned int Entry, // 0xffffffff for default
    IN      unsigned int cb,
    IN      const void *pv
    );

//
// encrypt using the key specified by Entry index.
// buffer of size cb at location pv is encrypted.
// this routine is the safe version of rc4()
//

void
RSA32API
rc4_safe(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );

void
RSA32API
rc4_safe_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );


#ifdef __cplusplus
}
#endif

#endif // __RANDLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\rsa_sys.h ===
/* rsa_sys.c
 *
 *	RSA system dependent functions.
 *		Memory allocation
 *		Random number generation.
 *
 */

#ifndef __RSA_SYS_H__
#define __RSA_SYS_H__

#ifndef KMODE_RSA32

#define RSA32Alloc(cb) LocalAlloc(0, cb)
#define RSA32Free(pv) LocalFree(pv)

#else

void* __stdcall RSA32Alloc( unsigned long cb );
void __stdcall RSA32Free( void *pv );

#endif  // KMODE_RSA32

#endif  // __RSA_SYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\rsa.h ===
#ifndef __RSA_H__
#define __RSA_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* rsa.h
 *
 *      RSA library functions.
 *
 * Copyright (C) RSA Data Security, Inc. created 1990.  This is an
 * unpublished work protected as such under copyright law.  This work
 * contains proprietary, confidential, and trade secret information of
 * RSA Data Security, Inc.  Use, disclosure or reproduction without the
 * express written authorization of RSA Data Security, Inc. is
 * prohibited.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#define RSA2 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24))

// Key header structures.
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.

typedef struct {
    DWORD       magic;                  /* Should always be RSA1 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // # of bits in modulus
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 //public exponent
} BSAFE_PUB_KEY, FAR *LPBSAFE_PUB_KEY;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef const BYTE far *cLPBYTE;                // const LPBYTE resolves wrong

// Structure for passing info into BSafe calls (currently this is used for
// passing in a callback function pointer for random number generation and
// information needed by the RNG, may eventually support exponentiation
// offload.
//

typedef struct {
    void        *pRNGInfo;              // dat
    void        *pFuncRNG;              // Function pointer for RNG callback
                                        // callback prototype is
                                        // void pFuncRNG(
                                        //        IN      void *pRNGInfo, 
                                        //        IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
                                        //        IN      unsigned long *pcbRandSeed,
                                        //        IN  OUT unsigned char *pbBuffer,
                                        //        IN      unsigned long dwLength
                                        //        );
} BSAFE_OTHER_INFO;


/* BSafeEncPublic
 *
 * BSafeEncPublic(key, part_in, part_out)
 *
 *      RSA encrypt a buffer of size key->keylen, filled with data of size
 *      key->datalen with the public key pointed to by key, returning the
 *      encrypted data in part_out.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY key - points to a public key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be encrypted.  The
 *                              data in the buffer should be no larger
 *                              than key->datalen.  All other bytes should
 *                              be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size keylen
 *                              to receive the encrypted data.
 *
 *      Returns
 *
 *              TRUE - encryption succeeded.
 *              FALSE - encryption failed.
 *
 */

BOOL
RSA32API
BSafeEncPublic(
    const LPBSAFE_PUB_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );


/* BSafeDecPrivate
 *
 * BSafeDecPrivate(key, part_in, part_out)
 *
 *      RSA decrypt a buffer of size keylen, containing key->datalen bytes
 *      of data with the private key pointed to by key, returning the
 *      decrypted data in part_out.
 *
 *      Parameters
 *
 *              LPBSAFE_PRV_KEY key - points to a private key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be decrypted.  The data
 *                              in the buffer should be no longer than
 *                              key->datalen.  All other bytes should be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size GRAINSIZE
 *                              to receive the decrypted data.
 *
 *      Returns
 *
 *              TRUE - decryption succeeded.
 *              FALSE - decryption failed.
 *
 */

BOOL
RSA32API
BSafeDecPrivate(
    const LPBSAFE_PRV_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );

/* BSafeMakeKeyPair
 *
 * BSafeMakeKeyPair(public_key, private_key, bits)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                              This value must be even and greater than 63
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPair(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits
    );

/* BSafeMakeKeyPairEx
 *
 * BSafeMakeKeyPairEx(public_key, private_key, bits, public_exp)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                                      This value must be even and greater
 *                                      than 63
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPairEx(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits,
    DWORD public_exp
    );

/* BSafeMakeKeyPairEx2
 *
 * BSafeMakeKeyPairEx2(pOtherInfo, public_key, private_key, bits, public_exp)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              BSAFE_OTHER_INFO pOtherInfo - points to a structure with information
 *                                      alternate information to be used when
 *                                      generating the RSA key pair.  Currently
 *                                      this structure has a pointer to a callback
 *                                      function which may be used when generating
 *                                      keys.  It also has a information to pass
 *                                      into that callback function (see OTHER_INFO).
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                                      This value must be even and greater
 *                                      than 63
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPairEx2(BSAFE_OTHER_INFO *pOtherInfo,
                    LPBSAFE_PUB_KEY public_key,
                    LPBSAFE_PRV_KEY private_key,
                    DWORD bits,
                    DWORD dwPubExp);

/* BSafeFreePubKey
 *
 * BSafeFreePubKey(public_key)
 *
 *      Free the data associated with a public key
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to a BSAFE_PUB_KEY
 *                               structure to free.
 *
 *      Returns
 *
 *              nothing
 *
 */

void
RSA32API
BSafeFreePubKey(
    LPBSAFE_PUB_KEY public_key
    );

/* BSafeFreePrvKey
 *
 * BSafeFreePrvKey(public_key)
 *
 *      Free the data associated with a private key
 *
 *      Parameters
 *
 *              LPBSAFE_PRV_KEY private_key - points to a BSAFE_PRV_KEY
 *                               structure to free.
 *
 *      Returns
 *
 *              nothing
 *
 */

void
RSA32API
BSafeFreePrvKey(
    LPBSAFE_PRV_KEY private_key
    );


/* BSafeComputeKeySizes
 *
 *      BSafeComputeKeySizes(   LPDWORD PubKeySize,
 *                              LPDWORD PrivKeySize,
 *                              LPDWORD bits )
 *
 *      Computes the required memory to hold a public and private key of
 *      a specified number of bits.
 *
 *      Parameters:
 *
 *              LPDWORD PubKeySize - pointer to DWORD to return the public
 *                                   key size, in bytes.
 *
 *              LPDWORD PrivKeySize - pointer to DWORD to return the private
 *                                    key size, in bytes.
 *
 *              LPDWORD bits      - pointer to DWORD specifying number of bits
 *                                  in the RSA modulus.
 *
 *      Returns:
 *
 *              TRUE if *bits is a valid RSA modulus size.
 *              FALSE if *bits is an invalid RSA modulus size.
 *
 */

BOOL
RSA32API
BSafeComputeKeySizes(
    LPDWORD PublicKeySize,
    LPDWORD PrivateKeySize,
    LPDWORD bits
    );

/* BSafeGetPrvKeyParts
 *
 * BOOL BSafeGetPrvKeyParts(    LPBSAFE_PRV_KEY key,
 *                              LPBSAFE_KEY_PARTS parts)
 *
 *      Returns pointers to the parts of a private key, and the length of
 *      the modulus in bytes.
 *
 *      Parameters:
 *
 *              LPBSAFE_PRV_KEY key     - the key to disassemble
 *              LPBSAFE_KEY_PARTS parts - the structure to fill in
 *
 *      Returns -
 *              FALSE if the key is not valid.
 */

BOOL
RSA32API
BSafeGetPrvKeyParts(
    LPBSAFE_PRV_KEY key,
    LPBSAFE_KEY_PARTS parts
    );


/* BSafeGetPubKeyModulus
 *
 * BYTE *BSafeGetPubKeyModulus(LPBSAFE_PUB_KEY key)
 *
 *      Returns pointer to the modulus of a public key
 *
 *      Parameters:
 *
 *              LPBSAFE_PUB_KEY key     - the key to disassemble
 *
 *      Returns -
 *
 *              Pointer to the parts, VOID on error.
 *              Fails if the key is not valid.
 */

BYTE *
RSA32API
BSafeGetPubKeyModulus(
    LPBSAFE_PUB_KEY key
    );

#ifdef __cplusplus
}
#endif


#endif // __RSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\sha.h ===
#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

//
// until CAPI is cleaned up to not require the FinishFlag and HashVal
// fields be present, need to define some slack space to insure that
// buffer is aligned on IA64.  Low-impact fix is just add a DWORD of space,
// which the underlying library will offset to buffer+4 when reading/writing
// to buffer.
//

typedef struct {
    union {
#if _WIN64
    ULONGLONG buffer64[8];                      /* force quadword alignment */
#endif
    unsigned char buffer[64];                   /* input buffer */
    } u;
    ULONG state[5];                             /* state (ABCDE) */
    ULONG count[2];                             /* number of bytes, msb first */
} A_SHA_CTX;

void RSA32API A_SHAInit(A_SHA_CTX *);
void RSA32API A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
// versions that don't internally byteswap (NoSwap version), for apps like
// the RNG that don't need hash compatibility - perf increase helps.
//

void RSA32API A_SHAUpdateNS(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinalNS(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\rsa_fast.h ===
/* rsa_fast.h
 *
 *  Headers for performance critical RSA routines.
 */

/*
 *
 *  #defines used by RSA routines
 */

#define DIGIT_BYTES     4
#define DIGIT_BITS      32
#define DIGIT_HIBIT     0x80000000
#define DIGIT_ALLONES   0xffffffff

#define ULTRA           unsigned __int64
#define U_RADIX         (ULTRA)0x100000000

#ifndef BIGENDIAN
#define LODWORD(x)      (DWORD)(x & DIGIT_ALLONES)
#else
#define LODWORD(x)      (DWORD)(x)
#endif

// warning!!!!!
// the following macro defines a highspeed 32 bit right shift by modeling an ULTRA
// as a low dword followed by a high dword.  We just pick up the high dword instead
// of shifting.

#ifndef BIGENDIAN
#define HIDWORD(x)      (DWORD)(*(((DWORD *)&x)+1))
#else
#define HIDWORD(x)      (DWORD)(*(((DWORD *)&x)))
#endif

// Sub(A, B, C, N)
// A = B - C
// All operands are N DWORDS long.

DWORD Sub(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// Add(A, B, C, N)
// A = B + C
// All operands are N DWORDS long.

DWORD Add(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// BaseMult(A, B, C, N)
// A = B * C
// returns A[N]
// All operands are N DWORDS long.

DWORD BaseMult(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// Accumulate(A, B, C, N)
// A = A + B * C
// returns A[N]
// All operands are N DWORDS long.

DWORD Accumulate(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// Reduce(A, B, C, N)
// A = A - C * B
// returns -A[N]
// All operands are N DWORDS long.

DWORD Reduce(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// square the digits in B, and add them to A

void AccumulateSquares(LPDWORD A, LPDWORD B, DWORD blen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\rc4.h ===
#ifndef __RC4_H__
#define __RC4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Key structure */
#if defined(_WIN64) && !defined(MIDL_PASS)
__declspec(align(8))
#endif
typedef struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
} RC4_KEYSTRUCT;

/* rc4_key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *   Key        A KEYSTRUCT structure that will be initialized.
 *   dwLen      Size of the key, in bytes.
 *   pbKey      Pointer to the key.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4_key(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbKey);

/* rc4()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *   pKS        Pointer to the KEYSTRUCT created using rc4_key().
 *   dwLen      Size of buffer, in bytes.
 *   pbuf       Buffer to be encrypted.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbuf);

#ifdef __cplusplus
}
#endif

#endif // __RC4_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\sha2.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sha2.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the low-level SHA2 (256/384/512) FIPS 180-2


Author:

    Scott Field (SField) 11-Jun-2001

Revision History:

--*/


#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifndef _SHA2_H_
#define _SHA2_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define SHA256_DIGEST_LEN   (32)
#define SHA384_DIGEST_LEN   (48)
#define SHA512_DIGEST_LEN   (64)


typedef struct {
    union {
#if _WIN64
    ULONGLONG state64[4];                       /* force alignment */
#endif
    ULONG state[8];                             /* state (ABCDEFGH) */
    };
    ULONG count[2];                             /* number of bytes, msb first */
    unsigned char buffer[64];                   /* input buffer */
} SHA256_CTX, *PSHA256_CTX;

typedef struct {
    ULONGLONG state[8];                         /* state (ABCDEFGH) */
    ULONGLONG count[2];                         /* number of bytes, msb first */
    unsigned char buffer[128];                  /* input buffer */
} SHA512_CTX, *PSHA512_CTX;

#define SHA384_CTX SHA512_CTX

void RSA32API SHA256Init(SHA256_CTX *);
void RSA32API SHA256Update(SHA256_CTX *, unsigned char *, unsigned int);
void RSA32API SHA256Final(SHA256_CTX *, unsigned char [SHA256_DIGEST_LEN]);

void RSA32API SHA512Init(SHA512_CTX *);
void RSA32API SHA512Update(SHA512_CTX *, unsigned char *, unsigned int);
void RSA32API SHA512Final(SHA512_CTX *, unsigned char [SHA512_DIGEST_LEN]);

void RSA32API SHA384Init(SHA384_CTX *);
#define SHA384Update SHA512Update
void RSA32API SHA384Final(SHA384_CTX *, unsigned char [SHA384_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\rsa_math.h ===
/* rsa_math.h
 *
 *	Headers for math routines related to RSA.
 *
 *  Except for Mod(), output parameters are listed first
 */

// void Decrement(LPDWORD A, DWORD N)
// Decrement the value A of length N.
void Decrement(LPDWORD A, DWORD N);

// BOOL Increment(LPDWORD A, DWORD N)
// Increment the value A of length N.
BOOL Increment(LPDWORD A, DWORD N);

// void SetValDWORD(LPDWORD num DWORD val, WORD len)
// Set the value of num to val.
void SetValDWORD(LPDWORD num, DWORD val, DWORD len);

// void TwoPower(LPDWORD A, DWORD V, DWORD N)
// Set A to 2^^V
void TwoPower(LPDWORD A, DWORD V, DWORD N);

// DWORD DigitLen(LPDWORD A, DWORD N)
// Return the number of non-zero words in A.
// N is number of total words in A.
DWORD DigitLen(LPDWORD A, DWORD N);

// DWORD BitLen(LPDWORD A, DWORD N)
// Return the bit length of A.
// N is the number of total words in A.
DWORD BitLen(LPDWORD A, DWORD N);

// void MultiplyLow(A, B, C, N)
// A = lower half of B * C.
void MultiplyLow(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// int Compare(A, B, N)
// Return 1 if A > B
// Return 0 if A = B
// Return -1 if A < B
int Compare(LPDWORD A, LPDWORD B, DWORD N);

// Multiply(A, B, C, N)
// A = B * C
// B and C are N DWORDS long
// A is 2N DWORDS long
void Multiply(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// Square(A, B, N)
// A = B * B
// B is N DWORDS long
// A is 2N DWORDS long

void Square(LPDWORD A, LPDWORD B, DWORD N);

// Mod(A, B, R, T, N)
// R = A mod B
// T = allocated length of A
// N = allocated length of B
BOOL Mod(LPDWORD A, LPDWORD B, LPDWORD R, DWORD T, DWORD N);

// ModSquare(A, B, D, N)
// A = B ^ 2 mod D
// N = len B
BOOL ModSquare(LPDWORD A, LPDWORD B, LPDWORD D, DWORD N);

// ModMultiply(A, B, C, D, N)
// A = B * C mod D
// N = len B, C, D
BOOL ModMultiply(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD N);

// Divide(qi, ri, uu, vv, N)
// qi = uu / vv
// ri = uu mod vv
// N = len uu, vv
BOOL Divide(LPDWORD qi,LPDWORD ri, LPDWORD uu, LPDWORD vv, DWORD ll, DWORD kk);

// GCD
// extended euclid GCD.
// N = length of params
BOOL GCD(LPDWORD u3, LPDWORD u1, LPDWORD u2, LPDWORD u, LPDWORD v, DWORD k);

// ModExp
// A = B ^ C mod D
// N = len of params
BOOL ModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);

// ModRoot(M, C, PP, QQ, DP, DQ, CR)
// CRT ModExp.
BOOL ModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\shacomm.h ===
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHACOMM_H_
#define _SHACOMM_H_ 1

//
// this file and it's contents were made obsolete.  Only sha.h is required.
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\tripldes.h ===
#ifndef __TRIPLDES_H__
#define __TRIPLDES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

//   tripledes2key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes2key(PDES3TABLE pDES3Table, BYTE *pbKey);

//   tripledes3key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes3key(PDES3TABLE pDES3Table, BYTE *pbKey);

//
//   Encrypt or decrypt with the key in pKey (DES3Table)
//

void RSA32API tripledes(BYTE *pbOut, BYTE *pbIn, void *pKey, int op);

extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __TRIPLDES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\swincryp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       wincrypt.h
//
//  Contents:   Cryptographic API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __SWINCRYP_H__
#define __SWINCRYP_H__

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
SCryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
BOOL
WINAPI
SCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
#ifdef UNICODE
#define SCryptAcquireContext  SCryptAcquireContextW
#else
#define SCryptAcquireContext  SCryptAcquireContextA
#endif // !UNICODE


BOOL
WINAPI
SCryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags);


BOOL
WINAPI
SCryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

BOOL
WINAPI
SCryptDuplicateKey(
    HCRYPTKEY hKey,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTKEY * phKey);

BOOL
WINAPI
SCryptDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);


BOOL
WINAPI
SCryptDestroyKey(
    HCRYPTKEY hKey);

BOOL
WINAPI
SCryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

BOOL
WINAPI
SCryptGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

BOOL
WINAPI
SCryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

BOOL
WINAPI
SCryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

BOOL
WINAPI
SCryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

BOOL
WINAPI
SCryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

BOOL
WINAPI
SCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

BOOL
WINAPI
SCryptDuplicateHash(
    HCRYPTHASH hHash,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTHASH * phHash);

BOOL
WINAPI
SCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen);

BOOL
WINAPI
SCryptDestroyHash(
    HCRYPTHASH hHash);

BOOL
WINAPI
SCryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

BOOL
WINAPI
SCryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

#ifdef UNICODE
#define SCryptSignHash  SCryptSignHashW
#else
#define SCryptSignHash  SCryptSignHashA
#endif // !UNICODE

BOOL
WINAPI
SCryptVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);

BOOL
WINAPI
SCryptVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);

#ifdef UNICODE
#define SCryptVerifySignature  SCryptVerifySignatureW
#else
#define SCryptVerifySignature  SCryptVerifySignatureA
#endif // !UNICODE

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __SWINCRYP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dfs\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR [string] LPWSTR
#endif

#include <lmdfs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\wintrustp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       wintrustP.h
//
//  Contents:   Microsoft Internet Security Trust PRIVATE INCLUDE
//
//  History:    20-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WINTRUSTP_H
#define WINTRUSTP_H

#include    <wincrypt.h>
#include    <wintrust.h>

#ifdef __cplusplus
extern "C" 
{
#endif

#pragma pack(8)

typedef struct WINTRUST_PBCB_INFO_
{
    DWORD                       cbStruct;

    LPCWSTR                     pcwszFileName;
    HANDLE                      hFile;

    DWORD                       cbContent;
    BYTE                        *pbContent;

    struct WINTRUST_ADV_INFO_   *psAdvanced;    // optional

} WINTRUST_PBCB_INFO, *PWINTRUST_PBCB_INFO;

typedef struct WINTRUST_ADV_INFO_
{
    DWORD           cbStruct;

    DWORD           dwStoreFlags;
#                       define      WTCI_DONT_OPEN_STORES   0x00000001  // only open dummy "root" all other are in pahStores.
#                       define      WTCI_OPEN_ONLY_ROOT     0x00000002

    DWORD           chStores;       // number of stores in pahStores
    HCERTSTORE      *pahStores;     // array of stores to add to internal list

    GUID            *pgSubject;     // Optional: SIP to load

} WINTRUST_ADV_INFO, *PWINTRUST_ADV_INFO;

#pragma pack()

//////////////////////////////////////////////////////////////////////////////
//
// TrustFindIssuerCertificate
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern PCCERT_CONTEXT WINAPI TrustFindIssuerCertificate(IN PCCERT_CONTEXT pChildContext,
                                                        IN DWORD dwEncoding,
                                                        IN DWORD chStores,
                                                        IN HCERTSTORE  *pahStores,
                                                        IN FILETIME *psftVerifyAsOf,
                                                        OUT OPTIONAL DWORD *pdwConfidence,
                                                        OUT OPTIONAL DWORD *pdwError,
                                                        IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////////
//
// TrustOpenStores
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern BOOL WINAPI TrustOpenStores(IN HCRYPTPROV hProv,
                                   IN OUT DWORD *chStores,
                                   IN OUT OPTIONAL HCERTSTORE *pahStores,
                                   IN DWORD dwFlags);


//////////////////////////////////////////////////////////////////////////////
//
// TrustIsCertificateSelfSigned
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern BOOL WINAPI TrustIsCertificateSelfSigned(IN PCCERT_CONTEXT pContext,
                                                IN DWORD dwEncoding, 
                                                IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////////
//
// Exported "helper" functions
//----------------------------------------------------------------------------
//  

extern BOOL WINAPI WTHelperOpenKnownStores(CRYPT_PROVIDER_DATA *pProvData);

#define     WTH_ALLOC                       0x00000001
#define     WTH_FREE                        0x00000002
extern BOOL WINAPI                      WTHelperGetKnownUsages(DWORD fdwAction, 
                                                               PCCRYPT_OID_INFO **ppOidInfo);

extern HANDLE WINAPI                    WTHelperGetFileHandle(WINTRUST_DATA *pWintrustData);
extern WCHAR * WINAPI                   WTHelperGetFileName(WINTRUST_DATA *pWintrustData);
extern BOOL WINAPI                      WTHelperCertIsSelfSignedEx(DWORD dwEncoding, PCCERT_CONTEXT pContext);
extern BOOL WINAPI                      WTHelperOpenKnownStores(CRYPT_PROVIDER_DATA *pProvData);
extern BOOL WINAPI                      WTHelperCheckCertUsage(PCCERT_CONTEXT pCertContext, 
                                                               LPCSTR pszRequestedUsageOID);
extern BOOL WINAPI                      WTHelperIsInRootStore(CRYPT_PROVIDER_DATA *pProvData, 
                                                              PCCERT_CONTEXT pCertContext);
extern BOOL WINAPI                      WTHelperGetAgencyInfo(PCCERT_CONTEXT pCert, 
                                                              DWORD *pcbAgencyInfo, 
                                                              struct _SPC_SP_AGENCY_INFO *psAgencyInfo);


#define WVT_MODID_WINTRUST              0x00000001
#define WVT_MODID_SOFTPUB               0x00010000
#define WVT_MODID_MSSIP                 0x00001000
extern BOOL WINAPI TrustDecode(DWORD dwModuleId, BYTE **ppbRet, DWORD *pcbRet, DWORD cbHint,
                               DWORD dwEncoding, const char *pcszOID, const BYTE *pbEncoded, DWORD cbEncoded,
                               DWORD dwDecodeFlags);
extern BOOL WINAPI TrustFreeDecode(DWORD dwModuleId, BYTE **pbAllocated);


// Returns ERROR_SUCCESS and the hash if the file was signed and contains a
// valid hash
extern LONG WINAPI WTHelperGetFileHash(
    IN LPCWSTR pwszFilename,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved,
    OUT OPTIONAL BYTE *pbFileHash,
    IN OUT OPTIONAL DWORD *pcbFileHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    );

// Open the cert manager UI dialog's TrustedPublisher Tab.
//
// The following flags may be set:
//   WT_TRUSTDBDIALOG_NO_UI_FLAG
//      Set this flag in conjunction with
//      WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG and/or
//      WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG to do the registry and/or
//      store write without any UI.
//   WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG
//      By default all of the UI tabs are displayed with TrustedPublisher
//      as the initial tab. Setting this flag only displays the
//      TrustedPublisher tab.
//   WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG
//      Setting this flag causes the trusted publishers to be written to the
//      following legacy registry location:
//          "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\
//              WinTrust\Trust Providers\Software Publishing\Trust Database\0"
//      The registry value names are constructed as ascii generated
//      representations of the md5 hash of the issuer name and the cert's serial
//      number. The string value is the subject display name.
//
//      Note, the above registry key is initially deleted to force the removal
//      of any previous publisher values.
//   WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG
//      Setting this flag causes all of the trusted publishers to be copied to
//      the "TrustedPublisher_IEAK" system registry store at the following
//      location:
//          "HKEY_CURRENT_USER\Software\Microsoft\SystemCertificates\
//              TrustedPublisher_IEAK\Certificates\..."
//      Note, the logical HKCU TrustedPublisher store inherits from HKLM and
//      GroupPolicy. The TrustedPublisher_IEAK will contain the entire set
//      under a single registry subkey.
//
//      Note, initially all certs are removed from the above store.
//          
extern BOOL WINAPI OpenPersonalTrustDBDialogEx(
    IN OPTIONAL HWND hwndParent,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved
    );

#define WT_TRUSTDBDIALOG_NO_UI_FLAG             0x00000001
#define WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG      0x00000002
#define WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG  0x00000100
#define WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG  0x00000200


// Calls above with dwFlags = 0 and pvReserved = NULL
extern BOOL WINAPI OpenPersonalTrustDBDialog(
    IN OPTIONAL HWND hwndParent
    );


#ifdef __cplusplus
}
#endif

#endif // WINTRUSTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypto\uint4.h ===
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _UINT4_H_
#define _UINT4_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

/* Encodes x (DWORD) into block (unsigned char), most significant
     byte first.
 */
void DWORDToBigEndian (
    unsigned char *block,
    DWORD *x,
    unsigned int digits     // number of DWORDs
    );

/* Decodes block (unsigned char) into x (DWORD), most significant
     byte first.
 */
void DWORDFromBigEndian (
    DWORD *x,
    unsigned int digits,    // number of DWORDs
    unsigned char *block
    );

/* Encodes input (DWORD) into output (unsigned char), least significant
     byte first.  Assumes len is a multiple of 4.
 */
void DWORDToLittleEndian (
    unsigned char *output,
    const DWORD *input,
    unsigned int len
    );

void DWORDFromLittleEndian (
    DWORD *output,
    const unsigned char *input,
    unsigned int len
    );


#ifdef __cplusplus
}
#endif

#endif // _UINT4_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\enduser\inc\cdm.h ===
//=======================================================================
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdm.h
//
//  Description:
//
//    Public header file for the IU (V4) Code Download Manager (CDM.DLL).
//
//=======================================================================

#ifndef _INC_CDM
#define _INC_CDM

#if defined(__cplusplus)
extern "C" {
#endif

//
// Define API decoration for direct importing of DLL references.
//
#if !defined(_CDM_)
#define CDMAPI DECLSPEC_IMPORT
#else
#define CDMAPI
#endif

//
// HWID_LEN must remain 2048 for backwards CDM compatibility, however note that the maximum
// length for a hardware ID is defined in //depot/Lab04_N/Root/Public/sdk/inc/cfgmgr32.h
// as #define MAX_DEVICE_ID_LEN     200
//
#define HWID_LEN						2048
#ifndef LINE_LEN
	#define LINE_LEN                    256 // Win95-compatible maximum for displayable
											// strings coming from a device INF.
#endif                                        

//Win 98 DOWNLOADINFO
typedef struct _DOWNLOADINFOWIN98
{
	DWORD		dwDownloadInfoSize;	//size of this structure
	LPTSTR		lpHardwareIDs;		//multi_sz list of Hardware PnP IDs
	LPTSTR		lpCompatIDs;		//multi_sz list of compatible IDs
	LPTSTR		lpFile;				//File name (string)
	OSVERSIONINFO	OSVersionInfo;	//OSVERSIONINFO from GetVersionEx()
	DWORD		dwFlags;			//Flags
	DWORD		dwClientID;			//Client ID
} DOWNLOADINFOWIN98, *PDOWNLOADINFOWIN98;

typedef struct _DOWNLOADINFO {
    DWORD          dwDownloadInfoSize;    // size of this structure
    LPCWSTR        lpHardwareIDs;         // multi_sz list of Hardware PnP IDs
    LPCWSTR        lpDeviceInstanceID;    // Device Instance ID
    LPCWSTR        lpFile;                // File name (string)
    OSVERSIONINFOW OSVersionInfo;         // OSVERSIONINFO from GetVersionEx()
    DWORD          dwArchitecture;        // Specifies the system's processor architecture.
                                          //This value can be one of the following values: 
                                          //PROCESSOR_ARCHITECTURE_INTEL
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_MIPS
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_ALPHA
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_PPC
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_UNKNOWN 
    DWORD          dwFlags;               // Flags
    DWORD          dwClientID;            // Client ID
    LCID           localid;               // local id
} DOWNLOADINFO, *PDOWNLOADINFO;


typedef struct _WUDRIVERINFO
{
    DWORD dwStructSize;					// size of this structure
	WCHAR wszHardwareID[HWID_LEN];		// ID being used to match
	WCHAR wszDescription[LINE_LEN];		// from INF	
	WCHAR wszMfgName[LINE_LEN];			// from INF
	WCHAR wszProviderName[LINE_LEN];	// INF provider
	WCHAR wszDriverVer[LINE_LEN];		// from INF
} WUDRIVERINFO, *PWUDRIVERINFO;

typedef void (*PFN_QueryDetectionFilesCallback)(void* pCallbackParam, LPCWSTR pszURL, LPCWSTR pszLocalFile);

//
// CDM exported function declarations
//

CDMAPI
VOID
WINAPI
CloseCDMContext(
    IN HANDLE hConnection
    );

CDMAPI
void
WINAPI
DetFilesDownloaded(
    IN  HANDLE			hConnection
	);
//
// IMPORTANT:	DownloadGetUpdatedFiles is only exported from the IU CDM.DLL stub.
//				It is NOT present in the Whistler version of the "Classic" V3 control.
//
CDMAPI
BOOL
DownloadGetUpdatedFiles(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,
	IN OUT LPTSTR			lpDownloadPath,
	IN UINT					uSize
);

CDMAPI
BOOL
WINAPI
DownloadIsInternetAvailable(
	void
	);

CDMAPI
BOOL
WINAPI
DownloadUpdatedFiles(
    IN  HANDLE        hConnection, 
    IN  HWND          hwnd,  
    IN  PDOWNLOADINFO pDownloadInfo, 
    OUT LPWSTR        lpDownloadPath, 
    IN  UINT          uSize, 
    OUT PUINT         puRequiredSize
    );

CDMAPI
BOOL
WINAPI
FindMatchingDriver(
    IN  HANDLE			hConnection, 
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
	);

CDMAPI
void
WINAPI
LogDriverNotFound(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
	);

CDMAPI
HANDLE
WINAPI
OpenCDMContext(
    IN HWND hwnd
    );

CDMAPI
HANDLE
WINAPI
OpenCDMContextEx(
    IN BOOL fConnectIfNotConnected
    );

CDMAPI
int
WINAPI
QueryDetectionFiles(
    IN  HANDLE							hConnection, 
	IN	void*							pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
	);

//
// 502965 Windows Error Reporting bucket 2096553: Hang following NEWDEV.DLL!CancelDriverSearch
//
CDMAPI
HRESULT
WINAPI
CancelCDMOperation(
	void
);



//
// CDM prototypes
//

typedef VOID (WINAPI *CLOSE_CDM_CONTEXT_PROC)(
    IN HANDLE hConnection
    );

typedef void (WINAPI *DET_FILES_DOWNLOADED_PROC)(
    IN  HANDLE hConnection 
    );

typedef BOOL (WINAPI *DOWNLOAD_GET_UPDATED_FILES)(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,
	IN OUT LPTSTR			lpDownloadPath,
	IN UINT					uSize
);

typedef BOOL (WINAPI *CDM_INTERNET_AVAILABLE_PROC)(
    void
    );

typedef BOOL (WINAPI *DOWNLOAD_UPDATED_FILES_PROC)(
    IN HANDLE hConnection,
    IN HWND hwnd,
    IN PDOWNLOADINFO pDownloadInfo,
    OUT LPWSTR lpDownloadPath,
    IN UINT uSize,
    OUT PUINT puRequiredSize
    );

typedef BOOL (WINAPI *FIND_MATCHING_DRIVER_PROC)(
    IN  HANDLE hConnection,
	IN  PDOWNLOADINFO pDownloadInfo,
	OUT PWUDRIVERINFO pWuDriverInfo
    );

typedef void (WINAPI *LOG_DRIVER_NOT_FOUND_PROC)(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
    );

typedef HANDLE (WINAPI *OPEN_CDM_CONTEXT_PROC)(
    IN  HWND   hwnd
    );

typedef HANDLE (WINAPI *OPEN_CDM_CONTEXT_EX_PROC)(
    IN BOOL fConnectIfNotConnected
    );

typedef int (WINAPI *QUERY_DETECTION_FILES_PROC)(
    IN  HANDLE hConnection, 
	IN	void* pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
    );

typedef HRESULT (WINAPI *CANCEL_CDM_OPERATION_PROC)(
    void
    );


//
// The following defines and structures are private internal interfaces so 
// they are in cdm.h and not in setupapi.h
//
#define DIF_GETWINDOWSUPDATEINFO            0x00000025

#define DI_FLAGSEX_SHOWWINDOWSUPDATE        0x00400000L

	
//For dwFlags parameter of LogDriverNotFound(...) 
//used with bitwising
#define BEGINLOGFLAG 0x00000002	//if 1, batch logging ends, flushing internal hardware id list to file


//
// Structure corresponding to a DIF_GETWINDOWSUPDATEINFO install function.
//
typedef struct _SP_WINDOWSUPDATE_PARAMS_A {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    CHAR                   PackageId[MAX_PATH];
    HANDLE                 CDMContext;
} SP_WINDOWSUPDATE_PARAMS_A, *PSP_WINDOWSUPDATE_PARAMS_A;

typedef struct _SP_WINDOWSUPDATE_PARAMS_W {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    WCHAR                  PackageId[MAX_PATH];
    HANDLE                 CDMContext;
} SP_WINDOWSUPDATE_PARAMS_W, *PSP_WINDOWSUPDATE_PARAMS_W;


#ifdef UNICODE
typedef SP_WINDOWSUPDATE_PARAMS_W SP_WINDOWSUPDATE_PARAMS;
typedef PSP_WINDOWSUPDATE_PARAMS_W PSP_WINDOWSUPDATE_PARAMS;
#else
typedef SP_WINDOWSUPDATE_PARAMS_A SP_WINDOWSUPDATE_PARAMS;
typedef PSP_WINDOWSUPDATE_PARAMS_A PSP_WINDOWSUPDATE_PARAMS;
#endif

#if defined(__cplusplus)
}	// end extern "C"
#endif

#endif // _INC_CDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dfs\netdfs_s.c ===
/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for netdfs.idl, dfssrv.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>
#include "netdfs.h"

#define TYPE_FORMAT_STRING_SIZE   1017                              
#define PROC_FORMAT_STRING_SIZE   1255                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: netdfs, ver. 3.0,
   GUID={0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}} */


extern const MIDL_SERVER_INFO netdfs_ServerInfo;

extern RPC_DISPATCH_TABLE netdfs_DispatchTable;

static const RPC_SERVER_INTERFACE netdfs___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}},{3,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &netdfs_DispatchTable,
    0,
    0,
    0,
    &netdfs_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE netdfs_ServerIfHandle = (RPC_IF_HANDLE)& netdfs___RpcServerInterface;

extern const MIDL_STUB_DESC netdfs_StubDesc;


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure NetrDfsManagerGetVersion */

			0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 16 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 24 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 26 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd */

/* 30 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 32 */	NdrFcLong( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0x1 ),	/* 1 */
/* 38 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 46 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 54 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 56 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 58 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 60 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 64 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 66 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 70 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 72 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 74 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 76 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 78 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 80 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 84 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 86 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 88 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove */

/* 90 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 92 */	NdrFcLong( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 106 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 114 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 116 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 118 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 120 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 122 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 124 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 128 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 134 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo */

/* 138 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x3 ),	/* 3 */
/* 146 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 152 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 154 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 158 */	NdrFcShort( 0x3 ),	/* 3 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 162 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 164 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 166 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 168 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 170 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 172 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 174 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 176 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 178 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 180 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 182 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 186 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 188 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 190 */	NdrFcShort( 0xe ),	/* Type Offset=14 */

	/* Return value */

/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 194 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetInfo */

/* 198 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0x4 ),	/* 4 */
/* 206 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 212 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 214 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 216 */	NdrFcShort( 0x3 ),	/* 3 */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 222 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 224 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 226 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 228 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 230 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 232 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 234 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 236 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 238 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 240 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 242 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 244 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 246 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 248 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 250 */	NdrFcShort( 0x17c ),	/* Type Offset=380 */

	/* Return value */

/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 254 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnum */

/* 258 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x5 ),	/* 5 */
/* 266 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 268 */	NdrFcShort( 0x2c ),	/* 44 */
/* 270 */	NdrFcShort( 0x24 ),	/* 36 */
/* 272 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 274 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 276 */	NdrFcShort( 0x9 ),	/* 9 */
/* 278 */	NdrFcShort( 0x9 ),	/* 9 */
/* 280 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Level */

/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 284 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 288 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 292 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 294 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 298 */	NdrFcShort( 0x186 ),	/* Type Offset=390 */

	/* Parameter ResumeHandle */

/* 300 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 304 */	NdrFcShort( 0x32a ),	/* Type Offset=810 */

	/* Return value */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsMove */

/* 312 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* 6 */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 328 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 336 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 338 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 340 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewDfsEntryPath */

/* 342 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 344 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 346 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 348 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 350 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRename */

/* 354 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 356 */	NdrFcLong( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x7 ),	/* 7 */
/* 362 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 368 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 370 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 372 */	NdrFcShort( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Path */

/* 378 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 380 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 382 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewPath */

/* 384 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 386 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 388 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 392 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerGetConfigInfo */

/* 396 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 398 */	NdrFcLong( 0x0 ),	/* 0 */
/* 402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 404 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 406 */	NdrFcShort( 0x30 ),	/* 48 */
/* 408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 410 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 412 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 414 */	NdrFcShort( 0x1 ),	/* 1 */
/* 416 */	NdrFcShort( 0x1 ),	/* 1 */
/* 418 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 420 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 422 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 424 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszLocalVolumeEntryPath */

/* 426 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 428 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 430 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter idLocalVolume */

/* 432 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 434 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 436 */	NdrFcShort( 0x108 ),	/* Type Offset=264 */

	/* Parameter ppRelationInfo */

/* 438 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 440 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 442 */	NdrFcShort( 0x32e ),	/* Type Offset=814 */

	/* Return value */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerSendSiteInfo */

/* 450 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x9 ),	/* 9 */
/* 458 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0x8 ),	/* 8 */
/* 464 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 466 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x1 ),	/* 1 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 474 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 476 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 478 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pSiteInfo */

/* 480 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 482 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 484 */	NdrFcShort( 0x38e ),	/* Type Offset=910 */

	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 488 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddFtRoot */

/* 492 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0xa ),	/* 10 */
/* 500 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 502 */	NdrFcShort( 0xd ),	/* 13 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 508 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 510 */	NdrFcShort( 0x1 ),	/* 1 */
/* 512 */	NdrFcShort( 0x1 ),	/* 1 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 516 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 518 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 520 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 522 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 526 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 528 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 532 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 534 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 536 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 538 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 540 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 542 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 544 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ConfigDN */

/* 546 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 548 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 550 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewFtDfs */

/* 552 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 554 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 556 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 558 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 560 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 564 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 566 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 568 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 572 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveFtRoot */

/* 576 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 578 */	NdrFcLong( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0xb ),	/* 11 */
/* 584 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 586 */	NdrFcShort( 0x8 ),	/* 8 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 592 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 594 */	NdrFcShort( 0x1 ),	/* 1 */
/* 596 */	NdrFcShort( 0x1 ),	/* 1 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 600 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 602 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 604 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 606 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 608 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 610 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 612 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 614 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 616 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 618 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 620 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 622 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 624 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 626 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 630 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 632 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 634 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 636 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 638 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 640 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRoot */

/* 642 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 644 */	NdrFcLong( 0x0 ),	/* 0 */
/* 648 */	NdrFcShort( 0xc ),	/* 12 */
/* 650 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 654 */	NdrFcShort( 0x8 ),	/* 8 */
/* 656 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 658 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 662 */	NdrFcShort( 0x0 ),	/* 0 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 666 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 668 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 670 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 672 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 674 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 676 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 678 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 680 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 682 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 686 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 690 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 692 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveStdRoot */

/* 696 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 698 */	NdrFcLong( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0xd ),	/* 13 */
/* 704 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 706 */	NdrFcShort( 0x8 ),	/* 8 */
/* 708 */	NdrFcShort( 0x8 ),	/* 8 */
/* 710 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 712 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 716 */	NdrFcShort( 0x0 ),	/* 0 */
/* 718 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 720 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 722 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 724 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 726 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 728 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 730 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 732 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 734 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 738 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerInitialize */

/* 744 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 746 */	NdrFcLong( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0xe ),	/* 14 */
/* 752 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 754 */	NdrFcShort( 0x8 ),	/* 8 */
/* 756 */	NdrFcShort( 0x8 ),	/* 8 */
/* 758 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 760 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 768 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 770 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 772 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 774 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 776 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 780 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 782 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 784 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRootForced */

/* 786 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 788 */	NdrFcLong( 0x0 ),	/* 0 */
/* 792 */	NdrFcShort( 0xf ),	/* 15 */
/* 794 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 802 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 806 */	NdrFcShort( 0x0 ),	/* 0 */
/* 808 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 810 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 812 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 814 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 816 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 818 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 820 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 822 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 824 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 826 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Share */

/* 828 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 830 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 832 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 834 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 836 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetDcAddress */

/* 840 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 842 */	NdrFcLong( 0x0 ),	/* 0 */
/* 846 */	NdrFcShort( 0x10 ),	/* 16 */
/* 848 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 850 */	NdrFcShort( 0x35 ),	/* 53 */
/* 852 */	NdrFcShort( 0x3d ),	/* 61 */
/* 854 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 856 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 864 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 866 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 868 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 870 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 872 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 874 */	NdrFcShort( 0x3de ),	/* Type Offset=990 */

	/* Parameter IsRoot */

/* 876 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 878 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 880 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Timeout */

/* 882 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 884 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 888 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 890 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetDcAddress */

/* 894 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 896 */	NdrFcLong( 0x0 ),	/* 0 */
/* 900 */	NdrFcShort( 0x11 ),	/* 17 */
/* 902 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 904 */	NdrFcShort( 0x10 ),	/* 16 */
/* 906 */	NdrFcShort( 0x8 ),	/* 8 */
/* 908 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 910 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 912 */	NdrFcShort( 0x0 ),	/* 0 */
/* 914 */	NdrFcShort( 0x0 ),	/* 0 */
/* 916 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 918 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 920 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 922 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 924 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 926 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 928 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Timeout */

/* 930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 932 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 936 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 938 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 942 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 944 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsFlushFtTable */

/* 948 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 950 */	NdrFcLong( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x12 ),	/* 18 */
/* 956 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 960 */	NdrFcShort( 0x8 ),	/* 8 */
/* 962 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 964 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 968 */	NdrFcShort( 0x0 ),	/* 0 */
/* 970 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DcName */

/* 972 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 974 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 976 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszFtDfsName */

/* 978 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 980 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 982 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 984 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 986 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 988 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd2 */

/* 990 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 992 */	NdrFcLong( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x13 ),	/* 19 */
/* 998 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1002 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1004 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1006 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1008 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1010 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1014 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1016 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1018 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1020 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1022 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1024 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1026 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1028 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1030 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 1032 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1034 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1036 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 1038 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1040 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1042 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 1044 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1046 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 1050 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1052 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1054 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 1056 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1058 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove2 */

/* 1062 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1064 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1068 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1070 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1074 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1076 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1078 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1080 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1082 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1084 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1086 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1088 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1090 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1092 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1094 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1096 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1098 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1100 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1102 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1104 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1106 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1108 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppRootList */

/* 1110 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1112 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1114 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 1116 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1118 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnumEx */

/* 1122 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1124 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1128 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1130 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1132 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1134 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1136 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1138 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1140 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1142 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1144 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1146 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1148 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1150 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Level */

/* 1152 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1154 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1156 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 1158 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1160 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 1164 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 1166 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1168 */	NdrFcShort( 0x186 ),	/* Type Offset=390 */

	/* Parameter ResumeHandle */

/* 1170 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1172 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1174 */	NdrFcShort( 0x32a ),	/* Type Offset=810 */

	/* Return value */

/* 1176 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1178 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo2 */

/* 1182 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1184 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1190 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1192 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1194 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1196 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1198 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1200 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1202 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1206 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1208 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1210 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1212 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1214 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1216 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1218 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1220 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1222 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1224 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1226 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1228 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 1230 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1232 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pDfsInfo */

/* 1236 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1238 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1240 */	NdrFcShort( 0x3ee ),	/* Type Offset=1006 */

	/* Parameter ppRootList */

/* 1242 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1244 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1246 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 1248 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1250 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  8 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x2 ),	/* Offset= 2 (14) */
/* 14 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 16 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 18 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 20 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 22 */	NdrFcShort( 0x2 ),	/* Offset= 2 (24) */
/* 24 */	NdrFcShort( 0x4 ),	/* 4 */
/* 26 */	NdrFcShort( 0x3007 ),	/* 12295 */
/* 28 */	NdrFcLong( 0x1 ),	/* 1 */
/* 32 */	NdrFcShort( 0x28 ),	/* Offset= 40 (72) */
/* 34 */	NdrFcLong( 0x2 ),	/* 2 */
/* 38 */	NdrFcShort( 0x3a ),	/* Offset= 58 (96) */
/* 40 */	NdrFcLong( 0x3 ),	/* 3 */
/* 44 */	NdrFcShort( 0x58 ),	/* Offset= 88 (132) */
/* 46 */	NdrFcLong( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0xcc ),	/* Offset= 204 (254) */
/* 52 */	NdrFcLong( 0x64 ),	/* 100 */
/* 56 */	NdrFcShort( 0x10 ),	/* Offset= 16 (72) */
/* 58 */	NdrFcLong( 0x65 ),	/* 101 */
/* 62 */	NdrFcShort( 0x130 ),	/* Offset= 304 (366) */
/* 64 */	NdrFcLong( 0x66 ),	/* 102 */
/* 68 */	NdrFcShort( 0x12a ),	/* Offset= 298 (366) */
/* 70 */	NdrFcShort( 0x0 ),	/* Offset= 0 (70) */
/* 72 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 78 */	NdrFcShort( 0x4 ),	/* 4 */
/* 80 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 82 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
/* 88 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 90 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 92 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 94 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 96 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 98 */	NdrFcShort( 0x2 ),	/* Offset= 2 (100) */
/* 100 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x10 ),	/* 16 */
/* 104 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 106 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 114 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 116 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 118 */	NdrFcShort( 0x4 ),	/* 4 */
/* 120 */	NdrFcShort( 0x4 ),	/* 4 */
/* 122 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 124 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 126 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 128 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 130 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 132 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 134 */	NdrFcShort( 0x4c ),	/* Offset= 76 (210) */
/* 136 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 138 */	NdrFcShort( 0xc ),	/* 12 */
/* 140 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 142 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 144 */	NdrFcShort( 0x4 ),	/* 4 */
/* 146 */	NdrFcShort( 0x4 ),	/* 4 */
/* 148 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 150 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 152 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 160 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 162 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 164 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 166 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 168 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 170 */	NdrFcShort( 0xc ),	/* 12 */
/* 172 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 174 */	NdrFcShort( 0xc ),	/* 12 */
/* 176 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 178 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 180 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 182 */	NdrFcShort( 0xc ),	/* 12 */
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x2 ),	/* 2 */
/* 188 */	NdrFcShort( 0x4 ),	/* 4 */
/* 190 */	NdrFcShort( 0x4 ),	/* 4 */
/* 192 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 194 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 198 */	NdrFcShort( 0x8 ),	/* 8 */
/* 200 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 202 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 204 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 206 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (136) */
			0x5b,		/* FC_END */
/* 210 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x14 ),	/* 20 */
/* 214 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 216 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
/* 222 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 224 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 226 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 228 */	NdrFcShort( 0x4 ),	/* 4 */
/* 230 */	NdrFcShort( 0x4 ),	/* 4 */
/* 232 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 234 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 236 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 238 */	NdrFcShort( 0x10 ),	/* 16 */
/* 240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 242 */	0x12, 0x0,	/* FC_UP */
/* 244 */	NdrFcShort( 0xffb4 ),	/* Offset= -76 (168) */
/* 246 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 248 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 250 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 252 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 256 */	NdrFcShort( 0x3e ),	/* Offset= 62 (318) */
/* 258 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 262 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 264 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 266 */	NdrFcShort( 0x10 ),	/* 16 */
/* 268 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 270 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 272 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (258) */
			0x5b,		/* FC_END */
/* 276 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 278 */	NdrFcShort( 0xc ),	/* 12 */
/* 280 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 282 */	NdrFcShort( 0x20 ),	/* 32 */
/* 284 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 286 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 288 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 290 */	NdrFcShort( 0xc ),	/* 12 */
/* 292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x2 ),	/* 2 */
/* 296 */	NdrFcShort( 0x4 ),	/* 4 */
/* 298 */	NdrFcShort( 0x4 ),	/* 4 */
/* 300 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 302 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0x8 ),	/* 8 */
/* 306 */	NdrFcShort( 0x8 ),	/* 8 */
/* 308 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 310 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 312 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 314 */	0x0,		/* 0 */
			NdrFcShort( 0xff4d ),	/* Offset= -179 (136) */
			0x5b,		/* FC_END */
/* 318 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 320 */	NdrFcShort( 0x28 ),	/* 40 */
/* 322 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 324 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 330 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 332 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 334 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 336 */	NdrFcShort( 0x4 ),	/* 4 */
/* 338 */	NdrFcShort( 0x4 ),	/* 4 */
/* 340 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 342 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 344 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 346 */	NdrFcShort( 0x24 ),	/* 36 */
/* 348 */	NdrFcShort( 0x24 ),	/* 36 */
/* 350 */	0x12, 0x0,	/* FC_UP */
/* 352 */	NdrFcShort( 0xffb4 ),	/* Offset= -76 (276) */
/* 354 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 356 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 358 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 360 */	0x0,		/* 0 */
			NdrFcShort( 0xff9f ),	/* Offset= -97 (264) */
			0x8,		/* FC_LONG */
/* 364 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 366 */	
			0x12, 0x0,	/* FC_UP */
/* 368 */	NdrFcShort( 0x2 ),	/* Offset= 2 (370) */
/* 370 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 372 */	NdrFcShort( 0x4 ),	/* 4 */
/* 374 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 376 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 378 */	NdrFcShort( 0x2 ),	/* Offset= 2 (380) */
/* 380 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 382 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 384 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 386 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 388 */	NdrFcShort( 0xfe94 ),	/* Offset= -364 (24) */
/* 390 */	
			0x12, 0x0,	/* FC_UP */
/* 392 */	NdrFcShort( 0x194 ),	/* Offset= 404 (796) */
/* 394 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 396 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 398 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 400 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 402 */	NdrFcShort( 0x2 ),	/* Offset= 2 (404) */
/* 404 */	NdrFcShort( 0x4 ),	/* 4 */
/* 406 */	NdrFcShort( 0x3006 ),	/* 12294 */
/* 408 */	NdrFcLong( 0x1 ),	/* 1 */
/* 412 */	NdrFcShort( 0x22 ),	/* Offset= 34 (446) */
/* 414 */	NdrFcLong( 0x2 ),	/* 2 */
/* 418 */	NdrFcShort( 0x56 ),	/* Offset= 86 (504) */
/* 420 */	NdrFcLong( 0x3 ),	/* 3 */
/* 424 */	NdrFcShort( 0x92 ),	/* Offset= 146 (570) */
/* 426 */	NdrFcLong( 0x4 ),	/* 4 */
/* 430 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (644) */
/* 432 */	NdrFcLong( 0xc8 ),	/* 200 */
/* 436 */	NdrFcShort( 0xa ),	/* Offset= 10 (446) */
/* 438 */	NdrFcLong( 0x12c ),	/* 300 */
/* 442 */	NdrFcShort( 0x114 ),	/* Offset= 276 (718) */
/* 444 */	NdrFcShort( 0xffff ),	/* Offset= -1 (443) */
/* 446 */	
			0x12, 0x0,	/* FC_UP */
/* 448 */	NdrFcShort( 0x24 ),	/* Offset= 36 (484) */
/* 450 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 452 */	NdrFcShort( 0x4 ),	/* 4 */
/* 454 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 460 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 462 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 464 */	NdrFcShort( 0x4 ),	/* 4 */
/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x1 ),	/* 1 */
/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 476 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 478 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 480 */	0x0,		/* 0 */
			NdrFcShort( 0xfe6b ),	/* Offset= -405 (76) */
			0x5b,		/* FC_END */
/* 484 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 486 */	NdrFcShort( 0x8 ),	/* 8 */
/* 488 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 490 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 492 */	NdrFcShort( 0x4 ),	/* 4 */
/* 494 */	NdrFcShort( 0x4 ),	/* 4 */
/* 496 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 498 */	NdrFcShort( 0xffd0 ),	/* Offset= -48 (450) */
/* 500 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 502 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 504 */	
			0x12, 0x0,	/* FC_UP */
/* 506 */	NdrFcShort( 0x2c ),	/* Offset= 44 (550) */
/* 508 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 510 */	NdrFcShort( 0x10 ),	/* 16 */
/* 512 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */
/* 516 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 518 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 520 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 522 */	NdrFcShort( 0x10 ),	/* 16 */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x2 ),	/* 2 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 532 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 534 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 536 */	NdrFcShort( 0x4 ),	/* 4 */
/* 538 */	NdrFcShort( 0x4 ),	/* 4 */
/* 540 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 542 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 544 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 546 */	0x0,		/* 0 */
			NdrFcShort( 0xfe41 ),	/* Offset= -447 (100) */
			0x5b,		/* FC_END */
/* 550 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 552 */	NdrFcShort( 0x8 ),	/* 8 */
/* 554 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 556 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 558 */	NdrFcShort( 0x4 ),	/* 4 */
/* 560 */	NdrFcShort( 0x4 ),	/* 4 */
/* 562 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 564 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (508) */
/* 566 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 568 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 570 */	
			0x12, 0x0,	/* FC_UP */
/* 572 */	NdrFcShort( 0x34 ),	/* Offset= 52 (624) */
/* 574 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 576 */	NdrFcShort( 0x14 ),	/* 20 */
/* 578 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 584 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 586 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 588 */	NdrFcShort( 0x14 ),	/* 20 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 592 */	NdrFcShort( 0x3 ),	/* 3 */
/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 598 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 600 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 602 */	NdrFcShort( 0x4 ),	/* 4 */
/* 604 */	NdrFcShort( 0x4 ),	/* 4 */
/* 606 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 608 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 610 */	NdrFcShort( 0x10 ),	/* 16 */
/* 612 */	NdrFcShort( 0x10 ),	/* 16 */
/* 614 */	0x12, 0x0,	/* FC_UP */
/* 616 */	NdrFcShort( 0xfe40 ),	/* Offset= -448 (168) */
/* 618 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 620 */	0x0,		/* 0 */
			NdrFcShort( 0xfe65 ),	/* Offset= -411 (210) */
			0x5b,		/* FC_END */
/* 624 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 626 */	NdrFcShort( 0x8 ),	/* 8 */
/* 628 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 630 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 632 */	NdrFcShort( 0x4 ),	/* 4 */
/* 634 */	NdrFcShort( 0x4 ),	/* 4 */
/* 636 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 638 */	NdrFcShort( 0xffc0 ),	/* Offset= -64 (574) */
/* 640 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 642 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 644 */	
			0x12, 0x0,	/* FC_UP */
/* 646 */	NdrFcShort( 0x34 ),	/* Offset= 52 (698) */
/* 648 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 650 */	NdrFcShort( 0x28 ),	/* 40 */
/* 652 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 654 */	NdrFcShort( 0x0 ),	/* 0 */
/* 656 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 658 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 660 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 662 */	NdrFcShort( 0x28 ),	/* 40 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0x3 ),	/* 3 */
/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 672 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 674 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 676 */	NdrFcShort( 0x4 ),	/* 4 */
/* 678 */	NdrFcShort( 0x4 ),	/* 4 */
/* 680 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 682 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 684 */	NdrFcShort( 0x24 ),	/* 36 */
/* 686 */	NdrFcShort( 0x24 ),	/* 36 */
/* 688 */	0x12, 0x0,	/* FC_UP */
/* 690 */	NdrFcShort( 0xfe62 ),	/* Offset= -414 (276) */
/* 692 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 694 */	0x0,		/* 0 */
			NdrFcShort( 0xfe87 ),	/* Offset= -377 (318) */
			0x5b,		/* FC_END */
/* 698 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 700 */	NdrFcShort( 0x8 ),	/* 8 */
/* 702 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 704 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 706 */	NdrFcShort( 0x4 ),	/* 4 */
/* 708 */	NdrFcShort( 0x4 ),	/* 4 */
/* 710 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 712 */	NdrFcShort( 0xffc0 ),	/* Offset= -64 (648) */
/* 714 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 716 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 718 */	
			0x12, 0x0,	/* FC_UP */
/* 720 */	NdrFcShort( 0x38 ),	/* Offset= 56 (776) */
/* 722 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 724 */	NdrFcShort( 0x8 ),	/* 8 */
/* 726 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 728 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 730 */	NdrFcShort( 0x4 ),	/* 4 */
/* 732 */	NdrFcShort( 0x4 ),	/* 4 */
/* 734 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 736 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 738 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 740 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 742 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 744 */	NdrFcShort( 0x8 ),	/* 8 */
/* 746 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 752 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 754 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 756 */	NdrFcShort( 0x8 ),	/* 8 */
/* 758 */	NdrFcShort( 0x0 ),	/* 0 */
/* 760 */	NdrFcShort( 0x1 ),	/* 1 */
/* 762 */	NdrFcShort( 0x4 ),	/* 4 */
/* 764 */	NdrFcShort( 0x4 ),	/* 4 */
/* 766 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 768 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 770 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 772 */	0x0,		/* 0 */
			NdrFcShort( 0xffcd ),	/* Offset= -51 (722) */
			0x5b,		/* FC_END */
/* 776 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 780 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 782 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 784 */	NdrFcShort( 0x4 ),	/* 4 */
/* 786 */	NdrFcShort( 0x4 ),	/* 4 */
/* 788 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 790 */	NdrFcShort( 0xffd0 ),	/* Offset= -48 (742) */
/* 792 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 794 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 796 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	NdrFcShort( 0x0 ),	/* Offset= 0 (802) */
/* 804 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 806 */	0x0,		/* 0 */
			NdrFcShort( 0xfe63 ),	/* Offset= -413 (394) */
			0x5b,		/* FC_END */
/* 810 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 812 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 814 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 816 */	NdrFcShort( 0x2 ),	/* Offset= 2 (818) */
/* 818 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 820 */	NdrFcShort( 0x2a ),	/* Offset= 42 (862) */
/* 822 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 824 */	NdrFcShort( 0x14 ),	/* 20 */
/* 826 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 828 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 830 */	NdrFcShort( 0x10 ),	/* 16 */
/* 832 */	NdrFcShort( 0x10 ),	/* 16 */
/* 834 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 836 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 838 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 840 */	0x0,		/* 0 */
			NdrFcShort( 0xfdbf ),	/* Offset= -577 (264) */
			0x8,		/* FC_LONG */
/* 844 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 846 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 848 */	NdrFcShort( 0x14 ),	/* 20 */
/* 850 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 852 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 854 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 856 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 858 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (822) */
/* 860 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 862 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 864 */	NdrFcShort( 0x4 ),	/* 4 */
/* 866 */	NdrFcShort( 0xffec ),	/* Offset= -20 (846) */
/* 868 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 870 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 872 */	NdrFcShort( 0x14 ),	/* 20 */
/* 874 */	NdrFcShort( 0x4 ),	/* 4 */
/* 876 */	NdrFcShort( 0x1 ),	/* 1 */
/* 878 */	NdrFcShort( 0x14 ),	/* 20 */
/* 880 */	NdrFcShort( 0x14 ),	/* 20 */
/* 882 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 884 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 886 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 888 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 890 */	
			0x11, 0x0,	/* FC_RP */
/* 892 */	NdrFcShort( 0x12 ),	/* Offset= 18 (910) */
/* 894 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 896 */	NdrFcShort( 0x8 ),	/* 8 */
/* 898 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 900 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 902 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 904 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 906 */	NdrFcShort( 0xff48 ),	/* Offset= -184 (722) */
/* 908 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 910 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 912 */	NdrFcShort( 0x4 ),	/* 4 */
/* 914 */	NdrFcShort( 0xffec ),	/* Offset= -20 (894) */
/* 916 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 918 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 922 */	NdrFcShort( 0x4 ),	/* 4 */
/* 924 */	NdrFcShort( 0x1 ),	/* 1 */
/* 926 */	NdrFcShort( 0x8 ),	/* 8 */
/* 928 */	NdrFcShort( 0x8 ),	/* 8 */
/* 930 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 932 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 934 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 936 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 938 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 940 */	NdrFcShort( 0x2 ),	/* Offset= 2 (942) */
/* 942 */	
			0x12, 0x0,	/* FC_UP */
/* 944 */	NdrFcShort( 0x12 ),	/* Offset= 18 (962) */
/* 946 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 948 */	NdrFcShort( 0x4 ),	/* 4 */
/* 950 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 952 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 954 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 956 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 958 */	NdrFcShort( 0xfc8e ),	/* Offset= -882 (76) */
/* 960 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 962 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 964 */	NdrFcShort( 0x4 ),	/* 4 */
/* 966 */	NdrFcShort( 0xffec ),	/* Offset= -20 (946) */
/* 968 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 970 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 972 */	NdrFcShort( 0x4 ),	/* 4 */
/* 974 */	NdrFcShort( 0x4 ),	/* 4 */
/* 976 */	NdrFcShort( 0x1 ),	/* 1 */
/* 978 */	NdrFcShort( 0x4 ),	/* 4 */
/* 980 */	NdrFcShort( 0x4 ),	/* 4 */
/* 982 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 984 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 986 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 988 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 990 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 992 */	NdrFcShort( 0xfc26 ),	/* Offset= -986 (6) */
/* 994 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 996 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 998 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1000 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1002 */	
			0x11, 0x0,	/* FC_RP */
/* 1004 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1006) */
/* 1006 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 1008 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1010 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1012 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1014 */	NdrFcShort( 0xfc22 ),	/* Offset= -990 (24) */

			0x0
        }
    };

static const unsigned short netdfs_FormatStringOffsetTable[] =
    {
    0,
    30,
    90,
    138,
    198,
    258,
    312,
    354,
    396,
    450,
    492,
    576,
    642,
    696,
    744,
    786,
    840,
    894,
    948,
    990,
    1062,
    1122,
    1182
    };


static const MIDL_STUB_DESC netdfs_StubDesc = 
    {
    (void *)& netdfs___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION netdfs_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE netdfs_DispatchTable = 
    {
    23,
    netdfs_table
    };

static const SERVER_ROUTINE netdfs_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)NetrDfsManagerGetVersion,
    (SERVER_ROUTINE)NetrDfsAdd,
    (SERVER_ROUTINE)NetrDfsRemove,
    (SERVER_ROUTINE)NetrDfsSetInfo,
    (SERVER_ROUTINE)NetrDfsGetInfo,
    (SERVER_ROUTINE)NetrDfsEnum,
    (SERVER_ROUTINE)NetrDfsMove,
    (SERVER_ROUTINE)NetrDfsRename,
    (SERVER_ROUTINE)NetrDfsManagerGetConfigInfo,
    (SERVER_ROUTINE)NetrDfsManagerSendSiteInfo,
    (SERVER_ROUTINE)NetrDfsAddFtRoot,
    (SERVER_ROUTINE)NetrDfsRemoveFtRoot,
    (SERVER_ROUTINE)NetrDfsAddStdRoot,
    (SERVER_ROUTINE)NetrDfsRemoveStdRoot,
    (SERVER_ROUTINE)NetrDfsManagerInitialize,
    (SERVER_ROUTINE)NetrDfsAddStdRootForced,
    (SERVER_ROUTINE)NetrDfsGetDcAddress,
    (SERVER_ROUTINE)NetrDfsSetDcAddress,
    (SERVER_ROUTINE)NetrDfsFlushFtTable,
    (SERVER_ROUTINE)NetrDfsAdd2,
    (SERVER_ROUTINE)NetrDfsRemove2,
    (SERVER_ROUTINE)NetrDfsEnumEx,
    (SERVER_ROUTINE)NetrDfsSetInfo2
    };

static const MIDL_SERVER_INFO netdfs_ServerInfo = 
    {
    &netdfs_StubDesc,
    netdfs_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    netdfs_FormatStringOffsetTable,
    0,
    0,
    0,
    0};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for netdfs.idl, dfssrv.acf:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>
#include "netdfs.h"

#define TYPE_FORMAT_STRING_SIZE   863                               
#define PROC_FORMAT_STRING_SIZE   1301                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: netdfs, ver. 3.0,
   GUID={0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}} */


extern const MIDL_SERVER_INFO netdfs_ServerInfo;

extern RPC_DISPATCH_TABLE netdfs_DispatchTable;

static const RPC_SERVER_INTERFACE netdfs___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}},{3,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &netdfs_DispatchTable,
    0,
    0,
    0,
    &netdfs_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE netdfs_ServerIfHandle = (RPC_IF_HANDLE)& netdfs___RpcServerInterface;

extern const MIDL_STUB_DESC netdfs_StubDesc;


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure NetrDfsManagerGetVersion */

			0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 16 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 26 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 28 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 30 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd */

/* 32 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 34 */	NdrFcLong( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0x1 ),	/* 1 */
/* 40 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	NdrFcShort( 0x8 ),	/* 8 */
/* 46 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 48 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 58 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 60 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 62 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 64 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 66 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 68 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 70 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 72 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 74 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 76 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 78 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 80 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 82 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 84 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 86 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 88 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 90 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove */

/* 94 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 96 */	NdrFcLong( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x2 ),	/* 2 */
/* 102 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 106 */	NdrFcShort( 0x8 ),	/* 8 */
/* 108 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 110 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 120 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 122 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 124 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 128 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 132 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 134 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 136 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 140 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo */

/* 144 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0x3 ),	/* 3 */
/* 152 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 160 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x3 ),	/* 3 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 170 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 172 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 174 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 178 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 180 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 184 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 186 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 188 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 190 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 194 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 196 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 198 */	NdrFcShort( 0xe ),	/* Type Offset=14 */

	/* Return value */

/* 200 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 202 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 204 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetInfo */

/* 206 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 208 */	NdrFcLong( 0x0 ),	/* 0 */
/* 212 */	NdrFcShort( 0x4 ),	/* 4 */
/* 214 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 216 */	NdrFcShort( 0x8 ),	/* 8 */
/* 218 */	NdrFcShort( 0x8 ),	/* 8 */
/* 220 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 222 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 224 */	NdrFcShort( 0x3 ),	/* 3 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 232 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 234 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 236 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 238 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 240 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 242 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 244 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 246 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 248 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 250 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 252 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 256 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 258 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 260 */	NdrFcShort( 0x12a ),	/* Type Offset=298 */

	/* Return value */

/* 262 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 264 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 266 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnum */

/* 268 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 270 */	NdrFcLong( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x5 ),	/* 5 */
/* 276 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 278 */	NdrFcShort( 0x2c ),	/* 44 */
/* 280 */	NdrFcShort( 0x24 ),	/* 36 */
/* 282 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 284 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 286 */	NdrFcShort( 0x9 ),	/* 9 */
/* 288 */	NdrFcShort( 0x9 ),	/* 9 */
/* 290 */	NdrFcShort( 0x0 ),	/* 0 */
/* 292 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Level */

/* 294 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 296 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 302 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 306 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 308 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 310 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Parameter ResumeHandle */

/* 312 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 314 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 316 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Return value */

/* 318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 320 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsMove */

/* 324 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0x6 ),	/* 6 */
/* 332 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x8 ),	/* 8 */
/* 338 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 340 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 350 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 352 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 354 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewDfsEntryPath */

/* 356 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 358 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 360 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 364 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRename */

/* 368 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x7 ),	/* 7 */
/* 376 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 384 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Path */

/* 394 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 396 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 398 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewPath */

/* 400 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 402 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 404 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 406 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 408 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 410 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerGetConfigInfo */

/* 412 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 414 */	NdrFcLong( 0x0 ),	/* 0 */
/* 418 */	NdrFcShort( 0x8 ),	/* 8 */
/* 420 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 422 */	NdrFcShort( 0x30 ),	/* 48 */
/* 424 */	NdrFcShort( 0x8 ),	/* 8 */
/* 426 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 428 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 430 */	NdrFcShort( 0x1 ),	/* 1 */
/* 432 */	NdrFcShort( 0x1 ),	/* 1 */
/* 434 */	NdrFcShort( 0x0 ),	/* 0 */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 438 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 440 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 442 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszLocalVolumeEntryPath */

/* 444 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 446 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 448 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter idLocalVolume */

/* 450 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 452 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 454 */	NdrFcShort( 0xc8 ),	/* Type Offset=200 */

	/* Parameter ppRelationInfo */

/* 456 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 458 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 460 */	NdrFcShort( 0x29a ),	/* Type Offset=666 */

	/* Return value */

/* 462 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 464 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 466 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerSendSiteInfo */

/* 468 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 470 */	NdrFcLong( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x9 ),	/* 9 */
/* 476 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 480 */	NdrFcShort( 0x8 ),	/* 8 */
/* 482 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 484 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
/* 488 */	NdrFcShort( 0x1 ),	/* 1 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 494 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 496 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 498 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pSiteInfo */

/* 500 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 502 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 504 */	NdrFcShort( 0x300 ),	/* Type Offset=768 */

	/* Return value */

/* 506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 508 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddFtRoot */

/* 512 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 518 */	NdrFcShort( 0xa ),	/* 10 */
/* 520 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 522 */	NdrFcShort( 0xd ),	/* 13 */
/* 524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 526 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 528 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 530 */	NdrFcShort( 0x1 ),	/* 1 */
/* 532 */	NdrFcShort( 0x1 ),	/* 1 */
/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 536 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 538 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 540 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 542 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 544 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 546 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 548 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 550 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 552 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 554 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 556 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 558 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 560 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 562 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 564 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 566 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ConfigDN */

/* 568 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 570 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 572 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewFtDfs */

/* 574 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 576 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 578 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 580 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 582 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 586 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 588 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 590 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 592 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 594 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 596 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveFtRoot */

/* 598 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 600 */	NdrFcLong( 0x0 ),	/* 0 */
/* 604 */	NdrFcShort( 0xb ),	/* 11 */
/* 606 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 608 */	NdrFcShort( 0x8 ),	/* 8 */
/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 612 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 614 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 616 */	NdrFcShort( 0x1 ),	/* 1 */
/* 618 */	NdrFcShort( 0x1 ),	/* 1 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 624 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 626 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 628 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 630 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 632 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 634 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 636 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 638 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 640 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 642 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 644 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 646 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 650 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 654 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 656 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 658 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 660 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 662 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRoot */

/* 666 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 668 */	NdrFcLong( 0x0 ),	/* 0 */
/* 672 */	NdrFcShort( 0xc ),	/* 12 */
/* 674 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 676 */	NdrFcShort( 0x8 ),	/* 8 */
/* 678 */	NdrFcShort( 0x8 ),	/* 8 */
/* 680 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 682 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 690 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 692 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 694 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 696 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 698 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 700 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 702 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 704 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 706 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 708 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 710 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 712 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 716 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 718 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 720 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveStdRoot */

/* 722 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 724 */	NdrFcLong( 0x0 ),	/* 0 */
/* 728 */	NdrFcShort( 0xd ),	/* 13 */
/* 730 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 732 */	NdrFcShort( 0x8 ),	/* 8 */
/* 734 */	NdrFcShort( 0x8 ),	/* 8 */
/* 736 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 738 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	NdrFcShort( 0x0 ),	/* 0 */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 748 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 750 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 752 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 754 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 756 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 758 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 760 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 762 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 766 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 768 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 770 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerInitialize */

/* 772 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 774 */	NdrFcLong( 0x0 ),	/* 0 */
/* 778 */	NdrFcShort( 0xe ),	/* 14 */
/* 780 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 782 */	NdrFcShort( 0x8 ),	/* 8 */
/* 784 */	NdrFcShort( 0x8 ),	/* 8 */
/* 786 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 788 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 792 */	NdrFcShort( 0x0 ),	/* 0 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 798 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 800 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 802 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 804 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 806 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 808 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 812 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRootForced */

/* 816 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0xf ),	/* 15 */
/* 824 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x8 ),	/* 8 */
/* 830 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 832 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 834 */	NdrFcShort( 0x0 ),	/* 0 */
/* 836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 838 */	NdrFcShort( 0x0 ),	/* 0 */
/* 840 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 842 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 844 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 846 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 848 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 850 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 852 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 854 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 856 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 858 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Share */

/* 860 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 862 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 864 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 868 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetDcAddress */

/* 872 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 878 */	NdrFcShort( 0x10 ),	/* 16 */
/* 880 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 882 */	NdrFcShort( 0x35 ),	/* 53 */
/* 884 */	NdrFcShort( 0x3d ),	/* 61 */
/* 886 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 888 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 892 */	NdrFcShort( 0x0 ),	/* 0 */
/* 894 */	NdrFcShort( 0x0 ),	/* 0 */
/* 896 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 898 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 900 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 902 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 904 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 906 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 908 */	NdrFcShort( 0x344 ),	/* Type Offset=836 */

	/* Parameter IsRoot */

/* 910 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 912 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 914 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Timeout */

/* 916 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 918 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 920 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 922 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 924 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 926 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetDcAddress */

/* 928 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 930 */	NdrFcLong( 0x0 ),	/* 0 */
/* 934 */	NdrFcShort( 0x11 ),	/* 17 */
/* 936 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 938 */	NdrFcShort( 0x10 ),	/* 16 */
/* 940 */	NdrFcShort( 0x8 ),	/* 8 */
/* 942 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 944 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 946 */	NdrFcShort( 0x0 ),	/* 0 */
/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 954 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 956 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 958 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 960 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 962 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 964 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Timeout */

/* 966 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 968 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 970 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 972 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 974 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 976 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 978 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 980 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 982 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsFlushFtTable */

/* 984 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0x12 ),	/* 18 */
/* 992 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x8 ),	/* 8 */
/* 998 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1000 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1008 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DcName */

/* 1010 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1012 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1014 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszFtDfsName */

/* 1016 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1018 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1020 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 1022 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1024 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd2 */

/* 1028 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1030 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1034 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1036 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1038 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1040 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1042 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1044 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1046 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1048 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1052 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1054 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1056 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1058 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1060 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1062 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1064 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1066 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1068 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1070 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 1072 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1074 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1076 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 1078 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1080 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1082 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 1084 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1086 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1088 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 1090 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1092 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1094 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 1096 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1098 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove2 */

/* 1102 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1108 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1110 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1114 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1116 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1118 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1120 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1122 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1126 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1128 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1130 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1132 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1134 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1136 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1138 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1140 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1142 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1144 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1146 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1148 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1150 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppRootList */

/* 1152 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1154 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1156 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 1158 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1160 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnumEx */

/* 1164 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1166 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1170 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1172 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1174 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1176 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1178 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1180 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1182 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1184 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1190 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1192 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1194 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Level */

/* 1196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1198 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 1202 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1204 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 1208 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 1210 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1212 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Parameter ResumeHandle */

/* 1214 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1216 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1218 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Return value */

/* 1220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1222 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo2 */

/* 1226 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1232 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1234 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1240 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1242 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1244 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1246 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1252 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1254 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1256 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1258 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1260 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1262 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1264 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1266 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1268 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1270 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1272 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1274 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 1276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1278 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pDfsInfo */

/* 1282 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1284 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1286 */	NdrFcShort( 0x354 ),	/* Type Offset=852 */

	/* Parameter ppRootList */

/* 1288 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1290 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1292 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 1294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1296 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  8 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x2 ),	/* Offset= 2 (14) */
/* 14 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 16 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 18 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 20 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 22 */	NdrFcShort( 0x2 ),	/* Offset= 2 (24) */
/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
/* 26 */	NdrFcShort( 0x3007 ),	/* 12295 */
/* 28 */	NdrFcLong( 0x1 ),	/* 1 */
/* 32 */	NdrFcShort( 0x28 ),	/* Offset= 40 (72) */
/* 34 */	NdrFcLong( 0x2 ),	/* 2 */
/* 38 */	NdrFcShort( 0x34 ),	/* Offset= 52 (90) */
/* 40 */	NdrFcLong( 0x3 ),	/* 3 */
/* 44 */	NdrFcShort( 0x48 ),	/* Offset= 72 (116) */
/* 46 */	NdrFcLong( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0x8c ),	/* Offset= 140 (190) */
/* 52 */	NdrFcLong( 0x64 ),	/* 100 */
/* 56 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (266) */
/* 58 */	NdrFcLong( 0x65 ),	/* 101 */
/* 62 */	NdrFcShort( 0xde ),	/* Offset= 222 (284) */
/* 64 */	NdrFcLong( 0x66 ),	/* 102 */
/* 68 */	NdrFcShort( 0xd8 ),	/* Offset= 216 (284) */
/* 70 */	NdrFcShort( 0x0 ),	/* Offset= 0 (70) */
/* 72 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 78 */	NdrFcShort( 0x8 ),	/* 8 */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x4 ),	/* Offset= 4 (86) */
/* 84 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 86 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 88 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 90 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 92 */	NdrFcShort( 0x2 ),	/* Offset= 2 (94) */
/* 94 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 96 */	NdrFcShort( 0x18 ),	/* 24 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x8 ),	/* Offset= 8 (108) */
/* 102 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 104 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 106 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 108 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 110 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 112 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 114 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 116 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 118 */	NdrFcShort( 0x2e ),	/* Offset= 46 (164) */
/* 120 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0x18 ),	/* 24 */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 126 */	NdrFcShort( 0x8 ),	/* Offset= 8 (134) */
/* 128 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 130 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 134 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 136 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 138 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 140 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 142 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 146 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 148 */	NdrFcShort( 0x14 ),	/* 20 */
/* 150 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 152 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 156 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 158 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 160 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (120) */
/* 162 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 164 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 166 */	NdrFcShort( 0x20 ),	/* 32 */
/* 168 */	NdrFcShort( 0x0 ),	/* 0 */
/* 170 */	NdrFcShort( 0x8 ),	/* Offset= 8 (178) */
/* 172 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 174 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 176 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 178 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 180 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 182 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 184 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (142) */
/* 190 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 192 */	NdrFcShort( 0x2a ),	/* Offset= 42 (234) */
/* 194 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 198 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 200 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 206 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 208 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (194) */
			0x5b,		/* FC_END */
/* 212 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 218 */	NdrFcShort( 0x28 ),	/* 40 */
/* 220 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 222 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 226 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 228 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 230 */	NdrFcShort( 0xff92 ),	/* Offset= -110 (120) */
/* 232 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 234 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 236 */	NdrFcShort( 0x38 ),	/* 56 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0xe ),	/* Offset= 14 (254) */
/* 242 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 244 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 246 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 248 */	NdrFcShort( 0xffd0 ),	/* Offset= -48 (200) */
/* 250 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 252 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 256 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 258 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 260 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 262 */	
			0x12, 0x0,	/* FC_UP */
/* 264 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (212) */
/* 266 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 268 */	NdrFcShort( 0x2 ),	/* Offset= 2 (270) */
/* 270 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 276 */	NdrFcShort( 0x4 ),	/* Offset= 4 (280) */
/* 278 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 280 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 282 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 284 */	
			0x12, 0x0,	/* FC_UP */
/* 286 */	NdrFcShort( 0x2 ),	/* Offset= 2 (288) */
/* 288 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 290 */	NdrFcShort( 0x4 ),	/* 4 */
/* 292 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 294 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 296 */	NdrFcShort( 0x2 ),	/* Offset= 2 (298) */
/* 298 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 300 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 302 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 304 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 306 */	NdrFcShort( 0xfee6 ),	/* Offset= -282 (24) */
/* 308 */	
			0x12, 0x0,	/* FC_UP */
/* 310 */	NdrFcShort( 0x150 ),	/* Offset= 336 (646) */
/* 312 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 314 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 316 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 318 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 320 */	NdrFcShort( 0x2 ),	/* Offset= 2 (322) */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	NdrFcShort( 0x3006 ),	/* 12294 */
/* 326 */	NdrFcLong( 0x1 ),	/* 1 */
/* 330 */	NdrFcShort( 0x22 ),	/* Offset= 34 (364) */
/* 332 */	NdrFcLong( 0x2 ),	/* 2 */
/* 336 */	NdrFcShort( 0x46 ),	/* Offset= 70 (406) */
/* 338 */	NdrFcLong( 0x3 ),	/* 3 */
/* 342 */	NdrFcShort( 0x6a ),	/* Offset= 106 (448) */
/* 344 */	NdrFcLong( 0x4 ),	/* 4 */
/* 348 */	NdrFcShort( 0x8e ),	/* Offset= 142 (490) */
/* 350 */	NdrFcLong( 0xc8 ),	/* 200 */
/* 354 */	NdrFcShort( 0xb2 ),	/* Offset= 178 (532) */
/* 356 */	NdrFcLong( 0x12c ),	/* 300 */
/* 360 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (588) */
/* 362 */	NdrFcShort( 0xffff ),	/* Offset= -1 (361) */
/* 364 */	
			0x12, 0x0,	/* FC_UP */
/* 366 */	NdrFcShort( 0x18 ),	/* Offset= 24 (390) */
/* 368 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 372 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 378 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 382 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 384 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 386 */	NdrFcShort( 0xfeca ),	/* Offset= -310 (76) */
/* 388 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 390 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 392 */	NdrFcShort( 0x10 ),	/* 16 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	NdrFcShort( 0x6 ),	/* Offset= 6 (402) */
/* 398 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 400 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 402 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 404 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (368) */
/* 406 */	
			0x12, 0x0,	/* FC_UP */
/* 408 */	NdrFcShort( 0x18 ),	/* Offset= 24 (432) */
/* 410 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 418 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 420 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 424 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 426 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 428 */	NdrFcShort( 0xfeb2 ),	/* Offset= -334 (94) */
/* 430 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 432 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 434 */	NdrFcShort( 0x10 ),	/* 16 */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x6 ),	/* Offset= 6 (444) */
/* 440 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 442 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 444 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 446 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (410) */
/* 448 */	
			0x12, 0x0,	/* FC_UP */
/* 450 */	NdrFcShort( 0x18 ),	/* Offset= 24 (474) */
/* 452 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 456 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 462 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 466 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 468 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 470 */	NdrFcShort( 0xfece ),	/* Offset= -306 (164) */
/* 472 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 474 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 476 */	NdrFcShort( 0x10 ),	/* 16 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 480 */	NdrFcShort( 0x6 ),	/* Offset= 6 (486) */
/* 482 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 484 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 486 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 488 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (452) */
/* 490 */	
			0x12, 0x0,	/* FC_UP */
/* 492 */	NdrFcShort( 0x18 ),	/* Offset= 24 (516) */
/* 494 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 496 */	NdrFcShort( 0x0 ),	/* 0 */
/* 498 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 502 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 504 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 508 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 510 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 512 */	NdrFcShort( 0xfeea ),	/* Offset= -278 (234) */
/* 514 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 516 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 518 */	NdrFcShort( 0x10 ),	/* 16 */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	NdrFcShort( 0x6 ),	/* Offset= 6 (528) */
/* 524 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 526 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 528 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 530 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (494) */
/* 532 */	
			0x12, 0x0,	/* FC_UP */
/* 534 */	NdrFcShort( 0x26 ),	/* Offset= 38 (572) */
/* 536 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 542 */	NdrFcShort( 0x4 ),	/* Offset= 4 (546) */
/* 544 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 546 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 548 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 550 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 554 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 556 */	NdrFcShort( 0x0 ),	/* 0 */
/* 558 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 560 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 564 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 566 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 568 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (536) */
/* 570 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 572 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 574 */	NdrFcShort( 0x10 ),	/* 16 */
/* 576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 578 */	NdrFcShort( 0x6 ),	/* Offset= 6 (584) */
/* 580 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 582 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 584 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 586 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (550) */
/* 588 */	
			0x12, 0x0,	/* FC_UP */
/* 590 */	NdrFcShort( 0x28 ),	/* Offset= 40 (630) */
/* 592 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 594 */	NdrFcShort( 0x10 ),	/* 16 */
/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 598 */	NdrFcShort( 0x6 ),	/* Offset= 6 (604) */
/* 600 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 602 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 604 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 606 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 608 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 612 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 614 */	NdrFcShort( 0x0 ),	/* 0 */
/* 616 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 618 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 622 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 624 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 626 */	NdrFcShort( 0xffde ),	/* Offset= -34 (592) */
/* 628 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 630 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x10 ),	/* 16 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	NdrFcShort( 0x6 ),	/* Offset= 6 (642) */
/* 638 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 640 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 642 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 644 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (608) */
/* 646 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 648 */	NdrFcShort( 0x10 ),	/* 16 */
/* 650 */	NdrFcShort( 0x0 ),	/* 0 */
/* 652 */	NdrFcShort( 0x0 ),	/* Offset= 0 (652) */
/* 654 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 656 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 658 */	NdrFcShort( 0xfea6 ),	/* Offset= -346 (312) */
/* 660 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 662 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 664 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 666 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 668 */	NdrFcShort( 0x2 ),	/* Offset= 2 (670) */
/* 670 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 672 */	NdrFcShort( 0x2a ),	/* Offset= 42 (714) */
/* 674 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 676 */	NdrFcShort( 0x18 ),	/* 24 */
/* 678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 680 */	NdrFcShort( 0x8 ),	/* Offset= 8 (688) */
/* 682 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 684 */	NdrFcShort( 0xfe1c ),	/* Offset= -484 (200) */
/* 686 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 688 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 690 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 692 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 698 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 700 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 702 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 706 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 708 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 710 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (674) */
/* 712 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 714 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 716 */	NdrFcShort( 0x8 ),	/* 8 */
/* 718 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (692) */
/* 720 */	NdrFcShort( 0x0 ),	/* Offset= 0 (720) */
/* 722 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 724 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 726 */	
			0x11, 0x0,	/* FC_RP */
/* 728 */	NdrFcShort( 0x28 ),	/* Offset= 40 (768) */
/* 730 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 732 */	NdrFcShort( 0x10 ),	/* 16 */
/* 734 */	NdrFcShort( 0x0 ),	/* 0 */
/* 736 */	NdrFcShort( 0x6 ),	/* Offset= 6 (742) */
/* 738 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 740 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 742 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 744 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 746 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 752 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 754 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 756 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 760 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 762 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 764 */	NdrFcShort( 0xffde ),	/* Offset= -34 (730) */
/* 766 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 768 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 770 */	NdrFcShort( 0x8 ),	/* 8 */
/* 772 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (746) */
/* 774 */	NdrFcShort( 0x0 ),	/* Offset= 0 (774) */
/* 776 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 778 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 780 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 782 */	NdrFcShort( 0x2 ),	/* Offset= 2 (784) */
/* 784 */	
			0x12, 0x0,	/* FC_UP */
/* 786 */	NdrFcShort( 0x26 ),	/* Offset= 38 (824) */
/* 788 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 790 */	NdrFcShort( 0x8 ),	/* 8 */
/* 792 */	NdrFcShort( 0x0 ),	/* 0 */
/* 794 */	NdrFcShort( 0x4 ),	/* Offset= 4 (798) */
/* 796 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 798 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 800 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 802 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 806 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 808 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 810 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 812 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 816 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 818 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 820 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (788) */
/* 822 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 824 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 826 */	NdrFcShort( 0x8 ),	/* 8 */
/* 828 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (802) */
/* 830 */	NdrFcShort( 0x0 ),	/* Offset= 0 (830) */
/* 832 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 834 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 836 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 838 */	NdrFcShort( 0xfcc0 ),	/* Offset= -832 (6) */
/* 840 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 842 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 844 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 846 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 848 */	
			0x11, 0x0,	/* FC_RP */
/* 850 */	NdrFcShort( 0x2 ),	/* Offset= 2 (852) */
/* 852 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 854 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 856 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 858 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 860 */	NdrFcShort( 0xfcbc ),	/* Offset= -836 (24) */

			0x0
        }
    };

static const unsigned short netdfs_FormatStringOffsetTable[] =
    {
    0,
    32,
    94,
    144,
    206,
    268,
    324,
    368,
    412,
    468,
    512,
    598,
    666,
    722,
    772,
    816,
    872,
    928,
    984,
    1028,
    1102,
    1164,
    1226
    };


static const MIDL_STUB_DESC netdfs_StubDesc = 
    {
    (void *)& netdfs___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION netdfs_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE netdfs_DispatchTable = 
    {
    23,
    netdfs_table
    };

static const SERVER_ROUTINE netdfs_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)NetrDfsManagerGetVersion,
    (SERVER_ROUTINE)NetrDfsAdd,
    (SERVER_ROUTINE)NetrDfsRemove,
    (SERVER_ROUTINE)NetrDfsSetInfo,
    (SERVER_ROUTINE)NetrDfsGetInfo,
    (SERVER_ROUTINE)NetrDfsEnum,
    (SERVER_ROUTINE)NetrDfsMove,
    (SERVER_ROUTINE)NetrDfsRename,
    (SERVER_ROUTINE)NetrDfsManagerGetConfigInfo,
    (SERVER_ROUTINE)NetrDfsManagerSendSiteInfo,
    (SERVER_ROUTINE)NetrDfsAddFtRoot,
    (SERVER_ROUTINE)NetrDfsRemoveFtRoot,
    (SERVER_ROUTINE)NetrDfsAddStdRoot,
    (SERVER_ROUTINE)NetrDfsRemoveStdRoot,
    (SERVER_ROUTINE)NetrDfsManagerInitialize,
    (SERVER_ROUTINE)NetrDfsAddStdRootForced,
    (SERVER_ROUTINE)NetrDfsGetDcAddress,
    (SERVER_ROUTINE)NetrDfsSetDcAddress,
    (SERVER_ROUTINE)NetrDfsFlushFtTable,
    (SERVER_ROUTINE)NetrDfsAdd2,
    (SERVER_ROUTINE)NetrDfsRemove2,
    (SERVER_ROUTINE)NetrDfsEnumEx,
    (SERVER_ROUTINE)NetrDfsSetInfo2
    };

static const MIDL_SERVER_INFO netdfs_ServerInfo = 
    {
    &netdfs_StubDesc,
    netdfs_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    netdfs_FormatStringOffsetTable,
    0,
    0,
    0,
    0};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dfs\netdfs.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for netdfs.idl, dfssrv.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __netdfs_h__
#define __netdfs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "import.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __netdfs_INTERFACE_DEFINED__
#define __netdfs_INTERFACE_DEFINED__

/* interface netdfs */
/* [implicit_handle][unique][ms_union][version][uuid] */ 

#pragma once
typedef struct _DFS_INFO_1_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_1 Buffer;
    } 	DFS_INFO_1_CONTAINER;

typedef struct _DFS_INFO_1_CONTAINER *LPDFS_INFO_1_CONTAINER;

typedef struct _DFS_INFO_2_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_2 Buffer;
    } 	DFS_INFO_2_CONTAINER;

typedef struct _DFS_INFO_2_CONTAINER *LPDFS_INFO_2_CONTAINER;

typedef struct _DFS_INFO_3_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_3 Buffer;
    } 	DFS_INFO_3_CONTAINER;

typedef struct _DFS_INFO_3_CONTAINER *LPDFS_INFO_3_CONTAINER;

typedef struct _DFS_INFO_4_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_4 Buffer;
    } 	DFS_INFO_4_CONTAINER;

typedef struct _DFS_INFO_4_CONTAINER *LPDFS_INFO_4_CONTAINER;

typedef struct _DFS_INFO_200_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_200 Buffer;
    } 	DFS_INFO_200_CONTAINER;

typedef struct _DFS_INFO_200_CONTAINER *LPDFS_INFO_200_CONTAINER;

typedef struct _DFS_INFO_300_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_300 Buffer;
    } 	DFS_INFO_300_CONTAINER;

typedef struct _DFS_INFO_300_CONTAINER *LPDFS_INFO_300_CONTAINER;

typedef struct _DFS_INFO_ENUM_STRUCT
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPDFS_INFO_1_CONTAINER DfsInfo1Container;
        /* [case()] */ LPDFS_INFO_2_CONTAINER DfsInfo2Container;
        /* [case()] */ LPDFS_INFO_3_CONTAINER DfsInfo3Container;
        /* [case()] */ LPDFS_INFO_4_CONTAINER DfsInfo4Container;
        /* [case()] */ LPDFS_INFO_200_CONTAINER DfsInfo200Container;
        /* [case()] */ LPDFS_INFO_300_CONTAINER DfsInfo300Container;
        } 	DfsInfoContainer;
    } 	DFS_INFO_ENUM_STRUCT;

typedef struct _DFS_INFO_ENUM_STRUCT *LPDFS_INFO_ENUM_STRUCT;

typedef /* [switch_type] */ union _DFS_INFO_STRUCT
    {
    /* [case()] */ LPDFS_INFO_1 DfsInfo1;
    /* [case()] */ LPDFS_INFO_2 DfsInfo2;
    /* [case()] */ LPDFS_INFO_3 DfsInfo3;
    /* [case()] */ LPDFS_INFO_4 DfsInfo4;
    /* [case()] */ LPDFS_INFO_100 DfsInfo100;
    /* [case()] */ LPDFS_INFO_101 DfsInfo101;
    /* [case()] */ LPDFS_INFO_102 DfsInfo102;
    /* [default] */  /* Empty union arm */ 
    } 	DFS_INFO_STRUCT;

typedef /* [switch_type] */ union _DFS_INFO_STRUCT *LPDFS_INFO_STRUCT;

typedef struct _DFSM_ENTRY_ID
    {
    GUID idSubordinate;
    /* [unique][string] */ LPWSTR wszSubordinate;
    } 	DFSM_ENTRY_ID;

typedef struct _DFSM_ENTRY_ID *LPDFSM_ENTRY_ID;

typedef struct _DFSM_RELATION_INFO
    {
    DWORD cSubordinates;
    /* [size_is] */ DFSM_ENTRY_ID eid[ 1 ];
    } 	DFSM_RELATION_INFO;

typedef /* [allocate] */ struct _DFSM_RELATION_INFO *LPDFSM_RELATION_INFO;

typedef struct _DFSM_ROOT_LIST_ENTRY
    {
    /* [unique][string] */ LPWSTR ServerShare;
    } 	DFSM_ROOT_LIST_ENTRY;

typedef struct _DFSM_ROOT_LIST_ENTRY *PDFSM_ROOT_LIST_ENTRY;

typedef struct _DFSM_ROOT_LIST_ENTRY *LPDFSM_ROOT_LIST_ENTRY;

typedef struct _DFSM_ROOT_LIST
    {
    DWORD cEntries;
    /* [size_is] */ DFSM_ROOT_LIST_ENTRY Entry[ 1 ];
    } 	DFSM_ROOT_LIST;

typedef struct _DFSM_ROOT_LIST *PDFSM_ROOT_LIST;

typedef /* [allocate] */ struct _DFSM_ROOT_LIST *LPDFSM_ROOT_LIST;

DWORD NetrDfsManagerGetVersion( void);

DWORD NetrDfsAdd( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [string][unique][in] */ LPWSTR Comment,
    /* [in] */ DWORD Flags);

DWORD NetrDfsRemove( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName);

DWORD NetrDfsSetInfo( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [in] */ DWORD Level,
    /* [switch_is][in] */ LPDFS_INFO_STRUCT DfsInfo);

DWORD NetrDfsGetInfo( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [in] */ DWORD Level,
    /* [switch_is][out] */ LPDFS_INFO_STRUCT DfsInfo);

DWORD NetrDfsEnum( 
    /* [in] */ DWORD Level,
    /* [in] */ DWORD PrefMaxLen,
    /* [unique][out][in] */ LPDFS_INFO_ENUM_STRUCT DfsEnum,
    /* [unique][out][in] */ LPDWORD ResumeHandle);

DWORD NetrDfsMove( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR NewDfsEntryPath);

DWORD NetrDfsRename( 
    /* [string][in] */ LPWSTR Path,
    /* [string][in] */ LPWSTR NewPath);

DWORD NetrDfsManagerGetConfigInfo( 
    /* [string][in] */ LPWSTR wszServer,
    /* [string][in] */ LPWSTR wszLocalVolumeEntryPath,
    /* [in] */ GUID idLocalVolume,
    /* [unique][out][in] */ LPDFSM_RELATION_INFO *ppRelationInfo);

DWORD NetrDfsManagerSendSiteInfo( 
    /* [string][in] */ LPWSTR wszServer,
    /* [in] */ LPDFS_SITELIST_INFO pSiteInfo);

DWORD NetrDfsAddFtRoot( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR DcName,
    /* [string][in] */ LPWSTR RootShare,
    /* [string][in] */ LPWSTR FtDfsName,
    /* [string][in] */ LPWSTR Comment,
    /* [string][in] */ LPWSTR ConfigDN,
    /* [in] */ BOOLEAN NewFtDfs,
    /* [in] */ DWORD Flags,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);

DWORD NetrDfsRemoveFtRoot( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR DcName,
    /* [string][in] */ LPWSTR RootShare,
    /* [string][in] */ LPWSTR FtDfsName,
    /* [in] */ DWORD Flags,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);

DWORD NetrDfsAddStdRoot( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR RootShare,
    /* [string][in] */ LPWSTR Comment,
    /* [in] */ DWORD Flags);

DWORD NetrDfsRemoveStdRoot( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR RootShare,
    /* [in] */ DWORD Flags);

DWORD NetrDfsManagerInitialize( 
    /* [string][in] */ LPWSTR ServerName,
    /* [in] */ DWORD Flags);

DWORD NetrDfsAddStdRootForced( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR RootShare,
    /* [string][in] */ LPWSTR Comment,
    /* [string][in] */ LPWSTR Share);

DWORD NetrDfsGetDcAddress( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][out][in] */ LPWSTR *DcName,
    /* [out][in] */ BOOLEAN *IsRoot,
    /* [out][in] */ ULONG *Timeout);

DWORD NetrDfsSetDcAddress( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR DcName,
    /* [in] */ DWORD Timeout,
    /* [in] */ DWORD Flags);

DWORD NetrDfsFlushFtTable( 
    /* [string][in] */ LPWSTR DcName,
    /* [string][in] */ LPWSTR wszFtDfsName);

DWORD NetrDfsAdd2( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR DcName,
    /* [string][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [string][unique][in] */ LPWSTR Comment,
    /* [in] */ DWORD Flags,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);

DWORD NetrDfsRemove2( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR DcName,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);

DWORD NetrDfsEnumEx( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [in] */ DWORD Level,
    /* [in] */ DWORD PrefMaxLen,
    /* [unique][out][in] */ LPDFS_INFO_ENUM_STRUCT DfsEnum,
    /* [unique][out][in] */ LPDWORD ResumeHandle);

DWORD NetrDfsSetInfo2( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR DcName,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [in] */ DWORD Level,
    /* [switch_is][in] */ LPDFS_INFO_STRUCT pDfsInfo,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);


extern handle_t netdfs_bhandle;


extern RPC_IF_HANDLE netdfs_ClientIfHandle;
extern RPC_IF_HANDLE netdfs_ServerIfHandle;
#endif /* __netdfs_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\enduser\inc\sainstallcom.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for sainstallcom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sainstallcom_h__
#define __sainstallcom_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISaInstall_FWD_DEFINED__
#define __ISaInstall_FWD_DEFINED__
typedef interface ISaInstall ISaInstall;
#endif 	/* __ISaInstall_FWD_DEFINED__ */


#ifndef __SaInstall_FWD_DEFINED__
#define __SaInstall_FWD_DEFINED__

#ifdef __cplusplus
typedef class SaInstall SaInstall;
#else
typedef struct SaInstall SaInstall;
#endif /* __cplusplus */

#endif 	/* __SaInstall_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_sainstallcom_0000 */
/* [local] */ 

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_sainstallcom_0000_0001
    {	NAS	= 0,
	WEB	= NAS + 1,
	CUSTOM	= WEB + 1
    } 	SA_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_sainstallcom_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sainstallcom_0000_v0_0_s_ifspec;

#ifndef __ISaInstall_INTERFACE_DEFINED__
#define __ISaInstall_INTERFACE_DEFINED__

/* interface ISaInstall */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISaInstall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4DEDEF3-4D83-4516-BC1E-103A63F5F014")
    ISaInstall : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SAAlreadyInstalled( 
            /* [in] */ SA_TYPE installedType,
            /* [retval][out] */ VARIANT_BOOL *pbInstalled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SAInstall( 
            /* [in] */ SA_TYPE installType,
            /* [in] */ BSTR szDiskName,
            /* [in] */ VARIANT_BOOL DispError,
            /* [in] */ VARIANT_BOOL Unattended,
            /* [retval][out] */ BSTR *pszErrorString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SAUninstall( 
            /* [in] */ SA_TYPE installType,
            /* [retval][out] */ BSTR *pszErrorString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISaInstallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISaInstall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISaInstall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISaInstall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISaInstall * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISaInstall * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISaInstall * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISaInstall * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *SAAlreadyInstalled )( 
            ISaInstall * This,
            /* [in] */ SA_TYPE installedType,
            /* [retval][out] */ VARIANT_BOOL *pbInstalled);
        
        HRESULT ( STDMETHODCALLTYPE *SAInstall )( 
            ISaInstall * This,
            /* [in] */ SA_TYPE installType,
            /* [in] */ BSTR szDiskName,
            /* [in] */ VARIANT_BOOL DispError,
            /* [in] */ VARIANT_BOOL Unattended,
            /* [retval][out] */ BSTR *pszErrorString);
        
        HRESULT ( STDMETHODCALLTYPE *SAUninstall )( 
            ISaInstall * This,
            /* [in] */ SA_TYPE installType,
            /* [retval][out] */ BSTR *pszErrorString);
        
        END_INTERFACE
    } ISaInstallVtbl;

    interface ISaInstall
    {
        CONST_VTBL struct ISaInstallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISaInstall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISaInstall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISaInstall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISaInstall_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISaInstall_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISaInstall_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISaInstall_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISaInstall_SAAlreadyInstalled(This,installedType,pbInstalled)	\
    (This)->lpVtbl -> SAAlreadyInstalled(This,installedType,pbInstalled)

#define ISaInstall_SAInstall(This,installType,szDiskName,DispError,Unattended,pszErrorString)	\
    (This)->lpVtbl -> SAInstall(This,installType,szDiskName,DispError,Unattended,pszErrorString)

#define ISaInstall_SAUninstall(This,installType,pszErrorString)	\
    (This)->lpVtbl -> SAUninstall(This,installType,pszErrorString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISaInstall_SAAlreadyInstalled_Proxy( 
    ISaInstall * This,
    /* [in] */ SA_TYPE installedType,
    /* [retval][out] */ VARIANT_BOOL *pbInstalled);


void __RPC_STUB ISaInstall_SAAlreadyInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISaInstall_SAInstall_Proxy( 
    ISaInstall * This,
    /* [in] */ SA_TYPE installType,
    /* [in] */ BSTR szDiskName,
    /* [in] */ VARIANT_BOOL DispError,
    /* [in] */ VARIANT_BOOL Unattended,
    /* [retval][out] */ BSTR *pszErrorString);


void __RPC_STUB ISaInstall_SAInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISaInstall_SAUninstall_Proxy( 
    ISaInstall * This,
    /* [in] */ SA_TYPE installType,
    /* [retval][out] */ BSTR *pszErrorString);


void __RPC_STUB ISaInstall_SAUninstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISaInstall_INTERFACE_DEFINED__ */



#ifndef __SAINSTALLCOMLib_LIBRARY_DEFINED__
#define __SAINSTALLCOMLib_LIBRARY_DEFINED__

/* library SAINSTALLCOMLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_SAINSTALLCOMLib;

EXTERN_C const CLSID CLSID_SaInstall;

#ifdef __cplusplus

class DECLSPEC_UUID("142B8185-53AE-45b3-888F-C9835B156CA9")
SaInstall;
#endif
#endif /* __SAINSTALLCOMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\enduser\inc\msper.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_PER_H__
#define __MS_PER_H__

#include <msasn1.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

extern ASN1_PUBLIC int ASN1API ASN1PEREncZero(ASN1encoding_t enc, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBit(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBitVal(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBitIntx(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncNormallySmallBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctets(ASN1encoding_t enc, ASN1uint32_t noctets, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val, ASN1uint32_t minlen);
extern ASN1_PUBLIC int ASN1API ASN1PEREncNormallySmall(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedIntx(ASN1encoding_t enc, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedUIntx(ASN1encoding_t enc, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedLength(ASN1uint32_t *len, ASN1encoding_t enc, ASN1uint32_t nitems);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmented(ASN1encoding_t enc, ASN1uint32_t nitems, ASN1octet_t *val, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PEREncObjectIdentifier(ASN1encoding_t enc, ASN1objectidentifier_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncObjectIdentifier2(ASN1encoding_t enc, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncDouble(ASN1encoding_t enc, double d);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFlushFragmentedToParent(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1PEREncAlignment(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncMultibyteString(ASN1encoding_t enc, ASN1char_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncGeneralizedTime(ASN1encoding_t enc, ASN1generalizedtime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUTCTime(ASN1encoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckExtensions(ASN1uint32_t nbits, ASN1octet_t *val);

extern ASN1_PUBLIC int ASN1API ASN1PERDecBit(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN32Val(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN16Val(ASN1decoding_t dec, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN8Val(ASN1decoding_t dec, ASN1uint8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecNXVal(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmented(ASN1decoding_t dec, ASN1uint32_t *nitems, ASN1octet_t **val, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1PERDecAlignment(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1PERDecExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBits(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecDouble(ASN1decoding_t dec, double *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBitIntx(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedIntx(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedUIntx(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedLength(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecObjectIdentifier2(ASN1decoding_t dec, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecMultibyteString(ASN1decoding_t dec, ASN1char_t **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecGeneralizedTime(ASN1decoding_t dec, ASN1generalizedtime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTCTime(ASN1decoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipBits(ASN1decoding_t dec, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipFragmented(ASN1decoding_t dec, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmall(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions);

extern ASN1_PUBLIC int ASN1API ASN1PEREncInteger(ASN1encoding_t enc, ASN1int32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecInteger(ASN1decoding_t dec, ASN1int32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUnsignedInteger(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUnsignedInteger(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUnsignedShort(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUnsignedShort(ASN1decoding_t dec, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBoolean(ASN1encoding_t enc, ASN1bool_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBoolean(ASN1decoding_t dec, ASN1bool_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncExtensionBitClear(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncExtensionBitSet(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSimpleChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSimpleChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSimpleChoiceEx(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSimpleChoiceEx(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncComplexChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice);
extern ASN1_PUBLIC int ASN1API ASN1PERDecComplexChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice);

/* unconstrained */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_NoSize(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_NoSize(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr);

/* fixed-array */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_FixedSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_FixedSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_VarSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_VarSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);

/* unbounded */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_FixedSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_FixedSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_VarSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_VarSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);

typedef int (ASN1CALL *ASN1iterator_encfn) (ASN1encoding_t, ASN1iterator_t *);
typedef int (ASN1CALL *ASN1iterator_decfn) (ASN1decoding_t, ASN1iterator_t *);
typedef int (ASN1CALL *ASN1iterator_freefn) (ASN1iterator_t *);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSeqOf_NoSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSeqOf_NoSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSeqOf_VarSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSeqOf_VarSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC void ASN1API ASN1PERFreeSeqOf(ASN1iterator_t **val, ASN1iterator_freefn pfnIterator);

extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmallExtensionFragmented(ASN1decoding_t dec);
__inline int ASN1PERDecExtensionBit(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1PERDecBit(dec, val);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableCharString(ASN1uint32_t nchars, ASN1char_t *val, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableChar16String(ASN1uint32_t nchars, ASN1char16_t *val, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableChar32String(ASN1uint32_t nchars, ASN1char32_t *val, ASN1stringtable_t *table);

extern ASN1_PUBLIC int ASN1API ASN1PEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t nchars, WCHAR *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t nchars, WCHAR **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTF8StringEx(ASN1decoding_t dec, ASN1uint32_t *nchars, WCHAR **val);

extern ASN1_PUBLIC int ASN1API ASN1PEREncExternal(ASN1encoding_t enc, ASN1external_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncEmbeddedPdv(ASN1encoding_t enc, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncEmbeddedPdvOpt(ASN1encoding_t enc, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharacterString(ASN1encoding_t enc, ASN1characterstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharacterStringOpt(ASN1encoding_t enc, ASN1characterstring_t *val);

extern ASN1_PUBLIC int ASN1API ASN1PERDecExternal(ASN1decoding_t dec, ASN1external_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecEmbeddedPdv(ASN1decoding_t dec, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecEmbeddedPdvOpt(ASN1decoding_t dec, ASN1embeddedpdv_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharacterString(ASN1decoding_t dec, ASN1characterstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharacterStringOpt(ASN1decoding_t dec, ASN1characterstring_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer);

#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_PER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\dxtpriv.h ===
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the matrix classes.
*
*******************************************************************************/
#ifndef __DXTPRIV_H_
#define __DXTPRIV_H_

#ifndef _INC_MATH
#include <math.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

//=== Class, Enum, Struct and Union Declarations ===================
class CDXMatrix4x4F;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================
float det4x4( CDXMatrix4x4F *pIn );
float det3x3( float a1, float a2, float a3, float b1, float b2, float b3, 
              float c1, float c2, float c3 );
float det2x2( float a, float b, float c, float d );

/*** CDX2DXForm ************
*   This class implements basic matrix operation based on the GDI XFORM
*   structure.
*/
//const DX2DXFORM g_DX2DXFORMIdentity = { 1., 0., 0., 1., 0., 0., DX2DXO_IDENTITY };

class CDX2DXForm : public DX2DXFORM
{
  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDX2DXForm() { SetIdentity(); }
    CDX2DXForm( const CDX2DXForm& Other ) { memcpy( this, &Other, sizeof(*this) ); }
    CDX2DXForm( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); }

    /*--- methods ---*/
    void DetermineOp( void );
    void Set( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); DetermineOp(); }
    void ZeroMatrix( void ) { memset( this, 0, sizeof( *this ) ); }
    void SetIdentity( void ) {  
        eM11 = 1.;
        eM12 = 0.;
        eM21 = 0.;
        eM22 = 1.;
        eDx = 0.;
        eDy = 0.;
        eOp = DX2DXO_IDENTITY;
    }
    BOOL IsIdentity() const { return eOp == DX2DXO_IDENTITY; }
    void Scale( float sx, float sy );
    void Rotate( float Rotation );
    void Translate( float dx, float dy );
    BOOL Invert();
    void TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const;
    void TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const;
    void GetMinMaxScales( float& MinScale, float& MaxScale );

    /*--- operators ---*/
    DXFPOINT operator*( const DXFPOINT& v ) const;
    CDX2DXForm operator*( const CDX2DXForm& Other ) const;
};

//=== CDX2DXForm methods ==============================================================
inline void CDX2DXForm::DetermineOp( void )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        if( ( eM11 == 1. ) && ( eM22 == 1. ) )
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_IDENTITY):(DX2DXO_TRANSLATE);
        }
        else
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_SCALE):(DX2DXO_SCALE_AND_TRANS);
        }
    }
    else
    {
        eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_GENERAL):(DX2DXO_GENERAL_AND_TRANS);
    }
} /* CDX2DXForm::DetermineOp */

inline float DXSq( float f ) { return f * f; }

// This function computes the Min and Max scale that a matrix represents.
// In other words, what is the maximum/minimum length that a line of length 1
// could get stretched/shrunk to if the line was transformed by this matrix.
//
// The function uses eigenvalues; and returns two float numbers. Both are
// non-negative; and MaxScale >= MinScale.
// 
inline void CDX2DXForm::GetMinMaxScales( float& MinScale, float& MaxScale )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        // Let MinScale = abs(eM11)
        if (eM11 < 0)
            MinScale = -eM11;
        else
            MinScale = eM11;

        // Let MaxScale = abs(eM22)
        if (eM22 < 0)
            MaxScale = -eM22;
        else
            MaxScale = eM22;

        // Swap Min/Max if necessary
        if (MinScale > MaxScale)
        {
            float flTemp = MinScale;
            MinScale = MaxScale;
            MaxScale = flTemp;
        }
    }
    else
    {
        float t1 = DXSq(eM11) + DXSq(eM12) + DXSq(eM21) + DXSq(eM22);
        if( t1 == 0. )
        {
            MinScale = MaxScale = 0;
        }
        else
        {
            float t2 = (float)sqrt( (DXSq(eM12 + eM21) + DXSq(eM11 - eM22)) *
                                    (DXSq(eM12 - eM21) + DXSq(eM11 + eM22)) );

            // Due to floating point error; t1 may end up less than t2;
            // but that would mean that the min scale was small (relative
            // to max scale)
            if (t1 <= t2)
                MinScale = 0;
            else
                MinScale = (float)sqrt( (t1 - t2) * .5f );

            MaxScale = (float)sqrt( (t1 + t2) * .5f );
        }
    }
} /* CDX2DXForm::GetMinMaxScales */

inline void CDX2DXForm::Rotate( float Rotation )
{
    double Angle = Rotation * (3.1415926535/180.0);
    float CosZ   = (float)cos( Angle );
    float SinZ   = (float)sin( Angle );
    if (CosZ > 0.0F && CosZ < 0.0000005F)
    {
        CosZ = .0F;
    }
    if (SinZ > -0.0000005F && SinZ < .0F)
    {
        SinZ = .0F;
    }

    float M11 = ( CosZ * eM11 ) + ( SinZ * eM21 ); 
    float M21 = (-SinZ * eM11 ) + ( CosZ * eM21 );
    float M12 = ( CosZ * eM12 ) + ( SinZ * eM22 ); 
    float M22 = (-SinZ * eM12 ) + ( CosZ * eM22 );
    eM11 = M11; eM21 = M21; eM12 = M12; eM22 = M22;
    DetermineOp();
} /* CDX2DXForm::Rotate */

inline void CDX2DXForm::Scale( float sx, float sy )
{
    eM11 *= sx;
    eM12 *= sx;
    eDx  *= sx;
    eM21 *= sy;
    eM22 *= sy;
    eDy  *= sy;
    DetermineOp();
} /* CDX2DXForm::Scale */

inline void CDX2DXForm::Translate( float dx, float dy )
{
    eDx += dx;
    eDy += dy;
    DetermineOp();
} /* CDX2DXForm::Translate */

inline void CDX2DXForm::TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const
{
    ResultBnds = Bnds;
    if( eOp != DX2DXO_IDENTITY )
    {
        ResultBnds.u.D[DXB_X].Min = (long)(( eM11 * Bnds.u.D[DXB_X].Min ) + ( eM12 * Bnds.u.D[DXB_Y].Min ) + eDx);
        ResultBnds.u.D[DXB_X].Max = (long)(( eM11 * Bnds.u.D[DXB_X].Max ) + ( eM12 * Bnds.u.D[DXB_Y].Max ) + eDx);
        ResultBnds.u.D[DXB_Y].Min = (long)(( eM21 * Bnds.u.D[DXB_X].Min ) + ( eM22 * Bnds.u.D[DXB_Y].Min ) + eDy);
        ResultBnds.u.D[DXB_Y].Max = (long)(( eM21 * Bnds.u.D[DXB_X].Max ) + ( eM22 * Bnds.u.D[DXB_Y].Max ) + eDy);
    }
} /* CDX2DXForm::TransformBounds */

inline void CDX2DXForm::TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const
{
    ULONG i;
    switch( eOp )
    {
      case DX2DXO_IDENTITY:
        memcpy( OutPnts, InPnts, ulCount * sizeof( DXFPOINT ) );
        break;
      case DX2DXO_TRANSLATE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x + eDx;
            OutPnts[i].y = InPnts[i].y + eDy;
        }
        break;
      case DX2DXO_SCALE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x * eM11;
            OutPnts[i].y = InPnts[i].y * eM22;
        }
        break;
      case DX2DXO_SCALE_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = (InPnts[i].x * eM11) + eDx;
            OutPnts[i].y = (InPnts[i].y * eM22) + eDy;
        }
        break;
      case DX2DXO_GENERAL:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 );
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 );
        }
        break;
      case DX2DXO_GENERAL_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 ) + eDx;
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 ) + eDy;
        }
        break;
      default:
        _ASSERT( 0 );   // invalid operation id
    }
} /* CDX2DXForm::TransformPoints */

inline DXFPOINT CDX2DXForm::operator*( const DXFPOINT& v ) const
{
    DXFPOINT NewPnt;
    NewPnt.x = ( v.x * eM11 ) + ( v.y * eM12 ) + eDx;
    NewPnt.y = ( v.x * eM21 ) + ( v.y * eM22 ) + eDy;
    return NewPnt;
} /* CDX2DXForm::operator* */

inline CDX2DXForm CDX2DXForm::operator*( const CDX2DXForm& Other ) const
{
    DX2DXFORM x;
    x.eM11 = ( eM11 * Other.eM11 ) + ( eM12 * Other.eM21 );
    x.eM12 = ( eM11 * Other.eM12 ) + ( eM12 * Other.eM22 );
    x.eDx  = ( eM11 * Other.eDx  ) + ( eM12 * Other.eDy  ) + eDx;

    x.eM21 = ( eM21 * Other.eM11 ) + ( eM22 * Other.eM21 );
    x.eM22 = ( eM21 * Other.eM12 ) + ( eM22 * Other.eM22 );
    x.eDy  = ( eM21 * Other.eDx  ) + ( eM22 * Other.eDy  ) + eDy;
    return x;
} /* CDX2DXForm::operator*= */

inline BOOL CDX2DXForm::Invert()
{
    switch( eOp )
    {
    case DX2DXO_IDENTITY:
        break;
    case DX2DXO_TRANSLATE:
        eDx = -eDx;
        eDy = -eDy;
        break;
    case DX2DXO_SCALE:

        if (eM11 == 0.0 || eM22 == 0.0)
            return false;
        eM11 = 1.0f / eM11;
        eM22 = 1.0f / eM22;
        break;

    case DX2DXO_SCALE_AND_TRANS:
        {
            if (eM11 == 0.0f || eM22 == 0.0f)
                return false;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM11 and b is eDx
            float flOneOverA = 1.0f / eM11;
            eDx = -eDx * flOneOverA;
            eM11 = flOneOverA;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM22 and b is eDy

            flOneOverA = 1.0f / eM22;
            eDy = -eDy * flOneOverA;
            eM22 = flOneOverA;
            break;
        }

    case DX2DXO_GENERAL:
    case DX2DXO_GENERAL_AND_TRANS:
        {
            // The inverse of A=  |a b| is | d -c|*(1/Det) where Det is the determinant of A
            //                    |c d|    |-b  a|
            // Det(A) = ad - bc

            // Compute determininant
            float flDet = (eM11 * eM22 -  eM12 * eM21);
            if (flDet == 0.0f)
                return FALSE;

            float flCoef = 1.0f / flDet;

            // Remember old value of eM11
            float flM11Original = eM11;

            eM11 = flCoef * eM22;
            eM12 = -flCoef * eM12;
            eM21 = -flCoef * eM21;
            eM22 = flCoef * flM11Original;

            // If we have a translation; then we need to 
            // compute new values for that translation
            if (eOp == DX2DXO_GENERAL_AND_TRANS)
            {
                // Remember original value of eDx
                float eDxOriginal = eDx;

                eDx = -eM11 * eDx - eM12 * eDy;
                eDy = -eM21 * eDxOriginal - eM22 * eDy;
            }
        }
        break;

    default:
        _ASSERT( 0 );   // invalid operation id
    }

    // We don't need to call DetermineOp here
    // because the op doesn't change when inverted
    // i.e. a scale remains a scale, etc.

    return true;
} /* CDX2DXForm::Invert */

/*** CDXMatrix4x4F ************
*   This class implements basic matrix operation based on a 4x4 array.
*/
//const float g_DXMat4X4Identity[4][4] =
//{
//    { 1.0, 0. , 0. , 0.  },
//    { 0. , 1.0, 0. , 0.  },
//    { 0. , 0. , 1.0, 0.  },
//    { 0. , 0. , 0. , 1.0 }
//};

class CDXMatrix4x4F
{
public:
  /*=== Member Data ===*/
    float m_Coeff[4][4];

  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDXMatrix4x4F() { SetIdentity(); }
    CDXMatrix4x4F( const CDXMatrix4x4F& Other )
        { CopyMemory( (void *)&m_Coeff, (void *)&Other.m_Coeff, sizeof(m_Coeff) ); }
    CDXMatrix4x4F( DX2DXFORM& XForm );

    /*--- operations ---*/
    void ZeroMatrix( void ) { memset( m_Coeff, 0, sizeof( m_Coeff ) ); }
    void SetIdentity( void ) {
        memset( m_Coeff, 0, sizeof( m_Coeff ) );
        m_Coeff[0][0] = m_Coeff[1][1] = m_Coeff[2][2] = m_Coeff[3][3] = 1.0;
    }
    void SetCoefficients( float Coeff[4][4] ) { memcpy( m_Coeff, Coeff, sizeof( m_Coeff )); }
    void GetCoefficients( float Coeff[4][4] ) { memcpy( Coeff, m_Coeff, sizeof( m_Coeff )); }

    //BOOL IsIdentity();
    void Scale( float sx, float sy, float sz );
    void Rotate( float rx, float ry, float rz );
    void Translate( float dx, float dy, float dz );
    BOOL Invert();
    BOOL GetInverse( CDXMatrix4x4F *pIn );
    void Transpose();
    void GetTranspose( CDXMatrix4x4F *pIn );
    void GetAdjoint( CDXMatrix4x4F *pIn );
    HRESULT InitFromSafeArray( SAFEARRAY *psa );
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void TransformBounds( DXBNDS& Bnds, DXBNDS& ResultBnds );

    /*--- operators ---*/
    CDXDVec operator*( CDXDVec& v) const;
    CDXCVec operator*( CDXCVec& v) const;
    CDXMatrix4x4F operator*(CDXMatrix4x4F Matrix) const;
    void operator*=(CDXMatrix4x4F Matrix) const;
    void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix);
    void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix);
    void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix);
    BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const;
    BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const;
};

inline CDXMatrix4x4F::CDXMatrix4x4F( DX2DXFORM& XForm )
{
    SetIdentity();
    m_Coeff[0][0] = XForm.eM11;
    m_Coeff[0][1] = XForm.eM12;
    m_Coeff[1][0] = XForm.eM21;
    m_Coeff[1][1] = XForm.eM22;
    m_Coeff[0][3] = XForm.eDx;
    m_Coeff[1][3] = XForm.eDy;
}

// Additional Operations

inline void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix)
{
    CopyMemory( (void *)m_Coeff, (const void *)srcMatrix.m_Coeff, sizeof(srcMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator= */

inline BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const
{
    return !memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator== */

inline BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const
{
    return memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator!= */

inline void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix)
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] += otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator+= */

inline void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix) 
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] -= otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator-= */

inline CDXDVec CDXMatrix4x4F::operator*(CDXDVec& v) const
{
    CDXDVec t;
    float temp;
    temp = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[0] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[1] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[2] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    t[3] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    return t;
} /* CDXMatrix4x4F::operator*(DXDVEC) */

inline CDXCVec CDXMatrix4x4F::operator*(CDXCVec& v) const
{
    CDXCVec t;
    t[0] = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[1] = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[2] = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[3] = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    return t;
} /* CDXMatrix4x4F::operator*(DXCVEC) */

inline CDXMatrix4x4F CDXMatrix4x4F::operator*(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    return t;
} /* CDXMatrix4x4F::operator*(CDXMatrix4x4F) */
            
inline void CDXMatrix4x4F::operator*=(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    CopyMemory( (void *)m_Coeff, (void *)t.m_Coeff, sizeof(m_Coeff) );
} /* CDXMatrix4x4F::operator*=(CDXMatrix4x4F) */
            

inline void CDXMatrix4x4F::Scale( float sx, float sy, float sz )
{
    if( sx != 1. )
    {
        m_Coeff[0][0] *= sx;
        m_Coeff[0][1] *= sx;
        m_Coeff[0][2] *= sx;
        m_Coeff[0][3] *= sx;
    }
    if( sy != 1. )
    {
        m_Coeff[1][0] *= sy;
        m_Coeff[1][1] *= sy;
        m_Coeff[1][2] *= sy;
        m_Coeff[1][3] *= sy;
    }
    if( sz != 1. )
    {
        m_Coeff[2][0] *= sz;
        m_Coeff[2][1] *= sz;
        m_Coeff[2][2] *= sz;
        m_Coeff[2][3] *= sz;
    }
} /* CDXMatrix4x4F::Scale */

inline void CDXMatrix4x4F::Translate( float dx, float dy, float dz )
{
    float a, b, c, d;
    a = b = c = d = 0;
    if( dx != 0. )
    {
        a += m_Coeff[0][0]*dx;
        b += m_Coeff[0][1]*dx;
        c += m_Coeff[0][2]*dx;
        d += m_Coeff[0][3]*dx;
    }
    if( dy != 0. )
    {
        a += m_Coeff[1][0]*dy;
        b += m_Coeff[1][1]*dy;
        c += m_Coeff[1][2]*dy;
        d += m_Coeff[1][3]*dy;
    }
    if( dz != 0. )
    {
        a += m_Coeff[2][0]*dz;
        b += m_Coeff[2][1]*dz;
        c += m_Coeff[2][2]*dz;
        d += m_Coeff[2][3]*dz;
    }
    m_Coeff[3][0] += a;
    m_Coeff[3][1] += b;
    m_Coeff[3][2] += c;
    m_Coeff[3][3] += d;
} /* CDXMatrix4x4F::Translate */

inline void CDXMatrix4x4F::Rotate( float rx, float ry, float rz )
{
    const float l_dfCte = (const float)(3.1415926535/180.0);

    float lAngleY = 0.0;
    float lAngleX = 0.0;
    float lAngleZ = 0.0;
    float lCosX = 1.0;
    float lSinX = 0.0;
    float lCosY = 1.0;
    float lSinY = 0.0;
    float lCosZ = 1.0;
    float lSinZ = 0.0;

    // calculate rotation angle sines and cosines
    if( rx != 0 )
    {
        lAngleX = rx * l_dfCte;
        lCosX = (float)cos(lAngleX);
        lSinX = (float)sin(lAngleX);
        if (lCosX > 0.0F && lCosX < 0.0000005F)
        {
            lCosX = .0F;
        }
        if (lSinX > -0.0000005F && lSinX < .0F)
        {
            lSinX = .0F;
        }
    }
    if( ry != 0 )
    {
        lAngleY = ry * l_dfCte;
        lCosY = (float)cos(lAngleY);
        lSinY = (float)sin(lAngleY);
        if (lCosY > 0.0F && lCosY < 0.0000005F)
        {
            lCosY = .0F;
        }
        if (lSinY > -0.0000005F && lSinY < .0F)
        {
            lSinY = .0F;
        }
    }
    if( rz != 0 )
    {
        lAngleZ = rz * l_dfCte;
        lCosZ = (float)cos(lAngleZ);
        lSinZ = (float)sin(lAngleZ);
        if (lCosZ > 0.0F && lCosZ < 0.0000005F)
        {
            lCosZ = .0F;
        }
        if (lSinZ > -0.0000005F && lSinZ < .0F)
        {
            lSinZ = .0F;
        }
    }

    float u, v;
    int i;

    //--- X Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[1][i]; 
        v = m_Coeff[2][i];
        m_Coeff[1][i] = lCosX*u+lSinX*v; 
        m_Coeff[2][i] = -lSinX*u+lCosX*v;
    }

    //--- Y Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[2][i];
        m_Coeff[0][i] = lCosY*u-lSinY*v; 
        m_Coeff[2][i] = lSinY*u+lCosY*v;
    }

    //--- Z Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[1][i];
        m_Coeff[0][i] = lCosZ*u+lSinZ*v; 
        m_Coeff[1][i] = -lSinZ*u+lCosZ*v;
    }
}

/*
inline BOOL CDXMatrix4x4F::IsIdentity()
{
    return  !memcmp( m_Coeff, g_DXMat4X4Identity, sizeof(g_DXMat4X4Identity) );
} /* CDXMatrix4x4F::IsIdentity */


/*
   Uses Gaussian elimination to invert the 4 x 4 non-linear matrix in t and
   return the result in Mx.  The matrix t is destroyed in the process.
*/
inline BOOL CDXMatrix4x4F::Invert()
{
    int i,j,k,Pivot;
    float PValue;
    CDXMatrix4x4F Mx;
    Mx.SetIdentity();

/* Find pivot element.  Use partial pivoting by row */
    for( i = 0;i < 4; i++ )
    {
        Pivot = 0;
        for( j = 0; j < 4; j++ )
        {
            if( fabs(m_Coeff[i][j]) > fabs(m_Coeff[i][Pivot]) ) Pivot = j;
        }

        if( m_Coeff[i][Pivot] == 0.0 )
        {
            ZeroMatrix();   /* Singular Matrix */
            return FALSE; 
        }

/* Normalize */
        PValue = m_Coeff[i][Pivot];
        for( j = 0; j < 4; j++ )
        {
            m_Coeff[i][j] /= PValue;
            Mx.m_Coeff[i][j] /= PValue;
        }

/* Zeroing */
        for( j = 0; j < 4; j++ )
        {
            if( j != i )
            {
                PValue = m_Coeff[j][Pivot];
                for( k = 0; k < 4; k++ )
                {
                    m_Coeff[j][k] -= PValue*m_Coeff[i][k];
                    Mx.m_Coeff[j][k] -= PValue*Mx.m_Coeff[i][k];
                }
            }
        }
    }

/* Reorder rows */
    for( i = 0; i < 4; i++ )
    {
        if( m_Coeff[i][i] != 1.0 )
        {
            for( j = i + 1; j < 4; j++ )
                if( m_Coeff[j][i] == 1.0 ) break;
            if( j >= 4 )
            {
                ZeroMatrix();
                return FALSE;
            }

            //--- swap rows i and j of original
            for( k = 0; k < 4; k++ )
            {
                m_Coeff[i][k] += m_Coeff[j][k];
                m_Coeff[j][k] = m_Coeff[i][k] - m_Coeff[j][k];
                m_Coeff[i][k] -= m_Coeff[j][k];
            }
            
            //--- swap rows i and j of result
            for( k = 0; k < 4; k++ )
            {
                Mx.m_Coeff[i][k] += Mx.m_Coeff[j][k];
                Mx.m_Coeff[j][k] = Mx.m_Coeff[i][k] - Mx.m_Coeff[j][k];
                Mx.m_Coeff[i][k] -= Mx.m_Coeff[j][k];
            }
        }
    }
    *this = Mx;
    return TRUE;
} /* CDXMatrix4x4F::Invert */

inline void CDXMatrix4x4F::Transpose()
{
    float temp;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */

inline void CDXMatrix4x4F::GetTranspose( CDXMatrix4x4F *m )
{
    float temp;

    (*this) = *m;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */


/*
Matrix Inversion
by Richard Carling
from "Graphics Gems", Academic Press, 1990
*/

#define SMALL_NUMBER    1.e-8
/* 
 *   inverse( original_matrix, inverse_matrix )
 * 
 *    calculate the inverse of a 4x4 matrix
 *
 *     -1     
 *     A  = ___1__ adjoint A
 *         det A
 */

inline BOOL CDXMatrix4x4F::GetInverse( CDXMatrix4x4F *pIn )
{
    int i, j;
    float det;

    /* calculate the adjoint matrix */

    GetAdjoint( pIn );

    /*  calculate the 4x4 determinant
     *  if the determinant is zero, 
     *  then the inverse matrix is not unique.
     */

    det = det4x4( pIn );

    if( fabs( det ) < SMALL_NUMBER )
    {
        //  Non-singular matrix, no inverse!
        return FALSE;;
    }

    /* scale the adjoint matrix to get the inverse */

    for( i = 0; i < 4; i++ )
        for( j = 0; j < 4; j++ )
            m_Coeff[i][j] = m_Coeff[i][j] / det;

    return TRUE;
}


/* 
 *   adjoint( original_matrix, inverse_matrix )
 * 
 *     calculate the adjoint of a 4x4 matrix
 *
 *      Let  a   denote the minor determinant of matrix A obtained by
 *           ij
 *
 *      deleting the ith row and jth column from A.
 *
 *                    i+j
 *     Let  b   = (-1)    a
 *          ij            ji
 *
 *    The matrix B = (b  ) is the adjoint of A
 *                     ij
 */
inline void CDXMatrix4x4F::GetAdjoint( CDXMatrix4x4F *pIn )
{
    float a1, a2, a3, a4, b1, b2, b3, b4;
    float c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid  */
    /* selecting correct values  */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1];
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];


    /* row column labeling reversed since we transpose rows & columns */

    m_Coeff[0][0]  =   det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4);
    m_Coeff[1][0]  = - det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4);
    m_Coeff[2][0]  =   det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4);
    m_Coeff[3][0]  = - det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4);
        
    m_Coeff[0][1]  = - det3x3( b1, b3, b4, c1, c3, c4, d1, d3, d4);
    m_Coeff[1][1]  =   det3x3( a1, a3, a4, c1, c3, c4, d1, d3, d4);
    m_Coeff[2][1]  = - det3x3( a1, a3, a4, b1, b3, b4, d1, d3, d4);
    m_Coeff[3][1]  =   det3x3( a1, a3, a4, b1, b3, b4, c1, c3, c4);
        
    m_Coeff[0][2]  =   det3x3( b1, b2, b4, c1, c2, c4, d1, d2, d4);
    m_Coeff[1][2]  = - det3x3( a1, a2, a4, c1, c2, c4, d1, d2, d4);
    m_Coeff[2][2]  =   det3x3( a1, a2, a4, b1, b2, b4, d1, d2, d4);
    m_Coeff[3][2]  = - det3x3( a1, a2, a4, b1, b2, b4, c1, c2, c4);
        
    m_Coeff[0][3]  = - det3x3( b1, b2, b3, c1, c2, c3, d1, d2, d3);
    m_Coeff[1][3]  =   det3x3( a1, a2, a3, c1, c2, c3, d1, d2, d3);
    m_Coeff[2][3]  = - det3x3( a1, a2, a3, b1, b2, b3, d1, d2, d3);
    m_Coeff[3][3]  =   det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3);
}
/*
 * float = det4x4( matrix )
 * 
 * calculate the determinant of a 4x4 matrix.
 */
inline float det4x4( CDXMatrix4x4F *pIn )
{
    float ans;
    float a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid selecting */
    /*  correct elements */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1]; 
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];

    ans = a1 * det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4 )
        - b1 * det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4 )
        + c1 * det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4 )
        - d1 * det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4 );
    return ans;
}

/*
 * float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
 * 
 * calculate the determinant of a 3x3 matrix
 * in the form
 *
 *     | a1,  b1,  c1 |
 *     | a2,  b2,  c2 |
 *     | a3,  b3,  c3 |
 */

inline float det3x3( float a1, float a2, float a3, 
                     float b1, float b2, float b3, 
                     float c1, float c2, float c3 )
{
    float ans;

    ans = a1 * det2x2( b2, b3, c2, c3 )
        - b1 * det2x2( a2, a3, c2, c3 )
        + c1 * det2x2( a2, a3, b2, b3 );
    return ans;
}

/*
 * float = det2x2( float a, float b, float c, float d )
 * 
 * calculate the determinant of a 2x2 matrix.
 */
inline float det2x2( float a, float b, float c, float d )
{
    float ans = a * d - b * c;
    return ans;
}

inline HRESULT CDXMatrix4x4F::InitFromSafeArray( SAFEARRAY * /*pSA*/ )
{
    HRESULT hr = S_OK;
#if 0
    long *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(float) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                m_Bounds[i].Min = pData[i];
                m_Bounds[i].Max = pData[i+4];
                m_Bounds[i].SampleRate = SampleRate;
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::InitFromSafeArray */

inline HRESULT CDXMatrix4x4F::GetSafeArray( SAFEARRAY ** /*ppSA*/ ) const
{
    HRESULT hr = S_OK;
#if 0
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 16;

        if( !(pSA = SafeArrayCreate( VT_I4, 1, &rgsabound ) ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = m_Bounds[i].Min;
                    pData[i+4] = m_Bounds[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::GetSafeArray */

inline void CDXMatrix4x4F::TransformBounds( DXBNDS& /*Bnds*/, DXBNDS& /*ResultBnds*/ )
{

} /* CDXMatrix4x4F::TransformBounds */



#endif   // __DXTPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\dxtranspguid.h ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for dxtransp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehavior,0x14D7DDDD,0xACA2,0x4E45,0x95,0x04,0x38,0x08,0xAB,0xEB,0x4F,0x92);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehaviorSite,0x909B23C2,0x9018,0x499f,0xA8,0x6D,0x4E,0x7D,0xA9,0x37,0xE9,0x31);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterCollection,0x22B07B33,0x8BFB,0x49d4,0x9B,0x90,0x09,0x38,0x37,0x0C,0x90,0x19);


MIDL_DEFINE_GUID(IID, IID_IDXTFilter,0x6187E5A2,0xA445,0x4608,0x8F,0xC0,0xBE,0x7A,0x6C,0x8D,0xB3,0x86);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterController,0x5CF315F2,0x273D,0x47B6,0xB9,0xED,0xF7,0x5D,0xC3,0xB0,0x15,0x0B);


MIDL_DEFINE_GUID(IID, IID_IDXTRedirectFilterInit,0xD1A57094,0x21F7,0x4e6c,0x93,0xE5,0xF5,0xF7,0x7F,0x74,0x82,0x93);


MIDL_DEFINE_GUID(IID, IID_IDXTClipOrigin,0xEE1663D8,0x0988,0x4C48,0x9F,0xD6,0xDB,0x44,0x50,0x88,0x56,0x68);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSPLib,0x527A4DA4,0x7F2C,0x11d2,0xB1,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterBehavior,0x649EEC1E,0xB579,0x4E8C,0xBB,0x3B,0x49,0x97,0xF8,0x42,0x65,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterFactory,0x81397204,0xF51A,0x4571,0x8D,0x7B,0xDC,0x03,0x05,0x21,0xAA,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterCollection,0xA7EE7F34,0x3BD1,0x427f,0x92,0x31,0xF9,0x41,0xE9,0xB7,0xE1,0xFE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for dxtransp.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehavior,0x14D7DDDD,0xACA2,0x4E45,0x95,0x04,0x38,0x08,0xAB,0xEB,0x4F,0x92);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehaviorSite,0x909B23C2,0x9018,0x499f,0xA8,0x6D,0x4E,0x7D,0xA9,0x37,0xE9,0x31);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterCollection,0x22B07B33,0x8BFB,0x49d4,0x9B,0x90,0x09,0x38,0x37,0x0C,0x90,0x19);


MIDL_DEFINE_GUID(IID, IID_IDXTFilter,0x6187E5A2,0xA445,0x4608,0x8F,0xC0,0xBE,0x7A,0x6C,0x8D,0xB3,0x86);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterController,0x5CF315F2,0x273D,0x47B6,0xB9,0xED,0xF7,0x5D,0xC3,0xB0,0x15,0x0B);


MIDL_DEFINE_GUID(IID, IID_IDXTRedirectFilterInit,0xD1A57094,0x21F7,0x4e6c,0x93,0xE5,0xF5,0xF7,0x7F,0x74,0x82,0x93);


MIDL_DEFINE_GUID(IID, IID_IDXTClipOrigin,0xEE1663D8,0x0988,0x4C48,0x9F,0xD6,0xDB,0x44,0x50,0x88,0x56,0x68);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSPLib,0x527A4DA4,0x7F2C,0x11d2,0xB1,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterBehavior,0x649EEC1E,0xB579,0x4E8C,0xBB,0x3B,0x49,0x97,0xF8,0x42,0x65,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterFactory,0x81397204,0xF51A,0x4571,0x8D,0x7B,0xDC,0x03,0x05,0x21,0xAA,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterCollection,0xA7EE7F34,0x3BD1,0x427f,0x92,0x31,0xF9,0x41,0xE9,0xB7,0xE1,0xFE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\dxtransp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for dxtransp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtransp_h__
#define __dxtransp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDXRasterizer_FWD_DEFINED__
#define __IDXRasterizer_FWD_DEFINED__
typedef interface IDXRasterizer IDXRasterizer;
#endif 	/* __IDXRasterizer_FWD_DEFINED__ */


#ifndef __IDXTLabel_FWD_DEFINED__
#define __IDXTLabel_FWD_DEFINED__
typedef interface IDXTLabel IDXTLabel;
#endif 	/* __IDXTLabel_FWD_DEFINED__ */


#ifndef __IDX2DDebug_FWD_DEFINED__
#define __IDX2DDebug_FWD_DEFINED__
typedef interface IDX2DDebug IDX2DDebug;
#endif 	/* __IDX2DDebug_FWD_DEFINED__ */


#ifndef __IDX2D_FWD_DEFINED__
#define __IDX2D_FWD_DEFINED__
typedef interface IDX2D IDX2D;
#endif 	/* __IDX2D_FWD_DEFINED__ */


#ifndef __IDXGradient2_FWD_DEFINED__
#define __IDXGradient2_FWD_DEFINED__
typedef interface IDXGradient2 IDXGradient2;
#endif 	/* __IDXGradient2_FWD_DEFINED__ */


#ifndef __IDXTFilterBehavior_FWD_DEFINED__
#define __IDXTFilterBehavior_FWD_DEFINED__
typedef interface IDXTFilterBehavior IDXTFilterBehavior;
#endif 	/* __IDXTFilterBehavior_FWD_DEFINED__ */


#ifndef __IDXTFilterBehaviorSite_FWD_DEFINED__
#define __IDXTFilterBehaviorSite_FWD_DEFINED__
typedef interface IDXTFilterBehaviorSite IDXTFilterBehaviorSite;
#endif 	/* __IDXTFilterBehaviorSite_FWD_DEFINED__ */


#ifndef __IDXTFilterCollection_FWD_DEFINED__
#define __IDXTFilterCollection_FWD_DEFINED__
typedef interface IDXTFilterCollection IDXTFilterCollection;
#endif 	/* __IDXTFilterCollection_FWD_DEFINED__ */


#ifndef __IDXTFilter_FWD_DEFINED__
#define __IDXTFilter_FWD_DEFINED__
typedef interface IDXTFilter IDXTFilter;
#endif 	/* __IDXTFilter_FWD_DEFINED__ */


#ifndef __IDXTFilterController_FWD_DEFINED__
#define __IDXTFilterController_FWD_DEFINED__
typedef interface IDXTFilterController IDXTFilterController;
#endif 	/* __IDXTFilterController_FWD_DEFINED__ */


#ifndef __IDXTRedirectFilterInit_FWD_DEFINED__
#define __IDXTRedirectFilterInit_FWD_DEFINED__
typedef interface IDXTRedirectFilterInit IDXTRedirectFilterInit;
#endif 	/* __IDXTRedirectFilterInit_FWD_DEFINED__ */


#ifndef __IDXTClipOrigin_FWD_DEFINED__
#define __IDXTClipOrigin_FWD_DEFINED__
typedef interface IDXTClipOrigin IDXTClipOrigin;
#endif 	/* __IDXTClipOrigin_FWD_DEFINED__ */


#ifndef __DXTLabel_FWD_DEFINED__
#define __DXTLabel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLabel DXTLabel;
#else
typedef struct DXTLabel DXTLabel;
#endif /* __cplusplus */

#endif 	/* __DXTLabel_FWD_DEFINED__ */


#ifndef __DXRasterizer_FWD_DEFINED__
#define __DXRasterizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXRasterizer DXRasterizer;
#else
typedef struct DXRasterizer DXRasterizer;
#endif /* __cplusplus */

#endif 	/* __DXRasterizer_FWD_DEFINED__ */


#ifndef __DX2D_FWD_DEFINED__
#define __DX2D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DX2D DX2D;
#else
typedef struct DX2D DX2D;
#endif /* __cplusplus */

#endif 	/* __DX2D_FWD_DEFINED__ */


#ifndef __DXTFilterBehavior_FWD_DEFINED__
#define __DXTFilterBehavior_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTFilterBehavior DXTFilterBehavior;
#else
typedef struct DXTFilterBehavior DXTFilterBehavior;
#endif /* __cplusplus */

#endif 	/* __DXTFilterBehavior_FWD_DEFINED__ */


#ifndef __DXTFilterFactory_FWD_DEFINED__
#define __DXTFilterFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTFilterFactory DXTFilterFactory;
#else
typedef struct DXTFilterFactory DXTFilterFactory;
#endif /* __cplusplus */

#endif 	/* __DXTFilterFactory_FWD_DEFINED__ */


#ifndef __DXTFilterCollection_FWD_DEFINED__
#define __DXTFilterCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTFilterCollection DXTFilterCollection;
#else
typedef struct DXTFilterCollection DXTFilterCollection;
#endif /* __cplusplus */

#endif 	/* __DXTFilterCollection_FWD_DEFINED__ */


/* header files for imported files */
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dxtransp_0000 */
/* [local] */ 








typedef 
enum DXRASTERFILL
    {	DXRASTER_PEN	= 0,
	DXRASTER_BRUSH	= 1,
	DXRASTER_BACKGROUND	= 2
    } 	DXRASTERFILL;

typedef struct DXRASTERSCANINFO
    {
    ULONG ulIndex;
    ULONG Row;
    const BYTE *pWeights;
    const DXRUNINFO *pRunInfo;
    ULONG cRunInfo;
    } 	DXRASTERSCANINFO;

typedef struct DXRASTERPOINTINFO
    {
    DXOVERSAMPLEDESC Pixel;
    ULONG ulIndex;
    BYTE Weight;
    } 	DXRASTERPOINTINFO;

typedef struct DXRASTERRECTINFO
    {
    ULONG ulIndex;
    RECT Rect;
    BYTE Weight;
    } 	DXRASTERRECTINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0000_v0_0_s_ifspec;

#ifndef __IDXRasterizer_INTERFACE_DEFINED__
#define __IDXRasterizer_INTERFACE_DEFINED__

/* interface IDXRasterizer */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDXRasterizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B635-C37D-11d1-905E-00C04FD9189D")
    IDXRasterizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            /* [in] */ IDXSurface *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDXSurface **ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFill( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface *pSurface,
            /* [in] */ const POINT *ppt,
            /* [in] */ DXSAMPLE FillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFill( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface **ppSurface,
            /* [out] */ POINT *ppt,
            /* [out] */ DXSAMPLE *pFillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginRendering( 
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRendering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderScan( 
            /* [in] */ const DXRASTERSCANINFO *pScanInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPixel( 
            /* [in] */ DXRASTERPOINTINFO *pPointInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillRect( 
            /* [in] */ const DXRASTERRECTINFO *pRectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS *pBounds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRasterizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXRasterizer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXRasterizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXRasterizer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSurface )( 
            IDXRasterizer * This,
            /* [in] */ IDXSurface *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDXRasterizer * This,
            /* [out] */ IDXSurface **ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetFill )( 
            IDXRasterizer * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface *pSurface,
            /* [in] */ const POINT *ppt,
            /* [in] */ DXSAMPLE FillColor);
        
        HRESULT ( STDMETHODCALLTYPE *GetFill )( 
            IDXRasterizer * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface **ppSurface,
            /* [out] */ POINT *ppt,
            /* [out] */ DXSAMPLE *pFillColor);
        
        HRESULT ( STDMETHODCALLTYPE *BeginRendering )( 
            IDXRasterizer * This,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE *EndRendering )( 
            IDXRasterizer * This);
        
        HRESULT ( STDMETHODCALLTYPE *RenderScan )( 
            IDXRasterizer * This,
            /* [in] */ const DXRASTERSCANINFO *pScanInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetPixel )( 
            IDXRasterizer * This,
            /* [in] */ DXRASTERPOINTINFO *pPointInfo);
        
        HRESULT ( STDMETHODCALLTYPE *FillRect )( 
            IDXRasterizer * This,
            /* [in] */ const DXRASTERRECTINFO *pRectInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBounds )( 
            IDXRasterizer * This,
            /* [out] */ DXBNDS *pBounds);
        
        END_INTERFACE
    } IDXRasterizerVtbl;

    interface IDXRasterizer
    {
        CONST_VTBL struct IDXRasterizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRasterizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRasterizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRasterizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRasterizer_SetSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetSurface(This,pDXSurface)

#define IDXRasterizer_GetSurface(This,ppDXSurface)	\
    (This)->lpVtbl -> GetSurface(This,ppDXSurface)

#define IDXRasterizer_SetFill(This,ulIndex,pSurface,ppt,FillColor)	\
    (This)->lpVtbl -> SetFill(This,ulIndex,pSurface,ppt,FillColor)

#define IDXRasterizer_GetFill(This,ulIndex,ppSurface,ppt,pFillColor)	\
    (This)->lpVtbl -> GetFill(This,ulIndex,ppSurface,ppt,pFillColor)

#define IDXRasterizer_BeginRendering(This,ulTimeOut)	\
    (This)->lpVtbl -> BeginRendering(This,ulTimeOut)

#define IDXRasterizer_EndRendering(This)	\
    (This)->lpVtbl -> EndRendering(This)

#define IDXRasterizer_RenderScan(This,pScanInfo)	\
    (This)->lpVtbl -> RenderScan(This,pScanInfo)

#define IDXRasterizer_SetPixel(This,pPointInfo)	\
    (This)->lpVtbl -> SetPixel(This,pPointInfo)

#define IDXRasterizer_FillRect(This,pRectInfo)	\
    (This)->lpVtbl -> FillRect(This,pRectInfo)

#define IDXRasterizer_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRasterizer_SetSurface_Proxy( 
    IDXRasterizer * This,
    /* [in] */ IDXSurface *pDXSurface);


void __RPC_STUB IDXRasterizer_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetSurface_Proxy( 
    IDXRasterizer * This,
    /* [out] */ IDXSurface **ppDXSurface);


void __RPC_STUB IDXRasterizer_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetFill_Proxy( 
    IDXRasterizer * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ IDXSurface *pSurface,
    /* [in] */ const POINT *ppt,
    /* [in] */ DXSAMPLE FillColor);


void __RPC_STUB IDXRasterizer_SetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetFill_Proxy( 
    IDXRasterizer * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IDXSurface **ppSurface,
    /* [out] */ POINT *ppt,
    /* [out] */ DXSAMPLE *pFillColor);


void __RPC_STUB IDXRasterizer_GetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_BeginRendering_Proxy( 
    IDXRasterizer * This,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXRasterizer_BeginRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_EndRendering_Proxy( 
    IDXRasterizer * This);


void __RPC_STUB IDXRasterizer_EndRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_RenderScan_Proxy( 
    IDXRasterizer * This,
    /* [in] */ const DXRASTERSCANINFO *pScanInfo);


void __RPC_STUB IDXRasterizer_RenderScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetPixel_Proxy( 
    IDXRasterizer * This,
    /* [in] */ DXRASTERPOINTINFO *pPointInfo);


void __RPC_STUB IDXRasterizer_SetPixel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_FillRect_Proxy( 
    IDXRasterizer * This,
    /* [in] */ const DXRASTERRECTINFO *pRectInfo);


void __RPC_STUB IDXRasterizer_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetBounds_Proxy( 
    IDXRasterizer * This,
    /* [out] */ DXBNDS *pBounds);


void __RPC_STUB IDXRasterizer_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRasterizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0288 */
/* [local] */ 

typedef 
enum DX2DXFORMOPS
    {	DX2DXO_IDENTITY	= 0,
	DX2DXO_TRANSLATE	= DX2DXO_IDENTITY + 1,
	DX2DXO_SCALE	= DX2DXO_TRANSLATE + 1,
	DX2DXO_SCALE_AND_TRANS	= DX2DXO_SCALE + 1,
	DX2DXO_GENERAL	= DX2DXO_SCALE_AND_TRANS + 1,
	DX2DXO_GENERAL_AND_TRANS	= DX2DXO_GENERAL + 1
    } 	DX2DXFORMOPS;

typedef struct DX2DXFORM
    {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
    DX2DXFORMOPS eOp;
    } 	DX2DXFORM;

typedef struct DX2DXFORM *PDX2DXFORM;

typedef 
enum DX2DPOLYDRAW
    {	DX2D_WINDING_FILL	= 1L << 0,
	DX2D_NO_FLATTEN	= 1L << 1,
	DX2D_DO_GRID_FIT	= 1L << 2,
	DX2D_IS_RECT	= 1L << 3,
	DX2D_STROKE	= 1L << 4,
	DX2D_FILL	= 1L << 5,
	DX2D_UNUSED	= 0xffffffc0
    } 	DX2DPOLYDRAW;

typedef struct DXFPOINT
    {
    FLOAT x;
    FLOAT y;
    } 	DXFPOINT;

typedef 
enum DX2DPEN
    {	DX2D_PEN_DEFAULT	= 0,
	DX2D_PEN_WIDTH_IN_DISPLAY_COORDS	= 1L << 0,
	DX2D_PEN_UNUSED	= 0xfffffffe
    } 	DX2DPEN;

typedef struct DXPEN
    {
    DXSAMPLE Color;
    float Width;
    DWORD Style;
    IDXSurface *pTexture;
    DXFPOINT TexturePos;
    DWORD dwFlags;
    } 	DXPEN;

typedef struct DXBRUSH
    {
    DXSAMPLE Color;
    IDXSurface *pTexture;
    DXFPOINT TexturePos;
    } 	DXBRUSH;

typedef 
enum DX2DGRADIENT
    {	DX2DGRAD_DEFAULT	= 0,
	DX2DGRAD_CLIPGRADIENT	= 1,
	DX2DGRAD_UNUSED	= 0xfffffffe
    } 	DX2DGRADIENT;

typedef 
enum DXLOGFONTENUM
    {	DXLF_HEIGHT	= 1,
	DXLF_WIDTH	= 2,
	DXLF_ESC	= 4,
	DXLF_ORIENTATION	= 8,
	DXLF_WEIGHT	= 16,
	DXLF_ITALIC	= 32,
	DXLF_UNDERLINE	= 64,
	DXLF_STRIKEOUT	= 128,
	DXLF_CHARSET	= 256,
	DXLF_OUTPREC	= 512,
	DXLF_CLIPPREC	= 1024,
	DXLF_QUALITY	= 2048,
	DXLF_PITCHANDFAM	= 4096,
	DXLF_FACENAME	= 8192,
	DXLF_ALL	= 0x3fff
    } 	DXLOGFONTENUM;

#ifndef _WINGDI_
typedef struct tagLOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef struct tagLOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0288_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0288_v0_0_s_ifspec;

#ifndef __IDXTLabel_INTERFACE_DEFINED__
#define __IDXTLabel_INTERFACE_DEFINED__

/* interface IDXTLabel */
/* [object][hidden][unique][uuid] */ 


EXTERN_C const IID IID_IDXTLabel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0C17F0E-AE41-11d1-9A3B-0000F8756A10")
    IDXTLabel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFontHandle( 
            /* [in] */ HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontHandle( 
            /* [out] */ HFONT *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextString( 
            /* [in] */ LPCWSTR pString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextString( 
            /* [out] */ LPWSTR *ppString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundColor( 
            /* [out] */ DXSAMPLE *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTexturePosition( 
            /* [out] */ long *px,
            /* [out] */ long *py) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTexturePosition( 
            /* [in] */ long x,
            /* [in] */ long y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMatrix( 
            /* [out] */ PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMatrix( 
            /* [in] */ const PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogfont( 
            /* [in] */ const LOGFONT *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogfont( 
            /* [out] */ LOGFONT *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteWithRasterizer( 
            /* [in] */ IDXRasterizer *pRasterizer,
            /* [in] */ const DXBNDS *pClipBnds,
            /* [in] */ const DXVEC *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaselineOffset( 
            /* [out] */ long *px,
            /* [out] */ long *py,
            /* [out] */ long *pdx,
            /* [out] */ long *pdy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTLabelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTLabel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTLabel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTLabel * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontHandle )( 
            IDXTLabel * This,
            /* [in] */ HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontHandle )( 
            IDXTLabel * This,
            /* [out] */ HFONT *phFont);
        
        HRESULT ( STDMETHODCALLTYPE *SetTextString )( 
            IDXTLabel * This,
            /* [in] */ LPCWSTR pString);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextString )( 
            IDXTLabel * This,
            /* [out] */ LPWSTR *ppString);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillColor )( 
            IDXTLabel * This,
            /* [out] */ DXSAMPLE *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillColor )( 
            IDXTLabel * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundColor )( 
            IDXTLabel * This,
            /* [out] */ DXSAMPLE *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundColor )( 
            IDXTLabel * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTexturePosition )( 
            IDXTLabel * This,
            /* [out] */ long *px,
            /* [out] */ long *py);
        
        HRESULT ( STDMETHODCALLTYPE *SetTexturePosition )( 
            IDXTLabel * This,
            /* [in] */ long x,
            /* [in] */ long y);
        
        HRESULT ( STDMETHODCALLTYPE *GetMatrix )( 
            IDXTLabel * This,
            /* [out] */ PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE *SetMatrix )( 
            IDXTLabel * This,
            /* [in] */ const PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogfont )( 
            IDXTLabel * This,
            /* [in] */ const LOGFONT *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogfont )( 
            IDXTLabel * This,
            /* [out] */ LOGFONT *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteWithRasterizer )( 
            IDXTLabel * This,
            /* [in] */ IDXRasterizer *pRasterizer,
            /* [in] */ const DXBNDS *pClipBnds,
            /* [in] */ const DXVEC *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaselineOffset )( 
            IDXTLabel * This,
            /* [out] */ long *px,
            /* [out] */ long *py,
            /* [out] */ long *pdx,
            /* [out] */ long *pdy);
        
        END_INTERFACE
    } IDXTLabelVtbl;

    interface IDXTLabel
    {
        CONST_VTBL struct IDXTLabelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTLabel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTLabel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTLabel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTLabel_SetFontHandle(This,hFont)	\
    (This)->lpVtbl -> SetFontHandle(This,hFont)

#define IDXTLabel_GetFontHandle(This,phFont)	\
    (This)->lpVtbl -> GetFontHandle(This,phFont)

#define IDXTLabel_SetTextString(This,pString)	\
    (This)->lpVtbl -> SetTextString(This,pString)

#define IDXTLabel_GetTextString(This,ppString)	\
    (This)->lpVtbl -> GetTextString(This,ppString)

#define IDXTLabel_GetFillColor(This,pVal)	\
    (This)->lpVtbl -> GetFillColor(This,pVal)

#define IDXTLabel_SetFillColor(This,newVal)	\
    (This)->lpVtbl -> SetFillColor(This,newVal)

#define IDXTLabel_GetBackgroundColor(This,pVal)	\
    (This)->lpVtbl -> GetBackgroundColor(This,pVal)

#define IDXTLabel_SetBackgroundColor(This,newVal)	\
    (This)->lpVtbl -> SetBackgroundColor(This,newVal)

#define IDXTLabel_GetTexturePosition(This,px,py)	\
    (This)->lpVtbl -> GetTexturePosition(This,px,py)

#define IDXTLabel_SetTexturePosition(This,x,y)	\
    (This)->lpVtbl -> SetTexturePosition(This,x,y)

#define IDXTLabel_GetMatrix(This,pXform)	\
    (This)->lpVtbl -> GetMatrix(This,pXform)

#define IDXTLabel_SetMatrix(This,pXform)	\
    (This)->lpVtbl -> SetMatrix(This,pXform)

#define IDXTLabel_SetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> SetLogfont(This,plf,dwFlags)

#define IDXTLabel_GetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> GetLogfont(This,plf,dwFlags)

#define IDXTLabel_ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)

#define IDXTLabel_GetBaselineOffset(This,px,py,pdx,pdy)	\
    (This)->lpVtbl -> GetBaselineOffset(This,px,py,pdx,pdy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTLabel_SetFontHandle_Proxy( 
    IDXTLabel * This,
    /* [in] */ HFONT hFont);


void __RPC_STUB IDXTLabel_SetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFontHandle_Proxy( 
    IDXTLabel * This,
    /* [out] */ HFONT *phFont);


void __RPC_STUB IDXTLabel_GetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTextString_Proxy( 
    IDXTLabel * This,
    /* [in] */ LPCWSTR pString);


void __RPC_STUB IDXTLabel_SetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTextString_Proxy( 
    IDXTLabel * This,
    /* [out] */ LPWSTR *ppString);


void __RPC_STUB IDXTLabel_GetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFillColor_Proxy( 
    IDXTLabel * This,
    /* [out] */ DXSAMPLE *pVal);


void __RPC_STUB IDXTLabel_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetFillColor_Proxy( 
    IDXTLabel * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBackgroundColor_Proxy( 
    IDXTLabel * This,
    /* [out] */ DXSAMPLE *pVal);


void __RPC_STUB IDXTLabel_GetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetBackgroundColor_Proxy( 
    IDXTLabel * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTexturePosition_Proxy( 
    IDXTLabel * This,
    /* [out] */ long *px,
    /* [out] */ long *py);


void __RPC_STUB IDXTLabel_GetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTexturePosition_Proxy( 
    IDXTLabel * This,
    /* [in] */ long x,
    /* [in] */ long y);


void __RPC_STUB IDXTLabel_SetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetMatrix_Proxy( 
    IDXTLabel * This,
    /* [out] */ PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_GetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetMatrix_Proxy( 
    IDXTLabel * This,
    /* [in] */ const PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_SetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetLogfont_Proxy( 
    IDXTLabel * This,
    /* [in] */ const LOGFONT *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_SetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetLogfont_Proxy( 
    IDXTLabel * This,
    /* [out] */ LOGFONT *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_GetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_ExecuteWithRasterizer_Proxy( 
    IDXTLabel * This,
    /* [in] */ IDXRasterizer *pRasterizer,
    /* [in] */ const DXBNDS *pClipBnds,
    /* [in] */ const DXVEC *pPlacement);


void __RPC_STUB IDXTLabel_ExecuteWithRasterizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBaselineOffset_Proxy( 
    IDXTLabel * This,
    /* [out] */ long *px,
    /* [out] */ long *py,
    /* [out] */ long *pdx,
    /* [out] */ long *pdy);


void __RPC_STUB IDXTLabel_GetBaselineOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTLabel_INTERFACE_DEFINED__ */


#ifndef __IDX2DDebug_INTERFACE_DEFINED__
#define __IDX2DDebug_INTERFACE_DEFINED__

/* interface IDX2DDebug */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDX2DDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03BB2457-A279-11d1-81C6-0000F87557DB")
    IDX2DDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDC( 
            HDC hDC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDC( 
            HDC *phDC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDX2DDebug * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDX2DDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDX2DDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDC )( 
            IDX2DDebug * This,
            HDC hDC);
        
        HRESULT ( STDMETHODCALLTYPE *GetDC )( 
            IDX2DDebug * This,
            HDC *phDC);
        
        END_INTERFACE
    } IDX2DDebugVtbl;

    interface IDX2DDebug
    {
        CONST_VTBL struct IDX2DDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2DDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2DDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2DDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2DDebug_SetDC(This,hDC)	\
    (This)->lpVtbl -> SetDC(This,hDC)

#define IDX2DDebug_GetDC(This,phDC)	\
    (This)->lpVtbl -> GetDC(This,phDC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2DDebug_SetDC_Proxy( 
    IDX2DDebug * This,
    HDC hDC);


void __RPC_STUB IDX2DDebug_SetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2DDebug_GetDC_Proxy( 
    IDX2DDebug * This,
    HDC *phDC);


void __RPC_STUB IDX2DDebug_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2DDebug_INTERFACE_DEFINED__ */


#ifndef __IDX2D_INTERFACE_DEFINED__
#define __IDX2D_INTERFACE_DEFINED__

/* interface IDX2D */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDX2D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EFD02A9-A996-11d1-81C9-0000F87557DB")
    IDX2D : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTransformFactory( 
            IDXTransformFactory *pTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformFactory( 
            IDXTransformFactory **ppTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            IUnknown *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            REFIID riid,
            void **ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipRect( 
            RECT *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipRect( 
            RECT *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorldTransform( 
            const DX2DXFORM *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorldTransform( 
            DX2DXFORM *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPen( 
            const DXPEN *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPen( 
            DXPEN *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrush( 
            const DXBRUSH *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrush( 
            DXBRUSH *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundBrush( 
            const DXBRUSH *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundBrush( 
            DXBRUSH *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFont( 
            HFONT *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Blt( 
            IUnknown *punkSrc,
            const RECT *pSrcRect,
            const POINT *pDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAPolyDraw( 
            const DXFPOINT *pPos,
            const BYTE *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAText( 
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradientBrush( 
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradientBrush( 
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDX2D * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDX2D * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDX2D * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformFactory )( 
            IDX2D * This,
            IDXTransformFactory *pTransFact);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformFactory )( 
            IDX2D * This,
            IDXTransformFactory **ppTransFact);
        
        HRESULT ( STDMETHODCALLTYPE *SetSurface )( 
            IDX2D * This,
            IUnknown *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDX2D * This,
            REFIID riid,
            void **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipRect )( 
            IDX2D * This,
            RECT *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipRect )( 
            IDX2D * This,
            RECT *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorldTransform )( 
            IDX2D * This,
            const DX2DXFORM *pXform);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorldTransform )( 
            IDX2D * This,
            DX2DXFORM *pXform);
        
        HRESULT ( STDMETHODCALLTYPE *SetPen )( 
            IDX2D * This,
            const DXPEN *pPen);
        
        HRESULT ( STDMETHODCALLTYPE *GetPen )( 
            IDX2D * This,
            DXPEN *pPen);
        
        HRESULT ( STDMETHODCALLTYPE *SetBrush )( 
            IDX2D * This,
            const DXBRUSH *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetBrush )( 
            IDX2D * This,
            DXBRUSH *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundBrush )( 
            IDX2D * This,
            const DXBRUSH *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundBrush )( 
            IDX2D * This,
            DXBRUSH *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetFont )( 
            IDX2D * This,
            HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE *GetFont )( 
            IDX2D * This,
            HFONT *phFont);
        
        HRESULT ( STDMETHODCALLTYPE *Blt )( 
            IDX2D * This,
            IUnknown *punkSrc,
            const RECT *pSrcRect,
            const POINT *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *AAPolyDraw )( 
            IDX2D * This,
            const DXFPOINT *pPos,
            const BYTE *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AAText )( 
            IDX2D * This,
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetRadialGradientBrush )( 
            IDX2D * This,
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinearGradientBrush )( 
            IDX2D * This,
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDX2DVtbl;

    interface IDX2D
    {
        CONST_VTBL struct IDX2DVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2D_SetTransformFactory(This,pTransFact)	\
    (This)->lpVtbl -> SetTransformFactory(This,pTransFact)

#define IDX2D_GetTransformFactory(This,ppTransFact)	\
    (This)->lpVtbl -> GetTransformFactory(This,ppTransFact)

#define IDX2D_SetSurface(This,pSurface)	\
    (This)->lpVtbl -> SetSurface(This,pSurface)

#define IDX2D_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDX2D_SetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> SetClipRect(This,pClipRect)

#define IDX2D_GetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> GetClipRect(This,pClipRect)

#define IDX2D_SetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> SetWorldTransform(This,pXform)

#define IDX2D_GetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> GetWorldTransform(This,pXform)

#define IDX2D_SetPen(This,pPen)	\
    (This)->lpVtbl -> SetPen(This,pPen)

#define IDX2D_GetPen(This,pPen)	\
    (This)->lpVtbl -> GetPen(This,pPen)

#define IDX2D_SetBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBrush(This,pBrush)

#define IDX2D_GetBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBrush(This,pBrush)

#define IDX2D_SetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBackgroundBrush(This,pBrush)

#define IDX2D_GetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBackgroundBrush(This,pBrush)

#define IDX2D_SetFont(This,hFont)	\
    (This)->lpVtbl -> SetFont(This,hFont)

#define IDX2D_GetFont(This,phFont)	\
    (This)->lpVtbl -> GetFont(This,phFont)

#define IDX2D_Blt(This,punkSrc,pSrcRect,pDest)	\
    (This)->lpVtbl -> Blt(This,punkSrc,pSrcRect,pDest)

#define IDX2D_AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)	\
    (This)->lpVtbl -> AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)

#define IDX2D_AAText(This,Pos,pString,ulCount,dwFlags)	\
    (This)->lpVtbl -> AAText(This,Pos,pString,ulCount,dwFlags)

#define IDX2D_SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDX2D_SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2D_SetTransformFactory_Proxy( 
    IDX2D * This,
    IDXTransformFactory *pTransFact);


void __RPC_STUB IDX2D_SetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetTransformFactory_Proxy( 
    IDX2D * This,
    IDXTransformFactory **ppTransFact);


void __RPC_STUB IDX2D_GetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetSurface_Proxy( 
    IDX2D * This,
    IUnknown *pSurface);


void __RPC_STUB IDX2D_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetSurface_Proxy( 
    IDX2D * This,
    REFIID riid,
    void **ppSurface);


void __RPC_STUB IDX2D_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetClipRect_Proxy( 
    IDX2D * This,
    RECT *pClipRect);


void __RPC_STUB IDX2D_SetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetClipRect_Proxy( 
    IDX2D * This,
    RECT *pClipRect);


void __RPC_STUB IDX2D_GetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetWorldTransform_Proxy( 
    IDX2D * This,
    const DX2DXFORM *pXform);


void __RPC_STUB IDX2D_SetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetWorldTransform_Proxy( 
    IDX2D * This,
    DX2DXFORM *pXform);


void __RPC_STUB IDX2D_GetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetPen_Proxy( 
    IDX2D * This,
    const DXPEN *pPen);


void __RPC_STUB IDX2D_SetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetPen_Proxy( 
    IDX2D * This,
    DXPEN *pPen);


void __RPC_STUB IDX2D_GetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBrush_Proxy( 
    IDX2D * This,
    const DXBRUSH *pBrush);


void __RPC_STUB IDX2D_SetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBrush_Proxy( 
    IDX2D * This,
    DXBRUSH *pBrush);


void __RPC_STUB IDX2D_GetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBackgroundBrush_Proxy( 
    IDX2D * This,
    const DXBRUSH *pBrush);


void __RPC_STUB IDX2D_SetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBackgroundBrush_Proxy( 
    IDX2D * This,
    DXBRUSH *pBrush);


void __RPC_STUB IDX2D_GetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetFont_Proxy( 
    IDX2D * This,
    HFONT hFont);


void __RPC_STUB IDX2D_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetFont_Proxy( 
    IDX2D * This,
    HFONT *phFont);


void __RPC_STUB IDX2D_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_Blt_Proxy( 
    IDX2D * This,
    IUnknown *punkSrc,
    const RECT *pSrcRect,
    const POINT *pDest);


void __RPC_STUB IDX2D_Blt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAPolyDraw_Proxy( 
    IDX2D * This,
    const DXFPOINT *pPos,
    const BYTE *pTypes,
    ULONG ulCount,
    ULONG SubSampRes,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAPolyDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAText_Proxy( 
    IDX2D * This,
    DXFPOINT Pos,
    LPWSTR pString,
    ULONG ulCount,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetRadialGradientBrush_Proxy( 
    IDX2D * This,
    /* [size_is][in] */ double *rgdblOffsets,
    /* [size_is][in] */ double *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetRadialGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetLinearGradientBrush_Proxy( 
    IDX2D * This,
    /* [size_is][in] */ double *rgdblOffsets,
    /* [size_is][in] */ double *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetLinearGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2D_INTERFACE_DEFINED__ */


#ifndef __IDXGradient2_INTERFACE_DEFINED__
#define __IDXGradient2_INTERFACE_DEFINED__

/* interface IDXGradient2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0ef2a80-61dc-11d2-b2eb-00a0c936b212")
    IDXGradient2 : public IDXGradient
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradient( 
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradient( 
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradient2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGradient2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGradient2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGradient2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSize )( 
            IDXGradient2 * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE *SetGradient )( 
            IDXGradient2 * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSize )( 
            IDXGradient2 * This,
            /* [out] */ SIZE *pOutSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetRadialGradient )( 
            IDXGradient2 * This,
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinearGradient )( 
            IDXGradient2 * This,
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXGradient2Vtbl;

    interface IDXGradient2
    {
        CONST_VTBL struct IDXGradient2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient2_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient2_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient2_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)


#define IDXGradient2_SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDXGradient2_SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient2_SetRadialGradient_Proxy( 
    IDXGradient2 * This,
    /* [size_is][in] */ double *rgdblOffsets,
    /* [size_is][in] */ double *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetRadialGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient2_SetLinearGradient_Proxy( 
    IDXGradient2 * This,
    /* [size_is][in] */ double *rgdblOffsets,
    /* [size_is][in] */ double *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetLinearGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0292 */
/* [local] */ 

typedef 
enum DXTFILTERCAPS
    {	DXTFILTERCAPS_IDXSURFACE	= 1L << 0,
	DXTFILTERCAPS_IDXEFFECT	= 1L << 1,
	DXTFILTERCAPS_INPUT1REQ	= 1L << 2,
	DXTFILTERCAPS_INPUT2REQ	= 1L << 3,
	DXTFILTERCAPS_INPUT1OPT	= 1L << 4,
	DXTFILTERCAPS_INPUT2OPT	= 1L << 5,
	DXTFILTERCAPS_PRIV_MATRIX	= 1L << 6,
	DXTFILTERCAPS_MAX	= 1L << 7
    } 	DXTFILTERCAPS;

typedef void *HFILTER;

typedef 
enum DXT_FILTER_TYPE_FLAGS
    {	DXTFTF_INVALID	= 0,
	DXTFTF_CSS	= 1L << 0,
	DXTFTF_PRIVATE	= 1L << 1,
	DXTFTF_ALLMODIFIERS	= DXTFTF_CSS | DXTFTF_PRIVATE,
	DXTFTF_SURFACE	= 1L << 16,
	DXTFTF_ZEROINPUT	= 1L << 17,
	DXTFTF_FILTER	= 1L << 18,
	DXTFTF_ALLTYPES	= DXTFTF_SURFACE | DXTFTF_ZEROINPUT | DXTFTF_FILTER
    } 	DXT_FILTER_TYPE_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0292_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0292_v0_0_s_ifspec;

#ifndef __IDXTFilterBehavior_INTERFACE_DEFINED__
#define __IDXTFilterBehavior_INTERFACE_DEFINED__

/* interface IDXTFilterBehavior */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilterBehavior;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14D7DDDD-ACA2-4E45-9504-3808ABEB4F92")
    IDXTFilterBehavior : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            IDXTransformFactory *pDXTransformFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterCollection( 
            IDXTFilterCollection **ppDXTFilterCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockFilterChainForEdit( 
            DWORD *pdwKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFilterFromBSTR( 
            const BSTR bstrFilterString,
            const DWORD dwFlags,
            DWORD *const pdwFilterType,
            HFILTER *const phFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyFilter( 
            HFILTER hFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockFilterChain( 
            DWORD dwKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterBehaviorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilterBehavior * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilterBehavior * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilterBehavior * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDXTFilterBehavior * This,
            IDXTransformFactory *pDXTransformFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterCollection )( 
            IDXTFilterBehavior * This,
            IDXTFilterCollection **ppDXTFilterCollection);
        
        HRESULT ( STDMETHODCALLTYPE *LockFilterChainForEdit )( 
            IDXTFilterBehavior * This,
            DWORD *pdwKey);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilterFromBSTR )( 
            IDXTFilterBehavior * This,
            const BSTR bstrFilterString,
            const DWORD dwFlags,
            DWORD *const pdwFilterType,
            HFILTER *const phFilter);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyFilter )( 
            IDXTFilterBehavior * This,
            HFILTER hFilter);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockFilterChain )( 
            IDXTFilterBehavior * This,
            DWORD dwKey);
        
        END_INTERFACE
    } IDXTFilterBehaviorVtbl;

    interface IDXTFilterBehavior
    {
        CONST_VTBL struct IDXTFilterBehaviorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilterBehavior_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilterBehavior_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilterBehavior_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilterBehavior_Initialize(This,pDXTransformFactory)	\
    (This)->lpVtbl -> Initialize(This,pDXTransformFactory)

#define IDXTFilterBehavior_GetFilterCollection(This,ppDXTFilterCollection)	\
    (This)->lpVtbl -> GetFilterCollection(This,ppDXTFilterCollection)

#define IDXTFilterBehavior_LockFilterChainForEdit(This,pdwKey)	\
    (This)->lpVtbl -> LockFilterChainForEdit(This,pdwKey)

#define IDXTFilterBehavior_AddFilterFromBSTR(This,bstrFilterString,dwFlags,pdwFilterType,phFilter)	\
    (This)->lpVtbl -> AddFilterFromBSTR(This,bstrFilterString,dwFlags,pdwFilterType,phFilter)

#define IDXTFilterBehavior_DestroyFilter(This,hFilter)	\
    (This)->lpVtbl -> DestroyFilter(This,hFilter)

#define IDXTFilterBehavior_UnlockFilterChain(This,dwKey)	\
    (This)->lpVtbl -> UnlockFilterChain(This,dwKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_Initialize_Proxy( 
    IDXTFilterBehavior * This,
    IDXTransformFactory *pDXTransformFactory);


void __RPC_STUB IDXTFilterBehavior_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_GetFilterCollection_Proxy( 
    IDXTFilterBehavior * This,
    IDXTFilterCollection **ppDXTFilterCollection);


void __RPC_STUB IDXTFilterBehavior_GetFilterCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_LockFilterChainForEdit_Proxy( 
    IDXTFilterBehavior * This,
    DWORD *pdwKey);


void __RPC_STUB IDXTFilterBehavior_LockFilterChainForEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_AddFilterFromBSTR_Proxy( 
    IDXTFilterBehavior * This,
    const BSTR bstrFilterString,
    const DWORD dwFlags,
    DWORD *const pdwFilterType,
    HFILTER *const phFilter);


void __RPC_STUB IDXTFilterBehavior_AddFilterFromBSTR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_DestroyFilter_Proxy( 
    IDXTFilterBehavior * This,
    HFILTER hFilter);


void __RPC_STUB IDXTFilterBehavior_DestroyFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_UnlockFilterChain_Proxy( 
    IDXTFilterBehavior * This,
    DWORD dwKey);


void __RPC_STUB IDXTFilterBehavior_UnlockFilterChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilterBehavior_INTERFACE_DEFINED__ */


#ifndef __IDXTFilterBehaviorSite_INTERFACE_DEFINED__
#define __IDXTFilterBehaviorSite_INTERFACE_DEFINED__

/* interface IDXTFilterBehaviorSite */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilterBehaviorSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("909B23C2-9018-499f-A86D-4E7DA937E931")
    IDXTFilterBehaviorSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvalidateElement( 
            BOOL fInvalidateSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateFilterChain( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteFilterChain( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireOnFilterChangeEvent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFilterChangeStatus( 
            DXTFILTER_STATUS eStatusOld,
            DXTFILTER_STATUS eStatusNew) = 0;
        
        virtual void STDMETHODCALLTYPE OnFatalError( 
            HRESULT hrFatalError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimer( 
            void **ppvTimer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnsureView( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterBehaviorSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilterBehaviorSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilterBehaviorSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilterBehaviorSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateElement )( 
            IDXTFilterBehaviorSite * This,
            BOOL fInvalidateSize);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateFilterChain )( 
            IDXTFilterBehaviorSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteFilterChain )( 
            IDXTFilterBehaviorSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *FireOnFilterChangeEvent )( 
            IDXTFilterBehaviorSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnFilterChangeStatus )( 
            IDXTFilterBehaviorSite * This,
            DXTFILTER_STATUS eStatusOld,
            DXTFILTER_STATUS eStatusNew);
        
        void ( STDMETHODCALLTYPE *OnFatalError )( 
            IDXTFilterBehaviorSite * This,
            HRESULT hrFatalError);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimer )( 
            IDXTFilterBehaviorSite * This,
            void **ppvTimer);
        
        HRESULT ( STDMETHODCALLTYPE *EnsureView )( 
            IDXTFilterBehaviorSite * This);
        
        END_INTERFACE
    } IDXTFilterBehaviorSiteVtbl;

    interface IDXTFilterBehaviorSite
    {
        CONST_VTBL struct IDXTFilterBehaviorSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilterBehaviorSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilterBehaviorSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilterBehaviorSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilterBehaviorSite_InvalidateElement(This,fInvalidateSize)	\
    (This)->lpVtbl -> InvalidateElement(This,fInvalidateSize)

#define IDXTFilterBehaviorSite_InvalidateFilterChain(This)	\
    (This)->lpVtbl -> InvalidateFilterChain(This)

#define IDXTFilterBehaviorSite_ExecuteFilterChain(This)	\
    (This)->lpVtbl -> ExecuteFilterChain(This)

#define IDXTFilterBehaviorSite_FireOnFilterChangeEvent(This)	\
    (This)->lpVtbl -> FireOnFilterChangeEvent(This)

#define IDXTFilterBehaviorSite_OnFilterChangeStatus(This,eStatusOld,eStatusNew)	\
    (This)->lpVtbl -> OnFilterChangeStatus(This,eStatusOld,eStatusNew)

#define IDXTFilterBehaviorSite_OnFatalError(This,hrFatalError)	\
    (This)->lpVtbl -> OnFatalError(This,hrFatalError)

#define IDXTFilterBehaviorSite_GetTimer(This,ppvTimer)	\
    (This)->lpVtbl -> GetTimer(This,ppvTimer)

#define IDXTFilterBehaviorSite_EnsureView(This)	\
    (This)->lpVtbl -> EnsureView(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_InvalidateElement_Proxy( 
    IDXTFilterBehaviorSite * This,
    BOOL fInvalidateSize);


void __RPC_STUB IDXTFilterBehaviorSite_InvalidateElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_InvalidateFilterChain_Proxy( 
    IDXTFilterBehaviorSite * This);


void __RPC_STUB IDXTFilterBehaviorSite_InvalidateFilterChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_ExecuteFilterChain_Proxy( 
    IDXTFilterBehaviorSite * This);


void __RPC_STUB IDXTFilterBehaviorSite_ExecuteFilterChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_FireOnFilterChangeEvent_Proxy( 
    IDXTFilterBehaviorSite * This);


void __RPC_STUB IDXTFilterBehaviorSite_FireOnFilterChangeEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_OnFilterChangeStatus_Proxy( 
    IDXTFilterBehaviorSite * This,
    DXTFILTER_STATUS eStatusOld,
    DXTFILTER_STATUS eStatusNew);


void __RPC_STUB IDXTFilterBehaviorSite_OnFilterChangeStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXTFilterBehaviorSite_OnFatalError_Proxy( 
    IDXTFilterBehaviorSite * This,
    HRESULT hrFatalError);


void __RPC_STUB IDXTFilterBehaviorSite_OnFatalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_GetTimer_Proxy( 
    IDXTFilterBehaviorSite * This,
    void **ppvTimer);


void __RPC_STUB IDXTFilterBehaviorSite_GetTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_EnsureView_Proxy( 
    IDXTFilterBehaviorSite * This);


void __RPC_STUB IDXTFilterBehaviorSite_EnsureView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilterBehaviorSite_INTERFACE_DEFINED__ */


#ifndef __IDXTFilterCollection_INTERFACE_DEFINED__
#define __IDXTFilterCollection_INTERFACE_DEFINED__

/* interface IDXTFilterCollection */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilterCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22B07B33-8BFB-49d4-9B90-0938370C9019")
    IDXTFilterCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            const IDXTFilterBehavior *pDXTFilterBehavior) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFilter( 
            const BSTR bstrFilterString,
            const DWORD dwFlags,
            DWORD *const pdwFilterType,
            HFILTER *const phFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilter( 
            const HFILTER hFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilters( 
            const DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterController( 
            const HFILTER hFilter,
            IDXTFilterController **const ppDXTFilterController) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilterCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilterCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilterCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDXTFilterCollection * This,
            const IDXTFilterBehavior *pDXTFilterBehavior);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IDXTFilterCollection * This,
            const BSTR bstrFilterString,
            const DWORD dwFlags,
            DWORD *const pdwFilterType,
            HFILTER *const phFilter);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IDXTFilterCollection * This,
            const HFILTER hFilter);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilters )( 
            IDXTFilterCollection * This,
            const DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterController )( 
            IDXTFilterCollection * This,
            const HFILTER hFilter,
            IDXTFilterController **const ppDXTFilterController);
        
        END_INTERFACE
    } IDXTFilterCollectionVtbl;

    interface IDXTFilterCollection
    {
        CONST_VTBL struct IDXTFilterCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilterCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilterCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilterCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilterCollection_Init(This,pDXTFilterBehavior)	\
    (This)->lpVtbl -> Init(This,pDXTFilterBehavior)

#define IDXTFilterCollection_AddFilter(This,bstrFilterString,dwFlags,pdwFilterType,phFilter)	\
    (This)->lpVtbl -> AddFilter(This,bstrFilterString,dwFlags,pdwFilterType,phFilter)

#define IDXTFilterCollection_RemoveFilter(This,hFilter)	\
    (This)->lpVtbl -> RemoveFilter(This,hFilter)

#define IDXTFilterCollection_RemoveFilters(This,dwFlags)	\
    (This)->lpVtbl -> RemoveFilters(This,dwFlags)

#define IDXTFilterCollection_GetFilterController(This,hFilter,ppDXTFilterController)	\
    (This)->lpVtbl -> GetFilterController(This,hFilter,ppDXTFilterController)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilterCollection_Init_Proxy( 
    IDXTFilterCollection * This,
    const IDXTFilterBehavior *pDXTFilterBehavior);


void __RPC_STUB IDXTFilterCollection_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterCollection_AddFilter_Proxy( 
    IDXTFilterCollection * This,
    const BSTR bstrFilterString,
    const DWORD dwFlags,
    DWORD *const pdwFilterType,
    HFILTER *const phFilter);


void __RPC_STUB IDXTFilterCollection_AddFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterCollection_RemoveFilter_Proxy( 
    IDXTFilterCollection * This,
    const HFILTER hFilter);


void __RPC_STUB IDXTFilterCollection_RemoveFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterCollection_RemoveFilters_Proxy( 
    IDXTFilterCollection * This,
    const DWORD dwFlags);


void __RPC_STUB IDXTFilterCollection_RemoveFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterCollection_GetFilterController_Proxy( 
    IDXTFilterCollection * This,
    const HFILTER hFilter,
    IDXTFilterController **const ppDXTFilterController);


void __RPC_STUB IDXTFilterCollection_GetFilterController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilterCollection_INTERFACE_DEFINED__ */


#ifndef __IDXTFilter_INTERFACE_DEFINED__
#define __IDXTFilter_INTERFACE_DEFINED__

/* interface IDXTFilter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6187E5A2-A445-4608-8FC0-BE7A6C8DB386")
    IDXTFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDXTransform *pDXTransform,
            /* [in] */ IDXSurfaceFactory *pDXSurfaceFactory,
            /* [in] */ IDXTFilterBehaviorSite *pDXTFilterBehaviorSite,
            /* [in] */ DWORD dwFilterCaps,
            /* [in] */ BOOL fUsesOldStyleFilterName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSurface( 
            /* [in] */ IDXSurface *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSurface( 
            /* [in] */ IDXSurface *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSurface( 
            /* [out] */ IDXSurface **ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsIn2Out( 
            /* [in] */ DXBNDS *pbndsIn,
            /* [out][in] */ DXBNDS *pbndsOut,
            /* [in] */ BOOL fResetOutputSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsOut2In( 
            /* [in] */ DXBNDS *pbndsOut,
            /* [out][in] */ DXBNDS *pbndsIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ DXBNDS *pbndsPortion,
            /* [in] */ DXVEC *pvecPlacement,
            /* [in] */ BOOL fFireFilterChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMiscFlags( 
            /* [in] */ DWORD dwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ const DXVEC *pvecOut,
            /* [out][in] */ BOOL *pfInactiveInputHit,
            /* [out][in] */ DXVEC *pvecIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsEnabled( void) = 0;
        
        virtual void STDMETHODCALLTYPE HardDisable( 
            HRESULT hrHardDisable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDXTFilter * This,
            /* [in] */ IDXTransform *pDXTransform,
            /* [in] */ IDXSurfaceFactory *pDXSurfaceFactory,
            /* [in] */ IDXTFilterBehaviorSite *pDXTFilterBehaviorSite,
            /* [in] */ DWORD dwFilterCaps,
            /* [in] */ BOOL fUsesOldStyleFilterName);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputSurface )( 
            IDXTFilter * This,
            /* [in] */ IDXSurface *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSurface )( 
            IDXTFilter * This,
            /* [in] */ IDXSurface *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSurface )( 
            IDXTFilter * This,
            /* [out] */ IDXSurface **ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *MapBoundsIn2Out )( 
            IDXTFilter * This,
            /* [in] */ DXBNDS *pbndsIn,
            /* [out][in] */ DXBNDS *pbndsOut,
            /* [in] */ BOOL fResetOutputSize);
        
        HRESULT ( STDMETHODCALLTYPE *MapBoundsOut2In )( 
            IDXTFilter * This,
            /* [in] */ DXBNDS *pbndsOut,
            /* [out][in] */ DXBNDS *pbndsIn);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IDXTFilter * This,
            /* [in] */ DXBNDS *pbndsPortion,
            /* [in] */ DXVEC *pvecPlacement,
            /* [in] */ BOOL fFireFilterChange);
        
        HRESULT ( STDMETHODCALLTYPE *SetMiscFlags )( 
            IDXTFilter * This,
            /* [in] */ DWORD dwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            IDXTFilter * This,
            /* [in] */ const DXVEC *pvecOut,
            /* [out][in] */ BOOL *pfInactiveInputHit,
            /* [out][in] */ DXVEC *pvecIn);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IDXTFilter * This);
        
        BOOL ( STDMETHODCALLTYPE *IsEnabled )( 
            IDXTFilter * This);
        
        void ( STDMETHODCALLTYPE *HardDisable )( 
            IDXTFilter * This,
            HRESULT hrHardDisable);
        
        END_INTERFACE
    } IDXTFilterVtbl;

    interface IDXTFilter
    {
        CONST_VTBL struct IDXTFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilter_Initialize(This,pDXTransform,pDXSurfaceFactory,pDXTFilterBehaviorSite,dwFilterCaps,fUsesOldStyleFilterName)	\
    (This)->lpVtbl -> Initialize(This,pDXTransform,pDXSurfaceFactory,pDXTFilterBehaviorSite,dwFilterCaps,fUsesOldStyleFilterName)

#define IDXTFilter_SetInputSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetInputSurface(This,pDXSurface)

#define IDXTFilter_SetOutputSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetOutputSurface(This,pDXSurface)

#define IDXTFilter_GetOutputSurface(This,ppDXSurface)	\
    (This)->lpVtbl -> GetOutputSurface(This,ppDXSurface)

#define IDXTFilter_MapBoundsIn2Out(This,pbndsIn,pbndsOut,fResetOutputSize)	\
    (This)->lpVtbl -> MapBoundsIn2Out(This,pbndsIn,pbndsOut,fResetOutputSize)

#define IDXTFilter_MapBoundsOut2In(This,pbndsOut,pbndsIn)	\
    (This)->lpVtbl -> MapBoundsOut2In(This,pbndsOut,pbndsIn)

#define IDXTFilter_Execute(This,pbndsPortion,pvecPlacement,fFireFilterChange)	\
    (This)->lpVtbl -> Execute(This,pbndsPortion,pvecPlacement,fFireFilterChange)

#define IDXTFilter_SetMiscFlags(This,dwMiscFlags)	\
    (This)->lpVtbl -> SetMiscFlags(This,dwMiscFlags)

#define IDXTFilter_HitTest(This,pvecOut,pfInactiveInputHit,pvecIn)	\
    (This)->lpVtbl -> HitTest(This,pvecOut,pfInactiveInputHit,pvecIn)

#define IDXTFilter_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IDXTFilter_IsEnabled(This)	\
    (This)->lpVtbl -> IsEnabled(This)

#define IDXTFilter_HardDisable(This,hrHardDisable)	\
    (This)->lpVtbl -> HardDisable(This,hrHardDisable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilter_Initialize_Proxy( 
    IDXTFilter * This,
    /* [in] */ IDXTransform *pDXTransform,
    /* [in] */ IDXSurfaceFactory *pDXSurfaceFactory,
    /* [in] */ IDXTFilterBehaviorSite *pDXTFilterBehaviorSite,
    /* [in] */ DWORD dwFilterCaps,
    /* [in] */ BOOL fUsesOldStyleFilterName);


void __RPC_STUB IDXTFilter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_SetInputSurface_Proxy( 
    IDXTFilter * This,
    /* [in] */ IDXSurface *pDXSurface);


void __RPC_STUB IDXTFilter_SetInputSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_SetOutputSurface_Proxy( 
    IDXTFilter * This,
    /* [in] */ IDXSurface *pDXSurface);


void __RPC_STUB IDXTFilter_SetOutputSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_GetOutputSurface_Proxy( 
    IDXTFilter * This,
    /* [out] */ IDXSurface **ppDXSurface);


void __RPC_STUB IDXTFilter_GetOutputSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_MapBoundsIn2Out_Proxy( 
    IDXTFilter * This,
    /* [in] */ DXBNDS *pbndsIn,
    /* [out][in] */ DXBNDS *pbndsOut,
    /* [in] */ BOOL fResetOutputSize);


void __RPC_STUB IDXTFilter_MapBoundsIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_MapBoundsOut2In_Proxy( 
    IDXTFilter * This,
    /* [in] */ DXBNDS *pbndsOut,
    /* [out][in] */ DXBNDS *pbndsIn);


void __RPC_STUB IDXTFilter_MapBoundsOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_Execute_Proxy( 
    IDXTFilter * This,
    /* [in] */ DXBNDS *pbndsPortion,
    /* [in] */ DXVEC *pvecPlacement,
    /* [in] */ BOOL fFireFilterChange);


void __RPC_STUB IDXTFilter_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_SetMiscFlags_Proxy( 
    IDXTFilter * This,
    /* [in] */ DWORD dwMiscFlags);


void __RPC_STUB IDXTFilter_SetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_HitTest_Proxy( 
    IDXTFilter * This,
    /* [in] */ const DXVEC *pvecOut,
    /* [out][in] */ BOOL *pfInactiveInputHit,
    /* [out][in] */ DXVEC *pvecIn);


void __RPC_STUB IDXTFilter_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_Detach_Proxy( 
    IDXTFilter * This);


void __RPC_STUB IDXTFilter_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IDXTFilter_IsEnabled_Proxy( 
    IDXTFilter * This);


void __RPC_STUB IDXTFilter_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXTFilter_HardDisable_Proxy( 
    IDXTFilter * This,
    HRESULT hrHardDisable);


void __RPC_STUB IDXTFilter_HardDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0296 */
/* [local] */ 

typedef 
enum DXT_QUICK_APPLY_TYPE
    {	DXTQAT_TransitionIn	= 0,
	DXTQAT_TransitionOut	= DXTQAT_TransitionIn + 1,
	DXTQAT_TransitionFromElement	= DXTQAT_TransitionOut + 1,
	DXTQAT_TransitionToElement	= DXTQAT_TransitionFromElement + 1
    } 	DXT_QUICK_APPLY_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0296_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0296_v0_0_s_ifspec;

#ifndef __IDXTFilterController_INTERFACE_DEFINED__
#define __IDXTFilterController_INTERFACE_DEFINED__

/* interface IDXTFilterController */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilterController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF315F2-273D-47B6-B9ED-F75DC3B0150B")
    IDXTFilterController : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProgress( 
            float flProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnabled( 
            BOOL fEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilterControlsVisibility( 
            BOOL fFilterControlsVisibility) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuickApply( 
            DXT_QUICK_APPLY_TYPE dxtqat,
            IUnknown *punkInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilterController * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilterController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilterController * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgress )( 
            IDXTFilterController * This,
            float flProgress);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IDXTFilterController * This,
            BOOL fEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterControlsVisibility )( 
            IDXTFilterController * This,
            BOOL fFilterControlsVisibility);
        
        HRESULT ( STDMETHODCALLTYPE *QuickApply )( 
            IDXTFilterController * This,
            DXT_QUICK_APPLY_TYPE dxtqat,
            IUnknown *punkInput);
        
        END_INTERFACE
    } IDXTFilterControllerVtbl;

    interface IDXTFilterController
    {
        CONST_VTBL struct IDXTFilterControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilterController_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilterController_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilterController_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilterController_SetProgress(This,flProgress)	\
    (This)->lpVtbl -> SetProgress(This,flProgress)

#define IDXTFilterController_SetEnabled(This,fEnabled)	\
    (This)->lpVtbl -> SetEnabled(This,fEnabled)

#define IDXTFilterController_SetFilterControlsVisibility(This,fFilterControlsVisibility)	\
    (This)->lpVtbl -> SetFilterControlsVisibility(This,fFilterControlsVisibility)

#define IDXTFilterController_QuickApply(This,dxtqat,punkInput)	\
    (This)->lpVtbl -> QuickApply(This,dxtqat,punkInput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilterController_SetProgress_Proxy( 
    IDXTFilterController * This,
    float flProgress);


void __RPC_STUB IDXTFilterController_SetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterController_SetEnabled_Proxy( 
    IDXTFilterController * This,
    BOOL fEnabled);


void __RPC_STUB IDXTFilterController_SetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterController_SetFilterControlsVisibility_Proxy( 
    IDXTFilterController * This,
    BOOL fFilterControlsVisibility);


void __RPC_STUB IDXTFilterController_SetFilterControlsVisibility_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterController_QuickApply_Proxy( 
    IDXTFilterController * This,
    DXT_QUICK_APPLY_TYPE dxtqat,
    IUnknown *punkInput);


void __RPC_STUB IDXTFilterController_QuickApply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilterController_INTERFACE_DEFINED__ */


#ifndef __IDXTRedirectFilterInit_INTERFACE_DEFINED__
#define __IDXTRedirectFilterInit_INTERFACE_DEFINED__

/* interface IDXTRedirectFilterInit */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTRedirectFilterInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D1A57094-21F7-4e6c-93E5-F5F77F748293")
    IDXTRedirectFilterInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHTMLPaintSite( 
            void *pvHTMLPaintSite) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRedirectFilterInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTRedirectFilterInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTRedirectFilterInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTRedirectFilterInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHTMLPaintSite )( 
            IDXTRedirectFilterInit * This,
            void *pvHTMLPaintSite);
        
        END_INTERFACE
    } IDXTRedirectFilterInitVtbl;

    interface IDXTRedirectFilterInit
    {
        CONST_VTBL struct IDXTRedirectFilterInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRedirectFilterInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRedirectFilterInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRedirectFilterInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRedirectFilterInit_SetHTMLPaintSite(This,pvHTMLPaintSite)	\
    (This)->lpVtbl -> SetHTMLPaintSite(This,pvHTMLPaintSite)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTRedirectFilterInit_SetHTMLPaintSite_Proxy( 
    IDXTRedirectFilterInit * This,
    void *pvHTMLPaintSite);


void __RPC_STUB IDXTRedirectFilterInit_SetHTMLPaintSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRedirectFilterInit_INTERFACE_DEFINED__ */


#ifndef __IDXTClipOrigin_INTERFACE_DEFINED__
#define __IDXTClipOrigin_INTERFACE_DEFINED__

/* interface IDXTClipOrigin */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTClipOrigin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE1663D8-0988-4C48-9FD6-DB4450885668")
    IDXTClipOrigin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClipOrigin( 
            DXVEC *pvecClipOrigin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTClipOriginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTClipOrigin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTClipOrigin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTClipOrigin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipOrigin )( 
            IDXTClipOrigin * This,
            DXVEC *pvecClipOrigin);
        
        END_INTERFACE
    } IDXTClipOriginVtbl;

    interface IDXTClipOrigin
    {
        CONST_VTBL struct IDXTClipOriginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTClipOrigin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTClipOrigin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTClipOrigin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTClipOrigin_GetClipOrigin(This,pvecClipOrigin)	\
    (This)->lpVtbl -> GetClipOrigin(This,pvecClipOrigin)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTClipOrigin_GetClipOrigin_Proxy( 
    IDXTClipOrigin * This,
    DXVEC *pvecClipOrigin);


void __RPC_STUB IDXTClipOrigin_GetClipOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTClipOrigin_INTERFACE_DEFINED__ */



#ifndef __DXTRANSPLib_LIBRARY_DEFINED__
#define __DXTRANSPLib_LIBRARY_DEFINED__

/* library DXTRANSPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTRANSPLib;

EXTERN_C const CLSID CLSID_DXTLabel;

#ifdef __cplusplus

class DECLSPEC_UUID("54702535-2606-11D1-999C-0000F8756A10")
DXTLabel;
#endif

EXTERN_C const CLSID CLSID_DXRasterizer;

#ifdef __cplusplus

class DECLSPEC_UUID("8652CE55-9E80-11D1-9053-00C04FD9189D")
DXRasterizer;
#endif

EXTERN_C const CLSID CLSID_DX2D;

#ifdef __cplusplus

class DECLSPEC_UUID("473AA80B-4577-11D1-81A8-0000F87557DB")
DX2D;
#endif

EXTERN_C const CLSID CLSID_DXTFilterBehavior;

#ifdef __cplusplus

class DECLSPEC_UUID("649EEC1E-B579-4E8C-BB3B-4997F8426536")
DXTFilterBehavior;
#endif

EXTERN_C const CLSID CLSID_DXTFilterFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("81397204-F51A-4571-8D7B-DC030521AABD")
DXTFilterFactory;
#endif

EXTERN_C const CLSID CLSID_DXTFilterCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("A7EE7F34-3BD1-427f-9231-F941E9B7E1FE")
DXTFilterCollection;
#endif
#endif /* __DXTRANSPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HFONT_UserSize(     unsigned long *, unsigned long            , HFONT * ); 
unsigned char * __RPC_USER  HFONT_UserMarshal(  unsigned long *, unsigned char *, HFONT * ); 
unsigned char * __RPC_USER  HFONT_UserUnmarshal(unsigned long *, unsigned char *, HFONT * ); 
void                      __RPC_USER  HFONT_UserFree(     unsigned long *, HFONT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\httprequest_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for httprequest.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_WinHttp,0x662901fc,0x6951,0x4854,0x9e,0xb2,0xd9,0xa2,0x57,0x0f,0x2b,0x2e);


MIDL_DEFINE_GUID(IID, IID_IWinHttpRequest,0x016fe2ec,0xb2c8,0x45f8,0xb2,0x3b,0x39,0xe5,0x3a,0x75,0x39,0x6b);


MIDL_DEFINE_GUID(IID, IID_IWinHttpRequestEvents,0xf97f4e15,0xb787,0x4212,0x80,0xd1,0xd3,0x80,0xcb,0xbf,0x98,0x2e);


MIDL_DEFINE_GUID(CLSID, CLSID_WinHttpRequest,0x2087c2f4,0x2cef,0x4953,0xa8,0xab,0x66,0x77,0x9b,0x67,0x04,0x95);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for httprequest.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_WinHttp,0x662901fc,0x6951,0x4854,0x9e,0xb2,0xd9,0xa2,0x57,0x0f,0x2b,0x2e);


MIDL_DEFINE_GUID(IID, IID_IWinHttpRequest,0x016fe2ec,0xb2c8,0x45f8,0xb2,0x3b,0x39,0xe5,0x3a,0x75,0x39,0x6b);


MIDL_DEFINE_GUID(IID, IID_IWinHttpRequestEvents,0xf97f4e15,0xb787,0x4212,0x80,0xd1,0xd3,0x80,0xcb,0xbf,0x98,0x2e);


MIDL_DEFINE_GUID(CLSID, CLSID_WinHttpRequest,0x2087c2f4,0x2cef,0x4953,0xa8,0xab,0x66,0x77,0x9b,0x67,0x04,0x95);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\interned.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for interned.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __interned_h__
#define __interned_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISelectionObject2_FWD_DEFINED__
#define __ISelectionObject2_FWD_DEFINED__
typedef interface ISelectionObject2 ISelectionObject2;
#endif 	/* __ISelectionObject2_FWD_DEFINED__ */


#ifndef __IHTMLEditor_FWD_DEFINED__
#define __IHTMLEditor_FWD_DEFINED__
typedef interface IHTMLEditor IHTMLEditor;
#endif 	/* __IHTMLEditor_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow_FWD_DEFINED__
#define __IHTMLPrivateWindow_FWD_DEFINED__
typedef interface IHTMLPrivateWindow IHTMLPrivateWindow;
#endif 	/* __IHTMLPrivateWindow_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow2_FWD_DEFINED__
#define __IHTMLPrivateWindow2_FWD_DEFINED__
typedef interface IHTMLPrivateWindow2 IHTMLPrivateWindow2;
#endif 	/* __IHTMLPrivateWindow2_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow3_FWD_DEFINED__
#define __IHTMLPrivateWindow3_FWD_DEFINED__
typedef interface IHTMLPrivateWindow3 IHTMLPrivateWindow3;
#endif 	/* __IHTMLPrivateWindow3_FWD_DEFINED__ */


#ifndef __ISubDivisionProvider_FWD_DEFINED__
#define __ISubDivisionProvider_FWD_DEFINED__
typedef interface ISubDivisionProvider ISubDivisionProvider;
#endif 	/* __ISubDivisionProvider_FWD_DEFINED__ */


#ifndef __IElementBehaviorUI_FWD_DEFINED__
#define __IElementBehaviorUI_FWD_DEFINED__
typedef interface IElementBehaviorUI IElementBehaviorUI;
#endif 	/* __IElementBehaviorUI_FWD_DEFINED__ */


#ifndef __IElementAdorner_FWD_DEFINED__
#define __IElementAdorner_FWD_DEFINED__
typedef interface IElementAdorner IElementAdorner;
#endif 	/* __IElementAdorner_FWD_DEFINED__ */


#ifndef __IHTMLEditingServices_FWD_DEFINED__
#define __IHTMLEditingServices_FWD_DEFINED__
typedef interface IHTMLEditingServices IHTMLEditingServices;
#endif 	/* __IHTMLEditingServices_FWD_DEFINED__ */


#ifndef __IEditDebugServices_FWD_DEFINED__
#define __IEditDebugServices_FWD_DEFINED__
typedef interface IEditDebugServices IEditDebugServices;
#endif 	/* __IEditDebugServices_FWD_DEFINED__ */


#ifndef __IPrivacyServices_FWD_DEFINED__
#define __IPrivacyServices_FWD_DEFINED__
typedef interface IPrivacyServices IPrivacyServices;
#endif 	/* __IPrivacyServices_FWD_DEFINED__ */


#ifndef __IHTMLOMWindowServices_FWD_DEFINED__
#define __IHTMLOMWindowServices_FWD_DEFINED__
typedef interface IHTMLOMWindowServices IHTMLOMWindowServices;
#endif 	/* __IHTMLOMWindowServices_FWD_DEFINED__ */


#ifndef __IHTMLFilterPainter_FWD_DEFINED__
#define __IHTMLFilterPainter_FWD_DEFINED__
typedef interface IHTMLFilterPainter IHTMLFilterPainter;
#endif 	/* __IHTMLFilterPainter_FWD_DEFINED__ */


#ifndef __IHTMLFilterPaintSite_FWD_DEFINED__
#define __IHTMLFilterPaintSite_FWD_DEFINED__
typedef interface IHTMLFilterPaintSite IHTMLFilterPaintSite;
#endif 	/* __IHTMLFilterPaintSite_FWD_DEFINED__ */


#ifndef __IElementNamespacePrivate_FWD_DEFINED__
#define __IElementNamespacePrivate_FWD_DEFINED__
typedef interface IElementNamespacePrivate IElementNamespacePrivate;
#endif 	/* __IElementNamespacePrivate_FWD_DEFINED__ */


/* header files for imported files */
#include "dimm.h"
#include "mshtml.h"
#include "mshtmhst.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_interned_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// internal.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// TRIDENT Editing Services Interfaces.
//

#ifndef INTERNAL_H_
#define INTERNAL_H_



extern RPC_IF_HANDLE __MIDL_itf_interned_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_interned_0000_v0_0_s_ifspec;


#ifndef __MSHTMLINTERNAL_LIBRARY_DEFINED__
#define __MSHTMLINTERNAL_LIBRARY_DEFINED__

/* library MSHTMLINTERNAL */
/* [uuid][version][helpstring][lcid] */ 

typedef 
enum _EDITOR_NOTIFICATION
    {	EDITOR_NOTIFY_TIMER_TICK	= 0,
	EDITOR_NOTIFY_DOC_ENDED	= 1,
	EDITOR_NOTIFY_DOC_CHANGED	= 2,
	EDITOR_NOTIFY_CARET_IN_CONTEXT	= 3,
	EDITOR_NOTIFY_EXIT_TREE	= 4,
	EDITOR_NOTIFY_LOSE_FOCUS_FRAME	= 5,
	EDITOR_NOTIFY_LOSE_FOCUS	= 6,
	EDITOR_NOTIFY_BEFORE_FOCUS	= 7,
	EDITOR_NOTIFY_YIELD_FOCUS	= 8,
	EDITOR_NOTIFY_EDITABLE_CHANGE	= 9,
	EDITOR_NOTIFY_BEGIN_SELECTION_UNDO	= 10,
	EDITOR_NOTIFY_ATTACH_WIN	= 11,
	EDITOR_NOTIFY_UPDATE_CARET	= 12,
	EDITOR_NOTIFY_BEFORE_CURRENCY_CHANGE	= 13,
	EDITOR_NOTIFY_SETTING_VIEW_LINK	= 14,
	EDITOR_NOTIFY_CONTAINER_ENDED	= 15,
	EDITOR_NOTIFICATION_Max	= 2147483647L
    } 	EDITOR_NOTIFICATION;

typedef 
enum _DOCNAVFLAGS
    {	DOCNAVFLAG_DOCNAVIGATE	= 1,
	DOCNAVFLAG_DONTUPDATETLOG	= 2,
	DOCNAVFLAG_HTTPERRORPAGE	= 4,
	DOCNAVFLAG_OPENINNEWWINDOW	= 8,
	DOCNAVFLAG_REFRESH	= 16,
	DOCNAVFLAGS_Max	= 2147483647L
    } 	DOCNAVFLAGS;

typedef 
enum _NAVIGATEEXOPTIONS
    {	NAVIGATEEX_NONE	= 0,
	NAVIGATEEX_DONTUPDATETRAVELLOG	= 1,
	NAVIGATEEXOPTIONS_Max	= 2147483647L
    } 	NAVIGATEEXOPTIONS;

typedef 
enum _CHAR_FORMAT_FAMILY
    {	CHAR_FORMAT_None	= 0,
	CHAR_FORMAT_FontStyle	= 1,
	CHAR_FORMAT_FontInfo	= 2,
	CHAR_FORMAT_FontName	= 4,
	CHAR_FORMAT_ColorInfo	= 8,
	CHAR_FORMAT_ParaFormat	= 16,
	CHAR_FORMAT_FAMILY_Max	= 2147483647L
    } 	CHAR_FORMAT_FAMILY;

typedef 
enum _LAYOUT_MOVE_UNIT
    {	LAYOUT_MOVE_UNIT_PreviousLine	= 1,
	LAYOUT_MOVE_UNIT_NextLine	= 2,
	LAYOUT_MOVE_UNIT_CurrentLineStart	= 3,
	LAYOUT_MOVE_UNIT_CurrentLineEnd	= 4,
	LAYOUT_MOVE_UNIT_NextLineStart	= 5,
	LAYOUT_MOVE_UNIT_PreviousLineEnd	= 6,
	LAYOUT_MOVE_UNIT_TopOfWindow	= 7,
	LAYOUT_MOVE_UNIT_BottomOfWindow	= 8,
	LAYOUT_MOVE_UNIT_OuterLineStart	= 9,
	LAYOUT_MOVE_UNIT_OuterLineEnd	= 10,
	LAYOUT_MOVE_UNIT_Max	= 2147483647L
    } 	LAYOUT_MOVE_UNIT;

typedef 
enum _CARET_GRAVITY
    {	CARET_GRAVITY_NoChange	= 0,
	CARET_GRAVITY_BeginningOfLine	= 1,
	CARET_GRAVITY_EndOfLine	= 2,
	CARET_GRAVITY_Max	= 2147483647L
    } 	CARET_GRAVITY;

typedef 
enum _CARET_VISIBILITY
    {	CARET_TYPE_Hide	= 0,
	CARET_TYPE_Show	= 1,
	CARET_VISIBILITY_Max	= 2147483647L
    } 	CARET_VISIBILITY;

typedef 
enum _POINTER_SCROLLPIN
    {	POINTER_SCROLLPIN_TopLeft	= 0,
	POINTER_SCROLLPIN_BottomRight	= 1,
	POINTER_SCROLLPIN_Minimal	= 2,
	POINTER_SCROLLPIN_Max	= 2147483647L
    } 	POINTER_SCROLLPIN;

typedef 
enum _ADORNER_HTI
    {	ADORNER_HTI_NONE	= 0,
	ADORNER_HTI_TOPBORDER	= 1,
	ADORNER_HTI_LEFTBORDER	= 2,
	ADORNER_HTI_BOTTOMBORDER	= 3,
	ADORNER_HTI_RIGHTBORDER	= 4,
	ADORNER_HTI_TOPLEFTHANDLE	= 5,
	ADORNER_HTI_LEFTHANDLE	= 6,
	ADORNER_HTI_TOPHANDLE	= 7,
	ADORNER_HTI_BOTTOMLEFTHANDLE	= 8,
	ADORNER_HTI_TOPRIGHTHANDLE	= 9,
	ADORNER_HTI_BOTTOMHANDLE	= 10,
	ADORNER_HTI_RIGHTHANDLE	= 11,
	ADORNER_HTI_BOTTOMRIGHTHANDLE	= 12,
	ADORNER_HTI_Max	= 2147483647L
    } 	ADORNER_HTI;

typedef 
enum _FILTER_DRAW_LAYERS
    {	FILTER_DRAW_BORDER	= 0x1,
	FILTER_DRAW_BACKGROUND	= 0x2,
	FILTER_DRAW_CONTENT	= 0x4,
	FILTER_DRAW_ALLLAYERS	= 0x7,
	FILTER_DRAW_LAYERS_Max	= 2147483647L
    } 	FILTER_DRAW_LAYERS;

typedef 
enum _FILTER_FLAGS
    {	FILTER_FLAGS_PAGETRANSITION	= 0x1,
	FILTER_FLAGS_Max	= 2147483647L
    } 	FILTER_FLAGS;

typedef struct _HTMLPtrDispInfoRec
    {
    DWORD dwSize;
    LONG lBaseline;
    LONG lXPosition;
    LONG lLineHeight;
    LONG lTextHeight;
    LONG lDescent;
    LONG lTextDescent;
    BOOL fRTLLine;
    BOOL fRTLFlow;
    BOOL fAligned;
    BOOL fHasNestedRunOwner;
    } 	HTMLPtrDispInfoRec;




EXTERN_C const IID LIBID_MSHTMLINTERNAL;

#ifndef __ISelectionObject2_INTERFACE_DEFINED__
#define __ISelectionObject2_INTERFACE_DEFINED__

/* interface ISelectionObject2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISelectionObject2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fc-98b5-11cf-bb82-00aa00bdce0b")
    ISelectionObject2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ ISegmentList *pISegmentList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPointerInSelection( 
            /* [in] */ IDisplayPointer *pIDispPointer,
            /* [out] */ BOOL *pfPointerInSelection,
            /* [in] */ POINT *pptGlobal,
            /* [in] */ IHTMLElement *pIElementOver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmptySelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyAllSelection( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionObject2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectionObject2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectionObject2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            ISelectionObject2 * This,
            /* [in] */ ISegmentList *pISegmentList);
        
        HRESULT ( STDMETHODCALLTYPE *IsPointerInSelection )( 
            ISelectionObject2 * This,
            /* [in] */ IDisplayPointer *pIDispPointer,
            /* [out] */ BOOL *pfPointerInSelection,
            /* [in] */ POINT *pptGlobal,
            /* [in] */ IHTMLElement *pIElementOver);
        
        HRESULT ( STDMETHODCALLTYPE *EmptySelection )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DestroySelection )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyAllSelection )( 
            ISelectionObject2 * This);
        
        END_INTERFACE
    } ISelectionObject2Vtbl;

    interface ISelectionObject2
    {
        CONST_VTBL struct ISelectionObject2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionObject2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISelectionObject2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISelectionObject2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISelectionObject2_Select(This,pISegmentList)	\
    (This)->lpVtbl -> Select(This,pISegmentList)

#define ISelectionObject2_IsPointerInSelection(This,pIDispPointer,pfPointerInSelection,pptGlobal,pIElementOver)	\
    (This)->lpVtbl -> IsPointerInSelection(This,pIDispPointer,pfPointerInSelection,pptGlobal,pIElementOver)

#define ISelectionObject2_EmptySelection(This)	\
    (This)->lpVtbl -> EmptySelection(This)

#define ISelectionObject2_DestroySelection(This)	\
    (This)->lpVtbl -> DestroySelection(This)

#define ISelectionObject2_DestroyAllSelection(This)	\
    (This)->lpVtbl -> DestroyAllSelection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISelectionObject2_Select_Proxy( 
    ISelectionObject2 * This,
    /* [in] */ ISegmentList *pISegmentList);


void __RPC_STUB ISelectionObject2_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject2_IsPointerInSelection_Proxy( 
    ISelectionObject2 * This,
    /* [in] */ IDisplayPointer *pIDispPointer,
    /* [out] */ BOOL *pfPointerInSelection,
    /* [in] */ POINT *pptGlobal,
    /* [in] */ IHTMLElement *pIElementOver);


void __RPC_STUB ISelectionObject2_IsPointerInSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject2_EmptySelection_Proxy( 
    ISelectionObject2 * This);


void __RPC_STUB ISelectionObject2_EmptySelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject2_DestroySelection_Proxy( 
    ISelectionObject2 * This);


void __RPC_STUB ISelectionObject2_DestroySelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject2_DestroyAllSelection_Proxy( 
    ISelectionObject2 * This);


void __RPC_STUB ISelectionObject2_DestroyAllSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISelectionObject2_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditor_INTERFACE_DEFINED__
#define __IHTMLEditor_INTERFACE_DEFINED__

/* interface IHTMLEditor */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fa-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PreHandleEvent( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostHandleEvent( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pIDocument,
            /* [in] */ IUnknown *pIContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ EDITOR_NOTIFICATION eSelectionNotification,
            /* [in] */ IUnknown *pUnknown,
            /* [in] */ DWORD dword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommandTarget( 
            /* [in] */ IUnknown *pContext,
            /* [out][in] */ IUnknown **ppUnkTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementToTabFrom( 
            /* [in] */ BOOL fForward,
            /* [out][in] */ IHTMLElement **ppElement,
            /* [out][in] */ BOOL *pfFindNext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEditContextUIActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateIMEComposition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreHandleEvent )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *PostHandleEvent )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IHTMLEditor * This,
            /* [in] */ IUnknown *pIDocument,
            /* [in] */ IUnknown *pIContainer);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IHTMLEditor * This,
            /* [in] */ EDITOR_NOTIFICATION eSelectionNotification,
            /* [in] */ IUnknown *pUnknown,
            /* [in] */ DWORD dword);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandTarget )( 
            IHTMLEditor * This,
            /* [in] */ IUnknown *pContext,
            /* [out][in] */ IUnknown **ppUnkTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementToTabFrom )( 
            IHTMLEditor * This,
            /* [in] */ BOOL fForward,
            /* [out][in] */ IHTMLElement **ppElement,
            /* [out][in] */ BOOL *pfFindNext);
        
        HRESULT ( STDMETHODCALLTYPE *IsEditContextUIActive )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateIMEComposition )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IHTMLEditor * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IHTMLEditorVtbl;

    interface IHTMLEditor
    {
        CONST_VTBL struct IHTMLEditorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditor_PreHandleEvent(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> PreHandleEvent(This,inEvtDispId,pIEventObj)

#define IHTMLEditor_PostHandleEvent(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> PostHandleEvent(This,inEvtDispId,pIEventObj)

#define IHTMLEditor_TranslateAccelerator(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> TranslateAccelerator(This,inEvtDispId,pIEventObj)

#define IHTMLEditor_Initialize(This,pIDocument,pIContainer)	\
    (This)->lpVtbl -> Initialize(This,pIDocument,pIContainer)

#define IHTMLEditor_Notify(This,eSelectionNotification,pUnknown,dword)	\
    (This)->lpVtbl -> Notify(This,eSelectionNotification,pUnknown,dword)

#define IHTMLEditor_GetCommandTarget(This,pContext,ppUnkTarget)	\
    (This)->lpVtbl -> GetCommandTarget(This,pContext,ppUnkTarget)

#define IHTMLEditor_GetElementToTabFrom(This,fForward,ppElement,pfFindNext)	\
    (This)->lpVtbl -> GetElementToTabFrom(This,fForward,ppElement,pfFindNext)

#define IHTMLEditor_IsEditContextUIActive(This)	\
    (This)->lpVtbl -> IsEditContextUIActive(This)

#define IHTMLEditor_TerminateIMEComposition(This)	\
    (This)->lpVtbl -> TerminateIMEComposition(This)

#define IHTMLEditor_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditor_PreHandleEvent_Proxy( 
    IHTMLEditor * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditor_PreHandleEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_PostHandleEvent_Proxy( 
    IHTMLEditor * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditor_PostHandleEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_TranslateAccelerator_Proxy( 
    IHTMLEditor * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditor_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_Initialize_Proxy( 
    IHTMLEditor * This,
    /* [in] */ IUnknown *pIDocument,
    /* [in] */ IUnknown *pIContainer);


void __RPC_STUB IHTMLEditor_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_Notify_Proxy( 
    IHTMLEditor * This,
    /* [in] */ EDITOR_NOTIFICATION eSelectionNotification,
    /* [in] */ IUnknown *pUnknown,
    /* [in] */ DWORD dword);


void __RPC_STUB IHTMLEditor_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_GetCommandTarget_Proxy( 
    IHTMLEditor * This,
    /* [in] */ IUnknown *pContext,
    /* [out][in] */ IUnknown **ppUnkTarget);


void __RPC_STUB IHTMLEditor_GetCommandTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_GetElementToTabFrom_Proxy( 
    IHTMLEditor * This,
    /* [in] */ BOOL fForward,
    /* [out][in] */ IHTMLElement **ppElement,
    /* [out][in] */ BOOL *pfFindNext);


void __RPC_STUB IHTMLEditor_GetElementToTabFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_IsEditContextUIActive_Proxy( 
    IHTMLEditor * This);


void __RPC_STUB IHTMLEditor_IsEditContextUIActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_TerminateIMEComposition_Proxy( 
    IHTMLEditor * This);


void __RPC_STUB IHTMLEditor_TerminateIMEComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_EnableModeless_Proxy( 
    IHTMLEditor * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IHTMLEditor_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditor_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6dc-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SuperNavigate( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPendingUrl( 
            /* [out] */ LPOLESTR *pstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPICSTarget( 
            /* [in] */ IOleCommandTarget *pctPICS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PICSComplete( 
            /* [in] */ BOOL fApproved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindWindowByName( 
            /* [in] */ LPCOLESTR pstrTargeName,
            /* [out] */ IHTMLWindow2 **ppWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressBarUrl( 
            /* [out] */ BSTR *pbstrURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuperNavigate )( 
            IHTMLPrivateWindow * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPendingUrl )( 
            IHTMLPrivateWindow * This,
            /* [out] */ LPOLESTR *pstrURL);
        
        HRESULT ( STDMETHODCALLTYPE *SetPICSTarget )( 
            IHTMLPrivateWindow * This,
            /* [in] */ IOleCommandTarget *pctPICS);
        
        HRESULT ( STDMETHODCALLTYPE *PICSComplete )( 
            IHTMLPrivateWindow * This,
            /* [in] */ BOOL fApproved);
        
        HRESULT ( STDMETHODCALLTYPE *FindWindowByName )( 
            IHTMLPrivateWindow * This,
            /* [in] */ LPCOLESTR pstrTargeName,
            /* [out] */ IHTMLWindow2 **ppWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressBarUrl )( 
            IHTMLPrivateWindow * This,
            /* [out] */ BSTR *pbstrURL);
        
        END_INTERFACE
    } IHTMLPrivateWindowVtbl;

    interface IHTMLPrivateWindow
    {
        CONST_VTBL struct IHTMLPrivateWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPrivateWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPrivateWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPrivateWindow_SuperNavigate(This,bstrURL,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags)	\
    (This)->lpVtbl -> SuperNavigate(This,bstrURL,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags)

#define IHTMLPrivateWindow_GetPendingUrl(This,pstrURL)	\
    (This)->lpVtbl -> GetPendingUrl(This,pstrURL)

#define IHTMLPrivateWindow_SetPICSTarget(This,pctPICS)	\
    (This)->lpVtbl -> SetPICSTarget(This,pctPICS)

#define IHTMLPrivateWindow_PICSComplete(This,fApproved)	\
    (This)->lpVtbl -> PICSComplete(This,fApproved)

#define IHTMLPrivateWindow_FindWindowByName(This,pstrTargeName,ppWindow)	\
    (This)->lpVtbl -> FindWindowByName(This,pstrTargeName,ppWindow)

#define IHTMLPrivateWindow_GetAddressBarUrl(This,pbstrURL)	\
    (This)->lpVtbl -> GetAddressBarUrl(This,pbstrURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_SuperNavigate_Proxy( 
    IHTMLPrivateWindow * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ BSTR bstrShortcut,
    /* [in] */ BSTR bstrFrameName,
    /* [in] */ VARIANT *pvarPostData,
    /* [in] */ VARIANT *pvarHeaders,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IHTMLPrivateWindow_SuperNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_GetPendingUrl_Proxy( 
    IHTMLPrivateWindow * This,
    /* [out] */ LPOLESTR *pstrURL);


void __RPC_STUB IHTMLPrivateWindow_GetPendingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_SetPICSTarget_Proxy( 
    IHTMLPrivateWindow * This,
    /* [in] */ IOleCommandTarget *pctPICS);


void __RPC_STUB IHTMLPrivateWindow_SetPICSTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_PICSComplete_Proxy( 
    IHTMLPrivateWindow * This,
    /* [in] */ BOOL fApproved);


void __RPC_STUB IHTMLPrivateWindow_PICSComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_FindWindowByName_Proxy( 
    IHTMLPrivateWindow * This,
    /* [in] */ LPCOLESTR pstrTargeName,
    /* [out] */ IHTMLWindow2 **ppWindow);


void __RPC_STUB IHTMLPrivateWindow_FindWindowByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_GetAddressBarUrl_Proxy( 
    IHTMLPrivateWindow * This,
    /* [out] */ BSTR *pbstrURL);


void __RPC_STUB IHTMLPrivateWindow_GetAddressBarUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPrivateWindow_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow2_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow2_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7e5-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NavigateEx( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrUnencodedUrl,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInnerWindowUnknown( 
            /* [out][in] */ IUnknown **ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindow2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateEx )( 
            IHTMLPrivateWindow2 * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrUnencodedUrl,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerWindowUnknown )( 
            IHTMLPrivateWindow2 * This,
            /* [out][in] */ IUnknown **ppUnknown);
        
        END_INTERFACE
    } IHTMLPrivateWindow2Vtbl;

    interface IHTMLPrivateWindow2
    {
        CONST_VTBL struct IHTMLPrivateWindow2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPrivateWindow2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPrivateWindow2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPrivateWindow2_NavigateEx(This,bstrURL,bstrUnencodedUrl,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags)	\
    (This)->lpVtbl -> NavigateEx(This,bstrURL,bstrUnencodedUrl,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags)

#define IHTMLPrivateWindow2_GetInnerWindowUnknown(This,ppUnknown)	\
    (This)->lpVtbl -> GetInnerWindowUnknown(This,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow2_NavigateEx_Proxy( 
    IHTMLPrivateWindow2 * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ BSTR bstrUnencodedUrl,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ BSTR bstrContext,
    /* [in] */ IBindCtx *pBindCtx,
    /* [in] */ DWORD dwNavOptions,
    /* [in] */ DWORD dwFHLFlags);


void __RPC_STUB IHTMLPrivateWindow2_NavigateEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow2_GetInnerWindowUnknown_Proxy( 
    IHTMLPrivateWindow2 * This,
    /* [out][in] */ IUnknown **ppUnknown);


void __RPC_STUB IHTMLPrivateWindow2_GetInnerWindowUnknown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPrivateWindow2_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow3_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow3_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow3 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f840-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow3 : public IHTMLPrivateWindow2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenEx( 
            /* [in] */ BSTR url,
            /* [in] */ BSTR urlContext,
            /* [in] */ BSTR name,
            /* [in] */ BSTR features,
            /* [in] */ VARIANT_BOOL replace,
            /* [out] */ IHTMLWindow2 **pomWindowResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindow3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateEx )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrUnencodedUrl,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerWindowUnknown )( 
            IHTMLPrivateWindow3 * This,
            /* [out][in] */ IUnknown **ppUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *OpenEx )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ BSTR url,
            /* [in] */ BSTR urlContext,
            /* [in] */ BSTR name,
            /* [in] */ BSTR features,
            /* [in] */ VARIANT_BOOL replace,
            /* [out] */ IHTMLWindow2 **pomWindowResult);
        
        END_INTERFACE
    } IHTMLPrivateWindow3Vtbl;

    interface IHTMLPrivateWindow3
    {
        CONST_VTBL struct IHTMLPrivateWindow3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPrivateWindow3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPrivateWindow3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPrivateWindow3_NavigateEx(This,bstrURL,bstrUnencodedUrl,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags)	\
    (This)->lpVtbl -> NavigateEx(This,bstrURL,bstrUnencodedUrl,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags)

#define IHTMLPrivateWindow3_GetInnerWindowUnknown(This,ppUnknown)	\
    (This)->lpVtbl -> GetInnerWindowUnknown(This,ppUnknown)


#define IHTMLPrivateWindow3_OpenEx(This,url,urlContext,name,features,replace,pomWindowResult)	\
    (This)->lpVtbl -> OpenEx(This,url,urlContext,name,features,replace,pomWindowResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow3_OpenEx_Proxy( 
    IHTMLPrivateWindow3 * This,
    /* [in] */ BSTR url,
    /* [in] */ BSTR urlContext,
    /* [in] */ BSTR name,
    /* [in] */ BSTR features,
    /* [in] */ VARIANT_BOOL replace,
    /* [out] */ IHTMLWindow2 **pomWindowResult);


void __RPC_STUB IHTMLPrivateWindow3_OpenEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPrivateWindow3_INTERFACE_DEFINED__ */


#ifndef __ISubDivisionProvider_INTERFACE_DEFINED__
#define __ISubDivisionProvider_INTERFACE_DEFINED__

/* interface ISubDivisionProvider */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISubDivisionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4d2-98b5-11cf-bb82-00aa00bdce0b")
    ISubDivisionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionCount( 
            /* [out][retval] */ LONG *pcSubDivision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionTabs( 
            /* [in] */ LONG cTabs,
            /* [out][retval] */ LONG *pSubDivisionTabs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubDivisionFromPt( 
            /* [in] */ POINT pt,
            /* [out][retval] */ LONG *piSubDivision) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISubDivisionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISubDivisionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISubDivisionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISubDivisionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionCount )( 
            ISubDivisionProvider * This,
            /* [out][retval] */ LONG *pcSubDivision);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionTabs )( 
            ISubDivisionProvider * This,
            /* [in] */ LONG cTabs,
            /* [out][retval] */ LONG *pSubDivisionTabs);
        
        HRESULT ( STDMETHODCALLTYPE *SubDivisionFromPt )( 
            ISubDivisionProvider * This,
            /* [in] */ POINT pt,
            /* [out][retval] */ LONG *piSubDivision);
        
        END_INTERFACE
    } ISubDivisionProviderVtbl;

    interface ISubDivisionProvider
    {
        CONST_VTBL struct ISubDivisionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISubDivisionProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISubDivisionProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISubDivisionProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISubDivisionProvider_GetSubDivisionCount(This,pcSubDivision)	\
    (This)->lpVtbl -> GetSubDivisionCount(This,pcSubDivision)

#define ISubDivisionProvider_GetSubDivisionTabs(This,cTabs,pSubDivisionTabs)	\
    (This)->lpVtbl -> GetSubDivisionTabs(This,cTabs,pSubDivisionTabs)

#define ISubDivisionProvider_SubDivisionFromPt(This,pt,piSubDivision)	\
    (This)->lpVtbl -> SubDivisionFromPt(This,pt,piSubDivision)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISubDivisionProvider_GetSubDivisionCount_Proxy( 
    ISubDivisionProvider * This,
    /* [out][retval] */ LONG *pcSubDivision);


void __RPC_STUB ISubDivisionProvider_GetSubDivisionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISubDivisionProvider_GetSubDivisionTabs_Proxy( 
    ISubDivisionProvider * This,
    /* [in] */ LONG cTabs,
    /* [out][retval] */ LONG *pSubDivisionTabs);


void __RPC_STUB ISubDivisionProvider_GetSubDivisionTabs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISubDivisionProvider_SubDivisionFromPt_Proxy( 
    ISubDivisionProvider * This,
    /* [in] */ POINT pt,
    /* [out][retval] */ LONG *piSubDivision);


void __RPC_STUB ISubDivisionProvider_SubDivisionFromPt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISubDivisionProvider_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorUI_INTERFACE_DEFINED__
#define __IElementBehaviorUI_INTERFACE_DEFINED__

/* interface IElementBehaviorUI */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4bf-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnReceiveFocus( 
            /* [in] */ BOOL fFocus,
            /* [in] */ LONG lSubDivision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionProvider( 
            /* [out][retval] */ ISubDivisionProvider **ppProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanTakeFocus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorUI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnReceiveFocus )( 
            IElementBehaviorUI * This,
            /* [in] */ BOOL fFocus,
            /* [in] */ LONG lSubDivision);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionProvider )( 
            IElementBehaviorUI * This,
            /* [out][retval] */ ISubDivisionProvider **ppProvider);
        
        HRESULT ( STDMETHODCALLTYPE *CanTakeFocus )( 
            IElementBehaviorUI * This);
        
        END_INTERFACE
    } IElementBehaviorUIVtbl;

    interface IElementBehaviorUI
    {
        CONST_VTBL struct IElementBehaviorUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorUI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorUI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorUI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorUI_OnReceiveFocus(This,fFocus,lSubDivision)	\
    (This)->lpVtbl -> OnReceiveFocus(This,fFocus,lSubDivision)

#define IElementBehaviorUI_GetSubDivisionProvider(This,ppProvider)	\
    (This)->lpVtbl -> GetSubDivisionProvider(This,ppProvider)

#define IElementBehaviorUI_CanTakeFocus(This)	\
    (This)->lpVtbl -> CanTakeFocus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorUI_OnReceiveFocus_Proxy( 
    IElementBehaviorUI * This,
    /* [in] */ BOOL fFocus,
    /* [in] */ LONG lSubDivision);


void __RPC_STUB IElementBehaviorUI_OnReceiveFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorUI_GetSubDivisionProvider_Proxy( 
    IElementBehaviorUI * This,
    /* [out][retval] */ ISubDivisionProvider **ppProvider);


void __RPC_STUB IElementBehaviorUI_GetSubDivisionProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorUI_CanTakeFocus_Proxy( 
    IElementBehaviorUI * This);


void __RPC_STUB IElementBehaviorUI_CanTakeFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorUI_INTERFACE_DEFINED__ */


#ifndef __IElementAdorner_INTERFACE_DEFINED__
#define __IElementAdorner_INTERFACE_DEFINED__

/* interface IElementAdorner */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementAdorner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f607-98b5-11cf-bb82-00aa00bdce0b")
    IElementAdorner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTestPoint( 
            /* [in] */ POINT *pt,
            /* [in] */ LPRECT prc,
            /* [out][in] */ BOOL *fResult,
            /* [out][in] */ ADORNER_HTI *peAdornerHTI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [in] */ SIZE *pSizeElem,
            /* [in] */ SIZE *pSizeAdorn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPosition( 
            /* [in] */ POINT *pPosElem,
            /* [in] */ POINT *pPosAdorn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPositionSet( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementAdornerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementAdorner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementAdorner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementAdorner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IElementAdorner * This,
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prc);
        
        HRESULT ( STDMETHODCALLTYPE *HitTestPoint )( 
            IElementAdorner * This,
            /* [in] */ POINT *pt,
            /* [in] */ LPRECT prc,
            /* [out][in] */ BOOL *fResult,
            /* [out][in] */ ADORNER_HTI *peAdornerHTI);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IElementAdorner * This,
            /* [in] */ SIZE *pSizeElem,
            /* [in] */ SIZE *pSizeAdorn);
        
        HRESULT ( STDMETHODCALLTYPE *GetPosition )( 
            IElementAdorner * This,
            /* [in] */ POINT *pPosElem,
            /* [in] */ POINT *pPosAdorn);
        
        HRESULT ( STDMETHODCALLTYPE *OnPositionSet )( 
            IElementAdorner * This);
        
        END_INTERFACE
    } IElementAdornerVtbl;

    interface IElementAdorner
    {
        CONST_VTBL struct IElementAdornerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementAdorner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementAdorner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementAdorner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementAdorner_Draw(This,hdc,prc)	\
    (This)->lpVtbl -> Draw(This,hdc,prc)

#define IElementAdorner_HitTestPoint(This,pt,prc,fResult,peAdornerHTI)	\
    (This)->lpVtbl -> HitTestPoint(This,pt,prc,fResult,peAdornerHTI)

#define IElementAdorner_GetSize(This,pSizeElem,pSizeAdorn)	\
    (This)->lpVtbl -> GetSize(This,pSizeElem,pSizeAdorn)

#define IElementAdorner_GetPosition(This,pPosElem,pPosAdorn)	\
    (This)->lpVtbl -> GetPosition(This,pPosElem,pPosAdorn)

#define IElementAdorner_OnPositionSet(This)	\
    (This)->lpVtbl -> OnPositionSet(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementAdorner_Draw_Proxy( 
    IElementAdorner * This,
    /* [in] */ HDC hdc,
    /* [in] */ LPRECT prc);


void __RPC_STUB IElementAdorner_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementAdorner_HitTestPoint_Proxy( 
    IElementAdorner * This,
    /* [in] */ POINT *pt,
    /* [in] */ LPRECT prc,
    /* [out][in] */ BOOL *fResult,
    /* [out][in] */ ADORNER_HTI *peAdornerHTI);


void __RPC_STUB IElementAdorner_HitTestPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementAdorner_GetSize_Proxy( 
    IElementAdorner * This,
    /* [in] */ SIZE *pSizeElem,
    /* [in] */ SIZE *pSizeAdorn);


void __RPC_STUB IElementAdorner_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementAdorner_GetPosition_Proxy( 
    IElementAdorner * This,
    /* [in] */ POINT *pPosElem,
    /* [in] */ POINT *pPosAdorn);


void __RPC_STUB IElementAdorner_GetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementAdorner_OnPositionSet_Proxy( 
    IElementAdorner * This);


void __RPC_STUB IElementAdorner_OnPositionSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementAdorner_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditingServices_INTERFACE_DEFINED__
#define __IHTMLEditingServices_INTERFACE_DEFINED__

/* interface IHTMLEditingServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditingServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fb-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditingServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BOOL fAdjustPointers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Paste( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BSTR bstrText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PasteFromClipboard( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ IDataObject *pDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LaunderSpaces( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSanitizedText( 
            /* [in] */ IMarkupPointer *InsertHere,
            /* [in] */ OLECHAR *pstrText,
            /* [in] */ LONG cChInput,
            /* [in] */ BOOL fDataBinding) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UrlAutoDetectCurrentWord( 
            /* [in] */ IMarkupPointer *pWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UrlAutoDetectRange( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShouldUpdateAnchorText( 
            /* [in] */ OLECHAR *pstrHref,
            /* [in] */ OLECHAR *pstrAnchorText,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdjustPointerForInsert( 
            /* [in] */ IDisplayPointer *pDispWhereIThinkIAm,
            /* [in] */ BOOL fFurtherInDocument,
            /* [in] */ IMarkupPointer *pConstraintStart,
            /* [in] */ IMarkupPointer *pConstraintEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindSiteSelectableElement( 
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerEnd,
            /* [in] */ IHTMLElement **ppIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementSiteSelectable( 
            /* [in] */ IHTMLElement *pIHTMLElement,
            /* [out] */ IHTMLElement **ppIElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementUIActivatable( 
            /* [in] */ IHTMLElement *pIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementAtomic( 
            /* [in] */ IHTMLElement *pIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PositionPointersInMaster( 
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ IMarkupPointer *pIStart,
            /* [in] */ IMarkupPointer *pIEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditingServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditingServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditingServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditingServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BOOL fAdjustPointers);
        
        HRESULT ( STDMETHODCALLTYPE *Paste )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BSTR bstrText);
        
        HRESULT ( STDMETHODCALLTYPE *PasteFromClipboard )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ IDataObject *pDO);
        
        HRESULT ( STDMETHODCALLTYPE *LaunderSpaces )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSanitizedText )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *InsertHere,
            /* [in] */ OLECHAR *pstrText,
            /* [in] */ LONG cChInput,
            /* [in] */ BOOL fDataBinding);
        
        HRESULT ( STDMETHODCALLTYPE *UrlAutoDetectCurrentWord )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pWord);
        
        HRESULT ( STDMETHODCALLTYPE *UrlAutoDetectRange )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldUpdateAnchorText )( 
            IHTMLEditingServices * This,
            /* [in] */ OLECHAR *pstrHref,
            /* [in] */ OLECHAR *pstrAnchorText,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustPointerForInsert )( 
            IHTMLEditingServices * This,
            /* [in] */ IDisplayPointer *pDispWhereIThinkIAm,
            /* [in] */ BOOL fFurtherInDocument,
            /* [in] */ IMarkupPointer *pConstraintStart,
            /* [in] */ IMarkupPointer *pConstraintEnd);
        
        HRESULT ( STDMETHODCALLTYPE *FindSiteSelectableElement )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerEnd,
            /* [in] */ IHTMLElement **ppIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementSiteSelectable )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement,
            /* [out] */ IHTMLElement **ppIElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementUIActivatable )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementAtomic )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *PositionPointersInMaster )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ IMarkupPointer *pIStart,
            /* [in] */ IMarkupPointer *pIEnd);
        
        END_INTERFACE
    } IHTMLEditingServicesVtbl;

    interface IHTMLEditingServices
    {
        CONST_VTBL struct IHTMLEditingServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditingServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditingServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditingServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditingServices_Delete(This,pStart,pEnd,fAdjustPointers)	\
    (This)->lpVtbl -> Delete(This,pStart,pEnd,fAdjustPointers)

#define IHTMLEditingServices_Paste(This,pStart,pEnd,bstrText)	\
    (This)->lpVtbl -> Paste(This,pStart,pEnd,bstrText)

#define IHTMLEditingServices_PasteFromClipboard(This,pStart,pEnd,pDO)	\
    (This)->lpVtbl -> PasteFromClipboard(This,pStart,pEnd,pDO)

#define IHTMLEditingServices_LaunderSpaces(This,pStart,pEnd)	\
    (This)->lpVtbl -> LaunderSpaces(This,pStart,pEnd)

#define IHTMLEditingServices_InsertSanitizedText(This,InsertHere,pstrText,cChInput,fDataBinding)	\
    (This)->lpVtbl -> InsertSanitizedText(This,InsertHere,pstrText,cChInput,fDataBinding)

#define IHTMLEditingServices_UrlAutoDetectCurrentWord(This,pWord)	\
    (This)->lpVtbl -> UrlAutoDetectCurrentWord(This,pWord)

#define IHTMLEditingServices_UrlAutoDetectRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> UrlAutoDetectRange(This,pStart,pEnd)

#define IHTMLEditingServices_ShouldUpdateAnchorText(This,pstrHref,pstrAnchorText,pfResult)	\
    (This)->lpVtbl -> ShouldUpdateAnchorText(This,pstrHref,pstrAnchorText,pfResult)

#define IHTMLEditingServices_AdjustPointerForInsert(This,pDispWhereIThinkIAm,fFurtherInDocument,pConstraintStart,pConstraintEnd)	\
    (This)->lpVtbl -> AdjustPointerForInsert(This,pDispWhereIThinkIAm,fFurtherInDocument,pConstraintStart,pConstraintEnd)

#define IHTMLEditingServices_FindSiteSelectableElement(This,pPointerStart,pPointerEnd,ppIHTMLElement)	\
    (This)->lpVtbl -> FindSiteSelectableElement(This,pPointerStart,pPointerEnd,ppIHTMLElement)

#define IHTMLEditingServices_IsElementSiteSelectable(This,pIHTMLElement,ppIElement)	\
    (This)->lpVtbl -> IsElementSiteSelectable(This,pIHTMLElement,ppIElement)

#define IHTMLEditingServices_IsElementUIActivatable(This,pIHTMLElement)	\
    (This)->lpVtbl -> IsElementUIActivatable(This,pIHTMLElement)

#define IHTMLEditingServices_IsElementAtomic(This,pIHTMLElement)	\
    (This)->lpVtbl -> IsElementAtomic(This,pIHTMLElement)

#define IHTMLEditingServices_PositionPointersInMaster(This,pIElement,pIStart,pIEnd)	\
    (This)->lpVtbl -> PositionPointersInMaster(This,pIElement,pIStart,pIEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditingServices_Delete_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd,
    /* [in] */ BOOL fAdjustPointers);


void __RPC_STUB IHTMLEditingServices_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_Paste_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd,
    /* [in] */ BSTR bstrText);


void __RPC_STUB IHTMLEditingServices_Paste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_PasteFromClipboard_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd,
    /* [in] */ IDataObject *pDO);


void __RPC_STUB IHTMLEditingServices_PasteFromClipboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_LaunderSpaces_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd);


void __RPC_STUB IHTMLEditingServices_LaunderSpaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_InsertSanitizedText_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *InsertHere,
    /* [in] */ OLECHAR *pstrText,
    /* [in] */ LONG cChInput,
    /* [in] */ BOOL fDataBinding);


void __RPC_STUB IHTMLEditingServices_InsertSanitizedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_UrlAutoDetectCurrentWord_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pWord);


void __RPC_STUB IHTMLEditingServices_UrlAutoDetectCurrentWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_UrlAutoDetectRange_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd);


void __RPC_STUB IHTMLEditingServices_UrlAutoDetectRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_ShouldUpdateAnchorText_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ OLECHAR *pstrHref,
    /* [in] */ OLECHAR *pstrAnchorText,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB IHTMLEditingServices_ShouldUpdateAnchorText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_AdjustPointerForInsert_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IDisplayPointer *pDispWhereIThinkIAm,
    /* [in] */ BOOL fFurtherInDocument,
    /* [in] */ IMarkupPointer *pConstraintStart,
    /* [in] */ IMarkupPointer *pConstraintEnd);


void __RPC_STUB IHTMLEditingServices_AdjustPointerForInsert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_FindSiteSelectableElement_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerEnd,
    /* [in] */ IHTMLElement **ppIHTMLElement);


void __RPC_STUB IHTMLEditingServices_FindSiteSelectableElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_IsElementSiteSelectable_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IHTMLElement *pIHTMLElement,
    /* [out] */ IHTMLElement **ppIElement);


void __RPC_STUB IHTMLEditingServices_IsElementSiteSelectable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_IsElementUIActivatable_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IHTMLElement *pIHTMLElement);


void __RPC_STUB IHTMLEditingServices_IsElementUIActivatable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_IsElementAtomic_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IHTMLElement *pIHTMLElement);


void __RPC_STUB IHTMLEditingServices_IsElementAtomic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_PositionPointersInMaster_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [in] */ IMarkupPointer *pIStart,
    /* [in] */ IMarkupPointer *pIEnd);


void __RPC_STUB IHTMLEditingServices_PositionPointersInMaster_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditingServices_INTERFACE_DEFINED__ */


#ifndef __IEditDebugServices_INTERFACE_DEFINED__
#define __IEditDebugServices_INTERFACE_DEFINED__

/* interface IEditDebugServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IEditDebugServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f60b-98b5-11cf-bb82-00aa00bdce0b")
    IEditDebugServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCp( 
            /* [in] */ IMarkupPointer *pIPointer,
            /* [out] */ long *pcp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugName( 
            /* [in] */ IMarkupPointer *pIPointer,
            /* [in] */ LPCTSTR strDbgName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayPointerDebugName( 
            /* [in] */ IDisplayPointer *pDispPointer,
            /* [in] */ LPCTSTR strDbgName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DumpTree( 
            /* [in] */ IMarkupPointer *pIPointer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LinesInElement( 
            /* [in] */ IHTMLElement *pIElement,
            /* [out] */ long *piLines) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FontsOnLine( 
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ long iLine,
            /* [out] */ BSTR *pbstrFonts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPixel( 
            /* [in] */ long X,
            /* [in] */ long Y,
            /* [out] */ long *piColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingBckgrnRecalc( 
            /* [out] */ BOOL *pfUsingBckgrnRecalc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEncodingAutoSelect( 
            /* [out] */ BOOL *pfEncodingAutoSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableEncodingAutoSelect( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingTableIncRecalc( 
            /* [out] */ BOOL *pfUsingTableIncRecalc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEditDebugServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEditDebugServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEditDebugServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEditDebugServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCp )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer,
            /* [out] */ long *pcp);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugName )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer,
            /* [in] */ LPCTSTR strDbgName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayPointerDebugName )( 
            IEditDebugServices * This,
            /* [in] */ IDisplayPointer *pDispPointer,
            /* [in] */ LPCTSTR strDbgName);
        
        HRESULT ( STDMETHODCALLTYPE *DumpTree )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer);
        
        HRESULT ( STDMETHODCALLTYPE *LinesInElement )( 
            IEditDebugServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [out] */ long *piLines);
        
        HRESULT ( STDMETHODCALLTYPE *FontsOnLine )( 
            IEditDebugServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ long iLine,
            /* [out] */ BSTR *pbstrFonts);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixel )( 
            IEditDebugServices * This,
            /* [in] */ long X,
            /* [in] */ long Y,
            /* [out] */ long *piColor);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingBckgrnRecalc )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfUsingBckgrnRecalc);
        
        HRESULT ( STDMETHODCALLTYPE *IsEncodingAutoSelect )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfEncodingAutoSelect);
        
        HRESULT ( STDMETHODCALLTYPE *EnableEncodingAutoSelect )( 
            IEditDebugServices * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTableIncRecalc )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfUsingTableIncRecalc);
        
        END_INTERFACE
    } IEditDebugServicesVtbl;

    interface IEditDebugServices
    {
        CONST_VTBL struct IEditDebugServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEditDebugServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEditDebugServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEditDebugServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEditDebugServices_GetCp(This,pIPointer,pcp)	\
    (This)->lpVtbl -> GetCp(This,pIPointer,pcp)

#define IEditDebugServices_SetDebugName(This,pIPointer,strDbgName)	\
    (This)->lpVtbl -> SetDebugName(This,pIPointer,strDbgName)

#define IEditDebugServices_SetDisplayPointerDebugName(This,pDispPointer,strDbgName)	\
    (This)->lpVtbl -> SetDisplayPointerDebugName(This,pDispPointer,strDbgName)

#define IEditDebugServices_DumpTree(This,pIPointer)	\
    (This)->lpVtbl -> DumpTree(This,pIPointer)

#define IEditDebugServices_LinesInElement(This,pIElement,piLines)	\
    (This)->lpVtbl -> LinesInElement(This,pIElement,piLines)

#define IEditDebugServices_FontsOnLine(This,pIElement,iLine,pbstrFonts)	\
    (This)->lpVtbl -> FontsOnLine(This,pIElement,iLine,pbstrFonts)

#define IEditDebugServices_GetPixel(This,X,Y,piColor)	\
    (This)->lpVtbl -> GetPixel(This,X,Y,piColor)

#define IEditDebugServices_IsUsingBckgrnRecalc(This,pfUsingBckgrnRecalc)	\
    (This)->lpVtbl -> IsUsingBckgrnRecalc(This,pfUsingBckgrnRecalc)

#define IEditDebugServices_IsEncodingAutoSelect(This,pfEncodingAutoSelect)	\
    (This)->lpVtbl -> IsEncodingAutoSelect(This,pfEncodingAutoSelect)

#define IEditDebugServices_EnableEncodingAutoSelect(This,fEnable)	\
    (This)->lpVtbl -> EnableEncodingAutoSelect(This,fEnable)

#define IEditDebugServices_IsUsingTableIncRecalc(This,pfUsingTableIncRecalc)	\
    (This)->lpVtbl -> IsUsingTableIncRecalc(This,pfUsingTableIncRecalc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEditDebugServices_GetCp_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IMarkupPointer *pIPointer,
    /* [out] */ long *pcp);


void __RPC_STUB IEditDebugServices_GetCp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_SetDebugName_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IMarkupPointer *pIPointer,
    /* [in] */ LPCTSTR strDbgName);


void __RPC_STUB IEditDebugServices_SetDebugName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_SetDisplayPointerDebugName_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IDisplayPointer *pDispPointer,
    /* [in] */ LPCTSTR strDbgName);


void __RPC_STUB IEditDebugServices_SetDisplayPointerDebugName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_DumpTree_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IMarkupPointer *pIPointer);


void __RPC_STUB IEditDebugServices_DumpTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_LinesInElement_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [out] */ long *piLines);


void __RPC_STUB IEditDebugServices_LinesInElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_FontsOnLine_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [in] */ long iLine,
    /* [out] */ BSTR *pbstrFonts);


void __RPC_STUB IEditDebugServices_FontsOnLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_GetPixel_Proxy( 
    IEditDebugServices * This,
    /* [in] */ long X,
    /* [in] */ long Y,
    /* [out] */ long *piColor);


void __RPC_STUB IEditDebugServices_GetPixel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_IsUsingBckgrnRecalc_Proxy( 
    IEditDebugServices * This,
    /* [out] */ BOOL *pfUsingBckgrnRecalc);


void __RPC_STUB IEditDebugServices_IsUsingBckgrnRecalc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_IsEncodingAutoSelect_Proxy( 
    IEditDebugServices * This,
    /* [out] */ BOOL *pfEncodingAutoSelect);


void __RPC_STUB IEditDebugServices_IsEncodingAutoSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_EnableEncodingAutoSelect_Proxy( 
    IEditDebugServices * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IEditDebugServices_EnableEncodingAutoSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_IsUsingTableIncRecalc_Proxy( 
    IEditDebugServices * This,
    /* [out] */ BOOL *pfUsingTableIncRecalc);


void __RPC_STUB IEditDebugServices_IsUsingTableIncRecalc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEditDebugServices_INTERFACE_DEFINED__ */


#ifndef __IPrivacyServices_INTERFACE_DEFINED__
#define __IPrivacyServices_INTERFACE_DEFINED__

/* interface IPrivacyServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IPrivacyServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f84b-98b5-11cf-bb82-00aa00bdce0b")
    IPrivacyServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPrivacyInfoToList( 
            /* [in] */ LPOLESTR pstrUrl,
            /* [in] */ LPOLESTR pstrPolicyRef,
            /* [in] */ LPOLESTR pstrP3PHeader,
            /* [in] */ LONG dwReserved,
            /* [in] */ DWORD privacyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivacyServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivacyServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivacyServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivacyServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPrivacyInfoToList )( 
            IPrivacyServices * This,
            /* [in] */ LPOLESTR pstrUrl,
            /* [in] */ LPOLESTR pstrPolicyRef,
            /* [in] */ LPOLESTR pstrP3PHeader,
            /* [in] */ LONG dwReserved,
            /* [in] */ DWORD privacyFlags);
        
        END_INTERFACE
    } IPrivacyServicesVtbl;

    interface IPrivacyServices
    {
        CONST_VTBL struct IPrivacyServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivacyServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivacyServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivacyServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivacyServices_AddPrivacyInfoToList(This,pstrUrl,pstrPolicyRef,pstrP3PHeader,dwReserved,privacyFlags)	\
    (This)->lpVtbl -> AddPrivacyInfoToList(This,pstrUrl,pstrPolicyRef,pstrP3PHeader,dwReserved,privacyFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivacyServices_AddPrivacyInfoToList_Proxy( 
    IPrivacyServices * This,
    /* [in] */ LPOLESTR pstrUrl,
    /* [in] */ LPOLESTR pstrPolicyRef,
    /* [in] */ LPOLESTR pstrP3PHeader,
    /* [in] */ LONG dwReserved,
    /* [in] */ DWORD privacyFlags);


void __RPC_STUB IPrivacyServices_AddPrivacyInfoToList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivacyServices_INTERFACE_DEFINED__ */


#ifndef __IHTMLOMWindowServices_INTERFACE_DEFINED__
#define __IHTMLOMWindowServices_INTERFACE_DEFINED__

/* interface IHTMLOMWindowServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLOMWindowServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5fc-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLOMWindowServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE moveTo( 
            /* [in] */ LONG x,
            /* [in] */ LONG y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE moveBy( 
            /* [in] */ LONG x,
            /* [in] */ LONG y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resizeTo( 
            /* [in] */ LONG x,
            /* [in] */ LONG y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resizeBy( 
            /* [in] */ LONG x,
            /* [in] */ LONG y) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLOMWindowServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLOMWindowServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLOMWindowServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLOMWindowServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *moveTo )( 
            IHTMLOMWindowServices * This,
            /* [in] */ LONG x,
            /* [in] */ LONG y);
        
        HRESULT ( STDMETHODCALLTYPE *moveBy )( 
            IHTMLOMWindowServices * This,
            /* [in] */ LONG x,
            /* [in] */ LONG y);
        
        HRESULT ( STDMETHODCALLTYPE *resizeTo )( 
            IHTMLOMWindowServices * This,
            /* [in] */ LONG x,
            /* [in] */ LONG y);
        
        HRESULT ( STDMETHODCALLTYPE *resizeBy )( 
            IHTMLOMWindowServices * This,
            /* [in] */ LONG x,
            /* [in] */ LONG y);
        
        END_INTERFACE
    } IHTMLOMWindowServicesVtbl;

    interface IHTMLOMWindowServices
    {
        CONST_VTBL struct IHTMLOMWindowServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLOMWindowServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLOMWindowServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLOMWindowServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLOMWindowServices_moveTo(This,x,y)	\
    (This)->lpVtbl -> moveTo(This,x,y)

#define IHTMLOMWindowServices_moveBy(This,x,y)	\
    (This)->lpVtbl -> moveBy(This,x,y)

#define IHTMLOMWindowServices_resizeTo(This,x,y)	\
    (This)->lpVtbl -> resizeTo(This,x,y)

#define IHTMLOMWindowServices_resizeBy(This,x,y)	\
    (This)->lpVtbl -> resizeBy(This,x,y)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLOMWindowServices_moveTo_Proxy( 
    IHTMLOMWindowServices * This,
    /* [in] */ LONG x,
    /* [in] */ LONG y);


void __RPC_STUB IHTMLOMWindowServices_moveTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLOMWindowServices_moveBy_Proxy( 
    IHTMLOMWindowServices * This,
    /* [in] */ LONG x,
    /* [in] */ LONG y);


void __RPC_STUB IHTMLOMWindowServices_moveBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLOMWindowServices_resizeTo_Proxy( 
    IHTMLOMWindowServices * This,
    /* [in] */ LONG x,
    /* [in] */ LONG y);


void __RPC_STUB IHTMLOMWindowServices_resizeTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLOMWindowServices_resizeBy_Proxy( 
    IHTMLOMWindowServices * This,
    /* [in] */ LONG x,
    /* [in] */ LONG y);


void __RPC_STUB IHTMLOMWindowServices_resizeBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLOMWindowServices_INTERFACE_DEFINED__ */


#ifndef __IHTMLFilterPainter_INTERFACE_DEFINED__
#define __IHTMLFilterPainter_INTERFACE_DEFINED__

/* interface IHTMLFilterPainter */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLFilterPainter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6de-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLFilterPainter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvalidateRectUnfiltered( 
            /* [in] */ RECT *prcInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRgnUnfiltered( 
            /* [in] */ HRGN hrgnInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeElementVisibility( 
            /* [in] */ BOOL fVisible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLFilterPainterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLFilterPainter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLFilterPainter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLFilterPainter * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRectUnfiltered )( 
            IHTMLFilterPainter * This,
            /* [in] */ RECT *prcInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRgnUnfiltered )( 
            IHTMLFilterPainter * This,
            /* [in] */ HRGN hrgnInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeElementVisibility )( 
            IHTMLFilterPainter * This,
            /* [in] */ BOOL fVisible);
        
        END_INTERFACE
    } IHTMLFilterPainterVtbl;

    interface IHTMLFilterPainter
    {
        CONST_VTBL struct IHTMLFilterPainterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLFilterPainter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLFilterPainter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLFilterPainter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLFilterPainter_InvalidateRectUnfiltered(This,prcInvalid)	\
    (This)->lpVtbl -> InvalidateRectUnfiltered(This,prcInvalid)

#define IHTMLFilterPainter_InvalidateRgnUnfiltered(This,hrgnInvalid)	\
    (This)->lpVtbl -> InvalidateRgnUnfiltered(This,hrgnInvalid)

#define IHTMLFilterPainter_ChangeElementVisibility(This,fVisible)	\
    (This)->lpVtbl -> ChangeElementVisibility(This,fVisible)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLFilterPainter_InvalidateRectUnfiltered_Proxy( 
    IHTMLFilterPainter * This,
    /* [in] */ RECT *prcInvalid);


void __RPC_STUB IHTMLFilterPainter_InvalidateRectUnfiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPainter_InvalidateRgnUnfiltered_Proxy( 
    IHTMLFilterPainter * This,
    /* [in] */ HRGN hrgnInvalid);


void __RPC_STUB IHTMLFilterPainter_InvalidateRgnUnfiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPainter_ChangeElementVisibility_Proxy( 
    IHTMLFilterPainter * This,
    /* [in] */ BOOL fVisible);


void __RPC_STUB IHTMLFilterPainter_ChangeElementVisibility_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLFilterPainter_INTERFACE_DEFINED__ */


#ifndef __IHTMLFilterPaintSite_INTERFACE_DEFINED__
#define __IHTMLFilterPaintSite_INTERFACE_DEFINED__

/* interface IHTMLFilterPaintSite */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLFilterPaintSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6d3-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLFilterPaintSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DrawUnfiltered( 
            /* [in] */ HDC hdc,
            /* [in] */ IUnknown *punkDrawObject,
            /* [in] */ RECT rcBounds,
            /* [in] */ RECT rcUpdate,
            /* [in] */ LONG lDrawLayers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTestPointUnfiltered( 
            /* [in] */ POINT pt,
            /* [in] */ LONG lDrawLayers,
            /* [out][retval] */ BOOL *pbHit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRectFiltered( 
            /* [in] */ RECT *prcInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRgnFiltered( 
            /* [in] */ HRGN hrgnInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeFilterVisibility( 
            /* [in] */ BOOL fVisible) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnsureViewForFilterSite( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDraw( 
            /* [out][retval] */ void **ppDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterFlags( 
            /* [out][retval] */ DWORD *nFlagVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLFilterPaintSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLFilterPaintSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLFilterPaintSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawUnfiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ HDC hdc,
            /* [in] */ IUnknown *punkDrawObject,
            /* [in] */ RECT rcBounds,
            /* [in] */ RECT rcUpdate,
            /* [in] */ LONG lDrawLayers);
        
        HRESULT ( STDMETHODCALLTYPE *HitTestPointUnfiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ POINT pt,
            /* [in] */ LONG lDrawLayers,
            /* [out][retval] */ BOOL *pbHit);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRectFiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ RECT *prcInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRgnFiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ HRGN hrgnInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeFilterVisibility )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ BOOL fVisible);
        
        HRESULT ( STDMETHODCALLTYPE *EnsureViewForFilterSite )( 
            IHTMLFilterPaintSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDraw )( 
            IHTMLFilterPaintSite * This,
            /* [out][retval] */ void **ppDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterFlags )( 
            IHTMLFilterPaintSite * This,
            /* [out][retval] */ DWORD *nFlagVal);
        
        END_INTERFACE
    } IHTMLFilterPaintSiteVtbl;

    interface IHTMLFilterPaintSite
    {
        CONST_VTBL struct IHTMLFilterPaintSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLFilterPaintSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLFilterPaintSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLFilterPaintSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLFilterPaintSite_DrawUnfiltered(This,hdc,punkDrawObject,rcBounds,rcUpdate,lDrawLayers)	\
    (This)->lpVtbl -> DrawUnfiltered(This,hdc,punkDrawObject,rcBounds,rcUpdate,lDrawLayers)

#define IHTMLFilterPaintSite_HitTestPointUnfiltered(This,pt,lDrawLayers,pbHit)	\
    (This)->lpVtbl -> HitTestPointUnfiltered(This,pt,lDrawLayers,pbHit)

#define IHTMLFilterPaintSite_InvalidateRectFiltered(This,prcInvalid)	\
    (This)->lpVtbl -> InvalidateRectFiltered(This,prcInvalid)

#define IHTMLFilterPaintSite_InvalidateRgnFiltered(This,hrgnInvalid)	\
    (This)->lpVtbl -> InvalidateRgnFiltered(This,hrgnInvalid)

#define IHTMLFilterPaintSite_ChangeFilterVisibility(This,fVisible)	\
    (This)->lpVtbl -> ChangeFilterVisibility(This,fVisible)

#define IHTMLFilterPaintSite_EnsureViewForFilterSite(This)	\
    (This)->lpVtbl -> EnsureViewForFilterSite(This)

#define IHTMLFilterPaintSite_GetDirectDraw(This,ppDirectDraw)	\
    (This)->lpVtbl -> GetDirectDraw(This,ppDirectDraw)

#define IHTMLFilterPaintSite_GetFilterFlags(This,nFlagVal)	\
    (This)->lpVtbl -> GetFilterFlags(This,nFlagVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_DrawUnfiltered_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ HDC hdc,
    /* [in] */ IUnknown *punkDrawObject,
    /* [in] */ RECT rcBounds,
    /* [in] */ RECT rcUpdate,
    /* [in] */ LONG lDrawLayers);


void __RPC_STUB IHTMLFilterPaintSite_DrawUnfiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_HitTestPointUnfiltered_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ POINT pt,
    /* [in] */ LONG lDrawLayers,
    /* [out][retval] */ BOOL *pbHit);


void __RPC_STUB IHTMLFilterPaintSite_HitTestPointUnfiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_InvalidateRectFiltered_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ RECT *prcInvalid);


void __RPC_STUB IHTMLFilterPaintSite_InvalidateRectFiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_InvalidateRgnFiltered_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ HRGN hrgnInvalid);


void __RPC_STUB IHTMLFilterPaintSite_InvalidateRgnFiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_ChangeFilterVisibility_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ BOOL fVisible);


void __RPC_STUB IHTMLFilterPaintSite_ChangeFilterVisibility_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_EnsureViewForFilterSite_Proxy( 
    IHTMLFilterPaintSite * This);


void __RPC_STUB IHTMLFilterPaintSite_EnsureViewForFilterSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_GetDirectDraw_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [out][retval] */ void **ppDirectDraw);


void __RPC_STUB IHTMLFilterPaintSite_GetDirectDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_GetFilterFlags_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [out][retval] */ DWORD *nFlagVal);


void __RPC_STUB IHTMLFilterPaintSite_GetFilterFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLFilterPaintSite_INTERFACE_DEFINED__ */


#ifndef __IElementNamespacePrivate_INTERFACE_DEFINED__
#define __IElementNamespacePrivate_INTERFACE_DEFINED__

/* interface IElementNamespacePrivate */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementNamespacePrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7ff-98b5-11cf-bb82-00aa00bdce0b")
    IElementNamespacePrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTagPrivate( 
            /* [in] */ BSTR bstrTagName,
            /* [in] */ BSTR bstrBaseTagName,
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementNamespacePrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementNamespacePrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementNamespacePrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementNamespacePrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTagPrivate )( 
            IElementNamespacePrivate * This,
            /* [in] */ BSTR bstrTagName,
            /* [in] */ BSTR bstrBaseTagName,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IElementNamespacePrivateVtbl;

    interface IElementNamespacePrivate
    {
        CONST_VTBL struct IElementNamespacePrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementNamespacePrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementNamespacePrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementNamespacePrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementNamespacePrivate_AddTagPrivate(This,bstrTagName,bstrBaseTagName,lFlags)	\
    (This)->lpVtbl -> AddTagPrivate(This,bstrTagName,bstrBaseTagName,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementNamespacePrivate_AddTagPrivate_Proxy( 
    IElementNamespacePrivate * This,
    /* [in] */ BSTR bstrTagName,
    /* [in] */ BSTR bstrBaseTagName,
    /* [in] */ LONG lFlags);


void __RPC_STUB IElementNamespacePrivate_AddTagPrivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementNamespacePrivate_INTERFACE_DEFINED__ */

#endif /* __MSHTMLINTERNAL_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_interned_0733 */
/* [local] */ 

#endif //INTERNAL_H_


extern RPC_IF_HANDLE __MIDL_itf_interned_0733_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_interned_0733_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\mshtmlrc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident/MSHTML
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       mshtmlrc.h
//
//  Contents:   Resource identifiers
//
//----------------------------------------------------------------------------


#ifndef I_MSHTMLRC_H_
#define I_MSHTMLRC_H_
#pragma INCMSG("--- Beg 'mshtmlrc.h'")


#define IDC_SELBAR                      2008    // Text select cursor for text site

#define IDC_NOSCROLLVH                  2025


#define IDC_HYPERLINK                   9801
#define IDC_HYPERLINK_OFFLINE           9802
#define IDC_HIBEAM                      9803
#define IDC_RESIZEROW2				    9804 
#define IDC_RESIZECOL2				    9805

#define IDR_DRAG_CONTEXT_MENU       24645  //0x6045  // bad id - not in core range

// HTML Form
#define IDR_HTMLFORM_MENUDESIGN     907
#define IDR_HTMLFORM_MENURUN        908
#define IDR_HTMLFORM_DOCDIR         909
#define IDS_HTMLFORM_USERTYPESHORT  181
#define IDS_HTMLFORM_USERTYPEFULL   180

// Form
#define IDR_ACCELS_SITE_DESIGN          41
#define IDR_ACCELS_SITE_RUN             40
#define IDR_ACCELS_FRAMESET_DESIGN      47
#define IDR_ACCELS_FRAMESET_RUN         46
#define IDR_ACCELS_INPUTTXT_DESIGN      43
#define IDR_ACCELS_INPUTTXT_RUN         42
#define IDR_ACCELS_TCELL_DESIGN         45
#define IDR_ACCELS_TCELL_RUN            44
#define IDR_ACCELS_BODY_RUN             48
#define IDR_ACCELS_BODY_DESIGN          49
#define IDR_ACCELS_TXTSITE_RUN          50
#define IDR_ACCELS_TXTSITE_DESIGN       51


//+------------------------------------------------------------------------
//
//  Error strings
//
//-------------------------------------------------------------------------
#define IDS_USERTYPEAPP                 2212    // Microsoft Forms 2.0
#define IDS_MESSAGE_BOX_TITLE           2213    // Microsoft Forms
#define IDS_ERROR_SOLUTION              2214    // Solution:\n<0s>
#define IDS_EA_SETTING_PROPERTY         2216    // Could not set property ...
#define IDS_EA_GETTING_PROPERTY         2217    // Could not get property ...
#define IDS_EA_CALLING_METHOD           2326    // Could not call method ...
#define IDS_EE_INVALID_PROPERTY_VALUE   2218    // The value entered is not valid ..
#define IDS_ES_ENTER_VALUE_IN_RANGE     2220    // Enter a value between..
#define IDS_ES_ENTER_VALUE_GT_ZERO      2221    // Enter a value greater than
#define IDS_ES_ENTER_VALUE_GE_ZERO      2222    // Enter a value greater than
#define IDS_EE_SETNOTSUPPORTEDATRUNTIME 2321    // Set property is not support at runtime.
#define IDS_EE_METHODNOTAPPLICABLE      2324
#define IDS_ES_ENTER_PROPER_VALUE       2325    // Enter a proper value
#define IDS_EE_INVALIDPICTURETYPE       2227    // CTL_E_INVALIDPICTURETYPE mouse icon must be a mouse icon
#define IDS_EE_CANTMOVEFOCUSTOCTRL      2322    // can't move focus to control because...
#define IDS_EE_INVALIDPICTURE           2331    // CTL_E_INVALIDPICTURE
#define IDS_EE_FAIL                     2330    // E_FAIL
#define IDS_EE_UNEXPECTED               2329    // E_UNEXPECTED
#define IDS_EE_INVALIDARG               2336    // E_INVALIDARG
#define IDS_EE_INVALIDPROPERTYARRAYINDEX 2332   // CTL_E_INVALIDPROPERTYARRAYINDEX
#define IDS_EE_INVALIDPROPERTYVALUE     2333    // CTL_E_INVALIDPROPERTYVALUE
#define IDS_EE_OVERFLOW                 2334    // CTL_E_OVERFLOW
#define IDS_EE_PERMISSIONDENIED         2335    // CTL_E_PERMISSIONDENIED
#define IDS_MSG_SAVE_MODIFIED_OBJECT    2223    // Save modified object?

#define IDS_CTRLPROPERTIES              2229
#define IDS_NAMEDCTRLPROPERTIES         2230
#define IDS_EA_PASTE_CONTROL            2235
#define IDS_EA_INSERT_CONTROL           2236

#define IDS_UNKNOWN_ERROR               2215    // Unknown error <0x>
#define IDS_EE_CONTROLNEEDSFOCUS        2327    // The control needs to have the focus
#define IDS_EE_NOTLICENSED              2337    // CLASS_E_NOTLICENSED
#define IDS_EE_INVALIDPASTETARGET       2338    // CTL_E_INVALIDPASTETARGET
#define IDS_EE_INVALIDPASTESOURCE       2339    // CTL_E_INVALIDPASTESOURCE

#define IDS_UNKNOWN                     2340

#define IDS_EE_INTERNET_INVALID_URL         2341
#define IDS_EE_INTERNET_NAME_NOT_RESOLVED   2342
#define IDS_EE_MISMATCHEDTAG                2345    // CTL_E_MISMATCHEDTAG
#define IDS_EE_INCOMPATIBLEPOINTERS         2346    // CTL_E_INCOMPATIBLEPOINTERS
#define IDS_EE_UNPOSITIONEDPOINTER          2347    // CTL_E_UNPOSITIONEDPOINTER
#define IDS_EE_UNPOSITIONEDELEMENT          2348    // CTL_E_UNPOSITIONEDELEMENT

#define IDS_EDITVERB                    2210
#define IDS_PROPVERB                    2211

//----------------------------------------------------------------------------
//
// Generic property page (52xx)
//
//----------------------------------------------------------------------------

#define IDS_PPG_GENERIC             5211
#define IDS_PPG_INLINE_STYLE        5212
#define IDC_PROPNAME                5204
#define IDE_PROPVALUE               5208

//----------------------------------------------------------------------------
//
// Misc strings
//
//----------------------------------------------------------------------------

//  The following IDS's must be kept in order, such that the
//    string for a given unit has the id IDS_UNITS_BASE + units
//    Otherwise, the StringToHimetric and HimetricToString functions
//    in himetric.cxx will break.  (chrisz)

#define IDS_UNITS_BASE                  2240
#define IDS_UNITS_INCH                  (IDS_UNITS_BASE+0)
#define IDS_UNITS_CM                    (IDS_UNITS_BASE+1)
#define IDS_UNITS_POINT                 (IDS_UNITS_BASE+2)


//----------------------------------------------------------------------------
//
// Undo strings
//
//----------------------------------------------------------------------------

#define IDS_UNDO                        (IDS_UNITS_POINT + 1)
#define IDS_REDO                        (IDS_UNDO + 1)
#define IDS_CANTUNDO                    (IDS_UNDO + 2)
#define IDS_CANTREDO                    (IDS_UNDO + 3)
#define IDS_UNDONEWCTRL                 (IDS_UNDO + 4)
#define IDS_UNDODELETE                  (IDS_UNDO + 5)
#define IDS_UNDOPROPCHANGE              (IDS_UNDO + 6)
#define IDS_UNDOMOVE                    (IDS_UNDO + 7)
#define IDS_UNDODRAGDROP                (IDS_UNDO + 9)
#define IDS_UNDOPASTE                   (IDS_UNDO + 15)
#define IDS_UNDOTYPING                  (IDS_UNDO + 16)
#define IDS_UNDOGENERICTEXT             (IDS_UNDO + 19)

#define IDS_E_CMDNOTSUPPORTED           2206


#define IDS_SITE_BASE      7999
#define IDS_HTMLDEFAULTFONT          (IDS_SITE_BASE + 19)
#define IDS_RUNAWAYSCRIPT            (IDS_SITE_BASE + 29)
#define IDS_PROTECTEDFROMUNSAFEOCX   (IDS_SITE_BASE + 31)
#define IDS_PROTECTEDFROMOCXINIT     (IDS_SITE_BASE + 32)
#define IDS_REPOSTFORMDATA           (IDS_SITE_BASE + 33)
#define IDS_OCXDISABLED              (IDS_SITE_BASE + 34)
#define IDS_MISMATCHEDXML            (IDS_SITE_BASE + 35)
#define IDS_DEBUGCONTINUE            (IDS_SITE_BASE + 36)
#define IDS_FMTDEBUGCONTINUE         (IDS_SITE_BASE + 37)

#define IDS_ERR_SAVEPICTUREAS        (IDS_SITE_BASE + 26)
#define IDS_ERR_SETWALLPAPER         (IDS_SITE_BASE + 27)
#define IDS_ERR_SETDESKTOPITEM       (IDS_SITE_BASE + 38)


//+----------------------------------------------------------------------------
//
// string used by script window
//
//----------------------------------------------------------------------------

#define IDS_OMWINDOW_FIRST             8300
#define IDS_VAR2STR_VTERROR             (IDS_OMWINDOW_FIRST + 0)
#define IDS_VAR2STR_VTNULL              (IDS_OMWINDOW_FIRST + 1)
#define IDS_VAR2STR_VTBOOL_TRUE         (IDS_OMWINDOW_FIRST + 2)
#define IDS_VAR2STR_VTBOOL_FALSE        (IDS_OMWINDOW_FIRST + 3)

//+----------------------------------------------------------------------------
//
// string used in conversion GetIDsOfNames
//
//----------------------------------------------------------------------------

#define IDS_DISPID_FIRST                8200                       // matches:
#define IDS_DISPID_FONTNAME             (IDS_DISPID_FIRST +  1)    // DISPID_CommonCtrl_FONTNAME
#define IDS_DISPID_FONTSIZE             (IDS_DISPID_FIRST +  2)    // DISPID_CommonCtrl_FONTSIZE
#define IDS_DISPID_FONTBOLD             (IDS_DISPID_FIRST +  3)    // DISPID_CommonCtrl_FONTBOLD
#define IDS_DISPID_FONTITAL             (IDS_DISPID_FIRST +  4)    // DISPID_CommonCtrl_FONTITAL
#define IDS_DISPID_FONTUNDER            (IDS_DISPID_FIRST +  5)    // DISPID_CommonCtrl_FONTUNDER
#define IDS_DISPID_BACKCOLOR            (IDS_DISPID_FIRST +  7)    // DISPID_BACKCOLOR
#define IDS_DISPID_BORDERCOLOR          (IDS_DISPID_FIRST +  9)    // DISPID_BORDERCOLOR
#define IDS_DISPID_BORDERSTYLE          (IDS_DISPID_FIRST + 10)    // DISPID_BORDERSTYLE
#define IDS_DISPID_TEXTALIGN            (IDS_DISPID_FIRST + 11)    // DISPID_CommonCtrl_TextAlign
#define IDS_DISPID_SPECIALEFFECT        (IDS_DISPID_FIRST + 12)    // DISPID_CommonCtrl_SpecialEffect
#define IDS_DISPID_FONTSUPERSCRIPT      (IDS_DISPID_FIRST + 13)    // DISPID_CommonCtrl_FONTSUPERSCRIPT
#define IDS_DISPID_FONTSUBSCRIPT        (IDS_DISPID_FIRST + 14)    // DISPID_CommonCtrl_FONTSUBSCRIPT

//+----------------------------------------------------------------------------
//
//  Button caption constants
//
//----------------------------------------------------------------------------

#define IDS_BUTTONCAPTION_RESET         8500
#define IDS_BUTTONCAPTION_SUBMIT        8501
#define IDS_BUTTONCAPTION_UPLOAD        8502

//+----------------------------------------------------------------------------
//
//  Printing constants
//
//----------------------------------------------------------------------------

#define IDS_PRINT_URLTITLE              8400
#define IDS_PRINT_URLCOL1HEAD           8401
#define IDS_PRINT_URLCOL2HEAD           8402
#define IDS_DEFAULTHEADER               8403
#define IDS_DEFAULTFOOTER               8404
#define IDS_DEFAULTMARGINTOP            8405
#define IDS_DEFAULTMARGINBOTTOM         8406
#define IDS_DEFAULTMARGINLEFT           8407
#define IDS_DEFAULTMARGINRIGHT          8408

//+----------------------------------------------------------------------------
//
// Progress status text strings
//
//-----------------------------------------------------------------------------

#define IDS_BINDSTATUS_DOWNLOADING                  8154
#define IDS_BINDSTATUS_DOWNLOADINGDATA_PICTURE      8155
#define IDS_BINDSTATUS_GENERATINGDATA_TEXT          8156
#define IDS_BINDSTATUS_DOWNLOADINGDATA_TEXT         8157
#define IDS_BINDSTATUS_INSTALLINGCOMPONENTS         8160
#define IDS_BINDSTATUS_DOWNLOADINGDATA_BITS         8167

#define IDS_DONE                                    8169

#define IDS_LOADINGTABLE                            8170
#define IDS_DATABINDING                             8171

#define IDS_FRIENDLYURL_SHORTCUTTO                  8172
#define IDS_FRIENDLYURL_AT                          8173
#define IDS_FRIENDLYURL_SENDSMAILTO                 8174
#define IDS_FRIENDLYURL_LOCAL                       8175
#define IDS_FRIENDLYURL_GOPHER                      8176
#define IDS_FRIENDLYURL_FTP                         8177
#define IDS_FRIENDLYURL_SECUREWEBSITE               8178

#define IDS_CANNOTLOAD                              8193
#define IDS_ONBEFOREUNLOAD_PREAMBLE                 8194
#define IDS_ONBEFOREUNLOAD_POSTAMBLE                8197

#define IDS_DEFAULT_ISINDEX_PROMPT                  8196


#define IDS_UNKNOWNPROTOCOL             2511    
#define IDS_SECURECONNECTIONINFO        2512
#define IDS_SECURE_LOW                  2513
#define IDS_SECURE_MEDIUM               2514
#define IDS_SECURE_HIGH                 2515
#define IDS_SECURESOURCE                2516

// Jave Script prompt() dialog
#define IDD_PROMPT_MSHTML                   8131
#define IDC_PROMPT_PROMPT                   8132
#define IDC_PROMPT_EDIT                     8133

// Plugin/ActiveX Viewer Not Installed dialog
#define IDD_PLUGIN_UPGRADE                  8134
#define IDC_PLUGIN_UPGRADE_CHECK            8135
#define IDC_PLUGIN_UPGRADE_EXTENSION        8136
#define IDC_PLUGIN_UPGRADE_MIME_TYPE        8137

#define IDS_PROPERTYOPENPICTURE     5010
#define IDS_PROPERTYOPENMOUSEICON   5011

#define IDS_HTMLFORM_SAVE                   8114

#define IDS_SAVEPICTUREAS_GIF               8116
#define IDS_SAVEPICTUREAS_JPG               8117
#define IDS_SAVEPICTUREAS_BMP               8118
#define IDS_SAVEPICTUREAS_XBM               8119
#define IDS_SAVEPICTUREAS_ART               8120
#define IDS_SAVEPICTUREAS_WMF               8121
#define IDS_SAVEPICTUREAS_EMF               8122
#define IDS_SAVEPICTUREAS_AVI               8123
#define IDS_SAVEPICTUREAS_MPG               8124
#define IDS_SAVEPICTUREAS_MOV               8125
#define IDS_SAVEPICTUREAS_ORIGINAL          8126
#define IDS_UNTITLED_BITMAP                 8127
#define IDS_UNTITLED_MSHTML                 8128
#define IDS_WALLPAPER_BMP                   8129
#define IDS_SAVEPICTUREAS_PNG               8138
#define IDS_UPLOADFILE              5444

#ifdef UNIX
#  define IDS_PRINT_ERROR             5445
#  define IDS_PRINT_ERROR_MSG         5446
#endif


#define IDS_DLAY_ERROR_BASE      8999
#define IDS_MSG_DB_CANTSAVE         (IDS_DLAY_ERROR_BASE + 1)
#define IDS_EE_DB_COERCE            (IDS_DLAY_ERROR_BASE + 2)
#define IDS_EE_DB_DELROW            (IDS_DLAY_ERROR_BASE + 3)
#define IDS_EE_DB_READ              (IDS_DLAY_ERROR_BASE + 4)
#define IDS_EE_DB_SCHEMA            (IDS_DLAY_ERROR_BASE + 5)
#define IDS_EE_DB_CANCELED          (IDS_DLAY_ERROR_BASE + 6)
#define IDS_EE_DB_OTHER_STATUS      (IDS_DLAY_ERROR_BASE + 7)

#define IDS_MENUHELP(idm) (10000 + (idm))
#define IDS_TOOLTIP(idm)  (20000 + (idm))

//+----------------------------------------------------------------------------
//
// HTML Block Format String
//
//-----------------------------------------------------------------------------

#define IDS_BLOCKFMT_NORMAL    1000
#define IDS_BLOCKFMT_PRE       1001
#define IDS_BLOCKFMT_ADDRESS   1002
#define IDS_BLOCKFMT_H1        1003
#define IDS_BLOCKFMT_H2        1004
#define IDS_BLOCKFMT_H3        1005
#define IDS_BLOCKFMT_H4        1006
#define IDS_BLOCKFMT_H5        1007
#define IDS_BLOCKFMT_H6        1008
#define IDS_BLOCKFMT_OL        1009
#define IDS_BLOCKFMT_UL        1010
#define IDS_BLOCKFMT_DIR       1011
#define IDS_BLOCKFMT_MENU      1012
#define IDS_BLOCKFMT_DT        1013
#define IDS_BLOCKFMT_DD        1014
#define IDS_BLOCKFMT_P         1016

#define IDS_HELPABOUT_STRING   1017

//+----------------------------------------------------------------------------
//
// default title caption for untitled HTML documents
//
//-----------------------------------------------------------------------------

#define IDS_NULL_TITLE         1020

// default document security property
#define IDS_DEFAULT_DOC_SECURITY_PROP       8130

//+----------------------------------------------------------------------------
//
//   MailTo constants
//
//----------------------------------------------------------------------------
#define IDS_MAILTO_DEFAULTSUBJECT       8600
#define IDS_MAILTO_MAILCLIENTNOTFOUND   8601
#define IDS_MAILTO_SUBMITALERT          8602

// New Encoding Menu
#define RES_STRING_ENCODING_MORE            4700

#if DBG == 1

#define IDS_COLOR_BLACK             5430
#define IDS_COLOR_NAVY              5431
#define IDS_COLOR_BLUE              5432
#define IDS_COLOR_CYAN              5433
#define IDS_COLOR_RED               5434
#define IDS_COLOR_LIME              5435
#define IDS_COLOR_GRAY              5436
#define IDS_COLOR_GREEN             5437
#define IDS_COLOR_YELLOW            5438
#define IDS_COLOR_PINK              5439
#define IDS_COLOR_VIOLET            5440
#define IDS_COLOR_WHITE             5441
// 5442 and 5443 replaced by html dialogs

#endif // DBG == 1

//----------------------------------------------------------------------------
//
// HTML dialog (53xx)
//
//----------------------------------------------------------------------------

#define IDS_WEBPAGEDIALOG           5301
#define IDS_CODEPAGE                5302

//----------------------------------------------------------------------------
//
// Icons
//
//----------------------------------------------------------------------------

#define RES_ICO_FRAME                   2660
#define RES_ICO_HTML                    2661
#define IDI_APPEARANCE                  2662
#define IDI_ADVANCED                    2663
#define IDI_GOTOURL                     2664
#define IDI_HOMEPAGE_MSHTML             2665
#define IDI_FINDTEXT                    2666
#define IDI_UNKNOWN_FILETYPE            2667
#define RES_ICO_GIF                     2668
#define RES_ICO_JPEG                    2669
#define RES_ICON_FOLDER_OPEN            2670
#define RES_ICON_FOLDER_CLOSED          2671
#define RES_ICON_URL_FILE               2672
#define RES_ICO_NOICON                  2673
#define RES_ICO_FINDING                 2674
#define RES_ICO_CONNECTING              2675
#define RES_ICO_ACCESSING               2676
#define RES_ICO_RECEIVING               2677
#define IDI_INTERNET                    2678
#define IDI_SECURITY                    2679
#define IDI_NEWS                        2680
#define IDI_VRML                        2681

#define IDB_DITHER                      2502
#define IDR_HATCHBMP                    2503    // Bitmap for border hatching
#define IDB_NOTLOADED                   2030
#define IDB_MISSING                     2031

//----------------------------------------------------------------------------
//
// Tab order dialog (3250 - 3260)
//
//----------------------------------------------------------------------------
#define IDR_TABORDERLBL             3250
#define IDR_TABORDERLSTBOX          3251
#define IDR_BTNMOVEUP               3252
#define IDR_BTNMOVEDOWN             3253
//#define IDR_BTNAUTOORDER            3254
#define IDR_TABORDERDLG             3255
//#define IDR_TABORDERMOVELBL         3256

// Menu index
#define MENU_INDEX_EDIT             1
#define MENU_INDEX_VIEW             2
#define MENU_INDEX_INSERT           3
#define MENU_INDEX_FORMAT           4


//

// unfortunately, these macros can't be used in defining
//  the symbols below: the resource compiler doesn't like them.
#define IDS_USERTYPEFULL(base)  ((base)/5)
#define IDS_USERTYPESHORT(base) ((base)/5 + 1)

#define IDR_FORM_CONTEXT_MENU       24640  //0x6040  // bad id - not in core range

#define CX_CONTEXTMENUOFFSET    2
#define CY_CONTEXTMENUOFFSET    2

#define RT_FILE                         2110



// siterc.h

// Add controls to the save as dialog.
#define IDC_SAVE_CHARSET_MSHTML    8194
#define IDR_BASE_HTMLFORM           900

#ifndef NO_HTML_DIALOG
// find resources are now located in shdocvw (peterlee)
//#define IDR_FINDDIALOG              _T("find.dlg")
//#define IDR_BIDIFINDDIALOG          _T("bidifind.dlg")
#define IDR_REPLACEDIALOG           _T("replace.dlg")
#define IDR_FORPARDIALOG            _T("forpar.dlg")
#define IDR_FORCHARDIALOG           _T("forchar.dlg")
#define IDR_GOBOOKDIALOG            _T("gobook.dlg")
#define IDR_INSIMAGEDIALOG          _T("insimage.dlg")
#define IDR_EDLINKDIALOG            _T("edlink.dlg")
#define IDR_EDBOOKDIALOG            _T("edbook.dlg")
#endif // NO_HTML_DIALOG


// otherrc.h
#define IDD_GENERICPAGE             5202
#define IDB_APPLY                   5209
#define IDB_OPENDLG                 5210

// window.close dialog string ID.
//
// BUGBUG (scotrobe): This same ID exists in
// resource.h in shdocvw. Don't change one 
// without the other.
//
#define IDS_CONFIRM_SCRIPT_CLOSE_TEXT 0x3035

#pragma INCMSG("--- End 'mshtmlrc.h'")
#else
#pragma INCMSG("*** Dup 'mshtmlrc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\mshtmdbg.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       mshtmdbg.h
//
//  Contents:   External include file for mshtmdbg.dll
//
// ----------------------------------------------------------------------------

#ifndef _MSHTMDBG_H_
#define _MSHTMDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MSHTMDBG_API_VERSION    (7)     // Increment whenever API changes

struct IUnknown;

typedef INT     TRACETAG;
typedef INT_PTR PERFTAG;
typedef INT_PTR PERFMETERTAG;

DWORD       WINAPI  DbgExGetVersion();
BOOL        WINAPI  DbgExIsFullDebug();
void        WINAPI  DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));

void        WINAPI  DbgExDoTracePointsDialog(BOOL fWait);
void        WINAPI  DbgExRestoreDefaultDebugState();

BOOL        WINAPI  DbgExEnableTag(TRACETAG tag, BOOL fEnable);
BOOL        WINAPI  DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk);
BOOL        WINAPI  DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak);
BOOL        WINAPI  DbgExIsTagEnabled(TRACETAG tag);
TRACETAG    WINAPI  DbgExFindTag(char * szTagDesc);

TRACETAG    WINAPI  DbgExTagError();
TRACETAG    WINAPI  DbgExTagWarning();
TRACETAG    WINAPI  DbgExTagThread();
TRACETAG    WINAPI  DbgExTagAssertExit();
TRACETAG    WINAPI  DbgExTagAssertStacks();
TRACETAG    WINAPI  DbgExTagMemoryStrict();
TRACETAG    WINAPI  DbgExTagCoMemoryStrict();
TRACETAG    WINAPI  DbgExTagMemoryStrictTail();
TRACETAG    WINAPI  DbgExTagMemoryStrictAlign();
TRACETAG    WINAPI  DbgExTagOLEWatch();
TRACETAG    WINAPI  DbgExTagRegisterTrace(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagRegisterOther(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagPerf();

BOOL        __cdecl DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...);
BOOL        __cdecl DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...);
BOOL        WINAPI  DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker);
void        WINAPI  DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal);

BOOL        WINAPI  DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage);
void        WINAPI  DbgExAssertThreadDisable(BOOL fDisable);
HRESULT     __cdecl DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...);
HRESULT     WINAPI  DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker);

size_t      WINAPI  DbgExPreAlloc(size_t cbRequest);
void *      WINAPI  DbgExPostAlloc(void *pv);
void *      WINAPI  DbgExPreFree(void *pv);
void        WINAPI  DbgExPostFree();
size_t      WINAPI  DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv);
void *      WINAPI  DbgExPostRealloc(void *pv);
void *      WINAPI  DbgExPreGetSize(void *pvRequest);
size_t      WINAPI  DbgExPostGetSize(size_t cb);
void *      WINAPI  DbgExPreDidAlloc(void *pvRequest);
BOOL        WINAPI  DbgExPostDidAlloc(void *pvRequest, BOOL fActual);

void        WINAPI  DbgExMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExCoMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExMemoryBlockTrackDisable(void * pv);
void        WINAPI  DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt);
void *      WINAPI  DbgExGetMallocSpy();
void        WINAPI  DbgExTraceMemoryLeaks();
BOOL        WINAPI  DbgExValidateInternalHeap();

LONG_PTR    WINAPI  DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
LONG_PTR    WINAPI  DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite);
void        WINAPI  DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExSetSimFailCounts(int firstFailure, int cInterval);
void        WINAPI  DbgExShowSimFailDlg();
BOOL        WINAPI  DbgExFFail();
int         WINAPI  DbgExGetFailCount();
void        WINAPI  DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv);

void        WINAPI  DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize);
void        WINAPI  DbgExOpenMemoryMonitor();
void        WINAPI  DbgExOpenLogFile(LPCSTR szFName);

void *      __cdecl DbgExMemSetName(void *pvRequest, char * szFmt, ...);
void *      WINAPI  DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list valMarker);
char *      WINAPI  DbgExMemGetName(void *pvRequest);

HRESULT     WINAPI  DbgExWsClear(HANDLE hProcess);
HRESULT     WINAPI  DbgExWsTakeSnapshot(HANDLE hProcess);
BSTR        WINAPI  DbgExWsGetModule(long row);
BSTR        WINAPI  DbgExWsGetSection(long row);
long        WINAPI  DbgExWsSize(long row);
long        WINAPI  DbgExWsCount();
long        WINAPI  DbgExWsTotal();
HRESULT     WINAPI  DbgExWsStartDelta(HANDLE hProcess);
long        WINAPI  DbgExWsEndDelta(HANDLE hProcess);

void        WINAPI  DbgExDumpProcessHeaps();

PERFTAG     WINAPI  DbgExPerfRegister(char * szTag, char * szOwner, char * szDescrip);
void        __cdecl DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...);
void        WINAPI  DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker);
void        WINAPI  DbgExPerfDump();
void        WINAPI  DbgExPerfClear();
void        WINAPI  DbgExPerfTags();
void        WINAPI  DbgExPerfEnable(BOOL fEnable);

char *      WINAPI  DbgExDecodeMessage(UINT msg);

PERFMETERTAG WINAPI  DbgExMtRegister(char * szTag, char * szOwner, char * szDescrip);
void        WINAPI  DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal);
void        WINAPI  DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal);
char *      WINAPI  DbgExMtGetName(PERFMETERTAG mt);
char *      WINAPI  DbgExMtGetDesc(PERFMETERTAG mt);
BOOL        WINAPI  DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG_PTR lNewValue);
void        WINAPI  DbgExMtOpenMonitor();
void        WINAPI  DbgExMtLogDump(LPSTR pchFile);
PERFMETERTAG WINAPI  DbgExMtLookupMeter(char * szTag);
long        WINAPI  DbgExMtGetMeterCnt(PERFMETERTAG mt, BOOL fExclusive);
long        WINAPI  DbgExMtGetMeterVal(PERFMETERTAG mt, BOOL fExclusive);

void        WINAPI  DbgExSetTopUrl(LPWSTR pstrUrl);
void        WINAPI  DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf);

BOOL        WINAPI  DbgExGetChkStkFill(DWORD * pdwFill);
int         WINAPI  DbgExGetStackTrace(int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol);

#ifdef __cplusplus
}
#endif

// Performance Logging --------------------------------------------------------

#ifdef PERFTAGS

#define     IsPerfEnabled(tag) (*(BOOL *)tag)
#define     PerfTag(tag, szOwner, szDescrip) PERFTAG tag(DbgExPerfRegister(#tag, szOwner, szDescrip));
#define     PerfExtern(tag) extern PERFTAG tag;
#define     PerfLog(tag,pv,f) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f) : 0
#define     PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1) : 0
#define     PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2) : 0
#define     PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0
#define     PerfDump()  DbgExPerfDump()
#define     PerfClear() DbgExPerfClear()
#define     PerfTags()  DbgExPerfTags()
#define     PerfEnable(fEnable) DbgExPerfEnable(fEnable)

#else

#define     IsPerfEnabled(tag) (FALSE)
#define     PerfTag(tag, szOwner, szDescrip)
#define     PerfExtern(tag)
#define     PerfLog(tag,pv,f)
#define     PerfLog1(tag,pv,f,a1)
#define     PerfLog2(tag,pv,f,a1,a2)
#define     PerfLog3(tag,pv,f,a1,a2,a3)
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define     PerfDump()
#define     PerfClear()
#define     PerfTags()
#define     PerfEnable(fEnable)

#endif

// Performance Metering -------------------------------------------------------

#ifdef PERFMETER

#define     Mt(x)                               g_mt##x
#define     MtExtern(tag)                       extern PERFMETERTAG g_mt##tag;
#define     MtDefine(tag, tagOwner, szDescrip)  PERFMETERTAG g_mt##tag(DbgExMtRegister("mt" #tag, "mt" #tagOwner, szDescrip));
#define     MtAdd(mt, lCnt, lVal)               DbgExMtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)               DbgExMtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewVal)  DbgExMtSimulateOutOfMemory(mt, lNewVal)
#define     MtOpenMonitor()                     DbgExMtOpenMonitor()

#else

#define     Mt(x)                               ((PERFMETERTAG)0)
#define     MtExtern(tag)
#define     MtDefine(tag, szOwner, szDescrip)
#define     MtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewValue)
#define     MtOpenMonitor()

#endif

// MSHTML perf control --------------------------------------------------------

#define HTMPERFCTL_NAME     "#MSHTML#PERF#"

enum
{
    HTMPF_CALLBACK_ONLOAD   = 0x00000001,   // callback when topdoc loaded (dwArg1:HTMPF_CALLBACK_ONLOAD, dwArg2: strURL)
    HTMPF_ENABLE_PROFILE    = 0x00000002,   // enable profiling
    HTMPF_ENABLE_MEMWATCH   = 0x00000004,   // enable memwatch sampling
    HTMPF_DISABLE_PADEVENTS = 0x00000008,   // disable firing of events from mshtmpad.exe
    HTMPF_DISABLE_IMGCACHE  = 0x00000010,   // disable image cache in mshtml
    HTMPF_DISABLE_OFFSCREEN = 0x00000020,   // disable offscreen buffering
    HTMPF_DISABLE_ALERTS    = 0x00000040,   // disable alert() and confirm() methods
    HTMPF_SYNC_DATABIND     = 0x00000080,   // grab all records at once for databinding
    HTMPF_CALLBACK_ONLOAD2  = 0x00000100,   // callback when topdoc loaded (dwArg1:HTMPF_CALLBACK_ONLOAD, dwArg2: CDoc IUnk)
    HTMPF_CALLBACK_ONVIEWQ  = 0x00000200,   // callback when ensure view is queued (dwArg1: HTMPF_CALLBACK_ONVIEWQ, dwArg2: CDoc IUnk)
    HTMPF_CALLBACK_ONVIEWD  = 0x00000400,   // callback when ensure view is dequeued (dwArg1: HTMPF_CALLBACK_ONVIEWD, dwArg2: CDoc IUnk)
#ifndef NO_ETW_TRACING
    HTMPF_CALLBACK_ONEVENT  = 0x00000800    // callback when event tracing for windows is enabled
                                            // (dwArg1: UCHAR EVENT-TYPE, dwArg2: WCHAR* URL)
                                            // See shlwapi.w for event types.
#endif
};

typedef void (WINAPI *HTMPFCBFN)(DWORD dwArg1, void * pvArg2);

typedef struct HTMPERFCTL
{
    DWORD       dwSize;     // set to sizeof(MSHTMLPERF)
    DWORD       dwFlags;    // see HTMPF_*
    HTMPFCBFN   pfnCall;    // Callback function
    void *      pvHost;     // Private data for host
} HTMPERFCTL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\msoeimp.h ===
#ifndef _INC_NEWIMP_H
#define _INC_NEWIMP_H


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// WARNING:  If you make changes to this header, you must also update  //
//           inetcore\published\inc\newimp.h !!!                       //
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


#ifndef NO_IMPORT_ERROR

#define HR_IMP_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)
#define HR_IMP_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, n)
#define HR_IMP      0x3000

#define hrFolderOpenFail    HR_IMP_E(HR_IMP + 1)
#define hrFolderReadFail    HR_IMP_E(HR_IMP + 2)
#define hrMapiInitFail      HR_IMP_E(HR_IMP + 3)
#define hrNoProfilesFound   HR_IMP_E(HR_IMP + 4)
#define hrDiskFull          HR_IMP_E(HR_IMP + 5)
#define hrUserCancel        HR_IMP_E(HR_IMP + 6)

#endif // NO_IMPORT_ERROR

typedef enum tagIMPORTFOLDERTYPE
    {
    FOLDER_TYPE_NORMAL = 0,
    FOLDER_TYPE_INBOX,
    FOLDER_TYPE_OUTBOX,
    FOLDER_TYPE_SENT,
    FOLDER_TYPE_DELETED,
    FOLDER_TYPE_DRAFT,
    CFOLDERTYPE
    } IMPORTFOLDERTYPE;

typedef struct IMSG IMSG;

typedef enum
    {
    MSG_TYPE_MAIL = 0,
    MSG_TYPE_NEWS
    } MSGTYPE;

#define MSG_STATE_UNREAD    0x0001
#define MSG_STATE_UNSENT    0x0002
#define MSG_STATE_SUBMITTED 0x0004
#define MSG_PRI_LOW         0x0010
#define MSG_PRI_NORMAL      0x0020
#define MSG_PRI_HIGH        0x0040
#define MSG_PRI_MASK        0x0070

// {E4499DE7-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IFolderImport, 0xE4499DE7L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IFolderImport IFolderImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IFolderImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMessageCount(ULONG cMsg) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(IMSG *pimsg) = 0;
    };
#else   /* C style interface */
typedef struct IFolderImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IFolderImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IFolderImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IFolderImport * This);

    HRESULT ( STDMETHODCALLTYPE *SetMessageCount )(
		IFolderImport * This,
		ULONG cMsg);
    HRESULT ( STDMETHODCALLTYPE *ImportMessageEx )(
		IFolderImport * This,
		MSGTYPE type, 
		DWORD dwState, 
		LPSTREAM pstm, 
		const TCHAR **rgszAttach, 
		DWORD cAttach);
    HRESULT ( STDMETHODCALLTYPE *ImportMessage )(
		IFolderImport * This,
		IMSG *pimsg);
    END_INTERFACE
} IFolderImportVtbl;

interface IFolderImport
{
    CONST_VTBL struct IFolderImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IFolderImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IFolderImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IFolderImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IFolderImport_SetMessageCount(This,cMsg)	\
	(This)->lpVtbl -> SetMessageCount(This,cMsg)
#define IFolderImport_ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)	\
	(This)->lpVtbl -> ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)
#define IFolderImport_ImportMessage(This,pimsg)	\
	(This)->lpVtbl -> ImportMessage(This,pimsg)
#endif /* COBJMACROS */

#endif  /* C style interface */



// {E4499DE8-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImporter, 0xE4499DE8L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IMailImporter IMailImporter;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImporter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie) = 0;
    };
#else   /* C style interface */
typedef struct IMailImporterVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImporter * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImporter * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImporter * This);

    HRESULT ( STDMETHODCALLTYPE *OpenFolder )(
		IMailImporter * This,
		DWORD_PTR dwCookie, 
		const TCHAR *szFolder, 
		IMPORTFOLDERTYPE type, 
		DWORD dwFlags, 
		IFolderImport **ppFldrImp, 
		DWORD_PTR *pdwCookie);
    END_INTERFACE
} IMailImporterVtbl;

interface IMailImporter
{
    CONST_VTBL struct IMailImporterVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImporter_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImporter_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImporter_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImporter_OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)	\
   (This)->lpVtbl -> OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)

#endif /* COBJMACROS */

#endif  /* C style interface */

typedef struct tagIMPORTFOLDER
    {
    DWORD_PTR           dwCookie;
    TCHAR               szName[MAX_PATH];
    IMPORTFOLDERTYPE    type;
    // DWORD       cMsg;
    BOOL                fSubFolders;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    } IMPORTFOLDER;

// {E4499DE9-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IEnumFOLDERS, 0xE4499DE9L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IEnumFOLDERS IEnumFOLDERS;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IEnumFOLDERS : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(IMPORTFOLDER *pfldr) = 0;
        virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
    };
#else   /* C style interface */
typedef struct IEnumFOLDERSVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IEnumFOLDERS * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IEnumFOLDERS * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IEnumFOLDERS * This);

    HRESULT ( STDMETHODCALLTYPE *Next )(
		IEnumFOLDERS * This,
        IMPORTFOLDER *pfldr);
    HRESULT ( STDMETHODCALLTYPE *Reset )(
		IEnumFOLDERS * This);
    END_INTERFACE
} IEnumFOLDERSVtbl;

interface IEnumFOLDERS
{
    CONST_VTBL struct IEnumFOLDERSVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IEnumFOLDERS_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IEnumFOLDERS_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IEnumFOLDERS_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IEnumFOLDERS_Next(This,pfldr)	\
   (This)->lpVtbl -> Next(This,pfldr);
#define IEnumFOLDERS_Reset(This)	\
   (This)->lpVtbl -> Reset(This);
#endif /* COBJMACROS */

#endif  /* C style interface */


#define COOKIE_ROOT     MAXULONG_PTR

// {E4499DEA-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImport, 0xE4499DEAL, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IMailImport IMailImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetDirectory(char *szDir, UINT cch) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetDirectory(char *szDir) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport) = 0;
    };
#else   /* C style interface */
typedef struct IMailImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImport * This);

    HRESULT ( STDMETHODCALLTYPE *InitializeImport )(
		IMailImport * This,
        HWND hwnd);
    HRESULT ( STDMETHODCALLTYPE *GetDirectory )(
		IMailImport * This,
        char *szDir, 
        UINT cch);
    HRESULT ( STDMETHODCALLTYPE *SetDirectory )(
		IMailImport * This,
        char *szDir);
    HRESULT ( STDMETHODCALLTYPE *EnumerateFolders )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IEnumFOLDERS **ppEnum);
    HRESULT ( STDMETHODCALLTYPE *ImportFolder )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IFolderImport *pImport);

    END_INTERFACE
} IMailImportVtbl;

interface IMailImport
{
    CONST_VTBL struct IMailImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImport_InitializeImport(This,hwnd) \
    (This)->lpVtbl -> InitializeImport(This,hwnd)
#define IMailImport_GetDirectory(This,szDir,cch)    \
    (This)->lpVtbl -> GetDirectory(This,szDir,cch)
#define IMailImport_SetDirectory(This,szDir)    \
    (This)->lpVtbl -> SetDirectory(This,szDir)
#define IMailImport_EnumerateFolders(This,dwCookie,ppEnum)  \
    (This)->lpVtbl -> EnumerateFolders(This,dwCookie,ppEnum)
#define IMailImport_ImportFolder(This,dwCookie,pImport) \
    (This)->lpVtbl -> ImportFolder(This,dwCookie,pImport)

#endif /* COBJMACROS */

#endif  /* C style interface */

#define achPerformImport    "PerformImport"
void PerformImport(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef void (*PFNPERFORMIMPORT)(HWND, IMailImporter *, DWORD);

#define achPerformMigration "PerformMigration"
HRESULT PerformMigration(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef HRESULT (*PFNPERFORMMIGRATION)(HWND, IMailImporter *, DWORD);

#endif // _INC_NEWIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\httprequest.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for httprequest.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __httprequest_h__
#define __httprequest_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWinHttpRequest_FWD_DEFINED__
#define __IWinHttpRequest_FWD_DEFINED__
typedef interface IWinHttpRequest IWinHttpRequest;
#endif 	/* __IWinHttpRequest_FWD_DEFINED__ */


#ifndef __IWinHttpRequestEvents_FWD_DEFINED__
#define __IWinHttpRequestEvents_FWD_DEFINED__
typedef interface IWinHttpRequestEvents IWinHttpRequestEvents;
#endif 	/* __IWinHttpRequestEvents_FWD_DEFINED__ */


#ifndef __WinHttpRequest_FWD_DEFINED__
#define __WinHttpRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class WinHttpRequest WinHttpRequest;
#else
typedef struct WinHttpRequest WinHttpRequest;
#endif /* __cplusplus */

#endif 	/* __WinHttpRequest_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_httprequest_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows HTTP Services (WinHTTP) version 5.1
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_httprequest_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_httprequest_0000_v0_0_s_ifspec;


#ifndef __WinHttp_LIBRARY_DEFINED__
#define __WinHttp_LIBRARY_DEFINED__

/* library WinHttp */
/* [version][lcid][helpstring][uuid] */ 

typedef /* [public] */ long HTTPREQUEST_PROXY_SETTING;

#define	HTTPREQUEST_PROXYSETTING_DEFAULT	( 0 )

#define	HTTPREQUEST_PROXYSETTING_PRECONFIG	( 0 )

#define	HTTPREQUEST_PROXYSETTING_DIRECT	( 0x1 )

#define	HTTPREQUEST_PROXYSETTING_PROXY	( 0x2 )

typedef /* [public] */ long HTTPREQUEST_SETCREDENTIALS_FLAGS;

#define	HTTPREQUEST_SETCREDENTIALS_FOR_SERVER	( 0 )

#define	HTTPREQUEST_SETCREDENTIALS_FOR_PROXY	( 0x1 )

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("12782009-FE90-4877-9730-E5E183669B19") 
enum WinHttpRequestOption
    {	WinHttpRequestOption_UserAgentString	= 0,
	WinHttpRequestOption_URL	= WinHttpRequestOption_UserAgentString + 1,
	WinHttpRequestOption_URLCodePage	= WinHttpRequestOption_URL + 1,
	WinHttpRequestOption_EscapePercentInURL	= WinHttpRequestOption_URLCodePage + 1,
	WinHttpRequestOption_SslErrorIgnoreFlags	= WinHttpRequestOption_EscapePercentInURL + 1,
	WinHttpRequestOption_SelectCertificate	= WinHttpRequestOption_SslErrorIgnoreFlags + 1,
	WinHttpRequestOption_EnableRedirects	= WinHttpRequestOption_SelectCertificate + 1,
	WinHttpRequestOption_UrlEscapeDisable	= WinHttpRequestOption_EnableRedirects + 1,
	WinHttpRequestOption_UrlEscapeDisableQuery	= WinHttpRequestOption_UrlEscapeDisable + 1,
	WinHttpRequestOption_SecureProtocols	= WinHttpRequestOption_UrlEscapeDisableQuery + 1,
	WinHttpRequestOption_EnableTracing	= WinHttpRequestOption_SecureProtocols + 1,
	WinHttpRequestOption_RevertImpersonationOverSsl	= WinHttpRequestOption_EnableTracing + 1,
	WinHttpRequestOption_EnableHttpsToHttpRedirects	= WinHttpRequestOption_RevertImpersonationOverSsl + 1,
	WinHttpRequestOption_EnablePassportAuthentication	= WinHttpRequestOption_EnableHttpsToHttpRedirects + 1,
	WinHttpRequestOption_MaxAutomaticRedirects	= WinHttpRequestOption_EnablePassportAuthentication + 1,
	WinHttpRequestOption_MaxResponseHeaderSize	= WinHttpRequestOption_MaxAutomaticRedirects + 1,
	WinHttpRequestOption_MaxResponseDrainSize	= WinHttpRequestOption_MaxResponseHeaderSize + 1,
	WinHttpRequestOption_EnableHttp1_1	= WinHttpRequestOption_MaxResponseDrainSize + 1,
	WinHttpRequestOption_EnableCertificateRevocationCheck	= WinHttpRequestOption_EnableHttp1_1 + 1
    } 	WinHttpRequestOption;

typedef /* [uuid] */  DECLSPEC_UUID("9d8a6df8-13de-4b1f-a330-67c719d62514") 
enum WinHttpRequestAutoLogonPolicy
    {	AutoLogonPolicy_Always	= 0,
	AutoLogonPolicy_OnlyIfBypassProxy	= AutoLogonPolicy_Always + 1,
	AutoLogonPolicy_Never	= AutoLogonPolicy_OnlyIfBypassProxy + 1
    } 	WinHttpRequestAutoLogonPolicy;

typedef /* [uuid] */  DECLSPEC_UUID("152a1ca2-55a9-43a3-b187-0605bb886349") 
enum WinHttpRequestSslErrorFlags
    {	SslErrorFlag_UnknownCA	= 0x100,
	SslErrorFlag_CertWrongUsage	= 0x200,
	SslErrorFlag_CertCNInvalid	= 0x1000,
	SslErrorFlag_CertDateInvalid	= 0x2000,
	SslErrorFlag_Ignore_All	= 0x3300
    } 	WinHttpRequestSslErrorFlags;

typedef /* [uuid] */  DECLSPEC_UUID("6b2c51c1-a8ea-46bd-b928-c9b76f9f14dd") 
enum WinHttpRequestSecureProtocols
    {	SecureProtocol_SSL2	= 0x8,
	SecureProtocol_SSL3	= 0x20,
	SecureProtocol_TLS1	= 0x80,
	SecureProtocol_ALL	= 0xa8
    } 	WinHttpRequestSecureProtocols;


EXTERN_C const IID LIBID_WinHttp;

#ifndef __IWinHttpRequest_INTERFACE_DEFINED__
#define __IWinHttpRequest_INTERFACE_DEFINED__

/* interface IWinHttpRequest */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IWinHttpRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("016fe2ec-b2c8-45f8-b23b-39e53a75396b")
    IWinHttpRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetProxy( 
            /* [in] */ HTTPREQUEST_PROXY_SETTING ProxySetting,
            /* [optional][in] */ VARIANT ProxyServer,
            /* [optional][in] */ VARIANT BypassList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetCredentials( 
            /* [in] */ BSTR UserName,
            /* [in] */ BSTR Password,
            /* [in] */ HTTPREQUEST_SETCREDENTIALS_FLAGS Flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR Method,
            /* [in] */ BSTR Url,
            /* [optional][in] */ VARIANT Async) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRequestHeader( 
            /* [in] */ BSTR Header,
            /* [in] */ BSTR Value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetResponseHeader( 
            /* [in] */ BSTR Header,
            /* [retval][out] */ BSTR *Value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllResponseHeaders( 
            /* [retval][out] */ BSTR *Headers) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [optional][in] */ VARIANT Body) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long *Status) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ BSTR *Status) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResponseText( 
            /* [retval][out] */ BSTR *Body) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResponseBody( 
            /* [retval][out] */ VARIANT *Body) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResponseStream( 
            /* [retval][out] */ VARIANT *Body) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Option( 
            /* [in] */ WinHttpRequestOption Option,
            /* [retval][out] */ VARIANT *Value) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Option( 
            /* [in] */ WinHttpRequestOption Option,
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WaitForResponse( 
            /* [optional][in] */ VARIANT Timeout,
            /* [retval][out] */ VARIANT_BOOL *Succeeded) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetTimeouts( 
            /* [in] */ long ResolveTimeout,
            /* [in] */ long ConnectTimeout,
            /* [in] */ long SendTimeout,
            /* [in] */ long ReceiveTimeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetClientCertificate( 
            /* [in] */ BSTR ClientCertificate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAutoLogonPolicy( 
            /* [in] */ WinHttpRequestAutoLogonPolicy AutoLogonPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinHttpRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinHttpRequest * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinHttpRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinHttpRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWinHttpRequest * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWinHttpRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWinHttpRequest * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWinHttpRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetProxy )( 
            IWinHttpRequest * This,
            /* [in] */ HTTPREQUEST_PROXY_SETTING ProxySetting,
            /* [optional][in] */ VARIANT ProxyServer,
            /* [optional][in] */ VARIANT BypassList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetCredentials )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR UserName,
            /* [in] */ BSTR Password,
            /* [in] */ HTTPREQUEST_SETCREDENTIALS_FLAGS Flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR Method,
            /* [in] */ BSTR Url,
            /* [optional][in] */ VARIANT Async);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetRequestHeader )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR Header,
            /* [in] */ BSTR Value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetResponseHeader )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR Header,
            /* [retval][out] */ BSTR *Value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAllResponseHeaders )( 
            IWinHttpRequest * This,
            /* [retval][out] */ BSTR *Headers);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Send )( 
            IWinHttpRequest * This,
            /* [optional][in] */ VARIANT Body);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWinHttpRequest * This,
            /* [retval][out] */ long *Status);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            IWinHttpRequest * This,
            /* [retval][out] */ BSTR *Status);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseText )( 
            IWinHttpRequest * This,
            /* [retval][out] */ BSTR *Body);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseBody )( 
            IWinHttpRequest * This,
            /* [retval][out] */ VARIANT *Body);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseStream )( 
            IWinHttpRequest * This,
            /* [retval][out] */ VARIANT *Body);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Option )( 
            IWinHttpRequest * This,
            /* [in] */ WinHttpRequestOption Option,
            /* [retval][out] */ VARIANT *Value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Option )( 
            IWinHttpRequest * This,
            /* [in] */ WinHttpRequestOption Option,
            /* [in] */ VARIANT Value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WaitForResponse )( 
            IWinHttpRequest * This,
            /* [optional][in] */ VARIANT Timeout,
            /* [retval][out] */ VARIANT_BOOL *Succeeded);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IWinHttpRequest * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetTimeouts )( 
            IWinHttpRequest * This,
            /* [in] */ long ResolveTimeout,
            /* [in] */ long ConnectTimeout,
            /* [in] */ long SendTimeout,
            /* [in] */ long ReceiveTimeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetClientCertificate )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR ClientCertificate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetAutoLogonPolicy )( 
            IWinHttpRequest * This,
            /* [in] */ WinHttpRequestAutoLogonPolicy AutoLogonPolicy);
        
        END_INTERFACE
    } IWinHttpRequestVtbl;

    interface IWinHttpRequest
    {
        CONST_VTBL struct IWinHttpRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinHttpRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWinHttpRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWinHttpRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWinHttpRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWinHttpRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWinHttpRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWinHttpRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWinHttpRequest_SetProxy(This,ProxySetting,ProxyServer,BypassList)	\
    (This)->lpVtbl -> SetProxy(This,ProxySetting,ProxyServer,BypassList)

#define IWinHttpRequest_SetCredentials(This,UserName,Password,Flags)	\
    (This)->lpVtbl -> SetCredentials(This,UserName,Password,Flags)

#define IWinHttpRequest_Open(This,Method,Url,Async)	\
    (This)->lpVtbl -> Open(This,Method,Url,Async)

#define IWinHttpRequest_SetRequestHeader(This,Header,Value)	\
    (This)->lpVtbl -> SetRequestHeader(This,Header,Value)

#define IWinHttpRequest_GetResponseHeader(This,Header,Value)	\
    (This)->lpVtbl -> GetResponseHeader(This,Header,Value)

#define IWinHttpRequest_GetAllResponseHeaders(This,Headers)	\
    (This)->lpVtbl -> GetAllResponseHeaders(This,Headers)

#define IWinHttpRequest_Send(This,Body)	\
    (This)->lpVtbl -> Send(This,Body)

#define IWinHttpRequest_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IWinHttpRequest_get_StatusText(This,Status)	\
    (This)->lpVtbl -> get_StatusText(This,Status)

#define IWinHttpRequest_get_ResponseText(This,Body)	\
    (This)->lpVtbl -> get_ResponseText(This,Body)

#define IWinHttpRequest_get_ResponseBody(This,Body)	\
    (This)->lpVtbl -> get_ResponseBody(This,Body)

#define IWinHttpRequest_get_ResponseStream(This,Body)	\
    (This)->lpVtbl -> get_ResponseStream(This,Body)

#define IWinHttpRequest_get_Option(This,Option,Value)	\
    (This)->lpVtbl -> get_Option(This,Option,Value)

#define IWinHttpRequest_put_Option(This,Option,Value)	\
    (This)->lpVtbl -> put_Option(This,Option,Value)

#define IWinHttpRequest_WaitForResponse(This,Timeout,Succeeded)	\
    (This)->lpVtbl -> WaitForResponse(This,Timeout,Succeeded)

#define IWinHttpRequest_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IWinHttpRequest_SetTimeouts(This,ResolveTimeout,ConnectTimeout,SendTimeout,ReceiveTimeout)	\
    (This)->lpVtbl -> SetTimeouts(This,ResolveTimeout,ConnectTimeout,SendTimeout,ReceiveTimeout)

#define IWinHttpRequest_SetClientCertificate(This,ClientCertificate)	\
    (This)->lpVtbl -> SetClientCertificate(This,ClientCertificate)

#define IWinHttpRequest_SetAutoLogonPolicy(This,AutoLogonPolicy)	\
    (This)->lpVtbl -> SetAutoLogonPolicy(This,AutoLogonPolicy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetProxy_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ HTTPREQUEST_PROXY_SETTING ProxySetting,
    /* [optional][in] */ VARIANT ProxyServer,
    /* [optional][in] */ VARIANT BypassList);


void __RPC_STUB IWinHttpRequest_SetProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetCredentials_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR UserName,
    /* [in] */ BSTR Password,
    /* [in] */ HTTPREQUEST_SETCREDENTIALS_FLAGS Flags);


void __RPC_STUB IWinHttpRequest_SetCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_Open_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR Method,
    /* [in] */ BSTR Url,
    /* [optional][in] */ VARIANT Async);


void __RPC_STUB IWinHttpRequest_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetRequestHeader_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR Header,
    /* [in] */ BSTR Value);


void __RPC_STUB IWinHttpRequest_SetRequestHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_GetResponseHeader_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR Header,
    /* [retval][out] */ BSTR *Value);


void __RPC_STUB IWinHttpRequest_GetResponseHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_GetAllResponseHeaders_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ BSTR *Headers);


void __RPC_STUB IWinHttpRequest_GetAllResponseHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_Send_Proxy( 
    IWinHttpRequest * This,
    /* [optional][in] */ VARIANT Body);


void __RPC_STUB IWinHttpRequest_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_Status_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ long *Status);


void __RPC_STUB IWinHttpRequest_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_StatusText_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ BSTR *Status);


void __RPC_STUB IWinHttpRequest_get_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_ResponseText_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ BSTR *Body);


void __RPC_STUB IWinHttpRequest_get_ResponseText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_ResponseBody_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ VARIANT *Body);


void __RPC_STUB IWinHttpRequest_get_ResponseBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_ResponseStream_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ VARIANT *Body);


void __RPC_STUB IWinHttpRequest_get_ResponseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_Option_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ WinHttpRequestOption Option,
    /* [retval][out] */ VARIANT *Value);


void __RPC_STUB IWinHttpRequest_get_Option_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_put_Option_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ WinHttpRequestOption Option,
    /* [in] */ VARIANT Value);


void __RPC_STUB IWinHttpRequest_put_Option_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_WaitForResponse_Proxy( 
    IWinHttpRequest * This,
    /* [optional][in] */ VARIANT Timeout,
    /* [retval][out] */ VARIANT_BOOL *Succeeded);


void __RPC_STUB IWinHttpRequest_WaitForResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_Abort_Proxy( 
    IWinHttpRequest * This);


void __RPC_STUB IWinHttpRequest_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetTimeouts_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ long ResolveTimeout,
    /* [in] */ long ConnectTimeout,
    /* [in] */ long SendTimeout,
    /* [in] */ long ReceiveTimeout);


void __RPC_STUB IWinHttpRequest_SetTimeouts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetClientCertificate_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR ClientCertificate);


void __RPC_STUB IWinHttpRequest_SetClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetAutoLogonPolicy_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ WinHttpRequestAutoLogonPolicy AutoLogonPolicy);


void __RPC_STUB IWinHttpRequest_SetAutoLogonPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinHttpRequest_INTERFACE_DEFINED__ */


#ifndef __IWinHttpRequestEvents_INTERFACE_DEFINED__
#define __IWinHttpRequestEvents_INTERFACE_DEFINED__

/* interface IWinHttpRequestEvents */
/* [unique][helpstring][nonextensible][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IWinHttpRequestEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f97f4e15-b787-4212-80d1-d380cbbf982e")
    IWinHttpRequestEvents : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnResponseStart( 
            /* [in] */ long Status,
            /* [in] */ BSTR ContentType) = 0;
        
        virtual void STDMETHODCALLTYPE OnResponseDataAvailable( 
            /* [in] */ SAFEARRAY * *Data) = 0;
        
        virtual void STDMETHODCALLTYPE OnResponseFinished( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnError( 
            /* [in] */ long ErrorNumber,
            /* [in] */ BSTR ErrorDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinHttpRequestEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinHttpRequestEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinHttpRequestEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinHttpRequestEvents * This);
        
        void ( STDMETHODCALLTYPE *OnResponseStart )( 
            IWinHttpRequestEvents * This,
            /* [in] */ long Status,
            /* [in] */ BSTR ContentType);
        
        void ( STDMETHODCALLTYPE *OnResponseDataAvailable )( 
            IWinHttpRequestEvents * This,
            /* [in] */ SAFEARRAY * *Data);
        
        void ( STDMETHODCALLTYPE *OnResponseFinished )( 
            IWinHttpRequestEvents * This);
        
        void ( STDMETHODCALLTYPE *OnError )( 
            IWinHttpRequestEvents * This,
            /* [in] */ long ErrorNumber,
            /* [in] */ BSTR ErrorDescription);
        
        END_INTERFACE
    } IWinHttpRequestEventsVtbl;

    interface IWinHttpRequestEvents
    {
        CONST_VTBL struct IWinHttpRequestEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinHttpRequestEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWinHttpRequestEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWinHttpRequestEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWinHttpRequestEvents_OnResponseStart(This,Status,ContentType)	\
    (This)->lpVtbl -> OnResponseStart(This,Status,ContentType)

#define IWinHttpRequestEvents_OnResponseDataAvailable(This,Data)	\
    (This)->lpVtbl -> OnResponseDataAvailable(This,Data)

#define IWinHttpRequestEvents_OnResponseFinished(This)	\
    (This)->lpVtbl -> OnResponseFinished(This)

#define IWinHttpRequestEvents_OnError(This,ErrorNumber,ErrorDescription)	\
    (This)->lpVtbl -> OnError(This,ErrorNumber,ErrorDescription)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWinHttpRequestEvents_OnResponseStart_Proxy( 
    IWinHttpRequestEvents * This,
    /* [in] */ long Status,
    /* [in] */ BSTR ContentType);


void __RPC_STUB IWinHttpRequestEvents_OnResponseStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWinHttpRequestEvents_OnResponseDataAvailable_Proxy( 
    IWinHttpRequestEvents * This,
    /* [in] */ SAFEARRAY * *Data);


void __RPC_STUB IWinHttpRequestEvents_OnResponseDataAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWinHttpRequestEvents_OnResponseFinished_Proxy( 
    IWinHttpRequestEvents * This);


void __RPC_STUB IWinHttpRequestEvents_OnResponseFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWinHttpRequestEvents_OnError_Proxy( 
    IWinHttpRequestEvents * This,
    /* [in] */ long ErrorNumber,
    /* [in] */ BSTR ErrorDescription);


void __RPC_STUB IWinHttpRequestEvents_OnError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinHttpRequestEvents_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WinHttpRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("2087c2f4-2cef-4953-a8ab-66779b670495")
WinHttpRequest;
#endif
#endif /* __WinHttp_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetsrv\inc\cierror.h ===
#ifndef _CIERROR_H_
#define _CIERROR_H_
#ifndef FACILITY_WINDOWS
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_NULL                    0x0
#define FACILITY_ITF                     0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COFAIL           0x3
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: NOT_AN_ERROR1
//
// MessageText:
//
//  NOTE:  This dummy error message is necessary to force MC to output
//         the above defines inside the FACILITY_WINDOWS guard instead
//         of leaving it empty.
//
#define NOT_AN_ERROR1                    ((HRESULT)0x00081600L)

#endif // FACILITY_WINDOWS
//
// Range 0x1600-0x1850 is reserved by Content Index.
//
//
// Codes 0x1600-0x164f are reserved for QUERY
//
//
// MessageId: QUERY_E_FAILED
//
// MessageText:
//
//  Call failed for unknown reason.
//
#define QUERY_E_FAILED                   ((HRESULT)0x80041600L)

//
// MessageId: QUERY_E_INVALIDQUERY
//
// MessageText:
//
//  Invalid parameter.
//
#define QUERY_E_INVALIDQUERY             ((HRESULT)0x80041601L)

//
// MessageId: QUERY_E_INVALIDRESTRICTION
//
// MessageText:
//
//  The query restriction could not be parsed.
//
#define QUERY_E_INVALIDRESTRICTION       ((HRESULT)0x80041602L)

//
// MessageId: QUERY_E_INVALIDSORT
//
// MessageText:
//
//  An invalid sort order was requested.
//
#define QUERY_E_INVALIDSORT              ((HRESULT)0x80041603L)

//
// MessageId: QUERY_E_INVALIDCATEGORIZE
//
// MessageText:
//
//  An invalid categorization order was requested.
//
#define QUERY_E_INVALIDCATEGORIZE        ((HRESULT)0x80041604L)

//
// MessageId: QUERY_E_ALLNOISE
//
// MessageText:
//
//  The query contained only ignored words.
//
#define QUERY_E_ALLNOISE                 ((HRESULT)0x80041605L)

//
// MessageId: QUERY_E_TOOCOMPLEX
//
// MessageText:
//
//  The query was too complex to be executed.
//
#define QUERY_E_TOOCOMPLEX               ((HRESULT)0x80041606L)

//
// MessageId: QUERY_E_TIMEDOUT
//
// MessageText:
//
//  The query exceeded its execution time limit.
//
#define QUERY_E_TIMEDOUT                 ((HRESULT)0x80041607L)

//
// MessageId: QUERY_E_DUPLICATE_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is a duplicate.
//
#define QUERY_E_DUPLICATE_OUTPUT_COLUMN  ((HRESULT)0x80041608L)

//
// MessageId: QUERY_E_INVALID_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is not valid.
//
#define QUERY_E_INVALID_OUTPUT_COLUMN    ((HRESULT)0x80041609L)

//
// MessageId: QUERY_E_INVALID_DIRECTORY
//
// MessageText:
//
//  Invalid directory name.
//
#define QUERY_E_INVALID_DIRECTORY        ((HRESULT)0x8004160AL)

//
// MessageId: QUERY_E_DIR_ON_REMOVABLE_DRIVE
//
// MessageText:
//
//  Specified directory is on a removable medium.
//
#define QUERY_E_DIR_ON_REMOVABLE_DRIVE   ((HRESULT)0x8004160BL)

//
// MessageId: QUERY_S_NO_QUERY
//
// MessageText:
//
//  The catalog is in a state where indexing continues, but queries are not allowed.
//
#define QUERY_S_NO_QUERY                 ((HRESULT)0x8004160CL)

//
// Codes 0x1650-0x167f are reserved for qutil error codes
//
//
// MessageId: QPLIST_E_CANT_OPEN_FILE
//
// MessageText:
//
//  Can not open file.
//
#define QPLIST_E_CANT_OPEN_FILE          ((HRESULT)0x80041651L)

//
// MessageId: QPLIST_E_READ_ERROR
//
// MessageText:
//
//  Read error in file.
//
#define QPLIST_E_READ_ERROR              ((HRESULT)0x80041652L)

//
// MessageId: QPLIST_E_EXPECTING_NAME
//
// MessageText:
//
//  Expecting property name.
//
#define QPLIST_E_EXPECTING_NAME          ((HRESULT)0x80041653L)

//
// MessageId: QPLIST_E_EXPECTING_TYPE
//
// MessageText:
//
//  Expecting type specifier.
//
#define QPLIST_E_EXPECTING_TYPE          ((HRESULT)0x80041654L)

//
// MessageId: QPLIST_E_UNRECOGNIZED_TYPE
//
// MessageText:
//
//  Unrecognized type.
//
#define QPLIST_E_UNRECOGNIZED_TYPE       ((HRESULT)0x80041655L)

//
// MessageId: QPLIST_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPLIST_E_EXPECTING_INTEGER       ((HRESULT)0x80041656L)

//
// MessageId: QPLIST_E_EXPECTING_CLOSE_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis.
//
#define QPLIST_E_EXPECTING_CLOSE_PAREN   ((HRESULT)0x80041657L)

//
// MessageId: QPLIST_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPLIST_E_EXPECTING_GUID          ((HRESULT)0x80041658L)

//
// MessageId: QPLIST_E_BAD_GUID
//
// MessageText:
//
//  Invalid guid.
//
#define QPLIST_E_BAD_GUID                ((HRESULT)0x80041659L)

//
// MessageId: QPLIST_E_EXPECTING_PROP_SPEC
//
// MessageText:
//
//  Expecting property specifier.
//
#define QPLIST_E_EXPECTING_PROP_SPEC     ((HRESULT)0x8004165AL)

//
// MessageId: QPLIST_E_CANT_SET_PROPERTY
//
// MessageText:
//
//  Failed to set property name.
//
#define QPLIST_E_CANT_SET_PROPERTY       ((HRESULT)0x8004165BL)

//
// MessageId: QPLIST_E_DUPLICATE
//
// MessageText:
//
//  Duplicate property name.
//
#define QPLIST_E_DUPLICATE               ((HRESULT)0x8004165CL)

//
// MessageId: QPLIST_E_VECTORBYREF_USED_ALONE
//
// MessageText:
//
//  DBTYPE_VECTOR or DBTYPE_BYREF used alone.
//
#define QPLIST_E_VECTORBYREF_USED_ALONE  ((HRESULT)0x8004165DL)

//
// MessageId: QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE
//
// MessageText:
//
//  DBTYPE_BYREF must be used with DBTYPE_STR, DBTYPE_WSTR, DBTYPE_GUID
//   or DBTYPE_UI1 types.
//
#define QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE ((HRESULT)0x8004165EL)

//
// MessageId: QPARSE_E_UNEXPECTED_NOT
//
// MessageText:
//
//  Unexpected NOT operator.
//
#define QPARSE_E_UNEXPECTED_NOT          ((HRESULT)0x80041660L)

//
// MessageId: QPARSE_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPARSE_E_EXPECTING_INTEGER       ((HRESULT)0x80041661L)

//
// MessageId: QPARSE_E_EXPECTING_REAL
//
// MessageText:
//
//  Expecting real number.
//
#define QPARSE_E_EXPECTING_REAL          ((HRESULT)0x80041662L)

//
// MessageId: QPARSE_E_EXPECTING_DATE
//
// MessageText:
//
//  Expecting date.
//
#define QPARSE_E_EXPECTING_DATE          ((HRESULT)0x80041663L)

//
// MessageId: QPARSE_E_EXPECTING_CURRENCY
//
// MessageText:
//
//  Expecting currency.
//
#define QPARSE_E_EXPECTING_CURRENCY      ((HRESULT)0x80041664L)

//
// MessageId: QPARSE_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPARSE_E_EXPECTING_GUID          ((HRESULT)0x80041665L)

//
// MessageId: QPARSE_E_EXPECTING_BRACE
//
// MessageText:
//
//  Expecting closing square bracket ']'.
//
#define QPARSE_E_EXPECTING_BRACE         ((HRESULT)0x80041666L)

//
// MessageId: QPARSE_E_EXPECTING_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis ')'.
//
#define QPARSE_E_EXPECTING_PAREN         ((HRESULT)0x80041667L)

//
// MessageId: QPARSE_E_EXPECTING_PROPERTY
//
// MessageText:
//
//  Expecting property name.
//
#define QPARSE_E_EXPECTING_PROPERTY      ((HRESULT)0x80041668L)

//
// MessageId: QPARSE_E_NOT_YET_IMPLEMENTED
//
// MessageText:
//
//  Not yet implemented.
//
#define QPARSE_E_NOT_YET_IMPLEMENTED     ((HRESULT)0x80041669L)

//
// MessageId: QPARSE_E_EXPECTING_PHRASE
//
// MessageText:
//
//  Expecting phrase.
//
#define QPARSE_E_EXPECTING_PHRASE        ((HRESULT)0x8004166AL)

//
// MessageId: QPARSE_E_UNSUPPORTED_PROPERTY_TYPE
//
// MessageText:
//
//  Unsupported property type.
//
#define QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ((HRESULT)0x8004166BL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX
//
// MessageText:
//
//  Expecting regular expression.
//
#define QPARSE_E_EXPECTING_REGEX         ((HRESULT)0x8004166CL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX_PROPERTY
//
// MessageText:
//
//  Regular expressions require a property of type string.
//
#define QPARSE_E_EXPECTING_REGEX_PROPERTY ((HRESULT)0x8004166DL)

//
// MessageId: QPARSE_E_INVALID_LITERAL
//
// MessageText:
//
//  Invalid literal.
//
#define QPARSE_E_INVALID_LITERAL         ((HRESULT)0x8004166EL)

//
// MessageId: QPARSE_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  No such property.
//
#define QPARSE_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004166FL)

//
// MessageId: QPARSE_E_EXPECTING_EOS
//
// MessageText:
//
//  Expecting end of string.
//
#define QPARSE_E_EXPECTING_EOS           ((HRESULT)0x80041670L)

//
// MessageId: QPARSE_E_EXPECTING_COMMA
//
// MessageText:
//
//  Expecting comma.
//
#define QPARSE_E_EXPECTING_COMMA         ((HRESULT)0x80041671L)

//
// MessageId: QPARSE_E_UNEXPECTED_EOS
//
// MessageText:
//
//  Unexpected end of string.
//
#define QPARSE_E_UNEXPECTED_EOS          ((HRESULT)0x80041672L)

//
// MessageId: QPARSE_E_WEIGHT_OUT_OF_RANGE
//
// MessageText:
//
//  Weight must be between 0 and 1000 in short form queries and between 0.0 and 1.0 in long form queries.
//
#define QPARSE_E_WEIGHT_OUT_OF_RANGE     ((HRESULT)0x80041673L)

//
// MessageId: QPARSE_E_NO_SUCH_SORT_PROPERTY
//
// MessageText:
//
//  An invalid property was found in the sort specification.
//
#define QPARSE_E_NO_SUCH_SORT_PROPERTY   ((HRESULT)0x80041674L)

//
// MessageId: QPARSE_E_INVALID_SORT_ORDER
//
// MessageText:
//
//  An invalid sort order was specified.  Only [a] and [d] are supported.
//
#define QPARSE_E_INVALID_SORT_ORDER      ((HRESULT)0x80041675L)

//
// MessageId: QUTIL_E_CANT_CONVERT_VROOT
//
// MessageText:
//
//  Couldn't convert a virtual path to a physical path.
//
#define QUTIL_E_CANT_CONVERT_VROOT       ((HRESULT)0x80041676L)

//
// MessageId: QPARSE_E_INVALID_GROUPING
//
// MessageText:
//
//  An unsupported grouping type was specified.
//
#define QPARSE_E_INVALID_GROUPING        ((HRESULT)0x80041677L)

//
// MessageId: QUTIL_E_INVALID_CODEPAGE
//
// MessageText:
//
//  Invalid CiCodepage was specified.
//
#define QUTIL_E_INVALID_CODEPAGE         ((HRESULT)0xC0041678L)

//
// MessageId: QPLIST_S_DUPLICATE
//
// MessageText:
//
//  Exact duplicate property defined.
//
#define QPLIST_S_DUPLICATE               ((HRESULT)0x00041679L)

//
// MessageId: QPARSE_E_INVALID_QUERY
//
// MessageText:
//
//  Invalid query.
//
#define QPARSE_E_INVALID_QUERY           ((HRESULT)0x8004167AL)

//
// MessageId: QPARSE_E_INVALID_RANKMETHOD
//
// MessageText:
//
//  Invalid rank method.
//
#define QPARSE_E_INVALID_RANKMETHOD      ((HRESULT)0x8004167BL)

//
// 0x1680 - 0x169F are Filter daemon error codes
//
//
// MessageId: FDAEMON_W_WORDLISTFULL
//
// MessageText:
//
//  Wordlist has reached maximum size.  Additional documents should not be filtered.
//
#define FDAEMON_W_WORDLISTFULL           ((HRESULT)0x00041680L)

//
// MessageId: FDAEMON_E_LOWRESOURCE
//
// MessageText:
//
//  The system is running out of one of more resources needed for filtering, usually memory.
//
#define FDAEMON_E_LOWRESOURCE            ((HRESULT)0x80041681L)

//
// MessageId: FDAEMON_E_FATALERROR
//
// MessageText:
//
//  A critical error occurred during document filtering.  Consult system administrator.
//
#define FDAEMON_E_FATALERROR             ((HRESULT)0x80041682L)

//
// MessageId: FDAEMON_E_PARTITIONDELETED
//
// MessageText:
//
//  Documents not stored in content index because partition has been deleted.
//
#define FDAEMON_E_PARTITIONDELETED       ((HRESULT)0x80041683L)

//
// MessageId: FDAEMON_E_CHANGEUPDATEFAILED
//
// MessageText:
//
//  Documents not stored in content index because update of changelist failed.
//
#define FDAEMON_E_CHANGEUPDATEFAILED     ((HRESULT)0x80041684L)

//
// MessageId: FDAEMON_W_EMPTYWORDLIST
//
// MessageText:
//
//  Final wordlist was empty.
//
#define FDAEMON_W_EMPTYWORDLIST          ((HRESULT)0x00041685L)

//
// MessageId: FDAEMON_E_WORDLISTCOMMITFAILED
//
// MessageText:
//
//  Commit of wordlist failed.  Data not available for query.
//
#define FDAEMON_E_WORDLISTCOMMITFAILED   ((HRESULT)0x80041686L)

//
// MessageId: FDAEMON_E_NOWORDLIST
//
// MessageText:
//
//  No wordlist is being constructed.  May happen after fatal filter error.
//
#define FDAEMON_E_NOWORDLIST             ((HRESULT)0x80041687L)

//
// MessageId: FDAEMON_E_TOOMANYFILTEREDBLOCKS
//
// MessageText:
//
//  During document filtering the limit on buffers has been exceeded.
//
#define FDAEMON_E_TOOMANYFILTEREDBLOCKS  ((HRESULT)0x80041688L)

//
// ISearch error codes
//
//
// MessageId: SEARCH_S_NOMOREHITS
//
// MessageText:
//
//  End of hits has been reached.
//
#define SEARCH_S_NOMOREHITS              ((HRESULT)0x000416A0L)

//
// MessageId: SEARCH_E_NOMONIKER
//
// MessageText:
//
//  Retrival of hits as monikers is not supported (by filter passed into Init).
//
#define SEARCH_E_NOMONIKER               ((HRESULT)0x800416A1L)

//
// MessageId: SEARCH_E_NOREGION
//
// MessageText:
//
//  Retrival of hits as filter regions is not supported (by filter passed into Init).
//
#define SEARCH_E_NOREGION                ((HRESULT)0x800416A2L)

//
// Filter error codes
//
//
// MessageId: FILTER_E_TOO_BIG
//
// MessageText:
//
//  File is too large to filter.
//
#define FILTER_E_TOO_BIG                 ((HRESULT)0x80041730L)

//
// MessageId: FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A partial content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041731L)

//
// MessageId: FILTER_S_FULL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A full content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_FULL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041732L)

//
// MessageId: FILTER_S_CONTENTSCAN_DELAYED
//
// MessageText:
//
//  A content scan of the disk needs to be scheduled for execution later.
//
#define FILTER_S_CONTENTSCAN_DELAYED     ((HRESULT)0x00041733L)

//
// MessageId: FILTER_E_CONTENTINDEXCORRUPT
//
// MessageText:
//
//  The content index is corrupt. A content scan will to be scheduled after chkdsk or autochk is run.
//
#define FILTER_E_CONTENTINDEXCORRUPT     ((HRESULT)0xC0041734L)

//
// MessageId: FILTER_S_DISK_FULL
//
// MessageText:
//
//  The disk is getting full.
//
#define FILTER_S_DISK_FULL               ((HRESULT)0x00041735L)

//
// MessageId: FILTER_E_ALREADY_OPEN
//
// MessageText:
//
//  A file is already open. Cannot open another one while a file is open.
//
#define FILTER_E_ALREADY_OPEN            ((HRESULT)0x80041736L)

//
// MessageId: FILTER_E_UNREACHABLE
//
// MessageText:
//
//  The file is not reachable.
//
#define FILTER_E_UNREACHABLE             ((HRESULT)0x80041737L)

//
// MessageId: FILTER_E_IN_USE
//
// MessageText:
//
//  The document is in use by another process.
//
#define FILTER_E_IN_USE                  ((HRESULT)0x80041738L)

//
// MessageId: FILTER_E_NOT_OPEN
//
// MessageText:
//
//  The document is not opened.
//
#define FILTER_E_NOT_OPEN                ((HRESULT)0x80041739L)

//
// MessageId: FILTER_S_NO_PROPSETS
//
// MessageText:
//
//  The document has no property sets.
//
#define FILTER_S_NO_PROPSETS             ((HRESULT)0x0004173AL)

//
// MessageId: FILTER_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  There is no property with the given GUID.
//
#define FILTER_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004173BL)

//
// MessageId: FILTER_S_NO_SECURITY_DESCRIPTOR
//
// MessageText:
//
//  The document has no security descriptor.
//
#define FILTER_S_NO_SECURITY_DESCRIPTOR  ((HRESULT)0x0004173CL)

//
// MessageId: FILTER_E_OFFLINE
//
// MessageText:
//
//  The document is offline.
//
#define FILTER_E_OFFLINE                 ((HRESULT)0x8004173DL)

//
// MessageId: FILTER_E_PARTIALLY_FILTERED
//
// MessageText:
//
//  The document was too large to filter in its entirety.  Portions of the document were not emitted.
//
#define FILTER_E_PARTIALLY_FILTERED      ((HRESULT)0x8004173EL)

//
// Word breaker error codes
//
//
// MessageId: WBREAK_E_END_OF_TEXT
//
// MessageText:
//
//  End of text reached in text source.
//
#define WBREAK_E_END_OF_TEXT             ((HRESULT)0x80041780L)

//
// MessageId: LANGUAGE_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by word sink.
//
#define LANGUAGE_S_LARGE_WORD            ((HRESULT)0x00041781L)

//
// MessageId: WBREAK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define WBREAK_E_QUERY_ONLY              ((HRESULT)0x80041782L)

//
// MessageId: WBREAK_E_BUFFER_TOO_SMALL
//
// MessageText:
//
//  Buffer too small to hold composed phrase.
//
#define WBREAK_E_BUFFER_TOO_SMALL        ((HRESULT)0x80041783L)

//
// MessageId: LANGUAGE_E_DATABASE_NOT_FOUND
//
// MessageText:
//
//  Langauge database/cache file could not be found.
//
#define LANGUAGE_E_DATABASE_NOT_FOUND    ((HRESULT)0x80041784L)

//
// MessageId: WBREAK_E_INIT_FAILED
//
// MessageText:
//
//  Initialization of word breaker failed.
//
#define WBREAK_E_INIT_FAILED             ((HRESULT)0x80041785L)

//
// MessageId: PSINK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define PSINK_E_QUERY_ONLY               ((HRESULT)0x80041790L)

//
// MessageId: PSINK_E_INDEX_ONLY
//
// MessageText:
//
//  Feature only available in index mode.
//
#define PSINK_E_INDEX_ONLY               ((HRESULT)0x80041791L)

//
// MessageId: PSINK_E_LARGE_ATTACHMENT
//
// MessageText:
//
//  Attachment type beyond valid range.
//
#define PSINK_E_LARGE_ATTACHMENT         ((HRESULT)0x80041792L)

//
// MessageId: PSINK_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by phrase sink.
//
#define PSINK_S_LARGE_WORD               ((HRESULT)0x00041793L)

//
// Content Index Framework Error Codes
//
//
// MessageId: CI_CORRUPT_DATABASE
//
// MessageText:
//
//  The content index is corrupt.
//
#define CI_CORRUPT_DATABASE              ((HRESULT)0xC0041800L)

//
// MessageId: CI_CORRUPT_CATALOG
//
// MessageText:
//
//  The content index meta data is corrupt.
//
#define CI_CORRUPT_CATALOG               ((HRESULT)0xC0041801L)

//
// MessageId: CI_INVALID_PARTITION
//
// MessageText:
//
//  The content index partition is invalid.
//
#define CI_INVALID_PARTITION             ((HRESULT)0xC0041802L)

//
// MessageId: CI_INVALID_PRIORITY
//
// MessageText:
//
//  The priority is invalid.
//
#define CI_INVALID_PRIORITY              ((HRESULT)0xC0041803L)

//
// MessageId: CI_NO_STARTING_KEY
//
// MessageText:
//
//  There is no starting key.
//
#define CI_NO_STARTING_KEY               ((HRESULT)0xC0041804L)

//
// MessageId: CI_OUT_OF_INDEX_IDS
//
// MessageText:
//
//  The content index is out of index ids.
//
#define CI_OUT_OF_INDEX_IDS              ((HRESULT)0xC0041805L)

//
// MessageId: CI_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_NO_CATALOG                    ((HRESULT)0xC0041806L)

//
// MessageId: CI_CORRUPT_FILTER_BUFFER
//
// MessageText:
//
//  The filter buffer is corrupt.
//
#define CI_CORRUPT_FILTER_BUFFER         ((HRESULT)0xC0041807L)

//
// MessageId: CI_INVALID_INDEX
//
// MessageText:
//
//  The index is invalid.
//
#define CI_INVALID_INDEX                 ((HRESULT)0xC0041808L)

//
// MessageId: CI_PROPSTORE_INCONSISTENCY
//
// MessageText:
//
//  Inconsistency in property store detected.
//
#define CI_PROPSTORE_INCONSISTENCY       ((HRESULT)0xC0041809L)

//
// MessageId: CI_E_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object is already initialzed.
//
#define CI_E_ALREADY_INITIALIZED         ((HRESULT)0x8004180AL)

//
// MessageId: CI_E_NOT_INITIALIZED
//
// MessageText:
//
//  The object is not initialzed.
//
#define CI_E_NOT_INITIALIZED             ((HRESULT)0x8004180BL)

//
// MessageId: CI_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The buffer is too small.
//
#define CI_E_BUFFERTOOSMALL              ((HRESULT)0x8004180CL)

//
// MessageId: CI_E_PROPERTY_NOT_CACHED
//
// MessageText:
//
//  The given property is not cached.
//
#define CI_E_PROPERTY_NOT_CACHED         ((HRESULT)0x8004180DL)

//
// MessageId: CI_S_WORKID_DELETED
//
// MessageText:
//
//  The workid is deleted.
//
#define CI_S_WORKID_DELETED              ((HRESULT)0x0004180EL)

//
// MessageId: CI_E_INVALID_STATE
//
// MessageText:
//
//  The object is not in a valid state.
//
#define CI_E_INVALID_STATE               ((HRESULT)0x8004180FL)

//
// MessageId: CI_E_FILTERING_DISABLED
//
// MessageText:
//
//  Filtering is disabled in this content index.
//
#define CI_E_FILTERING_DISABLED          ((HRESULT)0x80041810L)

//
// MessageId: CI_E_DISK_FULL
//
// MessageText:
//
//  The disk is full and the specified operation cannot be done.
//
#define CI_E_DISK_FULL                   ((HRESULT)0x80041811L)

//
// MessageId: CI_E_SHUTDOWN
//
// MessageText:
//
//  Content Index has been shutdown.
//
#define CI_E_SHUTDOWN                    ((HRESULT)0x80041812L)

//
// MessageId: CI_E_WORKID_NOTVALID
//
// MessageText:
//
//  The workid is not valid.
//
#define CI_E_WORKID_NOTVALID             ((HRESULT)0x80041813L)

//
// MessageId: CI_S_END_OF_ENUMERATION
//
// MessageText:
//
//  There are no more documents to enumerate.
//
#define CI_S_END_OF_ENUMERATION          ((HRESULT)0x00041814L)    

//
// MessageId: CI_E_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define CI_E_NOT_FOUND                   ((HRESULT)0x80041815L)

//
// MessageId: CI_E_USE_DEFAULT_PID
//
// MessageText:
//
//  The passed-in property id is not supported.
//
#define CI_E_USE_DEFAULT_PID             ((HRESULT)0x80041816L)

//
// MessageId: CI_E_DUPLICATE_NOTIFICATION
//
// MessageText:
//
//  There were two notifications for the same workid.
//
#define CI_E_DUPLICATE_NOTIFICATION      ((HRESULT)0x80041817L)

//
// MessageId: CI_E_UPDATES_DISABLED
//
// MessageText:
//
//  A document update was rejected because updates were disabled.
//
#define CI_E_UPDATES_DISABLED            ((HRESULT)0x80041818L)

//
// MessageId: CI_E_INVALID_FLAGS_COMBINATION
//
// MessageText:
//
//  The combination of flags specified is invalid.
//
#define CI_E_INVALID_FLAGS_COMBINATION   ((HRESULT)0x80041819L)

//
// MessageId: CI_E_OUTOFSEQ_INCREMENT_DATA
//
// MessageText:
//
//  The incremental data given to Load is not valid. It may be out of sequence.
//
#define CI_E_OUTOFSEQ_INCREMENT_DATA     ((HRESULT)0x8004181AL)

//
// MessageId: CI_E_SHARING_VIOLATION
//
// MessageText:
//
//  A sharing or locking violation caused a failure.
//
#define CI_E_SHARING_VIOLATION           ((HRESULT)0x8004181BL)

//
// MessageId: CI_E_LOGON_FAILURE
//
// MessageText:
//
//  A logon permission violation caused a failure.
//
#define CI_E_LOGON_FAILURE               ((HRESULT)0x8004181CL)

//
// MessageId: CI_E_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_E_NO_CATALOG                  ((HRESULT)0x8004181DL)

//
// MessageId: CI_E_STRANGE_PAGEORSECTOR_SIZE
//
// MessageText:
//
//  Page size is not an integral multiple of the sector size of the volume where index is located.
//
#define CI_E_STRANGE_PAGEORSECTOR_SIZE   ((HRESULT)0x8004181EL)

//
// MessageId: CI_E_TIMEOUT
//
// MessageText:
//
//  Service is too busy.
//
#define CI_E_TIMEOUT                     ((HRESULT)0x8004181FL)

//
// MessageId: CI_E_NOT_RUNNING
//
// MessageText:
//
//  Service is not running.
//
#define CI_E_NOT_RUNNING                 ((HRESULT)0x80041820L)

//
// MessageId: CI_INCORRECT_VERSION
//
// MessageText:
//
//  The content index data on disk is for the wrong version.
//
#define CI_INCORRECT_VERSION             ((HRESULT)0xC0041821L)

//
// MessageId: CI_E_ENUMERATION_STARTED
//
// MessageText:
//
//  Enumeration has already been started for this query.
//
#define CI_E_ENUMERATION_STARTED         ((HRESULT)0xC0041822L)

//
// MessageId: CI_E_PROPERTY_TOOLARGE
//
// MessageText:
//
//  The specified variable length property is too large for the property cache.
//
#define CI_E_PROPERTY_TOOLARGE           ((HRESULT)0xC0041823L)

//
// MessageId: CI_E_CLIENT_FILTER_ABORT
//
// MessageText:
//
//  Filtering of object was aborted by client.
//
#define CI_E_CLIENT_FILTER_ABORT         ((HRESULT)0xC0041824L)

//
// MessageId: CI_S_NO_DOCSTORE
//
// MessageText:
//
//  For administrative connections from client without association to a docstore.
//
#define CI_S_NO_DOCSTORE                 ((HRESULT)0x00041825L)

//
// MessageId: CI_S_CAT_STOPPED
//
// MessageText:
//
//  The catalog has been stopped.
//
#define CI_S_CAT_STOPPED                 ((HRESULT)0x00041826L)

//
// MessageId: CI_E_CARDINALITY_MISMATCH
//
// MessageText:
//
//  Mismatch in cardinality of machine(s)/catalog(s)/scope(s).
//
#define CI_E_CARDINALITY_MISMATCH        ((HRESULT)0x80041827L)

//
// MessageId: CI_E_CONFIG_DISK_FULL
//
// MessageText:
//
//  The disk has reached its configured space limit.
//
#define CI_E_CONFIG_DISK_FULL            ((HRESULT)0x80041828L)

#endif // _CIERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\ratingsp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for ratingsp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ratingsp_h__
#define __ratingsp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRatingNotification_FWD_DEFINED__
#define __IRatingNotification_FWD_DEFINED__
typedef interface IRatingNotification IRatingNotification;
#endif 	/* __IRatingNotification_FWD_DEFINED__ */


#ifndef __ICustomRatingHelper_FWD_DEFINED__
#define __ICustomRatingHelper_FWD_DEFINED__
typedef interface ICustomRatingHelper ICustomRatingHelper;
#endif 	/* __ICustomRatingHelper_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ratingsp_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// Ratingsp.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
//Date : August 18, 1999
//DESCRIPTION : private interface definitions between Custom and msrating
//
typedef 
enum tagRATING_BLOCKING_SOURCE
    {	RBS_NO_RATINGS	= 0,
	RBS_PAGE	= RBS_NO_RATINGS + 1,
	RBS_RATING_HELPER	= RBS_PAGE + 1,
	RBS_CUSTOM_RATING_HELPER	= RBS_RATING_HELPER + 1,
	RBS_ERROR	= RBS_CUSTOM_RATING_HELPER + 1
    } 	RATING_BLOCKING_SOURCE;

typedef 
enum tagRATING_BLOCKING_METHOD
    {	RBM_DENY	= 0,
	RBM_LABEL	= RBM_DENY + 1,
	RBM_UNINIT	= RBM_LABEL + 1,
	RBM_ERROR_NOT_IN_CUSTOM_MODE	= RBM_UNINIT + 1
    } 	RATING_BLOCKING_METHOD;

typedef struct tagRATINGLEVEL
    {
    UINT nValue;
    LPWSTR pwszValueName;
    LPWSTR pwszDescription;
    } 	RATINGLEVEL;

typedef struct tagRATINGCATEGORY
    {
    LPWSTR pwszCategoryName;
    LPWSTR pwszTransmitName;
    } 	RATINGCATEGORY;

typedef struct tagRATINGBLOCKINGCATEGORY
    {
    LPWSTR pwszCategoryName;
    LPWSTR pwszTransmitName;
    UINT nValue;
    LPWSTR pwszValueName;
    } 	RATINGBLOCKINGCATEGORY;

typedef struct tagRATINGBLOCKINGLABELLIST
    {
    LPWSTR pwszRatingSystemName;
    UINT cBlockingLabels;
    RATINGBLOCKINGCATEGORY *paRBLS;
    } 	RATINGBLOCKINGLABELLIST;

typedef struct tagRATINGBLOCKINGINFO
    {
    LPWSTR pwszDeniedURL;
    RATING_BLOCKING_SOURCE rbSource;
    RATING_BLOCKING_METHOD rbMethod;
    UINT cLabels;
    RATINGBLOCKINGLABELLIST *prbLabelList;
    LPWSTR pwszRatingHelperName;
    LPWSTR pwszRatingHelperReason;
    } 	RATINGBLOCKINGINFO;

typedef struct tagRATINGCATEGORYSETTING
    {
    LPSTR pszValueName;
    UINT nValue;
    } 	RATINGCATEGORYSETTING;

typedef struct tagRATINGSYSTEMSETTING
    {
    LPSTR pszRatingSystemName;
    UINT cCategories;
    RATINGCATEGORYSETTING *paRCS;
    } 	RATINGSYSTEMSETTING;





extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0000_v0_0_s_ifspec;

#ifndef __IRatingNotification_INTERFACE_DEFINED__
#define __IRatingNotification_INTERFACE_DEFINED__

/* interface IRatingNotification */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRatingNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("639447BD-B2D3-44b9-9FB0-510F23CB45E4")
    IRatingNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AccessDeniedNotify( 
            /* [in] */ RATINGBLOCKINGINFO *rbInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRatingsEnabled( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRatingNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRatingNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRatingNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRatingNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *AccessDeniedNotify )( 
            IRatingNotification * This,
            /* [in] */ RATINGBLOCKINGINFO *rbInfo);
        
        HRESULT ( STDMETHODCALLTYPE *IsRatingsEnabled )( 
            IRatingNotification * This);
        
        END_INTERFACE
    } IRatingNotificationVtbl;

    interface IRatingNotification
    {
        CONST_VTBL struct IRatingNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRatingNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRatingNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRatingNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRatingNotification_AccessDeniedNotify(This,rbInfo)	\
    (This)->lpVtbl -> AccessDeniedNotify(This,rbInfo)

#define IRatingNotification_IsRatingsEnabled(This)	\
    (This)->lpVtbl -> IsRatingsEnabled(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRatingNotification_AccessDeniedNotify_Proxy( 
    IRatingNotification * This,
    /* [in] */ RATINGBLOCKINGINFO *rbInfo);


void __RPC_STUB IRatingNotification_AccessDeniedNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRatingNotification_IsRatingsEnabled_Proxy( 
    IRatingNotification * This);


void __RPC_STUB IRatingNotification_IsRatingsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRatingNotification_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ratingsp_0140 */
/* [local] */ 


#define SID_SRatingNotification IID_IRatingNotification



extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0140_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0140_v0_0_s_ifspec;

#ifndef __ICustomRatingHelper_INTERFACE_DEFINED__
#define __ICustomRatingHelper_INTERFACE_DEFINED__

/* interface ICustomRatingHelper */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICustomRatingHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D0D9842D-E211-4b2c-88DC-BC729342DFCB")
    ICustomRatingHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ObtainCustomRating( 
            /* [in] */ LPCSTR pszTargetUrl,
            /* [in] */ HANDLE hAbortEvent,
            /* [in] */ IMalloc *pAllocator,
            /* [out] */ LPSTR *ppRatingOut,
            /* [out] */ LPSTR *ppRatingName,
            /* [out] */ LPSTR *ppRatingReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICustomRatingHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICustomRatingHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICustomRatingHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICustomRatingHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *ObtainCustomRating )( 
            ICustomRatingHelper * This,
            /* [in] */ LPCSTR pszTargetUrl,
            /* [in] */ HANDLE hAbortEvent,
            /* [in] */ IMalloc *pAllocator,
            /* [out] */ LPSTR *ppRatingOut,
            /* [out] */ LPSTR *ppRatingName,
            /* [out] */ LPSTR *ppRatingReason);
        
        END_INTERFACE
    } ICustomRatingHelperVtbl;

    interface ICustomRatingHelper
    {
        CONST_VTBL struct ICustomRatingHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICustomRatingHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICustomRatingHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICustomRatingHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICustomRatingHelper_ObtainCustomRating(This,pszTargetUrl,hAbortEvent,pAllocator,ppRatingOut,ppRatingName,ppRatingReason)	\
    (This)->lpVtbl -> ObtainCustomRating(This,pszTargetUrl,hAbortEvent,pAllocator,ppRatingOut,ppRatingName,ppRatingReason)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICustomRatingHelper_ObtainCustomRating_Proxy( 
    ICustomRatingHelper * This,
    /* [in] */ LPCSTR pszTargetUrl,
    /* [in] */ HANDLE hAbortEvent,
    /* [in] */ IMalloc *pAllocator,
    /* [out] */ LPSTR *ppRatingOut,
    /* [out] */ LPSTR *ppRatingName,
    /* [out] */ LPSTR *ppRatingReason);


void __RPC_STUB ICustomRatingHelper_ObtainCustomRating_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICustomRatingHelper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ratingsp_0141 */
/* [local] */ 

STDAPI RatingCustomInit(BOOL bInit = TRUE);
STDAPI RatingCustomAddRatingSystem(LPSTR pszRatingSystemBuffer, UINT nBufferSize);
STDAPI RatingCustomSetUserOptions(RATINGSYSTEMSETTING* pRSSettings, UINT cSettings);
STDAPI RatingCustomAddRatingHelper(LPCSTR pszLibraryName, CLSID clsid, DWORD dwSort);
STDAPI RatingCustomRemoveRatingHelper(CLSID clsid);
STDAPI RatingCustomCrackData(LPCSTR pszUsername, void* pvRatingDetails, RATINGBLOCKINGINFO** pprbInfo);
STDAPI RatingCustomDeleteCrackedData(RATINGBLOCKINGINFO* prblInfo);
STDAPI RatingCustomSetDefaultBureau(LPCSTR pszRatingBureau);


extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0141_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0141_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetsrv\inc\p3admin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for p3admin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __p3admin_h__
#define __p3admin_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IP3User_FWD_DEFINED__
#define __IP3User_FWD_DEFINED__
typedef interface IP3User IP3User;
#endif 	/* __IP3User_FWD_DEFINED__ */


#ifndef __IP3Users_FWD_DEFINED__
#define __IP3Users_FWD_DEFINED__
typedef interface IP3Users IP3Users;
#endif 	/* __IP3Users_FWD_DEFINED__ */


#ifndef __IP3Domain_FWD_DEFINED__
#define __IP3Domain_FWD_DEFINED__
typedef interface IP3Domain IP3Domain;
#endif 	/* __IP3Domain_FWD_DEFINED__ */


#ifndef __IP3Domains_FWD_DEFINED__
#define __IP3Domains_FWD_DEFINED__
typedef interface IP3Domains IP3Domains;
#endif 	/* __IP3Domains_FWD_DEFINED__ */


#ifndef __IP3Service_FWD_DEFINED__
#define __IP3Service_FWD_DEFINED__
typedef interface IP3Service IP3Service;
#endif 	/* __IP3Service_FWD_DEFINED__ */


#ifndef __IP3Config_FWD_DEFINED__
#define __IP3Config_FWD_DEFINED__
typedef interface IP3Config IP3Config;
#endif 	/* __IP3Config_FWD_DEFINED__ */


#ifndef __P3Config_FWD_DEFINED__
#define __P3Config_FWD_DEFINED__

#ifdef __cplusplus
typedef class P3Config P3Config;
#else
typedef struct P3Config P3Config;
#endif /* __cplusplus */

#endif 	/* __P3Config_FWD_DEFINED__ */


#ifndef __P3Domains_FWD_DEFINED__
#define __P3Domains_FWD_DEFINED__

#ifdef __cplusplus
typedef class P3Domains P3Domains;
#else
typedef struct P3Domains P3Domains;
#endif /* __cplusplus */

#endif 	/* __P3Domains_FWD_DEFINED__ */


#ifndef __P3Domain_FWD_DEFINED__
#define __P3Domain_FWD_DEFINED__

#ifdef __cplusplus
typedef class P3Domain P3Domain;
#else
typedef struct P3Domain P3Domain;
#endif /* __cplusplus */

#endif 	/* __P3Domain_FWD_DEFINED__ */


#ifndef __P3Users_FWD_DEFINED__
#define __P3Users_FWD_DEFINED__

#ifdef __cplusplus
typedef class P3Users P3Users;
#else
typedef struct P3Users P3Users;
#endif /* __cplusplus */

#endif 	/* __P3Users_FWD_DEFINED__ */


#ifndef __P3Service_FWD_DEFINED__
#define __P3Service_FWD_DEFINED__

#ifdef __cplusplus
typedef class P3Service P3Service;
#else
typedef struct P3Service P3Service;
#endif /* __cplusplus */

#endif 	/* __P3Service_FWD_DEFINED__ */


#ifndef __P3DomainEnum_FWD_DEFINED__
#define __P3DomainEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class P3DomainEnum P3DomainEnum;
#else
typedef struct P3DomainEnum P3DomainEnum;
#endif /* __cplusplus */

#endif 	/* __P3DomainEnum_FWD_DEFINED__ */


#ifndef __P3User_FWD_DEFINED__
#define __P3User_FWD_DEFINED__

#ifdef __cplusplus
typedef class P3User P3User;
#else
typedef struct P3User P3User;
#endif /* __cplusplus */

#endif 	/* __P3User_FWD_DEFINED__ */


#ifndef __P3UserEnum_FWD_DEFINED__
#define __P3UserEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class P3UserEnum P3UserEnum;
#else
typedef struct P3UserEnum P3UserEnum;
#endif /* __cplusplus */

#endif 	/* __P3UserEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "pop3auth.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IP3User_INTERFACE_DEFINED__
#define __IP3User_INTERFACE_DEFINED__

/* interface IP3User */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IP3User;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EFDDC814-C177-4A0E-B997-5D76018326A7")
    IP3User : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Lock( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Lock( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MessageCount( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MessageDiskUsage( 
            /* [out] */ long *plFactor,
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EmailName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessageDiskUsage( 
            /* [out] */ VARIANT *pvFactor,
            /* [out] */ VARIANT *pvValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateQuotaFile( 
            /* [in] */ BSTR bstrMachineName,
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClientConfigDesc( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SAMName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IP3UserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IP3User * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IP3User * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IP3User * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IP3User * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IP3User * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IP3User * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IP3User * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Lock )( 
            IP3User * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Lock )( 
            IP3User * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageCount )( 
            IP3User * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageDiskUsage )( 
            IP3User * This,
            /* [out] */ long *plFactor,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IP3User * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmailName )( 
            IP3User * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessageDiskUsage )( 
            IP3User * This,
            /* [out] */ VARIANT *pvFactor,
            /* [out] */ VARIANT *pvValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateQuotaFile )( 
            IP3User * This,
            /* [in] */ BSTR bstrMachineName,
            /* [in] */ BSTR bstrUserName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientConfigDesc )( 
            IP3User * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SAMName )( 
            IP3User * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IP3UserVtbl;

    interface IP3User
    {
        CONST_VTBL struct IP3UserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IP3User_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IP3User_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IP3User_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IP3User_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IP3User_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IP3User_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IP3User_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IP3User_get_Lock(This,pVal)	\
    (This)->lpVtbl -> get_Lock(This,pVal)

#define IP3User_put_Lock(This,newVal)	\
    (This)->lpVtbl -> put_Lock(This,newVal)

#define IP3User_get_MessageCount(This,pVal)	\
    (This)->lpVtbl -> get_MessageCount(This,pVal)

#define IP3User_get_MessageDiskUsage(This,plFactor,pVal)	\
    (This)->lpVtbl -> get_MessageDiskUsage(This,plFactor,pVal)

#define IP3User_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IP3User_get_EmailName(This,pVal)	\
    (This)->lpVtbl -> get_EmailName(This,pVal)

#define IP3User_GetMessageDiskUsage(This,pvFactor,pvValue)	\
    (This)->lpVtbl -> GetMessageDiskUsage(This,pvFactor,pvValue)

#define IP3User_CreateQuotaFile(This,bstrMachineName,bstrUserName)	\
    (This)->lpVtbl -> CreateQuotaFile(This,bstrMachineName,bstrUserName)

#define IP3User_get_ClientConfigDesc(This,pVal)	\
    (This)->lpVtbl -> get_ClientConfigDesc(This,pVal)

#define IP3User_get_SAMName(This,pVal)	\
    (This)->lpVtbl -> get_SAMName(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3User_get_Lock_Proxy( 
    IP3User * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IP3User_get_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3User_put_Lock_Proxy( 
    IP3User * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IP3User_put_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3User_get_MessageCount_Proxy( 
    IP3User * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3User_get_MessageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3User_get_MessageDiskUsage_Proxy( 
    IP3User * This,
    /* [out] */ long *plFactor,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3User_get_MessageDiskUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3User_get_Name_Proxy( 
    IP3User * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IP3User_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3User_get_EmailName_Proxy( 
    IP3User * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IP3User_get_EmailName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3User_GetMessageDiskUsage_Proxy( 
    IP3User * This,
    /* [out] */ VARIANT *pvFactor,
    /* [out] */ VARIANT *pvValue);


void __RPC_STUB IP3User_GetMessageDiskUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3User_CreateQuotaFile_Proxy( 
    IP3User * This,
    /* [in] */ BSTR bstrMachineName,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB IP3User_CreateQuotaFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3User_get_ClientConfigDesc_Proxy( 
    IP3User * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IP3User_get_ClientConfigDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3User_get_SAMName_Proxy( 
    IP3User * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IP3User_get_SAMName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IP3User_INTERFACE_DEFINED__ */


#ifndef __IP3Users_INTERFACE_DEFINED__
#define __IP3Users_INTERFACE_DEFINED__

/* interface IP3Users */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IP3Users;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67F74F11-C5FB-4BBE-9AC6-86534B08745F")
    IP3Users : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIEnumVARIANT) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IP3User **ppIUser) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR bstrUserName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddEx( 
            /* [in] */ BSTR bstrUserName,
            /* [in] */ BSTR bstrPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveEx( 
            /* [in] */ BSTR bstrUserName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IP3UsersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IP3Users * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IP3Users * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IP3Users * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IP3Users * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IP3Users * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IP3Users * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IP3Users * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IP3Users * This,
            /* [retval][out] */ IEnumVARIANT **ppIEnumVARIANT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IP3Users * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IP3Users * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IP3User **ppIUser);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IP3Users * This,
            /* [in] */ BSTR bstrUserName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IP3Users * This,
            /* [in] */ BSTR bstrUserName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddEx )( 
            IP3Users * This,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ BSTR bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveEx )( 
            IP3Users * This,
            /* [in] */ BSTR bstrUserName);
        
        END_INTERFACE
    } IP3UsersVtbl;

    interface IP3Users
    {
        CONST_VTBL struct IP3UsersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IP3Users_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IP3Users_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IP3Users_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IP3Users_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IP3Users_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IP3Users_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IP3Users_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IP3Users_get__NewEnum(This,ppIEnumVARIANT)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIEnumVARIANT)

#define IP3Users_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IP3Users_get_Item(This,vIndex,ppIUser)	\
    (This)->lpVtbl -> get_Item(This,vIndex,ppIUser)

#define IP3Users_Add(This,bstrUserName)	\
    (This)->lpVtbl -> Add(This,bstrUserName)

#define IP3Users_Remove(This,bstrUserName)	\
    (This)->lpVtbl -> Remove(This,bstrUserName)

#define IP3Users_AddEx(This,bstrUserName,bstrPassword)	\
    (This)->lpVtbl -> AddEx(This,bstrUserName,bstrPassword)

#define IP3Users_RemoveEx(This,bstrUserName)	\
    (This)->lpVtbl -> RemoveEx(This,bstrUserName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Users_get__NewEnum_Proxy( 
    IP3Users * This,
    /* [retval][out] */ IEnumVARIANT **ppIEnumVARIANT);


void __RPC_STUB IP3Users_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Users_get_Count_Proxy( 
    IP3Users * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Users_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Users_get_Item_Proxy( 
    IP3Users * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IP3User **ppIUser);


void __RPC_STUB IP3Users_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Users_Add_Proxy( 
    IP3Users * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB IP3Users_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Users_Remove_Proxy( 
    IP3Users * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB IP3Users_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Users_AddEx_Proxy( 
    IP3Users * This,
    /* [in] */ BSTR bstrUserName,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB IP3Users_AddEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Users_RemoveEx_Proxy( 
    IP3Users * This,
    /* [in] */ BSTR bstrUserName);


void __RPC_STUB IP3Users_RemoveEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IP3Users_INTERFACE_DEFINED__ */


#ifndef __IP3Domain_INTERFACE_DEFINED__
#define __IP3Domain_INTERFACE_DEFINED__

/* interface IP3Domain */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IP3Domain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01C343C8-64BE-463E-BEFD-1A8CF2EDD2C7")
    IP3Domain : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Users( 
            /* [retval][out] */ IP3Users **ppIP3Users) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Lock( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Lock( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MessageCount( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MessageDiskUsage( 
            /* [out] */ long *plFactor,
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessageDiskUsage( 
            /* [out] */ VARIANT *pvFactor,
            /* [out] */ VARIANT *pvValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IP3DomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IP3Domain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IP3Domain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IP3Domain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IP3Domain * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IP3Domain * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IP3Domain * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IP3Domain * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Users )( 
            IP3Domain * This,
            /* [retval][out] */ IP3Users **ppIP3Users);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Lock )( 
            IP3Domain * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Lock )( 
            IP3Domain * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageCount )( 
            IP3Domain * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageDiskUsage )( 
            IP3Domain * This,
            /* [out] */ long *plFactor,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IP3Domain * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessageDiskUsage )( 
            IP3Domain * This,
            /* [out] */ VARIANT *pvFactor,
            /* [out] */ VARIANT *pvValue);
        
        END_INTERFACE
    } IP3DomainVtbl;

    interface IP3Domain
    {
        CONST_VTBL struct IP3DomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IP3Domain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IP3Domain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IP3Domain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IP3Domain_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IP3Domain_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IP3Domain_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IP3Domain_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IP3Domain_get_Users(This,ppIP3Users)	\
    (This)->lpVtbl -> get_Users(This,ppIP3Users)

#define IP3Domain_get_Lock(This,pVal)	\
    (This)->lpVtbl -> get_Lock(This,pVal)

#define IP3Domain_put_Lock(This,newVal)	\
    (This)->lpVtbl -> put_Lock(This,newVal)

#define IP3Domain_get_MessageCount(This,pVal)	\
    (This)->lpVtbl -> get_MessageCount(This,pVal)

#define IP3Domain_get_MessageDiskUsage(This,plFactor,pVal)	\
    (This)->lpVtbl -> get_MessageDiskUsage(This,plFactor,pVal)

#define IP3Domain_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IP3Domain_GetMessageDiskUsage(This,pvFactor,pvValue)	\
    (This)->lpVtbl -> GetMessageDiskUsage(This,pvFactor,pvValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Domain_get_Users_Proxy( 
    IP3Domain * This,
    /* [retval][out] */ IP3Users **ppIP3Users);


void __RPC_STUB IP3Domain_get_Users_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Domain_get_Lock_Proxy( 
    IP3Domain * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IP3Domain_get_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3Domain_put_Lock_Proxy( 
    IP3Domain * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IP3Domain_put_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Domain_get_MessageCount_Proxy( 
    IP3Domain * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Domain_get_MessageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Domain_get_MessageDiskUsage_Proxy( 
    IP3Domain * This,
    /* [out] */ long *plFactor,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Domain_get_MessageDiskUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Domain_get_Name_Proxy( 
    IP3Domain * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IP3Domain_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Domain_GetMessageDiskUsage_Proxy( 
    IP3Domain * This,
    /* [out] */ VARIANT *pvFactor,
    /* [out] */ VARIANT *pvValue);


void __RPC_STUB IP3Domain_GetMessageDiskUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IP3Domain_INTERFACE_DEFINED__ */


#ifndef __IP3Domains_INTERFACE_DEFINED__
#define __IP3Domains_INTERFACE_DEFINED__

/* interface IP3Domains */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IP3Domains;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD604138-18C1-4DC5-A9F0-4A440AB45DA5")
    IP3Domains : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIEnumVARIANT) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IP3Domain **ppIP3Domain) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrDomainName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR bstrDomainName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchForMailbox( 
            /* [in] */ BSTR bstrUserName,
            /* [out] */ BSTR *pbstrDomainName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IP3DomainsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IP3Domains * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IP3Domains * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IP3Domains * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IP3Domains * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IP3Domains * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IP3Domains * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IP3Domains * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IP3Domains * This,
            /* [retval][out] */ IEnumVARIANT **ppIEnumVARIANT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IP3Domains * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IP3Domains * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IP3Domain **ppIP3Domain);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IP3Domains * This,
            /* [in] */ BSTR bstrDomainName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IP3Domains * This,
            /* [in] */ BSTR bstrDomainName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchForMailbox )( 
            IP3Domains * This,
            /* [in] */ BSTR bstrUserName,
            /* [out] */ BSTR *pbstrDomainName);
        
        END_INTERFACE
    } IP3DomainsVtbl;

    interface IP3Domains
    {
        CONST_VTBL struct IP3DomainsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IP3Domains_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IP3Domains_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IP3Domains_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IP3Domains_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IP3Domains_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IP3Domains_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IP3Domains_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IP3Domains_get__NewEnum(This,ppIEnumVARIANT)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIEnumVARIANT)

#define IP3Domains_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IP3Domains_get_Item(This,vIndex,ppIP3Domain)	\
    (This)->lpVtbl -> get_Item(This,vIndex,ppIP3Domain)

#define IP3Domains_Add(This,bstrDomainName)	\
    (This)->lpVtbl -> Add(This,bstrDomainName)

#define IP3Domains_Remove(This,bstrDomainName)	\
    (This)->lpVtbl -> Remove(This,bstrDomainName)

#define IP3Domains_SearchForMailbox(This,bstrUserName,pbstrDomainName)	\
    (This)->lpVtbl -> SearchForMailbox(This,bstrUserName,pbstrDomainName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Domains_get__NewEnum_Proxy( 
    IP3Domains * This,
    /* [retval][out] */ IEnumVARIANT **ppIEnumVARIANT);


void __RPC_STUB IP3Domains_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Domains_get_Count_Proxy( 
    IP3Domains * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Domains_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Domains_get_Item_Proxy( 
    IP3Domains * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IP3Domain **ppIP3Domain);


void __RPC_STUB IP3Domains_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Domains_Add_Proxy( 
    IP3Domains * This,
    /* [in] */ BSTR bstrDomainName);


void __RPC_STUB IP3Domains_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Domains_Remove_Proxy( 
    IP3Domains * This,
    /* [in] */ BSTR bstrDomainName);


void __RPC_STUB IP3Domains_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Domains_SearchForMailbox_Proxy( 
    IP3Domains * This,
    /* [in] */ BSTR bstrUserName,
    /* [out] */ BSTR *pbstrDomainName);


void __RPC_STUB IP3Domains_SearchForMailbox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IP3Domains_INTERFACE_DEFINED__ */


#ifndef __IP3Service_INTERFACE_DEFINED__
#define __IP3Service_INTERFACE_DEFINED__

/* interface IP3Service */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IP3Service;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EA6F3C46-469A-4D9B-87B0-86D4C323FBA1")
    IP3Service : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ThreadCountPerCPU( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ThreadCountPerCPU( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SocketsMax( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SocketsMin( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SocketsThreshold( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSockets( 
            /* [in] */ long lMax,
            /* [in] */ long lMin,
            /* [in] */ long lThreshold,
            /* [in] */ long lBacklog) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SocketsBacklog( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Port( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SPARequired( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SPARequired( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_POP3ServiceStatus( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartPOP3Service( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopPOP3Service( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PausePOP3Service( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResumePOP3Service( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPServiceStatus( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartSMTPService( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopSMTPService( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseSMTPService( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResumeSMTPService( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IISAdminServiceStatus( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartIISAdminService( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopIISAdminService( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseIISAdminService( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResumeIISAdminService( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_W3ServiceStatus( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartW3Service( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopW3Service( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseW3Service( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResumeW3Service( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IP3ServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IP3Service * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IP3Service * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IP3Service * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IP3Service * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IP3Service * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IP3Service * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IP3Service * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ThreadCountPerCPU )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ThreadCountPerCPU )( 
            IP3Service * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SocketsMax )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SocketsMin )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SocketsThreshold )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSockets )( 
            IP3Service * This,
            /* [in] */ long lMax,
            /* [in] */ long lMin,
            /* [in] */ long lThreshold,
            /* [in] */ long lBacklog);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SocketsBacklog )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Port )( 
            IP3Service * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPARequired )( 
            IP3Service * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPARequired )( 
            IP3Service * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_POP3ServiceStatus )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartPOP3Service )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopPOP3Service )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PausePOP3Service )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResumePOP3Service )( 
            IP3Service * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPServiceStatus )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartSMTPService )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopSMTPService )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PauseSMTPService )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResumeSMTPService )( 
            IP3Service * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IISAdminServiceStatus )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartIISAdminService )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopIISAdminService )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PauseIISAdminService )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResumeIISAdminService )( 
            IP3Service * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_W3ServiceStatus )( 
            IP3Service * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartW3Service )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopW3Service )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PauseW3Service )( 
            IP3Service * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResumeW3Service )( 
            IP3Service * This);
        
        END_INTERFACE
    } IP3ServiceVtbl;

    interface IP3Service
    {
        CONST_VTBL struct IP3ServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IP3Service_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IP3Service_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IP3Service_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IP3Service_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IP3Service_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IP3Service_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IP3Service_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IP3Service_get_ThreadCountPerCPU(This,pVal)	\
    (This)->lpVtbl -> get_ThreadCountPerCPU(This,pVal)

#define IP3Service_put_ThreadCountPerCPU(This,newVal)	\
    (This)->lpVtbl -> put_ThreadCountPerCPU(This,newVal)

#define IP3Service_get_SocketsMax(This,pVal)	\
    (This)->lpVtbl -> get_SocketsMax(This,pVal)

#define IP3Service_get_SocketsMin(This,pVal)	\
    (This)->lpVtbl -> get_SocketsMin(This,pVal)

#define IP3Service_get_SocketsThreshold(This,pVal)	\
    (This)->lpVtbl -> get_SocketsThreshold(This,pVal)

#define IP3Service_SetSockets(This,lMax,lMin,lThreshold,lBacklog)	\
    (This)->lpVtbl -> SetSockets(This,lMax,lMin,lThreshold,lBacklog)

#define IP3Service_get_SocketsBacklog(This,pVal)	\
    (This)->lpVtbl -> get_SocketsBacklog(This,pVal)

#define IP3Service_get_Port(This,pVal)	\
    (This)->lpVtbl -> get_Port(This,pVal)

#define IP3Service_put_Port(This,newVal)	\
    (This)->lpVtbl -> put_Port(This,newVal)

#define IP3Service_get_SPARequired(This,pVal)	\
    (This)->lpVtbl -> get_SPARequired(This,pVal)

#define IP3Service_put_SPARequired(This,newVal)	\
    (This)->lpVtbl -> put_SPARequired(This,newVal)

#define IP3Service_get_POP3ServiceStatus(This,pVal)	\
    (This)->lpVtbl -> get_POP3ServiceStatus(This,pVal)

#define IP3Service_StartPOP3Service(This)	\
    (This)->lpVtbl -> StartPOP3Service(This)

#define IP3Service_StopPOP3Service(This)	\
    (This)->lpVtbl -> StopPOP3Service(This)

#define IP3Service_PausePOP3Service(This)	\
    (This)->lpVtbl -> PausePOP3Service(This)

#define IP3Service_ResumePOP3Service(This)	\
    (This)->lpVtbl -> ResumePOP3Service(This)

#define IP3Service_get_SMTPServiceStatus(This,pVal)	\
    (This)->lpVtbl -> get_SMTPServiceStatus(This,pVal)

#define IP3Service_StartSMTPService(This)	\
    (This)->lpVtbl -> StartSMTPService(This)

#define IP3Service_StopSMTPService(This)	\
    (This)->lpVtbl -> StopSMTPService(This)

#define IP3Service_PauseSMTPService(This)	\
    (This)->lpVtbl -> PauseSMTPService(This)

#define IP3Service_ResumeSMTPService(This)	\
    (This)->lpVtbl -> ResumeSMTPService(This)

#define IP3Service_get_IISAdminServiceStatus(This,pVal)	\
    (This)->lpVtbl -> get_IISAdminServiceStatus(This,pVal)

#define IP3Service_StartIISAdminService(This)	\
    (This)->lpVtbl -> StartIISAdminService(This)

#define IP3Service_StopIISAdminService(This)	\
    (This)->lpVtbl -> StopIISAdminService(This)

#define IP3Service_PauseIISAdminService(This)	\
    (This)->lpVtbl -> PauseIISAdminService(This)

#define IP3Service_ResumeIISAdminService(This)	\
    (This)->lpVtbl -> ResumeIISAdminService(This)

#define IP3Service_get_W3ServiceStatus(This,pVal)	\
    (This)->lpVtbl -> get_W3ServiceStatus(This,pVal)

#define IP3Service_StartW3Service(This)	\
    (This)->lpVtbl -> StartW3Service(This)

#define IP3Service_StopW3Service(This)	\
    (This)->lpVtbl -> StopW3Service(This)

#define IP3Service_PauseW3Service(This)	\
    (This)->lpVtbl -> PauseW3Service(This)

#define IP3Service_ResumeW3Service(This)	\
    (This)->lpVtbl -> ResumeW3Service(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_ThreadCountPerCPU_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_ThreadCountPerCPU_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3Service_put_ThreadCountPerCPU_Proxy( 
    IP3Service * This,
    /* [in] */ long newVal);


void __RPC_STUB IP3Service_put_ThreadCountPerCPU_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_SocketsMax_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_SocketsMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_SocketsMin_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_SocketsMin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_SocketsThreshold_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_SocketsThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_SetSockets_Proxy( 
    IP3Service * This,
    /* [in] */ long lMax,
    /* [in] */ long lMin,
    /* [in] */ long lThreshold,
    /* [in] */ long lBacklog);


void __RPC_STUB IP3Service_SetSockets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_SocketsBacklog_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_SocketsBacklog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_Port_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3Service_put_Port_Proxy( 
    IP3Service * This,
    /* [in] */ long newVal);


void __RPC_STUB IP3Service_put_Port_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_SPARequired_Proxy( 
    IP3Service * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IP3Service_get_SPARequired_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3Service_put_SPARequired_Proxy( 
    IP3Service * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IP3Service_put_SPARequired_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_POP3ServiceStatus_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_POP3ServiceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_StartPOP3Service_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_StartPOP3Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_StopPOP3Service_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_StopPOP3Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_PausePOP3Service_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_PausePOP3Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_ResumePOP3Service_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_ResumePOP3Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_SMTPServiceStatus_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_SMTPServiceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_StartSMTPService_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_StartSMTPService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_StopSMTPService_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_StopSMTPService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_PauseSMTPService_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_PauseSMTPService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_ResumeSMTPService_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_ResumeSMTPService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_IISAdminServiceStatus_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_IISAdminServiceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_StartIISAdminService_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_StartIISAdminService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_StopIISAdminService_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_StopIISAdminService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_PauseIISAdminService_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_PauseIISAdminService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_ResumeIISAdminService_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_ResumeIISAdminService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Service_get_W3ServiceStatus_Proxy( 
    IP3Service * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Service_get_W3ServiceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_StartW3Service_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_StartW3Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_StopW3Service_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_StopW3Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_PauseW3Service_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_PauseW3Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Service_ResumeW3Service_Proxy( 
    IP3Service * This);


void __RPC_STUB IP3Service_ResumeW3Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IP3Service_INTERFACE_DEFINED__ */


#ifndef __IP3Config_INTERFACE_DEFINED__
#define __IP3Config_INTERFACE_DEFINED__

/* interface IP3Config */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IP3Config;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA7B7F6D-87E7-44F0-9294-153714B0D9CC")
    IP3Config : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IISConfig( 
            /* [in] */ BOOL bRegister) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Service( 
            /* [retval][out] */ IP3Service **ppIService) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Domains( 
            /* [retval][out] */ IP3Domains **ppIDomains) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingLevel( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoggingLevel( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MailRoot( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MailRoot( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Authentication( 
            /* [retval][out] */ IAuthMethods **ppIAuthMethods) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MachineName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MachineName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFormattedMessage( 
            /* [in] */ long lError,
            /* [out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConfirmAddUser( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConfirmAddUser( 
            /* [in] */ BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IP3ConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IP3Config * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IP3Config * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IP3Config * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IP3Config * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IP3Config * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IP3Config * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IP3Config * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IISConfig )( 
            IP3Config * This,
            /* [in] */ BOOL bRegister);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Service )( 
            IP3Config * This,
            /* [retval][out] */ IP3Service **ppIService);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IP3Config * This,
            /* [retval][out] */ IP3Domains **ppIDomains);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingLevel )( 
            IP3Config * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoggingLevel )( 
            IP3Config * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MailRoot )( 
            IP3Config * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MailRoot )( 
            IP3Config * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authentication )( 
            IP3Config * This,
            /* [retval][out] */ IAuthMethods **ppIAuthMethods);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MachineName )( 
            IP3Config * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MachineName )( 
            IP3Config * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFormattedMessage )( 
            IP3Config * This,
            /* [in] */ long lError,
            /* [out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConfirmAddUser )( 
            IP3Config * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConfirmAddUser )( 
            IP3Config * This,
            /* [in] */ BOOL newVal);
        
        END_INTERFACE
    } IP3ConfigVtbl;

    interface IP3Config
    {
        CONST_VTBL struct IP3ConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IP3Config_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IP3Config_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IP3Config_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IP3Config_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IP3Config_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IP3Config_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IP3Config_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IP3Config_IISConfig(This,bRegister)	\
    (This)->lpVtbl -> IISConfig(This,bRegister)

#define IP3Config_get_Service(This,ppIService)	\
    (This)->lpVtbl -> get_Service(This,ppIService)

#define IP3Config_get_Domains(This,ppIDomains)	\
    (This)->lpVtbl -> get_Domains(This,ppIDomains)

#define IP3Config_get_LoggingLevel(This,pVal)	\
    (This)->lpVtbl -> get_LoggingLevel(This,pVal)

#define IP3Config_put_LoggingLevel(This,newVal)	\
    (This)->lpVtbl -> put_LoggingLevel(This,newVal)

#define IP3Config_get_MailRoot(This,pVal)	\
    (This)->lpVtbl -> get_MailRoot(This,pVal)

#define IP3Config_put_MailRoot(This,newVal)	\
    (This)->lpVtbl -> put_MailRoot(This,newVal)

#define IP3Config_get_Authentication(This,ppIAuthMethods)	\
    (This)->lpVtbl -> get_Authentication(This,ppIAuthMethods)

#define IP3Config_get_MachineName(This,pVal)	\
    (This)->lpVtbl -> get_MachineName(This,pVal)

#define IP3Config_put_MachineName(This,newVal)	\
    (This)->lpVtbl -> put_MachineName(This,newVal)

#define IP3Config_GetFormattedMessage(This,lError,pVal)	\
    (This)->lpVtbl -> GetFormattedMessage(This,lError,pVal)

#define IP3Config_get_ConfirmAddUser(This,pVal)	\
    (This)->lpVtbl -> get_ConfirmAddUser(This,pVal)

#define IP3Config_put_ConfirmAddUser(This,newVal)	\
    (This)->lpVtbl -> put_ConfirmAddUser(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Config_IISConfig_Proxy( 
    IP3Config * This,
    /* [in] */ BOOL bRegister);


void __RPC_STUB IP3Config_IISConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Config_get_Service_Proxy( 
    IP3Config * This,
    /* [retval][out] */ IP3Service **ppIService);


void __RPC_STUB IP3Config_get_Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Config_get_Domains_Proxy( 
    IP3Config * This,
    /* [retval][out] */ IP3Domains **ppIDomains);


void __RPC_STUB IP3Config_get_Domains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Config_get_LoggingLevel_Proxy( 
    IP3Config * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IP3Config_get_LoggingLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3Config_put_LoggingLevel_Proxy( 
    IP3Config * This,
    /* [in] */ long newVal);


void __RPC_STUB IP3Config_put_LoggingLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Config_get_MailRoot_Proxy( 
    IP3Config * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IP3Config_get_MailRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3Config_put_MailRoot_Proxy( 
    IP3Config * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IP3Config_put_MailRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Config_get_Authentication_Proxy( 
    IP3Config * This,
    /* [retval][out] */ IAuthMethods **ppIAuthMethods);


void __RPC_STUB IP3Config_get_Authentication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Config_get_MachineName_Proxy( 
    IP3Config * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IP3Config_get_MachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3Config_put_MachineName_Proxy( 
    IP3Config * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IP3Config_put_MachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IP3Config_GetFormattedMessage_Proxy( 
    IP3Config * This,
    /* [in] */ long lError,
    /* [out] */ VARIANT *pVal);


void __RPC_STUB IP3Config_GetFormattedMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IP3Config_get_ConfirmAddUser_Proxy( 
    IP3Config * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IP3Config_get_ConfirmAddUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IP3Config_put_ConfirmAddUser_Proxy( 
    IP3Config * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IP3Config_put_ConfirmAddUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IP3Config_INTERFACE_DEFINED__ */



#ifndef __P3ADMINLib_LIBRARY_DEFINED__
#define __P3ADMINLib_LIBRARY_DEFINED__

/* library P3ADMINLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_P3ADMINLib;

EXTERN_C const CLSID CLSID_P3Config;

#ifdef __cplusplus

class DECLSPEC_UUID("27AAC95F-CCC1-46F8-B4BC-E592252755A9")
P3Config;
#endif

EXTERN_C const CLSID CLSID_P3Domains;

#ifdef __cplusplus

class DECLSPEC_UUID("3C26DBFB-0C9E-46E7-9DB4-34F0DBF06C98")
P3Domains;
#endif

EXTERN_C const CLSID CLSID_P3Domain;

#ifdef __cplusplus

class DECLSPEC_UUID("76E18025-DE1C-4FFB-A379-F9785E31287D")
P3Domain;
#endif

EXTERN_C const CLSID CLSID_P3Users;

#ifdef __cplusplus

class DECLSPEC_UUID("725E9D04-FD47-4DA2-BE5F-9FCC133351B1")
P3Users;
#endif

EXTERN_C const CLSID CLSID_P3Service;

#ifdef __cplusplus

class DECLSPEC_UUID("BD180BA8-CA05-4364-9CDD-44DB27CF40B8")
P3Service;
#endif

EXTERN_C const CLSID CLSID_P3DomainEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("4BB57E54-E2A7-452B-BE9E-66BDEC0B1D1A")
P3DomainEnum;
#endif

EXTERN_C const CLSID CLSID_P3User;

#ifdef __cplusplus

class DECLSPEC_UUID("22659E85-FA75-438C-8B31-093B6C29C060")
P3User;
#endif

EXTERN_C const CLSID CLSID_P3UserEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("8CB44364-D42D-4B98-8AD0-FF7AFCF68050")
P3UserEnum;
#endif
#endif /* __P3ADMINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetsrv\inc\pop3auth.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for pop3auth.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __pop3auth_h__
#define __pop3auth_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAuthMethod_FWD_DEFINED__
#define __IAuthMethod_FWD_DEFINED__
typedef interface IAuthMethod IAuthMethod;
#endif 	/* __IAuthMethod_FWD_DEFINED__ */


#ifndef __IAuthMethods_FWD_DEFINED__
#define __IAuthMethods_FWD_DEFINED__
typedef interface IAuthMethods IAuthMethods;
#endif 	/* __IAuthMethods_FWD_DEFINED__ */


#ifndef __AuthMethods_FWD_DEFINED__
#define __AuthMethods_FWD_DEFINED__

#ifdef __cplusplus
typedef class AuthMethods AuthMethods;
#else
typedef struct AuthMethods AuthMethods;
#endif /* __cplusplus */

#endif 	/* __AuthMethods_FWD_DEFINED__ */


#ifndef __AuthLocalAccount_FWD_DEFINED__
#define __AuthLocalAccount_FWD_DEFINED__

#ifdef __cplusplus
typedef class AuthLocalAccount AuthLocalAccount;
#else
typedef struct AuthLocalAccount AuthLocalAccount;
#endif /* __cplusplus */

#endif 	/* __AuthLocalAccount_FWD_DEFINED__ */


#ifndef __AuthDomainAccount_FWD_DEFINED__
#define __AuthDomainAccount_FWD_DEFINED__

#ifdef __cplusplus
typedef class AuthDomainAccount AuthDomainAccount;
#else
typedef struct AuthDomainAccount AuthDomainAccount;
#endif /* __cplusplus */

#endif 	/* __AuthDomainAccount_FWD_DEFINED__ */


#ifndef __AuthMD5Hash_FWD_DEFINED__
#define __AuthMD5Hash_FWD_DEFINED__

#ifdef __cplusplus
typedef class AuthMD5Hash AuthMD5Hash;
#else
typedef struct AuthMD5Hash AuthMD5Hash;
#endif /* __cplusplus */

#endif 	/* __AuthMD5Hash_FWD_DEFINED__ */


#ifndef __AuthMethodsEnum_FWD_DEFINED__
#define __AuthMethodsEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class AuthMethodsEnum AuthMethodsEnum;
#else
typedef struct AuthMethodsEnum AuthMethodsEnum;
#endif /* __cplusplus */

#endif 	/* __AuthMethodsEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_pop3auth_0000 */
/* [local] */ 

#define SZ_PROPNAME_MAIL_ROOT		_T("MailRoot")
#define SZ_PROPNAME_SERVER_RESPONSE  _T("ServerResponse")
#define SZ_PASSWORD_DESC				_T("EncryptedPassword")
#define SZ_SERVER_NAME				_T("ServerName")
#define SZ_EMAILADDR					_T("EmailAddress")
#define SZ_USERPRICIPALNAME			_T("UserPrincipalName")
#define SZ_SAMACCOUNT_NAME			_T("SAMAccountName")
#define NO_DOMAIN				1
#define DOMAIN_NONE_DC           2
#define DOMAIN_CONTROLLER		4
#define MAX_USER_NAME_LENGTH    20


extern RPC_IF_HANDLE __MIDL_itf_pop3auth_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_pop3auth_0000_v0_0_s_ifspec;

#ifndef __IAuthMethod_INTERFACE_DEFINED__
#define __IAuthMethod_INTERFACE_DEFINED__

/* interface IAuthMethod */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAuthMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4b0acca9-859a-4909-bf9f-b694801a6f44")
    IAuthMethod : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [in] */ BSTR bstrUserName,
            /* [in] */ VARIANT vPassword) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUser( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteUser( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChangePassword( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vNewPassword,
            /* [in] */ VARIANT vOldPassword) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateEmailWithUser( 
            /* [in] */ BSTR bstrEmailAddr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnassociateEmailWithUser( 
            /* [in] */ BSTR bstrEmailAddr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAuthMethod * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAuthMethod * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAuthMethod * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAuthMethod * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAuthMethod * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAuthMethod * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAuthMethod * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Authenticate )( 
            IAuthMethod * This,
            /* [in] */ BSTR bstrUserName,
            /* [in] */ VARIANT vPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IAuthMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IAuthMethod * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IAuthMethod * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUser )( 
            IAuthMethod * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteUser )( 
            IAuthMethod * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChangePassword )( 
            IAuthMethod * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT vNewPassword,
            /* [in] */ VARIANT vOldPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IAuthMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AssociateEmailWithUser )( 
            IAuthMethod * This,
            /* [in] */ BSTR bstrEmailAddr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnassociateEmailWithUser )( 
            IAuthMethod * This,
            /* [in] */ BSTR bstrEmailAddr);
        
        END_INTERFACE
    } IAuthMethodVtbl;

    interface IAuthMethod
    {
        CONST_VTBL struct IAuthMethodVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuthMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuthMethod_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAuthMethod_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAuthMethod_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAuthMethod_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAuthMethod_Authenticate(This,bstrUserName,vPassword)	\
    (This)->lpVtbl -> Authenticate(This,bstrUserName,vPassword)

#define IAuthMethod_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IAuthMethod_Get(This,bstrName,pVal)	\
    (This)->lpVtbl -> Get(This,bstrName,pVal)

#define IAuthMethod_Put(This,bstrName,vVal)	\
    (This)->lpVtbl -> Put(This,bstrName,vVal)

#define IAuthMethod_CreateUser(This,bstrName,vPassword)	\
    (This)->lpVtbl -> CreateUser(This,bstrName,vPassword)

#define IAuthMethod_DeleteUser(This,bstrName)	\
    (This)->lpVtbl -> DeleteUser(This,bstrName)

#define IAuthMethod_ChangePassword(This,bstrName,vNewPassword,vOldPassword)	\
    (This)->lpVtbl -> ChangePassword(This,bstrName,vNewPassword,vOldPassword)

#define IAuthMethod_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IAuthMethod_AssociateEmailWithUser(This,bstrEmailAddr)	\
    (This)->lpVtbl -> AssociateEmailWithUser(This,bstrEmailAddr)

#define IAuthMethod_UnassociateEmailWithUser(This,bstrEmailAddr)	\
    (This)->lpVtbl -> UnassociateEmailWithUser(This,bstrEmailAddr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethod_Authenticate_Proxy( 
    IAuthMethod * This,
    /* [in] */ BSTR bstrUserName,
    /* [in] */ VARIANT vPassword);


void __RPC_STUB IAuthMethod_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAuthMethod_get_Name_Proxy( 
    IAuthMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAuthMethod_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethod_Get_Proxy( 
    IAuthMethod * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IAuthMethod_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethod_Put_Proxy( 
    IAuthMethod * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ VARIANT vVal);


void __RPC_STUB IAuthMethod_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethod_CreateUser_Proxy( 
    IAuthMethod * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ VARIANT vPassword);


void __RPC_STUB IAuthMethod_CreateUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethod_DeleteUser_Proxy( 
    IAuthMethod * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IAuthMethod_DeleteUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethod_ChangePassword_Proxy( 
    IAuthMethod * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ VARIANT vNewPassword,
    /* [in] */ VARIANT vOldPassword);


void __RPC_STUB IAuthMethod_ChangePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAuthMethod_get_ID_Proxy( 
    IAuthMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAuthMethod_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethod_AssociateEmailWithUser_Proxy( 
    IAuthMethod * This,
    /* [in] */ BSTR bstrEmailAddr);


void __RPC_STUB IAuthMethod_AssociateEmailWithUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethod_UnassociateEmailWithUser_Proxy( 
    IAuthMethod * This,
    /* [in] */ BSTR bstrEmailAddr);


void __RPC_STUB IAuthMethod_UnassociateEmailWithUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuthMethod_INTERFACE_DEFINED__ */


#ifndef __IAuthMethods_INTERFACE_DEFINED__
#define __IAuthMethods_INTERFACE_DEFINED__

/* interface IAuthMethods */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAuthMethods;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("679729c4-198c-4fd7-800d-7093cadf5d69")
    IAuthMethods : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vID,
            /* [retval][out] */ IAuthMethod **ppVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrGUID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT vID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAuthMethod( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentAuthMethod( 
            /* [in] */ VARIANT vID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MachineName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MachineName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE VerifyCurrentAuthMethod( 
            int iIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthMethodsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAuthMethods * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAuthMethods * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAuthMethods * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAuthMethods * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAuthMethods * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAuthMethods * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAuthMethods * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IAuthMethods * This,
            /* [retval][out] */ IEnumVARIANT **ppVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAuthMethods * This,
            /* [retval][out] */ LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IAuthMethods * This,
            /* [in] */ VARIANT vID,
            /* [retval][out] */ IAuthMethod **ppVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IAuthMethods * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrGUID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IAuthMethods * This,
            /* [in] */ VARIANT vID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IAuthMethods * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAuthMethod )( 
            IAuthMethods * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentAuthMethod )( 
            IAuthMethods * This,
            /* [in] */ VARIANT vID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MachineName )( 
            IAuthMethods * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MachineName )( 
            IAuthMethods * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *VerifyCurrentAuthMethod )( 
            IAuthMethods * This,
            int iIndex);
        
        END_INTERFACE
    } IAuthMethodsVtbl;

    interface IAuthMethods
    {
        CONST_VTBL struct IAuthMethodsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthMethods_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthMethods_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuthMethods_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuthMethods_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAuthMethods_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAuthMethods_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAuthMethods_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAuthMethods_get__NewEnum(This,ppVal)	\
    (This)->lpVtbl -> get__NewEnum(This,ppVal)

#define IAuthMethods_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IAuthMethods_get_Item(This,vID,ppVal)	\
    (This)->lpVtbl -> get_Item(This,vID,ppVal)

#define IAuthMethods_Add(This,bstrName,bstrGUID)	\
    (This)->lpVtbl -> Add(This,bstrName,bstrGUID)

#define IAuthMethods_Remove(This,vID)	\
    (This)->lpVtbl -> Remove(This,vID)

#define IAuthMethods_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IAuthMethods_get_CurrentAuthMethod(This,pVal)	\
    (This)->lpVtbl -> get_CurrentAuthMethod(This,pVal)

#define IAuthMethods_put_CurrentAuthMethod(This,vID)	\
    (This)->lpVtbl -> put_CurrentAuthMethod(This,vID)

#define IAuthMethods_get_MachineName(This,pVal)	\
    (This)->lpVtbl -> get_MachineName(This,pVal)

#define IAuthMethods_put_MachineName(This,newVal)	\
    (This)->lpVtbl -> put_MachineName(This,newVal)

#define IAuthMethods_VerifyCurrentAuthMethod(This,iIndex)	\
    (This)->lpVtbl -> VerifyCurrentAuthMethod(This,iIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAuthMethods_get__NewEnum_Proxy( 
    IAuthMethods * This,
    /* [retval][out] */ IEnumVARIANT **ppVal);


void __RPC_STUB IAuthMethods_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAuthMethods_get_Count_Proxy( 
    IAuthMethods * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB IAuthMethods_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAuthMethods_get_Item_Proxy( 
    IAuthMethods * This,
    /* [in] */ VARIANT vID,
    /* [retval][out] */ IAuthMethod **ppVal);


void __RPC_STUB IAuthMethods_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethods_Add_Proxy( 
    IAuthMethods * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrGUID);


void __RPC_STUB IAuthMethods_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethods_Remove_Proxy( 
    IAuthMethods * This,
    /* [in] */ VARIANT vID);


void __RPC_STUB IAuthMethods_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethods_Save_Proxy( 
    IAuthMethods * This);


void __RPC_STUB IAuthMethods_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAuthMethods_get_CurrentAuthMethod_Proxy( 
    IAuthMethods * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IAuthMethods_get_CurrentAuthMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAuthMethods_put_CurrentAuthMethod_Proxy( 
    IAuthMethods * This,
    /* [in] */ VARIANT vID);


void __RPC_STUB IAuthMethods_put_CurrentAuthMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAuthMethods_get_MachineName_Proxy( 
    IAuthMethods * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAuthMethods_get_MachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAuthMethods_put_MachineName_Proxy( 
    IAuthMethods * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAuthMethods_put_MachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAuthMethods_VerifyCurrentAuthMethod_Proxy( 
    IAuthMethods * This,
    int iIndex);


void __RPC_STUB IAuthMethods_VerifyCurrentAuthMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuthMethods_INTERFACE_DEFINED__ */



#ifndef __Pop3Auth_LIBRARY_DEFINED__
#define __Pop3Auth_LIBRARY_DEFINED__

/* library Pop3Auth */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_Pop3Auth;

EXTERN_C const CLSID CLSID_AuthMethods;

#ifdef __cplusplus

class DECLSPEC_UUID("4330ab4e-a901-404a-9b24-d518901741f9")
AuthMethods;
#endif

EXTERN_C const CLSID CLSID_AuthLocalAccount;

#ifdef __cplusplus

class DECLSPEC_UUID("14f1665c-e3d3-46aa-884f-ed4cf19d7ad5")
AuthLocalAccount;
#endif

EXTERN_C const CLSID CLSID_AuthDomainAccount;

#ifdef __cplusplus

class DECLSPEC_UUID("ef9d811e-36c5-497f-ade7-2b36df172824")
AuthDomainAccount;
#endif

EXTERN_C const CLSID CLSID_AuthMD5Hash;

#ifdef __cplusplus

class DECLSPEC_UUID("c395e20c-2236-4af7-b736-54fad07dc526")
AuthMD5Hash;
#endif

EXTERN_C const CLSID CLSID_AuthMethodsEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("0feca139-a4ea-4097-bd73-8f5c78783c3f")
AuthMethodsEnum;
#endif
#endif /* __Pop3Auth_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetsrv\inc\ciodmguid.h ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for ciodm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAdminIndexServer,0x3BC4F3A0,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, IID_ICatAdm,0x3BC4F3A2,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, IID_IScopeAdm,0x3BC4F3A4,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, LIBID_CIODMLib,0x3BC4F393,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_AdminIndexServer,0x3BC4F3A1,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_CatAdm,0x3BC4F3A3,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_ScopeAdm,0x3BC4F3A7,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for ciodm.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAdminIndexServer,0x3BC4F3A0,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, IID_ICatAdm,0x3BC4F3A2,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, IID_IScopeAdm,0x3BC4F3A4,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, LIBID_CIODMLib,0x3BC4F393,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_AdminIndexServer,0x3BC4F3A1,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_CatAdm,0x3BC4F3A3,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_ScopeAdm,0x3BC4F3A7,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetsrv\inc\seoexports.h ===
//-----------------------------------------------------------------------------
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Description:
//      This header file defines stuff published by SEO to other (Microsoft
//      internal) projects in additon to the seo.idl file.
//
//-----------------------------------------------------------------------------

#ifndef __SEOEXPORTS_H__
#define __SEOEXPORTS_H__

class CStringGUID {
	public:
		CStringGUID() { m_bValid=FALSE; };
		CStringGUID(const CStringGUID& objGuid) { m_bValid=FALSE; Assign(objGuid); };
		CStringGUID(REFGUID rGuid) { m_bValid=FALSE; Assign(rGuid); };
		CStringGUID(LPCOLESTR pszGuid) { m_bValid=FALSE; Assign(pszGuid); };
		CStringGUID(LPCSTR pszGuid) { m_bValid=FALSE; Assign(pszGuid); };
		CStringGUID(const VARIANT *pvarGuid) { m_bValid=FALSE; Assign(pvarGuid); };
		CStringGUID(const VARIANT& varGuid) { m_bValid=FALSE; Assign(varGuid); };
		CStringGUID(REFGUID rGuid, DWORD dwIndex) {
			GUID tmp = rGuid;
			tmp.Data4[7] |= 0x80;
			tmp.Data2 = (WORD) (dwIndex >> 16);
			tmp.Data3 = (WORD) dwIndex;
			Assign(rGuid,dwIndex); };
		BOOL ReCalcFromGuid() {
			m_bValid = FALSE;
			if (SUCCEEDED(StringFromGUID2(m_guid,m_szGuidW,sizeof(m_szGuidW)/sizeof(m_szGuidW[0])))) {
				ATLW2AHELPER(m_szGuidA,m_szGuidW,sizeof(m_szGuidA)/sizeof(m_szGuidA[0])); m_bValid=TRUE; };
#ifdef DEBUG
			USES_CONVERSION;
			_ASSERTE(!m_bValid||(!strcmp(W2A(m_szGuidW),m_szGuidA)&&!wcscmp(m_szGuidW,A2W(m_szGuidA))));
#endif
			return (m_bValid); };
		BOOL CalcNew() {
			if (!SUCCEEDED(CoCreateGuid(&m_guid))) { m_bValid=FALSE; return (FALSE); };
			return (ReCalcFromGuid()); };
		BOOL CalcFromProgID(LPCOLESTR pszProgID) {
			if (!pszProgID || !SUCCEEDED(CLSIDFromProgID(pszProgID,&m_guid))) {
				m_bValid=FALSE; return (FALSE); };
			return (ReCalcFromGuid()); };
		BOOL CalcFromProgID(LPCSTR pszProgID) {
			USES_CONVERSION; return (CalcFromProgID(pszProgID?A2W(pszProgID):NULL)); };
		BOOL Assign(const CStringGUID& objGuid) { operator =(objGuid); return (m_bValid); };
		BOOL Assign(REFGUID rGuid) { operator =(rGuid); return (m_bValid); };
		BOOL Assign(LPCOLESTR pszGuid) { operator =(pszGuid); return (m_bValid); };
		BOOL Assign(LPCSTR pszGuid) { operator =(pszGuid); return (m_bValid); };
		BOOL Assign(const VARIANT *pvarGuid) { operator =(pvarGuid); return (m_bValid); };
		BOOL Assign(const VARIANT& varGuid) { operator =(varGuid); return (m_bValid); };
		BOOL Assign(REFGUID rGuid, DWORD dwIndex) {
			// For index'ed GUID's, we set the high-bit of the MAC-address in the GUID - this
			// is the multicast bit, and will never be set for any real MAC-address.  Then we
			// XOR the index value over the Data2 and Data 3 fields of the GUID.  Since we
			// leave the timestamp fields completely untouched, confidence is "high" that this
			// algorithm will never create collisions with any other GUID's.
			GUID tmp = rGuid;
			tmp.Data4[2] |= 0x80;
			tmp.Data2 ^= (WORD) (dwIndex >> 16);
			tmp.Data3 ^= (WORD) dwIndex;
			operator =(tmp);
			return (m_bValid); };
		BOOL GetIndex(REFGUID rGuid, DWORD *dwIndex) {
			// check to see if this is an indexed GUID by seeing if the
			// multicast bit is set to 1
			if ((m_guid.Data4[2] & 0x80) != 0x80) return FALSE;
			*dwIndex = 0;
			// get the high part
			*dwIndex = ((WORD) (rGuid.Data2) ^ (m_guid.Data2)) << 16;
			// get the low part
			*dwIndex += (WORD) ((rGuid.Data3) ^ (m_guid.Data3));
			// This does not check that rGuid mangles into m_guid
			// if you run it through the index function with dwIndex
			return TRUE;
		}
		operator REFGUID() { _ASSERTE(m_bValid); return (m_guid); };
		operator LPCOLESTR() { _ASSERTE(m_bValid); return (m_szGuidW); };
		operator LPCSTR() { _ASSERTE(m_bValid); return (m_szGuidA); };
		const CStringGUID& operator =(const CStringGUID& objGuid) {
			if (!objGuid) { m_bValid=FALSE; return (*this); };
			return (operator=((REFGUID) objGuid)); };
		const CStringGUID& operator =(REFGUID rGuid) {
			m_guid = rGuid; ReCalcFromGuid(); return (*this); };
		const CStringGUID& operator =(LPCOLESTR pszGuid) {
			m_bValid=FALSE;
			if (pszGuid && SUCCEEDED(CLSIDFromString((LPOLESTR) pszGuid,&m_guid))) ReCalcFromGuid();
			return (*this); };
		const CStringGUID& operator =(LPCSTR pszGuid) {
			USES_CONVERSION; return (operator=(pszGuid?A2W(pszGuid):NULL)); };
		const CStringGUID& operator =(const VARIANT *pvarGuid) {
			if (!pvarGuid) { m_bValid=FALSE; return (*this); } return (operator =(*pvarGuid)); };
		const CStringGUID& operator =(const VARIANT& varGuid) {
				CComVariant varTmp(varGuid);
				if (!SUCCEEDED(varTmp.ChangeType(VT_BSTR))) { m_bValid=FALSE; return (*this); };
				return (operator =(varTmp.bstrVal)); };
		GUID* operator &() { _ASSERTE(!m_bValid); return (&m_guid); };
		BOOL operator !() const { return (!m_bValid); };
	private:
		BOOL m_bValid;
		GUID m_guid;
		WCHAR m_szGuidW[40];
		CHAR m_szGuidA[40];
};

#endif // __SEOEXPORTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\inetcore\inc\winhttpi.h ===
#if !defined(_WINHTTPXEX_)
#define _WINHTTPXEX_

#if defined(__cplusplus)
extern "C" {
#endif

#define INTERNETAPI
// url-parsing flags added internally
//#define WINHTTP_FLAG_DEFAULT_ESCAPE   0x00000010 //obloete because of WIHHTTP_FLAG_ESCAPE_DISABLE
#define WINHTTP_FLAG_VALID_HOSTNAME     0x00000020  //only for server name; fast conversion is performed, no escaping
// These flags are superseded by WINHTTP_OPTION_DISABLE_FEATURE
#define INTERNET_FLAG_KEEP_CONNECTION   0x00400000  // use keep-alive semantics
#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000  // don't handle redirections automatically
#define INTERNET_FLAG_NO_COOKIES        0x00080000  // no automatic cookie handling
#define INTERNET_FLAG_NO_AUTH           0x00040000  // no automatic authentication handling
// WARNING: these flags may become unsupported or done in a different way.
// Security Ignore Flags, Allow HttpOpenRequest to overide
//  Secure Channel (SSL) failures of the following types.

#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   0x00008000 // ex: https:// to http://
#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://
#define SECURITY_INTERNET_MASK  (SECURITY_FLAG_IGNORE_CERT_CN_INVALID    |  \
                                 SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   |  \
                                 SECURITY_FLAG_IGNORE_UNKNOWN_CA         |  \
                                 SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE)


// parameter validation masks

#define WINHTTP_OPEN_FLAGS_MASK         (WINHTTP_FLAG_ASYNC) // valid flags mask
#define WINHTTP_CONNECT_FLAG_NO_INDICATION  0x00000001
#define WINHTTP_CONNECT_FLAGS_MASK      WINHTTP_CONNECT_FLAG_NO_INDICATION
#define WINHTTP_OPEN_REQUEST_FLAGS_MASK (WINHTTP_FLAG_SECURE                |  \
                                         WINHTTP_FLAG_ESCAPE_PERCENT        |  \
                                         WINHTTP_FLAG_NULL_CODEPAGE         |  \
                                         WINHTTP_FLAG_BYPASS_PROXY_CACHE    |  \
                                         WINHTTP_FLAG_ESCAPE_DISABLE        |  \
                                         WINHTTP_FLAG_ESCAPE_DISABLE_QUERY)
#define INTERNET_SCHEME_PARTIAL     (-2)
#define INTERNET_SCHEME_UNKNOWN     (-1)
#define INTERNET_SCHEME_DEFAULT     (0)
#define INTERNET_SCHEME_SOCKS       (3)
#define INTERNET_SCHEME_FIRST       (INTERNET_SCHEME_HTTP)
#define INTERNET_SCHEME_LAST        (INTERNET_SCHEME_SOCKS)
// WINHTTP_OPTION_VERSION is confusing, so we are killing it.
#define WINHTTP_OPTION_VERSION                       40
#define WINHTTP_OPTION_ERROR_MASK                    62
// Pass in pointer to INTERNET_SECURITY_CONNECTION_INFO to be filled in.
#define WINHTTP_OPTION_SECURITY_CONNECTION_INFO      66
#define WINHTTP_LAST_OPTION_INTERNAL           WINHTTP_LAST_OPTION
#define WINHTTP_OPTION_MASK                    0x0fff
#define MAX_INTERNET_STRING_OPTION  (WINHTTP_OPTION_PROXY_PASSWORD & WINHTTP_OPTION_MASK)
#define NUM_INTERNET_STRING_OPTION  (MAX_INTERNET_STRING_OPTION + 1)
// values for WINHTTP_OPTION_ERROR_MASK
#define INTERNET_ERROR_MASK_COMBINED_SEC_CERT                 0x2
#define WINHTTP_AUTH_SCHEME_KERBEROS   0x00000020
// setable flags
#define SECURITY_FLAG_CHECK_REVOCATION               0x00020000
// Other than the define for all supported secure protocols in winhttp,
// the single bit flags map directly to the SP_PROT_*_CLIENT flags
// defined in schannel.h
#define WINHTTP_CALLBACK_STATUS_BEGIN_PROXY_SCRIPT_RUN  0x00800000
#define WINHTTP_CALLBACK_FLAG_BEGIN_PROXY_SCRIPT_RUN    WINHTTP_CALLBACK_STATUS_BEGIN_PROXY_SCRIPT_RUN
//ensure that WINHTTP_CALLBACK_FLAG_ALL always matches OR of all the CALLBACKFLAGS

//
// Note that adding any WINHTTP_QUERY_* codes here must be followed
//   by an equivlent line in wininet\http\hashgen\hashgen.cpp
//   please see that file for further information regarding
//   the addition of new HTTP headers
//


// These are not part of HTTP 1.1 yet. We will propose these to the
// HTTP extensions working group. These are required for the client-caps support
// we are doing in conjuntion with IIS.

#define WINHTTP_QUERY_ECHO_REQUEST                 71
#define WINHTTP_QUERY_ECHO_REPLY                   72

// These are the set of headers that should be added back to a request when
// re-doing a request after a RETRY_WITH response.
#define WINHTTP_QUERY_ECHO_HEADERS                 73
#define WINHTTP_QUERY_ECHO_HEADERS_CRLF            74


#define HTTP_QUERY_MODIFIER_FLAGS_MASK          (WINHTTP_QUERY_FLAG_REQUEST_HEADERS    \
                                                | WINHTTP_QUERY_FLAG_SYSTEMTIME        \
                                                | WINHTTP_QUERY_FLAG_NUMBER            \
                                                )

#define HTTP_QUERY_HEADER_MASK                  (~HTTP_QUERY_MODIFIER_FLAGS_MASK)


//
// AR_TYPE - Asynchronous Request Type designator. Used as index into array of
// ARB sizes, hence must start at 0
//

typedef enum {
    AR_INTERNET_CONNECT = 0,            // 0
    AR_INTERNET_OPEN_URL,               // 1
    AR_INTERNET_READ_FILE,              // 2
    AR_INTERNET_WRITE_FILE,             // 3
    AR_INTERNET_QUERY_DATA_AVAILABLE,   // 4
    AR_INTERNET_FIND_NEXT_FILE,         // 5
    AR_FTP_FIND_FIRST_FILE,             // 6
    AR_FTP_GET_FILE,                    // 7
    AR_FTP_PUT_FILE,                    // 8
    AR_FTP_DELETE_FILE,                 // 9
    AR_FTP_RENAME_FILE,                 // 10
    AR_FTP_OPEN_FILE,                   // 11
    AR_FTP_CREATE_DIRECTORY,            // 12
    AR_FTP_REMOVE_DIRECTORY,            // 13
    AR_FTP_SET_CURRENT_DIRECTORY,       // 14
    AR_FTP_GET_CURRENT_DIRECTORY,       // 15
    AR_GOPHER_FIND_FIRST_FILE,          // 16
    AR_GOPHER_OPEN_FILE,                // 17
    AR_GOPHER_GET_ATTRIBUTE,            // 18
    AR_HTTP_SEND_REQUEST,               // 19
    AR_HTTP_BEGIN_SEND_REQUEST,         // 20
    AR_HTTP_END_SEND_REQUEST,           // 21
    AR_READ_PREFETCH,                   // 22
    AR_SYNC_EVENT,                      // 23
    AR_TIMER_EVENT,                     // 24
    AR_HTTP_REQUEST1,                   // 25
    AR_FILE_IO,                         // 26
    AR_INTERNET_READ_FILE_EX,           // 27
    AR_MAX_REQUEST_TYPE
} AR_TYPE;

#define ERROR_WINHTTP_INCORRECT_PASSWORD       (WINHTTP_ERROR_BASE + 14)
#define ERROR_WINHTTP_NOT_REDIRECTED               (WINHTTP_ERROR_BASE + 160)

// WinHttp Auto-Proxy Svc event messages

#define WINHTTP_AUTOPROXY_SVC_MSG_BASE (WINHTTP_ERROR_BASE + 500)

#define MSG_WINHTTP_AUTOPROXY_SVC_DATA_CORRUPT                  (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 1)
#define MSG_WINHTTP_AUTOPROXY_SVC_IDLE_TIMEOUT                  (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 3)
#define MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR                   (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 6)
#define MSG_WINHTTP_AUTOPROXY_SVC_FAILED_ALLOCATE_RESOURCE      (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 7)
#define MSG_WINHTTP_AUTOPROXY_SVC_NON_LRPC_REQUEST              (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 9)
#define MSG_WINHTTP_AUTOPROXY_SVC_TIMEOUT_GRACEFUL_SHUTDOWN     (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 11)
#define MSG_WINHTTP_AUTOPROXY_SVC_INVALID_PARAMETER             (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 12)
#define MSG_WINHTTP_AUTOPROXY_SVC_NOT_IN_SERVICE                (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 13)
#define MSG_WINHTTP_AUTOPROXY_SVC_WINHTTP_EXCEPTED              (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 14)
#define MSG_WINHTTP_AUTOPROXY_SVC_RETRY_REQUEST                 (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 16)
#define MSG_WINHTTP_AUTOPROXY_SVC_SUSPEND_OPERATION             (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 17)
#define MSG_WINHTTP_AUTOPROXY_SVC_RESUME_OPERATION              (WINHTTP_AUTOPROXY_SVC_MSG_BASE + 18)


#if defined(INCLUDE_CACHE)
// Cache control flags

// Control expiry behaviour
#define CACHE_FLAG_SYNC_MODE_AUTOMATIC          0x00000010
#define CACHE_FLAG_SYNC_MODE_ALWAYS             0x00000020
#define CACHE_FLAG_SYNC_MODE_ONCE_PER_SESSION   0x00000040 
#define CACHE_FLAG_SYNC_MODE_NEVER              0x00000080

#define CACHE_FLAG_BGUPDATE                     0x00000100
#define CACHE_FLAG_ALWAYS_RESYNCHRONIZE         0x00000200
#define CACHE_FLAG_DISABLE_CACHE_WRITE          0x00000400
#define CACHE_FLAG_DISABLE_CACHE_READ           0x00000800
#define CACHE_FLAG_DISABLE_SSL_CACHING          0x00001000
#define CACHE_FLAG_MAKE_PERSISTENT              0x00002000
#define CACHE_FLAG_FWD_BACK                     0x00004000

#define CACHE_FLAG_OFFLINE_BROWSING         	CACHE_FLAG_DISABLE_CACHE_READ | CACHE_FLAG_DISABLE_CACHE_WRITE
#define CACHE_FLAG_DEFAULT_SETTING           	CACHE_FLAG_SYNC_MODE_AUTOMATIC

#define WINHTTP_CACHE_FLAGS_MASK     ( CACHE_FLAG_SYNC_MODE_AUTOMATIC |           \
                                          CACHE_FLAG_SYNC_MODE_ALWAYS |              \
                                          CACHE_FLAG_SYNC_MODE_ONCE_PER_SESSION |   \
                                          CACHE_FLAG_SYNC_MODE_NEVER |               \
                                          CACHE_FLAG_BGUPDATE |                       \
                                          CACHE_FLAG_ALWAYS_RESYNCHRONIZE |          \
                                          CACHE_FLAG_DISABLE_CACHE_WRITE |           \
                                          CACHE_FLAG_DISABLE_CACHE_READ |            \
                                          CACHE_FLAG_MAKE_PERSISTENT |                \
                                          CACHE_FLAG_FWD_BACK |                       \
                                          CACHE_FLAG_OFFLINE_BROWSING |               \
                                          CACHE_FLAG_DEFAULT_SETTING)
#undef WINHTTP_OPEN_FLAGS_MASK
#define WINHTTP_OPEN_FLAGS_MASK    (WINHTTP_CACHE_FLAGS_MASK | \
                                      WINHTTP_FLAG_ASYNC)

WINHTTPAPI
HINTERNET
WINAPI
WinHttpCacheOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    );

WINHTTPAPI
HINTERNET
WINAPI
WinHttpCacheConnect(
    HINTERNET hSession,
    LPCWSTR pswzServerName,
    INTERNET_PORT nServerPort,
    DWORD dwReserved
    );

WINHTTPAPI
HINTERNET
WINAPI
WinHttpCacheOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    );

BOOLAPI
WinHttpCacheSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    );

BOOLAPI
WinHttpCacheReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut
    );

BOOLAPI
WinHttpCacheQueryDataAvailable(
    IN HINTERNET hRequest,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    );

BOOLAPI
WinHttpCacheReadData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

BOOLAPI
WinHttpCacheCloseHandle(
    IN HINTERNET hInternet
    );

BOOL
WINAPI
WinHttpCacheQueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength
    );

BOOL
WINAPI
WinHttpCacheSetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength
    );

BOOL
WINAPI
WinHttpCacheQueryHeaders(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPCWSTR lpszName OPTIONAL, 
    OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );

BOOL
WINAPI
WinHttpCacheAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

BOOL
WINAPI
WinHttpCacheQueryAuthSchemes(
    IN  HINTERNET   hRequest,
    OUT LPDWORD     lpdwSupportedSchemes,
    OUT LPDWORD     lpdwFirstScheme,
    OUT LPDWORD      pdwAuthTarget
    );

BOOL
WINAPI
WinHttpCacheSetCredentials(
    IN HINTERNET   hRequest,
    IN DWORD       AuthTargets,
    IN DWORD       AuthScheme,
    IN LPCWSTR     pwszUserName,
    IN LPCWSTR     pwszPassword,
    IN LPVOID      pAuthParams
    );

BOOL
WINAPI 
WinCacheHttpSetTimeouts(    
    IN HINTERNET    hInternet,
    IN int        nResolveTimeout,
    IN int        nConnectTimeout,
    IN int        nSendTimeout,
    IN int        nReceiveTimeout
    );

BOOL
WINAPI
WinCacheHttpWriteData(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    );

WINHTTP_STATUS_CALLBACK
WINAPI
WinHttpCacheSetStatusCallback(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    );

VOID
WinHttpCacheStatusCallback(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    );

#endif


#if defined(__cplusplus)
}
#endif

#endif // !define(_WINHTTPXEX_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\d3d8rgbrast.h ===
// Copyright (C) Microsoft Corporation.  All Rights Reserved.

#ifndef __D3D8RGBRAST_H__
#define __D3D8RGBRAST_H__

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

extern void* D3D8RGBRasterizer;

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3D8RGBRAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\d3d8sddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       D3D8sddi.h
 *  Content:    Defines the interface between the ddi thunk layer
 *              and the refrast/RGB HEL layer..
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   04-nov-99  smac    initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __D3D8SW_INCLUDED__
#define __D3D8SW_INCLUDED__

// Surface types
#define SWSURF_SURFACE                     0x00000001
#define SWSURF_VOLUME                      0x00000002
#define SWSURF_MIPMAP                      0x00000004
#define SWSURF_MIPVOLUME                   0x00000008
#define SWSURF_CUBEMAP                     0x00000010
#define SWSURF_VERTEXBUFFER                0x00000020
#define SWSURF_OPTIMIZERVERTEXBUFFER       0x00000040
#define SWSURF_INDEXBUFFER                 0x00000080
#define SWSURF_COMMANDBUFFER               0x00000100

// Flags
#define SWFLAG_D3DEXENDEDCAPS              0x00000001
#define SWFLAG_D3DGLOBALDRIVERDATA         0x00000002
#define SWFLAG_D3DCAPS8                    0x00000004



typedef struct _D3D8_SWCALLBACKS
{
    // From Callbacks
    LPD3DHAL_CONTEXTCREATECB                CreateContext;
    LPD3DHAL_CONTEXTDESTROYCB               ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB            ContextDestroyAll;
    LPD3DHAL_SCENECAPTURECB                 SceneCapture;
    LPD3DHAL_RENDERSTATECB                  RenderState;
    LPD3DHAL_RENDERPRIMITIVECB              RenderPrimitive;
    LPD3DHAL_TEXTURECREATECB                TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB               TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB                  TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB               TextureGetSurf;
    LPD3DHAL_GETSTATECB                     GetState;

    // From Callbacks2
    LPD3DHAL_SETRENDERTARGETCB              SetRenderTarget;
    LPD3DHAL_CLEARCB                        Clear;
    LPD3DHAL_DRAWONEPRIMITIVECB             DrawOnePrimitive;
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB      DrawOneIndexedPrimitive;
    LPD3DHAL_DRAWPRIMITIVESCB               DrawPrimitives;

    // From Callbacks3
    LPD3DHAL_CLEAR2CB                       Clear2;
    LPD3DHAL_VALIDATETEXTURESTAGESTATECB    ValidateTextureStageState;
    LPD3DHAL_DRAWPRIMITIVES2CB              DrawPrimitives2;

    // From MiscCallbacks in DDraw
    LPDDHAL_GETDRIVERSTATE                  GetDriverState;
    LPDDHAL_CREATESURFACEEX                 CreateSurfaceEx;

    // DDraw Callbacks
    LPDDHAL_CREATESURFACE                   CreateSurface;
    LPDDHALSURFCB_DESTROYSURFACE            DestroySurface;
    LPDDHALSURFCB_LOCK                      Lock;
    LPDDHALSURFCB_UNLOCK                    Unlock;

} D3D8_SWCALLBACKS, * PD3D8_SWCALLBACKS;


#ifdef __cplusplus
extern "C" {
#endif

HRESULT APIENTRY D3D8GetSWInfo(
    D3DCAPS8*           pCaps,
    PD3D8_SWCALLBACKS   pCallbacks,
    DWORD*              pNumTextures,
    DDSURFACEDESC**     ppTexList
    );

#ifdef __cplusplus
}
#endif


// Prototypes required to hook the DDI layer (used by RefRast and the HEL

#define D3D8_REFRASTNAME            "D3DREF8.DLL"

#define D3D8HOOK_GETSWINFOPROCNAME  "D3D8GetSWInfo"

typedef HRESULT (WINAPI * PD3D8GetSWInfo)(D3DCAPS8*          pCaps,
                                          PD3D8_SWCALLBACKS  pCallbacks,
                                          DWORD*             pNumTextures,
                                          DDSURFACEDESC**    ppTexList
                                          );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\d3ddm.hpp ===
// Copyright (C) Microsoft Corporation.  All Rights Reserved.

#ifndef _D3DDM_HPP
#define _D3DDM_HPP

#define D3DDM_VERSION       0xDBDB0003      // version tag

// base names for shared memory segments
#define D3DDM_TGTCTX_SM     "D3DDM_DTC_"    // tgt pid
#define D3DDM_MONCTX_SM     "D3DDM_DMC_"    // mon id
#define D3DDM_CMDDATA_SM    "D3DDM_CD_"     // mon id
#define D3DDM_TSHFILE_SM    "D3DDM_TSF_"    // tgt pid; target shader -> file association
#define D3DDM_IMAGE_SM      "D3DDM_I_"      // 0..n

// base names for events
#define D3DDM_TGT_EVENTBP   "D3DDM_TEBP_"   // tgt pid
#define D3DDM_TGT_EVENTACK  "D3DDM_TEACK_"  // tgt pid
#define D3DDM_MON_EVENTCMD  "D3DDM_MECMD_"  // mon id

#define D3DDM_MAX_BP   32    // max number of breakpoints for all types

// event definitions - can set more than one in single word so they
// can be used as breakpoint enables
#define D3DDM_EVENT_RSTOKEN             (1<<0)
#define D3DDM_EVENT_BEGINSCENE          (1<<1)
#define D3DDM_EVENT_ENDSCENE            (1<<2)

#define D3DDM_EVENT_VERTEX              (1<<8)
#define D3DDM_EVENT_VERTEXSHADERINST    (2<<8)
#define D3DDM_EVENT_VERTEXSHADER        (3<<8)

#define D3DDM_EVENT_PRIMITIVE           (1<<15)

#define D3DDM_EVENT_PIXEL               (1<<16)
#define D3DDM_EVENT_PIXELSHADERINST     (1<<17)
#define D3DDM_EVENT_PIXELSHADER         (1<<18)

#define D3DDM_EVENT_TARGETDISCONNECT    (1<<30)
#define D3DDM_EVENT_TARGETEXIT          (1<<31)

// command definitions - command enum is in upper 16 bits so lower 16
// can be used to send command specific parameter information
#define D3DDM_CMD_MASK                  (0xffff<<16)
#define D3DDM_CMD_GO                    (1<<16)

#define D3DDM_CMD_GETDEVICESTATE        (2<<16)
#define D3DDM_CMD_GETTEXTURESTATE       (3<<16)
#define D3DDM_CMD_GETPRIMITIVESTATE     (4<<16)
#define D3DDM_CMD_GETVERTEXSHADER       (5<<16)

#define D3DDM_CMD_GETVERTEXSTATE        (8<<16)
#define D3DDM_CMD_GETVERTEXSHADERCONST  (9<<16)
#define D3DDM_CMD_GETVERTEXSHADERINST   (10<<16) // 15:00 shader instruction
#define D3DDM_CMD_GETVERTEXSHADERSTATE  (11<<16)

#define D3DDM_CMD_GETPIXELSTATE         (16<<16) // 01:00 pixel selection from 2x2 grid
#define D3DDM_CMD_GETPIXELSHADERCONST   (17<<16)
#define D3DDM_CMD_GETPIXELSHADERINST    (18<<16) // 15:00 shader instruction
#define D3DDM_CMD_GETPIXELSHADERSTATE   (19<<16)

#define D3DDM_CMD_DUMPTEXTURE           (32<<16) // 03:00 SM selection (up to 16)
                                                 // 06:04 texture stage (0..7)
                                                 // 10:07 LOD (0..15)
                                                 // 15:11 cubemap or volume slice (0..31)
#define D3DDM_CMD_DUMPRENDERTARGET      (33<<16) // 03:00 SM selection (up to 16)

const UINT D3DDM_MAX_TSSSTAGES      = 8;
const UINT D3DDM_MAX_TSSVALUE       = 32;
const UINT D3DDM_MAX_RS             = 256;

const UINT D3DDM_MAX_VSDECL         = 128;
const UINT D3DDM_MAX_VSINPUTREG     = 16;
const UINT D3DDM_MAX_VSCONSTREG     = 128;
const UINT D3DDM_MAX_VSTEMPREG      = 12;
const UINT D3DDM_MAX_VSRASTOUTREG   = 3;
const UINT D3DDM_MAX_VSATTROUTREG   = 2;
const UINT D3DDM_MAX_VSTEXCRDOUTREG = 8;
const UINT D3DDM_MAX_VSINSTDWORD    = 32;
const UINT D3DDM_MAX_VSINSTSTRING   = 128;

const UINT D3DDM_MAX_PSINPUTREG     = 2;
const UINT D3DDM_MAX_PSCONSTREG     = 8;
const UINT D3DDM_MAX_PSTEMPREG      = 2;
const UINT D3DDM_MAX_PSTEXTREG      = 8;
const UINT D3DDM_MAX_PSINSTDWORD    = 32;
const UINT D3DDM_MAX_PSINSTSTRING   = 128;

// structs for command data
typedef struct _D3DDMDeviceState
{
    UINT32  TextureStageState[D3DDM_MAX_TSSSTAGES][D3DDM_MAX_TSSVALUE];
    UINT32  RenderState[D3DDM_MAX_RS];
    UINT32  VertexShaderHandle;
    UINT32  PixelShaderHandle;
    UINT    MaxVShaderHandle;
    UINT    MaxPShaderHandle;
} D3DDMDeviceState;
typedef struct _D3DDMTextureState
{
} D3DDMTextureState;
typedef struct _D3DDMVertexShader
{
    UINT32  Decl[D3DDM_MAX_VSDECL];
    // followed by user data
} D3DDMVertexShader;

typedef struct _D3DDMVertexState
{
    FLOAT   InputRegs[D3DDM_MAX_VSINPUTREG][4];
} D3DDMVertexState;
typedef struct _D3DDMVertexShaderConst
{
    FLOAT   ConstRegs[D3DDM_MAX_VSCONSTREG][4];
} D3DDMVertexShaderConst;
typedef struct _D3DDMVertexShaderInst
{
    DWORD   Inst[D3DDM_MAX_VSINSTDWORD];
    char    InstString[D3DDM_MAX_VSINSTSTRING];
} D3DDMVertexShaderInst;
typedef struct _D3DDMVertexShaderState
{
    UINT    CurrentInst;
    FLOAT   TempRegs[D3DDM_MAX_VSTEMPREG][4];
    FLOAT   AddressReg[4];
    FLOAT   RastOutRegs[D3DDM_MAX_VSRASTOUTREG][4];
    FLOAT   AttrOutRegs[D3DDM_MAX_VSATTROUTREG][4];
    FLOAT   TexCrdOutRegs[D3DDM_MAX_VSTEXCRDOUTREG][4];
} D3DDMVertexShaderState;

typedef struct _D3DDMPrimState
{
} D3DDMPrimState;

typedef struct _D3DDMPixelState
{
    UINT    Location[2];
    FLOAT   Depth;
    FLOAT   FogIntensity;
    FLOAT   InputRegs[D3DDM_MAX_PSINPUTREG][4];
} D3DDMPixelState;
typedef struct _D3DDMPixelShaderConst
{
    FLOAT   ConstRegs[D3DDM_MAX_PSCONSTREG][4];
} D3DDMPixelShaderConst;
typedef struct _D3DDMPixelShaderInst
{
    DWORD   Inst[D3DDM_MAX_PSINSTDWORD];
    char    InstString[D3DDM_MAX_PSINSTSTRING];
} D3DDMPixelShaderInst;
typedef struct _D3DDMPixelShaderState
{
    UINT    CurrentInst;
    FLOAT   TempRegs[D3DDM_MAX_PSTEMPREG][4];
    FLOAT   TextRegs[D3DDM_MAX_PSTEXTREG][4];
    BOOL    Discard;
} D3DDMPixelShaderState;

// size of command data buffer - large enough for any (single) command,
// the largest of which is the instruction + instruction comment (128KB)
#define D3DDM_CMDDATA_SIZE  0x28000

//
// DebugMonitorContext & DebugTargetContext - Contexts for each side of the
// target/monitor processes.
//
// DebugMonitorContext is R/W to monitor and RO to debug target.  The only
// exception is the TargetIDRequest, which is written by a target when
// requesting to be connected to that monitor.
//
// The TargetBP (BreakPoint) event is signaled by the target whenever a
// breakpoint is hit.
//
// The MonitorCmd (Command) event is signaled by the monitor when a command
// is ready to be processed by the target, and the TargetAck is signaled
// when the target is done processing the command.  This is reversed during
// target attachment, where the target signals (via MonitorCmd) the monitor
// to look at it's TargetIDRequest and connect to that target, sending an
// acknowledge to the target via TargetAck.
//

typedef struct _DebugMonitorContext
{
    int     MonitorID;          // 1..X ID of monitor
    int     TargetIDRequest;    // pid of CMDing target; writeable by target
    int     TargetID;           // pid of attached target; zero if not connected
    UINT32  Command;            // D3DDM_CMD_* token

// breakpoint settings
    UINT32  EventBP;
    UINT64  VertexCountBP;
    UINT64  PrimitiveCountBP;
    UINT64  PixelCountBP;
    DWORD   VertexShaderHandleBP;
    DWORD   PixelShaderHandleBP;
    UINT32  RastVertexBPEnable;
    UINT32  PixelBPEnable;

    INT32   RastVertexBP[D3DDM_MAX_BP][2];
    UINT    PixelBP[D3DDM_MAX_BP][2];
} DebugMonitorContext;

typedef struct _DebugTargetContext
{
    DWORD   Version;            // version
    int     ProcessID;          // pid of this target
    int     MonitorID;          // ID of monitor; zero if not connected
    UINT32  CommandBufferSize;  // size of data in command buffer

// status/state
    UINT32  EventStatus;
    UINT32  SceneCount;
    UINT64  PrimitiveCount;
    UINT64  PixelCount;

// The target side maintains dirty flags so the monitor side knows when to
// requery target-side state.
#define D3DDM_SC_DEVICESTATE        (1<<0)
#define D3DDM_SC_TEXTURE            (1<<1)
#define D3DDM_SC_PSSETSHADER        (1<<2)
#define D3DDM_SC_PSCONSTANTS        (1<<3)
#define D3DDM_SC_VSSETSHADER        (1<<4)
#define D3DDM_SC_VSCONSTANTS        (1<<5)
#define D3DDM_SC_VSMODIFYSHADERS    (1<<6)
#define D3DDM_SC_PSMODIFYSHADERS    (1<<7)
    UINT32  StateChanged;

} DebugTargetContext;

#endif // _D3DDM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\d3prm.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27/02/96   stevela Moved from RL to D3DRM.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __D3DRM_H__
#define __D3DRM_H__

#include "ddraw.h"

#ifdef __cplusplus
struct IDirect3DRM;
#endif

typedef struct IDirect3DRM *LPDIRECT3DRM;

//@@BEGIN_MSINTERNAL
#ifdef WINNT
#include "d3prmobj.h"
#else 
#include "d3drmobj.h"
#endif
#if 0
//@@END_MSINTERNAL
#include "d3drmobj.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL

#ifdef __cplusplus
extern "C" {
#endif

//@@BEGIN_MSINTERNAL
typedef void (CDECL *D3DRMERRORHANDLER)(HRESULT error, void *arg);
#ifdef BUILD_RLAPI
typedef D3DRMERRORHANDLER RLErrorHandler;
#endif
//@@END_MSINTERNAL

DEFINE_GUID(IID_IDirect3DRM,	0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRM2,	0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x4516ec83, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
WIN_TYPES(IDirect3DRM, DIRECT3DRM);
WIN_TYPES(IDirect3DRM2, DIRECT3DRM2);
WIN_TYPES(IDirect3DRM3, DIRECT3DRM3);

/*
 * Direct3DRM Object Class (for CoCreateInstance())
 */
DEFINE_GUID(CLSID_CDirect3DRM,  0x4516ec41, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);

//@@BEGIN_MSINTERNAL
/* Set the Reality Lab memory allocators */
STDAPI IDirect3DRMSetAllocator(D3DRMMALLOCFUNCTION, D3DRMREALLOCFUNCTION, D3DRMFREEFUNCTION);
STDAPI IDirect3DRMGetAllocator(LPD3DRMMALLOCFUNCTION, LPD3DRMREALLOCFUNCTION, LPD3DRMFREEFUNCTION);
//@@END_MSINTERNAL

/* Create a Direct3DRM API */
STDAPI Direct3DRMCreate(LPDIRECT3DRM FAR *lplpDirect3DRM);

#undef INTERFACE
#define INTERFACE IDirect3DRM

DECLARE_INTERFACE_(IDirect3DRM, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev,
	LPDIRECT3DRMDEVICE *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HRSRC rs, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
	LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM2

DECLARE_INTERFACE_(IDirect3DRM2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME2 *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER2 *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE2 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE2 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
	LPDIRECT3DRMDEVICE2 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE2 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE2 *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE2 *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
	LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM3

DECLARE_INTERFACE_(IDirect3DRM3, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME3, LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3 *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION2 *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET2 *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE3 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags, LPDIRECT3DRMDEVICE3 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
	LPDIRECT3DRMDEVICE3 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE3 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE3 *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPUNKNOWN, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMSHADOW2 *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE3, LPDIRECT3DRMFRAME3, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT2 *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME3,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE3 *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURE3CALLBACK, LPVOID,
	LPDIRECT3DRMFRAME3
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;

    /* Used with IDirect3DRMObject2 */
    STDMETHOD(RegisterClient)   (THIS_ REFGUID rguid, LPDWORD lpdwID) PURE;
    STDMETHOD(UnregisterClient) (THIS_ REFGUID rguid) PURE;

    STDMETHOD(CreateClippedVisual) (THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMCLIPPEDVISUAL *) PURE;
    STDMETHOD(SetOptions) (THIS_ DWORD);
    STDMETHOD(GetOptions) (THIS_ LPDWORD);
};

#define D3DRM_OK			DD_OK
#define D3DRMERR_BADOBJECT		MAKE_DDHRESULT(781)
#define D3DRMERR_BADTYPE		MAKE_DDHRESULT(782)
#define D3DRMERR_BADALLOC		MAKE_DDHRESULT(783)
#define D3DRMERR_FACEUSED		MAKE_DDHRESULT(784)
#define D3DRMERR_NOTFOUND		MAKE_DDHRESULT(785)
#define D3DRMERR_NOTDONEYET		MAKE_DDHRESULT(786)
#define D3DRMERR_FILENOTFOUND		MAKE_DDHRESULT(787)
#define D3DRMERR_BADFILE		MAKE_DDHRESULT(788)
#define D3DRMERR_BADDEVICE		MAKE_DDHRESULT(789)
#define D3DRMERR_BADVALUE		MAKE_DDHRESULT(790)
#define D3DRMERR_BADMAJORVERSION	MAKE_DDHRESULT(791)
#define D3DRMERR_BADMINORVERSION	MAKE_DDHRESULT(792)
#define D3DRMERR_UNABLETOEXECUTE	MAKE_DDHRESULT(793)
#define D3DRMERR_LIBRARYNOTFOUND        MAKE_DDHRESULT(794)
#define D3DRMERR_INVALIDLIBRARY         MAKE_DDHRESULT(795)
#define D3DRMERR_PENDING                MAKE_DDHRESULT(796)
#define D3DRMERR_NOTENOUGHDATA          MAKE_DDHRESULT(797)
#define D3DRMERR_REQUESTTOOLARGE        MAKE_DDHRESULT(798)
#define D3DRMERR_REQUESTTOOSMALL        MAKE_DDHRESULT(799)
#define D3DRMERR_CONNECTIONLOST         MAKE_DDHRESULT(800)
#define D3DRMERR_LOADABORTED            MAKE_DDHRESULT(801)
#define D3DRMERR_NOINTERNET             MAKE_DDHRESULT(802)
#define D3DRMERR_BADCACHEFILE           MAKE_DDHRESULT(803)
#define D3DRMERR_BOXNOTSET		MAKE_DDHRESULT(804)
#define D3DRMERR_BADPMDATA              MAKE_DDHRESULT(805)
#define D3DRMERR_CLIENTNOTREGISTERED    MAKE_DDHRESULT(806)
#define D3DRMERR_NOTCREATEDFROMDDS	MAKE_DDHRESULT(807)
#define D3DRMERR_NOSUCHKEY              MAKE_DDHRESULT(808)
#define D3DRMERR_INCOMPATABLEKEY        MAKE_DDHRESULT(809)
#define D3DRMERR_ELEMENTINUSE		MAKE_DDHRESULT(810)
#define D3DRMERR_TEXTUREFORMATNOTFOUND  MAKE_DDHRESULT(811)
#define D3DRMERR_NOTAGGREGATED          MAKE_DDHRESULT(812)

#ifdef __cplusplus
};
#endif

#endif /* _D3DRMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\d3prmdef.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27/02/96   stevela Moved from RL to D3DRM.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __D3DRMDEFS_H__
#define __D3DRMDEFS_H__

#include <stddef.h>
#include "d3dtypes.h"

#ifdef WIN32
#define D3DRMAPI  __stdcall
#else
#define D3DRMAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef struct _D3DRMVECTOR4D
{   D3DVALUE x, y, z, w;
} D3DRMVECTOR4D, *LPD3DRMVECTOR4D;

typedef D3DVALUE D3DRMMATRIX4D[4][4];

typedef struct _D3DRMQUATERNION
{   D3DVALUE s;
    D3DVECTOR v;
} D3DRMQUATERNION, *LPD3DRMQUATERNION;

typedef struct _D3DRMRAY
{   D3DVECTOR dvDir;
    D3DVECTOR dvPos;
} D3DRMRAY, *LPD3DRMRAY;

typedef struct _D3DRMBOX
{   D3DVECTOR min, max;
} D3DRMBOX, *LPD3DRMBOX;

typedef void (*D3DRMWRAPCALLBACK)
    (LPD3DVECTOR, int* u, int* v, LPD3DVECTOR a, LPD3DVECTOR b, LPVOID);

typedef enum _D3DRMLIGHTTYPE
{   D3DRMLIGHT_AMBIENT,
    D3DRMLIGHT_POINT,
    D3DRMLIGHT_SPOT,
    D3DRMLIGHT_DIRECTIONAL,
    D3DRMLIGHT_PARALLELPOINT
} D3DRMLIGHTTYPE, *LPD3DRMLIGHTTYPE;

typedef enum _D3DRMSHADEMODE {
    D3DRMSHADE_FLAT	= 0,
    D3DRMSHADE_GOURAUD	= 1,
    D3DRMSHADE_PHONG	= 2,

    D3DRMSHADE_MASK	= 7,
    D3DRMSHADE_MAX	= 8
} D3DRMSHADEMODE, *LPD3DRMSHADEMODE;

typedef enum _D3DRMLIGHTMODE {
    D3DRMLIGHT_OFF	= 0 * D3DRMSHADE_MAX,
    D3DRMLIGHT_ON	= 1 * D3DRMSHADE_MAX,

    D3DRMLIGHT_MASK	= 7 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MAX	= 8 * D3DRMSHADE_MAX
} D3DRMLIGHTMODE, *LPD3DRMLIGHTMODE;

typedef enum _D3DRMFILLMODE {
    D3DRMFILL_POINTS	= 0 * D3DRMLIGHT_MAX,
    D3DRMFILL_WIREFRAME	= 1 * D3DRMLIGHT_MAX,
    D3DRMFILL_SOLID	= 2 * D3DRMLIGHT_MAX,

    D3DRMFILL_MASK	= 7 * D3DRMLIGHT_MAX,
    D3DRMFILL_MAX	= 8 * D3DRMLIGHT_MAX
} D3DRMFILLMODE, *LPD3DRMFILLMODE;

typedef DWORD D3DRMRENDERQUALITY, *LPD3DRMRENDERQUALITY;

#define D3DRMRENDER_WIREFRAME	(D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_WIREFRAME)
#define D3DRMRENDER_UNLITFLAT	(D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_SOLID)
#define D3DRMRENDER_FLAT	(D3DRMSHADE_FLAT+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_GOURAUD	(D3DRMSHADE_GOURAUD+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_PHONG	(D3DRMSHADE_PHONG+D3DRMLIGHT_ON+D3DRMFILL_SOLID)

#define D3DRMRENDERMODE_BLENDEDTRANSPARENCY	1
#define D3DRMRENDERMODE_SORTEDTRANSPARENCY	2
//@@BEGIN_MSINTERNAL
#define D3DRMRENDERMODE_SORTIFNOZBUFFER		4
//@@END_MSINTERNAL
#define D3DRMRENDERMODE_LIGHTINMODELSPACE	8
#define D3DRMRENDERMODE_VIEWDEPENDENTSPECULAR	16
#define D3DRMRENDERMODE_DISABLESORTEDALPHAZWRITE 32

//@@BEGIN_MSINTERNAL
typedef enum _D3DRMLIGHTINGFREQUENCY
{   D3DRMLIGHT_NEVER,
    D3DRMLIGHT_ONCE,
    D3DRMLIGHT_CONTINUALLY
} D3DRMLIGHTINGFREQUENCY;

//@@END_MSINTERNAL
typedef enum _D3DRMTEXTUREQUALITY
{   D3DRMTEXTURE_NEAREST,		/* choose nearest texel */
    D3DRMTEXTURE_LINEAR,		/* interpolate 4 texels */
    D3DRMTEXTURE_MIPNEAREST,		/* nearest texel in nearest mipmap  */
    D3DRMTEXTURE_MIPLINEAR,		/* interpolate 2 texels from 2 mipmaps */
    D3DRMTEXTURE_LINEARMIPNEAREST,	/* interpolate 4 texels in nearest mipmap */
    D3DRMTEXTURE_LINEARMIPLINEAR	/* interpolate 8 texels from 2 mipmaps */
} D3DRMTEXTUREQUALITY, *LPD3DRMTEXTUREQUALITY;

/*
 * Texture flags
 */
#define D3DRMTEXTURE_FORCERESIDENT	    0x00000001 /* texture should be kept in video memory */
#define D3DRMTEXTURE_STATIC		    0x00000002 /* texture will not change */
#define D3DRMTEXTURE_DOWNSAMPLEPOINT	    0x00000004 /* point filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEBILINEAR	    0x00000008 /* bilinear filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEREDUCEDEPTH  0x00000010 /* reduce bit depth when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLENONE	    0x00000020 /* texture should never be downsampled */
#define D3DRMTEXTURE_CHANGEDPIXELS	    0x00000040 /* pixels have changed */
#define D3DRMTEXTURE_CHANGEDPALETTE	    0x00000080 /* palette has changed */
#define D3DRMTEXTURE_INVALIDATEONLY	    0x00000100 /* dirty regions are invalid */

/*
 * Shadow flags
 */
#define D3DRMSHADOW_TRUEALPHA		    0x00000001 /* shadow should render without artifacts when true alpha is on */

typedef enum _D3DRMCOMBINETYPE
{   D3DRMCOMBINE_REPLACE,
    D3DRMCOMBINE_BEFORE,
    D3DRMCOMBINE_AFTER
} D3DRMCOMBINETYPE, *LPD3DRMCOMBINETYPE;

typedef D3DCOLORMODEL D3DRMCOLORMODEL, *LPD3DRMCOLORMODEL;

typedef enum _D3DRMPALETTEFLAGS
{   D3DRMPALETTE_FREE,			/* renderer may use this entry freely */
    D3DRMPALETTE_READONLY,		/* fixed but may be used by renderer */
    D3DRMPALETTE_RESERVED		/* may not be used by renderer */
} D3DRMPALETTEFLAGS, *LPD3DRMPALETTEFLAGS;

typedef struct _D3DRMPALETTEENTRY
{   unsigned char red;		/* 0 .. 255 */
    unsigned char green;	/* 0 .. 255 */
    unsigned char blue;		/* 0 .. 255 */
    unsigned char flags;	/* one of D3DRMPALETTEFLAGS */
} D3DRMPALETTEENTRY, *LPD3DRMPALETTEENTRY;

typedef struct _D3DRMIMAGE
{   int width, height;		/* width and height in pixels */
    int aspectx, aspecty;	/* aspect ratio for non-square pixels */
    int depth;			/* bits per pixel */
    int rgb;			/* if false, pixels are indices into a
				   palette otherwise, pixels encode
				   RGB values. */
    int bytes_per_line;		/* number of bytes of memory for a
				   scanline. This must be a multiple
				   of 4. */
    void* buffer1;		/* memory to render into (first buffer). */
    void* buffer2;		/* second rendering buffer for double
				   buffering, set to NULL for single
				   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;	/* if rgb is true, these are masks for
				   the red, green and blue parts of a
				   pixel.  Otherwise, these are masks
				   for the significant bits of the
				   red, green and blue elements in the
				   palette.  For instance, most SVGA
				   displays use 64 intensities of red,
				   green and blue, so the masks should
				   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    D3DRMPALETTEENTRY* palette;	/* description of the palette (only if
				   rgb is false).  Must be (1<<depth)
				   elements. */
} D3DRMIMAGE, *LPD3DRMIMAGE;

typedef enum _D3DRMWRAPTYPE
{   D3DRMWRAP_FLAT,
    D3DRMWRAP_CYLINDER,
    D3DRMWRAP_SPHERE,
    D3DRMWRAP_CHROME,
    D3DRMWRAP_SHEET,
    D3DRMWRAP_BOX
} D3DRMWRAPTYPE, *LPD3DRMWRAPTYPE;

#define D3DRMWIREFRAME_CULL		1 /* cull backfaces */
#define D3DRMWIREFRAME_HIDDENLINE	2 /* lines are obscured by closer objects */

/*
 * Do not use righthanded perspective in Viewport2::SetProjection().
 * Set up righthanded mode by using IDirect3DRM3::SetOptions().
 */
typedef enum _D3DRMPROJECTIONTYPE
{   D3DRMPROJECT_PERSPECTIVE,
    D3DRMPROJECT_ORTHOGRAPHIC,
    D3DRMPROJECT_RIGHTHANDPERSPECTIVE, /* Only valid pre-DX6 */
    D3DRMPROJECT_RIGHTHANDORTHOGRAPHIC /* Only valid pre-DX6 */
} D3DRMPROJECTIONTYPE, *LPD3DRMPROJECTIONTYPE;

#define D3DRMOPTIONS_LEFTHANDED  0x00000001L /* Default */
#define D3DRMOPTIONS_RIGHTHANDED 0x00000002L

typedef enum _D3DRMXOFFORMAT
{   D3DRMXOF_BINARY,
    D3DRMXOF_COMPRESSED,
    D3DRMXOF_TEXT
} D3DRMXOFFORMAT, *LPD3DRMXOFFORMAT;

typedef DWORD D3DRMSAVEOPTIONS;
#define D3DRMXOFSAVE_NORMALS 1
#define D3DRMXOFSAVE_TEXTURECOORDINATES 2
#define D3DRMXOFSAVE_MATERIALS 4
#define D3DRMXOFSAVE_TEXTURENAMES 8
#define D3DRMXOFSAVE_ALL 15
#define D3DRMXOFSAVE_TEMPLATES 16
#define D3DRMXOFSAVE_TEXTURETOPOLOGY 32

typedef enum _D3DRMCOLORSOURCE
{   D3DRMCOLOR_FROMFACE,
    D3DRMCOLOR_FROMVERTEX
} D3DRMCOLORSOURCE, *LPD3DRMCOLORSOURCE;

typedef enum _D3DRMFRAMECONSTRAINT
{   D3DRMCONSTRAIN_Z,		/* use only X and Y rotations */
    D3DRMCONSTRAIN_Y,		/* use only X and Z rotations */
    D3DRMCONSTRAIN_X		/* use only Y and Z rotations */
} D3DRMFRAMECONSTRAINT, *LPD3DRMFRAMECONSTRAINT;

typedef enum _D3DRMMATERIALMODE
{   D3DRMMATERIAL_FROMMESH,
    D3DRMMATERIAL_FROMPARENT,
    D3DRMMATERIAL_FROMFRAME
} D3DRMMATERIALMODE, *LPD3DRMMATERIALMODE;

typedef enum _D3DRMFOGMODE
{   D3DRMFOG_LINEAR,		/* linear between start and end */
    D3DRMFOG_EXPONENTIAL,	/* density * exp(-distance) */
    D3DRMFOG_EXPONENTIALSQUARED	/* density * exp(-distance*distance) */
} D3DRMFOGMODE, *LPD3DRMFOGMODE;

typedef enum _D3DRMZBUFFERMODE {
    D3DRMZBUFFER_FROMPARENT,	/* default */
    D3DRMZBUFFER_ENABLE,	/* enable zbuffering */
    D3DRMZBUFFER_DISABLE	/* disable zbuffering */
} D3DRMZBUFFERMODE, *LPD3DRMZBUFFERMODE;

typedef enum _D3DRMSORTMODE {
    D3DRMSORT_FROMPARENT,	/* default */
    D3DRMSORT_NONE,		/* don't sort child frames */
    D3DRMSORT_FRONTTOBACK,	/* sort child frames front-to-back */
    D3DRMSORT_BACKTOFRONT	/* sort child frames back-to-front */
} D3DRMSORTMODE, *LPD3DRMSORTMODE;

typedef struct _D3DRMMATERIALOVERRIDE
{
    DWORD         dwSize;	/* Size of this structure */
    DWORD         dwFlags;	/* Indicate which fields are valid */
    D3DCOLORVALUE dcDiffuse;	/* RGBA */
    D3DCOLORVALUE dcAmbient;	/* RGB */
    D3DCOLORVALUE dcEmissive;	/* RGB */
    D3DCOLORVALUE dcSpecular;	/* RGB */
    D3DVALUE      dvPower;
    LPUNKNOWN     lpD3DRMTex;
} D3DRMMATERIALOVERRIDE, *LPD3DRMMATERIALOVERRIDE;

#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY     0x00000001L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY       0x00000002L
#define D3DRMMATERIALOVERRIDE_DIFFUSE               0x00000003L
#define D3DRMMATERIALOVERRIDE_AMBIENT               0x00000004L
#define D3DRMMATERIALOVERRIDE_EMISSIVE              0x00000008L
#define D3DRMMATERIALOVERRIDE_SPECULAR              0x00000010L
#define D3DRMMATERIALOVERRIDE_POWER                 0x00000020L
#define D3DRMMATERIALOVERRIDE_TEXTURE               0x00000040L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAMULTIPLY 0x00000080L
#define D3DRMMATERIALOVERRIDE_ALL                   0x000000FFL

#define D3DRMFPTF_ALPHA                           0x00000001L
#define D3DRMFPTF_NOALPHA                         0x00000002L
#define D3DRMFPTF_PALETTIZED                      0x00000004L
#define D3DRMFPTF_NOTPALETTIZED                   0x00000008L

#define D3DRMSTATECHANGE_UPDATEONLY		  0x000000001L
#define D3DRMSTATECHANGE_VOLATILE		  0x000000002L
#define D3DRMSTATECHANGE_NONVOLATILE		  0x000000004L
//@@BEGIN_MSINTERNAL
#define D3DRMSTATECHANGE_OVERRIDE		  0x000000008L
//@@END_MSINTERNAL
#define D3DRMSTATECHANGE_RENDER			  0x000000020L
#define D3DRMSTATECHANGE_LIGHT			  0x000000040L

/*
 * Values for flags in RM3::CreateDeviceFromSurface
 */
#define D3DRMDEVICE_NOZBUFFER           0x00000001L

/*
 * Values for flags in Object2::SetClientData
 */
#define D3DRMCLIENTDATA_NONE            0x00000001L
#define D3DRMCLIENTDATA_LOCALFREE       0x00000002L
#define D3DRMCLIENTDATA_IUNKNOWN        0x00000004L

/*
 * Values for flags in Frame2::AddMoveCallback.
 */
#define D3DRMCALLBACK_PREORDER		0
#define D3DRMCALLBACK_POSTORDER		1

/*
 * Values for flags in MeshBuilder2::RayPick.
 */
#define D3DRMRAYPICK_ONLYBOUNDINGBOXES		1
#define D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES	2
#define D3DRMRAYPICK_INTERPOLATEUV		4
#define D3DRMRAYPICK_INTERPOLATECOLOR		8
#define D3DRMRAYPICK_INTERPOLATENORMAL		0x10	

/*
 * Values for flags in MeshBuilder3::AddFacesIndexed.
 */
#define D3DRMADDFACES_VERTICESONLY		1

/*
 * Values for flags in MeshBuilder2::GenerateNormals.
 */
#define D3DRMGENERATENORMALS_PRECOMPACT		1
#define D3DRMGENERATENORMALS_USECREASEANGLE	2

/*
 * Values for MeshBuilder3::GetParentMesh
 */
#define D3DRMMESHBUILDER_DIRECTPARENT		1
#define D3DRMMESHBUILDER_ROOTMESH		2

/*
 * Flags for MeshBuilder3::Enable
 */
#define D3DRMMESHBUILDER_RENDERENABLE	0x00000001L
#define D3DRMMESHBUILDER_PICKENABLE     0x00000002L

/*
 * Flags for MeshBuilder3::AddMeshBuilder
 */
#define D3DRMADDMESHBUILDER_DONTCOPYAPPDATA	1
#define D3DRMADDMESHBUILDER_FLATTENSUBMESHES	2
#define D3DRMADDMESHBUILDER_NOSUBMESHES		4

/*
 * Flags for Object2::GetAge when used with MeshBuilders
 */
#define D3DRMMESHBUILDERAGE_GEOMETRY    0x00000001L
#define D3DRMMESHBUILDERAGE_MATERIALS   0x00000002L
#define D3DRMMESHBUILDERAGE_TEXTURES    0x00000004L

/*
 * Format flags for MeshBuilder3::AddTriangles.
 */
#define D3DRMFVF_TYPE                   0x00000001L
#define D3DRMFVF_NORMAL                 0x00000002L
#define D3DRMFVF_COLOR                  0x00000004L
#define D3DRMFVF_TEXTURECOORDS          0x00000008L

#define D3DRMVERTEX_STRIP               0x00000001L
#define D3DRMVERTEX_FAN                 0x00000002L
#define D3DRMVERTEX_LIST                0x00000004L

/*
 * Values for flags in Viewport2::Clear2
 */
#define D3DRMCLEAR_TARGET               0x00000001L
#define D3DRMCLEAR_ZBUFFER              0x00000002L
#define D3DRMCLEAR_DIRTYRECTS           0x00000004L
#define D3DRMCLEAR_ALL                  (D3DRMCLEAR_TARGET | \
					 D3DRMCLEAR_ZBUFFER | \
					 D3DRMCLEAR_DIRTYRECTS)

/*
 * Values for flags in Frame3::SetSceneFogMethod
 */
#define D3DRMFOGMETHOD_VERTEX          0x00000001L
#define D3DRMFOGMETHOD_TABLE           0x00000002L
#define D3DRMFOGMETHOD_ANY             0x00000004L

/*
 * Values for flags in Frame3::SetTraversalOptions
 */
#define D3DRMFRAME_RENDERENABLE        0x00000001L
#define D3DRMFRAME_PICKENABLE          0x00000002L

typedef DWORD D3DRMANIMATIONOPTIONS;
#define D3DRMANIMATION_OPEN 0x01L
#define D3DRMANIMATION_CLOSED 0x02L
#define D3DRMANIMATION_LINEARPOSITION 0x04L
#define D3DRMANIMATION_SPLINEPOSITION 0x08L
#define D3DRMANIMATION_SCALEANDROTATION 0x00000010L
#define D3DRMANIMATION_POSITION 0x00000020L

typedef DWORD D3DRMINTERPOLATIONOPTIONS;
#define D3DRMINTERPOLATION_OPEN 0x01L
#define D3DRMINTERPOLATION_CLOSED 0x02L
#define D3DRMINTERPOLATION_NEAREST 0x0100L
#define D3DRMINTERPOLATION_LINEAR 0x04L
#define D3DRMINTERPOLATION_SPLINE 0x08L
#define D3DRMINTERPOLATION_VERTEXCOLOR 0x40L
#define D3DRMINTERPOLATION_SLERPNORMALS 0x80L

typedef DWORD D3DRMLOADOPTIONS;

#define D3DRMLOAD_FROMFILE  0x00L
#define D3DRMLOAD_FROMRESOURCE 0x01L
#define D3DRMLOAD_FROMMEMORY 0x02L
#define D3DRMLOAD_FROMSTREAM 0x04L
#define D3DRMLOAD_FROMURL 0x08L

#define D3DRMLOAD_BYNAME 0x10L
#define D3DRMLOAD_BYPOSITION 0x20L
#define D3DRMLOAD_BYGUID 0x40L
#define D3DRMLOAD_FIRST 0x80L

#define D3DRMLOAD_INSTANCEBYREFERENCE 0x100L
#define D3DRMLOAD_INSTANCEBYCOPYING 0x200L

#define D3DRMLOAD_ASYNCHRONOUS 0x400L

typedef struct _D3DRMLOADRESOURCE {
  HMODULE hModule;
  LPCTSTR lpName;
  LPCTSTR lpType;
} D3DRMLOADRESOURCE, *LPD3DRMLOADRESOURCE;

typedef struct _D3DRMLOADMEMORY {
  LPVOID lpMemory;
  DWORD dSize;
} D3DRMLOADMEMORY, *LPD3DRMLOADMEMORY;

#define D3DRMPMESHSTATUS_VALID 0x01L
#define D3DRMPMESHSTATUS_INTERRUPTED 0x02L
#define D3DRMPMESHSTATUS_BASEMESHCOMPLETE 0x04L
#define D3DRMPMESHSTATUS_COMPLETE 0x08L
#define D3DRMPMESHSTATUS_RENDERABLE 0x10L

#define D3DRMPMESHEVENT_BASEMESH 0x01L
#define D3DRMPMESHEVENT_COMPLETE 0x02L

typedef struct _D3DRMPMESHLOADSTATUS {
  DWORD dwSize;            // Size of this structure
  DWORD dwPMeshSize;       // Total Size (bytes)
  DWORD dwBaseMeshSize;    // Total Size of the Base Mesh
  DWORD dwBytesLoaded;     // Total bytes loaded
  DWORD dwVerticesLoaded;  // Number of vertices loaded
  DWORD dwFacesLoaded;     // Number of faces loaded
  HRESULT dwLoadResult;    // Result of the load operation
  DWORD dwFlags;
} D3DRMPMESHLOADSTATUS, *LPD3DRMPMESHLOADSTATUS;

typedef enum _D3DRMUSERVISUALREASON {
    D3DRMUSERVISUAL_CANSEE,
    D3DRMUSERVISUAL_RENDER
} D3DRMUSERVISUALREASON, *LPD3DRMUSERVISUALREASON;

//@@BEGIN_MSINTERNAL
typedef LPVOID (*D3DRMMALLOCFUNCTION)(DWORD);
typedef D3DRMMALLOCFUNCTION *LPD3DRMMALLOCFUNCTION;
typedef LPVOID (*D3DRMREALLOCFUNCTION)(LPVOID, DWORD);
typedef D3DRMREALLOCFUNCTION *LPD3DRMREALLOCFUNCTION; 
typedef VOID  (*D3DRMFREEFUNCTION)(LPVOID);
typedef D3DRMFREEFUNCTION *LPD3DRMFREEFUNCTION;
//@@END_MSINTERNAL

typedef struct _D3DRMANIMATIONKEY 
{
    DWORD dwSize;
    DWORD dwKeyType;
    D3DVALUE dvTime;
    DWORD dwID;
#if (!defined __cplusplus) || (!defined D3D_OVERLOADS)
    union 
    {
	D3DRMQUATERNION dqRotateKey;
	D3DVECTOR dvScaleKey;
	D3DVECTOR dvPositionKey;
    };
#else
    /*
     * We do this as D3D_OVERLOADS defines constructors for D3DVECTOR,
     * this can then not be used in a union.  Use the inlines provided
     * to extract and set the required component.
     */
    D3DVALUE dvK[4];
#endif
} D3DRMANIMATIONKEY;
typedef D3DRMANIMATIONKEY *LPD3DRMANIMATIONKEY;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
inline VOID
D3DRMAnimationGetRotateKey(const D3DRMANIMATIONKEY& rmKey,
			   D3DRMQUATERNION& rmQuat)
{
    rmQuat.s = rmKey.dvK[0];
    rmQuat.v = D3DVECTOR(rmKey.dvK[1], rmKey.dvK[2], rmKey.dvK[3]);
}

inline VOID
D3DRMAnimationGetScaleKey(const D3DRMANIMATIONKEY& rmKey,
			  D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}

inline VOID
D3DRMAnimationGetPositionKey(const D3DRMANIMATIONKEY& rmKey,
			     D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}
inline VOID
D3DRMAnimationSetRotateKey(D3DRMANIMATIONKEY& rmKey,
			   const D3DRMQUATERNION& rmQuat)
{
    rmKey.dvK[0] = rmQuat.s;
    rmKey.dvK[1] = rmQuat.v.x;
    rmKey.dvK[2] = rmQuat.v.y;
    rmKey.dvK[3] = rmQuat.v.z;
}

inline VOID
D3DRMAnimationSetScaleKey(D3DRMANIMATIONKEY& rmKey,
			  const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}

inline VOID
D3DRMAnimationSetPositionKey(D3DRMANIMATIONKEY& rmKey,
			     const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}
#endif

#define D3DRMANIMATION_ROTATEKEY 0x01
#define D3DRMANIMATION_SCALEKEY 0x02
#define D3DRMANIMATION_POSITIONKEY 0x03


typedef DWORD D3DRMMAPPING, D3DRMMAPPINGFLAG, *LPD3DRMMAPPING;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPU = 1;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPV = 2;
static const D3DRMMAPPINGFLAG D3DRMMAP_PERSPCORRECT = 4;

typedef struct _D3DRMVERTEX
{   D3DVECTOR	    position;
    D3DVECTOR	    normal;
    D3DVALUE	    tu, tv;
    D3DCOLOR	    color;
} D3DRMVERTEX, *LPD3DRMVERTEX;

typedef LONG D3DRMGROUPINDEX; /* group indexes begin a 0 */
static const D3DRMGROUPINDEX D3DRMGROUP_ALLGROUPS = -1;

/*
 * Create a color from three components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI	D3DRMCreateColorRGB(D3DVALUE red,
					  D3DVALUE green,
					  D3DVALUE blue);

/*
 * Create a color from four components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI	D3DRMCreateColorRGBA(D3DVALUE red,
						 D3DVALUE green,
						 D3DVALUE blue,
						 D3DVALUE alpha);

/*
 * Get the red component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetRed(D3DCOLOR);

/*
 * Get the green component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetGreen(D3DCOLOR);

/*
 * Get the blue component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetBlue(D3DCOLOR);

/*
 * Get the alpha component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetAlpha(D3DCOLOR);

/*
 * Add two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorAdd(LPD3DVECTOR d,
					  LPD3DVECTOR s1,
					  LPD3DVECTOR s2);

/*
 * Subtract two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorSubtract(LPD3DVECTOR d,
					       LPD3DVECTOR s1,
					       LPD3DVECTOR s2);
/*
 * Reflect a ray about a given normal.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorReflect(LPD3DVECTOR d,
					      LPD3DVECTOR ray,
					      LPD3DVECTOR norm);

/*
 * Calculate the vector cross product.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorCrossProduct(LPD3DVECTOR d,
						   LPD3DVECTOR s1,
						   LPD3DVECTOR s2);
/*
 * Return the vector dot product.
 */
extern D3DVALUE 		D3DRMAPI D3DRMVectorDotProduct(LPD3DVECTOR s1,
						 LPD3DVECTOR s2);

/*
 * Scale a vector so that its modulus is 1.  Returns its argument or
 * NULL if there was an error (e.g. a zero vector was passed).
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorNormalize(LPD3DVECTOR);
#define D3DRMVectorNormalise D3DRMVectorNormalize

/*
 * Return the length of a vector (e.g. sqrt(x*x + y*y + z*z)).
 */
extern D3DVALUE 		D3DRMAPI D3DRMVectorModulus(LPD3DVECTOR v);

/*
 * Set the rotation part of a matrix to be a rotation of theta radians
 * around the given axis.
 */

extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorRotate(LPD3DVECTOR r, LPD3DVECTOR v, LPD3DVECTOR axis, D3DVALUE theta);

/*
 * Scale a vector uniformly in all three axes
 */
extern LPD3DVECTOR	D3DRMAPI D3DRMVectorScale(LPD3DVECTOR d, LPD3DVECTOR s, D3DVALUE factor);

/*
 * Return a random unit vector
 */
extern LPD3DVECTOR	D3DRMAPI D3DRMVectorRandom(LPD3DVECTOR d);

/*
 * Returns a unit quaternion that represents a rotation of theta radians
 * around the given axis.
 */

extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromRotation(LPD3DRMQUATERNION quat,
							      LPD3DVECTOR v,
							      D3DVALUE theta);

/*
 * Calculate the product of two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionMultiply(LPD3DRMQUATERNION q,
						    	  LPD3DRMQUATERNION a,
						   	  LPD3DRMQUATERNION b);

/*
 * Interpolate between two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionSlerp(LPD3DRMQUATERNION q,
						       LPD3DRMQUATERNION a,
						       LPD3DRMQUATERNION b,
						       D3DVALUE alpha);

/*
 * Calculate the matrix for the rotation that a unit quaternion represents
 */
extern void 		D3DRMAPI D3DRMMatrixFromQuaternion(D3DRMMATRIX4D dmMat, LPD3DRMQUATERNION lpDqQuat);

/*
 * Calculate the quaternion that corresponds to a rotation matrix
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromMatrix(LPD3DRMQUATERNION, D3DRMMATRIX4D);

//@@BEGIN_MSINTERNAL
#ifdef BUILD_RLAPI
#ifdef __psx__
#ifndef FIXED_POINT_API
#define FIXED_POINT_API
#endif
#ifndef FIXED_POINT_INTERNAL
#define FIXED_POINT_INTERNAL
#endif
#endif

/* RLRGB and RLRGBA may be used as initialisers for RLColors
 * The int or float values must be in the range 0..1
 */
#define RLRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
#define RLRGBA(r, g, b, a) \
    (	(((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
    |	(((long)((g) * 255)) << 8) | (long)((b) * 255) \
    )

typedef D3DVALUE RLValue;
typedef D3DCOLOR RLColor;
#ifdef FIXED_POINT_API
#ifndef __psx__
#define RLVal(x)		((RLValue)((x) * (double)(1<<16)))
#else
#define RLVal(x)		((RLValue)((x) * 65536))
#endif
#define RLInt(x)		((x) >> 16)
#define RLFloat(x)		((x) / 65536.0)
extern RLValue D3DRMAPI RLDivide(RLValue, RLValue);
extern RLValue D3DRMAPI RLMultiply(RLValue, RLValue);
#define RLMultiply3(a,b,c)	RLMultiply(RLMultiply(a, b), c)
#else
typedef float 		RLValue;
#define RLVal(x)	((RLValue) (x))
#define RLInt(x)	((int)(x))
#define RLFloat(x)	((float) (x))
#define RLDivide(a,b)	((RLValue) ((double) (a) / (double) (b)))
#define RLMultiply(a,b)	((RLValue) ((a) * (b)))
#define RLMultiply3(a,b,c)	((RLValue) ((a) * (b) * (c)))
#endif

/*
 * These types for internal compilation
 */
typedef D3DRECT RLRectangle;
typedef D3DVECTOR RLVector;
typedef D3DRMVECTOR4D RLVector4d;
typedef D3DRMMATRIX4D RLMatrix4d;
typedef D3DRMQUATERNION RLQuaternion;
typedef D3DRMBOX RLBox;
typedef D3DRMWRAPCALLBACK RLWrapCallback;

typedef D3DRMLIGHTTYPE RLLightType;
#define RLLightAmbient D3DRMLIGHT_AMBIENT
#define RLLightPoint D3DRMLIGHT_POINT
#define RLLightSpot D3DRMLIGHT_SPOT
#define RLLightDirectional D3DRMLIGHT_DIRECTIONAL
#define RLLightParallelPoint D3DRMLIGHT_PARALLELPOINT

typedef D3DRMSHADEMODE RLShadeMode;
#define RLShadeFlat D3DRMSHADE_FLAT
#define RLShadeGouraud D3DRMSHADE_GOURAUD
#define RLShadePhong D3DRMSHADE_PHONG
#define RLShadeMask D3DRMSHADE_MASK
#define RLShadeMax D3DRMSHADE_MAX

typedef D3DRMLIGHTMODE RLLightMode;
#define RLLightOff D3DRMLIGHT_OFF
#define RLLightOn D3DRMLIGHT_ON
#define RLLightMask D3DRMLIGHT_MASK
#define RLLightMax D3DRMLIGHT_MAX

typedef D3DRMFILLMODE RLFillMode;
#define RLFillPoints D3DRMFILL_POINTS
#define RLFillWireframe D3DRMFILL_WIREFRAME
#define RLFillSolid D3DRMFILL_SOLID
#define RLFillMask D3DRMFILL_MASK
#define RLFillMax D3DRMFILL_MAX

typedef D3DRMRENDERQUALITY RLRenderQuality;

#define RLRenderWireframe D3DRMRENDER_WIREFRAME
#define RLRenderUnlitflat D3DRMRENDER_UNLITFLAT
#define RLRenderFlat D3DRMRENDER_FLAT
#define RLRenderGouraud D3DRMRENDER_GOURAUD
#define RLRenderPhong D3DRMRENDER_PHONG

typedef D3DRMLIGHTINGFREQUENCY RLLightingFrequency;
#define RLLightNever D3DRMLIGHT_NEVER
#define RLLightOnce D3DRMLIGHT_ONCE
#define RLLightContinually D3DRMLIGHT_CONTINUALLY

typedef D3DRMTEXTUREQUALITY RLTextureQuality;
#define RLTextureNearest D3DRMTEXTURE_NEAREST
#define RLTextureLinear D3DRMTEXTURE_LINEAR
#define RLTextureMipNearest D3DRMTEXTURE_MIPNEAREST
#define RLTextureMipLinear D3DRMTEXTURE_MIPLINEAR
#define RLTextureLinearMipNearest D3DRMTEXTURE_LINEARMIPNEAREST
#define RLTextureLinearMipLinear D3DRMTEXTURE_LINEARMIPLINEAR

typedef D3DRMCOMBINETYPE RLCombineType;
#define RLCombineReplace D3DRMCOMBINE_REPLACE
#define RLCombineBefore D3DRMCOMBINE_BEFORE
#define RLCombineAfter D3DRMCOMBINE_AFTER

typedef D3DCOLORMODEL RLColorModel;
#define RLColorRamp D3DCOLOR_MONO
#define RLColorRGB D3DCOLOR_RGB

typedef D3DRMPALETTEFLAGS RLPaletteFlags;
#define RLPaletteFree D3DRMPALETTE_FREE
#define RLPaletteReadOnly D3DRMPALETTE_READONLY
#define RLPaletteReserved D3DRMPALETTE_RESERVED

typedef D3DRMPALETTEENTRY RLPaletteEntry;
typedef D3DRMIMAGE RLImage;

typedef D3DRMWRAPTYPE RLWrapType;
#define RLWrapFlat D3DRMWRAP_FLAT
#define RLWrapCylinder D3DRMWRAP_CYLINDER
#define RLWrapSphere D3DRMWRAP_SPHERE
#define RLWrapChrome D3DRMWRAP_CHROME
#define RLWrapSheet D3DRMWRAP_SHEET
#define RLWrapBox D3DRMWRAP_BOX

#define RLWireframeCull D3DRMWIREFRAME_CULL
#define RLWireframeHiddenLine D3DRMWIREFRAME_HIDDENLINE

typedef D3DRMPROJECTIONTYPE RLProjectionType;
#define RLProjectPerspective D3DRMPROJECT_PERSPECTIVE
#define RLProjectOrthographic D3DRMPROJECT_ORTHOGRAPHIC
#define RLProjectRightHandPerspective D3DRMPROJECT_RIGHTHANDPERSPECTIVE
#define RLProjectRightHandOrthographic D3DRMPROJECT_RIGHTHANDORTHOGRAPHIC

typedef D3DRMXOFFORMAT RLXOFFormat;
#define RLXOFBinary			D3DRMXOF_BINARY
#define RLXOFCompressed			D3DRMXOF_COMPRESSED
#define RLXOFText			D3DRMXOF_TEXT

#define RLXOFSaveNormals		D3DRMXOFSAVE_NORMALS
#define RLXOFSaveTextureCoordinates	D3DRMXOFSAVE_TEXTURECOORDINATES
#define RLXOFSaveMaterials 		D3DRMXOFSAVE_MATERIALS
#define RLXOFSaveTextureNames		D3DRMXOFSAVE_TEXTURENAMES
#define RLXOFSaveAll			D3DRMXOFSAVE_ALL
#define RLXOFSaveTemplates              D3DRMXOFSAVE_TEMPLATES

typedef D3DRMCOLORSOURCE RLColorSource;
#define RLColorFromFace D3DRMCOLOR_FROMFACE
#define RLColorFromVertex D3DRMCOLOR_FROMVERTEX

typedef D3DRMFRAMECONSTRAINT RLFrameConstraint;
#define RLConstrainZ D3DRMCONSTRAIN_Z
#define RLConstrainY D3DRMCONSTRAIN_Y
#define RLConstrainX D3DRMCONSTRAIN_X

typedef D3DRMMATERIALMODE RLMaterialMode;
#define RLMaterialFromMesh D3DRMMATERIAL_FROMMESH
#define RLMaterialFromParent D3DRMMATERIAL_FROMPARENT
#define RLMaterialFromFrame D3DRMMATERIAL_FROMFRAME

typedef D3DRMFOGMODE RLFogMode;
#define RLFogLinear D3DRMFOG_LINEAR
#define RLFogExponential D3DRMFOG_EXPONENTIAL
#define RLFogExponentialSquared D3DRMFOG_EXPONENTIALSQUARED

#define RLAnimationOpen			D3DRMANIMATION_OPEN
#define RLAnimationClosed		D3DRMANIMATION_CLOSED
#define RLAnimationLinearPosition	D3DRMANIMATION_LINEARPOSITION
#define RLAnimationSplinePosition	D3DRMANIMATION_SPLINEPOSITION
#define RLAnimationScaleAndRotation	D3DRMANIMATION_SCALEANDROTATION
#define RLAnimationPosition		D3DRMANIMATION_POSITION

typedef D3DRMUSERVISUALREASON RLUserVisualReason;
#define RLUserVisualCanSee D3DRMUSERVISUAL_CANSEE
#define RLUserVisualRender D3DRMUSERVISUAL_RENDER

typedef D3DRMMALLOCFUNCTION RLMallocFunction;
typedef D3DRMREALLOCFUNCTION RLReallocFunction;
typedef D3DRMFREEFUNCTION RLFreeFunction;

typedef D3DRMMAPPING RLMapping, RLMappingFlag;
static const RLMapping RLMapWrapU = 1;
static const RLMapping RLMapWrapV = 2;
static const RLMapping RLMapPerspCorrect = 4;

typedef D3DRMVERTEX RLVertex;

typedef D3DRMGROUPINDEX RLGroupIndex;
static const RLGroupIndex RLAllGroups = -1;

#define RLCreateColorRGB	D3DRMCreateColorRGB
#define RLCreateColorRGBA	D3DRMCreateColorRGBA
#define RLColorGetRed		D3DRMColorGetRed
#define RLColorGetGreen		D3DRMColorGetGreen
#define RLColorGetBlue		D3DRMColorGetBlue
#define RLColorGetAlpha		D3DRMColorGetAlpha
#define RLVectorAdd		D3DRMVectorAdd
#define RLVectorSubtract	D3DRMVectorSubtract
#define RLVectorReflect		D3DRMVectorReflect
#define RLVectorCrossProduct	D3DRMVectorCrossProduct
#define RLVectorDotProduct	D3DRMVectorDotProduct
#define RLVectorNormalize	D3DRMVectorNormalize
#define RLVectorNormalise	D3DRMVectorNormalize
#define RLVectorModulus		D3DRMVectorModulus
#define RLVectorRotate		D3DRMVectorRotate
#define RLVectorScale		D3DRMVectorScale
#define RLVectorRandom		D3DRMVectorRandom
#define RLQuaternionFromRotation D3DRMQuaternionFromRotation
#define RLQuaternionMultiply	D3DRMQuaternionMultiply
#define RLQuaternionSlerp	D3DRMQuaternionSlerp
#define RLMatrixFromQuaternion	D3DRMMatrixFromQuaternion
#define RLQuaternionFromMatrix	D3DRMQuaternionFromMatrix
#endif /* BUILD_RLAPI */
//@@END_MSINTERNAL

#if defined(__cplusplus)
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\d3prmobj.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27/02/96   stevela Moved from RL to D3DRM.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DRMOBJ_H_
#define _D3DRMOBJ_H_

// @@BEGIN_MSINTERNAL
#ifdef WIN32
// @@END_MSINTERNAL
#include <objbase.h> /* Use Windows header files */
#define VIRTUAL
// @@BEGIN_MSINTERNAL
#else
/* No Windows platform */
#include "d3drmbase.h"
#endif
// @@END_MSINTERNAL

// @@BEGIN_MSINTERNAL
#ifdef WINNT
#include "d3prmdef.h"
#else
#include "d3drmdef.h"
#endif
#if 0
// @@END_MSINTERNAL
#include "d3drmdef.h"
// @@BEGIN_MSINTERNAL
#endif
// @@END_MSINTERNAL

#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The methods for IUnknown
 */
#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)	   	(THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)	   	(THIS) kind; \
    STDMETHOD_(ULONG, Release)	   	(THIS) kind

/*
 * The methods for IDirect3DRMObject
 */
#define IDIRECT3DRMOBJECT_METHODS(kind) \
    STDMETHOD(Clone)			(THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD(AddDestroyCallback)  	(THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(DeleteDestroyCallback)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(SetAppData)	   	(THIS_ DWORD data) kind; \
    STDMETHOD_(DWORD, GetAppData)  	(THIS) kind; \
    STDMETHOD(SetName)		   	(THIS_ LPCSTR) kind; \
    STDMETHOD(GetName)			(THIS_ LPDWORD lpdwSize, LPSTR lpName) kind; \
    STDMETHOD(GetClassName)		(THIS_ LPDWORD lpdwSize, LPSTR lpName) kind


#define WIN_TYPES(itype, ptype) \
    typedef interface itype FAR *LP##ptype, FAR **LPLP##ptype

WIN_TYPES(IDirect3DRMObject, DIRECT3DRMOBJECT);
WIN_TYPES(IDirect3DRMObject2, DIRECT3DRMOBJECT2);
WIN_TYPES(IDirect3DRMDevice, DIRECT3DRMDEVICE);
WIN_TYPES(IDirect3DRMDevice2, DIRECT3DRMDEVICE2);
WIN_TYPES(IDirect3DRMDevice3, DIRECT3DRMDEVICE3);
WIN_TYPES(IDirect3DRMViewport, DIRECT3DRMVIEWPORT);
WIN_TYPES(IDirect3DRMViewport2, DIRECT3DRMVIEWPORT2);
WIN_TYPES(IDirect3DRMFrame, DIRECT3DRMFRAME);
WIN_TYPES(IDirect3DRMFrame2, DIRECT3DRMFRAME2);
WIN_TYPES(IDirect3DRMFrame3, DIRECT3DRMFRAME3);
WIN_TYPES(IDirect3DRMVisual, DIRECT3DRMVISUAL);
WIN_TYPES(IDirect3DRMMesh, DIRECT3DRMMESH);
WIN_TYPES(IDirect3DRMMeshBuilder, DIRECT3DRMMESHBUILDER);
WIN_TYPES(IDirect3DRMMeshBuilder2, DIRECT3DRMMESHBUILDER2);
WIN_TYPES(IDirect3DRMMeshBuilder3, DIRECT3DRMMESHBUILDER3);
WIN_TYPES(IDirect3DRMFace, DIRECT3DRMFACE);
WIN_TYPES(IDirect3DRMFace2, DIRECT3DRMFACE2);
WIN_TYPES(IDirect3DRMLight, DIRECT3DRMLIGHT);
WIN_TYPES(IDirect3DRMTexture, DIRECT3DRMTEXTURE);
WIN_TYPES(IDirect3DRMTexture2, DIRECT3DRMTEXTURE2);
WIN_TYPES(IDirect3DRMTexture3, DIRECT3DRMTEXTURE3);
WIN_TYPES(IDirect3DRMWrap, DIRECT3DRMWRAP);
WIN_TYPES(IDirect3DRMMaterial, DIRECT3DRMMATERIAL);
WIN_TYPES(IDirect3DRMMaterial2, DIRECT3DRMMATERIAL2);
WIN_TYPES(IDirect3DRMInterpolator, DIRECT3DRMINTERPOLATOR);
WIN_TYPES(IDirect3DRMAnimation, DIRECT3DRMANIMATION);
WIN_TYPES(IDirect3DRMAnimation2, DIRECT3DRMANIMATION2);
WIN_TYPES(IDirect3DRMAnimationSet, DIRECT3DRMANIMATIONSET);
WIN_TYPES(IDirect3DRMAnimationSet2, DIRECT3DRMANIMATIONSET2);
WIN_TYPES(IDirect3DRMUserVisual, DIRECT3DRMUSERVISUAL);
WIN_TYPES(IDirect3DRMShadow, DIRECT3DRMSHADOW);
WIN_TYPES(IDirect3DRMShadow2, DIRECT3DRMSHADOW2);
WIN_TYPES(IDirect3DRMArray, DIRECT3DRMARRAY);
WIN_TYPES(IDirect3DRMObjectArray, DIRECT3DRMOBJECTARRAY);
WIN_TYPES(IDirect3DRMDeviceArray, DIRECT3DRMDEVICEARRAY);
WIN_TYPES(IDirect3DRMFaceArray, DIRECT3DRMFACEARRAY);
WIN_TYPES(IDirect3DRMViewportArray, DIRECT3DRMVIEWPORTARRAY);
WIN_TYPES(IDirect3DRMFrameArray, DIRECT3DRMFRAMEARRAY);
WIN_TYPES(IDirect3DRMAnimationArray, DIRECT3DRMANIMATIONARRAY);
WIN_TYPES(IDirect3DRMVisualArray, DIRECT3DRMVISUALARRAY);
WIN_TYPES(IDirect3DRMPickedArray, DIRECT3DRMPICKEDARRAY);
WIN_TYPES(IDirect3DRMPicked2Array, DIRECT3DRMPICKED2ARRAY);
WIN_TYPES(IDirect3DRMLightArray, DIRECT3DRMLIGHTARRAY);
WIN_TYPES(IDirect3DRMProgressiveMesh, DIRECT3DRMPROGRESSIVEMESH);
WIN_TYPES(IDirect3DRMClippedVisual, DIRECT3DRMCLIPPEDVISUAL);

/*
 * Direct3DRM Object classes
 */
DEFINE_GUID(CLSID_CDirect3DRMDevice,	    0x4fa3568e, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewport,	    0x4fa3568f, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFrame,	    0x4fa35690, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMesh,	    0x4fa35691, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMeshBuilder,   0x4fa35692, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFace,	    0x4fa35693, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMLight,	    0x4fa35694, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMTexture,	    0x4fa35695, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMWrap,	    0x4fa35696, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMaterial,	    0x4fa35697, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimation,	    0x4fa35698, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimationSet,  0x4fa35699, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMUserVisual,    0x4fa3569a, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMShadow,	    0x4fa3569b, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewportInterpolator, 
0xde9eaa1, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMFrameInterpolator, 
0xde9eaa2, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMeshInterpolator, 
0xde9eaa3, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMLightInterpolator, 
0xde9eaa6, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMaterialInterpolator, 
0xde9eaa7, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMTextureInterpolator, 
0xde9eaa8, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMProgressiveMesh, 0x4516ec40, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMClippedVisual,   0x5434e72d, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);


/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject, 	    0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice, 	    0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,	    0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport, 	    0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame, 	    0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,	    0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual, 	    0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh, 	    0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,	    0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0x4516ec82, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFace, 	    0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFace2,           0x4516ec81, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMLight, 	    0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture, 	    0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap, 	    0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial, 	    0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation, 	    0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,	    0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,	    0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray, 	    0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,	    0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray, 	    0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,	    0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,	    0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray, 
0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,	    0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,	    0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,	    0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);

typedef void (__cdecl *D3DRMOBJECTCALLBACK)(LPDIRECT3DRMOBJECT obj, LPVOID arg);
typedef void (__cdecl *D3DRMFRAMEMOVECALLBACK)(LPDIRECT3DRMFRAME obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMFRAME3MOVECALLBACK)(LPDIRECT3DRMFRAME3 obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMUPDATECALLBACK)(LPDIRECT3DRMDEVICE obj, LPVOID arg, int, LPD3DRECT);
typedef void (__cdecl *D3DRMDEVICE3UPDATECALLBACK)(LPDIRECT3DRMDEVICE3 obj, LPVOID arg, int, LPD3DRECT);
typedef int (__cdecl *D3DRMUSERVISUALCALLBACK)
    (   LPDIRECT3DRMUSERVISUAL obj, LPVOID arg,	D3DRMUSERVISUALREASON reason,
        LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view
    );
typedef HRESULT (__cdecl *D3DRMLOADTEXTURECALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE *);
typedef HRESULT (__cdecl *D3DRMLOADTEXTURE3CALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE3 *);
typedef void (__cdecl *D3DRMLOADCALLBACK)
    (LPDIRECT3DRMOBJECT object, REFIID objectguid, LPVOID arg);

typedef HRESULT (__cdecl *D3DRMDOWNSAMPLECALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     LPDIRECTDRAWSURFACE pDDSSrc, LPDIRECTDRAWSURFACE pDDSDst);
typedef HRESULT (__cdecl *D3DRMVALIDATIONCALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     DWORD dwFlags, DWORD dwcRects, LPRECT pRects);

//@@BEGIN_MSINTERNAL
#ifdef BUILD_RLAPI
typedef D3DRMOBJECTCALLBACK RLObjectCallback;
typedef D3DRMFRAMEMOVECALLBACK RLFrameMoveCallback;
typedef D3DRMFRAME3MOVECALLBACK RLFrame3MoveCallback;
typedef D3DRMUPDATECALLBACK RLUpdateCallback;
typedef D3DRMDEVICE3UPDATECALLBACK RLDevice3UpdateCallback;
typedef D3DRMUSERVISUALCALLBACK RLUserVisualCallback;
typedef D3DRMLOADTEXTURECALLBACK RLLoadTextureCallback;
typedef D3DRMLOADTEXTURE3CALLBACK RLLoadTexture3Callback;
typedef D3DRMLOADCALLBACK RLLoadCallback;
typedef D3DRMDOWNSAMPLECALLBACK RLDownsampleCallback;
typedef D3DRMVALIDATIONCALLBACK RLValidationCallback;
#endif
//@@END_MSINTERNAL

typedef struct _D3DRMPICKDESC
{
    ULONG	ulFaceIdx;
    LONG	lGroupIdx;
    D3DVECTOR	vPosition;

} D3DRMPICKDESC, *LPD3DRMPICKDESC;

typedef struct _D3DRMPICKDESC2
{
    ULONG	ulFaceIdx;
    LONG	lGroupIdx;
    D3DVECTOR	dvPosition;
    D3DVALUE	tu;
    D3DVALUE	tv;
    D3DVECTOR	dvNormal;
    D3DCOLOR	dcColor;

} D3DRMPICKDESC2, *LPD3DRMPICKDESC2;

#undef INTERFACE
#define INTERFACE IDirect3DRMObject

/*
 * Base class
 */
DECLARE_INTERFACE_(IDirect3DRMObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObject2

DECLARE_INTERFACE_(IDirect3DRMObject2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * IDirect3DRMObject2 methods
     */
    STDMETHOD(AddDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE;
    STDMETHOD(Clone)(THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) PURE; \
    STDMETHOD(DeleteDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE; \
    STDMETHOD(GetClientData)(THIS_ DWORD dwID, LPVOID* lplpvData) PURE;
    STDMETHOD(GetDirect3DRM)(THIS_ LPDIRECT3DRM* lplpDirect3DRM) PURE;
    STDMETHOD(GetName)(THIS_ LPDWORD lpdwSize, LPSTR lpName) PURE;
    STDMETHOD(SetClientData)(THIS_ DWORD dwID, LPVOID lpvData, DWORD dwFlags) PURE;
    STDMETHOD(SetName)(THIS_ LPCSTR lpName) PURE;
    STDMETHOD(GetAge)(THIS_ DWORD dwFlags, LPDWORD pdwAge) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisual

DECLARE_INTERFACE_(IDirect3DRMVisual, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice

DECLARE_INTERFACE_(IDirect3DRMDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice2

DECLARE_INTERFACE_(IDirect3DRMDevice2, IDirect3DRMDevice)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice3

DECLARE_INTERFACE_(IDirect3DRMDevice3, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;

    /*
     * IDirect3DRMDevice3 methods
     */
    STDMETHOD(FindPreferredTextureFormat)(THIS_ DWORD dwBitDepths, DWORD dwFlags, LPDDPIXELFORMAT lpDDPF) PURE;
    STDMETHOD(RenderStateChange)(THIS_ D3DRENDERSTATETYPE drsType, DWORD dwVal, DWORD dwFlags) PURE;
    STDMETHOD(LightStateChange)(THIS_ D3DLIGHTSTATETYPE drsType, DWORD dwVal, DWORD dwFlags) PURE;
    STDMETHOD(GetStateChangeOptions)(THIS_ DWORD dwStateClass, DWORD dwStateNum, LPDWORD pdwFlags) PURE;
    STDMETHOD(SetStateChangeOptions)(THIS_ DWORD dwStateClass, DWORD dwStateNum, DWORD dwFlags) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMViewport

DECLARE_INTERFACE_(IDirect3DRMViewport, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMFRAME camera,
	DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewport2
DECLARE_INTERFACE_(IDirect3DRMViewport2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport2 methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMDEVICE3 dev, LPDIRECT3DRMFRAME3 camera,
	DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME3) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE3 *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
    STDMETHOD(TransformVectors)(THIS_ DWORD dwNumVectors,
				LPD3DRMVECTOR4D lpDstVectors,
				LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ DWORD dwNumVectors,
				       LPD3DVECTOR lpDstVectors,
				       LPD3DRMVECTOR4D lpSrcVectors) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame

DECLARE_INTERFACE_(IDirect3DRMFrame, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame2

DECLARE_INTERFACE_(IDirect3DRMFrame2, IDirect3DRMFrame)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;

    /*
     * IDirect3DRMFrame2 methods
     */
    STDMETHOD(AddMoveCallback2)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
		       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat, 
		    D3DRMSAVEOPTIONS d3dSaveFlags);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame3

DECLARE_INTERFACE_(IDirect3DRMFrame3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame3 methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME3 child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(GetTransform)(THIS_ LPDIRECT3DRMFRAME3 reference,
			     D3DRMMATRIX4D rmMatrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME3 target, LPDIRECT3DRMFRAME3 reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME3 reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
		       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat, 
		    D3DRMSAVEOPTIONS d3dSaveFlags);
    STDMETHOD(TransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
				DWORD dwNumVectors,
				LPD3DVECTOR lpDstVectors,
				LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
				       DWORD dwNumVectors,
				       LPD3DVECTOR lpDstVectors,
				       LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(SetTraversalOptions)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetTraversalOptions)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetSceneFogMethod)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetSceneFogMethod)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
    STDMETHOD(GetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMesh

DECLARE_INTERFACE_(IDirect3DRMMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMesh methods
     */
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(AddGroup)(THIS_ unsigned vCount, unsigned fCount, unsigned vPerFace, unsigned *fData, D3DRMGROUPINDEX *returnId) PURE;
    STDMETHOD(SetVertices)(THIS_ D3DRMGROUPINDEX id, unsigned index, unsigned count, D3DRMVERTEX *values) PURE;
    STDMETHOD(SetGroupColor)(THIS_ D3DRMGROUPINDEX id, D3DCOLOR value) PURE;
    STDMETHOD(SetGroupColorRGB)(THIS_ D3DRMGROUPINDEX id, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetGroupMapping)(THIS_ D3DRMGROUPINDEX id, D3DRMMAPPING value) PURE;
    STDMETHOD(SetGroupQuality)(THIS_ D3DRMGROUPINDEX id, D3DRMRENDERQUALITY value) PURE;
    STDMETHOD(SetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL value) PURE;
    STDMETHOD(SetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE value) PURE;

    STDMETHOD_(unsigned, GetGroupCount)(THIS) PURE;
    STDMETHOD(GetGroup)(THIS_ D3DRMGROUPINDEX id, unsigned *vCount, unsigned *fCount, unsigned *vPerFace, DWORD *fDataSize, unsigned *fData) PURE;
    STDMETHOD(GetVertices)(THIS_ D3DRMGROUPINDEX id, DWORD index, DWORD count, D3DRMVERTEX *returnPtr) PURE;
    STDMETHOD_(D3DCOLOR, GetGroupColor)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMMAPPING, GetGroupMapping)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetGroupQuality)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD(GetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL *returnPtr) PURE;
    STDMETHOD(GetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE *returnPtr) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMProgressiveMesh

DECLARE_INTERFACE_(IDirect3DRMProgressiveMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMProgressiveMesh methods
     */
    STDMETHOD(Load) (THIS_ LPVOID lpObjLocation, LPVOID lpObjId, 
		     D3DRMLOADOPTIONS dloLoadflags, D3DRMLOADTEXTURECALLBACK lpCallback,
		     LPVOID lpArg) PURE;
    STDMETHOD(GetLoadStatus) (THIS_ LPD3DRMPMESHLOADSTATUS lpStatus) PURE;
    STDMETHOD(SetMinRenderDetail) (THIS_ D3DVALUE d3dVal) PURE;
    STDMETHOD(Abort) (THIS_ DWORD dwFlags) PURE;
    
    STDMETHOD(GetFaceDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(GetVertexDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(SetFaceDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(SetVertexDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(GetFaceDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetVertexDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetDetail) (THIS_ D3DVALUE *lpdvVal) PURE;
    STDMETHOD(SetDetail) (THIS_ D3DVALUE d3dVal) PURE;

    STDMETHOD(RegisterEvents) (THIS_ HANDLE hEvent, DWORD dwFlags, DWORD dwReserved) PURE;
    STDMETHOD(CreateMesh) (THIS_ LPDIRECT3DRMMESH *lplpD3DRMMesh) PURE;
    STDMETHOD(Duplicate) (THIS_ LPDIRECT3DRMPROGRESSIVEMESH *lplpD3DRMPMesh) PURE;
    STDMETHOD(GetBox) (THIS_ LPD3DRMBOX lpBBox) PURE;
    STDMETHOD(SetQuality) (THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(GetQuality) (THIS_ LPD3DRMRENDERQUALITY lpdwquality) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow

DECLARE_INTERFACE_(IDirect3DRMShadow, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMVISUAL visual, LPDIRECT3DRMLIGHT light,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow2

DECLARE_INTERFACE_(IDirect3DRMShadow2, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (	THIS_ LPUNKNOWN pUNK, LPDIRECT3DRMLIGHT light,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;

    /*
     * IDirect3DRMShadow2 methods
     */
    STDMETHOD(GetVisual)(THIS_ LPDIRECT3DRMVISUAL *) PURE;
    STDMETHOD(SetVisual)(THIS_ LPUNKNOWN pUNK, DWORD) PURE;
    STDMETHOD(GetLight)(THIS_ LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(SetLight)(THIS_ LPDIRECT3DRMLIGHT, DWORD) PURE;
    STDMETHOD(GetPlane)(THIS_ LPD3DVALUE px, LPD3DVALUE py, LPD3DVALUE pz,
			LPD3DVALUE nx, LPD3DVALUE ny, LPD3DVALUE nz) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE px, D3DVALUE py, D3DVALUE pz,
			D3DVALUE nx, D3DVALUE ny, D3DVALUE nz, DWORD) PURE;
    STDMETHOD(GetOptions)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetOptions)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace

DECLARE_INTERFACE_(IDirect3DRMFace, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace2

DECLARE_INTERFACE_(IDirect3DRMFace2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder2

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder2, IDirect3DRMMeshBuilder)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;

    /*
     * IDirect3DRMMeshBuilder2 methods
     */
    STDMETHOD(GenerateNormals2)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder3

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder3 methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3, DWORD dwFlags) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE2) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetGeometry)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;
    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;
    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD(GetVertex)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(GetNormal)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(DeleteVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteFace)(THIS_ LPDIRECT3DRMFACE2) PURE;
    STDMETHOD(Empty)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(AddFacesIndexed)(THIS_ DWORD dwFlags, DWORD *lpdwvIndices, DWORD *dwIndexFirst, DWORD *dwCount) PURE;
    STDMETHOD(CreateSubMesh)(THIS_ LPUNKNOWN *) PURE;
    STDMETHOD(GetParentMesh)(THIS_ DWORD, LPUNKNOWN *) PURE;
    STDMETHOD(GetSubMeshes)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(DeleteSubMesh)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(Enable)(THIS_ DWORD) PURE;
    STDMETHOD(GetEnable)(THIS_ DWORD *) PURE;
    STDMETHOD(AddTriangles)(THIS_ DWORD dwFlags, DWORD dwFormat,
			    DWORD dwVertexCount, LPVOID lpvData) PURE;
    STDMETHOD(SetVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetVertices)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD(SetNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetNormals)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD_(int, GetNormalCount)(THIS) PURE;
};  

#undef INTERFACE
#define INTERFACE IDirect3DRMLight

DECLARE_INTERFACE_(IDirect3DRMLight, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMLight methods
     */
    STDMETHOD(SetType)(THIS_ D3DRMLIGHTTYPE) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetRange)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUmbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetPenumbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetConstantAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetLinearAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetQuadraticAttenuation)(THIS_ D3DVALUE) PURE;

    STDMETHOD_(D3DVALUE, GetRange)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetUmbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetPenumbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetConstantAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetLinearAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetQuadraticAttenuation)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD_(D3DRMLIGHTTYPE, GetType)(THIS) PURE;

    STDMETHOD(SetEnableFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(GetEnableFrame)(THIS_ LPDIRECT3DRMFRAME*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture

DECLARE_INTERFACE_(IDirect3DRMTexture, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture2

DECLARE_INTERFACE_(IDirect3DRMTexture2, IDirect3DRMTexture)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;

    /*
     * IDirect3DRMTexture2 methods
     */
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture3

DECLARE_INTERFACE_(IDirect3DRMTexture3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture3 methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ DWORD dwFlags, DWORD dwcRects, LPRECT pRects) PURE;
    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
    STDMETHOD(GetSurface)(THIS_ DWORD dwFlags, LPDIRECTDRAWSURFACE* lplpDDS) PURE;
    STDMETHOD(SetCacheOptions)(THIS_ LONG lImportance, DWORD dwFlags) PURE;
    STDMETHOD(GetCacheOptions)(THIS_ LPLONG lplImportance, LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetDownsampleCallback)(THIS_ D3DRMDOWNSAMPLECALLBACK pCallback, LPVOID pArg) PURE;
    STDMETHOD(SetValidationCallback)(THIS_ D3DRMVALIDATIONCALLBACK pCallback, LPVOID pArg) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMWrap

DECLARE_INTERFACE_(IDirect3DRMWrap, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWrap methods
     */
    STDMETHOD(Init)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME ref,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv
    ) PURE;
    STDMETHOD(Apply)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(ApplyRelative)(THIS_ LPDIRECT3DRMFRAME frame, LPDIRECT3DRMOBJECT) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial

DECLARE_INTERFACE_(IDirect3DRMMaterial, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;

    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial2

DECLARE_INTERFACE_(IDirect3DRMMaterial2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial2 methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetAmbient)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(SetAmbient)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation

DECLARE_INTERFACE_(IDirect3DRMAnimation, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation2

DECLARE_INTERFACE_(IDirect3DRMAnimation2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation2 methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME3 frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
    STDMETHOD(GetFrame)(THIS_ LPDIRECT3DRMFRAME3 *lpD3DFrame) PURE;
    STDMETHOD(DeleteKeyByID)(THIS_ DWORD dwID) PURE;
    STDMETHOD(AddKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(ModifyKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(GetKeys)(THIS_ D3DVALUE dvTimeMin,
		       D3DVALUE dvTimeMax, LPDWORD lpdwNumKeys,
		       LPD3DRMANIMATIONKEY lpKey);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet

DECLARE_INTERFACE_(IDirect3DRMAnimationSet, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet2

DECLARE_INTERFACE_(IDirect3DRMAnimationSet2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet2 methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME3 parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(GetAnimations)(THIS_ LPDIRECT3DRMANIMATIONARRAY *) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMUserVisual

DECLARE_INTERFACE_(IDirect3DRMUserVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMUserVisual methods
     */
    STDMETHOD(Init)(THIS_ D3DRMUSERVISUALCALLBACK fn, void *arg) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMArray

DECLARE_INTERFACE_(IDirect3DRMArray, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    /* No GetElement method as it would get overloaded
     * in derived classes, and overloading is
     * a no-no in COM
     */
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObjectArray

DECLARE_INTERFACE_(IDirect3DRMObjectArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMOBJECT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDeviceArray

DECLARE_INTERFACE_(IDirect3DRMDeviceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrameArray

DECLARE_INTERFACE_(IDirect3DRMFrameArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFRAME *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewportArray

DECLARE_INTERFACE_(IDirect3DRMViewportArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisualArray

DECLARE_INTERFACE_(IDirect3DRMVisualArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationArray

DECLARE_INTERFACE_(IDirect3DRMAnimationArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMANIMATION2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPickedArray

DECLARE_INTERFACE_(IDirect3DRMPickedArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMLightArray

DECLARE_INTERFACE_(IDirect3DRMLightArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMLIGHT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFaceArray

DECLARE_INTERFACE_(IDirect3DRMFaceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFACE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPicked2Array

DECLARE_INTERFACE_(IDirect3DRMPicked2Array, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC2) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMInterpolator

DECLARE_INTERFACE_(IDirect3DRMInterpolator, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMInterpolator methods
     */
    STDMETHOD(AttachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(GetAttachedObjects)(THIS_ LPDIRECT3DRMOBJECTARRAY *) PURE;
    STDMETHOD(DetachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(SetIndex)(THIS_ D3DVALUE) PURE;
    STDMETHOD_(D3DVALUE, GetIndex)(THIS) PURE;
    STDMETHOD(Interpolate)(THIS_ D3DVALUE, LPDIRECT3DRMOBJECT, D3DRMINTERPOLATIONOPTIONS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMClippedVisual

DECLARE_INTERFACE_(IDirect3DRMClippedVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMClippedVisual methods
     */
    STDMETHOD(Init) (THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(AddPlane) (THIS_ LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD, LPDWORD) PURE;
    STDMETHOD(DeletePlane)(THIS_ DWORD, DWORD) PURE;
    STDMETHOD(GetPlaneIDs)(THIS_ LPDWORD, LPDWORD, DWORD) PURE;
    STDMETHOD(GetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
    STDMETHOD(SetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
};

#ifdef __cplusplus
};
#endif
#endif /* _D3DRMOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\d3prmwin.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27/02/96   stevela Moved from RL to D3DRM.
 *   11/04/97	stevela Removed D3DRMUPDATECALLBACK
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __D3DRMWIN_H__
#define __D3DRMWIN_H__

#ifndef WIN32
#define WIN32
#endif

// @@BEGIN_MSINTERNAL
#ifdef WINNT
#include "d3prm.h"
#else 
#include "d3drm.h"
#endif
#if 0
// @@END_MSINTERNAL
#include "d3drm.h"
// @@BEGIN_MSINTERNAL
#endif
// @@END_MSINTERNAL

#include "ddraw.h"
#include "d3d.h"

/*
 * GUIDS used by Direct3DRM Windows interface
 */
DEFINE_GUID(IID_IDirect3DRMWinDevice,	0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

WIN_TYPES(IDirect3DRMWinDevice, DIRECT3DRMWINDEVICE);

#undef INTERFACE
#define INTERFACE IDirect3DRMWinDevice

DECLARE_INTERFACE_(IDirect3DRMWinDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWinDevice methods
     */

    /* Repaint the window with the last frame which was rendered. */
    STDMETHOD(HandlePaint)(THIS_ HDC hdc) PURE;

    /* Respond to a WM_ACTIVATE message. */
    STDMETHOD(HandleActivate)(THIS_ WORD wparam) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\d3prmvis.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drmvis.h
 *  Content:	Direct3DRM external visualinclude file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   12/06/97   stevela Initial rev
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DRMVIS_H_
#define _D3DRMVIS_H_

//@@BEGIN_MSINTERNAL
#if 1
#include "d3prm.h"
#include "d3prmobj.h"
#else
//@@END_MSINTERNAL
#include "d3drm.h"
#include "d3drmobj.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL

#include <ocidl.h>
#include "dxfile.h"

#ifdef __cplusplus
extern "C" {
#endif

WIN_TYPES(IDirect3DRMExternalVisual, DIRECT3DRMEXTERNALVISUAL);
WIN_TYPES(IDirect3DRMExternalUtil, DIRECT3DRMEXTERNALUTIL);

DEFINE_GUID(IID_IDirect3DRMExternalVisual,
0x4516ec80, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMExternalUtil,
0x4516ec80, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);

/* In IDirect3DRMExternalVisual::CanSee() */
#define D3DRMEXTVIS_CANNOTSEE 0x00000001L
#define D3DRMEXTVIS_CANSEE    0x00000002L

/* In IDirect3DRMExternalVisual::Pick() */
#define D3DRMEXTVIS_NOTPICKED 0x00000001L
#define D3DRMEXTVIS_PICKED    0x00000002L

/* In D3DRMEXTVISRENDERCONTEXT.dwOverrides */
#define D3DRMEXTVIS_RENDERCONTEXT_OVERRIDEMATERIAL 0x00000001L
#define D3DRMEXTVIS_RENDERCONTEXT_OVERRIDETEXTURE  0x00000002L
#define D3DRMEXTVIS_RENDERCONTEXT_DEVICEOVERRIDE   0x00000004L

/* In D3DRMEXTVISRENDERCONTEXT.dwZBufferMode */
#define D3DRMEXTVIS_RENDERCONTEXT_ZBUFFERON        0x00000001L
#define D3DRMEXTVIS_RENDERCONTEXT_ZBUFFEROFF       0x00000002L

/*
 * Structure for IDirect3DRMExternalVisual::SetRenderContext()
 */
typedef struct
{
    DWORD dwSize;		/* Size of structure */
    DWORD dwFlags;		/* Must be zero */
    DWORD dwOverrides;		/* Indicates which overrides are in effect */
    D3DMATERIALHANDLE hMat;	/* If non-zero, this material handle MUST
				   be used for all rendering */
    D3DTEXTUREHANDLE hTex;	/* If non-zero, this texture handle MUST
				   be used for all rendering */
    D3DRMMATERIALOVERRIDE dmUserOverride; /* contains per-attribute overrides
					     for materials */
    D3DRMSHADEMODE pShadeMode;  /* Flat, gouraud or phong */
    D3DRMLIGHTMODE pLightMode;  /* On or off */
    D3DRMFILLMODE pFillMode;    /* Points, wireframe or solid */
    DWORD dwZBufferMode;	/* As defined above */
    DWORD dwRenderMode;		/* Blended transparency and/or sorted */
} D3DRMEXTVISRENDERCONTEXT, *LPD3DRMEXTVISRENDERCONTEXT;

/*
 * Structure for IDirect3DRMExternalVisual::RayPick()
 */
typedef struct
{
    D3DVALUE  dDistance;
    D3DVECTOR dvPosition;
    D3DVECTOR dvNormal;
    D3DVALUE  tu;
    D3DVALUE  tv;
    D3DCOLOR  dcColor;
} D3DRMEXTVISRAYPICKINFO, *LPD3DRMEXTVISRAYPICKINFO;

#undef INTERFACE
#define INTERFACE IDirect3DRMExternalVisual
DECLARE_INTERFACE_(IDirect3DRMExternalVisual, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * IDirect3DRMExternalVisual methods
     */
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DRM, LPDIRECT3DRMEXTERNALUTIL,
			  DWORD dwFlags) PURE;
    STDMETHOD(Load)(THIS_ IDirectXFileData *dObject, 
		    IPropertyBag *pPropBag, 
		    DWORD dwFlags) PURE;

    /*
     * Information about device state, viewport state, overrides, etc...
     */
    STDMETHOD(SetRenderContext)(THIS_ LPD3DRMEXTVISRENDERCONTEXT pCntx,
				DWORD dwFlags) PURE;
    
    /*
     * Rendering operations
     */
    STDMETHOD(CanSee)(THIS_ LPDIRECT3DRMDEVICE2, LPDIRECT3DRMVIEWPORT2,
		      LPDWORD pdwCanSee) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMDEVICE2, LPDIRECT3DRMVIEWPORT2,
		      DWORD dwFlags) PURE;
    STDMETHOD(DeviceChange)(THIS) PURE;

    /* 
     * Notify external visuals when BeginScene/EndScene are called during 
     * rendering
     */
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;

    /*
     * Picking
     */
    STDMETHOD(Pick)(THIS_ LPDIRECT3DRMVIEWPORT2 pViewIn,
		    LPDIRECT3DRMFRAME3 pFrameIn,
		    DWORD dwXIn, DWORD dwYIn,
		    LPD3DVALUE pdvZOut, LPDWORD pdwPicked) PURE;

    /*
     * RayPicking
     *
     * dwFlags can contain:
     * D3DRMRAYPICK_INTERPOLATENORMAL - pPickInfo.dvNormal must be filled in
     * D3DRMRAYPICK_INTERPOLATECOLOR  - pPickInfo.dcColor must be filled in
     * D3DRMRAYPICK_INTERPOLATEUV     - pPickInfo.tu, tv must be filled in
     */
    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME3 pFrameIn,
		       LPD3DRMRAY pRayIn,
		       DWORD dwFlags,
		       LPDWORD pdwPicked,
		       LPD3DRMEXTVISRAYPICKINFO pPickInfo) PURE;

    /*
     * Misc
     */
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(GetAge)(THIS_ LPDWORD) PURE;
};

/*
 * Flags for UpdateBounds
 */
#define D3DRMEXTUTIL_BOUNDSINVALIDATE 0x00000001L
#define D3DRMEXTUTIL_BOUNDSVALID      0x00000002L

#undef INTERFACE
#define INTERFACE IDirect3DRMExternalUtil
DECLARE_INTERFACE_(IDirect3DRMExternalUtil, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * External Visual must use these methods to provide IDirect3DRMObject
     * functionality.
     */
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMExternalUtil methods
     */

    /*
     * Texture Management
     */
    STDMETHOD(FindDeviceTexture)(LPDIRECT3DRMDEVICE2, LPDIRECT3DRMTEXTURE,
				 LPDWORD dwDevTexId) PURE;
    STDMETHOD(GetTextureHandle)(DWORD dwDevTexId, LPDWORD pdwHandle) PURE;
    STDMETHOD(DestroyDeviceTexture)(DWORD dwDevTexId) PURE;
    STDMETHOD(ValidateDeviceTextures)(LPDIRECT3DRMDEVICE2,
				      LPDWORD dwDevTexIds,
				      DWORD dwNumIds) PURE;
    STDMETHOD(UpdateBounds)(DWORD dwFlags,
			    LPD3DVECTOR dvMin,
			    LPD3DVECTOR dvMax) PURE;
    STDMETHOD(SetExtents)(LPDIRECT3DRMVIEWPORT2,
			  DWORD dwNumExtents, 
			  LPD3DCLIPSTATUS pExtents) PURE;
};

#ifdef __cplusplus
};
#endif /* __cplusplus */

#endif /* _D3DRMVIS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\ddrawpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawpr.h
 *  Content:    DirectDraw private header file
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   25-dec-94  craige  initial implementation
 *   06-jan-95  craige  video memory manager
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   22-feb-95  craige  use critical sections on Win95
 *   27-feb-95  craige  new sync. macros
 *   03-mar-95  craige  WaitForVerticalBlank stuff
 *   06-mar-95  craige  HEL integration
 *   08-mar-95  craige  GetFourCCCodes
 *   11-mar-95  craige  palette stuff
 *   19-mar-95  craige  use HRESULTs
 *   20-mar-95  craige  new CSECT work
 *   23-mar-95  craige  attachment work
 *   26-mar-95  craige  added TMPALLOC and TMPFREE
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  switched to PALETTEENTRY from RGBQUAD
 *   29-mar-95  craige  debug memory manager; build.h; hacks for DLL
 *                      unload problem...
 *   31-mar-95  craige  use critical sections with palettes
 *   03-apr-95  craige  added MAKE_SURF_RECT
 *   04-apr-95  craige  added DD_GetPaletteEntries, DD_SetPaletteEntries
 *   06-apr-95  craige  split out process list stuff; fill in free vidmem
 *   12-apr-95  craige  add debugging to CSECT macros
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   14-may-95  craige  added DoneExclusiveMode, DD16_EnableReboot; cleaned out
 *                      obsolete junk
 *   23-may-95  craige  no longer use MapLS_Pool; added Flush, GetBatchLimit
 *                      and SetBatchLimit
 *   24-may-95  craige  added Restore
 *   28-may-95  craige  unicode support; cleaned up HAL: added GetBltStatus;
 *                      GetFlipStatus; GetScanLine
 *   02-jun-95  craige  added SetDisplayMode
 *   04-jun-95  craige  added AllocSurfaceMem, IsLost
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  added RestoreDisplayMode
 *   07-jun-95  craige  added StartExclusiveMode
 *   10-jun-95  craige  split out vmemmgr stuff
 *   13-jun-95  kylej   move FindAttachedFlip to misc.c, added CanBeFlippable
 *   18-jun-95  craige  specify pitch for rectangular heaps
 *   20-jun-95  craige  added DD16_InquireVisRgn; make retail builds
 *                      not bother to check for NULL (since there are 4
 *                      billion other invalid ptrs we don't check for...)
 *   21-jun-95  craige  new clipper stuff
 *   23-jun-95  craige  ATTACHED_PROCESSES stuff
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  replaced batch limit/flush stuff with BltBatch
 *   30-jun-95  kylej   function prototypes to support mult. prim. surfaces
 *   30-jun-95  craige  changed GET_PIXEL_FORMAT to use HASPIXELFORMAT flag
 *   01-jul-95  craige  hide composition & streaming stuff
 *   02-jul-95  craige  SEH macros; added DD16_ChangeDisplaySettings
 *   03-jul-95  kylej   Changed EnumSurfaces declaration
 *   03-jul-95  craige  YEEHAW: new driver struct; Removed GetProcessPrimary
 *   05-jul-95  craige  added Initialize fn to each object
 *   07-jul-95  craige  added some VALIDEX_xxx structs
 *   07-jul-95  kylej   proto XformRect, STRETCH_X and STRETCH_Y macros
 *   08-jul-95  craige  added FindProcessDDObject; added InvalidateAllSurfaces
 *   09-jul-95  craige  added debug output to win16 lock macro; added
 *                      ComputePitch, added hasvram flag to MoveToSystemMemory;
 *                      changed SetExclusiveMode to SetCooperativeLevel;
 *                      added ChangeToSoftwareColorKey
 *   10-jul-95  craige  support SetOverlayPosition
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock;
 *                      Get/SetOverlayPosition takes LONGs
 *   13-jul-95  toddla  remove _export from thunk functions
 *   18-jul-95  craige  removed DD_Surface_Flush
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   28-jul-95  craige  go back to private DDRAW lock
 *   31-jul-95  craige  added DCIIsBanked
 *   01-aug-95  craige  added ENTER/LEAVE_BOTH; DOHALCALL_NOWIN16
 *   04-aug-95  craige  added InternalLock/Unlock
 *   10-aug-95  toddla  changed proto of EnumDisplayModes
 *   10-aug-95  toddla  added VALIDEX_DDSURFACEDESC_PTR
 *   12-aug-95  craige  added use_full_lock parm to MoveToSystemMemory and
 *                      ChangeToSoftwareColorKey
 *   13-aug-95  craige  flags parm for Flip
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 735: added SetPaletteAlways
 *                      bug 738: use GUID instead of IID
 *   02-sep-95  craige  bug 786: verify dwSize in retail
 *   04-sep-95  craige  bug 894: force flag to SetDisplayMode
 *   10-sep-95  toddla  added string ids
 *   21-sep-95  craige  bug 1215: added DD16_SetCertified
 *   11-nov-95  colinmc added new pointer validition macro for byte arrays
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (defined by DDSCAPS)
 *   10-dec-95  colinmc added execute buffer support
 *   14-dec-95  colinmc added shared back and z-buffer support
 *   25-dec-95  craige  added class factory support
 *   31-dec-95  craige  added VALID_IID_PTR
 *   26-jan-96  jeffno  FlipToGDISurface now only takes 1 arg
 *   09-feb-96  colinmc local surface objects now have invalid surface flag
 *   12-feb-96  jeffno  Cheaper Mutex implementation for NT
 *   15-feb-96  jeffno  GETCURRENTPID needs to call HackCurrentPID on both 95 and NT
 *   17-feb-96  colinmc Removed dependency on Direct3D include files
 *   24-feb-96  colinmc Added prototype for new member which is used to
 *                      determine if the callback tables have already been
 *                      initialized.
 *   02-mar-96  colinmc Simply disgusting and temporary hack to keep
 *                      interim drivers working
 *   14-mar-96  colinmc Changes for the clipper class factory
 *   17-mar-96  colinmc Bug 13124: flippable mip-maps
 *   20-mar-96  colinmc Bug 13634: unidirectional attachments cause infinite
 *                      loop on cleanup
 *   22-mar-96  colinmc Bug 13316: Uninitialized interfaces
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   10-apr-96  colinmc Bug 16903: HEL using obsolete FindProcessDDObject
 *   13-apr-96  colinmc Bug 17736: No driver notifcation of flip to GDI
 *   15-apr-96  colinmc Bug 16885: Can't pass NULL to initialize in C++
 *   16-apr-96  colinmc Bug 17921: Remove interim driver support
 *   26-mar-96  jeffno  Removed cheap mutexes. Added check for mode change for NT's
 *                      ENTERDDRAW.
 *   29-apr-96  colinmc Bug 19954: Must query for Direct3D before texture or
 *                      device interface
 *   11-may-96  colinmc Bug 22293: New macro to validate GUID even if not
 *                      in debug
 *   17-may-96  kylej   Bug 23301: validate DDHALINFO size >= current size
 *   28-jul-96  colinmc Bug 2613:  Minimal support for secondary (stacked)
 *                                 drivers.
 *   16-aug-96  craige  include ddreg.h, added dwRegFlags + flag defns
 *   03-sep-96  craige  added app compat stuff.
 *   23-sep-96  ketand  added InternalGetClipList
 *   01-oct-96  ketand  added TIMING routings
 *   05-oct-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   17-nov-96  colinmc New ref flag to control the enabling and disabling
 *                      of PrintScreen
 *   02-jan-97  colinmc Initial AGP implementation work
 *   12-jan-97  colinmc More Win16 lock work
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   18-jan-97  colinmc AGP VMM support
 *   21-jan-97  ketand  Change DD16_SetPaletteEntries for multi-mon. Deleted
 *                      unused code.
 *   26-jan-97  ketand  Remove unused DD16_GetPaletteEntries. (It didn't handle
 *                      multi-mon; and wasn't worth fixing.) Also, remove
 *                      globals that don't work anymore with multi-mon.
 *   30-jan-97  colinmc Work item 4125: Need time bomb for final
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   02-feb-97  toddla  pass driver name to DD16_GetMonitor functions
 *                      added DD16_GetDeviceConfig
 *   02-feb-97  colinmc Bug 5625: V1.0 DirectX drivers don't get recognized
 *                      due to bad size check on DDCALLBACKS
 *   05-feb-97  ketand  Remove unused parameter from ClipRgnToRect
 *   22-feb-97  colinmc Enabled OWNDC for explicit system memory surfaces
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   04-mar-97  ketand  Added UpdateOutstandingDC to track palette changes
 *   08-mar-97  colinmc Added support for DMA style AGP parts
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   22-mar-97  colinmc Bug 6673: Add compile time option to allow new
 *                      applications to run against legacy run times.
 *   23-mar-97  colinmc Bug 6673 again: Changed structure numbering scheme
 *                      for consistency's sake
 *   24-mar-97  jeffno  Optimized Surfaces
 *   07-may-97  colinmc Moved AGP support detection from misc.c to ddagp.c
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   26-nov-97 t-craigs Added IDirectDrawPalette2
 *   19-dec-97 jvanaken IDDS4::Unlock now takes a pointer to a rectangle.
 *
 ***************************************************************************/

#ifndef __DDRAWPR_INCLUDED__
#define __DDRAWPR_INCLUDED__

#ifndef WIN95
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#endif

#ifdef WIN95
    #define WIN16_SEPARATE
#endif
#include "verinfo.h"

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <mmsystem.h>

#if defined( WIN95 ) && !defined ( NT_BUILD_ENVIRONMENT )
#undef PBT_APMRESUMEAUTOMATIC
    #include <pbt.h>
#endif

//#ifdef NT_BUILD_ENVIRONMENT
    /*
     * These are various definitions brought over from the win95 world, just to get us
     * compiling under the NT headers.
     */
    #ifdef WIN32
        /*
         * These come from \proj\dev\sdk\inc\winbase.h
         */
        #define FILE_FLAG_GLOBAL_HANDLE         0x00800000  // ;internal
        VOID    // ;internal
        WINAPI  // ;internal
        ReinitializeCriticalSection(    // ;internal
            LPCRITICAL_SECTION lpCriticalSection        // ;internal
            );  // ;internal

       //
       // Windows 9x stuff
       //

       #define CDS_EXCLUSIVE       0x80000000
       #define DISPLAY_DEVICE_VGA  0x00000010
       #define DCX_USESTYLE        0x00010000

    #endif //IS_32


    /*
     * These two come from \proj\dev\msdev\include\pbt.h
     */
    #define PBT_APMSUSPEND                  0x0004
    #define PBT_APMSTANDBY                  0x0005

//#endif //NT_BUILD_ENVIRONMENT

#include <string.h>
#include <stddef.h>

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #undef IS_32
    #define IS_32
    #include <dibeng.inc>
    #ifndef HARDWARECURSOR
        //#pragma message("defining local version of HARDWARECURSOR")
        #define HARDWARECURSOR 0x0100 // new post-Win95 deFlag
    #endif
#else
    #define IID void
#endif

#pragma warning( disable: 4704)

#include "dpf.h"

/*
 * registry stuff
 */
#include "ddreg.h"

/*
 * application compat. stuff
 */
#define DDRAW_APPCOMPAT_MODEXONLY           0x00000001l
#define DDRAW_APPCOMPAT_NODDSCAPSINDDSD     0x00000002l
#define DDRAW_APPCOMPAT_MMXFORRGB           0x00000004l
#define DDRAW_APPCOMPAT_EXPLICITMONITOR     0x00000008l
#define DDRAW_APPCOMPAT_SCREENSAVER         0x00000010l
#define DDRAW_APPCOMPAT_FORCEMODULATED      0x00000020l
#define DDRAW_APPCOMPAT_TEXENUMINCL_0       0x00000040l  // two bit field
#define DDRAW_APPCOMPAT_TEXENUMINCL_1       0x00000080l
#define DDRAW_APPCOMPAT_VALID               0x000000ffl

#define DDRAW_REGFLAGS_MODEXONLY        0x00000001l
#define DDRAW_REGFLAGS_EMULATIONONLY    0x00000002l
#define DDRAW_REGFLAGS_SHOWFRAMERATE    0x00000004l
#define DDRAW_REGFLAGS_ENABLEPRINTSCRN  0x00000008l
#define DDRAW_REGFLAGS_FORCEAGPSUPPORT  0x00000010l
#define DDRAW_REGFLAGS_DISABLEMMX       0x00000020l
#define DDRAW_REGFLAGS_DISABLEWIDESURF  0x00000040l
#define DDRAW_REGFLAGS_AGPPOLICYMAXBYTES 0x00000200l
#define DDRAW_REGFLAGS_FORCEREFRESHRATE 0x00008000l
#ifdef DEBUG
    #define DDRAW_REGFLAGS_DISABLENOSYSLOCK  0x00000080l
    #define DDRAW_REGFLAGS_FORCENOSYSLOCK    0x00000100l
#endif
#define DDRAW_REGFLAGS_NODDSCAPSINDDSD  0x00000400l
#define DDRAW_REGFLAGS_DISABLEAGPSUPPORT 0x00000800l
#ifdef DEBUG
    #define DDRAW_REGFLAGS_DISABLEINACTIVATE 0x00001000l
    #define DDRAW_REGFLAGS_PREGUARD          0x00002000l
    #define DDRAW_REGFLAGS_POSTGUARD         0x00004000l
#endif
#define DDRAW_REGFLAGS_USENONLOCALVIDMEM    0x00010000l

#define DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES 0x00008000l

extern  DWORD dwRegFlags;

#include "memalloc.h"

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #include <objbase.h>
#else
    #define IUnknown void
#endif
#include "ddrawi.h"
#include "dwininfo.h"

#ifdef WIN95
    #include "..\ddraw16\modex.h"
#endif

/*
 * Need this to get CDS_ macros under NT build environment for win95.
 * winuserp.h comes from private\windows\inc
 */
#ifdef NT_BUILD_ENVIRONMENT
    #ifdef WIN32
        #include "winuserp.h"
    #endif
#endif
#include "ids.h"

/*
 * NT kernel mode stub(ish)s
 */
#ifndef WIN95
    #include "ddrawgdi.h"
#endif

/*
 * Driver version info
 */

//========================================================================
// advanced driver information
//========================================================================
typedef struct tagDDDRIVERINFOEX
{
        DDDEVICEIDENTIFIER      di;
        char                    szDeviceID[MAX_DDDEVICEID_STRING];
} DDDRIVERINFOEX, * LPDDDRIVERINFOEX;



/*
 * Direct3D interfacing defines.
 */
#ifndef NO_D3D
#include "ddd3dapi.h"
#endif
#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN95
    #define USE_CRITSECTS
    extern void DDAPI DD16_SetEventHandle( DWORD hInstance, DWORD dwEvent );
    extern void DDAPI DD16_DoneDriver( DWORD hInstance );
    extern void DDAPI DD16_GetDriverFns( LPDDHALDDRAWFNS list );
    extern void DDAPI DD16_GetHALInfo( LPDDHALINFO pinfo );
    extern LONG DDAPI DD16_ChangeDisplaySettings( LPDEVMODE pdm, DWORD flags);
    extern HRGN DDAPI DD16_InquireVisRgn( HDC );
    extern void DDAPI DD16_SelectPalette( HDC, HPALETTE, BOOL );
    extern BOOL DDAPI DD16_SetPaletteEntries( HDC hdc, DWORD dwBase, DWORD dwNum, LPPALETTEENTRY, BOOL fPrimary );
    extern void DDAPI DD16_EnableReboot( BOOL );
    extern void DDAPI DD16_SetCertified( BOOL iscert );
    extern BOOL DDAPI DCIIsBanked( HDC hdc );
    #define GETCURRPID HackGetCurrentProcessId
    VOID WINAPI MakeCriticalSectionGlobal( CSECT_HANDLE lpcsCriticalSection );

    extern HDC  DDAPI DD16_GetDC(HDC hdc, LPDDSURFACEDESC pddsd, LPPALETTEENTRY lpPalette);
    extern void DDAPI DD16_ReleaseDC(HDC hdc);
    extern BOOL DDAPI DD16_SafeMode(HDC hdc, BOOL fSafeMode);

    extern void DDAPI DD16_Exclude(DWORD dwPDevice, RECTL FAR *prcl);
    extern void DDAPI DD16_Unexclude(DWORD dwPDevice);

    extern int DDAPI DD16_Stretch(DWORD DstPtr, int DstPitch, UINT DstBPP, int DstX, int DstY, int DstDX, int DstDY,
                       DWORD SrcPtr, int SrcPitch, UINT SrcBPP, int SrcX, int SrcY, int SrcDX, int SrcDY);
    extern BOOL DDAPI DD16_IsWin95MiniDriver( void );
    extern int  DDAPI DD16_GetMonitorMaxSize(LPSTR szDevice);
    extern BOOL DDAPI DD16_GetMonitorRefreshRateRanges(LPSTR szDevice, int xres, int yres, int FAR *pmin, int FAR *pmax);
    extern DWORD DDAPI DD16_GetDeviceConfig(LPSTR szDevice, LPVOID lpConfig, DWORD size);
    extern BOOL DDAPI DD16_GetMonitorEDIDData(LPSTR szDevice, LPVOID lpEdidData);
    extern DWORD DDAPI DD16_GetRateFromRegistry( LPSTR szDevice );
    extern int DDAPI DD16_SetRateInRegistry( LPSTR szDevice, DWORD dwRateToRestore );

    #ifdef USE_ALIAS
        extern BOOL DDAPI DD16_FixupDIBEngine( void );
    #endif /* USE_ALIAS */
    extern WORD DDAPI DD16_MakeObjectPrivate(HDC hdc, BOOL fPrivate);
    extern BOOL DDAPI DD16_AttemptGamma(HDC hdc);
    extern BOOL DDAPI DD16_IsDeviceBusy(HDC hdc);

#else
    #define DD16_DoneDriver( hInstance ) 0
    #define DD16_GetDriverFns( list ) 0
    #define DD16_GetHALInfo( pinfo ) 0
    #define DD16_ChangeDisplaySettings( pdm, flags) ChangeDisplaySettings( pdm, flags )
    #define DD16_SelectPalette( hdc, hpal ) SelectPalette( hdc, hpal, FALSE )
    #define DD16_EnableReboot( retboot ) 0
    #define DD16_WWOpen( ptr ) 0
    #define DD16_WWClose( ptr, newlist ) 0
    #define DD16_WWNotifyInit( pww, lpcallback, param ) 0
    #define DD16_WWGetClipList( pww, prect, rdsize, prd ) 0
    //
    // On NT, it is an assert that we are never called by DDHELP, so we should always be
    // working on the current process.
    //
    #define GETCURRPID GetCurrentProcessId
    #define DCIIsBanked( hdc ) FALSE
    #define DD16_IsWin95MiniDriver() TRUE
    #define DD16_SetCertified( iscert ) 0
    #define DD16_GetMonitorMaxSize(dev) 0
    #define DD16_GetMonitorRefreshRateRanges( dev, xres, yres, pmin, pmax) 0
    #define DD16_GetRateFromRegistry( szDevice ) 0
    #define DD16_SetRateInRegistry( szDevice, dwRateToRestore ) 0
    #ifdef USE_ALIAS
        #define DD16_FixupDIBEngine() TRUE
    #endif /* USE_ALIAS */
    #define DD16_AttemptGamma( hdc) 0
    #define DD16_IsDeviceBusy( hdc) 0
#endif

#ifndef NO_DDHELP
    #include "w95help.h"
#endif //NO_DDHELP

#define TRY             _try
#define EXCEPT(a)       _except( a )

extern LPDDRAWI_DDRAWCLIPPER_INT lpGlobalClipperList;

/*
 * list of processes attached to DLL
 */
typedef struct ATTACHED_PROCESSES
{
    struct ATTACHED_PROCESSES   *lpLink;
    DWORD                       dwPid;
#ifdef WINNT
    DWORD                       dwNTToldYet;
#endif
} ATTACHED_PROCESSES, FAR *LPATTACHED_PROCESSES;

//extern LPATTACHED_PROCESSES   lpAttachedProcesses;

/* Structure for keeping track of DCs that have
 * been handed out by DDraw for surfaces.
 */
typedef struct _dcinfo
{
    HDC hdc;                            // HDC associated with surface
    LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl; // Surface associated with HDC
    struct _dcinfo * pdcinfoNext;       // Pointer to next
} DCINFO, *LPDCINFO;
/*
 *  Head of the list of DCs handed out.
 */
extern DCINFO *g_pdcinfoHead;

/*
 * macros for doing allocations of a temporary basis.
 * Tries alloca first, if that fails, it will allocate storage from the heap
 */
#ifdef USEALLOCA
    #define TMPALLOC( ptr, size ) \
            ptr = _alloca( (size)+sizeof( DWORD ) ); \
            if( ptr == NULL ) \
            { \
                ptr = MemAlloc( (size)+sizeof( DWORD ) ); \
                if( ptr != NULL ) \
                { \
                    *(DWORD *)ptr = 1; \
                    (LPSTR) ptr += sizeof( DWORD ); \
                } \
            } \
            else \
            { \
                *(DWORD *)ptr = 0; \
                (LPSTR) ptr += sizeof( DWORD ); \
            }

    #define TMPFREE( ptr ) \
            if( ptr != NULL ) \
            { \
                (LPSTR) ptr -= sizeof( DWORD ); \
                if( (*(DWORD *) ptr) ) \
                { \
                    MemFree( ptr ); \
                } \
            }
#else

    #define TMPALLOC( ptr, size )  ptr = MemAlloc( size );
    #define TMPFREE( ptr )  MemFree( ptr );

#endif

/*
 * macros for getting at values that aren't always present in the surface
 * object
 */
#define GET_PIXEL_FORMAT( thisx, thisl, pddpf ) \
    if( thisx->dwFlags & DDRAWISURF_HASPIXELFORMAT ) \
    { \
        pddpf = &thisl->ddpfSurface; \
    } \
    else \
    { \
        pddpf = &thisl->lpDD->vmiData.ddpfDisplay; \
    }

/*
 * macro for building a rectangle that is the size of a surface.
 * For multi-monitor systems, we have a different code path
 * to deal with the fact that the upper-left coord may not be zero.
 */
#define MAKE_SURF_RECT( surf, surf_lcl, r ) \
    r.top = 0;                  \
    r.left = 0;                 \
    r.bottom = (DWORD) surf->wHeight; \
    r.right = (DWORD) surf->wWidth;

/*
 * macro for doing doing HAL call.
 *
 * Takes the Win16 lock for 32-bit Win95 driver routines.  This serves a
 * 2-fold purpose:
 *      1) keeps the 16-bit portion of the driver safe
 *      2) 32-bit routine needs lock others out while its updating
 *         its hardware
 */
#if defined( WIN95 ) && defined( WIN16_SEPARATE )
    #define DOHALCALL( halcall, fn, data, rc, isHEL ) \
        if( (fn != _DDHAL_##halcall) && !isHEL ) { \
            ENTER_WIN16LOCK(); \
            rc = fn( &data ); \
            LEAVE_WIN16LOCK(); \
        } else { \
            rc = fn( &data ); \
        }

    #define DOHALCALL_NOWIN16( halcall, fn, data, rc, isHEL ) \
            rc = fn( &data );
#else
    #define DOHALCALL( halcall, fn, data, rc, isHEL ) \
            if (fn) \
                rc = fn( &data );\
            else\
                rc = DDHAL_DRIVER_NOTHANDLED;
    #define DOHALCALL_NOWIN16( halcall, fn, data, rc, isHEL ) \
            if (fn) \
                rc = fn( &data );\
            else\
                rc = DDHAL_DRIVER_NOTHANDLED;
#endif


/*
 * macro for incrementing/decrementing the driver ref count
 */
#define CHANGE_GLOBAL_CNT( pdrv, thisg, cnt ) \
    if( !(thisg->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED) ) \
    { \
        (int) pdrv->dwSurfaceLockCount += (int) (cnt); \
    }


/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

/*
 * maximum timeout (in ms) when spinlocked on a surface
 */
#define MAX_TIMEOUT     5000

/*
 * defined in dllmain.c
 */
extern CSECT_HANDLE     lpDDCS;
#ifdef WINNT
    extern HANDLE hDriverObjectListMutex;
#else
    #ifdef IS_32
        extern CRITICAL_SECTION csDriverObjectList;
    #endif
#endif
#define MAX_TIMER_HWNDS 15
extern HWND ghwndTopmostList[MAX_TIMER_HWNDS];
extern int giTopmostCnt;
extern BOOL bGammaCalibratorExists;
extern BYTE szGammaCalibrator[MAX_PATH];
extern DWORD dwForceRefreshRate;

/*
 * blt flags
 */
#define DDBLT_PRIVATE_ALIASPATTERN      0x80000000l

/*
 * get the fail code based on what HAL and HEL support; used by BLT
 *
 * assumes variables halonly, helonly, fail are defined
 */
#define GETFAILCODEBLT( testhal, testhel, halonly, helonly, flag ) \
    if( halonly ) { \
        if( !(testhal & flag) ) { \
            fail = TRUE; \
        } \
    } else if( helonly ) { \
        if( !(testhel & flag) ) { \
            fail = TRUE; \
        } \
    } else { \
        if( !(testhal & flag) ) { \
            if( !(testhel & flag) ) { \
                fail = TRUE; \
            } else { \
                helonly = TRUE; \
            } \
        } else { \
            halonly = TRUE; \
        } \
    }

/*
 * get the fail code based on what HAL and HEL support
 *
 * assumes variables halonly, helonly, fail are defined
 */
#define GETFAILCODE( testhal, testhel, flag ) \
    if( halonly ) \
    { \
        if( !(testhal & flag) ) \
        { \
            fail = TRUE; \
        } \
    } \
    else if( helonly ) \
    { \
        if( !(testhel & flag) ) \
        { \
            fail = TRUE; \
        } \
    } \
    else \
    { \
        if( !(testhal & flag) ) \
        { \
            if( !(testhel & flag) ) \
            { \
                fail = TRUE; \
            } \
            else \
            { \
                helonly = TRUE; \
            } \
        } \
        else \
        { \
            halonly = TRUE; \
        } \
    }


typedef struct {
    DWORD               src_height;
    DWORD               src_width;
    DWORD               dest_height;
    DWORD               dest_width;
    BOOL                halonly;
    BOOL                helonly;
    LPDDHALSURFCB_BLT   bltfn;
    LPDDHALSURFCB_BLT   helbltfn;
} SPECIAL_BLT_DATA, FAR *LPSPECIAL_BLT_DATA;

/*
 * synchronization
 */
#ifdef WINNT
#define RELEASE_EXCLUSIVEMODE_MUTEX {if (hExclusiveModeMutex) ReleaseMutex(hExclusiveModeMutex);}
#else
    #define RELEASE_EXCLUSIVEMODE_MUTEX ;
#endif


//--------------------------------- new cheap mutexes -------------------------------------------
//
// Global Critical Sections have two components. One piece is shared between all
// applications using the global lock. This portion will typically reside in some
// sort of shared memory
//
// The second piece is per-process. This contains a per-process handle to the shared
// critical section lock semaphore. The semaphore is itself shared, but each process
// may have a different handle value to the semaphore.
//
// Global critical sections are attached to by name. The application wishing to
// attach must know the name of the critical section (actually the name of the shared
// lock semaphore, and must know the address of the global portion of the critical
// section
//

typedef struct _GLOBAL_SHARED_CRITICAL_SECTION {
    LONG LockCount;
    LONG RecursionCount;
    DWORD OwningThread;
    DWORD OwningProcess;
    DWORD Reserved;
} GLOBAL_SHARED_CRITICAL_SECTION, *PGLOBAL_SHARED_CRITICAL_SECTION;

typedef struct _GLOBAL_LOCAL_CRITICAL_SECTION {
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    HANDLE LockSemaphore;
    DWORD Reserved1;
    DWORD Reserved2;
} GLOBAL_LOCAL_CRITICAL_SECTION, *PGLOBAL_LOCAL_CRITICAL_SECTION;

/*
 * The following functions are defined in mutex.c
 */
BOOL
WINAPI
AttachToGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion,
    PGLOBAL_SHARED_CRITICAL_SECTION lpGlobalPortion,
    LPCSTR lpName
    );
BOOL
WINAPI
DetachFromGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
VOID
WINAPI
EnterGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
VOID
WINAPI
LeaveGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
void
DestroyPIDsLock(
                PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion,
                DWORD                           dwPid,
                LPSTR                           lpName
    );


#define DDRAW_FAST_CS_NAME "DdrawGlobalFastCrit"
extern GLOBAL_LOCAL_CRITICAL_SECTION CheapMutexPerProcess;
extern GLOBAL_SHARED_CRITICAL_SECTION CheapMutexCrossProcess;

#define CHEAP_LEAVE {LeaveGlobalCriticalSection(&CheapMutexPerProcess);}
#define CHEAP_ENTER {EnterGlobalCriticalSection(&CheapMutexPerProcess);}

#ifdef WINNT
//    #define USE_CHEAP_MUTEX
#define NT_USES_CRITICAL_SECTION
#endif

extern void ModeChangedOnENTERDDRAW(void); // in ddmodent.c
extern ULONG uDisplaySettingsUnique;

//
#ifdef IS_32
    #ifndef USE_CRITSECTS
        #define INIT_DDRAW_CSECT()
        #define FINI_DDRAW_CSECT()
        #define ENTER_DDRAW()
        #define LEAVE_DDRAW()
        #define ENTER_DRIVERLISTCSECT()
        #define LEAVE_DRIVERLISTCSECT()
    #else //so use csects:
        #ifdef DEBUG
            //extern int iWin16Cnt;
            //extern int iDLLCSCnt;
            #define INCCSCNT() iDLLCSCnt++;
            #define DECCSCNT() iDLLCSCnt--;
            #define INCW16CNT() iWin16Cnt++;
            #define DECW16CNT() iWin16Cnt--;
        #else
            #define INCCSCNT()
            #define DECCSCNT()
            #define INCW16CNT()
            #define DECW16CNT()
        #endif //debug

        #ifdef WINNT
                extern HANDLE hDirectDrawMutex; //def'd in dllmain.c
                #ifdef USE_CHEAP_MUTEX
                    //--------------------------------- new cheap mutexes -------------------------------------------
                        #define ENTER_DDRAW() {CHEAP_ENTER;}
                        #define ENTER_DDRAW_INDLLMAIN() CHEAP_ENTER
                        #define LEAVE_DDRAW() CHEAP_LEAVE
                    #define INIT_DDRAW_CSECT()                                                                     \
                        {                                                                                          \
                            if (!AttachToGlobalCriticalSection(&CheapMutexPerProcess,&CheapMutexCrossProcess,DDRAW_FAST_CS_NAME) )  \
                                {DPF(0,"===================== Mutex Creation FAILED =================");}          \
                        }

                    #define FINI_DDRAW_CSECT() {DetachFromGlobalCriticalSection(&CheapMutexPerProcess);}

                #else

                    #ifdef NT_USES_CRITICAL_SECTION
                        //
                        // Use critical sections
                        //
                        #define INIT_DDRAW_CSECT() InitializeCriticalSection( lpDDCS );

                        #define FINI_DDRAW_CSECT() DeleteCriticalSection( lpDDCS );

                        extern DWORD gdwRecursionCount;

                        #define ENTER_DDRAW() \
                                {                                                                   \
                                    DWORD dwUniqueness;                                             \
                                    EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS );            \
                                    gdwRecursionCount++;                                            \
                                    dwUniqueness = DdQueryDisplaySettingsUniqueness();              \
                                    if (dwUniqueness != uDisplaySettingsUnique &&                   \
                                        1 == gdwRecursionCount)                                     \
                                    {                                                               \
                                        ModeChangedOnENTERDDRAW();                                  \
                                        uDisplaySettingsUnique = dwUniqueness;                      \
                                    }                                                               \
                                }

                        #define ENTER_DDRAW_INDLLMAIN() \
                                    EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS );            \
                                    gdwRecursionCount++;

                        #define LEAVE_DDRAW() { gdwRecursionCount--; LeaveCriticalSection( (LPCRITICAL_SECTION) lpDDCS );}


                    #else
                        //
                        // Use a mutex object.
                        //

                        #define INIT_DDRAW_CSECT()                                                      \
                            { if (hDirectDrawMutex) {DPF(0,"Direct draw mutex initialised twice!");}    \
                              else{                                                                     \
                                hDirectDrawMutex = CreateMutex(NULL,FALSE,"DirectDrawMutexName");       \
                                if (!hDirectDrawMutex) {DPF(0,"===================== Mutex Creation FAILED =================");}\
                                }      \
                            }

                        extern DWORD gdwRecursionCount;
                        #define FINI_DDRAW_CSECT() { if (hDirectDrawMutex) CloseHandle(hDirectDrawMutex); }
                        #define LEAVE_DDRAW() { gdwRecursionCount--;ReleaseMutex(hDirectDrawMutex); }
                        #define ENTER_DDRAW()                                                       \
                                {                                                                   \
                                    DWORD dwUniqueness,dwWaitValue;                                 \
                                    dwWaitValue = WaitForSingleObject(hDirectDrawMutex,INFINITE);   \
                                    gdwRecursionCount++;                                            \
                                    dwUniqueness = DdQueryDisplaySettingsUniqueness();              \
                                    if (dwUniqueness != uDisplaySettingsUnique &&                   \
                                        1 == gdwRecursionCount)                                     \
                                    {                                                               \
                                        ModeChangedOnENTERDDRAW();                                  \
                                        uDisplaySettingsUnique = dwUniqueness;                      \
                                    }                                                               \
                                }
                        #define ENTER_DDRAW_INDLLMAIN() WaitForSingleObject(hDirectDrawMutex,INFINITE);
                    #endif //use (expensive) mutexes
                #endif //use_cheap_mutex

                #define ENTER_DRIVERLISTCSECT() \
                        WaitForSingleObject(hDriverObjectListMutex,INFINITE);
                #define LEAVE_DRIVERLISTCSECT() \
                        ReleaseMutex(hDriverObjectListMutex);

        #else //not winnt:
            #ifdef WIN16_SEPARATE
                #define INIT_DDRAW_CSECT() \
                        ReinitializeCriticalSection( lpDDCS ); \
                        MakeCriticalSectionGlobal( lpDDCS );

                #define FINI_DDRAW_CSECT() \
                        DeleteCriticalSection( lpDDCS );

                #define ENTER_DDRAW() \
                        DPF( 7, "*****%08lx ENTER_DDRAW: CNT = %ld," REMIND( "" ), GETCURRPID(), iDLLCSCnt ); \
                        EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS ); \
                        INCCSCNT(); \
                        DPF( 7, "*****%08lx GOT DDRAW CSECT: CNT = %ld," REMIND(""), GETCURRPID(), iDLLCSCnt );

                #define LEAVE_DDRAW() \
                        DECCSCNT() \
                        DPF( 7, "*****%08lx LEAVE_DDRAW: CNT = %ld," REMIND( "" ), GETCURRPID(), iDLLCSCnt ); \
                        LeaveCriticalSection( (LPCRITICAL_SECTION) lpDDCS );

            #else //not WIN16_SEPARATE

                #define INIT_DDRAW_CSECT()
                #define FINI_DDRAW_CSECT()
                #define ENTER_DDRAW()   \
                            DPF( 7, "*****%08lx ENTER_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                            _EnterSysLevel( lpWin16Lock ); \
                            INCW16CNT(); \
                            DPF( 7, "*****%08lx GOT WIN16LOCK: CNT = %ld," REMIND(""), GETCURRPID(), iWin16Cnt );
                #define LEAVE_DDRAW() \
                            DECW16CNT() \
                            DPF( 7, "*****%08lx LEAVE_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                            _LeaveSysLevel( lpWin16Lock );

            #endif //win16_separate
            #define ENTER_DRIVERLISTCSECT() \
                        EnterCriticalSection( &csDriverObjectList );

            #define LEAVE_DRIVERLISTCSECT() \
                        LeaveCriticalSection( &csDriverObjectList );
        #endif  //winnt
    #endif //use csects

    #if defined(WIN95)
        /*
         * selector management functions
         */
        extern DWORD _stdcall MapLS( LPVOID );  // flat -> 16:16
        extern void _stdcall UnMapLS( DWORD ); // unmap 16:16
        extern LPVOID _stdcall MapSLFix( DWORD ); // 16:16->flat
        extern LPVOID _stdcall MapSL( DWORD ); // 16:16->flat
        //extern void _stdcall UnMapSLFix( LPVOID ); // 16:16->flat
        /*
         * win16 lock
         */
        extern void _stdcall    GetpWin16Lock( LPVOID FAR *);
        extern void _stdcall    _EnterSysLevel( LPVOID );
        extern void _stdcall    _LeaveSysLevel( LPVOID );
        extern LPVOID           lpWin16Lock;
    #endif win95
#endif //is_32

#ifdef WIN95
    #ifdef WIN16_SEPARATE
        #define ENTER_WIN16LOCK()       \
                    DPF( 7, "*****%08lx ENTER_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                    _EnterSysLevel( lpWin16Lock ); \
                    INCW16CNT(); \
                    DPF( 7, "*****%08lx GOT WIN16LOCK: CNT = %ld," REMIND(""), GETCURRPID(), iWin16Cnt );
        #define LEAVE_WIN16LOCK() \
                    DECW16CNT() \
                    DPF( 7,"*****%08lx LEAVE_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                    _LeaveSysLevel( lpWin16Lock );
    #else
        #define ENTER_WIN16LOCK()       badbadbad
        #define LEAVE_WIN16LOCK()       badbadbad
    #endif
#else
    #define ENTER_WIN16LOCK()
    #define LEAVE_WIN16LOCK()
#endif

#ifdef WIN16_SEPARATE
    #define ENTER_BOTH() \
            ENTER_DDRAW(); \
            ENTER_WIN16LOCK();

    #define LEAVE_BOTH() \
            LEAVE_WIN16LOCK(); \
            LEAVE_DDRAW();
#else
    #define ENTER_BOTH() \
            ENTER_DDRAW();
    #define LEAVE_BOTH() \
            LEAVE_DDRAW();
#endif

/* We now have a special case in dllmain on NT... */
#ifndef ENTER_DDRAW_INDLLMAIN
    #define ENTER_DDRAW_INDLLMAIN() ENTER_DDRAW()
#endif

#ifdef WIN95

    /*
     * DDHELP's handle for communicating with the DirectSound VXD. We need this
     * when we are executing DDRAW code with one of DDHELP's threads.
     */
    extern HANDLE hHelperDDVxd;

    /*
     * Macro to return the DirectSound VXD handle to use when communicating with
     * the VXD. This is necessary as we need to communicate with the VXD from
     * DirectDraw executing on a DDHELP thread. In which case we need to use
     * the VXD handle defined above (which is the VXD handle DDHELP got when it
     * loaded DDRAW.VXD). Otherwise, we use the VXD handle out of the given
     * local object.
     *
     * NOTE: We don't use GETCURRPID() or HackGetCurrentProcessId() as we want
     * the real PID not one that has been munged.
     */
    #define GETDDVXDHANDLE( pdrv_lcl ) \
        ( ( GetCurrentProcessId() == ( pdrv_lcl )->dwProcessId ) ? (HANDLE) ( ( pdrv_lcl )->hDDVxd ) : hHelperDDVxd )

#else  /* !WIN95 */

    #define GETDDVXDHANDLE( pdrv_lcl ) NULL

#endif /* !WIN95 */

#define VDPF(Args) DPF Args
#include "ddheap.h"
#include "ddagp.h"
/* apphack.c */
extern void FreeAppHackData(void);


/* cliprgn.h */
extern void ClipRgnToRect( LPRECT prect, LPRGNDATA prd );

/* ddcsurf.c */
extern BOOL isPowerOf2(DWORD dw, int* pPower);
extern HRESULT checkSurfaceDesc( LPDDSURFACEDESC2 lpsd, LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD FAR *psflags, BOOL emulation, BOOL real_sysmem, LPDDRAWI_DIRECTDRAW_INT pdrv_int );
extern DWORD ComputePitch( LPDDRAWI_DIRECTDRAW_GBL thisg, DWORD caps, DWORD width, UINT bpp );
extern DWORD GetBytesFromPixels( DWORD pixels, UINT bpp );
extern HRESULT InternalCreateSurface( LPDDRAWI_DIRECTDRAW_LCL thisg, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *lplpDDSurface, LPDDRAWI_DIRECTDRAW_INT this_int );
extern HRESULT AllocSurfaceMem( LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPDDRAWI_DDRAWSURFACE_LCL *slist, int nsurf );
#ifdef DEBUG
    void SurfaceSanityTest( LPDDRAWI_DIRECTDRAW_LCL pdrv, LPSTR title );
    #define SURFSANITY( a,b ) SurfaceSanityTest( a, b );
#else
    #define SURFSANITY( a,b )
#endif

/* ddclip.c */
extern HRESULT InternalCreateClipper( LPDDRAWI_DIRECTDRAW_GBL lpDD, DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter, BOOL fInitialized, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DIRECTDRAW_INT pdrv_int );
void ProcessClipperCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* ddcreate.c */
extern BOOL IsVGADevice(LPSTR szDevice);
extern char g_szPrimaryDisplay[];
extern BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, struct _DISPLAY_DEVICEA *pdd, DWORD dwFlags);
extern BOOL CurrentProcessCleanup( BOOL );
extern LPHEAPALIGNMENT GetExtendedHeapAlignment( LPDDRAWI_DIRECTDRAW_GBL pddd , LPDDHAL_GETHEAPALIGNMENTDATA pghad, int iHeap);
extern void RemoveDriverFromList( LPDDRAWI_DIRECTDRAW_INT lpDD, BOOL );
extern void RemoveLocalFromList( LPDDRAWI_DIRECTDRAW_LCL lpDD_lcl );
extern LPDDRAWI_DIRECTDRAW_GBL DirectDrawObjectCreate( LPDDHALINFO lpDDHALInfo, BOOL reset, LPDDRAWI_DIRECTDRAW_GBL pdrv, HANDLE hDDVxd, char *szDrvName, DWORD dwDriverContext );
extern LPDDRAWI_DIRECTDRAW_GBL FetchDirectDrawData( LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL reset, DWORD hInstance, HANDLE hDDVxd, char *szDrvName, DWORD dwDriverContext, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern LPVOID NewDriverInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPVOID lpvtbl );
extern DWORD DirectDrawMsg(LPSTR msg);
extern BOOL DirectDrawSupported( void );
extern BOOL IsMultiMonitor( void );
extern LPDDRAWI_DIRECTDRAW_GBL fetchModeXData(LPDDRAWI_DIRECTDRAW_GBL pdrv,LPDDHALMODEINFO pmi, HANDLE hDDVxd );

#ifdef WINNT
extern BOOL GetCurrentMode(LPDDRAWI_DIRECTDRAW_GBL, LPDDHALINFO lpHalInfo, char *szDrvName);
extern HRESULT GetNTDeviceRect( LPSTR pDriverName, LPRECT lpRect );
#endif

extern HDC  DD_CreateDC(LPSTR pdrvname);
extern void DD_DoneDC(HDC hdc);

#ifdef IS_32
extern LONG xxxChangeDisplaySettingsExA(LPCSTR szDevice, LPDEVMODEA pdm, HWND hwnd, DWORD dwFlags,LPVOID lParam);
extern HRESULT InternalDirectDrawCreate( GUID * lpGUID, LPDIRECTDRAW *lplpDD, LPDDRAWI_DIRECTDRAW_INT pnew_int, DWORD dwFlags );
extern void UpdateRectFromDevice( LPDDRAWI_DIRECTDRAW_GBL pdrv );
extern void UpdateAllDeviceRects( void );
#endif

/* ddiunk.c */
extern HRESULT InitD3D( LPDDRAWI_DIRECTDRAW_INT this_int );
extern HRESULT InitDDrawPrivateD3DContext( LPDDRAWI_DIRECTDRAW_INT this_int );

/* dddefwp.c */
extern HRESULT SetAppHWnd( LPDDRAWI_DIRECTDRAW_LCL thisg, HWND hWnd, DWORD dwFlags );
extern VOID CleanupWindowList( DWORD pid );
extern void ClipTheCursor(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPRECT lpRect);

/* ddesurf.c */
extern void FillDDSurfaceDesc( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC lpdsd );
extern void FillDDSurfaceDesc2( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC2 lpdsd );
extern void FillEitherDDSurfaceDesc( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC2 lpdsd );

/* ddfake.c */
extern BOOL getBitMask( LPDDHALMODEINFO pmi );
extern LPDDRAWI_DIRECTDRAW_GBL FakeDDCreateDriverObject( HDC hdc_dd, LPSTR szDrvName, LPDDRAWI_DIRECTDRAW_GBL, BOOL reset, HANDLE hDDVxd );
extern DWORD BuildModes( LPSTR szDevice, LPDDHALMODEINFO FAR *ppddhmi );
extern void BuildPixelFormat(HDC, LPDDHALMODEINFO, LPDDPIXELFORMAT);

/* ddpal.c */
extern void ResetSysPalette( LPDDRAWI_DDRAWSURFACE_GBL psurf, BOOL dofree );
extern void ProcessPaletteCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern ULONG DDAPI InternalPaletteRelease( LPDDRAWI_DDRAWPALETTE_INT this_int );
extern HRESULT SetPaletteAlways( LPDDRAWI_DDRAWSURFACE_INT psurf_int, LPDIRECTDRAWPALETTE lpDDPalette );

/* ddraw.c */
extern void DoneExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv );
extern void StartExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv, DWORD dwFlags, DWORD pid );
extern HRESULT FlipToGDISurface( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_INT psurf_int); //, FLATPTR fpprim );
extern void CheckExclusiveMode(LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPBOOL pbExclusiveExists, LPBOOL pbThisLclOwnsExclusive, BOOL bKeepMutex, HWND hwnd, BOOL bCanGetIt);

/* ddsacc.c */
void WINAPI AcquireDDThreadLock(void);
void WINAPI ReleaseDDThreadLock(void);
extern void RemoveProcessLocks( LPDDRAWI_DIRECTDRAW_LCL pdrv, LPDDRAWI_DDRAWSURFACE_LCL this_lcl, DWORD pid );
extern HRESULT InternalLock( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID *pbits,
                             LPRECT lpDestRect, DWORD dwFlags);
extern HRESULT InternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpSurfaceData, LPRECT lpDestRect, DWORD dwFlags );
#ifdef USE_ALIAS
    extern void BreakSurfaceLocks( LPDDRAWI_DDRAWSURFACE_GBL thisg );
#endif /* USE_ALIAS */

/* ddsatch.c */
extern void UpdateMipMapCount( LPDDRAWI_DDRAWSURFACE_INT psurf_int );
extern HRESULT AddAttachedSurface( LPDDRAWI_DDRAWSURFACE_INT psurf_from, LPDDRAWI_DDRAWSURFACE_INT psurf_to, BOOL implicit );
extern void DeleteAttachedSurfaceLists( LPDDRAWI_DDRAWSURFACE_LCL psurf );
#define DOA_DONTDELETEIMPLICIT FALSE
#define DOA_DELETEIMPLICIT     TRUE
extern HRESULT DeleteOneAttachment( LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DDRAWSURFACE_INT pattsurf_int, BOOL cleanup, BOOL delete_implicit );
extern HRESULT DeleteOneLink( LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DDRAWSURFACE_INT pattsurf_int );

/* ddsblt.c */
extern void WaitForDriverToFinishWithSurface(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl );
extern LPDDRAWI_DDRAWSURFACE_LCL FindAttached( LPDDRAWI_DDRAWSURFACE_LCL ptr, DWORD caps );
extern HRESULT XformRect(RECT * prcSrc,RECT * prcDest,RECT * prcClippedDest,RECT * prcClippedSrc,DWORD scale_x,DWORD scale_y);
// SCALE_X and SCALE_Y are fixed point variables scaled 16.16. These macros used by calls to XformRect.
#define SCALE_X(rcSrc,rcDest) ( ((rcSrc.right - rcSrc.left) << 16) / (rcDest.right - rcDest.left))
#define SCALE_Y(rcSrc,rcDest) ( ((rcSrc.bottom - rcSrc.top) << 16) / (rcDest.bottom - rcDest.top))

/* ddsckey.c */
extern HRESULT CheckColorKey( DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDCOLORKEY lpDDColorKey, LPDWORD psflags, BOOL halonly, BOOL helonly );
extern HRESULT ChangeToSoftwareColorKey( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL );

/* ddsiunk.c */
extern LPDDRAWI_DDRAWSURFACE_LCL NewSurfaceLocal( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpvtbl );
extern LPDDRAWI_DDRAWSURFACE_INT NewSurfaceInterface( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpvtbl );
extern void DestroySurface( LPDDRAWI_DDRAWSURFACE_LCL thisg );
extern void LooseManagedSurface( LPDDRAWI_DDRAWSURFACE_LCL thisg );
extern DWORD InternalSurfaceRelease( LPDDRAWI_DDRAWSURFACE_INT this_int );
extern void ProcessSurfaceCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern void FreeD3DSurfaceIUnknowns( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* ddmode.c */
extern HRESULT SetDisplayMode( LPDDRAWI_DIRECTDRAW_LCL thisx, DWORD modeidx, BOOL force, BOOL useRefreshRate );
extern HRESULT RestoreDisplayMode( LPDDRAWI_DIRECTDRAW_LCL thisx, BOOL force );
extern void AddModeXModes( LPDDRAWI_DIRECTDRAW_GBL pdrv );
extern BOOL MonitorCanHandleMode(LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD width, DWORD height, WORD refreshRate );
extern BOOL GetDDStereoMode( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD dwWidth, DWORD dwHeight, DWORD dwBpp, DWORD dwRefreshRate);

/* ddsurf.c */
extern HRESULT InternalGetBltStatus(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl , DWORD dwFlags );
extern HRESULT MoveToSystemMemory( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL hasvram, BOOL use_full_lock );
extern void InvalidateAllPrimarySurfaces( LPDDRAWI_DIRECTDRAW_GBL );
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalPrimary( LPDDRAWI_DIRECTDRAW_GBL );
extern BOOL MatchPrimary( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC2 lpDDSD );
extern void InvalidateAllSurfaces( LPDDRAWI_DIRECTDRAW_GBL thisg, HANDLE hDDVxd, BOOL fRebuildAliases );
#ifdef SHAREDZ
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalZBuffer( LPDDRAWI_DIRECTDRAW_GBL );
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalBackBuffer( LPDDRAWI_DIRECTDRAW_GBL );
extern BOOL MatchSharedZBuffer( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC lpDDSD );
extern BOOL MatchSharedBackBuffer( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC lpDDSD );
#endif
extern HRESULT InternalPageLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern HRESULT InternalPageUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

extern LPDDRAWI_DDRAWSURFACE_INT getDDSInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpddcb );

extern HRESULT InternalGetDC( LPDDRAWI_DDRAWSURFACE_INT this_int, HDC FAR *lphdc );
extern HRESULT InternalReleaseDC( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, HDC hdc );
extern HRESULT EXTERN_DDAPI GetSurfaceFromDC( HDC hdc, LPDIRECTDRAWSURFACE *ppdds, HDC *phdcDriver );
extern HRESULT InternalAssociateDC( HDC hdc, LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl );
extern HRESULT InternalRemoveDCFromList( HDC hdc, LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl );


// function from ddsprite.c to clean pid from master sprite list:
void ProcessSpriteCleanup(LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid);

#ifdef WIN95
extern void UpdateOutstandingDC( LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl, LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl );
extern void UpdateDCOnPaletteChanges( LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl );
#else
#define UpdateOutstandingDC(x,y)
#define UpdateDCOnPaletteChanges(x)
#endif


#ifdef USE_ALIAS
    /* ddalias.c */
    extern HRESULT CreateHeapAliases( HANDLE hvxd, LPDDRAWI_DIRECTDRAW_GBL pdrv );
    extern BOOL    ReleaseHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern HRESULT MapHeapAliasesToVidMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern HRESULT MapHeapAliasesToDummyMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv,
                                     LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
                                     FLATPTR                   fpVidMem );
#endif /* USE_ALIAS */

/* dllmain.c */
extern BOOL RemoveProcessFromDLL( DWORD pid );

/* misc.c */
extern BOOL CanBeFlippable( LPDDRAWI_DDRAWSURFACE_LCL thisg, LPDDRAWI_DDRAWSURFACE_LCL this_attach);
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedFlip( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedSurfaceLeft( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedMipMap( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindParentMipMap( LPDDRAWI_DDRAWSURFACE_INT thisg );
#ifdef WIN95
    extern HANDLE GetDXVxdHandle( void );
#endif /* WIN95 */

/* ddcallbk.c */
extern void InitCallbackTables( void );
extern BOOL CallbackTablesInitialized( void );

/* ddvp.c */
extern void ProcessVideoPortCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern HRESULT InternalStopVideo( LPDDRAWI_DDVIDEOPORT_INT this_int );
extern LPDDRAWI_DDVIDEOPORT_LCL GetVideoPortFromSurface( LPDDRAWI_DDRAWSURFACE_INT surf_int );
extern DWORD IsValidAutoFlipSurface( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
#define IVAS_NOAUTOFLIPPING             0
#define IVAS_SOFTWAREAUTOFLIPPING       1
#define IVAS_HARDWAREAUTOFLIPPING       2
extern VOID RequireSoftwareAutoflip( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
extern VOID SetRingZeroSurfaceData( LPDDRAWI_DDRAWSURFACE_LCL lpSurface_lcl );
extern DWORD FlipVideoPortSurface( LPDDRAWI_DDRAWSURFACE_INT , DWORD );
extern VOID OverrideOverlay( LPDDRAWI_DDRAWSURFACE_INT lpSurf_int, LPDWORD lpdwFlags );
extern BOOL MustSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurf_int );
extern VOID RequireSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
extern VOID DecrementRefCounts( LPDDRAWI_DDRAWSURFACE_INT surf_int );

/* ddcolor.c */
extern VOID ReleaseColorControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );

/* ddgamma.c */
extern VOID ReleaseGammaControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );
extern BOOL SetGamma( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern VOID RestoreGamma( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern VOID InitGamma( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPSTR szDrvName );

/* ddkernel.c */
extern HRESULT InternalReleaseKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, BOOL bLosingSurface );
extern HRESULT InternalCreateKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, PULONG_PTR lpHandle );
extern HRESULT UpdateKernelSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );
extern HRESULT UpdateKernelVideoPort( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFlags );
extern HRESULT GetKernelFieldNum( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, LPDWORD lpdwFieldNum );
extern HRESULT SetKernelFieldNum( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFieldNum );
extern HRESULT SetKernelSkipPattern( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwStartField, DWORD dwPatternSize, DWORD dwPattern );
extern HRESULT InitKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern HRESULT GetKernelSurfaceState( LPDDRAWI_DDRAWSURFACE_LCL lpSurf, LPDWORD lpdwStateFlags );
extern HRESULT ReleaseKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern BOOL CanSoftwareAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort );
extern BOOL IsKernelInterfaceSupported( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern HRESULT SetKernelDOSBoxEvent( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern VOID EnableAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, BOOL bEnable );
extern BOOL IsWindows98( VOID );

/* ddmc.c */
extern BOOL IsMotionCompSupported( LPDDRAWI_DIRECTDRAW_LCL this_lcl );
extern void ProcessMotionCompCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* private.c */
extern void FreeAllPrivateData(LPPRIVATEDATANODE * ppListHead);

/* factory.c */
extern HRESULT InternalCreateDDFactory2(void **, IUnknown * pUnkOuter);

// ddrestor.c
extern HRESULT AllocSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void FreeSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern HRESULT BackupSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern HRESULT RestoreSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void BackupAllSurfaces(LPDDRAWI_DIRECTDRAW_GBL this_gbl);
extern void MungeAutoflipCaps(LPDDRAWI_DIRECTDRAW_GBL pdrv);

/* ddrefrsh.c */
extern HRESULT DDGetMonitorInfo( LPDDRAWI_DIRECTDRAW_INT lpDD_int);
extern HRESULT ExpandModeTable( LPDDRAWI_DIRECTDRAW_GBL pddd );
extern BOOL CanMonitorHandleRefreshRate( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight, int wRefresh );

/* drvinfo.c */
extern BOOL Voodoo1GoodToGo( GUID * pGuid );


/* A handy one from ddhel.c */
/* DDRAW16 doesn't need this. */
#ifdef WIN32
    SCODE InitDIB(HDC hdc, LPBITMAPINFO lpbmi);
#endif
void ResetBITMAPINFO(LPDDRAWI_DIRECTDRAW_GBL thisg);
BOOL doPixelFormatsMatch(LPDDPIXELFORMAT lpddpf1,
                                LPDDPIXELFORMAT lpddpf2);
HRESULT ConvertToPhysColor(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl, LPDDARGB pSource, LPDWORD pdwPhysColor);
HRESULT ConvertFromPhysColor(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl, LPDWORD pdwPhysColor, LPDDARGB pDest);
extern DWORD GetSurfPFIndex(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl);
extern DWORD GetDxtBlkSize(DWORD dwFourCC);

/*
 * HEL's public memory allocator
 */
extern void HELFreeSurfaceSysMem(LPDDRAWI_DDRAWSURFACE_LCL lpsurf_lcl);
extern LPVOID HELAllocateSurfaceSysMem(LPDDRAWI_DDRAWSURFACE_LCL lpsurf_lcl, DWORD nWidth,
                                DWORD nHeight, LPDWORD lpdwSurfaceSize, LPLONG lpSurfPitch );

#ifndef NO_DDHELP
    /* w95hack.c */
    extern DWORD HackGetCurrentProcessId( void );
    extern BOOL DDAPI DDNotify( LPDDHELPDATA phd );
    extern void DDAPI DDNotifyModeSet( LPDDRAWI_DIRECTDRAW_GBL );
    extern void DDAPI DDNotifyDOSBox( LPDDRAWI_DIRECTDRAW_GBL );
#endif //NO_DDHELP

#ifdef POSTPONED
/* Delegating IUnknown functions */
extern HRESULT EXTERN_DDAPI DD_DelegatingQueryInterface(LPDIRECTDRAW, REFIID, LPVOID FAR *);
extern DWORD EXTERN_DDAPI DD_DelegatingAddRef( LPDIRECTDRAW lpDD );
extern DWORD EXTERN_DDAPI DD_DelegatingRelease( LPDIRECTDRAW lpDD );
#endif

/* DirectDrawFactory2 functions */
extern HRESULT EXTERN_DDAPI DDFac2_QueryInterface(LPDIRECTDRAWFACTORY2, REFIID, LPVOID FAR *);
extern DWORD EXTERN_DDAPI DDFac2_AddRef( LPDIRECTDRAWFACTORY2 lpDDFac );
extern ULONG EXTERN_DDAPI DDFac2_Release( LPDIRECTDRAWFACTORY2 lpDDFac );
extern HRESULT EXTERN_DDAPI DDFac2_CreateDirectDraw(LPDIRECTDRAWFACTORY2, GUID FAR *, HWND, DWORD dwCoopLevelFlags, DWORD, IUnknown *, struct IDirectDraw4 ** );
#ifdef IS_32
#ifdef SM_CMONITORS
    extern HRESULT EXTERN_DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 , LPDDENUMCALLBACKEX , LPVOID  , DWORD );
#else
    /*
     * This def'n is a hack to keep us building under NT build which doesn't have the
     * multimon headers in it yet
     */
    extern HRESULT EXTERN_DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 , LPDDENUMCALLBACK , LPVOID  , DWORD );
#endif
#endif

/* DIRECTDRAW functions */
extern HRESULT EXTERN_DDAPI DD_UnInitedQueryInterface( LPDIRECTDRAW lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern HRESULT EXTERN_DDAPI DD_QueryInterface( LPDIRECTDRAW lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_AddRef( LPDIRECTDRAW lpDD );
extern DWORD   EXTERN_DDAPI DD_Release( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_Compact( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_CreateClipper( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreatePalette( LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable, LPDIRECTDRAWPALETTE FAR *lplpDDPalette, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreateSurface( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreateSurface4( LPDIRECTDRAW lpDD, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_DuplicateSurface( LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSurface, LPDIRECTDRAWSURFACE FAR *lplpDupDDSurface );
extern HRESULT EXTERN_DDAPI DD_EnumDisplayModes( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK lpEnumModesCallback );
extern HRESULT EXTERN_DDAPI DD_EnumDisplayModes4( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK2 lpEnumModesCallback );
extern HRESULT EXTERN_DDAPI DD_EnumSurfaces( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumCallback );
extern HRESULT EXTERN_DDAPI DD_EnumSurfaces4( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK2 lpEnumCallback );
extern HRESULT EXTERN_DDAPI DD_FlipToGDISurface( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_GetCaps( LPDIRECTDRAW lpDD, LPDDCAPS lpDDDriverCaps, LPDDCAPS lpHELCaps );
extern HRESULT EXTERN_DDAPI DD_GetColorKey( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_GetDisplayMode( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpSurfaceDesc );
extern HRESULT EXTERN_DDAPI DD_GetFourCCCodes(LPDIRECTDRAW,DWORD FAR *,DWORD FAR *);
extern HRESULT EXTERN_DDAPI DD_GetGDISurface( LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE FAR * );
extern HRESULT EXTERN_DDAPI DD_GetScanLine( LPDIRECTDRAW lpDD, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_GetVerticalBlankStatus( LPDIRECTDRAW lpDD, BOOL FAR * );
extern HRESULT EXTERN_DDAPI DD_Initialize(LPDIRECTDRAW, GUID FAR *);
extern HRESULT EXTERN_DDAPI DD_SetColorKey( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_SetCooperativeLevel(LPDIRECTDRAW,HWND,DWORD);
extern HRESULT EXTERN_DDAPI DD_SetDisplayMode(LPDIRECTDRAW,DWORD,DWORD,DWORD);
extern HRESULT EXTERN_DDAPI DD_SetDisplayMode2(LPDIRECTDRAW,DWORD,DWORD,DWORD,DWORD,DWORD);
extern HRESULT EXTERN_DDAPI DD_RestoreDisplayMode(LPDIRECTDRAW);
extern HRESULT EXTERN_DDAPI DD_GetMonitorFrequency( LPDIRECTDRAW lpDD, LPDWORD lpdwFrequency);
extern HRESULT EXTERN_DDAPI DD_WaitForVerticalBlank( LPDIRECTDRAW lpDD, DWORD dwFlags, HANDLE hEvent );
extern HRESULT EXTERN_DDAPI DD_GetAvailableVidMem( LPDIRECTDRAW lpDD, LPDDSCAPS lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree );
extern HRESULT EXTERN_DDAPI DD_GetAvailableVidMem4( LPDIRECTDRAW lpDD, LPDDSCAPS2 lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree );
extern HRESULT EXTERN_DDAPI DD_GetSurfaceFromDC( LPDIRECTDRAW lpDD, HDC, LPDIRECTDRAWSURFACE *);
extern HRESULT EXTERN_DDAPI DD_RestoreAllSurfaces( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_GetDeviceIdentifier( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER, DWORD);
extern HRESULT EXTERN_DDAPI DD_GetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2, DWORD);
extern HRESULT EXTERN_DDAPI DD_StartModeTest( LPDIRECTDRAW7 lpDD, LPSIZE lpModesToTest, DWORD dwNumEntries, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_EvaluateMode( LPDIRECTDRAW7 lpDD, DWORD dwFlags, DWORD *pSecondsUntilTimeout);
#ifdef IS_32
    //streaming stuff confuses ddraw16
    #ifndef __cplusplus
        extern HRESULT EXTERN_DDAPI DD_CreateSurfaceFromStream( LPDIRECTDRAW4 lpDD, IStream *, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE4 *, IUnknown *);
        extern HRESULT EXTERN_DDAPI DD_CreateSurfaceFromFile( LPDIRECTDRAW4 lpDD, BSTR, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE4 *, IUnknown *);
    #endif
#endif
extern HRESULT EXTERN_DDAPI DD_CreateOptSurface( LPDIRECTDRAW, LPDDOPTSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter);
extern HRESULT EXTERN_DDAPI DD_ListOptSurfaceGUIDS(LPDIRECTDRAW, DWORD *, LPGUID);
extern HRESULT EXTERN_DDAPI DD_CanOptimizeSurface(LPDIRECTDRAW, LPDDSURFACEDESC2, LPDDOPTSURFACEDESC, BOOL FAR *);
extern HRESULT EXTERN_DDAPI DD_TestCooperativeLevel(LPDIRECTDRAW);

/* DIRECTDRAWPALETTE functions */
extern HRESULT EXTERN_DDAPI DD_Palette_QueryInterface( LPDIRECTDRAWPALETTE lpDDPalette, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_Palette_AddRef( LPDIRECTDRAWPALETTE lpDDPalette );
extern DWORD   EXTERN_DDAPI DD_Palette_Release( LPDIRECTDRAWPALETTE lpDDPalette );
extern HRESULT EXTERN_DDAPI DD_Palette_GetCaps( LPDIRECTDRAWPALETTE lpDDPalette, LPDWORD lpdwFlags );
extern HRESULT EXTERN_DDAPI DD_Palette_Initialize( LPDIRECTDRAWPALETTE, LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable );
extern HRESULT EXTERN_DDAPI DD_Palette_SetEntries( LPDIRECTDRAWPALETTE lpDDPalette, DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
extern HRESULT EXTERN_DDAPI DD_Palette_GetEntries( LPDIRECTDRAWPALETTE lpDDPalette, DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
extern HRESULT EXTERN_DDAPI DD_Palette_SetPrivateData( LPDIRECTDRAWPALETTE, REFIID, LPVOID, DWORD, DWORD);
extern HRESULT EXTERN_DDAPI DD_Palette_GetPrivateData( LPDIRECTDRAWPALETTE, REFIID, LPVOID, LPDWORD);
extern HRESULT EXTERN_DDAPI DD_Palette_FreePrivateData( LPDIRECTDRAWPALETTE, REFIID );
extern HRESULT EXTERN_DDAPI DD_Palette_GetUniquenessValue( LPDIRECTDRAWPALETTE, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Palette_ChangeUniquenessValue( LPDIRECTDRAWPALETTE );
extern HRESULT EXTERN_DDAPI DD_Palette_IsEqual( LPDIRECTDRAWPALETTE, LPDIRECTDRAWPALETTE );


/* DIRECTDRAWCLIPPER functions */
extern HRESULT EXTERN_DDAPI DD_UnInitedClipperQueryInterface( LPDIRECTDRAWCLIPPER lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern HRESULT EXTERN_DDAPI DD_Clipper_QueryInterface( LPVOID lpDDClipper, REFIID riid, LPVOID FAR * ppvObj );
extern ULONG   EXTERN_DDAPI DD_Clipper_AddRef( LPVOID lpDDClipper );
extern ULONG   EXTERN_DDAPI DD_Clipper_Release( LPVOID lpDDClipper );
extern HRESULT EXTERN_DDAPI DD_Clipper_GetClipList( LPDIRECTDRAWCLIPPER, LPRECT, LPRGNDATA, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Clipper_GetHWnd(LPDIRECTDRAWCLIPPER,HWND FAR *);
extern HRESULT EXTERN_DDAPI DD_Clipper_Initialize( LPDIRECTDRAWCLIPPER, LPDIRECTDRAW lpDD, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_Clipper_IsClipListChanged(LPDIRECTDRAWCLIPPER,BOOL FAR *);
extern HRESULT EXTERN_DDAPI DD_Clipper_SetClipList(LPDIRECTDRAWCLIPPER,LPRGNDATA, DWORD);
extern HRESULT EXTERN_DDAPI DD_Clipper_SetHWnd(LPDIRECTDRAWCLIPPER, DWORD, HWND );
extern HRESULT EXTERN_DDAPI DD_Clipper_SetNotificationCallback(LPDIRECTDRAWCLIPPER, DWORD,LPCLIPPERCALLBACK, LPVOID);

/* Private DIRECTDRAWCLIPPER functions */
extern HRESULT InternalGetClipList( LPDIRECTDRAWCLIPPER lpDDClipper, LPRECT lpRect, LPRGNDATA lpClipList, LPDWORD lpdwSize, LPDDRAWI_DIRECTDRAW_GBL pdrv);

/* DIRECTDRAWSURFACE functions */
extern HRESULT EXTERN_DDAPI DD_Surface_QueryInterface( LPVOID lpDDSurface, REFIID riid, LPVOID FAR * ppvObj );
extern ULONG   EXTERN_DDAPI DD_Surface_AddRef( LPVOID lpDDSurface );
extern ULONG   EXTERN_DDAPI DD_Surface_Release( LPVOID lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_AddAttachedSurface(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_AddOverlayDirtyRect(LPDIRECTDRAWSURFACE, LPRECT);
extern HRESULT EXTERN_DDAPI DD_Surface_AlphaBlt(LPDIRECTDRAWSURFACE, LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDALPHABLTFX);
extern HRESULT EXTERN_DDAPI DD_Surface_Blt(LPDIRECTDRAWSURFACE,LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
extern HRESULT EXTERN_DDAPI DD_Surface_BltFast(LPDIRECTDRAWSURFACE,DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_BltBatch( LPDIRECTDRAWSURFACE, LPDDBLTBATCH, DWORD, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_ChangeUniquenessValue( LPDIRECTDRAWSURFACE );
extern HRESULT EXTERN_DDAPI DD_Surface_DeleteAttachedSurfaces(LPDIRECTDRAWSURFACE, DWORD,LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_EnumAttachedSurfaces(LPDIRECTDRAWSURFACE,LPVOID, LPDDENUMSURFACESCALLBACK );
extern HRESULT EXTERN_DDAPI DD_Surface_EnumOverlayZOrders(LPDIRECTDRAWSURFACE,DWORD,LPVOID,LPDDENUMSURFACESCALLBACK);
extern HRESULT EXTERN_DDAPI DD_Surface_Flip(LPDIRECTDRAWSURFACE,LPDIRECTDRAWSURFACE, DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_FreePrivateData(LPDIRECTDRAWSURFACE, REFIID);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface(LPDIRECTDRAWSURFACE,LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface4(LPDIRECTDRAWSURFACE4,LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface7(LPDIRECTDRAWSURFACE7,LPDDSCAPS2, LPDIRECTDRAWSURFACE7 FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetBltStatus(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetCaps( LPDIRECTDRAWSURFACE lpDDSurface, LPDDSCAPS lpDDSCaps );
extern HRESULT EXTERN_DDAPI DD_Surface_GetCaps4( LPDIRECTDRAWSURFACE lpDDSurface, LPDDSCAPS2 lpDDSCaps );
extern HRESULT EXTERN_DDAPI DD_Surface_GetClipper( LPDIRECTDRAWSURFACE, LPDIRECTDRAWCLIPPER FAR * );
extern HRESULT EXTERN_DDAPI DD_Surface_GetColorKey( LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_Surface_GetDC( LPDIRECTDRAWSURFACE, HDC FAR * );
extern HRESULT EXTERN_DDAPI DD_Surface_GetDDInterface(LPDIRECTDRAWSURFACE lpDDSurface, LPVOID FAR *lplpDD );
extern HRESULT EXTERN_DDAPI DD_Surface_GetOverlayPosition( LPDIRECTDRAWSURFACE, LPLONG, LPLONG );
extern HRESULT EXTERN_DDAPI DD_Surface_GetPalette(LPDIRECTDRAWSURFACE,LPDIRECTDRAWPALETTE FAR*);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPixelFormat(LPDIRECTDRAWSURFACE, LPDDPIXELFORMAT);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPrivateData(LPDIRECTDRAWSURFACE, REFIID, LPVOID, LPDWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC);
extern HRESULT EXTERN_DDAPI DD_Surface_GetSurfaceDesc4(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC2);
extern HRESULT EXTERN_DDAPI DD_Surface_GetFlipStatus(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetUniquenessValue( LPDIRECTDRAWSURFACE, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_Initialize( LPDIRECTDRAWSURFACE, LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc);
extern HRESULT EXTERN_DDAPI DD_Surface_IsLost( LPDIRECTDRAWSURFACE lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_Lock(LPDIRECTDRAWSURFACE,LPRECT,LPDDSURFACEDESC lpDDSurfaceDesc, DWORD, HANDLE hEvent );
extern HRESULT EXTERN_DDAPI DD_Surface_PageLock(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_PageUnlock(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_ReleaseDC(LPDIRECTDRAWSURFACE,HDC );
#ifdef POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_Resize(LPDIRECTDRAWSURFACE,DWORD,DWORD,DWORD);
#endif //POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_Restore( LPDIRECTDRAWSURFACE lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_SetBltOrder(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_SetClipper( LPDIRECTDRAWSURFACE, LPDIRECTDRAWCLIPPER );
extern HRESULT EXTERN_DDAPI DD_Surface_SetColorKey( LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_Surface_SetOverlayPosition( LPDIRECTDRAWSURFACE, LONG, LONG );
extern HRESULT EXTERN_DDAPI DD_Surface_SetPalette(LPDIRECTDRAWSURFACE,LPDIRECTDRAWPALETTE);
extern HRESULT EXTERN_DDAPI DD_Surface_SetPrivateData(LPDIRECTDRAWSURFACE, REFIID, LPVOID, DWORD, DWORD);
#ifdef POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_SetSpriteDisplayList(LPDIRECTDRAWSURFACE,LPDDSPRITE *,DWORD,DWORD,LPDIRECTDRAWSURFACE,DWORD);
#endif //POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_SetSurfaceDesc( LPDIRECTDRAWSURFACE3, LPDDSURFACEDESC, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_SetSurfaceDesc4( LPDIRECTDRAWSURFACE3, LPDDSURFACEDESC2, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_Unlock(LPDIRECTDRAWSURFACE,LPVOID);
extern HRESULT EXTERN_DDAPI DD_Surface_Unlock4(LPDIRECTDRAWSURFACE,LPRECT);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlay(LPDIRECTDRAWSURFACE,LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlayDisplay(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlayZOrder(LPDIRECTDRAWSURFACE,DWORD,LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_SetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwPriority);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwPriority);
extern HRESULT EXTERN_DDAPI DD_Surface_SetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwLOD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwLOD);

/* DrawDrawVideoPortContainer functions */
extern HRESULT EXTERN_DDAPI DDVPC_QueryInterface(LPDDVIDEOPORTCONTAINER lpDVP, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DDVPC_AddRef(LPDDVIDEOPORTCONTAINER lpDVP );
extern DWORD   EXTERN_DDAPI DDVPC_Release( LPDDVIDEOPORTCONTAINER lpDD );
extern HRESULT EXTERN_DDAPI DDVPC_CreateVideoPort(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwFlags, LPDDVIDEOPORTDESC lpDesc, LPDIRECTDRAWVIDEOPORT FAR *lplpVideoPort, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DDVPC_EnumVideoPorts(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwReserved, LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext, LPDDENUMVIDEOCALLBACK lpCallback );
extern HRESULT EXTERN_DDAPI DDVPC_GetVideoPortConnectInfo(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwVideoPortID, LPDWORD lpdwNumGUIDs, LPDDVIDEOPORTCONNECT lpConnect );
extern HRESULT EXTERN_DDAPI DDVPC_QueryVideoPortStatus(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwVideoPortID, LPDDVIDEOPORTSTATUS lpStatus );

/* DirectDrawVideoPort functions */
extern HRESULT EXTERN_DDAPI DD_VP_QueryInterface(LPDIRECTDRAWVIDEOPORT lpDVP, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_VP_AddRef(LPDIRECTDRAWVIDEOPORT lpDVP );
extern DWORD   EXTERN_DDAPI DD_VP_Release(LPDIRECTDRAWVIDEOPORT lpDVP );
extern HRESULT EXTERN_DDAPI DD_VP_SetTargetSurface(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_Flip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD );
extern HRESULT EXTERN_DDAPI DD_VP_GetBandwidth(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpf, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags, LPDDVIDEOPORTBANDWIDTH lpBandwidth );
extern HRESULT EXTERN_DDAPI DD_VP_GetInputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwNum, LPDDPIXELFORMAT lpf, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_GetOutputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpf, LPDWORD lp1, LPDDPIXELFORMAT lp2, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_GetCurrentAutoFlip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE FAR* lpSurf, LPDIRECTDRAWSURFACE FAR* lpVBI, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetLastAutoFlip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE FAR* lpSurf, LPDIRECTDRAWSURFACE FAR* lpVBI, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetField(LPDIRECTDRAWVIDEOPORT lpDVP, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetLine(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwLine );
extern HRESULT EXTERN_DDAPI DD_VP_StartVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo );
extern HRESULT EXTERN_DDAPI DD_VP_StopVideo(LPDIRECTDRAWVIDEOPORT lpDVP );
extern HRESULT EXTERN_DDAPI DD_VP_UpdateVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo );
extern HRESULT EXTERN_DDAPI DD_VP_WaitForSync(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFlags, DWORD dwLine, DWORD dwTimeOut );
extern HRESULT EXTERN_DDAPI DD_VP_SetFieldNumber(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFieldNum );
extern HRESULT EXTERN_DDAPI DD_VP_GetFieldNumber(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwFieldNum );
extern HRESULT EXTERN_DDAPI DD_VP_SetSkipFieldPattern(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwStartField, DWORD dwPattSize, DWORD dwPatt );
extern HRESULT EXTERN_DDAPI DD_VP_GetSignalStatus(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStatus );
extern HRESULT EXTERN_DDAPI DD_VP_GetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_VP_SetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_VP_GetStateInfo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStateFlags );

/* DrawDrawColorControl functions */
extern HRESULT EXTERN_DDAPI DD_Color_GetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_Color_SetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor );

/* DrawDrawGammaControl functions */
extern HRESULT EXTERN_DDAPI DD_Gamma_GetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC, DWORD dwFlags, LPVOID lpGammaTable );
extern HRESULT EXTERN_DDAPI DD_Gamma_SetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC, DWORD dwFlags, LPVOID lpGammaTable );

/* DirectDrawKernel functions */
extern HRESULT EXTERN_DDAPI DD_Kernel_GetCaps(LPDIRECTDRAWKERNEL lpDDK, LPDDKERNELCAPS lpCaps );
extern HRESULT EXTERN_DDAPI DD_Kernel_GetKernelHandle(LPDIRECTDRAWKERNEL lpDDK, PULONG_PTR lpHandle );
extern HRESULT EXTERN_DDAPI DD_Kernel_ReleaseKernelHandle(LPDIRECTDRAWKERNEL lpDDK );

/* DirectDrawSurfaceKernel functions */
extern HRESULT EXTERN_DDAPI DD_SurfaceKernel_GetKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK, PULONG_PTR lpHandle );
extern HRESULT EXTERN_DDAPI DD_SurfaceKernel_ReleaseKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK );

/* DIrectDrawSurface and palette IPersist and IPersistStream functions */
#ifdef IS_32
    extern HRESULT EXTERN_DDAPI DD_PStream_GetSizeMax(IPersistStream * lpSurfOrPalette, ULARGE_INTEGER * pMax);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_Save(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm, BOOL bClearDirty);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_IsDirty(LPDIRECTDRAWSURFACE lpDDS);
    extern HRESULT EXTERN_DDAPI DD_Surface_Persist_GetClassID(LPDIRECTDRAWSURFACE lpDDS, CLSID * pClassID);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_Load(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_Save(LPDIRECTDRAWPALETTE lpDDS, IStream * pStrm, BOOL bClearDirty);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_IsDirty(LPDIRECTDRAWPALETTE lpDDS);
    extern HRESULT EXTERN_DDAPI DD_Palette_Persist_GetClassID(LPDIRECTDRAWPALETTE lpDDS, CLSID * pClassID);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_Load(LPDIRECTDRAWPALETTE lpDDS, IStream * pStrm);
#endif

/* DirectDrawOptSurface functions */
extern HRESULT EXTERN_DDAPI DD_OptSurface_GetOptSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDOPTSURFACEDESC);
extern HRESULT EXTERN_DDAPI DD_OptSurface_LoadUnoptimizedSurf(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_OptSurface_CopyOptimizedSurf(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_OptSurface_Unoptimize(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *);

/* DrawDrawMotionCompContainer functions */
extern HRESULT EXTERN_DDAPI DDMCC_CreateMotionComp(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPVOID lpData, DWORD dwDataSize, LPDIRECTDRAWVIDEOACCELERATOR FAR *lplpMotionComp, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DDMCC_GetUncompressedFormats(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDWORD lpNumFormats, LPDDPIXELFORMAT lpFormats );
extern HRESULT EXTERN_DDAPI DDMCC_GetMotionCompGUIDs(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPDWORD lpNumGuids, LPGUID lpGuids );
extern HRESULT EXTERN_DDAPI DDMCC_GetCompBuffInfo(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPDWORD lpNumBuffInfo, LPDDVACompBufferInfo lpCompBuffInfo );
extern HRESULT EXTERN_DDAPI DDMCC_GetInternalMoCompInfo(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPDDVAInternalMemInfo lpMemInfo );

/* DrawDrawMotionComp functions */
extern HRESULT EXTERN_DDAPI DD_MC_QueryInterface(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_MC_AddRef(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC);
extern DWORD   EXTERN_DDAPI DD_MC_Release(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC);
extern HRESULT EXTERN_DDAPI DD_MC_BeginFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDDVABeginFrameInfo lpInfo);
extern HRESULT EXTERN_DDAPI DD_MC_EndFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDDVAEndFrameInfo lpInfo);
extern HRESULT EXTERN_DDAPI DD_MC_QueryRenderStatus(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDIRECTDRAWSURFACE7 lpSurface, DWORD dwFlags);
extern HRESULT EXTERN_DDAPI DD_MC_RenderMacroBlocks(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, DWORD dwFunction, LPVOID lpInput, DWORD dwInputSize, LPVOID lpOutput, DWORD dwOutSize, DWORD dwNumBuffers, LPDDVABUFFERINFO lpBuffInfo);

//#endif //WIN95

/*
 * HAL fns
 */

//#ifdef WIN95
/*
 * thunk helper fns
 */
extern DWORD DDAPI _DDHAL_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData );
extern DWORD DDAPI DDThunk16_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData );

extern DWORD DDAPI _DDHAL_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );
extern DWORD DDAPI DDThunk16_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );

extern DWORD DDAPI _DDHAL_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );
extern DWORD DDAPI DDThunk16_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );

extern DWORD DDAPI _DDHAL_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData );
extern DWORD DDAPI DDThunk16_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData );

extern DWORD DDAPI _DDHAL_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData );
extern DWORD DDAPI DDThunk16_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData );

extern DWORD DDAPI _DDHAL_SetMode( LPDDHAL_SETMODEDATA lpSetModeData );
extern DWORD DDAPI DDThunk16_SetMode( LPDDHAL_SETMODEDATA lpSetModeData );

extern DWORD DDAPI _DDHAL_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData );
extern DWORD DDAPI DDThunk16_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData );

extern DWORD DDAPI _DDHAL_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData );
extern DWORD DDAPI DDThunk16_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData );

extern DWORD DDAPI _DDHAL_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData );
extern DWORD DDAPI DDThunk16_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData );

extern DWORD DDAPI _DDHAL_GetAvailDriverMemory ( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData );
extern DWORD DDAPI DDThunk16_GetAvailDriverMemory ( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData );

extern DWORD DDAPI _DDHAL_UpdateNonLocalHeap ( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData );
extern DWORD DDAPI DDThunk16_UpdateNonLocalHeap ( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData );

/*
 * Palette Object HAL fns
 */
extern DWORD DDAPI _DDHAL_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA );
extern DWORD DDAPI DDThunk16_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA );

extern DWORD DDAPI _DDHAL_SetEntries( LPDDHAL_SETENTRIESDATA );
extern DWORD DDAPI DDThunk16_SetEntries( LPDDHAL_SETENTRIESDATA );

/*
 * Surface Object HAL fns
 */
extern DWORD DDAPI _DDHAL_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );
extern DWORD DDAPI DDThunk16_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );

extern DWORD DDAPI _DDHAL_Flip( LPDDHAL_FLIPDATA lpFlipData );
extern DWORD DDAPI DDThunk16_Flip( LPDDHAL_FLIPDATA lpFlipData );

extern DWORD DDAPI _DDHAL_Blt( LPDDHAL_BLTDATA lpBltData );
extern DWORD DDAPI DDThunk16_Blt( LPDDHAL_BLTDATA lpBltData );

extern DWORD DDAPI _DDHAL_Lock( LPDDHAL_LOCKDATA lpLockData );
extern DWORD DDAPI DDThunk16_Lock( LPDDHAL_LOCKDATA lpLockData );

extern DWORD DDAPI _DDHAL_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData );
extern DWORD DDAPI DDThunk16_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData );

extern DWORD DDAPI _DDHAL_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData );
extern DWORD DDAPI DDThunk16_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData );

extern DWORD DDAPI _DDHAL_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData );
extern DWORD DDAPI DDThunk16_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData );

extern DWORD DDAPI _DDHAL_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData );
extern DWORD DDAPI DDThunk16_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData );

extern DWORD DDAPI _DDHAL_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData );
extern DWORD DDAPI DDThunk16_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData );

extern DWORD DDAPI _DDHAL_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData );
extern DWORD DDAPI DDThunk16_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData );

extern DWORD DDAPI _DDHAL_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData );
extern DWORD DDAPI DDThunk16_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData );

extern DWORD DDAPI _DDHAL_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData );
extern DWORD DDAPI DDThunk16_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData );

extern DWORD DDAPI _DDHAL_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData );
extern DWORD DDAPI DDThunk16_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData );

/*
 * Execute Buffer Pseudo Object HAL fns
 *
 * NOTE: No DDThunk16 equivalents as these are just dummy place holders to keep
 * DOHALCALL happy.
 */
extern DWORD DDAPI _DDHAL_CanCreateExecuteBuffer( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );
extern DWORD DDAPI _DDHAL_CreateExecuteBuffer( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );
extern DWORD DDAPI _DDHAL_DestroyExecuteBuffer( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );
extern DWORD DDAPI _DDHAL_LockExecuteBuffer( LPDDHAL_LOCKDATA lpLockData );
extern DWORD DDAPI _DDHAL_UnlockExecuteBuffer( LPDDHAL_UNLOCKDATA lpUnlockData );

/*
 * Video Port Pseudo Object HAL fns
 *
 * NOTE: No DDThunk16 equivalents as these are just dummy place holders to keep
 * DOHALCALL happy.
 */
extern DWORD DDAPI _DDHAL_GetVideoPortConnectInfo( LPDDHAL_GETVPORTCONNECTDATA lpGetTypeData );
extern DWORD DDAPI _DDHAL_CanCreateVideoPort( LPDDHAL_CANCREATEVPORTDATA lpCanCreateData );
extern DWORD DDAPI _DDHAL_CreateVideoPort( LPDDHAL_CREATEVPORTDATA lpCreateData );
extern DWORD DDAPI _DDHAL_DestroyVideoPort( LPDDHAL_DESTROYVPORTDATA lpDestroyData );
extern DWORD DDAPI _DDHAL_GetVideoPortInputFormats( LPDDHAL_GETVPORTINPUTFORMATDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_GetVideoPortOutputFormats( LPDDHAL_GETVPORTOUTPUTFORMATDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_GetVideoPortBandwidthInfo( LPDDHAL_GETVPORTBANDWIDTHDATA lpGetBandwidthData );
extern DWORD DDAPI _DDHAL_UpdateVideoPort( LPDDHAL_UPDATEVPORTDATA lpUpdateData );
extern DWORD DDAPI _DDHAL_GetVideoPortField( LPDDHAL_GETVPORTFIELDDATA lpGetFieldData );
extern DWORD DDAPI _DDHAL_GetVideoPortLine( LPDDHAL_GETVPORTLINEDATA lpGetLineData );
extern DWORD DDAPI _DDHAL_WaitForVideoPortSync( LPDDHAL_WAITFORVPORTSYNCDATA lpWaitSyncData );
extern DWORD DDAPI _DDHAL_FlipVideoPort( LPDDHAL_FLIPVPORTDATA lpFlipData );
extern DWORD DDAPI _DDHAL_GetVideoPortFlipStatus( LPDDHAL_GETVPORTFLIPSTATUSDATA lpFlipData );
extern DWORD DDAPI _DDHAL_GetVideoSignalStatus( LPDDHAL_GETVPORTSIGNALDATA lpData );
extern DWORD DDAPI _DDHAL_VideoColorControl( LPDDHAL_VPORTCOLORDATA lpData );

/*
 * Color Control Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData );
extern DWORD DDAPI DDThunk16_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData );

/*
 * Kernel Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_SyncSurfaceData( LPDDHAL_SYNCSURFACEDATA lpSyncData );
extern DWORD DDAPI _DDHAL_SyncVideoPortData( LPDDHAL_SYNCVIDEOPORTDATA lpSyncData );

/*
 * MotionComp Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_GetMoCompGuids( LPDDHAL_GETMOCOMPGUIDSDATA lpGetGuidData );
extern DWORD DDAPI _DDHAL_GetMoCompFormats( LPDDHAL_GETMOCOMPFORMATSDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_CreateMoComp( LPDDHAL_CREATEMOCOMPDATA lpCreateData );
extern DWORD DDAPI _DDHAL_GetMoCompBuffInfo( LPDDHAL_GETMOCOMPCOMPBUFFDATA lpBuffData );
extern DWORD DDAPI _DDHAL_GetInternalMoCompInfo( LPDDHAL_GETINTERNALMOCOMPDATA lpInternalData );
extern DWORD DDAPI _DDHAL_DestroyMoComp( LPDDHAL_DESTROYMOCOMPDATA lpDestroyData );
extern DWORD DDAPI _DDHAL_BeginMoCompFrame( LPDDHAL_BEGINMOCOMPFRAMEDATA lpFrameData );
extern DWORD DDAPI _DDHAL_EndMoCompFrame( LPDDHAL_ENDMOCOMPFRAMEDATA lpFrameData );
extern DWORD DDAPI _DDHAL_RenderMoComp( LPDDHAL_RENDERMOCOMPDATA lpRenderData );
extern DWORD DDAPI _DDHAL_QueryMoCompStatus( LPDDHAL_QUERYMOCOMPSTATUSDATA lpStatusData );
#ifdef POSTPONED
extern DWORD DDAPI _DDHAL_CanOptimizeSurface( LPDDHAL_CANOPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_OptimizeSurface( LPDDHAL_OPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_UnOptimizeSurface( LPDDHAL_UNOPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_CopyOptSurface( LPDDHAL_COPYOPTSURFACEDATA);
#endif
//#endif

#ifdef POSTPONED
    #ifdef IS_32
    /*
     * DirectDrawFactory2 implementation
     */
    typedef struct _DDFACTORY2
    {
        IDirectDrawFactory2Vtbl *lpVtbl;
        DWORD                   dwRefCnt;
        /* internal data */
    } DDFACTORY2, FAR * LPDDFACTORY2;
    #endif
#endif //POSTPONED

/*
 * Macros for checking interface versions
 */

#define LOWERTHANDDRAW7(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks || lpDD->lpVtbl == &dd4Callbacks )

#define LOWERTHANDDRAW4(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks)

#define LOWERTHANDDRAW3(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks)

#define LOWERTHANSURFACE7(lpDDS) \
    (lpDDS->lpVtbl == &ddSurfaceCallbacks || lpDDS->lpVtbl == &ddSurface2Callbacks || \
     lpDDS->lpVtbl == &ddSurface3Callbacks || lpDDS->lpVtbl == &ddSurface4Callbacks )

#define LOWERTHANSURFACE4(lpDDS) \
    (lpDDS->lpVtbl == &ddSurfaceCallbacks || lpDDS->lpVtbl == &ddSurface2Callbacks || lpDDS->lpVtbl == &ddSurface3Callbacks )

/*
 * This macro allows testing an interface pointer to see if it's one that come from
 * our implementation of ddraw, or somebody else's
 */
#define IS_NATIVE_DDRAW_INTERFACE(ptr) \
        ( ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd2Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd4Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd7Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd2UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd4UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd5UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddVideoPortContainerCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddKernelCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddMotionCompContainerCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddUninitCallbacks) )

/*
 * This macro tests if this ddraw interface is one for which child objects should take
 * a ref count on that interface and thus achieve immortality wrt that interface.
 */
#define CHILD_SHOULD_TAKE_REFCNT(dd_int) (!LOWERTHANDDRAW3(dd_int))

/*
 * macros for checking if surface as been lost due to mode change
 * NOTE: The flag for determining if a surface is lost or not is now
 * stored in the local than global object. This prevents the scenario
 * where a surface being shared by two processes is lost and restored
 * by one of them - giving the other no notification that the contents
 * of the surface are gone.
 */
#define SURFACE_LOST( lcl_ptr ) (((lcl_ptr)->dwFlags & DDRAWISURF_INVALID))

/*
 * Useful palette macros
 *
 * All these flags are really iritating to handle but but changing
 * to use a numeric palette size would require an API change and
 * internal structure mods (visible to the driver) so I am sticking
 * with flags.
 */
#define SIZE_PCAPS_TO_FLAGS( pcaps )                              \
    (((pcaps) & DDPCAPS_1BIT) ? DDRAWIPAL_2 :                     \
     (((pcaps) & DDPCAPS_2BIT) ? DDRAWIPAL_4 :                    \
      (((pcaps) & DDPCAPS_4BIT) ? DDRAWIPAL_16 : DDRAWIPAL_256)))

#define SIZE_FLAGS_TO_PCAPS( flags )                              \
    (((flags) & DDRAWIPAL_2) ? DDPCAPS_1BIT :                     \
     (((flags) & DDRAWIPAL_4) ? DDPCAPS_2BIT :                    \
      (((flags) & DDRAWIPAL_16) ? DDPCAPS_4BIT : DDPCAPS_8BIT)))

#define FLAGS_TO_SIZE( flags )                                    \
    (((flags) & DDRAWIPAL_2)  ? 2 :                               \
     (((flags) & DDRAWIPAL_4)  ? 4 :                              \
      (((flags) & DDRAWIPAL_16) ? 16 : 256)))

/*
 * has Direct3D been initialized for this DirectDraw driver object?
 */
#define D3D_INITIALIZED( lcl_ptr )  (( NULL != (lcl_ptr)->pD3DIUnknown)  && ( NULL != (lcl_ptr)->hD3DInstance ))

#if defined( _WIN32 ) && !defined( WINNT )
/*
 * Macros and types to support secondary (stacked) drivers.
 *
 * NOTE: This stuff is only relevant to 32-bit DirectDraw and the GUIDs
 * confuse DDRAW16.
 */
#define MAX_SECONDARY_DRIVERNAME              MAX_PATH
#define MAX_SECONDARY_ENTRYPOINTNAME          32UL
#define DEFAULT_SECONDARY_ENTRYPOINTNAME      "GetInfo"

#define REGSTR_PATH_SECONDARY                 "Software\\Microsoft\\DirectDraw\\Secondary"
#define REGSTR_VALUE_SECONDARY_ENTRYPOINTNAME "Entry"
#define REGSTR_VALUE_SECONDARY_DRIVERNAME     "Name"

typedef DWORD                    (WINAPI * LPSECONDARY_PATCHHALINFO)(
                                        LPDDHALINFO                lpDDHALInfo,
                                        LPDDHAL_DDCALLBACKS        lpDDCallbacks,
                                        LPDDHAL_DDSURFACECALLBACKS lpDDSurfaceCallbacks,
                                        LPDDHAL_DDPALETTECALLBACKS lpDDPaletteCallbacks,
                                        LPDDHAL_DDEXEBUFCALLBACKS  lpDDExeBufCallbacks);
typedef LPSECONDARY_PATCHHALINFO (WINAPI * LPSECONDARY_VALIDATE)(LPGUID lpGuid);

DEFINE_GUID( guidCertifiedSecondaryDriver, 0x8061d4e0,0xe895,0x11cf,0xa2,0xe0,0x00,0xaa,0x00,0xb9,0x33,0x56 );
#endif

#if defined( _WIN32 )
DEFINE_GUID( guidVoodoo1A, 0x3a0cfd01,0x9320,0x11cf,0xac,0xa1,0x00,0xa0,0x24,0x13,0xc2,0xe2 );
DEFINE_GUID( guidVoodoo1B, 0xaba52f41,0xf744,0x11cf,0xb4,0x52,0x00,0x00,0x1d,0x1b,0x41,0x26 );
#endif

/*
 * macros for validating pointers
 */
extern DIRECTDRAWCALLBACKS                      ddCallbacks;
extern DIRECTDRAWCALLBACKS                      ddUninitCallbacks;
extern DIRECTDRAW2CALLBACKS                     dd2UninitCallbacks;
extern DIRECTDRAW2CALLBACKS                     dd2Callbacks;
extern DIRECTDRAW4CALLBACKS                     dd4UninitCallbacks;
extern DIRECTDRAW4CALLBACKS                     dd4Callbacks;
extern DIRECTDRAW7CALLBACKS                     dd7UninitCallbacks;
extern DIRECTDRAW7CALLBACKS                     dd7Callbacks;
extern DIRECTDRAWSURFACECALLBACKS               ddSurfaceCallbacks;
extern DIRECTDRAWSURFACE2CALLBACKS              ddSurface2Callbacks;
extern DIRECTDRAWSURFACE3CALLBACKS              ddSurface3Callbacks;
extern DIRECTDRAWSURFACE4CALLBACKS              ddSurface4Callbacks;
extern DIRECTDRAWSURFACE7CALLBACKS              ddSurface7Callbacks;
extern DIRECTDRAWCLIPPERCALLBACKS               ddClipperCallbacks;
extern DIRECTDRAWCLIPPERCALLBACKS               ddUninitClipperCallbacks;
extern DIRECTDRAWPALETTECALLBACKS               ddPaletteCallbacks;
extern DDVIDEOPORTCONTAINERCALLBACKS            ddVideoPortContainerCallbacks;
extern DIRECTDRAWVIDEOPORTCALLBACKS             ddVideoPortCallbacks;
extern DIRECTDRAWKERNELCALLBACKS                ddKernelCallbacks;
extern DIRECTDRAWSURFACEKERNELCALLBACKS         ddSurfaceKernelCallbacks;
extern DIRECTDRAWPALETTECALLBACKS               ddPaletteCallbacks;
extern DIRECTDRAWCOLORCONTROLCALLBACKS          ddColorControlCallbacks;
extern DIRECTDRAWGAMMACONTROLCALLBACKS          ddGammaControlCallbacks;
#ifdef POSTPONED
extern NONDELEGATINGUNKNOWNCALLBACKS            ddNonDelegatingUnknownCallbacks;
extern NONDELEGATINGUNKNOWNCALLBACKS            ddUninitNonDelegatingUnknownCallbacks;
extern LPVOID NonDelegatingIUnknownInterface;
extern LPVOID UninitNonDelegatingIUnknownInterface;
#endif
extern DDVIDEOACCELERATORCONTAINERCALLBACKS     ddMotionCompContainerCallbacks;
extern DIRECTDRAWVIDEOACCELERATORCALLBACKS      ddMotionCompCallbacks;

#ifdef POSTPONED
extern DDFACTORY2CALLBACKS                      ddFactory2Callbacks;
extern DIRECTDRAWPALETTE2CALLBACKS              ddPalette2Callbacks;
extern DIRECTDRAWPALETTEPERSISTCALLBACKS        ddPalettePersistCallbacks;
extern DIRECTDRAWPALETTEPERSISTSTREAMCALLBACKS  ddPalettePersistStreamCallbacks;
extern DIRECTDRAWSURFACEPERSISTCALLBACKS        ddSurfacePersistCallbacks;
extern DIRECTDRAWSURFACEPERSISTSTREAMCALLBACKS  ddSurfacePersistStreamCallbacks;
extern DIRECTDRAWOPTSURFACECALLBACKS            ddOptSurfaceCallbacks;
#endif

#ifndef DEBUG
#define FAST_CHECKING
#endif

/*
 * VALIDEX_xxx macros are the same for debug and retail
 */
#define VALIDEX_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )

#define VALIDEX_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
        (!IsBadCodePtr( (LPVOID) ptr ) )

#define VALIDEX_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_DIRECTDRAWFACTORY2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDFACTORY2 )) && \
        (ptr->lpVtbl == &ddFactory2Callbacks) )
#define VALIDEX_DIRECTDRAW_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DIRECTDRAW_INT )) && \
        ( (ptr->lpVtbl == &ddCallbacks) || \
          (ptr->lpVtbl == &dd2Callbacks) || \
          (ptr->lpVtbl == &dd4Callbacks) || \
          (ptr->lpVtbl == &dd7Callbacks) || \
          (ptr->lpVtbl == &dd2UninitCallbacks) || \
          (ptr->lpVtbl == &dd4UninitCallbacks) || \
          (ptr->lpVtbl == &dd7UninitCallbacks) || \
          (ptr->lpVtbl == &ddVideoPortContainerCallbacks) || \
          (ptr->lpVtbl == &ddKernelCallbacks) || \
          (ptr->lpVtbl == &ddMotionCompContainerCallbacks) || \
          (ptr->lpVtbl == &ddUninitCallbacks) ) )
#define VALIDEX_DIRECTDRAWSURFACE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWSURFACE_INT )) && \
        ( (ptr->lpVtbl == &ddSurfaceCallbacks ) || \
          (ptr->lpVtbl == &ddSurface7Callbacks ) || \
          (ptr->lpVtbl == &ddSurface4Callbacks ) || \
          (ptr->lpVtbl == &ddSurface3Callbacks ) || \
          (ptr->lpVtbl == &ddSurface2Callbacks ) || \
          (ptr->lpVtbl == &ddSurfaceKernelCallbacks ) || \
          (ptr->lpVtbl == &ddColorControlCallbacks ) || \
          (ptr->lpVtbl == &ddGammaControlCallbacks ) ) )
#define VALIDEX_DIRECTDRAWPALETTE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWPALETTE_INT )) && \
        (ptr->lpVtbl == &ddPaletteCallbacks) )
#define VALIDEX_DIRECTDRAWCLIPPER_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWCLIPPER_INT )) && \
        ( (ptr->lpVtbl == &ddClipperCallbacks) || \
          (ptr->lpVtbl == &ddUninitClipperCallbacks) ) )
#define VALIDEX_DDCOLORCONTROL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDCOLORCONTROL_INT )) && \
        (ptr->lpVtbl == &ddColorControlCallbacks) )
#define VALIDEX_DDDEVICEIDENTIFIER_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER )))
#define VALIDEX_DDDEVICEIDENTIFIER2_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER2 )))


/*
 * These macros validate the size (in debug and retail) of callback
 * tables.
 *
 * NOTE: It is essential that the comparison against the current
 * callback size expected by this DirectDraw the comparison operator
 * be >= rather than ==. This is to ensure that newer drivers can run
 * against older DirectDraws.
 */
#define VALIDEX_DDCALLBACKSSIZE( ptr )                       \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ( ptr )->dwSize == DDCALLBACKSSIZE_V1   )   || \
            ( ( ptr )->dwSize >= DDCALLBACKSSIZE      ) ) )

#define VALIDEX_DDSURFACECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDSURFACECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDEXEBUFCALLBACKSSIZE( ptr )                 \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDEXEBUFCALLBACKSSIZE ) )

#define VALIDEX_DDVIDEOPORTCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDVIDEOPORTCALLBACKSSIZE ) )

#define VALIDEX_DDMOTIONCOMPCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMOTIONCOMPCALLBACKSSIZE ) )

#define VALIDEX_DDCOLORCONTROLCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDCOLORCONTROLCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUSCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUSCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUS2CALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUS2CALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS2SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( (( ptr )->dwSize >= D3DHAL_CALLBACKS2SIZE ) ))

#define VALIDEX_D3DCOMMANDBUFFERCALLBACKSSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_COMMANDBUFFERCALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS3SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_CALLBACKS3SIZE ) )

#define VALIDEX_DDKERNELCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDKERNELCALLBACKSSIZE ) )

#define VALIDEX_DDUMODEDRVINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDHAL_DDUMODEDRVINFOSIZE ) )
#define VALIDEX_DDOPTSURFKMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEKMODEINFOSIZE ) )

#define VALIDEX_DDOPTSURFUMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEUMODEINFOSIZE ) )

#ifndef WIN95
#define VALIDEX_DDNTCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDNTCALLBACKSSIZE ) )
#endif

#ifndef FAST_CHECKING
#define VALID_DIRECTDRAW_PTR( ptr )        VALIDEX_DIRECTDRAW_PTR( ptr )
#define VALID_DIRECTDRAWFACTORY2_PTR( ptr )        VALIDEX_DIRECTDRAWFACTORY2_PTR( ptr )
#define VALID_DIRECTDRAWSURFACE_PTR( ptr ) VALIDEX_DIRECTDRAWSURFACE_PTR( ptr )
#define VALID_DIRECTDRAWPALETTE_PTR( ptr ) VALIDEX_DIRECTDRAWPALETTE_PTR( ptr )
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr ) VALIDEX_DIRECTDRAWCLIPPER_PTR( ptr )
#define VALID_DDSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC )))
#define VALID_DDSURFACEDESC2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC2 ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC2 )))
#define VALID_DDVIDEOPORTDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTDESC ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTDESC )) )
#define VALID_DDVIDEOPORTCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTCAPS ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTCAPS )) )
#define VALID_DDVIDEOPORTINFO_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTINFO ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTINFO )) )
#define VALID_DDVIDEOPORTBANDWIDTH_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTBANDWIDTH ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTBANDWIDTH )) )
#define VALID_DDVIDEOPORTSTATUS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTSTATUS ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTSTATUS )) )
#define VALID_DDCOLORCONTROL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCOLORCONTROL ) ) && \
        (ptr->dwSize == sizeof( DDCOLORCONTROL )) )
#define VALID_DDKERNELCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDKERNELCAPS ) ) && \
        (ptr->dwSize == sizeof( DDKERNELCAPS )) )
#define VALID_DWORD_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) ))
#define VALID_BOOL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_HDC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HDC ) ))
#define VALID_DDPIXELFORMAT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDPIXELFORMAT ) ) && \
        (ptr->dwSize == sizeof( DDPIXELFORMAT )) )
#define VALID_DDCOLORKEY_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr, size ) \
        (!IsBadWritePtr( ptr, size ) )
#define VALID_RECT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_DDBLTFX_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDBLTFX ) ) && \
        (ptr->dwSize == sizeof( DDBLTFX )) )
#define VALID_DDBLTBATCH_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDBLTBATCH ) ) )
#define VALID_DDOVERLAYFX_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDOVERLAYFX ) ) && \
        (ptr->dwSize == sizeof( DDOVERLAYFX )) )
#define VALID_DDSCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSCAPS ) ) )
#define VALID_DDSCAPS2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSCAPS2 ) ) )
#define VALID_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( PALETTEENTRY ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DDCORECAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCORECAPS ) ) && \
         (ptr->dwSize == sizeof( DDCORECAPS ) ) )
#define VALID_DDCAPS_PTR( ptr )                          \
         ( ( !IsBadWritePtr( ptr, sizeof( DWORD ) ) ) && \
           ( !IsBadWritePtr( ptr, ptr->dwSize     ) ) && \
           ( ( ptr->dwSize == sizeof( DDCAPS_DX1 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX3 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX5 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX6 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX7 ) ) ) )
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt ) \
        (!IsBadReadPtr( ptr, sizeof( DDSURFACEDESC ) * cnt ) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )
#define VALID_DDVIDEOPORT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDVIDEOPORT_INT )) && \
        (ptr->lpVtbl == &ddVideoPortCallbacks) )
#define VALID_DDOPTSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDOPTSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDOPTSURFACEDESC )))
#define VALID_DDMOTIONCOMP_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDMOTIONCOMP_INT )) && \
        (ptr->lpVtbl == &ddMotionCompCallbacks) )

#else
#define VALID_PTR( ptr, size )          1
#define VALID_DIRECTDRAW_PTR( ptr )     1
#define VALID_DIRECTDRAWFACTORY2_PTR( ptr )     1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )      1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )      1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )      1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_DDSURFACEDESC2_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC2 ))
#define VALID_DDVIDEOPORTDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTDESC ))
#define VALID_DDVIDEOPORTCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTCAPS ))
#define VALID_DDVIDEOPORTINFO_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTINFO ))
#define VALID_DDVIDEOPORTBANDWIDTH_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTBANDWIDTH ))
#define VALID_DDVIDEOPORTSTATUS_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTSTATUS ))
#define VALID_DDCOLORCONTROL_PTR( ptr ) (ptr->dwSize == sizeof( DDCOLORCONTROL ))
#define VALID_DDKERNELCAPS_PTR( ptr) (ptr->dwSize == sizeof( DDKERNELCAPS ))
#define VALID_DWORD_PTR( ptr )  1
#define VALID_BOOL_PTR( ptr )   1
#define VALID_HDC_PTR( ptr )    1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )     1
#define VALID_RGNDATA_PTR( ptr )        1
#define VALID_RECT_PTR( ptr )   1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )     1
#define VALID_DDMASK_PTR( ptr ) 1
#define VALID_DDSCAPS_PTR( ptr )        1
#define VALID_DDSCAPS2_PTR( ptr )       1
#define VALID_PTR_PTR( ptr )    1
#define VALID_IID_PTR( ptr )    1
#define VALID_HWND_PTR( ptr )   1
#define VALID_VMEM_PTR( ptr )   1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )    1
#define VALID_HANDLE_PTR( ptr ) 1
#define VALID_DDCORECAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCORECAPS )
#define VALID_DDCAPS_PTR( ptr )                  \
    ( ( ptr->dwSize == sizeof( DDCAPS_DX1 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX3 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX5 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX6 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX7 ) ) )
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )      1
#define VALID_DWORD_ARRAY( ptr, cnt )   1
#define VALID_GUID_PTR( ptr )   1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1
#define VALID_DDVIDEOPORT_PTR( ptr ) 1
#define VALID_DDOPTSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDOPTSURFACEDESC ))
#define VALID_DDMOTIONCOMP_PTR( ptr ) 1

#endif

/*
 * All global (i.e. cross-process) values now reside in an instance of the following structure.
 * This instance is in its own shared data section.
 */

#undef GLOBALS_IN_STRUCT

#ifdef GLOBALS_IN_STRUCT
    #define GLOBAL_STORAGE_CLASS
    typedef struct
    {
#else
    #define GLOBAL_STORAGE_CLASS extern
#endif

    /*
     * This member should stay at the top in order to guarantee that it be intialized to zero
     * -see dllmain.c 's instance of this structure
     */
GLOBAL_STORAGE_CLASS    DWORD               dwRefCnt;

GLOBAL_STORAGE_CLASS    DWORD                   dwLockCount;

GLOBAL_STORAGE_CLASS    DWORD                   dwFakeCurrPid;
GLOBAL_STORAGE_CLASS    DWORD                   dwGrimReaperPid;

GLOBAL_STORAGE_CLASS    LPDDWINDOWINFO      lpWindowInfo;  // the list of WINDOWINFO structures
GLOBAL_STORAGE_CLASS    LPDDRAWI_DIRECTDRAW_INT lpDriverObjectList;
GLOBAL_STORAGE_CLASS    LPDDRAWI_DIRECTDRAW_LCL lpDriverLocalList;
GLOBAL_STORAGE_CLASS    volatile DWORD      dwMarker;
    /*
     * This is the globally maintained list of clippers not owned by any
     * DirectDraw object. All clippers created with DirectDrawClipperCreate
     * are placed on this list. Those created by IDirectDraw_CreateClipper
     * are placed on the clipper list of thier owning DirectDraw object.
     *
     * The objects on this list are NOT released when an app's DirectDraw
     * object is released. They remain alive until explictly released or
     * the app. dies.
     */
GLOBAL_STORAGE_CLASS    LPDDRAWI_DDRAWCLIPPER_INT lpGlobalClipperList;

GLOBAL_STORAGE_CLASS    HINSTANCE                   hModule;
GLOBAL_STORAGE_CLASS    LPATTACHED_PROCESSES    lpAttachedProcesses;
GLOBAL_STORAGE_CLASS    BOOL                bFirstTime;

    #ifdef DEBUG
GLOBAL_STORAGE_CLASS        int             iDLLCSCnt;
GLOBAL_STORAGE_CLASS        int             iWin16Cnt;
    #endif

        /*
         * Winnt specific global statics
         */
        /*
         *Hel globals:
         */

    // used to count how many drivers are currently using the HEL
GLOBAL_STORAGE_CLASS    DWORD               dwHELRefCnt;
#ifdef WINNT
    GLOBAL_STORAGE_CLASS  LPDCISURFACEINFO  gpdci;
#endif

#ifdef DEBUG
        // these are used by myCreateSurface
    GLOBAL_STORAGE_CLASS        int                 gcSurfMem; // surface memory in bytes
    GLOBAL_STORAGE_CLASS        int                 gcSurf;  // number of surfaces
#endif

GLOBAL_STORAGE_CLASS    DWORD               dwHelperPid;

#ifdef WINNT
GLOBAL_STORAGE_CLASS    HANDLE              hExclusiveModeMutex;
GLOBAL_STORAGE_CLASS    HANDLE              hCheckExclusiveModeMutex;
#endif

#ifdef GLOBALS_IN_STRUCT

    } GLOBALS;

    /*
     * And this is the pointer to the globals. Each process has an instance (contained in dllmain.c)
     */
    //extern GLOBALS * gp;
    extern GLOBALS g_s;
#endif //globals in struct

/*
 * IMPORTANT NOTE: This function validates the HAL information passed to us from the driver.
 * It is vital that we code this check so that we will pass HAL information structures
 * larger than the ones we know about so that new drivers can work with old DirectDraws.
 */
#define VALIDEX_DDHALINFO_PTR( ptr )                         \
        ( ( ( ( ptr )->dwSize == sizeof( DDHALINFO_V1 ) ) || \
            ( ( ptr )->dwSize == DDHALINFOSIZE_V2 )       || \
            ( ( ptr )->dwSize >= sizeof( DDHALINFO ) ) ) &&  \
          !IsBadWritePtr( ( ptr ), ( UINT ) ( ( ptr )->dwSize ) ) )

#define VALIDEX_STR_PTR( ptr, len ) \
        (!IsBadReadPtr( ptr, 1 ) && (lstrlen( ptr ) <len) )
#define VALIDEX_DDSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC )) )
#define VALIDEX_DDSURFACEDESC2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC2 ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC2 )) )

/* Turn on D3D stats collection for Debug builds HERE */
#define COLLECTSTATS    DBG

#ifdef __cplusplus
}       // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\dinputdp.h ===
DEFINE_GUID(IID_IDirectInputDeviceCallback, 0x1DE12AA0,0xC9F5,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputEffectShepherd, 0x1DE12AA1,0xC9F5,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputMapShepherd,    0x6a3e3144,0x3eee,0x4aa5,0x95,0x87,0xe1,0x0a,0x21,0xfe,0xc7,0x71);
DEFINE_GUID(IID_IDIActionFramework,             0xf4279160,0x608f,0x11d3,0x8f,0xb2,0x0, 0xc0,0x4f,0x8e,0xc6,0x27);
DEFINE_GUID(CLSID_CDirectInputActionFramework,  0x9f34af20,0x6095,0x11d3,0x8f,0xb2,0x0, 0xc0,0x4f,0x8e,0xc6,0x27);
/****************************************************************************
 *
 *      IDirectInputEffectShepherd
 *
 *      Special wrapper class which gates access to DirectInput
 *      effect drivers.
 *
 ****************************************************************************/

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SHEPHANDLE |
 *
 *          Information that shepherds an effect handle.
 *
 *  @field  DWORD | dwEffect |
 *
 *          The effect handle itself, possibly invalid if the device
 *          has since been reset.
 *
 *          If the value is zero, then the effect has not
 *          been downloaded.
 *
 *  @field  DWORD | dwTag |
 *
 *          Reset counter tag for the effect.  If this value is different
 *          from the tag stored in shared memory, then it means that
 *          the device has been reset in the interim and no longer
 *          belongs to the caller.
 *
 ****************************************************************************/

typedef struct SHEPHANDLE {
    DWORD dwEffect;
    DWORD dwTag;
} SHEPHANDLE, *PSHEPHANDLE;

#undef INTERFACE
#define INTERFACE IDirectInputEffectShepherd

DECLARE_INTERFACE_(IDirectInputEffectShepherd, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffectShepherd methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,LPVOID) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(Escape)(THIS_ PSHEPHANDLE,LPDIEFFESCAPE) PURE;
    STDMETHOD(DeviceEscape)(THIS_ PSHEPHANDLE,LPDIEFFESCAPE) PURE;
    STDMETHOD(SetGain)(THIS_ PSHEPHANDLE,DWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ PSHEPHANDLE,DWORD) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ PSHEPHANDLE,LPDIDEVICESTATE) PURE;
    STDMETHOD(DownloadEffect)(THIS_ DWORD,PSHEPHANDLE,LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(DestroyEffect)(THIS_ PSHEPHANDLE) PURE;
    STDMETHOD(StartEffect)(THIS_ PSHEPHANDLE,DWORD,DWORD) PURE;
    STDMETHOD(StopEffect)(THIS_ PSHEPHANDLE) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ PSHEPHANDLE,LPDWORD) PURE;
    STDMETHOD(SetGlobalGain)(THIS_ DWORD) PURE;
};

typedef struct IDirectInputEffectShepherd *LPDIRECTINPUTEFFECTSHEPHERD;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffectShepherd_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffectShepherd_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffectShepherd_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffectShepherd_DeviceID(p,a,b,c) (p)->lpVtbl->DeviceID(p,a,b,c)
#define IDirectInputEffectShepherd_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputEffectShepherd_Escape(p,a,b) (p)->lpVtbl->Escape(p,a,b)
#define IDirectInputEffectShepherd_DeviceEscape(p,a,b) (p)->lpVtbl->DeviceEscape(p,a,b)
#define IDirectInputEffectShepherd_SetGain(p,a,b) (p)->lpVtbl->SetGain(p,a,b)
#define IDirectInputEffectShepherd_SendForceFeedbackCommand(p,a,b) (p)->lpVtbl->SendForceFeedbackCommand(p,a,b)
#define IDirectInputEffectShepherd_GetForceFeedbackState(p,a,b) (p)->lpVtbl->GetForceFeedbackState(p,a,b)
#define IDirectInputEffectShepherd_DownloadEffect(p,a,b,c,d) (p)->lpVtbl->DownloadEffect(p,a,b,c,d)
#define IDirectInputEffectShepherd_DestroyEffect(p,a) (p)->lpVtbl->DestroyEffect(p,a)
#define IDirectInputEffectShepherd_StartEffect(p,a,b,c) (p)->lpVtbl->StartEffect(p,a,b,c)
#define IDirectInputEffectShepherd_StopEffect(p,a) (p)->lpVtbl->StopEffect(p,a)
#define IDirectInputEffectShepherd_GetEffectStatus(p,a,b) (p)->lpVtbl->GetEffectStatus(p,a,b)
#define IDirectInputEffectShepherd_SetGlobalGain(p,a) (p)->lpVtbl->SetGlobalGain(p,a)
#else
#define IDirectInputEffectShepherd_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffectShepherd_AddRef(p) (p)->AddRef()
#define IDirectInputEffectShepherd_Release(p) (p)->Release()
#define IDirectInputEffectShepherd_DeviceID(p,a,b,c) (p)->DeviceID(a,b,c)
#define IDirectInputEffectShepherd_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputEffectShepherd_Escape(p,a,b) (p)->Escape(a,b)
#define IDirectInputEffectShepherd_DeviceEscape(p,a,b) (p)->DeviceEscape(a,b)
#define IDirectInputEffectShepherd_SetGain(p,a,b) (p)->SetGain(a,b)
#define IDirectInputEffectShepherd_SendForceFeedbackCommand(p,a,b) (p)->SendForceFeedbackCommand(a,b)
#define IDirectInputEffectShepherd_GetForceFeedbackState(p,a,b) (p)->GetForceFeedbackState(a,b)
#define IDirectInputEffectShepherd_DownloadEffect(p,a,b,c,d) (p)->DownloadEffect(a,b,c,d)
#define IDirectInputEffectShepherd_DestroyEffect(p,a) (p)->DestroyEffect(a)
#define IDirectInputEffectShepherd_StartEffect(p,a,b,c) (p)->StartEffect(a,b,c)
#define IDirectInputEffectShepherd_StopEffect(p,a) (p)->StopEffect(a)
#define IDirectInputEffectShepherd_GetEffectStatus(p,a,b) (p)->GetEffectStatus(a,b)
#define IDirectInputEffectShepherd_SetGlobalGain(p,a) (p)->SetGlobalGain(a)
#endif

/****************************************************************************
 *
 *      IDirectInputMapShepherd
 *
 *      Special wrapper class which gates access to DirectInput mapper.
 *
 ****************************************************************************/

#if(DIRECTINPUT_VERSION >= 0x0800)
#undef INTERFACE
#define INTERFACE IDirectInputMapShepherd

DECLARE_INTERFACE_(IDirectInputMapShepherd, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputMapShepherd methods ***/
    STDMETHOD(GetActionMap)(THIS_ REFGUID,LPCWSTR,LPDIACTIONFORMATW,LPCWSTR,LPFILETIME,DWORD) PURE;
    STDMETHOD(SaveActionMap)(THIS_ REFGUID,LPCWSTR,LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
    STDMETHOD(GetImageInfo)(THIS_ REFGUID,LPCWSTR,LPDIDEVICEIMAGEINFOHEADERW) PURE;
};

typedef struct IDirectInputMapShepherd *LPDIRECTINPUTMAPSHEPHERD;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputMapShepherd_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputMapShepherd_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputMapShepherd_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputMapShepherd_GetActionMap(p,a,b,c,d,e,f) (p)->lpVtbl->GetActionMap(p,a,b,c,d,e,f)
#define IDirectInputMapShepherd_SaveActionMap(p,a,b,c,d,e) (p)->lpVtbl->SaveActionMap(p,a,b,c,d,e)
#define IDirectInputMapShepherd_GetImageInfo(p,a,b,c) (p)->lpVtbl->GetImageInfo(p,a,b,c)
#else
#define IDirectInputMapShepherd_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputMapShepherd_AddRef(p) (p)->AddRef()
#define IDirectInputMapShepherd_Release(p) (p)->Release()
#define IDirectInputMapShepherd_GetActionMap(p,a,b,c,d,e,f) (p)->GetActionMap(a,b,c,d,e,f)
#define IDirectInputMapShepherd_SaveActionMap(p,a,b,c,d,e) (p)->SaveActionMap(a,b,c,d,e)
#define IDirectInputMapShepherd_GetImageInfo(p,a,b,c) (p)->GetImageInfo(a,b,c)
#endif
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct DIPROPINFO |
 *
 *          Information used to describe an object being accessed.
 *
 *  @field  const GUID * | pguid |
 *
 *          The property being accessed (if applicable).
 *
 *  @field  UINT | iobj |
 *
 *          Zero-based index to object (or 0xFFFFFFFF if accessing the
 *          device).
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type information (or 0 if accessing the device).
 *
 ****************************************************************************/

typedef struct DIPROPINFO {
    const GUID *pguid;
    UINT iobj;
    DWORD dwDevType;
} DIPROPINFO, *LPDIPROPINFO;
typedef const DIPROPINFO *LPCDIPROPINFO;

#define DICOOK_DFOFSFROMOFSID(dwOfs, dwType)        MAKELONG(dwOfs, dwType)
#define DICOOK_IDFROMDFOFS(dwFakeOfs)               HIWORD(dwFakeOfs)
#define DICOOK_OFSFROMDFOFS(dwFakeOfs)              LOWORD(dwFakeOfs)

/****************************************************************************
 *
 *      IDirectInputDeviceCallback
 *
 *      IDirectInputDevice uses it to communicate with the
 *      component that is responsible for collecting data from
 *      the appropriate hardware device.
 *
 *      E.g., mouse, keyboard, joystick, HID.
 *
 *      Methods should return E_NOTIMPL for anything not understood.
 *
 ****************************************************************************/
#if(DIRECTINPUT_VERSION >= 0x0800)
#undef INTERFACE
#define INTERFACE IDirectInputDeviceCallback

DECLARE_INTERFACE_(IDirectInputDeviceCallback, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceCallback methods ***/
    STDMETHOD(GetInstance)(THIS_ LPVOID *) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(GetDataFormat)(THIS_ LPDIDATAFORMAT *) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPCDIPROPINFO,LPDIDEVICEOBJECTINSTANCEW) PURE;
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ LPVOID) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(GetProperty)(THIS_ LPCDIPROPINFO,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ LPCDIPROPINFO,LPCDIPROPHEADER) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(CookDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA) PURE;
    STDMETHOD(CreateEffect)(THIS_ LPDIRECTINPUTEFFECTSHEPHERD *) PURE;
    STDMETHOD(GetFFConfigKey)(THIS_ DWORD,PHKEY) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD_(DWORD,GetUsage)(THIS_ int) PURE;
    STDMETHOD(MapUsage)(THIS_ DWORD,PINT) PURE;
    STDMETHOD(SetDIData)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(BuildDefaultActionMap)(THIS_ LPDIACTIONFORMATW,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceCallback *LPDIRECTINPUTDEVICECALLBACK;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDeviceCallback_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDeviceCallback_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDeviceCallback_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDeviceCallback_GetInstance(p,a) (p)->lpVtbl->GetInstance(p,a)
#define IDirectInputDeviceCallback_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputDeviceCallback_GetDataFormat(p,a) (p)->lpVtbl->GetDataFormat(p,a)
#define IDirectInputDeviceCallback_GetObjectInfo(p,a,b) (p)->lpVtbl->GetObjectInfo(p,a,b)
#define IDirectInputDeviceCallback_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDeviceCallback_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDeviceCallback_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDeviceCallback_GetDeviceState(p,a) (p)->lpVtbl->GetDeviceState(p,a)
#define IDirectInputDeviceCallback_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDeviceCallback_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDeviceCallback_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDeviceCallback_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDeviceCallback_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDeviceCallback_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDeviceCallback_CookDeviceData(p,a,b) (p)->lpVtbl->CookDeviceData(p,a,b)
#define IDirectInputDeviceCallback_CreateEffect(p,a) (p)->lpVtbl->CreateEffect(p,a)
#define IDirectInputDeviceCallback_GetFFConfigKey(p,a,b) (p)->lpVtbl->GetFFConfigKey(p,a,b)
#define IDirectInputDeviceCallback_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#define IDirectInputDeviceCallback_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDeviceCallback_GetUsage(p,a) (p)->lpVtbl->GetUsage(p,a)
#define IDirectInputDeviceCallback_MapUsage(p,a,b) (p)->lpVtbl->MapUsage(p,a,b)
#define IDirectInputDeviceCallback_SetDIData(p,a,b) (p)->lpVtbl->SetDIData(p,a,b)
#define IDirectInputDeviceCallback_BuildDefaultActionMap(p,a,b,c) (p)->lpVtbl->BuildDefaultActionMap(p,a,b,c)
#else
#define IDirectInputDeviceCallback_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDeviceCallback_AddRef(p) (p)->AddRef()
#define IDirectInputDeviceCallback_Release(p) (p)->Release()
#define IDirectInputDeviceCallback_GetInstance(p,a) (p)->GetInstance(a)
#define IDirectInputDeviceCallback_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputDeviceCallback_GetDataFormat(p,a) (p)->GetDataFormat(a)
#define IDirectInputDeviceCallback_GetObjectInfo(p,a,b) (p)->GetObjectInfo(a,b)
#define IDirectInputDeviceCallback_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDeviceCallback_Acquire(p) (p)->Acquire()
#define IDirectInputDeviceCallback_Unacquire(p) (p)->Unacquire()
#define IDirectInputDeviceCallback_GetDeviceState(p,a) (p)->GetDeviceState(a)
#define IDirectInputDeviceCallback_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDeviceCallback_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDeviceCallback_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDeviceCallback_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDeviceCallback_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDeviceCallback_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDeviceCallback_CookDeviceData(p,a,b) (p)->CookDeviceData(a,b)
#define IDirectInputDeviceCallback_CreateEffect(p,a) (p)->CreateEffect(a)
#define IDirectInputDeviceCallback_GetFFConfigKey(p,a,b) (p)->GetFFConfigKey(a,b)
#define IDirectInputDeviceCallback_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#define IDirectInputDeviceCallback_Poll(p) (p)->Poll()
#define IDirectInputDeviceCallback_GetUsage(p,a) (p)->GetUsage(a)
#define IDirectInputDeviceCallback_MapUsage(p,a,b) (p)->MapUsage(a,b)
#define IDirectInputDeviceCallback_SetDIData(p,a,b) (p)->SetDIData(a,b)
#define IDirectInputDeviceCallback_BuildDefaultActionMap(p,a,b,c) (p)->BuildDefaultActionMap(a,b,c)
#endif

#else
#undef INTERFACE
#define INTERFACE IDirectInputDeviceCallback

DECLARE_INTERFACE_(IDirectInputDeviceCallback, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceCallback methods ***/
    STDMETHOD(GetInstance)(THIS_ LPVOID *) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(GetDataFormat)(THIS_ LPDIDATAFORMAT *) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPCDIPROPINFO,LPDIDEVICEOBJECTINSTANCEW) PURE;
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ LPVOID) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(GetProperty)(THIS_ LPCDIPROPINFO,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ LPCDIPROPINFO,LPCDIPROPHEADER) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(CookDeviceData)(THIS_ UINT,LPDIDEVICEOBJECTDATA) PURE;
    STDMETHOD(CreateEffect)(THIS_ LPDIRECTINPUTEFFECTSHEPHERD *) PURE;
    STDMETHOD(GetFFConfigKey)(THIS_ DWORD,PHKEY) PURE;
    STDMETHOD(SendDeviceData)(THIS_ LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD_(DWORD,GetUsage)(THIS_ int) PURE;
    STDMETHOD(MapUsage)(THIS_ DWORD,PINT) PURE;
    STDMETHOD(SetDIData)(THIS_ DWORD,LPVOID) PURE;
};

typedef struct IDirectInputDeviceCallback *LPDIRECTINPUTDEVICECALLBACK;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDeviceCallback_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDeviceCallback_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDeviceCallback_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDeviceCallback_GetInstance(p,a) (p)->lpVtbl->GetInstance(p,a)
#define IDirectInputDeviceCallback_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputDeviceCallback_GetDataFormat(p,a) (p)->lpVtbl->GetDataFormat(p,a)
#define IDirectInputDeviceCallback_GetObjectInfo(p,a,b) (p)->lpVtbl->GetObjectInfo(p,a,b)
#define IDirectInputDeviceCallback_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDeviceCallback_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDeviceCallback_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDeviceCallback_GetDeviceState(p,a) (p)->lpVtbl->GetDeviceState(p,a)
#define IDirectInputDeviceCallback_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDeviceCallback_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDeviceCallback_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDeviceCallback_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDeviceCallback_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDeviceCallback_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDeviceCallback_CookDeviceData(p,a,b) (p)->lpVtbl->CookDeviceData(p,a,b)
#define IDirectInputDeviceCallback_CreateEffect(p,a) (p)->lpVtbl->CreateEffect(p,a)
#define IDirectInputDeviceCallback_GetFFConfigKey(p,a,b) (p)->lpVtbl->GetFFConfigKey(p,a,b)
#define IDirectInputDeviceCallback_SendDeviceData(p,a,b,c) (p)->lpVtbl->SendDeviceData(p,a,b,c)
#define IDirectInputDeviceCallback_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDeviceCallback_GetUsage(p,a) (p)->lpVtbl->GetUsage(p,a)
#define IDirectInputDeviceCallback_MapUsage(p,a,b) (p)->lpVtbl->MapUsage(p,a,b)
#define IDirectInputDeviceCallback_SetDIData(p,a,b) (p)->lpVtbl->SetDIData(p,a,b)
#else
#define IDirectInputDeviceCallback_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDeviceCallback_AddRef(p) (p)->AddRef()
#define IDirectInputDeviceCallback_Release(p) (p)->Release()
#define IDirectInputDeviceCallback_GetInstance(p,a) (p)->GetInstance(a)
#define IDirectInputDeviceCallback_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputDeviceCallback_GetDataFormat(p,a) (p)->GetDataFormat(a)
#define IDirectInputDeviceCallback_GetObjectInfo(p,a,b) (p)->GetObjectInfo(a,b)
#define IDirectInputDeviceCallback_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDeviceCallback_Acquire(p) (p)->Acquire()
#define IDirectInputDeviceCallback_Unacquire(p) (p)->Unacquire()
#define IDirectInputDeviceCallback_GetDeviceState(p,a) (p)->GetDeviceState(a)
#define IDirectInputDeviceCallback_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDeviceCallback_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDeviceCallback_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDeviceCallback_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDeviceCallback_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDeviceCallback_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDeviceCallback_CookDeviceData(p,a,b) (p)->CookDeviceData(a,b)
#define IDirectInputDeviceCallback_CreateEffect(p,a) (p)->CreateEffect(a)
#define IDirectInputDeviceCallback_GetFFConfigKey(p,a,b) (p)->GetFFConfigKey(a,b)
#define IDirectInputDeviceCallback_SendDeviceData(p,a,b,c) (p)->SendDeviceData(a,b,c)
#define IDirectInputDeviceCallback_Poll(p) (p)->Poll()
#define IDirectInputDeviceCallback_GetUsage(p,a) (p)->GetUsage(a)
#define IDirectInputDeviceCallback_MapUsage(p,a,b) (p)->MapUsage(a,b)
#define IDirectInputDeviceCallback_SetDIData(p,a,b) (p)->SetDIData(a,b)
#endif

#endif /* DIRECTINPUT_VERSION >= 0x0800 */

/****************************************************************************
 *
 *      Emulation flags
 *
 *      These bits can be put into the Emulation flag in the registry
 *      key REGSTR_PATH_DINPUT as the DWORD value of REGSTR_VAL_EMULATION.
 *
 *      Warning!  If you use more than fifteen bits of emulation, then
 *      you also have to mess with DIGETEMFL() and DIMAKEEMFL() in
 *      dinputv.h.
 *
 ****************************************************************************/

#define DIEMFL_MOUSE    0x00000001      /* Force mouse emulation */
#define DIEMFL_KBD      0x00000002      /* Force keyboard emulation */
#define DIEMFL_JOYSTICK 0x00000004      /* Force joystick emulation */
#define DIEMFL_KBD2     0x00000008      /* Force keyboard emulation 2 */
#define DIEMFL_MOUSE2   0x00000010      /* Force mouse emulation 2 */

/****************************************************************************
 *
 *      IDirectInputActionFramework
 *      Framework interface for configuring devices
 *
 ****************************************************************************/
#if(DIRECTINPUT_VERSION >= 0x0800)

#undef INTERFACE
#define INTERFACE IDirectInputActionFramework

DECLARE_INTERFACE_(IDirectInputActionFramework, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputActionFramework methods ***/
    STDMETHOD(ConfigureDevices)(THIS_ LPDICONFIGUREDEVICESCALLBACK,LPDICONFIGUREDEVICESPARAMSW,DWORD,LPVOID) PURE;
};

typedef struct IDirectInputActionFramework *LPDIRECTINPUTACTIONFRAMEWORK;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputActionFramework_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputActionFramework_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputActionFramework_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputActionFramework_ConfigureDevices(p,a,b,c,d) (p)->lpVtbl->ConfigureDevices(p,a,b,c,d)
#else
#define IDirectInputActionFramework_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputActionFramework_AddRef(p) (p)->AddRef()
#define IDirectInputActionFramework_Release(p) (p)->Release()
#define IDirectInputActionFramework_ConfigureDevices(p,a,b,c,d) (p)->ConfigureDevices(a,b,c,d)
#endif
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#define JOY_HW_PREDEFMIN    JOY_HW_2A_2B_GENERIC 
#ifdef WINNT
  #define JOY_HW_PREDEFMAX    JOY_HW_LASTENTRY 
#else
  #define JOY_HW_PREDEFMAX    (JOY_HW_LASTENTRY-1)
#endif
#define JOYTYPE_FLAGS1_SETVALID         0x80000000l
#define JOYTYPE_FLAGS1_GETVALID         0x8000000Fl
#define JOYTYPE_FLAGS2_SETVALID         0x01FFFFFFl
#define JOYTYPE_FLAGS2_GETVALID         0x01FFFFFFl
#define iJoyPosAxisX        0                   /* The order in which   */
#define iJoyPosAxisY        1                   /* axes appear          */
#define iJoyPosAxisZ        2                   /* in a JOYPOS          */
#define iJoyPosAxisR        3
#define iJoyPosAxisU        4
#define iJoyPosAxisV        5
#define cJoyPosAxisMax      6
#define cJoyPosButtonMax   32

#define DITC_VOLATILEREGKEY         0x80000000
#define DITC_INREGISTRY_DX5         0x0000000F
#define DITC_GETVALID_DX5           0x0000000F
#define DITC_SETVALID_DX5           0x0000000F
#define DITC_INREGISTRY_DX6         0x0000003F
#define DITC_GETVALID_DX6           0x0000003F
#define DITC_SETVALID_DX6           0x0000003F


#define DITC_INREGISTRY             0x000000FF
#define DITC_GETVALID               0x000000FF
#define DITC_SETVALID               0x000000FF
/*
 *  Name for the 8.0 structure, in places where we specifically care.
 */
typedef       DIJOYTYPEINFO         DIJOYTYPEINFO_DX8;
typedef       LPDIJOYTYPEINFO      *LPDIJOYTYPEINFO_DX8;

BOOL static __inline
IsValidSizeDIJOYTYPEINFO(DWORD cb)
{
    return cb == sizeof(DIJOYTYPEINFO_DX8) ||
           cb == sizeof(DIJOYTYPEINFO_DX6) ||
           cb == sizeof(DIJOYTYPEINFO_DX5);
}

#define DIJC_UPDATEALIAS            0x80000000


#define DIJC_INREGISTRY_DX5         0x0000000E
#define DIJC_GETVALID_DX5           0x0000000F
#define DIJC_SETVALID_DX5           0x0000000E

#define DIJC_INREGISTRY             0x0000001E
#define DIJC_GETVALID               0x0000001F
#define DIJC_SETVALID               0x0000001F
#define DIJC_INTERNALSETVALID       0x8000001F
/*
 *  Name for the 6.? structure, in places where we specifically care.
 */
typedef       DIJOYCONFIG         DIJOYCONFIG_DX6;
typedef       DIJOYCONFIG        *LPDIJOYCONFIG_DX6;

BOOL static __inline
IsValidSizeDIJOYCONFIG(DWORD cb)
{
    return cb == sizeof(DIJOYCONFIG_DX6) ||
           cb == sizeof(DIJOYCONFIG_DX5);
}
#define DIJU_INDRIVERREGISTRY       0x00000006
#define DIJU_GETVALID               0x00000007
#define DIJU_SETVALID               0x80000007
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\ddrawp.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw.h
 *  Content:    DirectDraw include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   24-dec-94  craige  initial implementation
 *   13-jan-95  craige  updated
 *   31-jan-95  craige  and even more ongoing work...
 *   01-mar-95  craige  flags with Get/SetExclusiveMode
 *   07-mar-95  craige  FourCC code stuff
 *   08-mar-95  craige  blt/overlay stretch distinction, bunch of new APIs
 *   11-mar-95  craige  palette stuff
 *   17-mar-95  craige  COM interface
 *   20-mar-95  craige  Get/SetExclusiveMode->Get/SetExclusiveModeOwner,
 *                      flags with CreateSurface and DuplicateSurface
 *   28-mar-95  craige  removed Get/SetColorKey, added FlipToGDISurface to
 *                      IDirectDraw; switched to PALETTEENTRY from RGBQUAD
 *   01-apr-95  craige  happy fun joy updated header file THANK YOU ERIC
 *   06-apr-95  craige  added dwVidMemTotal, dwVidMemFree to DDCAPS
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  GetBltStatus, added flag to GetFlipStatus
 *   12-may-95  craige  added GUIDS;DirectDrawEnumerate
 *   19-may-95  craige  added DDSEMO_ALLOWREBOOT
 *   23-may-95  craige  have driver GetCaps return HEL caps; added Flush,
 *                      GetBatchLimit, SetBatchLimit to IDirectDraw
 *   24-may-95  kylej   removed obsolete ZOrder variables
 *   24-may-95  craige  added Restore
 *   28-may-95  craige  added DDCAPS_COLORKEY_HWASSIST; Unicode support
 *   04-jun-95  craige  added IsLost
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  removed GetExclusiveModeOwner; added parm to
 *                      SetExclusiveMode
 *   15-jun-95  craige  new surface interfaces: IDirectDrawSurfaceNotification,
 *                      IDirectDrawSurfaceComposition
 *   19-jun-95  craige  rationalized INVALIDxxx to DDERR_INVALIDOBJECT
 *   20-jun-95  kylej   added DDERR_CANNOTDETACHSURFACE
 *   21-jun-95  craige  added DirectDrawClipper object; removed clipping
 *                      info from surface object
 *   24-jun-95  craige  added DDBLTFAST_xxx flags
 *   27-jun-95  craige  removed Flush,Set/GetBatchLimit; added BltBatch
 *   30-jun-95  kylej   added DDERR_INCOMPATIBLEPRIMARY
 *   30-jun-95  craige  added dest align as well as src
 *   01-jul-95  craige  hide composition & streaming stuff; added DDERR_EXCEPTION
 *   02-jul-95  craige  hide clipper notification stuff; futzed with DDSCAPS
 *                      position in structures
 *   03-jul-95  kylej   changed EnumSurfaces declaration
 *   03-jul-95  craige  added pUnkOuter to all Create fns; added object ptr
 *                      to CreateSurface, removed lpClipList and lpDDSurface
 *                      from surface desc.
 *   05-jul-95  craige  added Initialize members to all interfaces to allow
 *                      for full COM integration
 *   09-jul-95  craige  added DDERR_LOCKEDSURFACES; changed SetExclusiveMode
 *                      to SetCooperativeLevel
 *   10-jul-95  kylej   added mirroring caps and overlay FX flags
 *   12-jul-95  craige  added DDSCAPS_OWNDC
 *   13-jul-95  craige  changed Get/SetOverlayPosition to take LONGs
 *   14-jul-95  craige  added dwFlags to DDOVERLAYFX
 *   15-jul-95  craige  set DDCAPS_NOHARDWARE
 *   15-jul-95  ericeng changed EnumSurface callback param order, BltBatch
 *                      params, moved all Const var references to a consistent
 *                      location, removed failure mode for height alignment
 *   18-jul-95  craige  removed Flush from surface object
 *   27-jul-95  craige  added DDCAPS_BLTCOLORFILL
 *   31-jul-95  craige  added DDCAPS_BANKSWITCHED, validation flags
 *   02-aug-95  craige  added dwMinOverlayStretch/dwMaxOverlayStretch to DDCAPS
 *   10-aug-95  toddla  added DDBLT_WAIT, DDBLTFAST_WAIT, DDLOCK_WAIT, DDFLIP_WAIT
 *   13-aug-95  craige  added dwCaps2 and reserved fields to DDCAPS; added
 *                      DDCAPS2_CERTIFIED; named alpha caps properly;
 *                      flags parm for Flip
 *   13-aug-95  toddla  added DDSCL_DONTHOOKHWND
 *   19-aug-95  ericeng added DDCAPS2_LIVEVIDEO and DDCAPS2_HWCODEC
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 742: added DDPCAPS_256
 *                      bug 738: use GUID instead of IID
 *   22-sep-95  craige  bug 1268,1269:  getbltstatus/getflipstatus flags wrong
 *   09-nov-95  colinmc added support for 1, 2 and 4 bit RGB and indexed
 *                      palettes
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (determined by DDSCAPS).
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   05-dec-95  colinmc added mip-map support
 *   09-dec-95  colinmc added execute buffer support
 *   13-dec-95  colinmc added shared back and z-buffer support
 *   18-dec-95  colinmc added valid caps mask for surface caps
 *   25-dec-95  craige  changed IDirectDrawV2 to IDirectDraw2
 *   31-dec-95  craige  added CLSID_DirectDraw
 *   04-jan-96  colinmc added explicit support for z-buffer clears
 *   12-feb-96  kylej   added  Interface
 *   23-feb-96  kylej   added IDirectDrawSurface2 Interface
 *   01-mar-96  kylej   new ddcaps structure
 *   06-mar-96  kylej   changed HANDLEs to DWORDs
 *   13-mar-96  kylej   added DD_Surface_GetDDInterface in IDirectDrawSurface2
 *   14-mar-96  colinmc added CLSID_DirectDrawClipper and added the clipper
 *                      creation API function back in
 *   21-mar-96  colinmc Bug 13316: Unitialized interfaces
 *   24-mar-96  colinmc Bug 14321: Structure change to allow flippable mip
 *                      map chains with a single call
 *   26-mar-96  colinmc Bug 14470: Compressed surface support
 *   15-apr-96  colinmc Bug 16855: Can't pass NULL to Initialize in C++
 *   19-apr-96  colinmc Bug 18059: News caps bit to flag that you can't do
 *                      2D during 3D.
 *   01-may-96  colinmc Bug 20005: InternalLock does not check for lost
 *                      surfaces
 *   25-jul-96  scottm  Added DDCAPS2_AUTOFLIPOVERLAY,
 *                      DDCAPS2_CANSMOOTHINTERLEAVED,DDCAPS2_CANSMOOTHNONINTERLEAVED
 *   08-oct-96  ketand  Added support for Interleaved Z (aka RGBZ surfaces)
 *   15-nov-96  colinmc Finally retired DDSCAPS_3D and moved
 *                      DDSCAPS_EXECUTEBUFFER to ddrawi.h so DDK users can
 *                      see it.
 *   08-dec-96  colinmc Initial AGP support
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   12-jan-97  colinmc More Win16 lock work
 *   29-jan-97  smac    Updated color control structure
 *   29-jan-97  jeffno  Mode13 support. New surface cap and enum/setmode flags
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc Support for DMA model AGP cards
 *   11-mar-97  smac    Obsoleted dwMin/MaxLiveVideoStretch and dwMin/MaxHwCodecStretch fields
 *   11-mar-97  jeffno  Don't allow blts between surfaces from different ddraw gbls
 *   22-mar-97  colinmc Bug 6673: Mechanism to let new applications run against
 *                      old runtimes
 *   23-mar-97  colinmc Bug 6673: Changed structure numbering scheme for
 *                      consistency's sake
 *   24-mar-97  jeffno  Optimized Surfaces
 *   16-sep-97  jeffno  DirectDrawEnumerateEx
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for AlphaBlt and SetSpriteDisplayList
 *   07-nov-97  raymondc Borland compatibility
 *   24-nov-97  t-craigs Added IDirectDrawPalette2
 *   19-dec-97 jvanaken IDDS4::Unlock now takes a pointer to a rectangle.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDRAW_INCLUDED__
#define __DDRAW_INCLUDED__

//Disable the nameless union warning when building internally
#undef ENABLE_NAMELESS_UNION_PRAGMA
#ifdef DIRECTX_REDIST
#define ENABLE_NAMELESS_UNION_PRAGMA
#endif

#ifdef ENABLE_NAMELESS_UNION_PRAGMA
#pragma warning(disable:4201)
#endif

/*
 * If you wish an application built against the newest version of DirectDraw
 * to run against an older DirectDraw run time then define DIRECTDRAW_VERSION
 * to be the earlies version of DirectDraw you wish to run against. For,
 * example if you wish an application to run against a DX 3 runtime define
 * DIRECTDRAW_VERSION to be 0x0300.
 */
#ifndef   DIRECTDRAW_VERSION
#define   DIRECTDRAW_VERSION 0x0700
#endif /* DIRECTDRAW_VERSION */

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown            void
#if !defined( NT_BUILD_ENVIRONMENT ) && !defined(WINNT)
        #define CO_E_NOTINITIALIZED 0x800401F0L
#endif
#endif

#define _FACDD  0x876
#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )

#ifdef __cplusplus
extern "C" {
#endif

//
// For compilers that don't support nameless unions, do a
//
// #define NONAMELESSUNION
//
// before #include <ddraw.h>
//
#ifndef DUMMYUNIONNAMEN
#if defined(__cplusplus) || !defined(NONAMELESSUNION)
#define DUMMYUNIONNAMEN(n)
#else
#define DUMMYUNIONNAMEN(n)      u##n
#endif
#endif

#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif //defined(MAKEFOURCC)

/*
 * FOURCC codes for DX compressed-texture pixel formats
 */
#define FOURCC_DXT1  (MAKEFOURCC('D','X','T','1'))
#define FOURCC_DXT2  (MAKEFOURCC('D','X','T','2'))
#define FOURCC_DXT3  (MAKEFOURCC('D','X','T','3'))
#define FOURCC_DXT4  (MAKEFOURCC('D','X','T','4'))
#define FOURCC_DXT5  (MAKEFOURCC('D','X','T','5'))

/*
 * GUIDS used by DirectDraw objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )

DEFINE_GUID( CLSID_DirectDraw,                  0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35 );
DEFINE_GUID( CLSID_DirectDraw7,                 0x3c305196,0x50db,0x11d3,0x9c,0xfe,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( CLSID_DirectDrawClipper,           0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw,                   0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDraw7,                  0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b );
DEFINE_GUID( IID_IDirectDrawSurface,            0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,           0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );
DEFINE_GUID( IID_IDirectDrawSurface7,           0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b );
//@@BEGIN_MSINTERNAL
DEFINE_GUID( IID_IDirectDrawSurfaceNew,         0x1bab8e96,0x9cfe,0x4ce3,0xbc,0x72,0xd7,0xe9,0xe9,0x9a,0x21,0x75 );
DEFINE_GUID( CLSID_DirectDrawFactory2,          0xb9dc4790,0x4af1,0x11d1,0x8c,0x4c,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDrawFactory2,           0x89b2c488,0x4af4,0x11d1,0x8c,0x4c,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( GUID_DirectDrawSurfaceStream,      0xe043bc46,0x5317,0x11d1,0x8c,0x4d,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( GUID_DirectDrawPaletteStream,      0x730c7ffc,0x5347,0x11d1,0x8c,0x4d,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID(IID_IDirectDrawOptSurface,          0x51191f1e, 0x4f2b, 0x11d1, 0x8c, 0xc3, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( IID_IDirectDrawPalette2,           0xc03c477e,0x6519,0x11d1,0x8c,0x52,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef STREAMING
DEFINE_GUID( IID_IDirectDrawSurfaceStreaming,   0x6C14DB82,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
#endif
#ifdef COMPOSITION
DEFINE_GUID( IID_IDirectDrawSurfaceComposition, 0x6C14DB83,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
#endif
//@@END_MSINTERNAL
DEFINE_GUID( IID_IDirectDrawPalette,            0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,            0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl,       0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
struct IDirectDrawSurfaceComposition;
#endif
#ifdef STREAMING
struct IDirectDrawSurfaceStreaming;
#endif
//@@END_MSINTERNAL
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDirectDraw              FAR *LPDIRECTDRAW;
typedef struct IDirectDraw2             FAR *LPDIRECTDRAW2;
typedef struct IDirectDraw4             FAR *LPDIRECTDRAW4;
typedef struct IDirectDraw7             FAR *LPDIRECTDRAW7;
typedef struct IDirectDrawSurface       FAR *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawSurface2      FAR *LPDIRECTDRAWSURFACE2;
typedef struct IDirectDrawSurface3      FAR *LPDIRECTDRAWSURFACE3;
typedef struct IDirectDrawSurface4      FAR *LPDIRECTDRAWSURFACE4;
typedef struct IDirectDrawSurface7      FAR *LPDIRECTDRAWSURFACE7;
//@@BEGIN_MSINTERNAL
typedef struct IDirectDrawFactory2      FAR *LPDIRECTDRAWFACTORY2;
typedef struct IDirectDrawOptSurface    FAR *LPDIRECTDRAWOPTSURFACE;
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
typedef struct IDirectDrawSurfaceComposition    FAR *LPDIRECTDRAWSURFACECOMPOSITION;
#endif
#ifdef STREAMING
typedef struct IDirectDrawSurfaceStreaming      FAR *LPDIRECTDRAWSURFACESTREAMING;
#endif
typedef struct IDirectDrawPalette2              FAR *LPDIRECTDRAWPALETTE2;
//@@END_MSINTERNAL
typedef struct IDirectDrawPalette               FAR *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper               FAR *LPDIRECTDRAWCLIPPER;
typedef struct IDirectDrawColorControl          FAR *LPDIRECTDRAWCOLORCONTROL;
typedef struct IDirectDrawGammaControl          FAR *LPDIRECTDRAWGAMMACONTROL;

typedef struct _DDFXROP                 FAR *LPDDFXROP;
typedef struct _DDSURFACEDESC           FAR *LPDDSURFACEDESC;
typedef struct _DDSURFACEDESC2          FAR *LPDDSURFACEDESC2;
//@@BEGIN_MSINTERNAL
typedef struct _DDOPTSURFACEDESC    FAR *LPDDOPTSURFACEDESC;
//@@END_MSINTERNAL
typedef struct _DDCOLORCONTROL          FAR *LPDDCOLORCONTROL;

/*
 * API's
 */
#if (defined (WIN32) || defined( _WIN32 ) ) && !defined( _NO_COM )
//#if defined( _WIN32 ) && !defined( _NO_ENUM )
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKA)(GUID FAR *, LPSTR, LPSTR, LPVOID);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID);
    extern HRESULT WINAPI DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
    extern HRESULT WINAPI DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
    /*
     * Protect against old SDKs
     */
    #if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
        #define HMONITOR_DECLARED
        DECLARE_HANDLE(HMONITOR);
    #endif
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXA)(GUID FAR *, LPSTR, LPSTR, LPVOID, HMONITOR);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID, HMONITOR);
    extern HRESULT WINAPI DirectDrawEnumerateExW( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);
    extern HRESULT WINAPI DirectDrawEnumerateExA( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXA)( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXW)( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);

    #ifdef UNICODE
        typedef LPDDENUMCALLBACKW           LPDDENUMCALLBACK;
        #define DirectDrawEnumerate         DirectDrawEnumerateW
        typedef LPDDENUMCALLBACKEXW         LPDDENUMCALLBACKEX;
        typedef LPDIRECTDRAWENUMERATEEXW        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx       DirectDrawEnumerateExW
    #else
        typedef LPDDENUMCALLBACKA           LPDDENUMCALLBACK;
        #define DirectDrawEnumerate         DirectDrawEnumerateA
        typedef LPDDENUMCALLBACKEXA         LPDDENUMCALLBACKEX;
        typedef LPDIRECTDRAWENUMERATEEXA        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx       DirectDrawEnumerateExA
    #endif
    extern HRESULT WINAPI DirectDrawCreate( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateEx( GUID FAR * lpGuid, LPVOID  *lplpDD, REFIID  iid,IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
#endif
/*
 * Flags for DirectDrawEnumerateEx
 * DirectDrawEnumerateEx supercedes DirectDrawEnumerate. You must use GetProcAddress to
 * obtain a function pointer (of type LPDIRECTDRAWENUMERATEEX) to DirectDrawEnumerateEx.
 * By default, only the primary display device is enumerated.
 * DirectDrawEnumerate is equivalent to DirectDrawEnumerate(,,DDENUM_NONDISPLAYDEVICES)
 */

/*
 * This flag causes enumeration of any GDI display devices which are part of
 * the Windows Desktop
 */
#define DDENUM_ATTACHEDSECONDARYDEVICES     0x00000001L

/*
 * This flag causes enumeration of any GDI display devices which are not
 * part of the Windows Desktop
 */
#define DDENUM_DETACHEDSECONDARYDEVICES     0x00000002L

/*
 * This flag causes enumeration of non-display devices
 */
#define DDENUM_NONDISPLAYDEVICES            0x00000004L

//@@BEGIN_MSINTERNAL
#define DDENUM_VALID                         0x00000007L
//@@END_MSINTERNAL

#define REGSTR_KEY_DDHW_DESCRIPTION     "Description"
#define REGSTR_KEY_DDHW_DRIVERNAME      "DriverName"
#define REGSTR_PATH_DDHW                "Hardware\\DirectDrawDrivers"

#define DDCREATE_HARDWAREONLY           0x00000001l
#define DDCREATE_EMULATIONONLY          0x00000002l

#if defined(WINNT) || !defined(WIN32)
typedef long HRESULT;
#endif

//#ifndef WINNT
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK2)(LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK2)(LPDIRECTDRAWSURFACE4, LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK7)(LPDIRECTDRAWSURFACE7, LPDDSURFACEDESC2, LPVOID);
//#endif

/*
 * Generic pixel format with 8-bit RGB and alpha components
 */
typedef struct _DDARGB
{
    BYTE blue;
    BYTE green;
    BYTE red;
    BYTE alpha;
} DDARGB;

typedef DDARGB FAR *LPDDARGB;

/*
 * This version of the structure remains for backwards source compatibility.
 * The DDARGB structure is the one that should be used for all DirectDraw APIs.
 */
typedef struct _DDRGBA
{
    BYTE red;
    BYTE green;
    BYTE blue;
    BYTE alpha;
} DDRGBA;

typedef DDRGBA FAR *LPDDRGBA;


/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD       dwColorSpaceLowValue;   // low boundary of color space that is to
                                        // be treated as Color Key, inclusive
    DWORD       dwColorSpaceHighValue;  // high boundary of color space that is
                                        // to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY FAR* LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwDDFX;                         // FX operations
    DWORD       dwROP;                          // Win32 raster operations
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw
    DWORD       dwRotationAngle;                // Rotation angle for blt
    DWORD       dwZBufferOpCode;                // ZBuffer compares
    DWORD       dwZBufferLow;                   // Low limit of Z buffer
    DWORD       dwZBufferHigh;                  // High limit of Z buffer
    DWORD       dwZBufferBaseDest;              // Destination base value
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination
    union
    {
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
        LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source
    union
    {
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
        LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src
    } DUMMYUNIONNAMEN(2);
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(3);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwFillColor;                    // color in RGB or Palettized
        DWORD   dwFillDepth;                    // depth value for z-buffer
        DWORD   dwFillPixel;                    // pixel value for RGBA or RGBZ
        LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern
    } DUMMYUNIONNAMEN(5);
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override
} DDBLTFX;

typedef DDBLTFX FAR* LPDDBLTFX;


//@@BEGIN_MSINTERNAL
/*
 * Structure used for lpDDAlphaBltFX arg to AlphaBlt API call
 */
typedef union _DDALPHABLTFX
{
    DDARGB ddargbScaleFactors;
    DWORD dwFillValue;

} DDALPHABLTFX;

typedef DDALPHABLTFX FAR* LPDDALPHABLTFX;


#ifdef COMPOSITION
/*
 * DDCOMPOSEFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Compose.
 */
typedef DWORD   (FAR PASCAL *LPCOMPOSECALLBACK)(DWORD);
typedef struct _DDCOMPOSEFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwDDFX;                         // FX operations
    DWORD       dwROP;                          // Win32 raster operations
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw
    DWORD       dwRotationAngle;                // Rotation angle for blt
    DWORD       dwZBufferOpCode;                // ZBuffer compares
    DWORD       dwZBufferLow;                   // Low limit of Z buffer
    DWORD       dwZBufferHigh;                  // High limit of Z buffer
    DWORD       dwZBufferBaseDest;              // Destination base value
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination
    union
    {
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
        LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source
    union
    {
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
        LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src
    } DUMMYUNIONNAMEN(2);
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(3);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwFillColor;                    // color in RGB or Palettized
        LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern
    } DUMMYUNIONNAMEN(5);
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override
    DWORD       dwRepeat;                       // how many times to repeat the composition command
    LPCOMPOSECALLBACK   lpfnCallback;           // function to call prior to execution of each compose command
} DDCOMPOSEFX;

typedef DDCOMPOSEFX FAR* LPDDCOMPOSEFX;
#endif
//@@END_MSINTERNAL

/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS FAR* LPDDSCAPS;


/*
 * DDOSCAPS
 */
typedef struct _DDOSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDOSCAPS;

typedef DDOSCAPS FAR* LPDDOSCAPS;

/*
 * This structure is used internally by DirectDraw.
//@@BEGIN_MSINTERNAL
 * Don't MSINTERNAL it: it's needed by ddrawi.h and drivers.
//@@END_MSINTERNAL
 */
typedef struct _DDSCAPSEX
{
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    union
    {
        DWORD       dwCaps4;
        DWORD       dwVolumeDepth;
    } DUMMYUNIONNAMEN(1);
} DDSCAPSEX, FAR * LPDDSCAPSEX;

/*
 * DDSCAPS2
 */
typedef struct _DDSCAPS2
{
    DWORD       dwCaps;         // capabilities of surface wanted
//@@BEGIN_MSINTERNAL
union
{
    struct
    {
//@@END_MSINTERNAL
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    union
    {
        DWORD       dwCaps4;
        DWORD       dwVolumeDepth;
    } DUMMYUNIONNAMEN(1);
//@@BEGIN_MSINTERNAL
    };
    DDSCAPSEX   ddsCapsEx;
};
//@@END_MSINTERNAL
} DDSCAPS2;

typedef DDSCAPS2 FAR* LPDDSCAPS2;

/*
 * DDCAPS
 */
#define DD_ROP_SPACE            (256/32)        // space required to store ROP array
/*
 * NOTE: Our choosen structure number scheme is to append a single digit to
 * the end of the structure giving the version that structure is associated
 * with.
 */

/*
 * This structure represents the DDCAPS structure released in DirectDraw 1.0.  It is used internally
 * by DirectDraw to interpret caps passed into ddraw by drivers written prior to the release of DirectDraw 2.0.
 * New applications should use the DDCAPS structure defined below.
 */
typedef struct _DDCAPS_DX1
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMinHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
} DDCAPS_DX1;

typedef DDCAPS_DX1 FAR* LPDDCAPS_DX1;

/*
 * This structure is the DDCAPS structure as it was in version 2 and 3 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX3
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwReserved4;            // reserved
    DWORD       dwReserved5;            // reserved
    DWORD       dwReserved6;            // reserved
} DDCAPS_DX3;
typedef DDCAPS_DX3 FAR* LPDDCAPS_DX3;

/*
 * This structure is the DDCAPS structure as it was in version 5 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX5
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsCaps;                // DDSCAPS structure has all the general capabilities
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
// Members added for DX5:
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DDCAPS_DX5;
typedef DDCAPS_DX5 FAR* LPDDCAPS_DX5;

typedef struct _DDCAPS_DX6
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha caps
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
} DDCAPS_DX6;
typedef DDCAPS_DX6 FAR* LPDDCAPS_DX6;

typedef struct _DDCAPS_DX7
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
/*170*/ DWORD   dwAlphaCaps;            // driver-specific alpha caps for overlays & Vmem->Vmem blts
/*174*/ DWORD   dwSVBAlphaCaps;         // driver-specific alpha capabilities for System->Vmem blts
/*178*/ DWORD   dwVSBAlphaCaps;         // driver-specific alpha capabilities for Vmem->System blts
/*17c*/ DWORD   dwSSBAlphaCaps;         // driver-specific alpha capabilities for System->System blts
/*180*/ DWORD   dwFilterCaps;           // driver-specific filter caps for overlays and Vmem->Vmem blts
/*184*/ DWORD   dwSVBFilterCaps;        // driver-specific filter capabilities for System->Vmem blts
/*188*/ DWORD   dwVSBFilterCaps;        // driver-specific filter capabilities for Vmem->System blts
/*18c*/ DWORD   dwSSBFilterCaps;        // driver-specific filter capabilities for System->System blts
/*190*/ DWORD   dwTransformCaps;        // driver-specific transform caps for overlays & Vmem->Vmem blts
/*194*/ DWORD   dwSVBTransformCaps;     // driver-specific transform capabilities for System->Vmem blts
/*198*/ DWORD   dwVSBTransformCaps;     // driver-specific transform capabilities for Vmem->System blts
/*19c*/ DWORD   dwSSBTransformCaps;     // driver-specific transform capabilities for System->System blts
/*1a0*/ DWORD   dwBltAffineMinifyLimit;   // minification limit for affine-transformed blts
/*1a4*/ DWORD   dwOverlayAffineMinifyLimit; // minification limit for affine-transformed overlays
#endif //POSTPONED2
//@@END_MSINTERNAL
} DDCAPS_DX7;
typedef DDCAPS_DX7 FAR* LPDDCAPS_DX7;


#if DIRECTDRAW_VERSION <= 0x300
    typedef DDCAPS_DX3 DDCAPS;
#elif DIRECTDRAW_VERSION <= 0x500
    typedef DDCAPS_DX5 DDCAPS;
#elif DIRECTDRAW_VERSION <= 0x600
    typedef DDCAPS_DX6 DDCAPS;
#else
    typedef DDCAPS_DX7 DDCAPS;
#endif

typedef DDCAPS FAR* LPDDCAPS;



/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
        DWORD   dwRGBBitCount;          // how many bits per pixel
        DWORD   dwYUVBitCount;          // how many bits per pixel
        DWORD   dwZBufferBitDepth;      // how many total bits/pixel in z buffer (including any stencil bits)
        DWORD   dwAlphaBitDepth;        // how many bits for alpha channels
        DWORD   dwLuminanceBitCount;    // how many bits per pixel
        DWORD   dwBumpBitCount;         // how many bits per "buxel", total
        DWORD   dwPrivateFormatBitCount;// Bits per pixel of private driver formats. Only valid in texture
                                        // format list and if DDPF_D3DFORMAT is set
    } DUMMYUNIONNAMEN(1);
    union
    {
        DWORD   dwRBitMask;             // mask for red bit
        DWORD   dwYBitMask;             // mask for Y bits
        DWORD   dwStencilBitDepth;      // how many stencil bits (note: dwZBufferBitDepth-dwStencilBitDepth is total Z-only bits)
        DWORD   dwLuminanceBitMask;     // mask for luminance bits
        DWORD   dwBumpDuBitMask;        // mask for bump map U delta bits
        DWORD   dwOperations;           // DDPF_D3DFORMAT Operations
    } DUMMYUNIONNAMEN(2);
    union
    {
        DWORD   dwGBitMask;             // mask for green bits
        DWORD   dwUBitMask;             // mask for U bits
        DWORD   dwZBitMask;             // mask for Z bits
        DWORD   dwBumpDvBitMask;        // mask for bump map V delta bits
        struct
        {
            WORD    wFlipMSTypes;       // Multisample methods supported via flip for this D3DFORMAT
            WORD    wBltMSTypes;        // Multisample methods supported via blt for this D3DFORMAT
        } MultiSampleCaps;

    } DUMMYUNIONNAMEN(3);
    union
    {
        DWORD   dwBBitMask;             // mask for blue bits
        DWORD   dwVBitMask;             // mask for V bits
        DWORD   dwStencilBitMask;       // mask for stencil bits
        DWORD   dwBumpLuminanceBitMask; // mask for luminance in bump map
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
        DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
        DWORD   dwLuminanceAlphaBitMask;// mask for alpha channel
        DWORD   dwRGBZBitMask;          // mask for Z channel
        DWORD   dwYUVZBitMask;          // mask for Z channel
    } DUMMYUNIONNAMEN(5);
} DDPIXELFORMAT;

typedef DDPIXELFORMAT FAR* LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Constant to use as alpha for edge blend
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as alpha channel for dest
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as alpha channel for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as alpha channel for src
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as alpha channel for src
    } DUMMYUNIONNAMEN(2);
    DDCOLORKEY  dckDestColorkey;                // DestColorkey override
    DDCOLORKEY  dckSrcColorkey;                 // DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD       dwFlags;                        // flags
} DDOVERLAYFX;

typedef DDOVERLAYFX FAR *LPDDOVERLAYFX;

//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
/*
 * DDSPRITEFX
 */
typedef struct _DDSPRITEFX
{
    DWORD       dwSize;               // sizeof(DDSPRITEFX)
    DWORD       dwDDFX;               // DDSPRITEFX_ (sprite FX) flags
    DDCOLORKEY  ddckDestColorkey;     // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;      // SrcColorkey override
    DDARGB      ddargbScaleFactors;   // Four 8-bit ARGB scaling factors
    float       fTransform[3][3];     // 3x3 transformation matrix
} DDSPRITEFX;

typedef DDSPRITEFX FAR *LPDDSPRITEFX;

/*
 * Structure that contains the information describing a sprite
 * in the display list that is passed to SetSpriteDisplayList().
 */
typedef struct _DDSPRITE {
    RECT        rcDest;             // destination rectangle
    LPDIRECTDRAWSURFACE7 lpDDSSrc;  // source surface
    RECT        rcSrc;              // source rectangle
    DWORD       dwFlags;            // DDSPRITE_ flags
    DWORD       dwReserved[2];      // reserved
    DDSPRITEFX  ddSpriteFX;         // sprite special FX
} DDSPRITE;

typedef DDSPRITE FAR *LPDDSPRITE;
#endif //POSTPONED2
//@@END_MSINTERNAL

/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT              lprDest;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPRECT              lprSrc;
    DWORD               dwFlags;
    LPDDBLTFX           lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH FAR * LPDDBLTBATCH;


/*
 * DDGAMMARAMP
 */
typedef struct _DDGAMMARAMP
{
    WORD                red[256];
    WORD                green[256];
    WORD                blue[256];
} DDGAMMARAMP;
typedef DDGAMMARAMP FAR * LPDDGAMMARAMP;

/*
 *  This is the structure within which DirectDraw returns data about the current graphics driver and chipset
 */

#define MAX_DDDEVICEID_STRING           512

typedef struct tagDDDEVICEIDENTIFIER
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[MAX_DDDEVICEID_STRING];
    char    szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
#ifdef _WIN32
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
#else
    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD   dwDriverVersionHighPart;
#endif


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;
} DDDEVICEIDENTIFIER, * LPDDDEVICEIDENTIFIER;

typedef struct tagDDDEVICEIDENTIFIER2
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[MAX_DDDEVICEID_STRING];
    char    szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
#ifdef _WIN32
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
#else
    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD   dwDriverVersionHighPart;
#endif


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;

    /*
     * This element is used to determine the Windows Hardware Quality Lab (WHQL)
     * certification level for this driver/device pair.
     */
    DWORD   dwWHQLLevel;

} DDDEVICEIDENTIFIER2, * LPDDDEVICEIDENTIFIER2;

/*
 * Flags for the IDirectDraw4::GetDeviceIdentifier method
 */

/*
 * This flag causes GetDeviceIdentifier to return information about the host (typically 2D) adapter in a system equipped
 * with a stacked secondary 3D adapter. Such an adapter appears to the application as if it were part of the
 * host adapter, but is typically physcially located on a separate card. The stacked secondary's information is
 * returned when GetDeviceIdentifier's dwFlags field is zero, since this most accurately reflects the qualities
 * of the DirectDraw object involved.
 */
#define DDGDI_GETHOSTIDENTIFIER         0x00000001L

//@@BEGIN_MSINTERNAL
#define DDGDI_VALID                     0x00000001L
//@@END_MSINTERNAL
/*
 * Macros for interpretting DDEVICEIDENTIFIER2.dwWHQLLevel
 */
#define GET_WHQL_YEAR( dwWHQLLevel ) \
    ( (dwWHQLLevel) / 0x10000 )
#define GET_WHQL_MONTH( dwWHQLLevel ) \
    ( ( (dwWHQLLevel) / 0x100 ) & 0x00ff )
#define GET_WHQL_DAY( dwWHQLLevel ) \
    ( (dwWHQLLevel) & 0xff )


/*
 * callbacks
 */
typedef DWORD   (FAR PASCAL *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
#ifdef STREAMING
typedef DWORD   (FAR PASCAL *LPSURFACESTREAMINGCALLBACK)(DWORD);
#endif

//@@BEGIN_MSINTERNAL
#ifdef CLIPPER_NOTIFY
/*
 * values passed into the clipper callback
 */
#ifndef WINWATCHNOTIFY_START
    #define WINWATCHNOTIFY_START        0
    #define WINWATCHNOTIFY_STOP         1
    #define WINWATCHNOTIFY_DESTROY      2
    #define WINWATCHNOTIFY_CHANGING     3
    #define WINWATCHNOTIFY_CHANGED      4
#endif
#endif
//@@END_MSINTERNAL

/*
 * INTERACES FOLLOW:
 *      IDirectDraw
 *      IDirectDrawClipper
 *      IDirectDrawPalette
 *      IDirectDrawSurface
 *@@BEGIN_MSINTERNAL
 *      IDirectDrawSurfaceStreaming
 *      IDirectDrawSurfaceComposition
 *      IDirectDrawSurfaceClipperEx
 *              // this would allow multiple clipper objects to be attached
 *              // to the same destination
 *@@END_MSINTERNAL
 */

/*
 * IDirectDraw
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw
DECLARE_INTERFACE_( IDirectDraw, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->lpVtbl->SetDisplayMode(p, a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#else
#define IDirectDraw_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw_AddRef(p)                       (p)->AddRef()
#define IDirectDraw_Release(p)                      (p)->Release()
#define IDirectDraw_Compact(p)                      (p)->Compact()
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->SetDisplayMode(a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw2
DECLARE_INTERFACE_( IDirectDraw2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw2_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw2_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw2_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw2_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw2_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#else
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw2_AddRef(p)                       (p)->AddRef()
#define IDirectDraw2_Release(p)                      (p)->Release()
#define IDirectDraw2_Compact(p)                      (p)->Compact()
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw2_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw2_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw4
DECLARE_INTERFACE_( IDirectDraw4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE4 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK2 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER, DWORD ) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw4_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw4_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw4_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw4_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw4_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
#else
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw4_AddRef(p)                       (p)->AddRef()
#define IDirectDraw4_Release(p)                      (p)->Release()
#define IDirectDraw4_Compact(p)                      (p)->Compact()
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw4_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw4_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw7
DECLARE_INTERFACE_( IDirectDraw7, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE7 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE7, LPDIRECTDRAWSURFACE7 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK7 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE7 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER2, DWORD ) PURE;
    STDMETHOD(StartModeTest)(THIS_ LPSIZE, DWORD, DWORD ) PURE;
    STDMETHOD(EvaluateMode)(THIS_ DWORD, DWORD * ) PURE;
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED
    STDMETHOD(CreateSurfaceFromStream) (THIS_ IStream *, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE7 *, IUnknown *) PURE;
    STDMETHOD(CreateSurfaceFromFile) (THIS_ BSTR , LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE7 *, IUnknown *) PURE;
#endif
//@@END_MSINTERNAL
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw7_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw7_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw7_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw7_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw7_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw7_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw7_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw7_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw7_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw7_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw7_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw7_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw7_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw7_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw7_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw7_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw7_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw7_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw7_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw7_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw7_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw7_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw7_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw7_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw7_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw7_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw7_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirectDraw7_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
#define IDirectDraw7_StartModeTest(p,a,b,c)        (p)->lpVtbl->StartModeTest(p,a,b,c)
#define IDirectDraw7_EvaluateMode(p,a,b)           (p)->lpVtbl->EvaluateMode(p,a,b)
//@@BEGIN_MSINTERNAL
#define IDirectDraw7_CreateSurfaceFromStream(p, a, b, c, d, e) (p)->lpVtbl->CreateSurfaceFromStream(p, a, b, c, d, e)
#define IDirectDraw7_CreateSurfaceFromFile(p, a, b, c, d, e) (p)->lpVtbl->CreateSurfaceFromFile(p, a, b, c, d, e)
//@@END_MSINTERNAL
#else
#define IDirectDraw7_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw7_AddRef(p)                       (p)->AddRef()
#define IDirectDraw7_Release(p)                      (p)->Release()
#define IDirectDraw7_Compact(p)                      (p)->Compact()
#define IDirectDraw7_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw7_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw7_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw7_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw7_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw7_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw7_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw7_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw7_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw7_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw7_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw7_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw7_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw7_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw7_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw7_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw7_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw7_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw7_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw7_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw7_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw7_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw7_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#define IDirectDraw7_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
#define IDirectDraw7_StartModeTest(p,a,b,c)        (p)->lpVtbl->StartModeTest(a,b,c)
#define IDirectDraw7_EvaluateMode(p,a,b)           (p)->lpVtbl->EvaluateMode(a,b)
//@@BEGIN_MSINTERNAL
#define IDirectDraw7_CreateSurfaceFromStream(p, a, b, c, d, e) (p)->CreateSurfaceFromStream(a, b, c, d, e)
#define IDirectDraw7_CreateSurfaceFromFile(p, a, b, c, d, e) (p)->CreateSurfaceFromFile(a, b, c, d, e)
//@@END_MSINTERNAL
#endif

#endif

//@@BEGIN_MSINTERNAL

/*
 * IDirectDrawFactory2
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawFactory2
DECLARE_INTERFACE_( IDirectDrawFactory2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawFactory2 methods ***/
    STDMETHOD(CreateDirectDraw) (THIS_ GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, IUnknown *pUnkOuter, struct IDirectDraw4 **ppDirectDraw) PURE;
#ifdef SM_CMONITORS
    STDMETHOD(DirectDrawEnumerate) (THIS_ LPDDENUMCALLBACKEX , LPVOID , DWORD ) PURE;
#else
    STDMETHOD(DirectDrawEnumerate) (THIS_ LPDDENUMCALLBACK , LPVOID , DWORD ) PURE;
#endif
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)                     (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                                   (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                                  (p)->lpVtbl->Release(p)
#define IDirectDraw_CreateDirectDraw(p, a, b, c, d, e, f)       (p)->lpVtbl->CreateDirectDraw(p, a, b, c, d, e, f)
#define IDirectDraw_DirectDrawEnumerate(p, a, b, c)             (p)->lpVtbl->DirectDrawEnumerate(p, a, b, c)
#else
#define IDirectDraw_QueryInterface(p, a, b)                     (p)->QueryInterface(a, b)
#define IDirectDraw_AddRef(p)                                   (p)->AddRef()
#define IDirectDraw_Release(p)                                  (p)->Release()
#define IDirectDraw_CreateDirectDraw(p, a, b, c, d, e, f)       (p)->CreateDirectDraw(a, b, c, d, e, f)
#define IDirectDraw_DirectDrawEnumerate(p, a, b, c)             (p)->DirectDrawEnumerate(a, b, c)
#endif

#endif
//@@END_MSINTERNAL

/*
 * IDirectDrawPalette
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette
DECLARE_INTERFACE_( IDirectDrawPalette, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#else
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->QueryInterface(a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->AddRef()
#define IDirectDrawPalette_Release(p)                   (p)->Release()
#define IDirectDrawPalette_GetCaps(p, a)                (p)->GetCaps(a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->GetEntries(a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->Initialize(a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->SetEntries(a, b, c, d)
#endif

#endif

//@@BEGIN_MSINTERNAL
/*
 * IDirectDrawPalette2
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette2
DECLARE_INTERFACE_( IDirectDrawPalette2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    /*** IDirectDrawPalette2 methods ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
    STDMETHOD(IsEqual)(THIS_ LPDIRECTDRAWPALETTE2) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette2_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette2_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette2_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette2_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette2_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#define IDirectDrawPalette2_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p, a, b, c, d)
#define IDirectDrawPalette2_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p, a, b, c)
#define IDirectDrawPalette2_FreePrivateData(p, a)        (p)->lpVtbl->FreePrivateData(p, a)
#define IDirectDrawPalette2_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawPalette2_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#define IDirectDrawPalette2_IsEqual(p, a)                (p)->lpVtbl->IsEqual(p, a)
#else
#define IDirectDrawPalette2_QueryInterface(p, a, b)      (p)->QueryInterface(a, b)
#define IDirectDrawPalette2_AddRef(p)                    (p)->AddRef()
#define IDirectDrawPalette2_Release(p)                   (p)->Release()
#define IDirectDrawPalette2_GetCaps(p, a)                (p)->GetCaps(a)
#define IDirectDrawPalette2_GetEntries(p, a, b, c, d)    (p)->GetEntries(a, b, c, d)
#define IDirectDrawPalette2_Initialize(p, a, b, c)       (p)->Initialize(a, b, c)
#define IDirectDrawPalette2_SetEntries(p, a, b, c, d)    (p)->SetEntries(a, b, c, d)
#define IDirectDrawPalette2_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a, b, c, d)
#define IDirectDrawPalette2_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a, b, c)
#define IDirectDrawPalette2_FreePrivateData(p, a)        (p)->FreePrivateData(a)
#define IDirectDrawPalette2_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawPalette2_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#define IDirectDrawPalette2_IsEqual(p, a)                (p)->IsEqual(a)
#endif

#endif
//@@END_MSINTERNAL


/*
 * IDirectDrawClipper
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawClipper
DECLARE_INTERFACE_( IDirectDrawClipper, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawClipper methods ***/
    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
    STDMETHOD(GetHWnd)(THIS_ HWND FAR *) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD) PURE;
    STDMETHOD(IsClipListChanged)(THIS_ BOOL FAR *) PURE;
    STDMETHOD(SetClipList)(THIS_ LPRGNDATA,DWORD) PURE;
    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawClipper_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->lpVtbl->GetClipList(p, a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->lpVtbl->GetHWnd(p, a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->lpVtbl->Initialize(p, a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->lpVtbl->IsClipListChanged(p, a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->lpVtbl->SetClipList(p, a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->lpVtbl->SetHWnd(p, a, b)
#else
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->AddRef()
#define IDirectDrawClipper_Release(p)               (p)->Release()
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->GetClipList(a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->GetHWnd(a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->Initialize(a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->IsClipListChanged(a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->SetClipList(a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->SetHWnd(a, b)
#endif

#endif

/*
 * IDirectDrawSurface and related interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurface
DECLARE_INTERFACE_( IDirectDrawSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#else
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface_Release(p)                   (p)->Release()
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#endif

/*
 * IDirectDrawSurface2 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface2
DECLARE_INTERFACE_( IDirectDrawSurface2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE2, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE2) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface2_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#else
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface2_Release(p)                   (p)->Release()
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface2_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->PageUnlock(a)
#endif

/*
 * IDirectDrawSurface3 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the V3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface3_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface3_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface3_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface3_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#else
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface3_Release(p)                   (p)->Release()
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface3_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface3_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface3_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#endif

/*
 * IDirectDrawSurface4 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface4
DECLARE_INTERFACE_( IDirectDrawSurface4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE4, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE4, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE4, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE4,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE4) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface4_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface4_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface4_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface4_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)         (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#else
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface4_Release(p)                   (p)->Release()
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface4_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface4_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface4_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)         (p)->FreePrivateData(a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#endif

/*
 * IDirectDrawSurface7 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface7
DECLARE_INTERFACE_( IDirectDrawSurface7, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE7, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE7, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK7) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK7) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE7, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE7 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE7,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE7) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
    STDMETHOD(AlphaBlt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE7,LPRECT,DWORD,LPDDALPHABLTFX) PURE;
    STDMETHOD(SetSpriteDisplayList)(THIS_ LPDDSPRITE *,DWORD,DWORD,LPDIRECTDRAWSURFACE7,DWORD) PURE;
    STDMETHOD(Resize)(THIS_ DWORD,DWORD,DWORD) PURE;
#endif //POSTPONED2
//@@END_MSINTERNAL
    /*** Moved Texture7 methods here ***/
    STDMETHOD(SetPriority)(THIS_ DWORD) PURE;
    STDMETHOD(GetPriority)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetLOD)(THIS_ DWORD) PURE;
    STDMETHOD(GetLOD)(THIS_ LPDWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface7_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface7_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface7_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface7_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface7_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface7_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface7_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface7_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface7_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface7_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface7_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface7_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface7_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface7_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface7_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface7_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface7_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface7_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface7_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface7_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface7_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface7_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface7_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface7_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface7_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface7_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface7_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface7_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface7_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface7_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface7_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface7_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface7_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface7_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface7_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface7_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface7_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface7_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface7_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface7_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface7_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface7_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface7_FreePrivateData(p,a)         (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface7_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface7_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
#define IDirectDrawSurface7_AlphaBlt(p,a,b,c,d,e)        (p)->lpVtbl->AlphaBlt(p,a,b,c,d,e)
#define IDirectDrawSurface7_SetSpriteDisplayList(p,a,b,c,d,e)  (p)->lpVtbl->SetSpriteDisplayList(p,a,b,c,d,e)
#define IDirectDrawSurface7_Resize(p,a,b,c)              (p)->lpVtbl->Resize(p,a,b,c)
#endif //POSTPONED2
//@@END_MSINTERNAL
#define IDirectDrawSurface7_SetPriority(p,a)             (p)->lpVtbl->SetPriority(p,a)
#define IDirectDrawSurface7_GetPriority(p,a)             (p)->lpVtbl->GetPriority(p,a)
#define IDirectDrawSurface7_SetLOD(p,a)                  (p)->lpVtbl->SetLOD(p,a)
#define IDirectDrawSurface7_GetLOD(p,a)                  (p)->lpVtbl->GetLOD(p,a)
#else
#define IDirectDrawSurface7_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface7_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface7_Release(p)                   (p)->Release()
#define IDirectDrawSurface7_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface7_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface7_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface7_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface7_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface7_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface7_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface7_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface7_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface7_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface7_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface7_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface7_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface7_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface7_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface7_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface7_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface7_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface7_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface7_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface7_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface7_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface7_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface7_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface7_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface7_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface7_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface7_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface7_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface7_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface7_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface7_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface7_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface7_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface7_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface7_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface7_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface7_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface7_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface7_FreePrivateData(p,a)         (p)->FreePrivateData(a)
#define IDirectDrawSurface7_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface7_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
#define IDirectDrawSurface7_AlphaBlt(p,a,b,c,d,e)        (p)->AlphaBlt(a,b,c,d,e)
#define IDirectDrawSurface7_SetSpriteDisplayList(p,a,b,c,d,e)  (p)->SetSpriteDisplayList(a,b,c,d,e)
#define IDirectDrawSurface7_Resize(p,a,b,c)              (p)->Resize(a,b,c)
#endif //POSTPONED2
//@@END_MSINTERNAL
#define IDirectDrawSurface7_SetPriority(p,a)             (p)->SetPriority(a)
#define IDirectDrawSurface7_GetPriority(p,a)             (p)->GetPriority(a)
#define IDirectDrawSurface7_SetLOD(p,a)                  (p)->SetLOD(a)
#define IDirectDrawSurface7_GetLOD(p,a)                  (p)->GetLOD(a)
#endif

//@@BEGIN_MSINTERNAL
/*
 * IDirectDrawOptSurface
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawOptSurface
DECLARE_INTERFACE_( IDirectDrawOptSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawOptSurface methods ***/
    STDMETHOD(GetOptSurfaceDesc)(THIS_ LPDDOPTSURFACEDESC) PURE;
    STDMETHOD(LoadUnoptimizedSurf)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(CopyOptimizedSurf)(THIS_ LPDIRECTDRAWOPTSURFACE) PURE;
    STDMETHOD(Unoptimize)(THIS_ LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE4, IUnknown FAR *) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawOptSurface_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawOptSurface_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawOptSurface_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawOptSurface_GetOptSurfaceDesc(p,a)   (p)->lpVtbl->GetOptSurfaceDesc(p,a)
#define IDirectDrawOptSurface_LoadUnoptimizedSurf(p,a) (p)->lpVtbl->LoadUnoptimizedSurf(p,a)
#define IDirectDrawOptSurface_CopyOptimizedSurf(p,a)   (p)->lpVtbl->CopyOptimizedSurf(p,a)
#define IDirectDrawOptSurface_Unoptimize(p,a,b)        (p)->lpVtbl->Unoptimize(p,a,b)
#else  //!defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawOptSurface_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawOptSurface_AddRef(p)                (p)->AddRef()
#define IDirectDrawOptSurface_Release(p)               (p)->Release()
#define IDirectDrawOptSurface_GetOptSurfaceDesc(p,a)   (p)->GetOptSurfaceDesc(a)
#define IDirectDrawOptSurface_LoadUnoptimizedSurf(p,a) (p)->LoadUnoptimizedSurf(a)
#define IDirectDrawOptSurface_CopyOptimizedSurf(p,a)   (p)->CopyOptimizedSurf(p,a)
#define IDirectDrawOptSurface_Unoptimize(p,a,b)        (p)->Unoptimize(a,b)
#endif //!defined(__cplusplus) || defined(CINTERFACE)

#endif //defined( _WIN32 ) && !defined( _NO_COM )
//@@END_MSINTERNAL


/*
 * IDirectDrawColorControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawColorControl
DECLARE_INTERFACE_( IDirectDrawColorControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawColorControl methods ***/
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawColorControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->lpVtbl->GetColorControls(p, a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->lpVtbl->SetColorControls(p, a)
#else
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawColorControl_Release(p)               (p)->Release()
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->GetColorControls(a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->SetColorControls(a)
#endif

#endif


/*
 * IDirectDrawGammaControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawGammaControl
DECLARE_INTERFACE_( IDirectDrawGammaControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawGammaControl methods ***/
    STDMETHOD(GetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
    STDMETHOD(SetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawGammaControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->lpVtbl->GetGammaRamp(p, a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->lpVtbl->SetGammaRamp(p, a, b)
#else
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawGammaControl_Release(p)               (p)->Release()
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->GetGammaRamp(a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->SetGammaRamp(a, b)
#endif

#endif


//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceComposition
DECLARE_INTERFACE_( IDirectDrawSurfaceComposition, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurfaceComposition methods ***/
    STDMETHOD(AddSurfaceDependency)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(Compose)(THIS_ LPRECT,LPDIRECTDRAWSURFACE,LPRECT,DWORD,LPDDCOMPOSEFX) PURE;
    STDMETHOD(DeleteSurfaceDependency)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(DestLock)(THIS) PURE;
    STDMETHOD(DestUnlock)(THIS) PURE;
    STDMETHOD(EnumSurfaceDependencies)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(GetCompositionOrder)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetCompositionOrder)(THIS_ DWORD) PURE;
};
#endif

#ifdef STREAMING
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceStreaming
DECLARE_INTERFACE_( IDirectDrawSurfaceStreaming, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurfaceStreaming methods ***/
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(SetNotificationCallback)(THIS_ DWORD,LPSURFACESTREAMINGCALLBACK) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
};
#endif
//@@END_MSINTERNAL

#endif

//@@BEGIN_MSINTERNAL
#ifdef CLIPPER_NOTIFY
/*
 * DIRECTDRAWCLIPPER FLAGS
 */
#define DDCLIPPER_WATCHWINDOW   0x00000001l
#endif
//@@END_MSINTERNAL

/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    union
    {
        LONG            lPitch;                 // distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    DWORD               dwBackBufferCount;      // number of back buffers requested
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requested
        DWORD           dwZBufferBitDepth;      // depth of Z buffer requested
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
    } DUMMYUNIONNAMEN(2);
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
    DWORD               dwCompositionOrder;     // blt order for the surface, 0 is background
#else
//@@END_MSINTERNAL
    DWORD               dwReserved;             // reserved
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
    LPVOID              lpSurface;              // pointer to the associated surface memory
    DDCOLORKEY          ddckCKDestOverlay;      // color key for destination overlay use
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    DDPIXELFORMAT       ddpfPixelFormat;        // pixel format description of the surface
    DDSCAPS             ddsCaps;                // direct draw surface capabilities
} DDSURFACEDESC;

/*
 * DDSURFACEDESC2
 */
typedef struct _DDSURFACEDESC2
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    union
    {
        LONG            lPitch;                 // distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    union
    {
        DWORD           dwBackBufferCount;      // number of back buffers requested
        DWORD           dwDepth;                // the depth if this is a volume texture 
    } DUMMYUNIONNAMEN(5);
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requestde
                                                // dwZBufferBitDepth removed, use ddpfPixelFormat one instead
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
        DWORD           dwSrcVBHandle;          // The source used in VB::Optimize
    } DUMMYUNIONNAMEN(2);
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
    DWORD               dwCompositionOrder;     // blt order for the surface, 0 is background
#else
//@@END_MSINTERNAL
    DWORD               dwReserved;             // reserved
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
    LPVOID              lpSurface;              // pointer to the associated surface memory
    union
    {
        DDCOLORKEY      ddckCKDestOverlay;      // color key for destination overlay use
        DWORD           dwEmptyFaceColor;       // Physical color for empty cubemap faces
    } DUMMYUNIONNAMEN(3);
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    union
    {
        DDPIXELFORMAT   ddpfPixelFormat;        // pixel format description of the surface
        DWORD           dwFVF;                  // vertex format description of vertex buffers
    } DUMMYUNIONNAMEN(4);
    DDSCAPS2            ddsCaps;                // direct draw surface capabilities
    DWORD               dwTextureStage;         // stage in multitexture cascade
} DDSURFACEDESC2;

/*
 * ddsCaps field is valid.
 */
#define DDSD_CAPS               0x00000001l     // default

/*
 * dwHeight field is valid.
 */
#define DDSD_HEIGHT             0x00000002l

/*
 * dwWidth field is valid.
 */
#define DDSD_WIDTH              0x00000004l

/*
 * lPitch is valid.
 */
#define DDSD_PITCH              0x00000008l

/*
 * dwBackBufferCount is valid.
 */
#define DDSD_BACKBUFFERCOUNT    0x00000020l

/*
 * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
 */
#define DDSD_ZBUFFERBITDEPTH    0x00000040l

/*
 * dwAlphaBitDepth is valid.
 */
#define DDSD_ALPHABITDEPTH      0x00000080l

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
/*
 * dwCompositionOrder is valid.
 */
#define DDSD_COMPOSITIONORDER   0x00000100l
#endif
//@@END_MSINTERNAL

/*
 * lpSurface is valid.
 */
#define DDSD_LPSURFACE          0x00000800l

/*
 * ddpfPixelFormat is valid.
 */
#define DDSD_PIXELFORMAT        0x00001000l

/*
 * ddckCKDestOverlay is valid.
 */
#define DDSD_CKDESTOVERLAY      0x00002000l

/*
 * ddckCKDestBlt is valid.
 */
#define DDSD_CKDESTBLT          0x00004000l

/*
 * ddckCKSrcOverlay is valid.
 */
#define DDSD_CKSRCOVERLAY       0x00008000l

/*
 * ddckCKSrcBlt is valid.
 */
#define DDSD_CKSRCBLT           0x00010000l

/*
 * dwMipMapCount is valid.
 */
#define DDSD_MIPMAPCOUNT        0x00020000l

 /*
  * dwRefreshRate is valid
  */
#define DDSD_REFRESHRATE        0x00040000l

/*
 * dwLinearSize is valid
 */
#define DDSD_LINEARSIZE         0x00080000l

/*
 * dwTextureStage is valid
 */
#define DDSD_TEXTURESTAGE       0x00100000l
/*
 * dwFVF is valid
 */
#define DDSD_FVF                0x00200000l
/*
 * dwSrcVBHandle is valid
 */
#define DDSD_SRCVBHANDLE        0x00400000l

/*
 * dwDepth is valid
 */
#define DDSD_DEPTH              0x00800000l

/*
 * All input fields are valid.
 */
#define DDSD_ALL                0x00fff9eel

/*
 * DDOPTSURFACEDESC
 */
typedef struct _DDOPTSURFACEDESC
{
    DWORD       dwSize;             // size of the DDOPTSURFACEDESC structure
    DWORD       dwFlags;            // determines what fields are valid
    DDSCAPS2    ddSCaps;            // Common caps like: Memory type
    DDOSCAPS    ddOSCaps;           // Common caps like: Memory type
    GUID        guid;               // Compression technique GUID
    DWORD       dwCompressionRatio; // Compression ratio
} DDOPTSURFACEDESC;

/*
 * guid field is valid.
 */
#define DDOSD_GUID                  0x00000001l

/*
 * dwCompressionRatio field is valid.
 */
#define DDOSD_COMPRESSION_RATIO     0x00000002l

/*
 * ddSCaps field is valid.
 */
#define DDOSD_SCAPS                 0x00000004l

/*
 * ddOSCaps field is valid.
 */
#define DDOSD_OSCAPS                0x00000008l

/*
 * All input fields are valid.
 */
#define DDOSD_ALL                   0x0000000fl

/*
 * The surface's optimized pixelformat is compressed
 */
#define DDOSDCAPS_OPTCOMPRESSED                 0x00000001l

/*
 * The surface's optimized pixelformat is reordered
 */
#define DDOSDCAPS_OPTREORDERED                  0x00000002l

/*
 * The opt surface is a monolithic mipmap
 */
#define DDOSDCAPS_MONOLITHICMIPMAP              0x00000004l

/*
 * The valid Surf caps:
 * #define DDSCAPS_SYSTEMMEMORY                 0x00000800l
 * #define DDSCAPS_VIDEOMEMORY          0x00004000l
 * #define DDSCAPS_LOCALVIDMEM          0x10000000l
 * #define DDSCAPS_NONLOCALVIDMEM       0x20000000l
 */
#define DDOSDCAPS_VALIDSCAPS            0x30004800l

/*
 * The valid OptSurf caps
 */
#define DDOSDCAPS_VALIDOSCAPS           0x00000007l


/*
 * DDCOLORCONTROL
 */
typedef struct _DDCOLORCONTROL
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LONG                lBrightness;
    LONG                lContrast;
    LONG                lHue;
    LONG                lSaturation;
    LONG                lSharpness;
    LONG                lGamma;
    LONG                lColorEnable;
    DWORD               dwReserved1;
} DDCOLORCONTROL;


/*
 * lBrightness field is valid.
 */
#define DDCOLOR_BRIGHTNESS              0x00000001l

/*
 * lContrast field is valid.
 */
#define DDCOLOR_CONTRAST                0x00000002l

/*
 * lHue field is valid.
 */
#define DDCOLOR_HUE                     0x00000004l

/*
 * lSaturation field is valid.
 */
#define DDCOLOR_SATURATION              0x00000008l

/*
 * lSharpness field is valid.
 */
#define DDCOLOR_SHARPNESS               0x00000010l

/*
 * lGamma field is valid.
 */
#define DDCOLOR_GAMMA                   0x00000020l

/*
 * lColorEnable field is valid.
 */
#define DDCOLOR_COLORENABLE             0x00000040l


//@@BEGIN_MSINTERNAL
/*
 * DDMODEDESC
 */
typedef struct _DDMODEDESC
{
    DWORD               dwSize;                 // size of structure
    DWORD               dwFlags;                // enumeration flags
    DWORD               dwMonitorFrequency;     // frequency of monitor in mode
    DDSURFACEDESC       ddsdSurfaceDesc;        // surface being enumerated
} DDMODEDESC;

typedef DDMODEDESC FAR* LPDDMODEDESC;
//@@END_MSINTERNAL

/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * This bit is reserved. It should not be specified.
 */
//@@BEGIN_MSINTERNAL
/*
 * In a previous life this bit used to be DDSCAPS_3D. This is now very
 * obsolete.
 */
//@@END_MSINTERNAL
#define DDSCAPS_RESERVED1                       0x00000001l

/*
 * Indicates that this surface contains alpha-only information.
 * (To determine if a surface is RGBA/YUVA, the pixel format must be
 * interrogated.)
 */
#define DDSCAPS_ALPHA                           0x00000002l

/*
 * Indicates that this surface is a backbuffer.  It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.  DirectDraw supports N surfaces in a
 * surface flipping structure.  Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */
#define DDSCAPS_BACKBUFFER                      0x00000004l

/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.  The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */
#define DDSCAPS_COMPLEX                         0x00000008l

/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.  They are set by CreateSurface
 * on the resulting creations.  The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */
#define DDSCAPS_FLIP                            0x00000010l

/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.  This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */
#define DDSCAPS_FRONTBUFFER                     0x00000020l

/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */
#define DDSCAPS_OFFSCREENPLAIN                  0x00000040l

/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
 * overlayed at the moment.
 */
#define DDSCAPS_OVERLAY                         0x00000080l

/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */
#define DDSCAPS_PALETTE                         0x00000100l

/*
 * Indicates that this surface is the primary surface.  The primary
 * surface represents what the user is seeing at the moment.
 */
#define DDSCAPS_PRIMARYSURFACE                  0x00000200l

//@@BEGIN_MSINTERNAL
/*
 * Indicates that this surface is the primary surface for the left eye.
 * The primary surface for the left eye represents what the user is seeing
 * at the moment with the users left eye.  When this surface is created the
 * DDSCAPS_PRIMARYSURFACE represents what the user is seeing with the users
 * right eye.
 */
#define DDSCAPS_PRIMARYSURFACELEFT              0x00000400l
//the zero-def'n is just to fix build issues... could be deleted when all dependencies are deleted (gdi kdexts may be only one)
//@@END_MSINTERNAL

/*
 * This flag used to be DDSCAPS_PRIMARYSURFACELEFT, which is now
 * obsolete.
 */
#define DDSCAPS_RESERVED3               0x00000400l
//@@BEGIN_MSINTERNAL
#if 0
//@@END_MSINTERNAL
#define DDSCAPS_PRIMARYSURFACELEFT              0x00000000l
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL

/*
 * Indicates that this surface memory was allocated in system memory
 */
#define DDSCAPS_SYSTEMMEMORY                    0x00000800l

/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */
#define DDSCAPS_TEXTURE                         0x00001000l

/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface
 * from this surface.
 */
#define DDSCAPS_3DDEVICE                        0x00002000l

/*
 * Indicates that this surface exists in video memory.
 */
#define DDSCAPS_VIDEOMEMORY                     0x00004000l

/*
 * Indicates that changes made to this surface are immediately visible.
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */
#define DDSCAPS_VISIBLE                         0x00008000l

/*
 * Indicates that only writes are permitted to the surface.  Read accesses
 * from the surface may or may not generate a protection fault, but the
 * results of a read from this surface will not be meaningful.  READ ONLY.
 */
#define DDSCAPS_WRITEONLY                       0x00010000l

/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured.
 */
#define DDSCAPS_ZBUFFER                         0x00020000l

/*
 * Indicates surface will have a DC associated long term
 */
#define DDSCAPS_OWNDC                           0x00040000l

/*
 * Indicates surface should be able to receive live video
 */
#define DDSCAPS_LIVEVIDEO                       0x00080000l

/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */
#define DDSCAPS_HWCODEC                         0x00100000l

/*
 * Surface is a ModeX surface.
 *
 */
#define DDSCAPS_MODEX                           0x00200000l

/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */
#define DDSCAPS_MIPMAP                          0x00400000l

/*
 * This bit is reserved. It should not be specified.
 */
//@@BEGIN_MSINTERNAL
/*
 * This bit is reserved for execute buffer surfaces. These surface are not
 * API visible and so this bit shows as reserved externally. However, driver
 * writers do need this bit so the correct definition of DDSCAPS_EXECUTEBUFFER
 * appears in ddraw.h.
 *
 * NOTE: Do not reassign this bit to a new surface capability. It is assigned
 * to an in-use cap: DDSCAPS_EXECUTEBUFFER
 */
//@@END_MSINTERNAL
#define DDSCAPS_RESERVED2                       0x00800000l

//@@BEGIN_MSINTERNAL
#ifdef SHAREDZ

/*
 * Indicates that this Z buffer surface can be shared with other DirectDraw
 * applications. This does not necessarily mean that this surface is
 * currently being shared with other processes but only that it can be. If
 * this bit is set then DDSCAPS_ZBUFFER must also be set.
 */
#define DDSCAPS_SHAREDZBUFFER                   0x01000000l

/*
 * Indicates that this backbuffer surface can be shared with other DirectDraw
 * applications. This does not necessarily mean that this surface is
 * currently being shared with other processes but only that it can be. If
 * this bit is set than DDSCAPS_BACKBUFFER must also be set (it may also be
 * set if a backbuffer is being created implicitly with as past of a complex
 * flippable chain).
 */
#define DDSCAPS_SHAREDBACKBUFFER                0x02000000l

#endif
//@@END_MSINTERNAL

/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */
#define DDSCAPS_ALLOCONLOAD                     0x04000000l

/*
 * Indicates that the surface will recieve data from a video port.
 */
#define DDSCAPS_VIDEOPORT                       0x08000000l

/*
 * Indicates that a video memory surface is resident in true, local video
 * memory rather than non-local video memory. If this flag is specified then
 * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_NONLOCALVIDMEM.
 */
#define DDSCAPS_LOCALVIDMEM                     0x10000000l

/*
 * Indicates that a video memory surface is resident in non-local video
 * memory rather than true, local video memory. If this flag is specified
 * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_LOCALVIDMEM.
 */
#define DDSCAPS_NONLOCALVIDMEM                  0x20000000l

/*
 * Indicates that this surface is a standard VGA mode surface, and not a
 * ModeX surface. (This flag will never be set in combination with the
 * DDSCAPS_MODEX flag).
 */
#define DDSCAPS_STANDARDVGAMODE                 0x40000000l

/*
 * Indicates that this surface will be an optimized surface. This flag is
 * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
 * will be created without any underlying video memory until loaded.
 */
#define DDSCAPS_OPTIMIZED                       0x80000000l


//@@BEGIN_MSINTERNAL
#ifdef SHAREDZ
#define DDSCAPS_VALID                           0xffffffffl
#else
#define DDSCAPS_VALID                           0xfcffffffl
#endif
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
/*
 * Indicates that this surface will not lose its contents when the physical
 * surface memory is lost. Upon restoring surface memory, contents will be
 * restored.
 */
#define DDSCAPS2_PERSISTENTCONTENTS             0x00000001L
//@@END_MSINTERNAL

/*
 * This bit is reserved
 */
#define DDSCAPS2_RESERVED4                      0x00000002L
#define DDSCAPS2_HARDWAREDEINTERLACE            0x00000000L

/*
 * Indicates to the driver that this surface will be locked very frequently
 * (for procedural textures, dynamic lightmaps, etc). Surfaces with this cap
 * set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTSTATIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTDYNAMIC                    0x00000004L

/*
 * Indicates to the driver that this surface can be re-ordered/retiled on
 * load. This operation will not change the size of the texture. It is
 * relatively fast and symmetrical, since the application may lock these
 * bits (although it will take a performance hit when doing so). Surfaces
 * with this cap set must also have DDSCAPS_TEXTURE. This cap cannot be
 * used with DDSCAPS2_HINTDYNAMIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTSTATIC                     0x00000008L

/*
 * Indicates that the client would like this texture surface to be managed by the
 * DirectDraw/Direct3D runtime. Surfaces with this cap set must also have
 * DDSCAPS_TEXTURE set.
 */
#define DDSCAPS2_TEXTUREMANAGE                  0x00000010L

/*
 * These bits are reserved for internal use */
#define DDSCAPS2_RESERVED1                      0x00000020L
#define DDSCAPS2_RESERVED2                      0x00000040L

/*
 * Indicates to the driver that this surface will never be locked again.
 * The driver is free to optimize this surface via retiling and actual compression.
 * All calls to Lock() or Blts from this surface will fail. Surfaces with this
 * cap set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTDYNAMIC and DDSCAPS2_HINTSTATIC.
 */
#define DDSCAPS2_OPAQUE                         0x00000080L

/*
 * Applications should set this bit at CreateSurface time to indicate that they
 * intend to use antialiasing. Only valid if DDSCAPS_3DDEVICE is also set.
 */
#define DDSCAPS2_HINTANTIALIASING               0x00000100L


/*
 * This flag is used at CreateSurface time to indicate that this set of
 * surfaces is a cubic environment map
 */
#define DDSCAPS2_CUBEMAP                        0x00000200L

/*
 * These flags preform two functions:
 * - At CreateSurface time, they define which of the six cube faces are
 *   required by the application.
 * - After creation, each face in the cubemap will have exactly one of these
 *   bits set.
 */
#define DDSCAPS2_CUBEMAP_POSITIVEX              0x00000400L
#define DDSCAPS2_CUBEMAP_NEGATIVEX              0x00000800L
#define DDSCAPS2_CUBEMAP_POSITIVEY              0x00001000L
#define DDSCAPS2_CUBEMAP_NEGATIVEY              0x00002000L
#define DDSCAPS2_CUBEMAP_POSITIVEZ              0x00004000L
#define DDSCAPS2_CUBEMAP_NEGATIVEZ              0x00008000L

/*
 * This macro may be used to specify all faces of a cube map at CreateSurface time
 */
#define DDSCAPS2_CUBEMAP_ALLFACES ( DDSCAPS2_CUBEMAP_POSITIVEX |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEX |\
                                    DDSCAPS2_CUBEMAP_POSITIVEY |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEY |\
                                    DDSCAPS2_CUBEMAP_POSITIVEZ |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEZ )


/*
 * This flag is an additional flag which is present on mipmap sublevels from DX7 onwards
 * It enables easier use of GetAttachedSurface rather than EnumAttachedSurfaces for surface
 * constructs such as Cube Maps, wherein there are more than one mipmap surface attached
 * to the root surface.
 * This caps bit is ignored by CreateSurface
 */
#define DDSCAPS2_MIPMAPSUBLEVEL                 0x00010000L

/* This flag indicates that the texture should be managed by D3D only */
#define DDSCAPS2_D3DTEXTUREMANAGE               0x00020000L

/* This flag indicates that the managed surface can be safely lost */
#define DDSCAPS2_DONOTPERSIST                   0x00040000L

/* indicates that this surface is part of a stereo flipping chain */
#define DDSCAPS2_STEREOSURFACELEFT              0x00080000L

//@@BEGIN_MSINTERNAL
/* Used to indicate that the texture manager is creating a videomemory
 * surface that shouldn't have an associated D3D texture object.
 */
#define DDSCAPS2_DONOTCREATED3DTEXOBJECT        0x00100000L
//@@END_MSINTERNAL

/*
 * Indicates that the surface is a volume.
 * Can be combined with DDSCAPS_MIPMAP to indicate a multi-level volume
 */
#define DDSCAPS2_VOLUME                         0x00200000L

/*
 * Indicates that the surface may be locked multiple times by the application.
 * This cap cannot be used with DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_NOTUSERLOCKABLE                0x00400000L

/*
 * Indicates that the vertex buffer data can be used to render points and
 * point sprites.
 */
#define DDSCAPS2_POINTS                         0x00800000L

/*
 * Indicates that the vertex buffer data can be used to render rt pactches.
 */
#define DDSCAPS2_RTPATCHES                      0x01000000L

/*
 * Indicates that the vertex buffer data can be used to render n patches.
 */
#define DDSCAPS2_NPATCHES                       0x02000000L

/*
 * This bit is reserved for internal use 
 */
#define DDSCAPS2_RESERVED3                      0x04000000L

//@@BEGIN_MSINTERNAL
/*
 * Indicates that the surface contains interlaced data that should be
 * deinterlaced when displayed.
 */
#define DDSCAPS2_DEINTERLACE                    0x08000000L
//@@END_MSINTERNAL

/*
 * Indicates that the contents of the backbuffer do not have to be preserved
 * the contents of the backbuffer after they are presented.
 */
#define DDSCAPS2_DISCARDBACKBUFFER              0x10000000L

/*
 * Indicates that all surfaces in this creation chain should be given an alpha channel.
 * This flag will be set on primary surface chains that may have no explicit pixel format
 * (and thus take on the format of the current display mode).
 * The driver should infer that all these surfaces have a format having an alpha channel.
 * (e.g. assume D3DFMT_A8R8G8B8 if the display mode is x888.)
 */
#define DDSCAPS2_ENABLEALPHACHANNEL             0x20000000L


/*
 * This is a mask that indicates the set of bits that may be set
 * at createsurface time to indicate number of samples per pixel
 * when multisampling
 */
#define DDSCAPS3_MULTISAMPLE_MASK               0x0000001FL

//@@BEGIN_MSINTERNAL
#define DDSCAPS2_VALID                          0x3ffffffeL
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#define DDSCAPS3_VALID                          DDSCAPS3_MULTISAMPLE_MASK
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#define DDSCAPS4_VALID                          0x00000000L
//@@END_MSINTERNAL

 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */
#define DDCAPS_3D                       0x00000001l

/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYDEST        0x00000002l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZEDEST            0x00000004l
/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYSRC         0x00000008l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZESRC             0x00000010l

/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */
#define DDCAPS_ALIGNSTRIDE              0x00000020l

/*
 * Display hardware is capable of blt operations.
 */
#define DDCAPS_BLT                      0x00000040l

/*
 * Display hardware is capable of asynchronous blt operations.
 */
#define DDCAPS_BLTQUEUE                 0x00000080l

/*
 * Display hardware is capable of color space conversions during the blt operation.
 */
#define DDCAPS_BLTFOURCC                0x00000100l

/*
 * Display hardware is capable of stretching during blt operations.
 */
#define DDCAPS_BLTSTRETCH               0x00000200l

/*
 * Display hardware is shared with GDI.
 */
#define DDCAPS_GDI                      0x00000400l

/*
 * Display hardware can overlay.
 */
#define DDCAPS_OVERLAY                  0x00000800l

/*
 * Set if display hardware supports overlays but can not clip them.
 */
#define DDCAPS_OVERLAYCANTCLIP          0x00001000l

/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */
#define DDCAPS_OVERLAYFOURCC            0x00002000l

/*
 * Indicates that stretching can be done by the overlay hardware.
 */
#define DDCAPS_OVERLAYSTRETCH           0x00004000l

/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */
#define DDCAPS_PALETTE                  0x00008000l

/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */
#define DDCAPS_PALETTEVSYNC             0x00010000l

/*
 * Display hardware can return the current scan line.
 */
#define DDCAPS_READSCANLINE             0x00020000l

//@@BEGIN_MSINTERNAL
/*
 * Display hardware has stereo vision capabilities.  DDSCAPS_PRIMARYSURFACELEFT
 * can be created.
 */
#define DDCAPS_STEREOVIEW               0x00040000l
//@@END_MSINTERNAL

/*
 * This flag used to bo DDCAPS_STEREOVIEW, which is now obsolete
 */
#define DDCAPS_RESERVED1                0x00040000l

/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */
#define DDCAPS_VBI                      0x00080000l

/*
 * Supports the use of z buffers with blt operations.
 */
#define DDCAPS_ZBLTS                    0x00100000l

/*
 * Supports Z Ordering of overlays.
 */
#define DDCAPS_ZOVERLAYS                0x00200000l

/*
 * Supports color key
 */
#define DDCAPS_COLORKEY                 0x00400000l

/*
 * Supports alpha surfaces
 */
#define DDCAPS_ALPHA                    0x00800000l

/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */
#define DDCAPS_COLORKEYHWASSIST         0x01000000l

/*
 * no hardware support at all
 */
#define DDCAPS_NOHARDWARE               0x02000000l

/*
 * Display hardware is capable of color fill with bltter
 */
#define DDCAPS_BLTCOLORFILL             0x04000000l

/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */
#define DDCAPS_BANKSWITCHED             0x08000000l

/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */
#define DDCAPS_BLTDEPTHFILL             0x10000000l

/*
 * Display hardware is capable of clipping while bltting.
 */
#define DDCAPS_CANCLIP                  0x20000000l

/*
 * Display hardware is capable of clipping while stretch bltting.
 */
#define DDCAPS_CANCLIPSTRETCHED         0x40000000l

/*
 * Display hardware is capable of bltting to or from system memory
 */
#define DDCAPS_CANBLTSYSMEM             0x80000000l


 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */
#define DDCAPS2_CERTIFIED              0x00000001l

/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */
#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l

/*
 * Display hardware contains a video port
 */
#define DDCAPS2_VIDEOPORT               0x00000004l

/*
 * The overlay can be automatically flipped according to the video port
 * VSYNCs, providing automatic doubled buffered display of video port
 * data using an overlay
 */
#define DDCAPS2_AUTOFLIPOVERLAY         0x00000008l

/*
 * Overlay can display each field of interlaced data individually while
 * it is interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBINTERLEAVED       0x00000010l

/*
 * Overlay can display each field of interlaced data individually while
 * it is not interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBNONINTERLEAVED    0x00000020l

/*
 * The overlay surface contains color controls (brightness, sharpness, etc.)
 */
#define DDCAPS2_COLORCONTROLOVERLAY     0x00000040l

/*
 * The primary surface contains color controls (gamma, etc.)
 */
#define DDCAPS2_COLORCONTROLPRIMARY     0x00000080l

/*
 * RGBZ -> RGB supported for 16:16 RGB:Z
 */
#define DDCAPS2_CANDROPZ16BIT           0x00000100l

/*
 * Driver supports non-local video memory.
 */
#define DDCAPS2_NONLOCALVIDMEM          0x00000200l

/*
 * Dirver supports non-local video memory but has different capabilities for
 * non-local video memory surfaces. If this bit is set then so must
 * DDCAPS2_NONLOCALVIDMEM.
 */
#define DDCAPS2_NONLOCALVIDMEMCAPS      0x00000400l

/*
 * Driver neither requires nor prefers surfaces to be pagelocked when performing
 * blts involving system memory surfaces
 */
#define DDCAPS2_NOPAGELOCKREQUIRED      0x00000800l

/*
 * Driver can create surfaces which are wider than the primary surface
 */
#define DDCAPS2_WIDESURFACES            0x00001000l

/*
 * Driver supports bob without using a video port by handling the
 * DDFLIP_ODD and DDFLIP_EVEN flags specified in Flip.
 */
#define DDCAPS2_CANFLIPODDEVEN          0x00002000l

/*
 * Driver supports bob using hardware
 */
#define DDCAPS2_CANBOBHARDWARE          0x00004000l

/*
 * Driver supports bltting any FOURCC surface to another surface of the same FOURCC
 */
#define DDCAPS2_COPYFOURCC              0x00008000l

//@@BEGIN_MSINTERNAL
/*
 * Driver supports optimized surfaces
 */
#define DDCAPS2_OPTIMIZEDSURFACES       0x00010000l
//@@END_MSINTERNAL

/*
 * Driver supports loadable gamma ramps for the primary surface
 */
#define DDCAPS2_PRIMARYGAMMA            0x00020000l
//@@BEGIN_MSINTERNAL
/*
 * This cap was meant to be used for driver managed textures, but they were broken
 * in DX 6.x. The cap was reintroduced in DX7 as 0x00800000l. However, 0x00040000l
 * cannot be reassigned to anything else since it causes bad things to happen in
 * the D3D 6.x runtime (snene 11/12/98).
 */
#define DDCAPS2_NEVERNEVERUSE           0x00040000l
//@@END_MSINTERNAL

/*
 * Driver can render in windowed mode.
 */
#define DDCAPS2_CANRENDERWINDOWED       0x00080000l

/*
 * A calibrator is available to adjust the gamma ramp according to the
 * physical display properties so that the result will be identical on
 * all calibrated systems.
 */
#define DDCAPS2_CANCALIBRATEGAMMA       0x00100000l

/*
 * Indicates that the driver will respond to DDFLIP_INTERVALn flags
 */
#define DDCAPS2_FLIPINTERVAL            0x00200000l

/*
 * Indicates that the driver will respond to DDFLIP_NOVSYNC
 */
#define DDCAPS2_FLIPNOVSYNC             0x00400000l

/*
 * Driver supports management of video memory, if this flag is ON,
 * driver manages the texture if requested with DDSCAPS2_TEXTUREMANAGE on
 * DirectX manages the texture if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
 */
#define DDCAPS2_CANMANAGETEXTURE        0x00800000l

/*
 * The Direct3D texture manager uses this cap to decide whether to put managed
 * surfaces in non-local video memory. If the cap is set, the texture manager will
 * put managed surfaces in non-local vidmem. Drivers that cannot texture from
 * local vidmem SHOULD NOT set this cap.
 */
#define DDCAPS2_TEXMANINNONLOCALVIDMEM  0x01000000l

/*
 * Indicates that the driver supports DX7 type of stereo in at least one mode (which may
 * not necessarily be the current mode). Applications should use IDirectDraw7 (or higher)
 * ::EnumDisplayModes and check the DDSURFACEDESC.ddsCaps.dwCaps2 field for the presence of
 * DDSCAPS2_STEREOSURFACELEFT to check if a particular mode supports stereo. The application
 * can also use IDirectDraw7(or higher)::GetDisplayMode to check the current mode.
 */
#define DDCAPS2_STEREO                  0x02000000L

/*
 * This caps bit is intended for internal DirectDraw use.
 * -It is only valid if DDCAPS2_NONLOCALVIDMEMCAPS is set.
 * -If this bit is set, then DDCAPS_CANBLTSYSMEM MUST be set by the driver (and
 *  all the assoicated system memory blt caps must be correct).
 * -It implies that the system->video blt caps in DDCAPS also apply to system to
 *  nonlocal blts. I.e. the dwSVBCaps, dwSVBCKeyCaps, dwSVBFXCaps and dwSVBRops
 *  members of DDCAPS (DDCORECAPS) are filled in correctly.
 * -Any blt from system to nonlocal memory that matches these caps bits will
 *  be passed to the driver.
 *
 * NOTE: This is intended to enable the driver itself to do efficient reordering
 * of textures. This is NOT meant to imply that hardware can write into AGP memory.
 * This operation is not currently supported.
 */
#define DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL   0x04000000L

/*
 * was DDCAPS2_PUREHAL
 */
#define DDCAPS2_RESERVED1                     0x08000000L

/*
 * Driver supports management of video memory, if this flag is ON,
 * driver manages the resource if requested with DDSCAPS2_TEXTUREMANAGE on
 * DirectX manages the resource if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
 */
#define DDCAPS2_CANMANAGERESOURCE             0x10000000L

/*
 * Driver supports dynamic textures. This will allow the application to set
 * D3DUSAGE_DYNAMIC (DDSCAPS2_HINTDYNAMIC for drivers) at texture create time.
 * Video memory dynamic textures WILL be lockable by applications. It is
 * expected that these locks will be very efficient (which implies that the
 * driver should always maintain a linear copy, a pointer to which can be
 * quickly handed out to the application).
 */
#define DDCAPS2_DYNAMICTEXTURES               0x20000000L

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAW ALPHA CAPABILITY FLAGS (for DDCAPS members dwAlphaCaps,
 *   dwSVBAlphaCaps, dwVSBAlphaCaps, and dwSSBAlphaCaps)
 *
 ****************************************************************************/

/*
 * Driver supports blitting of surfaces that contain alpha information
 * in the pixel format.
 */
#define DDALPHACAPS_BLTALPHAPIXELS              0x00000001l

/*
 * Driver performs saturated arithmetic when alpha-blending for a blit.
 * This prevents the dest pixels' color components from overflowing.
 */
#define DDALPHACAPS_BLTSATURATE                 0x00000002l

/*
 * Driver can perform alpha blitting with pixels in premultiplied-
 * alpha format (color components stored in each pixel have been
 * premultiplied by the pixel's alpha component).
 */
#define DDALPHACAPS_BLTPREMULT                  0x00000004l

/*
 * Driver can perform alpha blitting with pixels in NON-premultiplied-
 * alpha format (color components NOT premultiplied by alpha component).
 */
#define DDALPHACAPS_BLTNONPREMULT               0x00000008l

/*
 * Driver can perform one-factor ARGB scaling of source pixels
 * during a blit.
 */
#define DDALPHACAPS_BLTARGBSCALE1F              0x00000010l

/*
 * Driver can perform two-factor ARGB scaling of source pixels
 * during a blit.
 */
#define DDALPHACAPS_BLTARGBSCALE2F              0x00000020l

/*
 * Driver can perform four-factor ARGB scaling of source pixels
 * during a blit.
 */
#define DDALPHACAPS_BLTARGBSCALE4F              0x00000040l

/*
 * Driver can do an alpha-blended color fill of a dest surface.
 */
#define DDALPHACAPS_BLTALPHAFILL                0x00000080l

/*
 * Driver can handle source alpha channel and ARGB scaling at the same time.
 */
#define DDALPHACAPS_BLTALPHAANDARGBSCALING      0x00000100l

/*
 * Driver supports overlays with surfaces that contain alpha information
 * in the pixel format.
 */
#define DDALPHACAPS_OVERLAYALPHAPIXELS          0x00010000l

/*
 * Driver performs saturated arithmetic to prevent the color
 * components in an alpha-blended overlay from overflowing.
 */
#define DDALPHACAPS_OVERLAYSATURATE             0x00020000l

/*
 * Driver can do alpha-blended overlays with pixels in premultiplied-
 * alpha format (color components stored in each pixel have been
 * premultiplied by the pixel's alpha component).
 */
#define DDALPHACAPS_OVERLAYPREMULT              0x00040000l

/*
 * Driver can do alpha-blended overlays with pixels in NON-premultiplied-
 * alpha format (color components NOT premultiplied by alpha component).
 */
#define DDALPHACAPS_OVERLAYNONPREMULT           0x00080000l

/*
 * Driver can perform one-factor ARGB scaling of source pixels
 * for an overlay.
 */
#define DDALPHACAPS_OVERLAYARGBSCALE1F          0x00100000l

/*
 * Driver can perform two-factor ARGB scaling of source pixels
 * for an overlay.
 */
#define DDALPHACAPS_OVERLAYARGBSCALE2F          0x00200000l

/*
 * Driver can perform four-factor ARGB scaling of source pixels
 * for an overlay.
 */
#define DDALPHACAPS_OVERLAYARGBSCALE4F          0x00400000l

/*
 * Driver can handle alpha blending and dest color keying at the same time.
 */
#define DDALPHACAPS_OVERLAYALPHAANDKEYDEST      0x00800000l

/*
 * Driver can handle source alpha channel and ARGB scaling at the same time.
 */
#define DDALPHACAPS_OVERLAYALPHAANDARGBSCALING  0x01000000l
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
//@@BEGIN_MSINTERNAL
 * -- These are obsolete.  They are for the obsolete dwFXAlphaCaps member in DDCAPS_DX1/3/5.
//@@END_MSINTERNAL
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAEDGEBLEND         0x00000001l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELS            0x00000002l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELSNEG         0x00000004l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACES          0x00000008l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACESNEG       0x00000010l

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND     0x00000020l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELS        0x00000040l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG     0x00000080l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACES      0x00000100l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG   0x00000200l

#if DIRECTDRAW_VERSION < 0x0600
#endif  //DIRECTDRAW_VERSION

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAW FILTER CAPABILITY FLAGS (for DDCAPS members dwFilterCaps,
 *   dwSVBFilterCaps, dwVSBFilterCaps, and dwSSBFilterCaps)
 *
 ****************************************************************************/

/*
 * Driver can do filtering of source pixels for an alpha blit to improve
 * quality of image that is stretched or shrunk to fit dest rect.
 */
#define DDFILTCAPS_BLTQUALITYFILTER             0x00000001l

/*
 * Driver can disable filtering for an alpha blit.  This may be necessary to
 * preserve color key values in an image that is stretched or shrunk.
 */
#define DDFILTCAPS_BLTCANDISABLEFILTER          0x00000002l

/*
 * When filtering, driver can treat pixels bordering source rectangle as
 * transparent in order to smoothly blend source image onto dest image.
 */
#define DDFILTCAPS_BLTTRANSPBORDER              0x00000004l


/****************************************************************************
 *
 * DIRECTDRAW TRANSFORM CAPABILITY FLAGS (for DDCAPS members dwTransformCaps,
 *   dwSVBTransformCaps, dwVSBTransformCaps, and dwSSBTransformCaps)
 *
 ****************************************************************************/

/*
 * Driver can do an affine-transformed blit.
 */
#define DDTFRMCAPS_BLTAFFINETRANSFORM           0x00000001l

/*
 * Driver can do an affine-transformed overlay.
 */
#define DDTFRMCAPS_OVERLAYAFFINETRANSFORM       0x00000002l
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */
#define DDFXCAPS_BLTARITHSTRETCHY       0x00000020l

/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */
#define DDFXCAPS_BLTARITHSTRETCHYN      0x00000010l

/*
 * Supports mirroring left to right in blt.
 */
#define DDFXCAPS_BLTMIRRORLEFTRIGHT     0x00000040l

/*
 * Supports mirroring top to bottom in blt.
 */
#define DDFXCAPS_BLTMIRRORUPDOWN        0x00000080l

/*
 * Supports arbitrary rotation for blts.
 */
#define DDFXCAPS_BLTROTATION            0x00000100l

/*
 * Supports 90 degree rotations for blts.
 */
#define DDFXCAPS_BLTROTATION90          0x00000200l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKX             0x00000400l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKXN            0x00000800l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKY             0x00001000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKYN            0x00002000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHX            0x00004000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHXN           0x00008000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHY            0x00010000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHYN           0x00020000l

/*
 * Uses arithmetic operations to stretch and shrink surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHY   0x00040000l

/*
 * Uses arithmetic operations to stretch surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays. Only works for x1, x2, etc.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHYN  0x00000008l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKX         0x00080000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKXN        0x00100000l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKY         0x00200000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKYN        0x00400000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHX        0x00800000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHXN       0x01000000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHY        0x02000000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHYN       0x04000000l

/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */
#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT 0x08000000l

/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */
#define DDFXCAPS_OVERLAYMIRRORUPDOWN    0x10000000l

/*
 * DirectDraw supports deinterlacing of overlay surfaces
 */
#define DDFXCAPS_OVERLAYDEINTERLACE		0x20000000l

/*
 * Driver can do alpha blending for blits.
 */
#define DDFXCAPS_BLTALPHA               0x00000001l

//@@BEGIN_MSINTERNAL
/*
 * Driver can do geometric transformations (or warps) for blits.
 */
#define DDFXCAPS_BLTTRANSFORM           0x00000002l
//@@END_MSINTERNAL

/*
 * Driver can do surface-reconstruction filtering for warped blits.
 */
#define DDFXCAPS_BLTFILTER              DDFXCAPS_BLTARITHSTRETCHY

/*
 * Driver can do alpha blending for overlays.
 */
#define DDFXCAPS_OVERLAYALPHA           0x00000004l

//@@BEGIN_MSINTERNAL
/*
 * Driver can do geometric transformations (or warps) for overlays.
 */
#define DDFXCAPS_OVERLAYTRANSFORM       0x20000000l
//@@END_MSINTERNAL

/*
 * Driver can do surface-reconstruction filtering for warped overlays.
 */
#define DDFXCAPS_OVERLAYFILTER          DDFXCAPS_OVERLAYARITHSTRETCHY

/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * This flag used to be DDSVCAPS_ENIGMA, which is now obsolete
 */

#define DDSVCAPS_RESERVED1              0x00000001l

/*
 * This flag used to be DDSVCAPS_FLICKER, which is now obsolete
 */
#define DDSVCAPS_RESERVED2              0x00000002l

/*
 * This flag used to be DDSVCAPS_REDBLUE, which is now obsolete
 */
#define DDSVCAPS_RESERVED3              0x00000004l

/*
 * This flag used to be DDSVCAPS_SPLIT, which is now obsolete
 */
#define DDSVCAPS_RESERVED4              0x00000008l

/*
 * The stereo view is accomplished with switching technology
 */

#define DDSVCAPS_STEREOSEQUENTIAL       0x00000010L



/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */
#define DDPCAPS_4BIT                    0x00000001l

/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */
#define DDPCAPS_8BITENTRIES             0x00000002l

/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */
#define DDPCAPS_8BIT                    0x00000004l

/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 * This flag is obsolete. DirectDraw always initializes the color array from
 * the lpDDColorArray parameter. The definition remains for source-level
 * compatibility.
 */
#define DDPCAPS_INITIALIZE              0x00000000l

/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */
#define DDPCAPS_PRIMARYSURFACE          0x00000010l

/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */
#define DDPCAPS_PRIMARYSURFACELEFT      0x00000020l

/*
 * This palette can have all 256 entries defined
 */
#define DDPCAPS_ALLOW256                0x00000040l

/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */
#define DDPCAPS_VSYNC                   0x00000080l

/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */
#define DDPCAPS_1BIT                    0x00000100l

/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */
#define DDPCAPS_2BIT                    0x00000200l

/*
 * The peFlags member of PALETTEENTRY denotes an 8 bit alpha value
 */
#define DDPCAPS_ALPHA                   0x00000400l

//@@BEGIN_MSINTERNAL
#define DDPCAPS_VALID                   0x000007ffl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * Palette changes take effect immediately.
 */
#define DDPSETPAL_IMMEDIATE             0x00000000l     // default

/*
 * Palette changes should take effect during the vertical blank to avoid
 * palette tearing.
 */
#define DDPSETPAL_VSYNC                 0x00000002l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPRIVATEDATA CONSTANTS
 *
 ****************************************************************************/

/*
 * The passed pointer is an IUnknown ptr. The cbData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). DirectDraw will call AddRef through this
 * pointer and Release when the private data is destroyed. This includes when
 * the surface or palette is destroyed before such priovate data is destroyed.
 */
#define DDSPD_IUNKNOWNPOINTER           0x00000001L

/*
 * Private data is only valid for the current state of the object,
 * as determined by the uniqueness value.
 */
#define DDSPD_VOLATILE                  0x00000002L

//@@BEGIN_MSINTERNAL
#define DDSPD_VALID                     0x00000003L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * Palette change takes effect immediately.
 */
#define DDSETPAL_IMMEDIATE              0x00000000l     // default

/*
 * Palette change should take effect during the vertical blank to avoid
 * palette tearing.
 */
#define DDSETPAL_VSYNC                  0x00000002l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */
#define DDBD_1                  0x00004000l

/*
 * 2 bits per pixel.
 */
#define DDBD_2                  0x00002000l

/*
 * 4 bits per pixel.
 */
#define DDBD_4                  0x00001000l

/*
 * 8 bits per pixel.
 */
#define DDBD_8                  0x00000800l

/*
 * 16 bits per pixel.
 */
#define DDBD_16                 0x00000400l

/*
 * 24 bits per pixel.
 */
#define DDBD_24                 0X00000200l

/*
 * 32 bits per pixel.
 */
#define DDBD_32                 0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.  Not set if the structure
 * contains a single color key.
 */
#define DDCKEY_COLORSPACE       0x00000001l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */
#define DDCKEY_DESTBLT          0x00000002l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */
#define DDCKEY_DESTOVERLAY      0x00000004l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */
#define DDCKEY_SRCBLT           0x00000008l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */
#define DDCKEY_SRCOVERLAY       0x00000010l

//@@BEGIN_MSINTERNAL
#define DDCKEY_VALID            0x0000001fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLT                      0x00000001l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACE              0x00000002l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV           0x00000004l

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTYUV                   0x00000008l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAY                  0x00000010l

/*
 * Supports a color space as the color key for the destination for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACE          0x00000020l

/*
 * Supports a color space as the color key for the destination for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV       0x00000040l

/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */
#define DDCKEYCAPS_DESTOVERLAYONEACTIVE         0x00000080l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the
 * surface being overlayed for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYYUV               0x00000100l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLT                       0x00000200l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACE               0x00000400l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV            0x00000800l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTYUV                    0x00001000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAY                   0x00002000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACE           0x00004000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV        0x00008000l

/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */
#define DDCKEYCAPS_SRCOVERLAYONEACTIVE          0x00010000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYYUV                0x00020000l

/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */
#define DDCKEYCAPS_NOCOSTOVERLAY                0x00040000l


/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */
#define DDPF_ALPHAPIXELS                        0x00000001l

/*
 * The pixel format contains alpha only information
 */
#define DDPF_ALPHA                              0x00000002l

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l

/*
 * The surface is 4-bit color indexed.
 */
#define DDPF_PALETTEINDEXED4                    0x00000008l

/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */
#define DDPF_PALETTEINDEXEDTO8                  0x00000010l

/*
 * The surface is 8-bit color indexed.
 */
#define DDPF_PALETTEINDEXED8                    0x00000020l

/*
 * The RGB data in the pixel format structure is valid.
 */
#define DDPF_RGB                                0x00000040l

/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */
#define DDPF_COMPRESSED                         0x00000080l

/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set.
 */
#define DDPF_RGBTOYUV                           0x00000100l

/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */
#define DDPF_YUV                                0x00000200l

/*
 * pixel format is a z buffer only surface
 */
#define DDPF_ZBUFFER                            0x00000400l

/*
 * The surface is 1-bit color indexed.
 */
#define DDPF_PALETTEINDEXED1                    0x00000800l

/*
 * The surface is 2-bit color indexed.
 */
#define DDPF_PALETTEINDEXED2                    0x00001000l

/*
 * The surface contains Z information in the pixels
 */
#define DDPF_ZPIXELS                            0x00002000l

/*
 * The surface contains stencil information along with Z
 */
#define DDPF_STENCILBUFFER                      0x00004000l

/*
 * Premultiplied alpha format -- the color components have been
 * premultiplied by the alpha component.
 */
#define DDPF_ALPHAPREMULT                       0x00008000l

//@@BEGIN_MSINTERNAL
/*
 * Empty surface
 */
#define DDPF_EMPTYSURFACE                       0x00010000l
//@@END_MSINTERNAL

/*
 * Luminance data in the pixel format is valid.
 * Use this flag for luminance-only or luminance+alpha surfaces,
 * the bit depth is then ddpf.dwLuminanceBitCount.
 */
#define DDPF_LUMINANCE                          0x00020000l

/*
 * Luminance data in the pixel format is valid.
 * Use this flag when hanging luminance off bumpmap surfaces,
 * the bit mask for the luminance portion of the pixel is then
 * ddpf.dwBumpLuminanceBitMask
 */
#define DDPF_BUMPLUMINANCE                      0x00040000l

/*
 * Bump map dUdV data in the pixel format is valid.
 */
#define DDPF_BUMPDUDV                           0x00080000l

//@@BEGIN_MSINTERNAL
/*
 * This DDPF flag is used by drivers to signify that this format is new and may be
 * a candidate for hiding from certain applications
 * KEEP THIS DEFINITION IN SYNC WITH THAT OF DDPF_NOVEL_TEXTURE_FORMAT IN DDRAWI.H
 */
#define DDPF_RESERVED1                          0x00100000l


/*
 * This DDPF flag indicates a DX8 style texture list entry.
 * Keep this definition in sync with DDPF_D3DFORMAT in DDRAWI.H
 */
#define DDPF_RESERVED2                          0x00200000l

//@@END_MSINTERNAL

/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */
#define DDENUMSURFACES_ALL                      0x00000001l

/*
 * A search hit is a surface that matches the surface description.
 */
#define DDENUMSURFACES_MATCH                    0x00000002l

/*
 * A search hit is a surface that does not match the surface description.
 */
#define DDENUMSURFACES_NOMATCH                  0x00000004l

/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */
#define DDENUMSURFACES_CANBECREATED             0x00000008l

/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */
#define DDENUMSURFACES_DOESEXIST                0x00000010l

//@@BEGIN_MSINTERNAL
#define DDENUMSURFACES_VALID                    0x0000001fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SETDISPLAYMODE FLAGS
 *
 ****************************************************************************/

/*
 * The desired mode is a standard VGA mode
 */
#define DDSDM_STANDARDVGAMODE                   0x00000001l

//@@BEGIN_MSINTERNAL
#define DDSDM_VALID                             0x00000001l
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */
#define DDEDM_REFRESHRATES                      0x00000001l

/*
 * Enumerate VGA modes. Specify this flag if you wish to enumerate supported VGA
 * modes such as mode 0x13 in addition to the usual ModeX modes (which are always
 * enumerated if the application has previously called SetCooperativeLevel with the
 * DDSCL_ALLOWMODEX flag set).
 */
#define DDEDM_STANDARDVGAMODES                  0x00000002L

//@@BEGIN_MSINTERNAL
#define DDEDM_VALID                             0x00000003l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */
#define DDSCL_FULLSCREEN                        0x00000001l

/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
 */
#define DDSCL_ALLOWREBOOT                       0x00000002l

/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */
#define DDSCL_NOWINDOWCHANGES                   0x00000004l

/*
 * app wants to work as a regular Windows application
 */
#define DDSCL_NORMAL                            0x00000008l

/*
 * app wants exclusive access
 */
#define DDSCL_EXCLUSIVE                         0x00000010l

//@@BEGIN_MSINTERNAL
/*
 * dont hook window proc, only valid for non-exclusive
 */
#define DDSCL_DONTHOOKHWND                      0x00000020l
//@@END_MSINTERNAL

/*
 * app can deal with non-windows display modes
 */
#define DDSCL_ALLOWMODEX                        0x00000040l

/*
 * this window will receive the focus messages
 */
#define DDSCL_SETFOCUSWINDOW                    0x00000080l

/*
 * this window is associated with the DDRAW object and will
 * cover the screen in fullscreen mode
 */
#define DDSCL_SETDEVICEWINDOW                   0x00000100l

/*
 * app wants DDRAW to create a window to be associated with the
 * DDRAW object
 */
#define DDSCL_CREATEDEVICEWINDOW                0x00000200l

/*
 * App explicitly asks DDRAW/D3D to be multithread safe. This makes D3D
 * take the global crtisec more frequently.
 */
#define DDSCL_MULTITHREADED                     0x00000400l

/*
 * App specifies that it would like to keep the FPU set up for optimal Direct3D
 * performance (single precision and exceptions disabled) so Direct3D
 * does not need to explicitly set the FPU each time. This is assumed by
 * default in DirectX 7. See also DDSCL_FPUPRESERVE
 */
#define DDSCL_FPUSETUP                          0x00000800l

/*
 * App specifies that it needs either double precision FPU or FPU exceptions
 * enabled. This makes Direct3D explicitly set the FPU state eah time it is
 * called. Setting the flag will reduce Direct3D performance. The flag is
 * assumed by default in DirectX 6 and earlier. See also DDSCL_FPUSETUP
 */
#define DDSCL_FPUPRESERVE                          0x00001000l

//@@BEGIN_MSINTERNAL
/*
 * Used to flag a call from the DX8 thunk layer, which we use to modify
 * msg loop behaviour.
 */
#define DDSCL_DX8APP                               0x00002000l
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#define DDSCL_VALID                                0x00003FFFl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHADEST                         0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDBLT_ALPHADESTCONSTOVERRIDE            0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHADESTNEG                      0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDBLT_ALPHADESTSURFACEOVERRIDE          0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDBLT_ALPHAEDGEBLEND                    0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHASRC                          0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCCONSTOVERRIDE             0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHASRCNEG                       0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCSURFACEOVERRIDE           0x00000100l

/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */
#define DDBLT_ASYNC                             0x00000200l

/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDBLT_COLORFILL                         0x00000400l

/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */
#define DDBLT_DDFX                              0x00000800l

/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDBLT_DDROPS                            0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDBLT_KEYDEST                           0x00002000l

/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */
#define DDBLT_KEYDESTOVERRIDE                   0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDBLT_KEYSRC                            0x00008000l

/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */
#define DDBLT_KEYSRCOVERRIDE                    0x00010000l

/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDBLT_ROP                               0x00020000l

/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDBLT_ROTATIONANGLE                     0x00040000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDBLT_ZBUFFER                           0x00080000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDBLT_ZBUFFERDESTCONSTOVERRIDE          0x00100000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDBLT_ZBUFFERDESTOVERRIDE               0x00200000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDBLT_ZBUFFERSRCCONSTOVERRIDE           0x00400000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_WAIT                              0x01000000l

/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */
#define DDBLT_DEPTHFILL                         0x02000000l

//@@BEGIN_MSINTERNAL
//Turns on ddbltfx.dwZDestConstBitDepth as a write mask for zbuffer clears (so as not to
//clobber the stencil or vice versa). This is VERY internal only. Fielded only by the HEL
#define DDBLT_DEPTHFILLWRITEMASK                0x04000000l
//@@END_MSINTERNAL

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_DONOTWAIT                         0x08000000l

/*
 * These flags indicate a presentation blt (i.e. a blt
 * that moves surface contents from an offscreen back buffer to the primary
 * surface). The driver is not allowed to "queue"  more than three such blts.
 * The "end" of the presentation blt is indicated, since the
 * blt may be clipped, in which case the runtime will call the driver with 
 * several blts. All blts (even if not clipped) are tagged with DDBLT_PRESENTATION
 * and the last (even if not clipped) additionally with DDBLT_LAST_PRESENTATION.
 * Thus the true rule is that the driver must not schedule a DDBLT_PRESENTATION
 * blt if there are 3 or more DDBLT_PRESENTLAST blts in the hardware pipe.
 * If there are such blts in the pipe, the driver should return DDERR_WASSTILLDRAWING
 * until the oldest queued DDBLT_LAST_PRESENTATION blts has been retired (i.e. the
 * pixels have been actually written to the primary surface). Once the oldest blt
 * has been retired, the driver is free to schedule the current blt.
 * The goal is to provide a mechanism whereby the device's hardware queue never
 * gets more than 3 frames ahead of the frames being generated by the application.
 * When excessive queueing occurs, applications become unusable because the application
 * visibly lags user input, and such problems make windowed interactive applications impossible.
 * Some drivers may not have sufficient knowledge of their hardware's FIFO to know
 * when a certain blt has been retired. Such drivers should code cautiously, and 
 * simply not allow any frames to be queued at all. DDBLT_LAST_PRESENTATION should cause
 * such drivers to return DDERR_WASSTILLDRAWING until the accelerator is completely
 * finished- exactly as if the application had called Lock on the source surface
 * before calling Blt. 
 * In other words, the driver is allowed and encouraged to 
 * generate as much latency as it can, but never more than 3 frames worth.
 * Implementation detail: Drivers should count blts against the SOURCE surface, not
 * against the primary surface. This enables multiple parallel windowed application
 * to function more optimally.
 * This flag is passed only to DX8 or higher drivers.
 *
 * APPLICATIONS DO NOT SET THESE FLAGS. THEY ARE SET BY THE DIRECTDRAW RUNTIME.
 * 
 */
#define DDBLT_PRESENTATION                      0x10000000l
#define DDBLT_LAST_PRESENTATION                 0x20000000l


//@@BEGIN_MSINTERNAL
//We are running out of blt flags. From now on, the high bit will be used
//to indicate a DX8 (or higher) sourced blt, and we will start re-using
//old bits for internal-only flags (flags which are passed to the thunk
//layer's blt but not to the driver. All these DX8-only bits will be
//filtered off before checking against DDBLT_VALID.
#define DDBLT_DX8ORHIGHER                       0x80000000l

//will use the hWnd with the clipper to get the Destination
#define DDBLT_WINDOWCLIP                        0x00000001l /* DDBLT_ALPHADEST */
#define DDBLT_COPYVSYNC                         0x00000002l /* DDBLT_ALPHADESTCONSTOVERRIDE */

#define DDBLT_VALID                             0x1fffffffl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/

#define DDBLTFAST_NOCOLORKEY                    0x00000000
#define DDBLTFAST_SRCCOLORKEY                   0x00000001
#define DDBLTFAST_DESTCOLORKEY                  0x00000002
#define DDBLTFAST_WAIT                          0x00000010
#define DDBLTFAST_DONOTWAIT                     0x00000020
//@@BEGIN_MSINTERNAL
#define DDBLTFAST_COLORKEY_MASK                 0x0000000F
#define DDBLTFAST_VALID                         0x00000033
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * Flags for AlphaBlt API call
 *
 ****************************************************************************/

/*
 * Use color key associated with source surface.
 */
#define DDABLT_KEYSRC                           0x40000000L

/*
 * Mirror the source image left-to-right in the destination rect.
 */
#define DDABLT_MIRRORLEFTRIGHT                  0x20000000L

/*
 * Mirror the source image vertically in the destination rect.
 */
#define DDABLT_MIRRORUPDOWN                     0x10000000L

/*
 * If previously initiated drawing operation is still in progress,
 * wait for it to finish instead of returning DDERR_WASSTILLDRAWING.
 */
#define DDABLT_WAIT                             0x08000000L

/*
 * Mandates hardware acceleration -- no software emulation.
 */
#define DDABLT_HARDWAREONLY                     0x04000000L

/*
 * Convert the source pixels to the destination pixel format, but
 * perform no color keying, no alpha blending, and no ARGB scaling.
 */
#define DDABLT_NOBLEND                          0x02000000L

/*
 * Enable filtering of source pixels for blit in order to improve quality
 * of stretched or shrunk image.
 */
#define DDABLT_FILTERENABLE                     0x01000000l

/*
 * Disable filtering.  Use nearest-neighbor source pixels for stretch blits.
 */
#define DDABLT_FILTERDISABLE                    0x00800000L

/*
 * If the driver is unable to use the ARGB scaling factors as specified,
 * degrade the scaling operation to one the driver can perform.
 */
#define DDABLT_DEGRADEARGBSCALING               0x00400000L

/*
 * If previously initiated drawing operation is still in progress,
 * return DDERR_WASSTILLDRAWING instead of waiting for it to finish.
 */
#define DDABLT_DONOTWAIT                        0x00200000L

/*
 * Fill dest surface with pixel value contained in lpDDAlphaBltFX->dwFillValue.
 */
#define DDABLT_USEFILLVALUE                     0x00100000L

/*
 * Mandates software emulation -- no hardware acceleration.
 */
#define DDABLT_SOFTWAREONLY                     0x00080000L

/*
 * When filtering, pixels bordering source rectangle are treated as transparent
 * in order to smoothly blend edges of source image onto dest image.
 */
#define DDABLT_FILTERTRANSPBORDER               0x00040000L

#define DDABLT_VALID                            0x7ffc0000L
//@@END_MSINTERNAL


/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/

#define DDFLIP_WAIT                          0x00000001L

/*
 * Indicates that the target surface contains the even field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_EVEN                          0x00000002L

/*
 * Indicates that the target surface contains the odd field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_ODD                           0x00000004L

/*
 * Causes DirectDraw to perform the physical flip immediately and return
 * to the application. Typically, what was the front buffer but is now the back
 * buffer will still be visible (depending on timing) until the next vertical
 * retrace. Subsequent operations involving the two flipped surfaces will
 * not check to see if the physical flip has finished (i.e. will not return
 * DDERR_WASSTILLDRAWING for that reason (but may for other reasons)).
 * This allows an application to perform Flips at a higher frequency than the
 * monitor refresh rate, but may introduce visible artifacts.
 * Only effective if DDCAPS2_FLIPNOVSYNC is set. If that bit is not set,
 * DDFLIP_NOVSYNC has no effect.
 */
#define DDFLIP_NOVSYNC                       0x00000008L


/*
 * Flip Interval Flags. These flags indicate how many vertical retraces to wait between
 * each flip. The default is one. DirectDraw will return DDERR_WASSTILLDRAWING for each
 * surface involved in the flip until the specified number of vertical retraces has
 * ocurred. Only effective if DDCAPS2_FLIPINTERVAL is set. If that bit is not set,
 * DDFLIP_INTERVALn has no effect.
 */

/*
 * DirectDraw will flip on every other vertical sync
 */
#define DDFLIP_INTERVAL2                     0x02000000L


/*
 * DirectDraw will flip on every third vertical sync
 */
#define DDFLIP_INTERVAL3                     0x03000000L


/*
 * DirectDraw will flip on every fourth vertical sync
 */
#define DDFLIP_INTERVAL4                     0x04000000L

/*
 * DirectDraw will flip and display a main stereo surface
 */
#define DDFLIP_STEREO                        0x00000010L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDFLIP_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDFLIP_DONOTWAIT.
 */
#define DDFLIP_DONOTWAIT                     0x00000020L

//@@BEGIN_MSINTERNAL
#define DDFLIP_INTERVAL1                     0x01000000L
#define DDFLIP_INTERVALMASK                  0x07000000L
#define DDFLIP_VALID                         0x0700003fL
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
/****************************************************************************
 *
 * DIRECTDRAW COMP FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDCOMP_ALPHADEST                        0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDCOMPOSEFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDCOMP_ALPHADESTCONSTOVERRIDE           0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDCOMP_ALPHADESTNEG                     0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDCOMPOSEFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDCOMP_ALPHADESTSURFACEOVERRIDE         0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDCOMPOSEFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDCOMP_ALPHAEDGEBLEND                   0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDCOMP_ALPHASRC                         0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDCOMPOSEFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDCOMP_ALPHASRCCONSTOVERRIDE            0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDCOMP_ALPHASRCNEG                      0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDCOMPOSEFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDCOMP_ALPHASRCSURFACEOVERRIDE          0x00000100l

/*
 * Before performing this blt invoke the callback specified by the lpfnCallback
 * field in the DDCOMPOSEFX structure.
 */
#define DDCOMP_CALLBACK                         0x00000200l

/*
 * Uses the dwFillColor field in the DDCOMPOSEFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDCOMP_COLORFILL                        0x00000400l

/*
 * Uses the dwDDFX field in the DDCOMPOSEFX structure to specify the effects
 * to use for the blt.
 */
#define DDCOMP_DDFX                             0x00000800l

/*
 * Uses the dwDDROPS field in the DDCOMPOSEFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDCOMP_DDROPS                           0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDCOMP_KEYDEST                          0x00002000l

/*
 * Use the dckDestColorkey field in the DDCOMPOSEFX structure as the color key
 * for the destination surface.
 */
#define DDCOMP_KEYDESTOVERRIDE                  0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDCOMP_KEYSRC                           0x00008000l

/*
 * Use the dckSrcColorkey field in the DDCOMPOSEFX structure as the color key
 * for the source surface.
 */
#define DDCOMP_KEYSRCOVERRIDE                   0x00010000l

/*
 * Do this blt when DestUnlock is called for the last time on the source surface.
 */
#define DDCOMP_ONDESTUNLOCK                     0x00020000l

/*
 * Do this blt when Flip is called on the source surface.
 */
#define DDCOMP_ONFLIP                           0x00040000l

/*
 * Do this blt when Unlock is called for the last time on the source surface.
 */
#define DDCOMP_ONUNLOCK                         0x00080000l

/*
 * Repeat this composition blt the number of times specified in the dwRepeat
 * field of the DDCOMPOSEFX structure
 */
#define DDCOMP_REPEAT                           0x00100000l

/*
 * Use the dwROP field in the DDCOMPOSEFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDCOMP_ROP                              0x00200000l

/*
 * Use the dwRotationAngle field in the DDCOMPOSEFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDCOMP_ROTATIONANGLE                    0x00400000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDCOMP_ZBUFFER                          0x00800000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDCOMP_ZBUFFERDESTCONSTOVERRIDE         0x01000000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDCOMP_ZBUFFERDESTOVERRIDE              0x02000000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDCOMP_ZBUFFERSRCCONSTOVERRIDE          0x04000000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDCOMPOSEFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDCOMP_ZBUFFERSRCOVERRIDE               0x08000000l
#endif
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */
#define DDOVER_ALPHADEST                        0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */
#define DDOVER_ALPHADESTCONSTOVERRIDE           0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases.
 */
#define DDOVER_ALPHADESTNEG                     0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */
#define DDOVER_ALPHADESTSURFACEOVERRIDE         0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */
#define DDOVER_ALPHAEDGEBLEND                   0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */
#define DDOVER_ALPHASRC                         0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */
#define DDOVER_ALPHASRCCONSTOVERRIDE            0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */
#define DDOVER_ALPHASRCNEG                      0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */
#define DDOVER_ALPHASRCSURFACEOVERRIDE          0x00000100l

/*
 * Turn this overlay off.
 */
#define DDOVER_HIDE                             0x00000200l

/*
 * Use the color key associated with the destination surface.
 */
#define DDOVER_KEYDEST                          0x00000400l

/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */
#define DDOVER_KEYDESTOVERRIDE                  0x00000800l

/*
 * Use the color key associated with the source surface.
 */
#define DDOVER_KEYSRC                           0x00001000l

/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */
#define DDOVER_KEYSRCOVERRIDE                   0x00002000l

/*
 * Turn this overlay on.
 */
#define DDOVER_SHOW                             0x00004000l

/*
 * Add a dirty rect to an emulated overlayed surface.
 */
#define DDOVER_ADDDIRTYRECT                     0x00008000l

/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */
#define DDOVER_REFRESHDIRTYRECTS                0x00010000l

/*
 * Redraw the entire surface on an emulated overlayed surface.
 */
#define DDOVER_REFRESHALL                      0x00020000l

//@@BEGIN_MSINTERNAL
/*
 * Force redrawing onto the destination surface without regard for the background
 */
#define DDOVER_REFRESHPOUND                     0x00040000l
//@@END_MSINTERNAL

/*
 * Use the overlay FX flags to define special overlay FX
 */
#define DDOVER_DDFX                             0x00080000l

/*
 * Autoflip the overlay when ever the video port autoflips
 */
#define DDOVER_AUTOFLIP                         0x00100000l

/*
 * Display each field of video port data individually without
 * causing any jittery artifacts
 */
#define DDOVER_BOB                              0x00200000l

/*
 * Indicates that bob/weave decisions should not be overridden by other
 * interfaces.
 */
#define DDOVER_OVERRIDEBOBWEAVE                 0x00400000l

/*
 * Indicates that the surface memory is composed of interleaved fields.
 */
#define DDOVER_INTERLEAVED                      0x00800000l

/*
 * Indicates that bob will be performed using hardware rather than
 * software or emulated.
 */
#define DDOVER_BOBHARDWARE                      0x01000000l

/*
 * Indicates that overlay FX structure contains valid ARGB scaling factors.
 */
#define DDOVER_ARGBSCALEFACTORS                 0x02000000l

/*
 * Indicates that ARGB scaling factors can be degraded to fit driver capabilities.
 */
#define DDOVER_DEGRADEARGBSCALING               0x04000000l

//@@BEGIN_MSINTERNAL
#define DDOVER_VALID                            0x07ffffffl
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * Flags for dwFlags member of DDSPRITE structure
 *
 ****************************************************************************/

/*
 * Use the color key associated with the destination surface.
 */
#define DDSPRITE_KEYDEST                        0x00000001l

/*
 * Uses the dest color key value stored in the embedded DDSPRITEFX
 * structure instead of the color key stored in the dest surface.
 */
#define DDSPRITE_KEYDESTOVERRIDE                0x00000002l

/*
 * Use the color key associated with the source surface.
 */
#define DDSPRITE_KEYSRC                         0x00000004l

/*
 * Uses the source color key value stored in the embedded DDSPRITEFX
 * structure instead of the color key stored in the source surface.
 */
#define DDSPRITE_KEYSRCOVERRIDE                 0x00000008l

/*
 * Indicates that the rcSrc member contains a valid source rectangle.
 */
#define DDSPRITE_RECTSRC                        0x00000010l

/*
 * Indicates that the rcDest member contains a valid destination rectangle.
 */
#define DDSPRITE_RECTDEST                       0x00000020l

/*
 * Indicates that the ddSpriteFX member contains a valid DDSPRITEFX value.
 */
#define DDSPRITE_DDSPRITEFX                     0x00000040l
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Mask of valid DDSPRITE_ flag bits
#define DDSPRITE_VALID                          0x0000006fl
//@@END_MSINTERNAL


//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * Flags for SetSpriteDisplayList API call
 *
 ****************************************************************************/

/*
 * Sprites in display list are to be blitted to destination surface.
 */
#define DDSSDL_BLTSPRITES                       0x00000001l

/*
 * Sprites in display list are to be displayed as overlays on dest (primary) surface.
 */
#define DDSSDL_OVERLAYSPRITES                   0x00000002l

/*
 * Sprites in display list are sorted in back-to-front order (default is F-to-B).
 */
#define DDSSDL_BACKTOFRONT                      0x00000004l

/*
 * Perform page flip of primary surface at same time new display list is shown.
 */
#define DDSSDL_PAGEFLIP                         0x00000008l

/*
 * If hardware acceleration is unavailable, fail rather than emulate.
 */
#define DDSSDL_HARDWAREONLY                     0x00000010l

/*
 * Wait to return until driver is ready to accept new sprite display list.
 */
#define DDSSDL_WAIT                             0x00000020l
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Mask of all valid DDSSDL_ flag bits
#define DDSSDL_VALID                            0x0000003fl
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.  Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
#define DDLOCK_SURFACEMEMORYPTR                 0x00000000L     // default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return
 * DDERR_WASSTILLDRAWING.
 */
#define DDLOCK_WAIT                             0x00000001L

/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */
#define DDLOCK_EVENT                            0x00000002L

/*
 * Indicates that the surface being locked will only be read from.
 */
#define DDLOCK_READONLY                         0x00000010L

/*
 * Indicates that the surface being locked will only be written to
 */
#define DDLOCK_WRITEONLY                        0x00000020L

//@@BEGIN_MSINTERNAL
/*
 * Indicates that InternalLock should set the busy bit and Win16 lock
 * for surfaces not explicitly in system memory.
 */
#define DDLOCK_TAKE_WIN16                       0x00000040L

/*
 * Indicates that InternalLock should set the busy bit and Win16 lock
 * for surfaces in video memory only
 */
#define DDLOCK_TAKE_WIN16_VRAM                  0x00000080L

/*
 * Indicates that InternalLock should check for lost surfaces. By
 * default it does not.
 */
#define DDLOCK_FAILLOSTSURFACES                 0x00000100L

/*
 * Indicates that InternalLock should fail if the vis rgn has changed
 * since it was last queried.  This flag is only used on NT.
 */
#define DDLOCK_FAILONVISRGNCHANGED              0x00000200L

/*
 * This flag is used by the API DD_Surface_Lock to force InternalLock
 * to fail an attempt to lock an emulated primary on NT.
 * This is a symptom of the two-headed nature of InternalLock: it both
 * locks a surface (increases its usage count) and returns a pointer
 * to the bits. An emulated blt on NT requires the first but cares not about the
 * second. DD_Surface_Lock needs the pointer, so it must fail when the
 * second function of InternalLock fails.
 */
#define DDLOCK_FAILEMULATEDNTPRIMARY            0x00000400L

//@@END_MSINTERNAL

/*
 * Indicates that a system wide lock should not be taken when this surface
 * is locked. This has several advantages (cursor responsiveness, ability
 * to call more Windows functions, easier debugging) when locking video
 * memory surfaces. However, an application specifying this flag must
 * comply with a number of conditions documented in the help file.
 * Furthermore, this flag cannot be specified when locking the primary.
 */
#define DDLOCK_NOSYSLOCK                        0x00000800L

/*
 * Used only with Direct3D Vertex Buffer Locks. Indicates that no vertices
 * that were referred to in Draw*PrimtiveVB calls since the start of the
 * frame (or the last lock without this flag) will be modified during the
 * lock. This can be useful when one is only appending data to the vertex
 * buffer
 */
#define DDLOCK_NOOVERWRITE                      0x00001000L

/*
 * Indicates that no assumptions will be made about the contents of the
 * surface or vertex buffer during this lock.
 * This enables two things:
 * -    Direct3D or the driver may provide an alternative memory
 *      area as the vertex buffer. This is useful when one plans to clear the
 *      contents of the vertex buffer and fill in new data.
 * -    Drivers sometimes store surface data in a re-ordered format.
 *      When the application locks the surface, the driver is forced to un-re-order
 *      the surface data before allowing the application to see the surface contents.
 *      This flag is a hint to the driver that it can skip the un-re-ordering process
 *      since the application plans to overwrite every single pixel in the surface
 *      or locked rectangle (and so erase any un-re-ordered pixels anyway).
 *      Applications should always set this flag when they intend to overwrite the entire
 *      surface or locked rectangle.
 */
#define DDLOCK_DISCARDCONTENTS                  0x00002000L
 /*
  * DDLOCK_OKTOSWAP is an older, less informative name for DDLOCK_DISCARDCONTENTS
  */
#define DDLOCK_OKTOSWAP                         0x00002000L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDLOCK_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDLOCK_DONOTWAIT.
 */
#define DDLOCK_DONOTWAIT                        0x00004000L

/*
 * This indicates volume texture lock with front and back specified.
 */
#define DDLOCK_HASVOLUMETEXTUREBOXRECT          0x00008000L

/*
 * This indicates that the driver should not update dirty rect information for this lock.
 */
#define DDLOCK_NODIRTYUPDATE                    0x00010000L

//@@BEGIN_MSINTERNAL
/*
 * An aggregate of all the valid flags which can be passed into the API
 */
#define DDLOCK_VALID                            0x00017831L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */

//@@BEGIN_MSINTERNAL
#define DDPAGELOCK_VALID                        0x00000000L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */

//@@BEGIN_MSINTERNAL
#define DDPAGEUNLOCK_VALID                      0x00000000L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDBLTFX_ARITHSTRETCHY                   0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDBLTFX_MIRRORLEFTRIGHT                 0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDBLTFX_MIRRORUPDOWN                    0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDBLTFX_NOTEARING                       0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDBLTFX_ROTATE180                       0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDBLTFX_ROTATE270                       0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDBLTFX_ROTATE90                        0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDBLTFX_ZBUFFERRANGE                    0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDBLTFX_ZBUFFERBASEDEST                 0x00000100l

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAWSURFACE COMP FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDCOMPFX_ARITHSTRETCHY                  0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDCOMPFX_MIRRORLEFTRIGHT                0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDCOMPFX_MIRRORUPDOWN                   0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDCOMPFX_NOTEARING                      0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDCOMPFX_ROTATE180                      0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDCOMPFX_ROTATE270                      0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDCOMPFX_ROTATE90                       0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDCOMPFX_ZBUFFERRANGE                   0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDCOMPFX_ZBUFFERBASEDEST                0x00000100l
//@@END_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */
#define DDOVERFX_ARITHSTRETCHY                  0x00000001l

/*
 * Mirror the overlay across the vertical axis
 */
#define DDOVERFX_MIRRORLEFTRIGHT                0x00000002l

/*
 * Mirror the overlay across the horizontal axis
 */
#define DDOVERFX_MIRRORUPDOWN                   0x00000004l

/*
 * Deinterlace the overlay, if possible
 */
#define DDOVERFX_DEINTERLACE                    0x00000008l

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * Flags for dwDDFX member of DDSPRITEFX structure
 *
 ****************************************************************************/
/*
 * Use affine transformation matrix in fTransform member.
 */
#define DDSPRITEFX_AFFINETRANSFORM              0x00000001l

/*
 * Use RGBA scaling factors in ddargbScaleFactors member.
 */
#define DDSPRITEFX_RGBASCALING                  0x00000002l

/*
 * Degrade RGBA scaling factors to accommodate driver's capabilities.
 */
#define DDSPRITEFX_DEGRADERGBASCALING           0x00000004l

/*
 * Do bilinear filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_BILINEARFILTER               0x00000008l

/*
 * Do "blur" filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_BLURFILTER                   0x00000010l

/*
 * Do "flat" filtering of stretched or warped sprite.
 */
#define DDSPRITEFX_FLATFILTER                   0x00000020l

/*
 * Degrade filtering operation to accommodate driver's capabilities.
 */
#define DDSPRITEFX_DEGRADEFILTER                0x00000040l

// mask of valid DDSPRITEFX_ flags
#define DDSPRITEFX_VALID                        0x0000007fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */
#define DDWAITVB_BLOCKBEGIN                     0x00000001l

/*
 * set up an event to trigger when the vertical blank begins
 */
#define DDWAITVB_BLOCKBEGINEVENT                0x00000002l

/*
 * return when the vertical blank interval ends and display begins
 */
#define DDWAITVB_BLOCKEND                       0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */
#define DDGFS_CANFLIP                   0x00000001l

/*
 * is the last flip finished?
 */
#define DDGFS_ISFLIPDONE                0x00000002l
// @@BEGIN_MSINTERNAL
#define DDGFS_VALID                     0x00000003l
// @@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */
#define DDGBS_CANBLT                    0x00000001l

/*
 * is the blt to the surface finished?
 */
#define DDGBS_ISBLTDONE                 0x00000002l

// @@BEGIN_MSINTERNAL
#define DDGBS_VALID                     0x00000003l
// @@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */
#define DDENUMOVERLAYZ_BACKTOFRONT      0x00000000l

/*
 * Enumerate overlays front to back
 */
#define DDENUMOVERLAYZ_FRONTTOBACK      0x00000001l

/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */
#define DDOVERZ_SENDTOFRONT             0x00000000l

/*
 * Send overlay to back
 */
#define DDOVERZ_SENDTOBACK              0x00000001l

/*
 * Move Overlay forward
 */
#define DDOVERZ_MOVEFORWARD             0x00000002l

/*
 * Move Overlay backward
 */
#define DDOVERZ_MOVEBACKWARD            0x00000003l

/*
 * Move Overlay in front of relative surface
 */
#define DDOVERZ_INSERTINFRONTOF         0x00000004l

/*
 * Move Overlay in back of relative surface
 */
#define DDOVERZ_INSERTINBACKOF          0x00000005l

// @@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * CREATE/LOAD SURFACE FROM STREAM/FILE FLAGS
 * Valid for:
 *     IDirectDraw4::CreateSurfaceFromStream
 *     IDirectDraw4::CreateSurfaceFromFile
 *     IDirectDrawSurface4::LoadFromStream
 *     IDirectDrawSurface4::LoadFromFile
 *
 ****************************************************************************/

/*
 * Any palette information in the stream will be discarded.
 * Mutually exclusive with DDLS_MERGEEPALETTE
 * If neither DDLS_IGNOREPALETTE nor DDLS_MERGEPALETTE are specified, then any palette information
 * in the stream will be loaded into a new DirectDrawPalette and attached to the surface.
 */
#define DDLS_IGNOREPALETTE                      0x00000001L

/*
 * Any palette information in the stream/file will be matched against all existing DirectDrawPalettes.
 * Any matching palette will be attached to the surface. If no palette matches, a new palette is created
 * and attached to the surface.
 * Mutually exclusive with DDLS_IGNOREPALETTE
 * If neither DDLS_IGNOREPALETTE nor DDLS_MERGEPALETTE are specified, then any palette information
 * in the stream will be loaded into a new DirectDrawPalette and attached to the surface.
 */
#define DDLS_MERGEPALETTE                      0x00000002L

/*
 * The source image will be stretched to fit the specified width.
 * Valid only if the DDSURFACEDESC2 passed to the function has valid width and height members,
 * or if passed to IDirectDrawSurface4::LoadFromFile/Stream.
 * Note that if the specified target width or height is smaller than the source dimension, the
 * source image will be shrunken in that dimension regardless of the setting of this flag.
 */
#define DDLS_STRETCHTOFIT                       0x00000004L

/*
 * If stretched, the source image will be bilinear filtered.
 * Valid only if DDLS_STRETCHTOFIT is specified.
 */
#define DDLS_BILINEARFILTER                     0x00000008L

/*
 * The source image will be stretched only as far as is possible maintaining the
 * height to width ratio of the source image.
 * Valid only if DDLS_STRETCHTOFIT is specified.
 */
#define DDLS_MAINTAINASPECTRATIO                0x00000010L

/*
 * The source image will be centered in the target surface. If this flag is not specified,
 * the image will be placed in the upper left corner of the surface.
 * Any unused space will be initialized to zero.
 * Valid only if the DDSURFACEDESC2 passed to the function has valid width and height members,
 * or if passed to IDirectDrawSurface4::LoadFromFile/Stream.
 */
#define DDLS_CENTER                             0x00000020L
// @@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#define DDLS_VALID                              0x0000003FL
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SETGAMMARAMP FLAGS
 *
 ****************************************************************************/

/*
 * Request calibrator to adjust the gamma ramp according to the physical
 * properties of the display so that the result should appear identical
 * on all systems.
 */
#define DDSGR_CALIBRATE                        0x00000001L

//@@BEGIN_MSINTERNAL
#define DDSGR_VALID                            0x00000001L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW STARTMODETEST FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDSMT_ISTESTREQUIRED                   0x00000001L

//@@BEGIN_MSINTERNAL
#define DDSMT_VALID                            0x00000001L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW EVALUATEMODE FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDEM_MODEPASSED                        0x00000001L

/*
 * Indicates that the mode being tested has failed
 */
#define DDEM_MODEFAILED                        0x00000002L

//@@BEGIN_MSINTERNAL
#define DDEM_VALID                             0x00000003L
//@@END_MSINTERNAL

/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */
//@@BEGIN_MSINTERNAL
#define DD_OK_HANDLED                           1
#define DD_OK_NOTHANDLED                        0
//@@END_MSINTERNAL
#define DD_OK                                   S_OK
#define DD_FALSE                                S_FALSE

/****************************************************************************
 *
 * DIRECTDRAW ENUMCALLBACK RETURN VALUES
 *
 * EnumCallback returns are used to control the flow of the DIRECTDRAW and
 * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
 * enumeration callback routines.
 *
 ****************************************************************************/

/*
 * stop the enumeration
 */
#define DDENUMRET_CANCEL                        0

/*
 * continue the enumeration
 */
#define DDENUMRET_OK                            1

/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
//@@BEGIN_MSINTERNAL
 * NOTE: To avoid collision with other DX APIs, DDraw uses error codes
 *       [5-699] and [1024-2048].
//@@END_MSINTERNAL
 ****************************************************************************/

/*
 * This object is already initialized
 */
#define DDERR_ALREADYINITIALIZED                MAKE_DDHRESULT( 5 )

/*
 * This surface can not be attached to the requested surface.
 */
#define DDERR_CANNOTATTACHSURFACE               MAKE_DDHRESULT( 10 )

/*
 * This surface can not be detached from the requested surface.
 */
#define DDERR_CANNOTDETACHSURFACE               MAKE_DDHRESULT( 20 )

/*
 * Support is currently not available.
 */
#define DDERR_CURRENTLYNOTAVAIL                 MAKE_DDHRESULT( 40 )

/*
 * An exception was encountered while performing the requested operation
 */
#define DDERR_EXCEPTION                         MAKE_DDHRESULT( 55 )

/*
 * Generic failure.
 */
#define DDERR_GENERIC                           E_FAIL

/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */
#define DDERR_HEIGHTALIGN                       MAKE_DDHRESULT( 90 )

/*
 * Unable to match primary surface creation request with existing
 * primary surface.
 */
#define DDERR_INCOMPATIBLEPRIMARY               MAKE_DDHRESULT( 95 )

/*
 * One or more of the caps bits passed to the callback are incorrect.
 */
#define DDERR_INVALIDCAPS                       MAKE_DDHRESULT( 100 )

/*
 * DirectDraw does not support provided Cliplist.
 */
#define DDERR_INVALIDCLIPLIST                   MAKE_DDHRESULT( 110 )

/*
 * DirectDraw does not support the requested mode
 */
#define DDERR_INVALIDMODE                       MAKE_DDHRESULT( 120 )

/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */
#define DDERR_INVALIDOBJECT                     MAKE_DDHRESULT( 130 )

/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */
#define DDERR_INVALIDPARAMS                     E_INVALIDARG

/*
 * pixel format was invalid as specified
 */
#define DDERR_INVALIDPIXELFORMAT                MAKE_DDHRESULT( 145 )

/*
 * Rectangle provided was invalid.
 */
#define DDERR_INVALIDRECT                       MAKE_DDHRESULT( 150 )

/*
 * Operation could not be carried out because one or more surfaces are locked
 */
#define DDERR_LOCKEDSURFACES                    MAKE_DDHRESULT( 160 )

/*
 * There is no 3D present.
 */
#define DDERR_NO3D                              MAKE_DDHRESULT( 170 )

/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */
#define DDERR_NOALPHAHW                         MAKE_DDHRESULT( 180 )

/*
 * Operation could not be carried out because there is no stereo
 * hardware present or available.
 */
#define DDERR_NOSTEREOHARDWARE          MAKE_DDHRESULT( 181 )

/*
 * Operation could not be carried out because there is no hardware
 * present which supports stereo surfaces
 */
#define DDERR_NOSURFACELEFT                             MAKE_DDHRESULT( 182 )


// @@BEGIN_MSINTERNAL
/*
 * Operation could not be carried out because there is no hardware support
 * for synchronizing blts to avoid tearing.
 */
#define DDERR_NOANTITEARHW                      MAKE_DDHRESULT( 190 )

/*
 * Operation could not be carried out because there is no hardware support
 * for asynchronous blting.
 */
#define DDERR_NOBLTQUEUEHW                      MAKE_DDHRESULT( 200 )
// @@END_MSINTERNAL

/*
 * no clip list available
 */
#define DDERR_NOCLIPLIST                        MAKE_DDHRESULT( 205 )

/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */
#define DDERR_NOCOLORCONVHW                     MAKE_DDHRESULT( 210 )

/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */
#define DDERR_NOCOOPERATIVELEVELSET             MAKE_DDHRESULT( 212 )

/*
 * Surface doesn't currently have a color key
 */
#define DDERR_NOCOLORKEY                        MAKE_DDHRESULT( 215 )

/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */
#define DDERR_NOCOLORKEYHW                      MAKE_DDHRESULT( 220 )

/*
 * No DirectDraw support possible with current display driver
 */
#define DDERR_NODIRECTDRAWSUPPORT               MAKE_DDHRESULT( 222 )

/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */
#define DDERR_NOEXCLUSIVEMODE                   MAKE_DDHRESULT( 225 )

/*
 * Flipping visible surfaces is not supported.
 */
#define DDERR_NOFLIPHW                          MAKE_DDHRESULT( 230 )

/*
 * There is no GDI present.
 */
#define DDERR_NOGDI                             MAKE_DDHRESULT( 240 )

/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */
#define DDERR_NOMIRRORHW                        MAKE_DDHRESULT( 250 )

/*
 * Requested item was not found
 */
#define DDERR_NOTFOUND                          MAKE_DDHRESULT( 255 )

/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */
#define DDERR_NOOVERLAYHW                       MAKE_DDHRESULT( 260 )

/*
 * Operation could not be carried out because the source and destination
 * rectangles are on the same surface and overlap each other.
 */
#define DDERR_OVERLAPPINGRECTS                  MAKE_DDHRESULT( 270 )

/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */
#define DDERR_NORASTEROPHW                      MAKE_DDHRESULT( 280 )

/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */
#define DDERR_NOROTATIONHW                      MAKE_DDHRESULT( 290 )

/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */
#define DDERR_NOSTRETCHHW                       MAKE_DDHRESULT( 310 )

/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */
#define DDERR_NOT4BITCOLOR                      MAKE_DDHRESULT( 316 )

/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */
#define DDERR_NOT4BITCOLORINDEX                 MAKE_DDHRESULT( 317 )

/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */
#define DDERR_NOT8BITCOLOR                      MAKE_DDHRESULT( 320 )

/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */
#define DDERR_NOTEXTUREHW                       MAKE_DDHRESULT( 330 )

/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */
#define DDERR_NOVSYNCHW                         MAKE_DDHRESULT( 335 )

/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */
#define DDERR_NOZBUFFERHW                       MAKE_DDHRESULT( 340 )

/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */
#define DDERR_NOZOVERLAYHW                      MAKE_DDHRESULT( 350 )

/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */
#define DDERR_OUTOFCAPS                         MAKE_DDHRESULT( 360 )

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFMEMORY                       E_OUTOFMEMORY

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFVIDEOMEMORY                  MAKE_DDHRESULT( 380 )

/*
 * hardware does not support clipped overlays
 */
#define DDERR_OVERLAYCANTCLIP                   MAKE_DDHRESULT( 382 )

/*
 * Can only have ony color key active at one time for overlays
 */
#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE      MAKE_DDHRESULT( 384 )

/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */
#define DDERR_PALETTEBUSY                       MAKE_DDHRESULT( 387 )

/*
 * No src color key specified for this operation.
 */
#define DDERR_COLORKEYNOTSET                    MAKE_DDHRESULT( 400 )

/*
 * This surface is already attached to the surface it is being attached to.
 */
#define DDERR_SURFACEALREADYATTACHED            MAKE_DDHRESULT( 410 )

/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */
#define DDERR_SURFACEALREADYDEPENDENT           MAKE_DDHRESULT( 420 )

/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */
#define DDERR_SURFACEBUSY                       MAKE_DDHRESULT( 430 )

/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 * Will also happen on attempts to lock an optimized surface.
 */
#define DDERR_CANTLOCKSURFACE                   MAKE_DDHRESULT( 435 )

/*
 * Access to Surface refused because Surface is obscured.
 */
#define DDERR_SURFACEISOBSCURED                 MAKE_DDHRESULT( 440 )

/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should
 * have Restore called on it.
 */
#define DDERR_SURFACELOST                       MAKE_DDHRESULT( 450 )

/*
 * The requested surface is not attached.
 */
#define DDERR_SURFACENOTATTACHED                MAKE_DDHRESULT( 460 )

/*
 * Height requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGHEIGHT                      MAKE_DDHRESULT( 470 )

/*
 * Size requested by DirectDraw is too large --  The individual height and
 * width are OK.
 */
#define DDERR_TOOBIGSIZE                        MAKE_DDHRESULT( 480 )

/*
 * Width requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGWIDTH                       MAKE_DDHRESULT( 490 )

/*
 * Action not supported.
 */
#define DDERR_UNSUPPORTED                       E_NOTIMPL

/*
 * Pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDFORMAT                 MAKE_DDHRESULT( 510 )

/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDMASK                   MAKE_DDHRESULT( 520 )

/*
 * The specified stream contains invalid data
 */
#define DDERR_INVALIDSTREAM                     MAKE_DDHRESULT( 521 )

/*
 * vertical blank is in progress
 */
#define DDERR_VERTICALBLANKINPROGRESS           MAKE_DDHRESULT( 537 )

/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */
#define DDERR_WASSTILLDRAWING                   MAKE_DDHRESULT( 540 )

// @@BEGIN_MSINTERNAL

/*
 * NT specific: VisRgn changed and must be reset before call can be
 * completed.
 */
#define DDERR_VISRGNCHANGED             MAKE_DDHRESULT( 541 )

// @@END_MSINTERNAL

/*
 * The specified surface type requires specification of the COMPLEX flag
 */
#define DDERR_DDSCAPSCOMPLEXREQUIRED            MAKE_DDHRESULT( 542 )


/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */
#define DDERR_XALIGN                            MAKE_DDHRESULT( 560 )

/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */
#define DDERR_INVALIDDIRECTDRAWGUID             MAKE_DDHRESULT( 561 )

/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */
#define DDERR_DIRECTDRAWALREADYCREATED          MAKE_DDHRESULT( 562 )

/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */
#define DDERR_NODIRECTDRAWHW                    MAKE_DDHRESULT( 563 )

/*
 * this process already has created a primary surface
 */
#define DDERR_PRIMARYSURFACEALREADYEXISTS       MAKE_DDHRESULT( 564 )

/*
 * software emulation not available.
 */
#define DDERR_NOEMULATION                       MAKE_DDHRESULT( 565 )

/*
 * region passed to Clipper::GetClipList is too small.
 */
#define DDERR_REGIONTOOSMALL                    MAKE_DDHRESULT( 566 )

/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */
#define DDERR_CLIPPERISUSINGHWND                MAKE_DDHRESULT( 567 )

/*
 * No clipper object attached to surface object
 */
#define DDERR_NOCLIPPERATTACHED                 MAKE_DDHRESULT( 568 )

/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */
#define DDERR_NOHWND                            MAKE_DDHRESULT( 569 )

/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */
#define DDERR_HWNDSUBCLASSED                    MAKE_DDHRESULT( 570 )

/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */
#define DDERR_HWNDALREADYSET                    MAKE_DDHRESULT( 571 )

/*
 * No palette object attached to this surface.
 */
#define DDERR_NOPALETTEATTACHED                 MAKE_DDHRESULT( 572 )

/*
 * No hardware support for 16 or 256 color palettes.
 */
#define DDERR_NOPALETTEHW                       MAKE_DDHRESULT( 573 )

/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */
#define DDERR_BLTFASTCANTCLIP                   MAKE_DDHRESULT( 574 )

/*
 * No blter.
 */
#define DDERR_NOBLTHW                           MAKE_DDHRESULT( 575 )

/*
 * No DirectDraw ROP hardware.
 */
#define DDERR_NODDROPSHW                        MAKE_DDHRESULT( 576 )

/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */
#define DDERR_OVERLAYNOTVISIBLE                 MAKE_DDHRESULT( 577 )

/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */
#define DDERR_NOOVERLAYDEST                     MAKE_DDHRESULT( 578 )

/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */
#define DDERR_INVALIDPOSITION                   MAKE_DDHRESULT( 579 )

/*
 * returned when an overlay member is called for a non-overlay surface
 */
#define DDERR_NOTAOVERLAYSURFACE                MAKE_DDHRESULT( 580 )

/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */
#define DDERR_EXCLUSIVEMODEALREADYSET           MAKE_DDHRESULT( 581 )

/*
 * An attempt has been made to flip a surface that is not flippable.
 */
#define DDERR_NOTFLIPPABLE                      MAKE_DDHRESULT( 582 )

/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */
#define DDERR_CANTDUPLICATE                     MAKE_DDHRESULT( 583 )

/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */
#define DDERR_NOTLOCKED                         MAKE_DDHRESULT( 584 )

/*
 * Windows can not create any more DCs, or a DC was requested for a paltte-indexed
 * surface when the surface had no palette AND the display mode was not palette-indexed
 * (in this case DirectDraw cannot select a proper palette into the DC)
 */
#define DDERR_CANTCREATEDC                      MAKE_DDHRESULT( 585 )

/*
 * No DC was ever created for this surface.
 */
#define DDERR_NODC                              MAKE_DDHRESULT( 586 )

/*
 * This surface can not be restored because it was created in a different
 * mode.
 */
#define DDERR_WRONGMODE                         MAKE_DDHRESULT( 587 )

/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */
#define DDERR_IMPLICITLYCREATED                 MAKE_DDHRESULT( 588 )

/*
 * The surface being used is not a palette-based surface
 */
#define DDERR_NOTPALETTIZED                     MAKE_DDHRESULT( 589 )


/*
 * The display is currently in an unsupported mode
 */
#define DDERR_UNSUPPORTEDMODE                   MAKE_DDHRESULT( 590 )

/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */
#define DDERR_NOMIPMAPHW                        MAKE_DDHRESULT( 591 )

/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */
#define DDERR_INVALIDSURFACETYPE                MAKE_DDHRESULT( 592 )

// @@BEGIN_MSINTERNAL
/*
 * Operation could not be carried out because there is no hardware support
 * for execute buffers.
 */
#define DDERR_NOEXECUTEBUFFERHW                 MAKE_DDHRESULT( 593 )
// @@END_MSINTERNAL

// @@BEGIN_MSINTERNAL
#ifdef SHAREDZ

/*
 * This process has already created a shared Z buffer
 */
#define DDERR_SHAREDZBUFFERALREADYEXISTS        MAKE_DDHRESULT( 594 )

/*
 * Unable to match shared Z buffer creation request with existing
 * shared Z buffer.
 */
#define DDERR_INCOMPATIBLESHAREDZBUFFER         MAKE_DDHRESULT( 595 )

/*
 * This process has already created a shared backbuffer
 */
#define DDERR_SHAREDBACKBUFFERALREADYEXISTS     MAKE_DDHRESULT( 596 )

/*
 * Unable to match shared backbuffer creation request with existing
 * shared backbuffer.
 */
#define DDERR_INCOMPATIBLESHAREDBACKBUFFER      MAKE_DDHRESULT( 597 )

/*
 * Operation could not be carried out because there is no hardware support
 * for shared Z buffers.
 */
#define DDERR_NOSHAREDZBUFFERHW                 MAKE_DDHRESULT( 598 )

/*
 * Operation could not be carried out because there is no hardware support
 * for shared backbuffers.
 */
#define DDERR_NOSHAREDBACKBUFFERHW              MAKE_DDHRESULT( 599 )

#endif
// @@END_MSINTERNAL

/*
 * Device does not support optimized surfaces, therefore no video memory optimized surfaces
 */
#define DDERR_NOOPTIMIZEHW                      MAKE_DDHRESULT( 600 )

/*
 * Surface is an optimized surface, but has not yet been allocated any memory
 */
#define DDERR_NOTLOADED                         MAKE_DDHRESULT( 601 )

/*
 * Attempt was made to create or set a device window without first setting
 * the focus window
 */
#define DDERR_NOFOCUSWINDOW                     MAKE_DDHRESULT( 602 )

/*
 * Attempt was made to set a palette on a mipmap sublevel
 */
#define DDERR_NOTONMIPMAPSUBLEVEL               MAKE_DDHRESULT( 603 )

/*
 * A DC has already been returned for this surface. Only one DC can be
 * retrieved per surface.
 */
#define DDERR_DCALREADYCREATED                  MAKE_DDHRESULT( 620 )

/*
 * An attempt was made to allocate non-local video memory from a device
 * that does not support non-local video memory.
 */
#define DDERR_NONONLOCALVIDMEM                  MAKE_DDHRESULT( 630 )

/*
 * The attempt to page lock a surface failed.
 */
#define DDERR_CANTPAGELOCK                      MAKE_DDHRESULT( 640 )

//@@BEGIN_MSINTERNAL
/*
 * The GUID is not recognized by the driver. In case of Optimized Surfaces,
 * this GUID represents the compresison technique requested.
 */
#define DDERR_UNRECOGNIZEDGUID                  MAKE_DDHRESULT( 650 )

/*
 * The driver does not support Optimized Surfaces
 */
#define DDERR_NOOPTSURFACESUPPORT       MAKE_DDHRESULT( 651 )

/*
 * The surface is not an optimized surface
 */
#define DDERR_NOTANOPTIMIZEDSURFACE     MAKE_DDHRESULT( 652 )

/*
 * The surface is an empty optimized surface
 */
#define DDERR_ISANEMPTYOPTIMIZEDSURFACE         MAKE_DDHRESULT( 653 )

/*
 * The surface is not an empty optimized surface
 */
#define DDERR_NOTANEMPTYOPTIMIZEDSURFACE        MAKE_DDHRESULT( 654 )

/*
 * The surface is optimized
 */
#define DDERR_ISOPTIMIZEDSURFACE        MAKE_DDHRESULT( 655 )
//@@END_MSINTERNAL

/*
 * The attempt to page unlock a surface failed.
 */
#define DDERR_CANTPAGEUNLOCK                    MAKE_DDHRESULT( 660 )

/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */
#define DDERR_NOTPAGELOCKED                     MAKE_DDHRESULT( 680 )

/*
 * There is more data available than the specified buffer size could hold
 */
#define DDERR_MOREDATA                          MAKE_DDHRESULT( 690 )

/*
 * The data has expired and is therefore no longer valid.
 */
#define DDERR_EXPIRED                           MAKE_DDHRESULT( 691 )

/*
 * The mode test has finished executing.
 */
#define DDERR_TESTFINISHED                      MAKE_DDHRESULT( 692 )

/*
 * The mode test has switched to a new mode.
 */
#define DDERR_NEWMODE                           MAKE_DDHRESULT( 693 )

/*
 * D3D has not yet been initialized.
 */
#define DDERR_D3DNOTINITIALIZED                 MAKE_DDHRESULT( 694 )

/*
 * The video port is not active
 */
#define DDERR_VIDEONOTACTIVE                    MAKE_DDHRESULT( 695 )

/*
 * The monitor does not have EDID data.
 */
#define DDERR_NOMONITORINFORMATION              MAKE_DDHRESULT( 696 )

/*
 * The driver does not enumerate display mode refresh rates.
 */
#define DDERR_NODRIVERSUPPORT                   MAKE_DDHRESULT( 697 )

/*
 * Surfaces created by one direct draw device cannot be used directly by
 * another direct draw device.
 */
#define DDERR_DEVICEDOESNTOWNSURFACE            MAKE_DDHRESULT( 699 )


//@@BEGIN_MSINTERNAL
/*=======================================================================
 * DANGER WIL ROBINSON! D3D errors begin at 700... take care not to
 * step on D3dD's toes when defining new ddraw errors.
 *=======================================================================*/
/****************************************************************************
 *
 * end of DIRECTDRAW ERRORS
 *
 * NOTE: To avoid collision with other DX APIs, DDraw uses error codes
 *       [5-699] and [1024-2048].
 *
 ****************************************************************************/
//@@END_MSINTERNAL

/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */
#define DDERR_NOTINITIALIZED                    CO_E_NOTINITIALIZED


/* Alpha bit depth constants */

//@@BEGIN_MSINTERNAL
/*
 * 1 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not affect
 * the final result.
 */
#define DDALPHA1_TRANSPARENT                    0

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA1_OPAQUE                         1

/*
 * 2 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA2_TRANSPARENT                    0

/*
 * 50-50 blend.  Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA2_50                             2

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA2_OPAQUE                         3

/*
 * 4 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA4_TRANSPARENT                    0

/*
 * Opaque modifier is multiplied by any value between 0 and _OPAQUE to
 * establish gradients of alpha blending.
 */
#define DDALPHA4_OPAQUEMOD                      1

/*
 * 50-50 blend.  Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA4_50                             8

/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA4_OPAQUE                         15

/*
 * 8 bit alpha constants
 */

/*
 * Completely transparent. Colors being blended with this constant do not effect
 * the final result.
 */
#define DDALPHA8_TRANSPARENT                    0

/*
 * Opaque modifier is multiplied by any value between 0 and _OPAQUE to
 * establish gradients of alpha blending.
 */
#define DDALPHA8_OPAQUEMOD                      1

/*
 * 50-50 blend.  Colors being blended with this constant effect the final result
 * with 50% of their color.
 */
#define DDALPHA8_50                             128
/*
 * Completely opaque. Colors being blended with this constant are the final result.
 */
#define DDALPHA8_OPAQUE                         255
//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif

#ifdef ENABLE_NAMELESS_UNION_PRAGMA
#pragma warning(default:4201)
#endif

#endif //__DDRAW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\ddmc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE7    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE7    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->lpVtbl->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE7, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\ddmcp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-sep-97	smac
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE7    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE7    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->lpVtbl->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE7, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\dinputp.h ===
//GUID_FILEEFFECT is used to establish a effect file version
//beta file format different from final, so have different GUID
DEFINE_GUID(GUID_INTERNALFILEEFFECTBETA,0X981DC402, 0X880, 0X11D3, 0X8F, 0XB2, 0X0, 0XC0, 0X4F, 0X8E, 0XC6, 0X27);
//final for DX7 {197E775C-34BA-11d3-ABD5-00C04F8EC627}
DEFINE_GUID(GUID_INTERNALFILEEFFECT, 0x197e775c, 0x34ba, 0x11d3, 0xab, 0xd5, 0x0, 0xc0, 0x4f, 0x8e, 0xc6, 0x27);
#if DIRECTINPUT_VERSION <= 0x0300
/*
 *  Old GUIDs from DX3 that were never used but which we can't recycle
 *  because we shipped them.
 */
DEFINE_GUID(GUID_RAxis,   0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_UAxis,   0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_VAxis,   0xA36D02E5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
#endif
#define DIEFT_PREDEFMIN             0x00000001
#define DIEFT_PREDEFMAX             0x00000005
//#define DIEFT_PREDEFMAX             0x00000006
#define DIEFT_TYPEMASK              0x000000FF

#define DIEFT_FORCEFEEDBACK         0x00000100
#define DIEFT_VALIDFLAGS            0x0000FE00
#define DIEFT_ENUMVALID             0x040000FF
/*
 *  Name for the latest structures, in places where we specifically care.
 */
#if (DIRECTINPUT_VERSION >= 900)
typedef       DIEFFECT      DIEFFECT_DX9;
typedef       DIEFFECT   *LPDIEFFECT_DX9;
#else
typedef       DIEFFECT      DIEFFECT_DX6;
typedef       DIEFFECT   *LPDIEFFECT_DX6;
#endif

BOOL static __inline
IsValidSizeDIEFFECT(DWORD cb)
{
    return cb == sizeof(DIEFFECT_DX6)
        || cb == sizeof(DIEFFECT_DX5);
}


#define DIEFFECT_MAXAXES            32
#define DIEFF_OBJECTMASK            0x00000003
#define DIEFF_ANGULAR               0x00000060
#define DIEFF_COORDMASK             0x00000070
#define DIEFF_REGIONANGULAR         0x00006000
#define DIEFF_REGIONCOORDMASK       0x00007000

#define DIEFF_VALID                 0x00000073
#define DIEP_GETVALID_DX5           0x000001FF
#define DIEP_SETVALID_DX5           0xE00001FF
#define DIEP_GETVALID               0x000003FF
#define DIEP_SETVALID               0xE00003FF
#define DIEP_USESOBJECTS            0x00000028
#define DIEP_USESCOORDS             0x00000040
#define DIES_VALID                  0x80000001
#define DIES_DRIVER                 0x00000001
#define DIDEVTYPE_MAX           5
#define DI8DEVCLASS_MAX             5
#define DI8DEVTYPE_MIN              0x11
#define DI8DEVTYPE_GAMEMIN          0x14
#define DI8DEVTYPE_GAMEMAX          0x19
#define DI8DEVTYPE_MAX              0x1D
#define DIDEVTYPE_TYPEMASK      0x000000FF
#define DIDEVTYPE_SUBTYPEMASK   0x0000FF00
#define DIDEVTYPE_ENUMMASK      0xFFFFFF00
#define DIDEVTYPE_ENUMVALID     0x00010000
#define DIDEVTYPE_RANDOM        0x80000000
#define DI8DEVTYPEMOUSE_MIN                         1
#define DI8DEVTYPEMOUSE_MAX                         7
#define DI8DEVTYPEMOUSE_MIN_BUTTONS                 0
#define DI8DEVTYPEMOUSE_MIN_CAPS                    0
#define DI8DEVTYPEKEYBOARD_MIN                      0
#define DI8DEVTYPEKEYBOARD_MAX                     13
#define DI8DEVTYPEKEYBOARD_MIN_BUTTONS              0
#define DI8DEVTYPEKEYBOARD_MIN_CAPS                 0
#define DI8DEVTYPEJOYSTICK_MIN                      DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEJOYSTICK_MAX                      3
#define DI8DEVTYPEJOYSTICK_MIN_BUTTONS              5
#define DI8DEVTYPEJOYSTICK_MIN_CAPS                 ( JOY_HWS_HASPOV | JOY_HWS_HASZ )
#define DI8DEVTYPEGAMEPAD_MIN                       DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEGAMEPAD_MAX                       5
#define DI8DEVTYPEGAMEPAD_MIN_BUTTONS               6
#define DI8DEVTYPEGAMEPAD_MIN_CAPS                  0
#define DI8DEVTYPEDRIVING_MIN                       DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEDRIVING_MAX                       6
#define DI8DEVTYPEDRIVING_MIN_BUTTONS               4
#define DI8DEVTYPEDRIVING_MIN_CAPS                  0
#define DI8DEVTYPEFLIGHT_MIN                        DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEFLIGHT_MAX                        5
#define DI8DEVTYPEFLIGHT_MIN_BUTTONS                4
#define DI8DEVTYPEFLIGHT_MIN_CAPS                   ( JOY_HWS_HASPOV | JOY_HWS_HASZ )
#define DI8DEVTYPE1STPERSON_MIN                     DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPE1STPERSON_MAX                     5
#define DI8DEVTYPE1STPERSON_MIN_BUTTONS             4
#define DI8DEVTYPE1STPERSON_MIN_CAPS                0
#define DI8DEVTYPESCREENPTR_MIN                     2
#define DI8DEVTYPESCREENPTR_MAX                     6
#define DI8DEVTYPESCREENPTR_MIN_BUTTONS             0
#define DI8DEVTYPESCREENPTR_MIN_CAPS                0
#define DI8DEVTYPEREMOTE_MIN                        2
#define DI8DEVTYPEREMOTE_MAX                        3
#define DI8DEVTYPEREMOTE_MIN_BUTTONS                0
#define DI8DEVTYPEREMOTE_MIN_CAPS                   0
#define DI8DEVTYPEDEVICECTRL_MIN                    2
#define DI8DEVTYPEDEVICECTRL_MAX                    5
#define DI8DEVTYPEDEVICECTRL_MIN_BUTTONS            0
#define DI8DEVTYPEDEVICECTRL_MIN_CAPS               0
#define DI8DEVTYPESUPPLEMENTAL_MIN                  2
#define DI8DEVTYPESUPPLEMENTAL_MAX                 14
#define DI8DEVTYPESUPPLEMENTAL_MIN_BUTTONS         0
#define DI8DEVTYPESUPPLEMENTAL_MIN_CAPS            0
#define MAKE_DIDEVICE_TYPE(maj, min)    MAKEWORD(maj, min) //
#define GET_DIDEVICE_TYPEANDSUBTYPE(dwDevType)    LOWORD(dwDevType) //
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVCAPS     DIDEVCAPS_DX5;
typedef       DIDEVCAPS  *LPDIDEVCAPS_DX5;

BOOL static __inline
IsValidSizeDIDEVCAPS(DWORD cb)
{
    return cb == sizeof(DIDEVCAPS_DX5) ||
           cb == sizeof(DIDEVCAPS_DX3);
}

/* Force feedback bits live in the high byte, to keep them together */
#define DIDC_FFFLAGS            0x0000FF00
/*
 * Flags in the upper word mark devices normally excluded from enumeration.
 * To force enumeration of the device, you must pass the appropriate
 * DIEDFL_* flag.
 */
#define DIDC_EXCLUDEMASK        0x00FF0000
#define DIDC_RANDOM             0x80000000              //
#define DIDFT_RESERVEDTYPES 0x00000020      //
                                            //
#define DIDFT_DWORDOBJS     0x00000013      //
#define DIDFT_BYTEOBJS      0x0000000C      //
#define DIDFT_CONTROLOBJS   0x0000001F      //
#define DIDFT_ALLOBJS_DX3   0x0000001F      //
#define DIDFT_ALLOBJS       0x000000DF      //
#define DIDFT_TYPEMASK      0x000000FF
#define DIDFT_TYPEVALID     DIDFT_TYPEMASK   //
#define DIDFT_FINDMASK      0x00FFFFFF  //
#define DIDFT_FINDMATCH(n,m) ((((n)^(m)) & DIDFT_FINDMASK) == 0)

                                            //
/*                                          //
 *  DIDFT_OPTIONAL means that the           //
 *  SetDataFormat should ignore the         //
 *  field if the device does not            //
 *  support the object.                     //
 */                                         //
#define DIDFT_OPTIONAL          0x80000000  //
#define DIDFT_BESTFIT           0x40000000  //
#define DIDFT_RANDOM            0x20000000  //
#define DIDFT_ATTRVALID         0x1f000000
#if 0   // Disable the next line if building 5a
#endif
#define DIDFT_ATTRMASK          0xFF000000
#define DIDFT_ALIASATTRMASK     0x0C000000
#define DIDFT_GETATTR(n)    ((DWORD)(n) >> 24)
#define DIDFT_MAKEATTR(n)   ((BYTE)(n)  << 24)
#define DIDFT_GETCOLLECTION(n)  LOWORD((n) >> 8)
#define DIDFT_ENUMVALID                   \
        (DIDFT_ATTRVALID | DIDFT_ANYINSTANCE | DIDFT_ALLOBJS)
#define DIDF_VALID              0x00000003  //
#define DIA_VALID               0x0000001F
#define DIAH_OTHERAPP           0x00000010
#define DIAH_MAPMASK            0x0000003F
#define DIAH_VALID              0x8000003F
#define DIDBAM_VALID            0x00000007
#define DIDSAM_VALID            0x00000003
#define DICD_VALID              0x00000001
#define DIDIFTT_VALID           0x00000003
/*#define DIDIFT_DELETE           0x01000000 defined in dinput.w*/
#define DIDIFT_VALID            ( DIDIFTT_VALID)
#define DIDAL_VALID         0x0000000F  //
#define HAVE_DIDEVICEOBJECTINSTANCE_DX5
typedef       DIDEVICEOBJECTINSTANCEA    DIDEVICEOBJECTINSTANCE_DX5A;
typedef       DIDEVICEOBJECTINSTANCEW    DIDEVICEOBJECTINSTANCE_DX5W;
typedef       DIDEVICEOBJECTINSTANCE     DIDEVICEOBJECTINSTANCE_DX5;
typedef       DIDEVICEOBJECTINSTANCEA *LPDIDEVICEOBJECTINSTANCE_DX5A;
typedef       DIDEVICEOBJECTINSTANCEW *LPDIDEVICEOBJECTINSTANCE_DX5W;
typedef       DIDEVICEOBJECTINSTANCE  *LPDIDEVICEOBJECTINSTANCE_DX5;
typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCE_DX5A;
typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCE_DX5W;
typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE_DX5;

BOOL static __inline
IsValidSizeDIDEVICEOBJECTINSTANCEW(DWORD cb)
{
    return cb == sizeof(DIDEVICEOBJECTINSTANCE_DX5W) ||
           cb == sizeof(DIDEVICEOBJECTINSTANCE_DX3W);
}

BOOL static __inline
IsValidSizeDIDEVICEOBJECTINSTANCEA(DWORD cb)
{
    return cb == sizeof(DIDEVICEOBJECTINSTANCE_DX5A) ||
           cb == sizeof(DIDEVICEOBJECTINSTANCE_DX3A);
}

#define DIDOI_NOTINPUT          0x80000000
#define DIDOI_ASPECTUNKNOWN     0x00000000
#define DIDOI_RANDOM            0x80000000
typedef struct DIIMAGELABEL {
    RECT    MaxStringExtent;
    DWORD   dwFlags;
    POINT   Line[10];
    DWORD   dwLineCount;
    WCHAR   wsz[MAX_PATH];
} DIIMAGELABEL, *LPDIIMAGELABEL;
typedef const DIIMAGELABEL *LPCDIIMAGELABEL;


#if(DIRECTINPUT_VERSION >= 0x0800)
typedef struct DIPROPGUID {
    DIPROPHEADER diph;
    GUID guid;
} DIPROPGUID, *LPDIPROPGUID;
typedef const DIPROPGUID *LPCDIPROPGUID;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#if(DIRECTINPUT_VERSION >= 0x0800)
typedef struct DIPROPFILETIME {
    DIPROPHEADER diph;
    FILETIME time;
} DIPROPFILETIME, *LPDIPROPFILETIME;
typedef const DIPROPFILETIME *LPCDIPROPFILETIME;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
#define DIPROPAXISMODE_VALID    1   //
#define ISVALIDGAIN(n)          (HIWORD(n) == 0)
#define DIPROPAUTOCENTER_VALID  1
#define DIPROPCALIBRATIONMODE_VALID     1
#define DIPROP_ENABLEREPORTID       MAKEDIPROP(0xFFFB)


// now unused, may be replaced DIPROP_IMAGEFILE MAKEDIPROP(0xFFFC)

#define DIPROP_MAPFILE MAKEDIPROP(0xFFFD)//

#define DIPROP_SPECIFICCALIBRATION MAKEDIPROP(0xFFFE)//

#define DIPROP_MAXBUFFERSIZE    MAKEDIPROP(0xFFFF) //

#define DEVICE_MAXBUFFERSIZE    1023               //
#define DIGDD_RESIDUAL      0x00000002  //
#define DIGDD_VALID         0x00000003  //
#define DISCL_EXCLMASK      0x00000003  //
#define DISCL_GROUNDMASK    0x0000000C  //
#define DISCL_VALID         0x0000001F  //
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVICEINSTANCEA    DIDEVICEINSTANCE_DX5A;
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVICEINSTANCEW    DIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef DIDEVICEINSTANCE_DX5W DIDEVICEINSTANCE_DX5;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef DIDEVICEINSTANCE_DX5A DIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef       DIDEVICEINSTANCE     DIDEVICEINSTANCE_DX5;
typedef       DIDEVICEINSTANCEA *LPDIDEVICEINSTANCE_DX5A;
typedef       DIDEVICEINSTANCEW *LPDIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef LPDIDEVICEINSTANCE_DX5W LPDIDEVICEINSTANCE_DX5;
#else
typedef LPDIDEVICEINSTANCE_DX5A LPDIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef       DIDEVICEINSTANCE  *LPDIDEVICEINSTANCE_DX5;
typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCE_DX5A;
typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCE_DX5W LPCDIDEVICEINSTANCE_DX5;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCE_DX5A LPCDIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE_DX5;

BOOL static __inline
IsValidSizeDIDEVICEINSTANCEW(DWORD cb)
{
    return cb == sizeof(DIDEVICEINSTANCE_DX5W) ||
           cb == sizeof(DIDEVICEINSTANCE_DX3W);
}

BOOL static __inline
IsValidSizeDIDEVICEINSTANCEA(DWORD cb)
{
    return cb == sizeof(DIDEVICEINSTANCE_DX5A) ||
           cb == sizeof(DIDEVICEINSTANCE_DX3A);
}

#define DIRCP_MODAL         0x00000001  //
#define DIRCP_VALID         0x00000000  //
#define DISFFC_NULL             0x00000000
#define DISFFC_VALID            0x0000003F
#define DISFFC_FORCERESET       0x80000000
#define DIGFFS_RANDOM           0x40000000
#define DISDD_VALID             0x00000001
#define DIECEFL_VALID       0x00000000
#define DIFEF_ENUMVALID             0x00000011
#define DIFEF_WRITEVALID            0x00000001
#if DIRECTINPUT_VERSION >= 0x0700           //
#define DIMOUSESTATE_INT DIMOUSESTATE2      //
#define LPDIMOUSESTATE_INT LPDIMOUSESTATE2  //
#else                                       //
#define DIMOUSESTATE_INT DIMOUSESTATE       //
#define LPDIMOUSESTATE_INT LPDIMOUSESTATE   //
#endif                                      //
#define DIKBD_CKEYS         256     /* Size of buffers */       //
                                                                //
//  NT puts them here in their keyboard driver              
//  So keep them in the same place to avoid problems later
#define DIK_F16             0x67    //
#define DIK_F17             0x68    //
#define DIK_F18             0x69    //
#define DIK_F19             0x6A    //
#define DIK_F20             0x6B    //
#define DIK_F21             0x6C    //
#define DIK_F22             0x6D    //
#define DIK_F23             0x6E    //
#define DIK_F24             0x76    //
#define DIK_SHARP           0x84    /* Hash-mark                      */
//k_def(DIK_SNAPSHOT       ,0xC5)    /* Print Screen */
#define DIK_PRTSC           DIK_SNAPSHOT        /* Print Screen */
#define DIEDFL_INCLUDEMASK      0x00FF0000
#define DIEDFL_VALID            0x00030101
#if DIRECTINPUT_VERSION > 0x700
#define DIEDFL_VALID_DX5        0x00030101
#undef  DIEDFL_VALID
#define DIEDFL_VALID            0x00070101
#endif /* DIRECTINPUT_VERSION > 0x700 */
/********************************************************************************************
| Decoding a semantic
|            :           |           :           |           :           |           :
| 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
|PHY <      Genre       > <  Reserved   ><  Flags  > Pri<Group > <Typ> A/R<    Control Index    >
|
| PHY: Genre refers to a physical device
| Genre: Genre# (1-128)
| A/R - Axis mode ( 0 - Absolute,   1 - Relative )
| Pri - Priority  ( 0 - Priority 1, 1 - Priority 2 )
|
|
*IMPORTANT: The Mapper UI uses some of the masks generated by M4. If you change any of the 
 	    masks or Flags please make sure that the changes are also made to the the Mapper UI
            #defines. 
********************************************************************************************/
#define DISEM_GENRE_SET(x)                      ( ( (BYTE)(x)<<24 ) & 0xFF000000 ) 
#define DISEM_GENRE_GET(x)                      ((BYTE)( ( (x) & 0xFF000000 )>>24 )) 
#define DISEM_GENRE_MASK                        ( 0xFF000000 )
#define DISEM_GENRE_SHIFT                       ( 24 ) 
#define DISEM_PHYSICAL_SET(x)                   ( ( (BYTE)(x)<<31 ) & 0x80000000 ) 
#define DISEM_PHYSICAL_GET(x)                   ((BYTE)( ( (x) & 0x80000000 )>>31 )) 
#define DISEM_PHYSICAL_MASK                     ( 0x80000000 )
#define DISEM_PHYSICAL_SHIFT                    ( 31 ) 
#define DISEM_VIRTUAL_SET(x)                    ( ( (BYTE)(x)<<24 ) & 0x7F000000 ) 
#define DISEM_VIRTUAL_GET(x)                    ((BYTE)( ( (x) & 0x7F000000 )>>24 )) 
#define DISEM_VIRTUAL_MASK                      ( 0x7F000000 )
#define DISEM_VIRTUAL_SHIFT                     ( 24 ) 
#define DISEM_RES_SET(x)                        ( ( (BYTE)(x)<<19 ) & 0x00F80000 ) 
#define DISEM_RES_GET(x)                        ((BYTE)( ( (x) & 0x00F80000 )>>19 )) 
#define DISEM_RES_MASK                          ( 0x00F80000 )
#define DISEM_RES_SHIFT                         ( 19 ) 
#define DISEM_FLAGS_SET(x)                      ( ( (BYTE)(x)<<15 ) & 0x00078000 ) 
#define DISEM_FLAGS_GET(x)                      ((BYTE)( ( (x) & 0x00078000 )>>15 )) 
#define DISEM_FLAGS_MASK                        ( 0x00078000 )
#define DISEM_FLAGS_SHIFT                       ( 15 ) 
#define DISEM_PRI_SET(x)                        ( ( (BYTE)(x)<<14 ) & 0x00004000 ) 
#define DISEM_PRI_GET(x)                        ((BYTE)( ( (x) & 0x00004000 )>>14 )) 
#define DISEM_PRI_MASK                          ( 0x00004000 )
#define DISEM_PRI_SHIFT                         ( 14 ) 
#define DISEM_GROUP_SET(x)                      ( ( (BYTE)(x)<<11 ) & 0x00003800 ) 
#define DISEM_GROUP_GET(x)                      ((BYTE)( ( (x) & 0x00003800 )>>11 )) 
#define DISEM_GROUP_MASK                        ( 0x00003800 )
#define DISEM_GROUP_SHIFT                       ( 11 ) 
#define DISEM_TYPE_SET(x)                       ( ( (BYTE)(x)<<9 ) & 0x00000600 ) 
#define DISEM_TYPE_GET(x)                       ((BYTE)( ( (x) & 0x00000600 )>>9 )) 
#define DISEM_TYPE_MASK                         ( 0x00000600 )
#define DISEM_TYPE_SHIFT                        ( 9 ) 
#define DISEM_REL_SET(x)                        ( ( (BYTE)(x)<<8 ) & 0x00000100 ) 
#define DISEM_REL_GET(x)                        ((BYTE)( ( (x) & 0x00000100 )>>8 )) 
#define DISEM_REL_MASK                          ( 0x00000100 )
#define DISEM_REL_SHIFT                         ( 8 ) 
#define DISEM_INDEX_SET(x)                      ( ( (BYTE)(x)<<0 ) & 0x000000FF ) 
#define DISEM_INDEX_GET(x)                      ((BYTE)( ( (x) & 0x000000FF )>>0 )) 
#define DISEM_INDEX_MASK                        ( 0x000000FF )
#define DISEM_INDEX_SHIFT                       ( 0 ) 
#define DISEM_TYPE_AXIS                         0x00000200
#define DISEM_TYPE_BUTTON                       0x00000400
#define DISEM_TYPE_POV                          0x00000600
/*
 *  Default Axis mapping is encoded as follows:
 *      X - X or steering axis
 *      Y - Y
 *      Z - Z, not throttle
 *      R - rZ or rudder
 *      U - rY (not available for WinMM unless 6DOF or head tracker)
 *      V - rx (not available for WinMM unless 6DOF or head tracker)
 *      A - Accellerator or throttle
 *      B - Brake
 *      C - Clutch
 *      S - Slider
 *      
 *      P - is used in fallback button flags to indicate a POV
 */
#define DISEM_FLAGS_X                           0x00008000
#define DISEM_FLAGS_Y                           0x00010000
#define DISEM_FLAGS_Z                           0x00018000
#define DISEM_FLAGS_R                           0x00020000
#define DISEM_FLAGS_U                           0x00028000
#define DISEM_FLAGS_V                           0x00030000
#define DISEM_FLAGS_A                           0x00038000
#define DISEM_FLAGS_B                           0x00040000
#define DISEM_FLAGS_C                           0x00048000
#define DISEM_FLAGS_S                           0x00050000

#define DISEM_FLAGS_P                           0x00078000

/* The reserved button values */


/*
 *  Any axis value can be set to relative by or'ing the appropriate flags.
 */
#define DIAXIS_RELATIVE                         0x00000100 
#define DIAXIS_ABSOLUTE                         0x00000000
#define DIPHYSICAL_KEYBOARD                     0x81000000
/* @doc EXTERNAL 
 * @Semantics Keyboard | 
 * @normal Genre:  <c 01  >
 */

//  NT puts them here in their keyboard driver              
//  So keep them in the same place to avoid problems later
#define DIKEYBOARD_F16                          0x81000467    //
#define DIKEYBOARD_F17                          0x81000468    //
#define DIKEYBOARD_F18                          0x81000469    //
#define DIKEYBOARD_F19                          0x8100046A    //
#define DIKEYBOARD_F20                          0x8100046B    //
#define DIKEYBOARD_F21                          0x8100046C    //
#define DIKEYBOARD_F22                          0x8100046D    //
#define DIKEYBOARD_F23                          0x8100046E    //
#define DIKEYBOARD_F24                          0x81000476    //
#define DIKEYBOARD_SHARP                        0x81000484    /* Hash-mark                      */
//k_def(DIK_SNAPSHOT       ,0xC5)    /* Print Screen */
#define DIPHYSICAL_MOUSE                        0x82000000
/* @doc EXTERNAL 
 * @Semantics MOUSE | 
 * @normal Genre:  <c 02  >
 */

#define DIPHYSICAL_VOICE                        0x83000000
/* @doc EXTERNAL 
 * @Semantics VOICE | 
 * @normal Genre:  <c 03  >
 */

/* @doc EXTERNAL 
 * @Semantics Driving Simulator - Racing | 
 * @normal Genre:  <c 01  >
 */

#define DISEM_DEFAULTDEVICE_1 { DI8DEVTYPE_DRIVING,  }
 /* @normal <c DIAXIS_DRIVINGR_STEER>:0x01008A01
 *   Steering */
 /* @normal <c DIAXIS_DRIVINGR_ACCELERATE>:0x01039202
 *   Accelerate */
 /* @normal <c DIAXIS_DRIVINGR_BRAKE>:0x01041203
 *   Brake-Axis */
 /* @normal <c DIBUTTON_DRIVINGR_SHIFTUP>:0x01000C01
 *    Shift to next higher gear */
 /* @normal <c DIBUTTON_DRIVINGR_SHIFTDOWN>:0x01000C02
 *    Shift to next lower gear */
 /* @normal <c DIBUTTON_DRIVINGR_VIEW>:0x01001C03
 *    Cycle through view options */
 /* @normal <c DIBUTTON_DRIVINGR_MENU>:0x010004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIAXIS_DRIVINGR_ACCEL_AND_BRAKE>:0x01014A04
 *   Some devices combine accelerate and brake in a single axis */
 /* @normal <c DIHATSWITCH_DRIVINGR_GLANCE>:0x01004601
 *   Look around */
 /* @normal <c DIBUTTON_DRIVINGR_BRAKE>:0x01004C04
 *    Brake-button */
 /* @normal <c DIBUTTON_DRIVINGR_DASHBOARD>:0x01004405
 *    Select next dashboard option */
 /* @normal <c DIBUTTON_DRIVINGR_AIDS>:0x01004406
 *    Driver correction aids */
 /* @normal <c DIBUTTON_DRIVINGR_MAP>:0x01004407
 *    Display Driving Map */
 /* @normal <c DIBUTTON_DRIVINGR_BOOST>:0x01004408
 *    Turbo Boost */
 /* @normal <c DIBUTTON_DRIVINGR_PIT>:0x01004409
 *    Pit stop notification */
 /* @normal <c DIBUTTON_DRIVINGR_ACCELERATE_LINK>:0x0103D4E0
 *    Fallback Accelerate button */
 /* @normal <c DIBUTTON_DRIVINGR_STEER_LEFT_LINK>:0x0100CCE4
 *    Fallback Steer Left button */
 /* @normal <c DIBUTTON_DRIVINGR_STEER_RIGHT_LINK>:0x0100CCEC
 *    Fallback Steer Right button */
 /* @normal <c DIBUTTON_DRIVINGR_GLANCE_LEFT_LINK>:0x0107C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_DRIVINGR_GLANCE_RIGHT_LINK>:0x0107C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_DRIVINGR_DEVICE>:0x010044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_DRIVINGR_PAUSE>:0x010044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Driving Simulator - Combat | 
 * @normal Genre:  <c 02  >
 */

#define DISEM_DEFAULTDEVICE_2 { DI8DEVTYPE_DRIVING,  }
 /* @normal <c DIAXIS_DRIVINGC_STEER>:0x02008A01
 *   Steering  */
 /* @normal <c DIAXIS_DRIVINGC_ACCELERATE>:0x02039202
 *   Accelerate */
 /* @normal <c DIAXIS_DRIVINGC_BRAKE>:0x02041203
 *   Brake-axis */
 /* @normal <c DIBUTTON_DRIVINGC_FIRE>:0x02000C01
 *    Fire */
 /* @normal <c DIBUTTON_DRIVINGC_WEAPONS>:0x02000C02
 *    Select next weapon */
 /* @normal <c DIBUTTON_DRIVINGC_TARGET>:0x02000C03
 *    Select next available target */
 /* @normal <c DIBUTTON_DRIVINGC_MENU>:0x020004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIAXIS_DRIVINGC_ACCEL_AND_BRAKE>:0x02014A04
 *   Some devices combine accelerate and brake in a single axis */
 /* @normal <c DIHATSWITCH_DRIVINGC_GLANCE>:0x02004601
 *   Look around */
 /* @normal <c DIBUTTON_DRIVINGC_SHIFTUP>:0x02004C04
 *    Shift to next higher gear */
 /* @normal <c DIBUTTON_DRIVINGC_SHIFTDOWN>:0x02004C05
 *    Shift to next lower gear */
 /* @normal <c DIBUTTON_DRIVINGC_DASHBOARD>:0x02004406
 *    Select next dashboard option */
 /* @normal <c DIBUTTON_DRIVINGC_AIDS>:0x02004407
 *    Driver correction aids */
 /* @normal <c DIBUTTON_DRIVINGC_BRAKE>:0x02004C08
 *    Brake-button */
 /* @normal <c DIBUTTON_DRIVINGC_FIRESECONDARY>:0x02004C09
 *    Alternative fire button */
 /* @normal <c DIBUTTON_DRIVINGC_ACCELERATE_LINK>:0x0203D4E0
 *    Fallback Accelerate button */
 /* @normal <c DIBUTTON_DRIVINGC_STEER_LEFT_LINK>:0x0200CCE4
 *    Fallback Steer Left button */
 /* @normal <c DIBUTTON_DRIVINGC_STEER_RIGHT_LINK>:0x0200CCEC
 *    Fallback Steer Right button */
 /* @normal <c DIBUTTON_DRIVINGC_GLANCE_LEFT_LINK>:0x0207C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_DRIVINGC_GLANCE_RIGHT_LINK>:0x0207C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_DRIVINGC_DEVICE>:0x020044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_DRIVINGC_PAUSE>:0x020044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Driving Simulator - Tank | 
 * @normal Genre:  <c 03  >
 */

#define DISEM_DEFAULTDEVICE_3 { DI8DEVTYPE_DRIVING,  }
 /* @normal <c DIAXIS_DRIVINGT_STEER>:0x03008A01
 *   Turn tank left / right */
 /* @normal <c DIAXIS_DRIVINGT_BARREL>:0x03010202
 *   Raise / lower barrel */
 /* @normal <c DIAXIS_DRIVINGT_ACCELERATE>:0x03039203
 *   Accelerate */
 /* @normal <c DIAXIS_DRIVINGT_ROTATE>:0x03020204
 *   Turn barrel left / right */
 /* @normal <c DIBUTTON_DRIVINGT_FIRE>:0x03000C01
 *    Fire */
 /* @normal <c DIBUTTON_DRIVINGT_WEAPONS>:0x03000C02
 *    Select next weapon */
 /* @normal <c DIBUTTON_DRIVINGT_TARGET>:0x03000C03
 *    Selects next available target */
 /* @normal <c DIBUTTON_DRIVINGT_MENU>:0x030004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_DRIVINGT_GLANCE>:0x03004601
 *   Look around */
 /* @normal <c DIAXIS_DRIVINGT_BRAKE>:0x03045205
 *   Brake-axis */
 /* @normal <c DIAXIS_DRIVINGT_ACCEL_AND_BRAKE>:0x03014A06
 *   Some devices combine accelerate and brake in a single axis */
 /* @normal <c DIBUTTON_DRIVINGT_VIEW>:0x03005C04
 *    Cycle through view options */
 /* @normal <c DIBUTTON_DRIVINGT_DASHBOARD>:0x03005C05
 *    Select next dashboard option */
 /* @normal <c DIBUTTON_DRIVINGT_BRAKE>:0x03004C06
 *    Brake-button */
 /* @normal <c DIBUTTON_DRIVINGT_FIRESECONDARY>:0x03004C07
 *    Alternative fire button */
 /* @normal <c DIBUTTON_DRIVINGT_ACCELERATE_LINK>:0x0303D4E0
 *    Fallback Accelerate button */
 /* @normal <c DIBUTTON_DRIVINGT_STEER_LEFT_LINK>:0x0300CCE4
 *    Fallback Steer Left button */
 /* @normal <c DIBUTTON_DRIVINGT_STEER_RIGHT_LINK>:0x0300CCEC
 *    Fallback Steer Right button */
 /* @normal <c DIBUTTON_DRIVINGT_BARREL_UP_LINK>:0x030144E0
 *    Fallback Barrel up button */
 /* @normal <c DIBUTTON_DRIVINGT_BARREL_DOWN_LINK>:0x030144E8
 *    Fallback Barrel down button */
 /* @normal <c DIBUTTON_DRIVINGT_ROTATE_LEFT_LINK>:0x030244E4
 *    Fallback Rotate left button */
 /* @normal <c DIBUTTON_DRIVINGT_ROTATE_RIGHT_LINK>:0x030244EC
 *    Fallback Rotate right button */
 /* @normal <c DIBUTTON_DRIVINGT_GLANCE_LEFT_LINK>:0x0307C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_DRIVINGT_GLANCE_RIGHT_LINK>:0x0307C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_DRIVINGT_DEVICE>:0x030044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_DRIVINGT_PAUSE>:0x030044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Flight Simulator - Civilian  | 
 * @normal Genre:  <c 04  >
 */

#define DISEM_DEFAULTDEVICE_4 { DI8DEVTYPE_FLIGHT, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FLYINGC_BANK>:0x04008A01
 *   Roll ship left / right */
 /* @normal <c DIAXIS_FLYINGC_PITCH>:0x04010A02
 *   Nose up / down */
 /* @normal <c DIAXIS_FLYINGC_THROTTLE>:0x04039203
 *   Throttle */
 /* @normal <c DIBUTTON_FLYINGC_VIEW>:0x04002401
 *    Cycle through view options */
 /* @normal <c DIBUTTON_FLYINGC_DISPLAY>:0x04002402
 *    Select next dashboard / heads up display option */
 /* @normal <c DIBUTTON_FLYINGC_GEAR>:0x04002C03
 *    Gear up / down */
 /* @normal <c DIBUTTON_FLYINGC_MENU>:0x040004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FLYINGC_GLANCE>:0x04004601
 *   Look around */
 /* @normal <c DIAXIS_FLYINGC_BRAKE>:0x04046A04
 *   Apply Brake */
 /* @normal <c DIAXIS_FLYINGC_RUDDER>:0x04025205
 *   Yaw ship left/right */
 /* @normal <c DIAXIS_FLYINGC_FLAPS>:0x04055A06
 *   Flaps */
 /* @normal <c DIBUTTON_FLYINGC_FLAPSUP>:0x04006404
 *    Increment stepping up until fully retracted */
 /* @normal <c DIBUTTON_FLYINGC_FLAPSDOWN>:0x04006405
 *    Decrement stepping down until fully extended */
 /* @normal <c DIBUTTON_FLYINGC_BRAKE_LINK>:0x04046CE0
 *    Fallback brake button */
 /* @normal <c DIBUTTON_FLYINGC_FASTER_LINK>:0x0403D4E0
 *    Fallback throttle up button */
 /* @normal <c DIBUTTON_FLYINGC_SLOWER_LINK>:0x0403D4E8
 *    Fallback throttle down button */
 /* @normal <c DIBUTTON_FLYINGC_GLANCE_LEFT_LINK>:0x0407C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_FLYINGC_GLANCE_RIGHT_LINK>:0x0407C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_FLYINGC_GLANCE_UP_LINK>:0x0407C4E0
 *    Fallback Glance Up button */
 /* @normal <c DIBUTTON_FLYINGC_GLANCE_DOWN_LINK>:0x0407C4E8
 *    Fallback Glance Down button */
 /* @normal <c DIBUTTON_FLYINGC_DEVICE>:0x040044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FLYINGC_PAUSE>:0x040044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Flight Simulator - Military  | 
 * @normal Genre:  <c 05  >
 */

#define DISEM_DEFAULTDEVICE_5 { DI8DEVTYPE_FLIGHT, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FLYINGM_BANK>:0x05008A01
 *   Bank - Roll ship left / right */
 /* @normal <c DIAXIS_FLYINGM_PITCH>:0x05010A02
 *   Pitch - Nose up / down */
 /* @normal <c DIAXIS_FLYINGM_THROTTLE>:0x05039203
 *   Throttle - faster / slower */
 /* @normal <c DIBUTTON_FLYINGM_FIRE>:0x05000C01
 *    Fire */
 /* @normal <c DIBUTTON_FLYINGM_WEAPONS>:0x05000C02
 *    Select next weapon */
 /* @normal <c DIBUTTON_FLYINGM_TARGET>:0x05000C03
 *    Selects next available target */
 /* @normal <c DIBUTTON_FLYINGM_MENU>:0x050004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FLYINGM_GLANCE>:0x05004601
 *   Look around */
 /* @normal <c DIBUTTON_FLYINGM_COUNTER>:0x05005C04
 *    Activate counter measures */
 /* @normal <c DIAXIS_FLYINGM_RUDDER>:0x05024A04
 *   Rudder - Yaw ship left/right */
 /* @normal <c DIAXIS_FLYINGM_BRAKE>:0x05046205
 *   Brake-axis */
 /* @normal <c DIBUTTON_FLYINGM_VIEW>:0x05006405
 *    Cycle through view options */
 /* @normal <c DIBUTTON_FLYINGM_DISPLAY>:0x05006406
 *    Select next dashboard option */
 /* @normal <c DIAXIS_FLYINGM_FLAPS>:0x05055206
 *   Flaps */
 /* @normal <c DIBUTTON_FLYINGM_FLAPSUP>:0x05005407
 *    Increment stepping up until fully retracted */
 /* @normal <c DIBUTTON_FLYINGM_FLAPSDOWN>:0x05005408
 *    Decrement stepping down until fully extended */
 /* @normal <c DIBUTTON_FLYINGM_FIRESECONDARY>:0x05004C09
 *    Alternative fire button */
 /* @normal <c DIBUTTON_FLYINGM_GEAR>:0x0500640A
 *    Gear up / down */
 /* @normal <c DIBUTTON_FLYINGM_BRAKE_LINK>:0x050464E0
 *    Fallback brake button */
 /* @normal <c DIBUTTON_FLYINGM_FASTER_LINK>:0x0503D4E0
 *    Fallback throttle up button */
 /* @normal <c DIBUTTON_FLYINGM_SLOWER_LINK>:0x0503D4E8
 *    Fallback throttle down button */
 /* @normal <c DIBUTTON_FLYINGM_GLANCE_LEFT_LINK>:0x0507C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_FLYINGM_GLANCE_RIGHT_LINK>:0x0507C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_FLYINGM_GLANCE_UP_LINK>:0x0507C4E0
 *    Fallback Glance Up button */
 /* @normal <c DIBUTTON_FLYINGM_GLANCE_DOWN_LINK>:0x0507C4E8
 *    Fallback Glance Down button */
 /* @normal <c DIBUTTON_FLYINGM_DEVICE>:0x050044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FLYINGM_PAUSE>:0x050044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Flight Simulator - Combat Helicopter | 
 * @normal Genre:  <c 06  >
 */

#define DISEM_DEFAULTDEVICE_6 { DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FLYINGH_BANK>:0x06008A01
 *   Bank - Roll ship left / right */
 /* @normal <c DIAXIS_FLYINGH_PITCH>:0x06010A02
 *   Pitch - Nose up / down */
 /* @normal <c DIAXIS_FLYINGH_COLLECTIVE>:0x06018A03
 *   Collective - Blade pitch/power */
 /* @normal <c DIBUTTON_FLYINGH_FIRE>:0x06001401
 *    Fire */
 /* @normal <c DIBUTTON_FLYINGH_WEAPONS>:0x06001402
 *    Select next weapon */
 /* @normal <c DIBUTTON_FLYINGH_TARGET>:0x06001403
 *    Selects next available target */
 /* @normal <c DIBUTTON_FLYINGH_MENU>:0x060004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FLYINGH_GLANCE>:0x06004601
 *   Look around */
 /* @normal <c DIAXIS_FLYINGH_TORQUE>:0x06025A04
 *   Torque - Rotate ship around left / right axis */
 /* @normal <c DIAXIS_FLYINGH_THROTTLE>:0x0603DA05
 *   Throttle */
 /* @normal <c DIBUTTON_FLYINGH_COUNTER>:0x06005404
 *    Activate counter measures */
 /* @normal <c DIBUTTON_FLYINGH_VIEW>:0x06006405
 *    Cycle through view options */
 /* @normal <c DIBUTTON_FLYINGH_GEAR>:0x06006406
 *    Gear up / down */
 /* @normal <c DIBUTTON_FLYINGH_FIRESECONDARY>:0x06004C07
 *    Alternative fire button */
 /* @normal <c DIBUTTON_FLYINGH_FASTER_LINK>:0x0603DCE0
 *    Fallback throttle up button */
 /* @normal <c DIBUTTON_FLYINGH_SLOWER_LINK>:0x0603DCE8
 *    Fallback throttle down button */
 /* @normal <c DIBUTTON_FLYINGH_GLANCE_LEFT_LINK>:0x0607C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_FLYINGH_GLANCE_RIGHT_LINK>:0x0607C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_FLYINGH_GLANCE_UP_LINK>:0x0607C4E0
 *    Fallback Glance Up button */
 /* @normal <c DIBUTTON_FLYINGH_GLANCE_DOWN_LINK>:0x0607C4E8
 *    Fallback Glance Down button */
 /* @normal <c DIBUTTON_FLYINGH_DEVICE>:0x060044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FLYINGH_PAUSE>:0x060044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Space Simulator - Combat | 
 * @normal Genre:  <c 07  >
 */

#define DISEM_DEFAULTDEVICE_7 { DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_SPACESIM_LATERAL>:0x07008201
 *   Move ship left / right */
 /* @normal <c DIAXIS_SPACESIM_MOVE>:0x07010202
 *   Move ship forward/backward */
 /* @normal <c DIAXIS_SPACESIM_THROTTLE>:0x07038203
 *   Throttle - Engine speed */
 /* @normal <c DIBUTTON_SPACESIM_FIRE>:0x07000401
 *    Fire */
 /* @normal <c DIBUTTON_SPACESIM_WEAPONS>:0x07000402
 *    Select next weapon */
 /* @normal <c DIBUTTON_SPACESIM_TARGET>:0x07000403
 *    Selects next available target */
 /* @normal <c DIBUTTON_SPACESIM_MENU>:0x070004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_SPACESIM_GLANCE>:0x07004601
 *   Look around */
 /* @normal <c DIAXIS_SPACESIM_CLIMB>:0x0701C204
 *   Climb - Pitch ship up/down */
 /* @normal <c DIAXIS_SPACESIM_ROTATE>:0x07024205
 *   Rotate - Turn ship left/right */
 /* @normal <c DIBUTTON_SPACESIM_VIEW>:0x07004404
 *    Cycle through view options */
 /* @normal <c DIBUTTON_SPACESIM_DISPLAY>:0x07004405
 *    Select next dashboard / heads up display option */
 /* @normal <c DIBUTTON_SPACESIM_RAISE>:0x07004406
 *    Raise ship while maintaining current pitch */
 /* @normal <c DIBUTTON_SPACESIM_LOWER>:0x07004407
 *    Lower ship while maintaining current pitch */
 /* @normal <c DIBUTTON_SPACESIM_GEAR>:0x07004408
 *    Gear up / down */
 /* @normal <c DIBUTTON_SPACESIM_FIRESECONDARY>:0x07004409
 *    Alternative fire button */
 /* @normal <c DIBUTTON_SPACESIM_LEFT_LINK>:0x0700C4E4
 *    Fallback move left button */
 /* @normal <c DIBUTTON_SPACESIM_RIGHT_LINK>:0x0700C4EC
 *    Fallback move right button */
 /* @normal <c DIBUTTON_SPACESIM_FORWARD_LINK>:0x070144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_SPACESIM_BACKWARD_LINK>:0x070144E8
 *    Fallback move backwards button */
 /* @normal <c DIBUTTON_SPACESIM_FASTER_LINK>:0x0703C4E0
 *    Fallback throttle up button */
 /* @normal <c DIBUTTON_SPACESIM_SLOWER_LINK>:0x0703C4E8
 *    Fallback throttle down button */
 /* @normal <c DIBUTTON_SPACESIM_TURN_LEFT_LINK>:0x070244E4
 *    Fallback turn left button */
 /* @normal <c DIBUTTON_SPACESIM_TURN_RIGHT_LINK>:0x070244EC
 *    Fallback turn right button */
 /* @normal <c DIBUTTON_SPACESIM_GLANCE_LEFT_LINK>:0x0707C4E4
 *    Fallback Glance Left button */
 /* @normal <c DIBUTTON_SPACESIM_GLANCE_RIGHT_LINK>:0x0707C4EC
 *    Fallback Glance Right button */
 /* @normal <c DIBUTTON_SPACESIM_GLANCE_UP_LINK>:0x0707C4E0
 *    Fallback Glance Up button */
 /* @normal <c DIBUTTON_SPACESIM_GLANCE_DOWN_LINK>:0x0707C4E8
 *    Fallback Glance Down button */
 /* @normal <c DIBUTTON_SPACESIM_DEVICE>:0x070044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_SPACESIM_PAUSE>:0x070044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Fighting - First Person  | 
 * @normal Genre:  <c 08  >
 */

#define DISEM_DEFAULTDEVICE_8 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FIGHTINGH_LATERAL>:0x08008201
 *   Sidestep left/right */
 /* @normal <c DIAXIS_FIGHTINGH_MOVE>:0x08010202
 *   Move forward/backward */
 /* @normal <c DIBUTTON_FIGHTINGH_PUNCH>:0x08000401
 *    Punch */
 /* @normal <c DIBUTTON_FIGHTINGH_KICK>:0x08000402
 *    Kick */
 /* @normal <c DIBUTTON_FIGHTINGH_BLOCK>:0x08000403
 *    Block */
 /* @normal <c DIBUTTON_FIGHTINGH_CROUCH>:0x08000404
 *    Crouch */
 /* @normal <c DIBUTTON_FIGHTINGH_JUMP>:0x08000405
 *    Jump */
 /* @normal <c DIBUTTON_FIGHTINGH_SPECIAL1>:0x08000406
 *    Apply first special move */
 /* @normal <c DIBUTTON_FIGHTINGH_SPECIAL2>:0x08000407
 *    Apply second special move */
 /* @normal <c DIBUTTON_FIGHTINGH_MENU>:0x080004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FIGHTINGH_SELECT>:0x08004408
 *    Select special move */
 /* @normal <c DIHATSWITCH_FIGHTINGH_SLIDE>:0x08004601
 *   Look around */
 /* @normal <c DIBUTTON_FIGHTINGH_DISPLAY>:0x08004409
 *    Shows next on-screen display option */
 /* @normal <c DIAXIS_FIGHTINGH_ROTATE>:0x08024203
 *   Rotate - Turn body left/right */
 /* @normal <c DIBUTTON_FIGHTINGH_DODGE>:0x0800440A
 *    Dodge */
 /* @normal <c DIBUTTON_FIGHTINGH_LEFT_LINK>:0x0800C4E4
 *    Fallback left sidestep button */
 /* @normal <c DIBUTTON_FIGHTINGH_RIGHT_LINK>:0x0800C4EC
 *    Fallback right sidestep button */
 /* @normal <c DIBUTTON_FIGHTINGH_FORWARD_LINK>:0x080144E0
 *    Fallback forward button */
 /* @normal <c DIBUTTON_FIGHTINGH_BACKWARD_LINK>:0x080144E8
 *    Fallback backward button */
 /* @normal <c DIBUTTON_FIGHTINGH_DEVICE>:0x080044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FIGHTINGH_PAUSE>:0x080044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Fighting - First Person Shooting | 
 * @normal Genre:  <c 09  >
 */

#define DISEM_DEFAULTDEVICE_9 { DI8DEVTYPE_1STPERSON,  }
 /* @normal <c DIAXIS_FPS_ROTATE>:0x09008201
 *   Rotate character left/right */
 /* @normal <c DIAXIS_FPS_MOVE>:0x09010202
 *   Move forward/backward */
 /* @normal <c DIBUTTON_FPS_FIRE>:0x09000401
 *    Fire */
 /* @normal <c DIBUTTON_FPS_WEAPONS>:0x09000402
 *    Select next weapon */
 /* @normal <c DIBUTTON_FPS_APPLY>:0x09000403
 *    Use item */
 /* @normal <c DIBUTTON_FPS_SELECT>:0x09000404
 *    Select next inventory item */
 /* @normal <c DIBUTTON_FPS_CROUCH>:0x09000405
 *    Crouch/ climb down/ swim down */
 /* @normal <c DIBUTTON_FPS_JUMP>:0x09000406
 *    Jump/ climb up/ swim up */
 /* @normal <c DIAXIS_FPS_LOOKUPDOWN>:0x09018203
 *   Look up / down  */
 /* @normal <c DIBUTTON_FPS_STRAFE>:0x09000407
 *    Enable strafing while active */
 /* @normal <c DIBUTTON_FPS_MENU>:0x090004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FPS_GLANCE>:0x09004601
 *   Look around */
 /* @normal <c DIBUTTON_FPS_DISPLAY>:0x09004408
 *    Shows next on-screen display option/ map */
 /* @normal <c DIAXIS_FPS_SIDESTEP>:0x09024204
 *   Sidestep */
 /* @normal <c DIBUTTON_FPS_DODGE>:0x09004409
 *    Dodge */
 /* @normal <c DIBUTTON_FPS_GLANCEL>:0x0900440A
 *    Glance Left */
 /* @normal <c DIBUTTON_FPS_GLANCER>:0x0900440B
 *    Glance Right */
 /* @normal <c DIBUTTON_FPS_FIRESECONDARY>:0x0900440C
 *    Alternative fire button */
 /* @normal <c DIBUTTON_FPS_ROTATE_LEFT_LINK>:0x0900C4E4
 *    Fallback rotate left button */
 /* @normal <c DIBUTTON_FPS_ROTATE_RIGHT_LINK>:0x0900C4EC
 *    Fallback rotate right button */
 /* @normal <c DIBUTTON_FPS_FORWARD_LINK>:0x090144E0
 *    Fallback forward button */
 /* @normal <c DIBUTTON_FPS_BACKWARD_LINK>:0x090144E8
 *    Fallback backward button */
 /* @normal <c DIBUTTON_FPS_GLANCE_UP_LINK>:0x0901C4E0
 *    Fallback look up button */
 /* @normal <c DIBUTTON_FPS_GLANCE_DOWN_LINK>:0x0901C4E8
 *    Fallback look down button */
 /* @normal <c DIBUTTON_FPS_STEP_LEFT_LINK>:0x090244E4
 *    Fallback step left button */
 /* @normal <c DIBUTTON_FPS_STEP_RIGHT_LINK>:0x090244EC
 *    Fallback step right button */
 /* @normal <c DIBUTTON_FPS_DEVICE>:0x090044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FPS_PAUSE>:0x090044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Fighting - Third Person action | 
 * @normal Genre:  <c 10  >
 */

#define DISEM_DEFAULTDEVICE_10 { DI8DEVTYPE_1STPERSON,  }
 /* @normal <c DIAXIS_TPS_TURN>:0x0A020201
 *   Turn left/right */
 /* @normal <c DIAXIS_TPS_MOVE>:0x0A010202
 *   Move forward/backward */
 /* @normal <c DIBUTTON_TPS_RUN>:0x0A000401
 *    Run or walk toggle switch */
 /* @normal <c DIBUTTON_TPS_ACTION>:0x0A000402
 *    Action Button */
 /* @normal <c DIBUTTON_TPS_SELECT>:0x0A000403
 *    Select next weapon */
 /* @normal <c DIBUTTON_TPS_USE>:0x0A000404
 *    Use inventory item currently selected */
 /* @normal <c DIBUTTON_TPS_JUMP>:0x0A000405
 *    Character Jumps */
 /* @normal <c DIBUTTON_TPS_MENU>:0x0A0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_TPS_GLANCE>:0x0A004601
 *   Look around */
 /* @normal <c DIBUTTON_TPS_VIEW>:0x0A004406
 *    Select camera view */
 /* @normal <c DIBUTTON_TPS_STEPLEFT>:0x0A004407
 *    Character takes a left step */
 /* @normal <c DIBUTTON_TPS_STEPRIGHT>:0x0A004408
 *    Character takes a right step */
 /* @normal <c DIAXIS_TPS_STEP>:0x0A00C203
 *   Character steps left/right */
 /* @normal <c DIBUTTON_TPS_DODGE>:0x0A004409
 *    Character dodges or ducks */
 /* @normal <c DIBUTTON_TPS_INVENTORY>:0x0A00440A
 *    Cycle through inventory */
 /* @normal <c DIBUTTON_TPS_TURN_LEFT_LINK>:0x0A0244E4
 *    Fallback turn left button */
 /* @normal <c DIBUTTON_TPS_TURN_RIGHT_LINK>:0x0A0244EC
 *    Fallback turn right button */
 /* @normal <c DIBUTTON_TPS_FORWARD_LINK>:0x0A0144E0
 *    Fallback forward button */
 /* @normal <c DIBUTTON_TPS_BACKWARD_LINK>:0x0A0144E8
 *    Fallback backward button */
 /* @normal <c DIBUTTON_TPS_GLANCE_UP_LINK>:0x0A07C4E0
 *    Fallback look up button */
 /* @normal <c DIBUTTON_TPS_GLANCE_DOWN_LINK>:0x0A07C4E8
 *    Fallback look down button */
 /* @normal <c DIBUTTON_TPS_GLANCE_LEFT_LINK>:0x0A07C4E4
 *    Fallback glance up button */
 /* @normal <c DIBUTTON_TPS_GLANCE_RIGHT_LINK>:0x0A07C4EC
 *    Fallback glance right button */
 /* @normal <c DIBUTTON_TPS_DEVICE>:0x0A0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_TPS_PAUSE>:0x0A0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Strategy - Role Playing | 
 * @normal Genre:  <c 11  >
 */

#define DISEM_DEFAULTDEVICE_11 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_STRATEGYR_LATERAL>:0x0B008201
 *   sidestep - left/right */
 /* @normal <c DIAXIS_STRATEGYR_MOVE>:0x0B010202
 *   move forward/backward */
 /* @normal <c DIBUTTON_STRATEGYR_GET>:0x0B000401
 *    Acquire item */
 /* @normal <c DIBUTTON_STRATEGYR_APPLY>:0x0B000402
 *    Use selected item */
 /* @normal <c DIBUTTON_STRATEGYR_SELECT>:0x0B000403
 *    Select nextitem */
 /* @normal <c DIBUTTON_STRATEGYR_ATTACK>:0x0B000404
 *    Attack */
 /* @normal <c DIBUTTON_STRATEGYR_CAST>:0x0B000405
 *    Cast Spell */
 /* @normal <c DIBUTTON_STRATEGYR_CROUCH>:0x0B000406
 *    Crouch */
 /* @normal <c DIBUTTON_STRATEGYR_JUMP>:0x0B000407
 *    Jump */
 /* @normal <c DIBUTTON_STRATEGYR_MENU>:0x0B0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_STRATEGYR_GLANCE>:0x0B004601
 *   Look around */
 /* @normal <c DIBUTTON_STRATEGYR_MAP>:0x0B004408
 *    Cycle through map options */
 /* @normal <c DIBUTTON_STRATEGYR_DISPLAY>:0x0B004409
 *    Shows next on-screen display option */
 /* @normal <c DIAXIS_STRATEGYR_ROTATE>:0x0B024203
 *   Turn body left/right */
 /* @normal <c DIBUTTON_STRATEGYR_LEFT_LINK>:0x0B00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_STRATEGYR_RIGHT_LINK>:0x0B00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_STRATEGYR_FORWARD_LINK>:0x0B0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_STRATEGYR_BACK_LINK>:0x0B0144E8
 *    Fallback move backward button */
 /* @normal <c DIBUTTON_STRATEGYR_ROTATE_LEFT_LINK>:0x0B0244E4
 *    Fallback turn body left button */
 /* @normal <c DIBUTTON_STRATEGYR_ROTATE_RIGHT_LINK>:0x0B0244EC
 *    Fallback turn body right button */
 /* @normal <c DIBUTTON_STRATEGYR_DEVICE>:0x0B0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_STRATEGYR_PAUSE>:0x0B0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Strategy - Turn based | 
 * @normal Genre:  <c 12  >
 */

#define DISEM_DEFAULTDEVICE_12 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_STRATEGYT_LATERAL>:0x0C008201
 *   Sidestep left/right */
 /* @normal <c DIAXIS_STRATEGYT_MOVE>:0x0C010202
 *   Move forward/backwards */
 /* @normal <c DIBUTTON_STRATEGYT_SELECT>:0x0C000401
 *    Select unit or object */
 /* @normal <c DIBUTTON_STRATEGYT_INSTRUCT>:0x0C000402
 *    Cycle through instructions */
 /* @normal <c DIBUTTON_STRATEGYT_APPLY>:0x0C000403
 *    Apply selected instruction */
 /* @normal <c DIBUTTON_STRATEGYT_TEAM>:0x0C000404
 *    Select next team / cycle through all */
 /* @normal <c DIBUTTON_STRATEGYT_TURN>:0x0C000405
 *    Indicate turn over */
 /* @normal <c DIBUTTON_STRATEGYT_MENU>:0x0C0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_STRATEGYT_ZOOM>:0x0C004406
 *    Zoom - in / out */
 /* @normal <c DIBUTTON_STRATEGYT_MAP>:0x0C004407
 *    cycle through map options */
 /* @normal <c DIBUTTON_STRATEGYT_DISPLAY>:0x0C004408
 *    shows next on-screen display options */
 /* @normal <c DIBUTTON_STRATEGYT_LEFT_LINK>:0x0C00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_STRATEGYT_RIGHT_LINK>:0x0C00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_STRATEGYT_FORWARD_LINK>:0x0C0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_STRATEGYT_BACK_LINK>:0x0C0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_STRATEGYT_DEVICE>:0x0C0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_STRATEGYT_PAUSE>:0x0C0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Hunting | 
 * @normal Genre:  <c 13  >
 */

#define DISEM_DEFAULTDEVICE_13 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_HUNTING_LATERAL>:0x0D008201
 *   sidestep left/right */
 /* @normal <c DIAXIS_HUNTING_MOVE>:0x0D010202
 *   move forward/backwards */
 /* @normal <c DIBUTTON_HUNTING_FIRE>:0x0D000401
 *    Fire selected weapon */
 /* @normal <c DIBUTTON_HUNTING_AIM>:0x0D000402
 *    Select aim/move */
 /* @normal <c DIBUTTON_HUNTING_WEAPON>:0x0D000403
 *    Select next weapon */
 /* @normal <c DIBUTTON_HUNTING_BINOCULAR>:0x0D000404
 *    Look through Binoculars */
 /* @normal <c DIBUTTON_HUNTING_CALL>:0x0D000405
 *    Make animal call */
 /* @normal <c DIBUTTON_HUNTING_MAP>:0x0D000406
 *    View Map */
 /* @normal <c DIBUTTON_HUNTING_SPECIAL>:0x0D000407
 *    Special game operation */
 /* @normal <c DIBUTTON_HUNTING_MENU>:0x0D0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_HUNTING_GLANCE>:0x0D004601
 *   Look around */
 /* @normal <c DIBUTTON_HUNTING_DISPLAY>:0x0D004408
 *    show next on-screen display option */
 /* @normal <c DIAXIS_HUNTING_ROTATE>:0x0D024203
 *   Turn body left/right */
 /* @normal <c DIBUTTON_HUNTING_CROUCH>:0x0D004409
 *    Crouch/ Climb / Swim down */
 /* @normal <c DIBUTTON_HUNTING_JUMP>:0x0D00440A
 *    Jump/ Climb up / Swim up */
 /* @normal <c DIBUTTON_HUNTING_FIRESECONDARY>:0x0D00440B
 *    Alternative fire button */
 /* @normal <c DIBUTTON_HUNTING_LEFT_LINK>:0x0D00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_HUNTING_RIGHT_LINK>:0x0D00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_HUNTING_FORWARD_LINK>:0x0D0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_HUNTING_BACK_LINK>:0x0D0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_HUNTING_ROTATE_LEFT_LINK>:0x0D0244E4
 *    Fallback turn body left button */
 /* @normal <c DIBUTTON_HUNTING_ROTATE_RIGHT_LINK>:0x0D0244EC
 *    Fallback turn body right button */
 /* @normal <c DIBUTTON_HUNTING_DEVICE>:0x0D0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_HUNTING_PAUSE>:0x0D0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Fishing | 
 * @normal Genre:  <c 14  >
 */

#define DISEM_DEFAULTDEVICE_14 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FISHING_LATERAL>:0x0E008201
 *   sidestep left/right */
 /* @normal <c DIAXIS_FISHING_MOVE>:0x0E010202
 *   move forward/backwards */
 /* @normal <c DIBUTTON_FISHING_CAST>:0x0E000401
 *    Cast line */
 /* @normal <c DIBUTTON_FISHING_TYPE>:0x0E000402
 *    Select cast type */
 /* @normal <c DIBUTTON_FISHING_BINOCULAR>:0x0E000403
 *    Look through Binocular */
 /* @normal <c DIBUTTON_FISHING_BAIT>:0x0E000404
 *    Select type of Bait */
 /* @normal <c DIBUTTON_FISHING_MAP>:0x0E000405
 *    View Map */
 /* @normal <c DIBUTTON_FISHING_MENU>:0x0E0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_FISHING_GLANCE>:0x0E004601
 *   Look around */
 /* @normal <c DIBUTTON_FISHING_DISPLAY>:0x0E004406
 *    Show next on-screen display option */
 /* @normal <c DIAXIS_FISHING_ROTATE>:0x0E024203
 *   Turn character left / right */
 /* @normal <c DIBUTTON_FISHING_CROUCH>:0x0E004407
 *    Crouch/ Climb / Swim down */
 /* @normal <c DIBUTTON_FISHING_JUMP>:0x0E004408
 *    Jump/ Climb up / Swim up */
 /* @normal <c DIBUTTON_FISHING_LEFT_LINK>:0x0E00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_FISHING_RIGHT_LINK>:0x0E00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_FISHING_FORWARD_LINK>:0x0E0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_FISHING_BACK_LINK>:0x0E0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_FISHING_ROTATE_LEFT_LINK>:0x0E0244E4
 *    Fallback turn body left button */
 /* @normal <c DIBUTTON_FISHING_ROTATE_RIGHT_LINK>:0x0E0244EC
 *    Fallback turn body right button */
 /* @normal <c DIBUTTON_FISHING_DEVICE>:0x0E0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FISHING_PAUSE>:0x0E0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Baseball - Batting | 
 * @normal Genre:  <c 15  >
 */

#define DISEM_DEFAULTDEVICE_15 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BASEBALLB_LATERAL>:0x0F008201
 *   Aim left / right */
 /* @normal <c DIAXIS_BASEBALLB_MOVE>:0x0F010202
 *   Aim up / down */
 /* @normal <c DIBUTTON_BASEBALLB_SELECT>:0x0F000401
 *    cycle through swing options */
 /* @normal <c DIBUTTON_BASEBALLB_NORMAL>:0x0F000402
 *    normal swing */
 /* @normal <c DIBUTTON_BASEBALLB_POWER>:0x0F000403
 *    swing for the fence */
 /* @normal <c DIBUTTON_BASEBALLB_BUNT>:0x0F000404
 *    bunt */
 /* @normal <c DIBUTTON_BASEBALLB_STEAL>:0x0F000405
 *    Base runner attempts to steal a base */
 /* @normal <c DIBUTTON_BASEBALLB_BURST>:0x0F000406
 *    Base runner invokes burst of speed */
 /* @normal <c DIBUTTON_BASEBALLB_SLIDE>:0x0F000407
 *    Base runner slides into base */
 /* @normal <c DIBUTTON_BASEBALLB_CONTACT>:0x0F000408
 *    Contact swing */
 /* @normal <c DIBUTTON_BASEBALLB_MENU>:0x0F0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_BASEBALLB_NOSTEAL>:0x0F004409
 *    Base runner goes back to a base */
 /* @normal <c DIBUTTON_BASEBALLB_BOX>:0x0F00440A
 *    Enter or exit batting box */
 /* @normal <c DIBUTTON_BASEBALLB_LEFT_LINK>:0x0F00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_BASEBALLB_RIGHT_LINK>:0x0F00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_BASEBALLB_FORWARD_LINK>:0x0F0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BASEBALLB_BACK_LINK>:0x0F0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BASEBALLB_DEVICE>:0x0F0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BASEBALLB_PAUSE>:0x0F0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Baseball - Pitching | 
 * @normal Genre:  <c 16  >
 */

#define DISEM_DEFAULTDEVICE_16 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BASEBALLP_LATERAL>:0x10008201
 *   Aim left / right */
 /* @normal <c DIAXIS_BASEBALLP_MOVE>:0x10010202
 *   Aim up / down */
 /* @normal <c DIBUTTON_BASEBALLP_SELECT>:0x10000401
 *    cycle through pitch selections */
 /* @normal <c DIBUTTON_BASEBALLP_PITCH>:0x10000402
 *    throw pitch */
 /* @normal <c DIBUTTON_BASEBALLP_BASE>:0x10000403
 *    select base to throw to */
 /* @normal <c DIBUTTON_BASEBALLP_THROW>:0x10000404
 *    throw to base */
 /* @normal <c DIBUTTON_BASEBALLP_FAKE>:0x10000405
 *    Fake a throw to a base */
 /* @normal <c DIBUTTON_BASEBALLP_MENU>:0x100004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_BASEBALLP_WALK>:0x10004406
 *    Throw intentional walk / pitch out */
 /* @normal <c DIBUTTON_BASEBALLP_LOOK>:0x10004407
 *    Look at runners on bases */
 /* @normal <c DIBUTTON_BASEBALLP_LEFT_LINK>:0x1000C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_BASEBALLP_RIGHT_LINK>:0x1000C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_BASEBALLP_FORWARD_LINK>:0x100144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BASEBALLP_BACK_LINK>:0x100144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BASEBALLP_DEVICE>:0x100044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BASEBALLP_PAUSE>:0x100044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Baseball - Fielding | 
 * @normal Genre:  <c 17  >
 */

#define DISEM_DEFAULTDEVICE_17 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BASEBALLF_LATERAL>:0x11008201
 *   Aim left / right */
 /* @normal <c DIAXIS_BASEBALLF_MOVE>:0x11010202
 *   Aim up / down */
 /* @normal <c DIBUTTON_BASEBALLF_NEAREST>:0x11000401
 *    Switch to fielder nearest to the ball */
 /* @normal <c DIBUTTON_BASEBALLF_THROW1>:0x11000402
 *    Make conservative throw */
 /* @normal <c DIBUTTON_BASEBALLF_THROW2>:0x11000403
 *    Make aggressive throw */
 /* @normal <c DIBUTTON_BASEBALLF_BURST>:0x11000404
 *    Invoke burst of speed */
 /* @normal <c DIBUTTON_BASEBALLF_JUMP>:0x11000405
 *    Jump to catch ball */
 /* @normal <c DIBUTTON_BASEBALLF_DIVE>:0x11000406
 *    Dive to catch ball */
 /* @normal <c DIBUTTON_BASEBALLF_MENU>:0x110004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_BASEBALLF_SHIFTIN>:0x11004407
 *    Shift the infield positioning */
 /* @normal <c DIBUTTON_BASEBALLF_SHIFTOUT>:0x11004408
 *    Shift the outfield positioning */
 /* @normal <c DIBUTTON_BASEBALLF_AIM_LEFT_LINK>:0x1100C4E4
 *    Fallback aim left button */
 /* @normal <c DIBUTTON_BASEBALLF_AIM_RIGHT_LINK>:0x1100C4EC
 *    Fallback aim right button */
 /* @normal <c DIBUTTON_BASEBALLF_FORWARD_LINK>:0x110144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BASEBALLF_BACK_LINK>:0x110144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BASEBALLF_DEVICE>:0x110044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BASEBALLF_PAUSE>:0x110044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Basketball - Offense | 
 * @normal Genre:  <c 18  >
 */

#define DISEM_DEFAULTDEVICE_18 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BBALLO_LATERAL>:0x12008201
 *   left / right */
 /* @normal <c DIAXIS_BBALLO_MOVE>:0x12010202
 *   up / down */
 /* @normal <c DIBUTTON_BBALLO_SHOOT>:0x12000401
 *    shoot basket */
 /* @normal <c DIBUTTON_BBALLO_DUNK>:0x12000402
 *    dunk basket */
 /* @normal <c DIBUTTON_BBALLO_PASS>:0x12000403
 *    throw pass */
 /* @normal <c DIBUTTON_BBALLO_FAKE>:0x12000404
 *    fake shot or pass */
 /* @normal <c DIBUTTON_BBALLO_SPECIAL>:0x12000405
 *    apply special move */
 /* @normal <c DIBUTTON_BBALLO_PLAYER>:0x12000406
 *    select next player */
 /* @normal <c DIBUTTON_BBALLO_BURST>:0x12000407
 *    invoke burst */
 /* @normal <c DIBUTTON_BBALLO_CALL>:0x12000408
 *    call for ball / pass to me */
 /* @normal <c DIBUTTON_BBALLO_MENU>:0x120004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_BBALLO_GLANCE>:0x12004601
 *   scroll view */
 /* @normal <c DIBUTTON_BBALLO_SCREEN>:0x12004409
 *    Call for screen */
 /* @normal <c DIBUTTON_BBALLO_PLAY>:0x1200440A
 *    Call for specific offensive play */
 /* @normal <c DIBUTTON_BBALLO_JAB>:0x1200440B
 *    Initiate fake drive to basket */
 /* @normal <c DIBUTTON_BBALLO_POST>:0x1200440C
 *    Perform post move */
 /* @normal <c DIBUTTON_BBALLO_TIMEOUT>:0x1200440D
 *    Time Out */
 /* @normal <c DIBUTTON_BBALLO_SUBSTITUTE>:0x1200440E
 *    substitute one player for another */
 /* @normal <c DIBUTTON_BBALLO_LEFT_LINK>:0x1200C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_BBALLO_RIGHT_LINK>:0x1200C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_BBALLO_FORWARD_LINK>:0x120144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BBALLO_BACK_LINK>:0x120144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BBALLO_DEVICE>:0x120044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BBALLO_PAUSE>:0x120044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Basketball - Defense | 
 * @normal Genre:  <c 19  >
 */

#define DISEM_DEFAULTDEVICE_19 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BBALLD_LATERAL>:0x13008201
 *   left / right */
 /* @normal <c DIAXIS_BBALLD_MOVE>:0x13010202
 *   up / down */
 /* @normal <c DIBUTTON_BBALLD_JUMP>:0x13000401
 *    jump to block shot */
 /* @normal <c DIBUTTON_BBALLD_STEAL>:0x13000402
 *    attempt to steal ball */
 /* @normal <c DIBUTTON_BBALLD_FAKE>:0x13000403
 *    fake block or steal */
 /* @normal <c DIBUTTON_BBALLD_SPECIAL>:0x13000404
 *    apply special move */
 /* @normal <c DIBUTTON_BBALLD_PLAYER>:0x13000405
 *    select next player */
 /* @normal <c DIBUTTON_BBALLD_BURST>:0x13000406
 *    invoke burst */
 /* @normal <c DIBUTTON_BBALLD_PLAY>:0x13000407
 *    call for specific defensive play */
 /* @normal <c DIBUTTON_BBALLD_MENU>:0x130004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_BBALLD_GLANCE>:0x13004601
 *   scroll view */
 /* @normal <c DIBUTTON_BBALLD_TIMEOUT>:0x13004408
 *    Time Out */
 /* @normal <c DIBUTTON_BBALLD_SUBSTITUTE>:0x13004409
 *    substitute one player for another */
 /* @normal <c DIBUTTON_BBALLD_LEFT_LINK>:0x1300C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_BBALLD_RIGHT_LINK>:0x1300C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_BBALLD_FORWARD_LINK>:0x130144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_BBALLD_BACK_LINK>:0x130144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_BBALLD_DEVICE>:0x130044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BBALLD_PAUSE>:0x130044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Football - Play | 
 * @normal Genre:  <c 20  >
 */

#define DISEM_DEFAULTDEVICE_20 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIBUTTON_FOOTBALLP_PLAY>:0x14000401
 *    cycle through available plays */
 /* @normal <c DIBUTTON_FOOTBALLP_SELECT>:0x14000402
 *    select play */
 /* @normal <c DIBUTTON_FOOTBALLP_HELP>:0x14000403
 *    Bring up pop-up help */
 /* @normal <c DIBUTTON_FOOTBALLP_MENU>:0x140004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FOOTBALLP_DEVICE>:0x140044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FOOTBALLP_PAUSE>:0x140044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Football - QB | 
 * @normal Genre:  <c 21  >
 */

#define DISEM_DEFAULTDEVICE_21 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FOOTBALLQ_LATERAL>:0x15008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_FOOTBALLQ_MOVE>:0x15010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_FOOTBALLQ_SELECT>:0x15000401
 *    Select */
 /* @normal <c DIBUTTON_FOOTBALLQ_SNAP>:0x15000402
 *    snap ball - start play */
 /* @normal <c DIBUTTON_FOOTBALLQ_JUMP>:0x15000403
 *    jump over defender */
 /* @normal <c DIBUTTON_FOOTBALLQ_SLIDE>:0x15000404
 *    Dive/Slide */
 /* @normal <c DIBUTTON_FOOTBALLQ_PASS>:0x15000405
 *    throws pass to receiver */
 /* @normal <c DIBUTTON_FOOTBALLQ_FAKE>:0x15000406
 *    pump fake pass or fake kick */
 /* @normal <c DIBUTTON_FOOTBALLQ_MENU>:0x150004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FOOTBALLQ_FAKESNAP>:0x15004407
 *    Fake snap  */
 /* @normal <c DIBUTTON_FOOTBALLQ_MOTION>:0x15004408
 *    Send receivers in motion */
 /* @normal <c DIBUTTON_FOOTBALLQ_AUDIBLE>:0x15004409
 *    Change offensive play at line of scrimmage */
 /* @normal <c DIBUTTON_FOOTBALLQ_LEFT_LINK>:0x1500C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_FOOTBALLQ_RIGHT_LINK>:0x1500C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_FOOTBALLQ_FORWARD_LINK>:0x150144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_FOOTBALLQ_BACK_LINK>:0x150144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_FOOTBALLQ_DEVICE>:0x150044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FOOTBALLQ_PAUSE>:0x150044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Football - Offense | 
 * @normal Genre:  <c 22  >
 */

#define DISEM_DEFAULTDEVICE_22 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FOOTBALLO_LATERAL>:0x16008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_FOOTBALLO_MOVE>:0x16010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_FOOTBALLO_JUMP>:0x16000401
 *    jump or hurdle over defender */
 /* @normal <c DIBUTTON_FOOTBALLO_LEFTARM>:0x16000402
 *    holds out left arm */
 /* @normal <c DIBUTTON_FOOTBALLO_RIGHTARM>:0x16000403
 *    holds out right arm */
 /* @normal <c DIBUTTON_FOOTBALLO_THROW>:0x16000404
 *    throw pass or lateral ball to another runner */
 /* @normal <c DIBUTTON_FOOTBALLO_SPIN>:0x16000405
 *    Spin to avoid defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_MENU>:0x160004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FOOTBALLO_JUKE>:0x16004406
 *    Use special move to avoid defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_SHOULDER>:0x16004407
 *    Lower shoulder to run over defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_TURBO>:0x16004408
 *    Speed burst past defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_DIVE>:0x16004409
 *    Dive over defenders */
 /* @normal <c DIBUTTON_FOOTBALLO_ZOOM>:0x1600440A
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_FOOTBALLO_SUBSTITUTE>:0x1600440B
 *    substitute one player for another */
 /* @normal <c DIBUTTON_FOOTBALLO_LEFT_LINK>:0x1600C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_FOOTBALLO_RIGHT_LINK>:0x1600C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_FOOTBALLO_FORWARD_LINK>:0x160144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_FOOTBALLO_BACK_LINK>:0x160144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_FOOTBALLO_DEVICE>:0x160044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FOOTBALLO_PAUSE>:0x160044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Football - Defense | 
 * @normal Genre:  <c 23  >
 */

#define DISEM_DEFAULTDEVICE_23 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_FOOTBALLD_LATERAL>:0x17008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_FOOTBALLD_MOVE>:0x17010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_FOOTBALLD_PLAY>:0x17000401
 *    cycle through available plays */
 /* @normal <c DIBUTTON_FOOTBALLD_SELECT>:0x17000402
 *    select player closest to the ball */
 /* @normal <c DIBUTTON_FOOTBALLD_JUMP>:0x17000403
 *    jump to intercept or block */
 /* @normal <c DIBUTTON_FOOTBALLD_TACKLE>:0x17000404
 *    tackler runner */
 /* @normal <c DIBUTTON_FOOTBALLD_FAKE>:0x17000405
 *    hold down to fake tackle or intercept */
 /* @normal <c DIBUTTON_FOOTBALLD_SUPERTACKLE>:0x17000406
 *    Initiate special tackle */
 /* @normal <c DIBUTTON_FOOTBALLD_MENU>:0x170004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_FOOTBALLD_SPIN>:0x17004407
 *    Spin to beat offensive line */
 /* @normal <c DIBUTTON_FOOTBALLD_SWIM>:0x17004408
 *    Swim to beat the offensive line */
 /* @normal <c DIBUTTON_FOOTBALLD_BULLRUSH>:0x17004409
 *    Bull rush the offensive line */
 /* @normal <c DIBUTTON_FOOTBALLD_RIP>:0x1700440A
 *    Rip the offensive line */
 /* @normal <c DIBUTTON_FOOTBALLD_AUDIBLE>:0x1700440B
 *    Change defensive play at the line of scrimmage */
 /* @normal <c DIBUTTON_FOOTBALLD_ZOOM>:0x1700440C
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_FOOTBALLD_SUBSTITUTE>:0x1700440D
 *    substitute one player for another */
 /* @normal <c DIBUTTON_FOOTBALLD_LEFT_LINK>:0x1700C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_FOOTBALLD_RIGHT_LINK>:0x1700C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_FOOTBALLD_FORWARD_LINK>:0x170144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_FOOTBALLD_BACK_LINK>:0x170144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_FOOTBALLD_DEVICE>:0x170044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_FOOTBALLD_PAUSE>:0x170044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Golf | 
 * @normal Genre:  <c 24  >
 */

#define DISEM_DEFAULTDEVICE_24 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_GOLF_LATERAL>:0x18008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_GOLF_MOVE>:0x18010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_GOLF_SWING>:0x18000401
 *    swing club */
 /* @normal <c DIBUTTON_GOLF_SELECT>:0x18000402
 *    cycle between: club / swing strength / ball arc / ball spin */
 /* @normal <c DIBUTTON_GOLF_UP>:0x18000403
 *    increase selection */
 /* @normal <c DIBUTTON_GOLF_DOWN>:0x18000404
 *    decrease selection */
 /* @normal <c DIBUTTON_GOLF_TERRAIN>:0x18000405
 *    shows terrain detail */
 /* @normal <c DIBUTTON_GOLF_FLYBY>:0x18000406
 *    view the hole via a flyby */
 /* @normal <c DIBUTTON_GOLF_MENU>:0x180004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_GOLF_SCROLL>:0x18004601
 *   scroll view */
 /* @normal <c DIBUTTON_GOLF_ZOOM>:0x18004407
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_GOLF_TIMEOUT>:0x18004408
 *    Call for time out */
 /* @normal <c DIBUTTON_GOLF_SUBSTITUTE>:0x18004409
 *    substitute one player for another */
 /* @normal <c DIBUTTON_GOLF_LEFT_LINK>:0x1800C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_GOLF_RIGHT_LINK>:0x1800C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_GOLF_FORWARD_LINK>:0x180144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_GOLF_BACK_LINK>:0x180144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_GOLF_DEVICE>:0x180044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_GOLF_PAUSE>:0x180044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Hockey - Offense | 
 * @normal Genre:  <c 25  >
 */

#define DISEM_DEFAULTDEVICE_25 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_HOCKEYO_LATERAL>:0x19008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_HOCKEYO_MOVE>:0x19010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_HOCKEYO_SHOOT>:0x19000401
 *    Shoot */
 /* @normal <c DIBUTTON_HOCKEYO_PASS>:0x19000402
 *    pass the puck */
 /* @normal <c DIBUTTON_HOCKEYO_BURST>:0x19000403
 *    invoke speed burst */
 /* @normal <c DIBUTTON_HOCKEYO_SPECIAL>:0x19000404
 *    invoke special move */
 /* @normal <c DIBUTTON_HOCKEYO_FAKE>:0x19000405
 *    hold down to fake pass or kick */
 /* @normal <c DIBUTTON_HOCKEYO_MENU>:0x190004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_HOCKEYO_SCROLL>:0x19004601
 *   scroll view */
 /* @normal <c DIBUTTON_HOCKEYO_ZOOM>:0x19004406
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_HOCKEYO_STRATEGY>:0x19004407
 *    Invoke coaching menu for strategy help */
 /* @normal <c DIBUTTON_HOCKEYO_TIMEOUT>:0x19004408
 *    Call for time out */
 /* @normal <c DIBUTTON_HOCKEYO_SUBSTITUTE>:0x19004409
 *    substitute one player for another */
 /* @normal <c DIBUTTON_HOCKEYO_LEFT_LINK>:0x1900C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_HOCKEYO_RIGHT_LINK>:0x1900C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_HOCKEYO_FORWARD_LINK>:0x190144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_HOCKEYO_BACK_LINK>:0x190144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_HOCKEYO_DEVICE>:0x190044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_HOCKEYO_PAUSE>:0x190044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Hockey - Defense | 
 * @normal Genre:  <c 26  >
 */

#define DISEM_DEFAULTDEVICE_26 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_HOCKEYD_LATERAL>:0x1A008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_HOCKEYD_MOVE>:0x1A010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_HOCKEYD_PLAYER>:0x1A000401
 *    control player closest to the puck */
 /* @normal <c DIBUTTON_HOCKEYD_STEAL>:0x1A000402
 *    attempt steal */
 /* @normal <c DIBUTTON_HOCKEYD_BURST>:0x1A000403
 *    speed burst or body check */
 /* @normal <c DIBUTTON_HOCKEYD_BLOCK>:0x1A000404
 *    block puck */
 /* @normal <c DIBUTTON_HOCKEYD_FAKE>:0x1A000405
 *    hold down to fake tackle or intercept */
 /* @normal <c DIBUTTON_HOCKEYD_MENU>:0x1A0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_HOCKEYD_SCROLL>:0x1A004601
 *   scroll view */
 /* @normal <c DIBUTTON_HOCKEYD_ZOOM>:0x1A004406
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_HOCKEYD_STRATEGY>:0x1A004407
 *    Invoke coaching menu for strategy help */
 /* @normal <c DIBUTTON_HOCKEYD_TIMEOUT>:0x1A004408
 *    Call for time out */
 /* @normal <c DIBUTTON_HOCKEYD_SUBSTITUTE>:0x1A004409
 *    substitute one player for another */
 /* @normal <c DIBUTTON_HOCKEYD_LEFT_LINK>:0x1A00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_HOCKEYD_RIGHT_LINK>:0x1A00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_HOCKEYD_FORWARD_LINK>:0x1A0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_HOCKEYD_BACK_LINK>:0x1A0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_HOCKEYD_DEVICE>:0x1A0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_HOCKEYD_PAUSE>:0x1A0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Hockey - Goalie | 
 * @normal Genre:  <c 27  >
 */

#define DISEM_DEFAULTDEVICE_27 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_HOCKEYG_LATERAL>:0x1B008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_HOCKEYG_MOVE>:0x1B010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_HOCKEYG_PASS>:0x1B000401
 *    pass puck */
 /* @normal <c DIBUTTON_HOCKEYG_POKE>:0x1B000402
 *    poke / check / hack */
 /* @normal <c DIBUTTON_HOCKEYG_STEAL>:0x1B000403
 *    attempt steal */
 /* @normal <c DIBUTTON_HOCKEYG_BLOCK>:0x1B000404
 *    block puck */
 /* @normal <c DIBUTTON_HOCKEYG_MENU>:0x1B0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_HOCKEYG_SCROLL>:0x1B004601
 *   scroll view */
 /* @normal <c DIBUTTON_HOCKEYG_ZOOM>:0x1B004405
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_HOCKEYG_STRATEGY>:0x1B004406
 *    Invoke coaching menu for strategy help */
 /* @normal <c DIBUTTON_HOCKEYG_TIMEOUT>:0x1B004407
 *    Call for time out */
 /* @normal <c DIBUTTON_HOCKEYG_SUBSTITUTE>:0x1B004408
 *    substitute one player for another */
 /* @normal <c DIBUTTON_HOCKEYG_LEFT_LINK>:0x1B00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_HOCKEYG_RIGHT_LINK>:0x1B00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_HOCKEYG_FORWARD_LINK>:0x1B0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_HOCKEYG_BACK_LINK>:0x1B0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_HOCKEYG_DEVICE>:0x1B0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_HOCKEYG_PAUSE>:0x1B0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Mountain Biking | 
 * @normal Genre:  <c 28  >
 */

#define DISEM_DEFAULTDEVICE_28 { DI8DEVTYPE_JOYSTICK, DI8DEVTYPE_GAMEPAD,  }
 /* @normal <c DIAXIS_BIKINGM_TURN>:0x1C008201
 *   left / right */
 /* @normal <c DIAXIS_BIKINGM_PEDAL>:0x1C010202
 *   Pedal faster / slower / brake */
 /* @normal <c DIBUTTON_BIKINGM_JUMP>:0x1C000401
 *    jump over obstacle */
 /* @normal <c DIBUTTON_BIKINGM_CAMERA>:0x1C000402
 *    switch camera view */
 /* @normal <c DIBUTTON_BIKINGM_SPECIAL1>:0x1C000403
 *    perform first special move */
 /* @normal <c DIBUTTON_BIKINGM_SELECT>:0x1C000404
 *    Select */
 /* @normal <c DIBUTTON_BIKINGM_SPECIAL2>:0x1C000405
 *    perform second special move */
 /* @normal <c DIBUTTON_BIKINGM_MENU>:0x1C0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_BIKINGM_SCROLL>:0x1C004601
 *   scroll view */
 /* @normal <c DIBUTTON_BIKINGM_ZOOM>:0x1C004406
 *    Zoom view in / out */
 /* @normal <c DIAXIS_BIKINGM_BRAKE>:0x1C044203
 *   Brake axis  */
 /* @normal <c DIBUTTON_BIKINGM_LEFT_LINK>:0x1C00C4E4
 *    Fallback turn left button */
 /* @normal <c DIBUTTON_BIKINGM_RIGHT_LINK>:0x1C00C4EC
 *    Fallback turn right button */
 /* @normal <c DIBUTTON_BIKINGM_FASTER_LINK>:0x1C0144E0
 *    Fallback pedal faster button */
 /* @normal <c DIBUTTON_BIKINGM_SLOWER_LINK>:0x1C0144E8
 *    Fallback pedal slower button */
 /* @normal <c DIBUTTON_BIKINGM_BRAKE_BUTTON_LINK>:0x1C0444E8
 *    Fallback brake button */
 /* @normal <c DIBUTTON_BIKINGM_DEVICE>:0x1C0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BIKINGM_PAUSE>:0x1C0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports: Skiing / Snowboarding / Skateboarding | 
 * @normal Genre:  <c 29  >
 */

#define DISEM_DEFAULTDEVICE_29 { DI8DEVTYPE_JOYSTICK, DI8DEVTYPE_GAMEPAD ,  }
 /* @normal <c DIAXIS_SKIING_TURN>:0x1D008201
 *   left / right */
 /* @normal <c DIAXIS_SKIING_SPEED>:0x1D010202
 *   faster / slower */
 /* @normal <c DIBUTTON_SKIING_JUMP>:0x1D000401
 *    Jump */
 /* @normal <c DIBUTTON_SKIING_CROUCH>:0x1D000402
 *    crouch down */
 /* @normal <c DIBUTTON_SKIING_CAMERA>:0x1D000403
 *    switch camera view */
 /* @normal <c DIBUTTON_SKIING_SPECIAL1>:0x1D000404
 *    perform first special move */
 /* @normal <c DIBUTTON_SKIING_SELECT>:0x1D000405
 *    Select */
 /* @normal <c DIBUTTON_SKIING_SPECIAL2>:0x1D000406
 *    perform second special move */
 /* @normal <c DIBUTTON_SKIING_MENU>:0x1D0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_SKIING_GLANCE>:0x1D004601
 *   scroll view */
 /* @normal <c DIBUTTON_SKIING_ZOOM>:0x1D004407
 *    Zoom view in / out */
 /* @normal <c DIBUTTON_SKIING_LEFT_LINK>:0x1D00C4E4
 *    Fallback turn left button */
 /* @normal <c DIBUTTON_SKIING_RIGHT_LINK>:0x1D00C4EC
 *    Fallback turn right button */
 /* @normal <c DIBUTTON_SKIING_FASTER_LINK>:0x1D0144E0
 *    Fallback increase speed button */
 /* @normal <c DIBUTTON_SKIING_SLOWER_LINK>:0x1D0144E8
 *    Fallback decrease speed button */
 /* @normal <c DIBUTTON_SKIING_DEVICE>:0x1D0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_SKIING_PAUSE>:0x1D0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Soccer - Offense | 
 * @normal Genre:  <c 30  >
 */

#define DISEM_DEFAULTDEVICE_30 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_SOCCERO_LATERAL>:0x1E008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_SOCCERO_MOVE>:0x1E010202
 *   Move / Aim: up / down */
 /* @normal <c DIAXIS_SOCCERO_BEND>:0x1E018203
 *   Bend to soccer shot/pass */
 /* @normal <c DIBUTTON_SOCCERO_SHOOT>:0x1E000401
 *    Shoot the ball */
 /* @normal <c DIBUTTON_SOCCERO_PASS>:0x1E000402
 *    Pass  */
 /* @normal <c DIBUTTON_SOCCERO_FAKE>:0x1E000403
 *    Fake */
 /* @normal <c DIBUTTON_SOCCERO_PLAYER>:0x1E000404
 *    Select next player */
 /* @normal <c DIBUTTON_SOCCERO_SPECIAL1>:0x1E000405
 *    Apply special move */
 /* @normal <c DIBUTTON_SOCCERO_SELECT>:0x1E000406
 *    Select special move */
 /* @normal <c DIBUTTON_SOCCERO_MENU>:0x1E0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_SOCCERO_GLANCE>:0x1E004601
 *   scroll view */
 /* @normal <c DIBUTTON_SOCCERO_SUBSTITUTE>:0x1E004407
 *    Substitute one player for another */
 /* @normal <c DIBUTTON_SOCCERO_SHOOTLOW>:0x1E004408
 *    Shoot the ball low */
 /* @normal <c DIBUTTON_SOCCERO_SHOOTHIGH>:0x1E004409
 *    Shoot the ball high */
 /* @normal <c DIBUTTON_SOCCERO_PASSTHRU>:0x1E00440A
 *    Make a thru pass */
 /* @normal <c DIBUTTON_SOCCERO_SPRINT>:0x1E00440B
 *    Sprint / turbo boost */
 /* @normal <c DIBUTTON_SOCCERO_CONTROL>:0x1E00440C
 *    Obtain control of the ball */
 /* @normal <c DIBUTTON_SOCCERO_HEAD>:0x1E00440D
 *    Attempt to head the ball */
 /* @normal <c DIBUTTON_SOCCERO_LEFT_LINK>:0x1E00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_SOCCERO_RIGHT_LINK>:0x1E00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_SOCCERO_FORWARD_LINK>:0x1E0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_SOCCERO_BACK_LINK>:0x1E0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_SOCCERO_DEVICE>:0x1E0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_SOCCERO_PAUSE>:0x1E0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Soccer - Defense | 
 * @normal Genre:  <c 31  >
 */

#define DISEM_DEFAULTDEVICE_31 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_SOCCERD_LATERAL>:0x1F008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_SOCCERD_MOVE>:0x1F010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_SOCCERD_BLOCK>:0x1F000401
 *    Attempt to block shot */
 /* @normal <c DIBUTTON_SOCCERD_STEAL>:0x1F000402
 *    Attempt to steal ball */
 /* @normal <c DIBUTTON_SOCCERD_FAKE>:0x1F000403
 *    Fake a block or a steal */
 /* @normal <c DIBUTTON_SOCCERD_PLAYER>:0x1F000404
 *    Select next player */
 /* @normal <c DIBUTTON_SOCCERD_SPECIAL>:0x1F000405
 *    Apply special move */
 /* @normal <c DIBUTTON_SOCCERD_SELECT>:0x1F000406
 *    Select special move */
 /* @normal <c DIBUTTON_SOCCERD_SLIDE>:0x1F000407
 *    Attempt a slide tackle */
 /* @normal <c DIBUTTON_SOCCERD_MENU>:0x1F0004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_SOCCERD_GLANCE>:0x1F004601
 *   scroll view */
 /* @normal <c DIBUTTON_SOCCERD_FOUL>:0x1F004408
 *    Initiate a foul / hard-foul */
 /* @normal <c DIBUTTON_SOCCERD_HEAD>:0x1F004409
 *    Attempt a Header */
 /* @normal <c DIBUTTON_SOCCERD_CLEAR>:0x1F00440A
 *    Attempt to clear the ball down the field */
 /* @normal <c DIBUTTON_SOCCERD_GOALIECHARGE>:0x1F00440B
 *    Make the goalie charge out of the box */
 /* @normal <c DIBUTTON_SOCCERD_SUBSTITUTE>:0x1F00440C
 *    Substitute one player for another */
 /* @normal <c DIBUTTON_SOCCERD_LEFT_LINK>:0x1F00C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_SOCCERD_RIGHT_LINK>:0x1F00C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_SOCCERD_FORWARD_LINK>:0x1F0144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_SOCCERD_BACK_LINK>:0x1F0144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_SOCCERD_DEVICE>:0x1F0044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_SOCCERD_PAUSE>:0x1F0044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Sports - Racquet | 
 * @normal Genre:  <c 32  >
 */

#define DISEM_DEFAULTDEVICE_32 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_RACQUET_LATERAL>:0x20008201
 *   Move / Aim: left / right */
 /* @normal <c DIAXIS_RACQUET_MOVE>:0x20010202
 *   Move / Aim: up / down */
 /* @normal <c DIBUTTON_RACQUET_SWING>:0x20000401
 *    Swing racquet */
 /* @normal <c DIBUTTON_RACQUET_BACKSWING>:0x20000402
 *    Swing backhand */
 /* @normal <c DIBUTTON_RACQUET_SMASH>:0x20000403
 *    Smash shot */
 /* @normal <c DIBUTTON_RACQUET_SPECIAL>:0x20000404
 *    Special shot */
 /* @normal <c DIBUTTON_RACQUET_SELECT>:0x20000405
 *    Select special shot */
 /* @normal <c DIBUTTON_RACQUET_MENU>:0x200004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_RACQUET_GLANCE>:0x20004601
 *   scroll view */
 /* @normal <c DIBUTTON_RACQUET_TIMEOUT>:0x20004406
 *    Call for time out */
 /* @normal <c DIBUTTON_RACQUET_SUBSTITUTE>:0x20004407
 *    Substitute one player for another */
 /* @normal <c DIBUTTON_RACQUET_LEFT_LINK>:0x2000C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_RACQUET_RIGHT_LINK>:0x2000C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_RACQUET_FORWARD_LINK>:0x200144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_RACQUET_BACK_LINK>:0x200144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_RACQUET_DEVICE>:0x200044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_RACQUET_PAUSE>:0x200044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Arcade- 2D | 
 * @normal Genre:  <c 33  >
 */

#define DISEM_DEFAULTDEVICE_33 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_ARCADES_LATERAL>:0x21008201
 *   left / right */
 /* @normal <c DIAXIS_ARCADES_MOVE>:0x21010202
 *   up / down */
 /* @normal <c DIBUTTON_ARCADES_THROW>:0x21000401
 *    throw object */
 /* @normal <c DIBUTTON_ARCADES_CARRY>:0x21000402
 *    carry object */
 /* @normal <c DIBUTTON_ARCADES_ATTACK>:0x21000403
 *    attack */
 /* @normal <c DIBUTTON_ARCADES_SPECIAL>:0x21000404
 *    apply special move */
 /* @normal <c DIBUTTON_ARCADES_SELECT>:0x21000405
 *    select special move */
 /* @normal <c DIBUTTON_ARCADES_MENU>:0x210004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_ARCADES_VIEW>:0x21004601
 *   scroll view left / right / up / down */
 /* @normal <c DIBUTTON_ARCADES_LEFT_LINK>:0x2100C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_ARCADES_RIGHT_LINK>:0x2100C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_ARCADES_FORWARD_LINK>:0x210144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_ARCADES_BACK_LINK>:0x210144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_ARCADES_VIEW_UP_LINK>:0x2107C4E0
 *    Fallback scroll view up button */
 /* @normal <c DIBUTTON_ARCADES_VIEW_DOWN_LINK>:0x2107C4E8
 *    Fallback scroll view down button */
 /* @normal <c DIBUTTON_ARCADES_VIEW_LEFT_LINK>:0x2107C4E4
 *    Fallback scroll view left button */
 /* @normal <c DIBUTTON_ARCADES_VIEW_RIGHT_LINK>:0x2107C4EC
 *    Fallback scroll view right button */
 /* @normal <c DIBUTTON_ARCADES_DEVICE>:0x210044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_ARCADES_PAUSE>:0x210044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Arcade - Platform Game | 
 * @normal Genre:  <c 34  >
 */

#define DISEM_DEFAULTDEVICE_34 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_ARCADEP_LATERAL>:0x22008201
 *   Left / right */
 /* @normal <c DIAXIS_ARCADEP_MOVE>:0x22010202
 *   Up / down */
 /* @normal <c DIBUTTON_ARCADEP_JUMP>:0x22000401
 *    Jump */
 /* @normal <c DIBUTTON_ARCADEP_FIRE>:0x22000402
 *    Fire */
 /* @normal <c DIBUTTON_ARCADEP_CROUCH>:0x22000403
 *    Crouch */
 /* @normal <c DIBUTTON_ARCADEP_SPECIAL>:0x22000404
 *    Apply special move */
 /* @normal <c DIBUTTON_ARCADEP_SELECT>:0x22000405
 *    Select special move */
 /* @normal <c DIBUTTON_ARCADEP_MENU>:0x220004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_ARCADEP_VIEW>:0x22004601
 *   Scroll view */
 /* @normal <c DIBUTTON_ARCADEP_FIRESECONDARY>:0x22004406
 *    Alternative fire button */
 /* @normal <c DIBUTTON_ARCADEP_LEFT_LINK>:0x2200C4E4
 *    Fallback sidestep left button */
 /* @normal <c DIBUTTON_ARCADEP_RIGHT_LINK>:0x2200C4EC
 *    Fallback sidestep right button */
 /* @normal <c DIBUTTON_ARCADEP_FORWARD_LINK>:0x220144E0
 *    Fallback move forward button */
 /* @normal <c DIBUTTON_ARCADEP_BACK_LINK>:0x220144E8
 *    Fallback move back button */
 /* @normal <c DIBUTTON_ARCADEP_VIEW_UP_LINK>:0x2207C4E0
 *    Fallback scroll view up button */
 /* @normal <c DIBUTTON_ARCADEP_VIEW_DOWN_LINK>:0x2207C4E8
 *    Fallback scroll view down button */
 /* @normal <c DIBUTTON_ARCADEP_VIEW_LEFT_LINK>:0x2207C4E4
 *    Fallback scroll view left button */
 /* @normal <c DIBUTTON_ARCADEP_VIEW_RIGHT_LINK>:0x2207C4EC
 *    Fallback scroll view right button */
 /* @normal <c DIBUTTON_ARCADEP_DEVICE>:0x220044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_ARCADEP_PAUSE>:0x220044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics CAD - 2D Object Control | 
 * @normal Genre:  <c 35  >
 */

#define DISEM_DEFAULTDEVICE_35 { DI8DEVTYPE_1STPERSON, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_2DCONTROL_LATERAL>:0x23008201
 *   Move view left / right */
 /* @normal <c DIAXIS_2DCONTROL_MOVE>:0x23010202
 *   Move view up / down */
 /* @normal <c DIAXIS_2DCONTROL_INOUT>:0x23018203
 *   Zoom - in / out */
 /* @normal <c DIBUTTON_2DCONTROL_SELECT>:0x23000401
 *    Select Object */
 /* @normal <c DIBUTTON_2DCONTROL_SPECIAL1>:0x23000402
 *    Do first special operation */
 /* @normal <c DIBUTTON_2DCONTROL_SPECIAL>:0x23000403
 *    Select special operation */
 /* @normal <c DIBUTTON_2DCONTROL_SPECIAL2>:0x23000404
 *    Do second special operation */
 /* @normal <c DIBUTTON_2DCONTROL_MENU>:0x230004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_2DCONTROL_HATSWITCH>:0x23004601
 *   Hat switch */
 /* @normal <c DIAXIS_2DCONTROL_ROTATEZ>:0x23024204
 *   Rotate view clockwise / counterclockwise */
 /* @normal <c DIBUTTON_2DCONTROL_DISPLAY>:0x23004405
 *    Shows next on-screen display options */
 /* @normal <c DIBUTTON_2DCONTROL_DEVICE>:0x230044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_2DCONTROL_PAUSE>:0x230044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics CAD - 3D object control | 
 * @normal Genre:  <c 36  >
 */

#define DISEM_DEFAULTDEVICE_36 { DI8DEVTYPE_1STPERSON, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_3DCONTROL_LATERAL>:0x24008201
 *   Move view left / right */
 /* @normal <c DIAXIS_3DCONTROL_MOVE>:0x24010202
 *   Move view up / down */
 /* @normal <c DIAXIS_3DCONTROL_INOUT>:0x24018203
 *   Zoom - in / out */
 /* @normal <c DIBUTTON_3DCONTROL_SELECT>:0x24000401
 *    Select Object */
 /* @normal <c DIBUTTON_3DCONTROL_SPECIAL1>:0x24000402
 *    Do first special operation */
 /* @normal <c DIBUTTON_3DCONTROL_SPECIAL>:0x24000403
 *    Select special operation */
 /* @normal <c DIBUTTON_3DCONTROL_SPECIAL2>:0x24000404
 *    Do second special operation */
 /* @normal <c DIBUTTON_3DCONTROL_MENU>:0x240004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_3DCONTROL_HATSWITCH>:0x24004601
 *   Hat switch */
 /* @normal <c DIAXIS_3DCONTROL_ROTATEX>:0x24034204
 *   Rotate view forward or up / backward or down */
 /* @normal <c DIAXIS_3DCONTROL_ROTATEY>:0x2402C205
 *   Rotate view clockwise / counterclockwise */
 /* @normal <c DIAXIS_3DCONTROL_ROTATEZ>:0x24024206
 *   Rotate view left / right */
 /* @normal <c DIBUTTON_3DCONTROL_DISPLAY>:0x24004405
 *    Show next on-screen display options */
 /* @normal <c DIBUTTON_3DCONTROL_DEVICE>:0x240044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_3DCONTROL_PAUSE>:0x240044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics CAD - 3D Navigation - Fly through | 
 * @normal Genre:  <c 37  >
 */

#define DISEM_DEFAULTDEVICE_37 { DI8DEVTYPE_1STPERSON, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_CADF_LATERAL>:0x25008201
 *   move view left / right */
 /* @normal <c DIAXIS_CADF_MOVE>:0x25010202
 *   move view up / down */
 /* @normal <c DIAXIS_CADF_INOUT>:0x25018203
 *   in / out */
 /* @normal <c DIBUTTON_CADF_SELECT>:0x25000401
 *    Select Object */
 /* @normal <c DIBUTTON_CADF_SPECIAL1>:0x25000402
 *    do first special operation */
 /* @normal <c DIBUTTON_CADF_SPECIAL>:0x25000403
 *    Select special operation */
 /* @normal <c DIBUTTON_CADF_SPECIAL2>:0x25000404
 *    do second special operation */
 /* @normal <c DIBUTTON_CADF_MENU>:0x250004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_CADF_HATSWITCH>:0x25004601
 *   Hat switch */
 /* @normal <c DIAXIS_CADF_ROTATEX>:0x25034204
 *   Rotate view forward or up / backward or down */
 /* @normal <c DIAXIS_CADF_ROTATEY>:0x2502C205
 *   Rotate view clockwise / counterclockwise */
 /* @normal <c DIAXIS_CADF_ROTATEZ>:0x25024206
 *   Rotate view left / right */
 /* @normal <c DIBUTTON_CADF_DISPLAY>:0x25004405
 *    shows next on-screen display options */
 /* @normal <c DIBUTTON_CADF_DEVICE>:0x250044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_CADF_PAUSE>:0x250044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics CAD - 3D Model Control | 
 * @normal Genre:  <c 38  >
 */

#define DISEM_DEFAULTDEVICE_38 { DI8DEVTYPE_1STPERSON, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_CADM_LATERAL>:0x26008201
 *   move view left / right */
 /* @normal <c DIAXIS_CADM_MOVE>:0x26010202
 *   move view up / down */
 /* @normal <c DIAXIS_CADM_INOUT>:0x26018203
 *   in / out */
 /* @normal <c DIBUTTON_CADM_SELECT>:0x26000401
 *    Select Object */
 /* @normal <c DIBUTTON_CADM_SPECIAL1>:0x26000402
 *    do first special operation */
 /* @normal <c DIBUTTON_CADM_SPECIAL>:0x26000403
 *    Select special operation */
 /* @normal <c DIBUTTON_CADM_SPECIAL2>:0x26000404
 *    do second special operation */
 /* @normal <c DIBUTTON_CADM_MENU>:0x260004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIHATSWITCH_CADM_HATSWITCH>:0x26004601
 *   Hat switch */
 /* @normal <c DIAXIS_CADM_ROTATEX>:0x26034204
 *   Rotate view forward or up / backward or down */
 /* @normal <c DIAXIS_CADM_ROTATEY>:0x2602C205
 *   Rotate view clockwise / counterclockwise */
 /* @normal <c DIAXIS_CADM_ROTATEZ>:0x26024206
 *   Rotate view left / right */
 /* @normal <c DIBUTTON_CADM_DISPLAY>:0x26004405
 *    shows next on-screen display options */
 /* @normal <c DIBUTTON_CADM_DEVICE>:0x260044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_CADM_PAUSE>:0x260044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Control - Media Equipment | 
 * @normal Genre:  <c 39  >
 */

#define DISEM_DEFAULTDEVICE_39 { DI8DEVTYPE_GAMEPAD,  }
 /* @normal <c DIAXIS_REMOTE_SLIDER>:0x27050201
 *   Slider for adjustment: volume / color / bass / etc */
 /* @normal <c DIBUTTON_REMOTE_MUTE>:0x27000401
 *    Set volume on current device to zero */
 /* @normal <c DIBUTTON_REMOTE_SELECT>:0x27000402
 *    Next/previous: channel/ track / chapter / picture / station */
 /* @normal <c DIBUTTON_REMOTE_PLAY>:0x27002403
 *    Start or pause entertainment on current device */
 /* @normal <c DIBUTTON_REMOTE_CUE>:0x27002404
 *    Move through current media */
 /* @normal <c DIBUTTON_REMOTE_REVIEW>:0x27002405
 *    Move through current media */
 /* @normal <c DIBUTTON_REMOTE_CHANGE>:0x27002406
 *    Select next device */
 /* @normal <c DIBUTTON_REMOTE_RECORD>:0x27002407
 *    Start recording the current media */
 /* @normal <c DIBUTTON_REMOTE_MENU>:0x270004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIAXIS_REMOTE_SLIDER2>:0x27054202
 *   Slider for adjustment: volume */
 /* @normal <c DIBUTTON_REMOTE_TV>:0x27005C08
 *    Select TV */
 /* @normal <c DIBUTTON_REMOTE_CABLE>:0x27005C09
 *    Select cable box */
 /* @normal <c DIBUTTON_REMOTE_CD>:0x27005C0A
 *    Select CD player */
 /* @normal <c DIBUTTON_REMOTE_VCR>:0x27005C0B
 *    Select VCR */
 /* @normal <c DIBUTTON_REMOTE_TUNER>:0x27005C0C
 *    Select tuner */
 /* @normal <c DIBUTTON_REMOTE_DVD>:0x27005C0D
 *    Select DVD player */
 /* @normal <c DIBUTTON_REMOTE_ADJUST>:0x27005C0E
 *    Enter device adjustment menu */
 /* @normal <c DIBUTTON_REMOTE_DIGIT0>:0x2700540F
 *    Digit 0 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT1>:0x27005410
 *    Digit 1 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT2>:0x27005411
 *    Digit 2 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT3>:0x27005412
 *    Digit 3 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT4>:0x27005413
 *    Digit 4 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT5>:0x27005414
 *    Digit 5 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT6>:0x27005415
 *    Digit 6 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT7>:0x27005416
 *    Digit 7 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT8>:0x27005417
 *    Digit 8 */
 /* @normal <c DIBUTTON_REMOTE_DIGIT9>:0x27005418
 *    Digit 9 */
 /* @normal <c DIBUTTON_REMOTE_DEVICE>:0x270044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_REMOTE_PAUSE>:0x270044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Control- Web | 
 * @normal Genre:  <c 40  >
 */

#define DISEM_DEFAULTDEVICE_40 { DI8DEVTYPE_GAMEPAD, DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_BROWSER_LATERAL>:0x28008201
 *   Move on screen pointer */
 /* @normal <c DIAXIS_BROWSER_MOVE>:0x28010202
 *   Move on screen pointer */
 /* @normal <c DIBUTTON_BROWSER_SELECT>:0x28000401
 *    Select current item */
 /* @normal <c DIAXIS_BROWSER_VIEW>:0x28018203
 *   Move view up/down */
 /* @normal <c DIBUTTON_BROWSER_REFRESH>:0x28000402
 *    Refresh */
 /* @normal <c DIBUTTON_BROWSER_MENU>:0x280004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_BROWSER_SEARCH>:0x28004403
 *    Use search tool */
 /* @normal <c DIBUTTON_BROWSER_STOP>:0x28004404
 *    Cease current update */
 /* @normal <c DIBUTTON_BROWSER_HOME>:0x28004405
 *    Go directly to "home" location */
 /* @normal <c DIBUTTON_BROWSER_FAVORITES>:0x28004406
 *    Mark current site as favorite */
 /* @normal <c DIBUTTON_BROWSER_NEXT>:0x28004407
 *    Select Next page */
 /* @normal <c DIBUTTON_BROWSER_PREVIOUS>:0x28004408
 *    Select Previous page */
 /* @normal <c DIBUTTON_BROWSER_HISTORY>:0x28004409
 *    Show/Hide History */
 /* @normal <c DIBUTTON_BROWSER_PRINT>:0x2800440A
 *    Print current page */
 /* @normal <c DIBUTTON_BROWSER_DEVICE>:0x280044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_BROWSER_PAUSE>:0x280044FC
 *    Start / Pause / Restart game */
/* @doc EXTERNAL 
 * @Semantics Driving Simulator - Giant Walking Robot | 
 * @normal Genre:  <c 41  >
 */

#define DISEM_DEFAULTDEVICE_41 { DI8DEVTYPE_JOYSTICK,  }
 /* @normal <c DIAXIS_MECHA_STEER>:0x29008201
 *   Turns mecha left/right */
 /* @normal <c DIAXIS_MECHA_TORSO>:0x29010202
 *   Tilts torso forward/backward */
 /* @normal <c DIAXIS_MECHA_ROTATE>:0x29020203
 *   Turns torso left/right */
 /* @normal <c DIAXIS_MECHA_THROTTLE>:0x29038204
 *   Engine Speed */
 /* @normal <c DIBUTTON_MECHA_FIRE>:0x29000401
 *    Fire */
 /* @normal <c DIBUTTON_MECHA_WEAPONS>:0x29000402
 *    Select next weapon group */
 /* @normal <c DIBUTTON_MECHA_TARGET>:0x29000403
 *    Select closest enemy available target */
 /* @normal <c DIBUTTON_MECHA_REVERSE>:0x29000404
 *    Toggles throttle in/out of reverse */
 /* @normal <c DIBUTTON_MECHA_ZOOM>:0x29000405
 *    Zoom in/out targeting reticule */
 /* @normal <c DIBUTTON_MECHA_JUMP>:0x29000406
 *    Fires jump jets */
 /* @normal <c DIBUTTON_MECHA_MENU>:0x290004FD
 *    Show menu options */
/*--- @normal <c Priority2 Commands>                 ---*/
 /* @normal <c DIBUTTON_MECHA_CENTER>:0x29004407
 *    Center torso to legs */
 /* @normal <c DIHATSWITCH_MECHA_GLANCE>:0x29004601
 *   Look around */
 /* @normal <c DIBUTTON_MECHA_VIEW>:0x29004408
 *    Cycle through view options */
 /* @normal <c DIBUTTON_MECHA_FIRESECONDARY>:0x29004409
 *    Alternative fire button */
 /* @normal <c DIBUTTON_MECHA_LEFT_LINK>:0x2900C4E4
 *    Fallback steer left button */
 /* @normal <c DIBUTTON_MECHA_RIGHT_LINK>:0x2900C4EC
 *    Fallback steer right button */
 /* @normal <c DIBUTTON_MECHA_FORWARD_LINK>:0x290144E0
 *    Fallback tilt torso forward button */
 /* @normal <c DIBUTTON_MECHA_BACK_LINK>:0x290144E8
 *    Fallback tilt toroso backward button */
 /* @normal <c DIBUTTON_MECHA_ROTATE_LEFT_LINK>:0x290244E4
 *    Fallback rotate toroso right button */
 /* @normal <c DIBUTTON_MECHA_ROTATE_RIGHT_LINK>:0x290244EC
 *    Fallback rotate torso left button */
 /* @normal <c DIBUTTON_MECHA_FASTER_LINK>:0x2903C4E0
 *    Fallback increase engine speed */
 /* @normal <c DIBUTTON_MECHA_SLOWER_LINK>:0x2903C4E8
 *    Fallback decrease engine speed */
 /* @normal <c DIBUTTON_MECHA_DEVICE>:0x290044FE
 *    Show input device and controls */
 /* @normal <c DIBUTTON_MECHA_PAUSE>:0x290044FC
 *    Start / Pause / Restart game */


#define DIAS_INDEX_SPECIAL                      0xFC
#define DIAS_INDEX_LINK                         0xE0
#define DIGENRE_ANY                             0xFF
#define DISEMGENRE_ANY                          0xFF000000
#define DISEM_TYPEANDMODE_GET(x)                ( ( x & ( DISEM_TYPE_MASK | DISEM_REL_MASK ) ) >> DISEM_REL_SHIFT )
#define DISEM_VALID                             ( ~DISEM_RES_MASK )

#if (DIRECTINPUT_VERSION >= 0x0800)
#define DISEM_MAX_GENRE      41
static const BYTE DiGenreDeviceOrder[DISEM_MAX_GENRE][DI8DEVTYPE_MAX-DI8DEVTYPE_MIN]={
DISEM_DEFAULTDEVICE_1,
DISEM_DEFAULTDEVICE_2,
DISEM_DEFAULTDEVICE_3,
DISEM_DEFAULTDEVICE_4,
DISEM_DEFAULTDEVICE_5,
DISEM_DEFAULTDEVICE_6,
DISEM_DEFAULTDEVICE_7,
DISEM_DEFAULTDEVICE_8,
DISEM_DEFAULTDEVICE_9,
DISEM_DEFAULTDEVICE_10,
DISEM_DEFAULTDEVICE_11,
DISEM_DEFAULTDEVICE_12,
DISEM_DEFAULTDEVICE_13,
DISEM_DEFAULTDEVICE_14,
DISEM_DEFAULTDEVICE_15,
DISEM_DEFAULTDEVICE_16,
DISEM_DEFAULTDEVICE_17,
DISEM_DEFAULTDEVICE_18,
DISEM_DEFAULTDEVICE_19,
DISEM_DEFAULTDEVICE_20,
DISEM_DEFAULTDEVICE_21,
DISEM_DEFAULTDEVICE_22,
DISEM_DEFAULTDEVICE_23,
DISEM_DEFAULTDEVICE_24,
DISEM_DEFAULTDEVICE_25,
DISEM_DEFAULTDEVICE_26,
DISEM_DEFAULTDEVICE_27,
DISEM_DEFAULTDEVICE_28,
DISEM_DEFAULTDEVICE_29,
DISEM_DEFAULTDEVICE_30,
DISEM_DEFAULTDEVICE_31,
DISEM_DEFAULTDEVICE_32,
DISEM_DEFAULTDEVICE_33,
DISEM_DEFAULTDEVICE_34,
DISEM_DEFAULTDEVICE_35,
DISEM_DEFAULTDEVICE_36,
DISEM_DEFAULTDEVICE_37,
DISEM_DEFAULTDEVICE_38,
DISEM_DEFAULTDEVICE_39,
DISEM_DEFAULTDEVICE_40,
DISEM_DEFAULTDEVICE_41,

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\disysdef.h ===
#ifndef __DISYSDEF_H__
#define __DISYSDEF_H__

// IOCTLs defined here are only for NT builds to work with DINPUT.SYS

#ifdef WINNT

#undef IOCTL_FIRST
#define IOCTL_FIRST 0x0800

#undef IOCTL_GETVERSION
#define IOCTL_GETVERSION 0x0000

#undef IOCTL_INPUTLOST
#define IOCTL_INPUTLOST           CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_DESTROYINSTANCE
#define IOCTL_DESTROYINSTANCE     CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_SETDATAFORMAT
#define IOCTL_SETDATAFORMAT       CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_ACQUIREINSTANCE
#define IOCTL_ACQUIREINSTANCE     CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_UNACQUIREINSTANCE
#define IOCTL_UNACQUIREINSTANCE   CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_SETNOTIFYHANDLE
#define IOCTL_SETNOTIFYHANDLE     CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_SETBUFFERSIZE
#define IOCTL_SETBUFFERSIZE       CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+6, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Keyboard class IOCTLs
#undef IOCTL_KBD_CREATEINSTANCE
#define IOCTL_KBD_CREATEINSTANCE   CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_KBD_INITKEYS
#define IOCTL_KBD_INITKEYS         CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+8, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Mouse class IOCTLs
#undef IOCTL_MOUSE_CREATEINSTANCE
#define IOCTL_MOUSE_CREATEINSTANCE CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_MOUSE_INITBUTTONS
#define IOCTL_MOUSE_INITBUTTONS    CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+10, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Joystick class IOCTLs
#undef IOCTL_JOY_CREATEINSTANCE
#define IOCTL_JOY_CREATEINSTANCE   CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_PING
#define IOCTL_JOY_PING             CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_GETINITPARMS
#define IOCTL_JOY_GETINITPARMS     CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_FFIO
#define IOCTL_JOY_FFIO             CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_GETSEQUENCEPTR
#define IOCTL_GETSEQUENCEPTR       CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_GETAXES
#define IOCTL_JOY_GETAXES          CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+16, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_MOUSE_GETWHEEL
#define IOCTL_MOUSE_GETWHEEL       CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+17, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_JOY_CONFIGCHANGED
#define IOCTL_JOY_CONFIGCHANGED    CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+18, METHOD_BUFFERED, FILE_ANY_ACCESS)
#undef IOCTL_MAX
#define IOCTL_MAX                  CTL_CODE(FILE_DEVICE_KEYBOARD, IOCTL_FIRST+19, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif  // WINNT

#endif  // __DISYSDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\dsextend.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1995-2000.
//
//--------------------------------------------------------------------------;
//
// dsextend.cpp : implementation of various direct show extension classes
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "ksextend.h"
#include "dsextend.h"

const int MAX_OCCURRENCE_COUNT = 2;

static DWORD dwFetch;
#if 0
// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap
// and calling it in our dllmain.

// DSGraphContainer
std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT> * DSGraphContainer::Fetch = &std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT>(&IGraphBuilder::EnumFilters);
std_arity0pmf<IEnumFilters, HRESULT> * DSGraphContainer::iterator::Reset = &std_arity0_member(&IEnumFilters::Reset);
std_arity1pmf<IEnumFilters, IBaseFilter **, HRESULT> * DSGraphContainer::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumFilters::Next), 1, &dwFetch);

// DSFilter
std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT> * DSFilter::Fetch = &std_arity1_member(&IBaseFilter::EnumPins);
std_arity0pmf<IEnumPins, HRESULT> * DSFilter::iterator::Reset = &std_arity0_member(&IEnumPins::Reset);
std_arity1pmf<IEnumPins, IPin **, HRESULT> * DSFilter::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumPins::Next), 1, &dwFetch);

// DSDevices
std_arity1pmf<ICreateDevEnum, IEnumMoniker **, HRESULT> * DSDeviceSequence::Fetch = NULL;  // no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
std_arity0pmf<IEnumMoniker, HRESULT> * DSDevices::iterator::Reset = &std_arity0_member(&IEnumMoniker::Reset);
std_arity1pmf<IEnumMoniker, IMoniker **, HRESULT> * DSDevices::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumMoniker::Next), 1, &dwFetch);

// DSFilterMapper
std_arity1pmf<IFilterMapper2, IEnumMoniker **, HRESULT> * DSFilterMapperSequence::Fetch = NULL;// no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
// uses same types as DSDevices so its the same template expansion, already initialized

// DSPin
std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT> * DSPin::Fetch = &std_arity1_member(&IPin::EnumMediaTypes);
std_arity0pmf<IEnumMediaTypes, HRESULT> * DSPin::iterator::Reset = &std_arity0_member(&IEnumMediaTypes::Reset);
std_arity1pmf<IEnumMediaTypes, AM_MEDIA_TYPE **, HRESULT> * DSPin::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumMediaTypes::Next), 1, &dwFetch);
#else
// DSGraphContainer
std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT> * DSGraphContainer::Fetch = NULL;
std_arity0pmf<IEnumFilters, HRESULT> * DSGraphContainer::iterator::Reset = NULL;
std_arity1pmf<IEnumFilters, IBaseFilter **, HRESULT> * DSGraphContainer::iterator::Next = NULL;

// DSFilter
std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT> * DSFilter::Fetch = NULL;
std_arity0pmf<IEnumPins, HRESULT> * DSFilter::iterator::Reset = NULL;
std_arity1pmf<IEnumPins, IPin **, HRESULT> * DSFilter::iterator::Next = NULL;

// DSDevices
std_arity1pmf<ICreateDevEnum, IEnumMoniker **, HRESULT> * DSDeviceSequence::Fetch = NULL;  // no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
std_arity0pmf<IEnumMoniker, HRESULT> * DSDevices::iterator::Reset = NULL;
std_arity1pmf<IEnumMoniker, IMoniker **, HRESULT> * DSDevices::iterator::Next = NULL;

// DSFilterMapper
std_arity1pmf<IFilterMapper2, IEnumMoniker **, HRESULT> * DSFilterMapperSequence::Fetch = NULL;// no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
// uses same types as DSDevices so its the same template expansion, already initialized

// DSPin
std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT> * DSPin::Fetch = NULL;
std_arity0pmf<IEnumMediaTypes, HRESULT> * DSPin::iterator::Reset = NULL;
std_arity1pmf<IEnumMediaTypes, AM_MEDIA_TYPE **, HRESULT> * DSPin::iterator::Next = NULL;
#endif


// work around compiler bug as per above description
void CtorStaticDSExtendFwdSeqPMFs(void) {
    // DSGraphContainer
    DSGraphContainer::Fetch = new std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT>(&IGraphBuilder::EnumFilters);
    DSGraphContainer::iterator::Reset = new std_arity0pmf<IEnumFilters, HRESULT>(&IEnumFilters::Reset);
    DSGraphContainer::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumFilters, ULONG, IBaseFilter**, ULONG *, HRESULT> >(std_arity3_member(&IEnumFilters::Next), 1, &dwFetch);

    // DSFilter
    DSFilter::Fetch = new std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT>(&IBaseFilter::EnumPins);
    DSFilter::iterator::Reset = new std_arity0pmf<IEnumPins, HRESULT>(&IEnumPins::Reset);
    DSFilter::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumPins, ULONG, IPin **, ULONG *, HRESULT> >(std_arity3_member(&IEnumPins::Next), 1, &dwFetch);

    // DSDevices
    // DSDeviceSequence::Fetch,  no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
    DSDevices::iterator::Reset = new std_arity0pmf<IEnumMoniker, HRESULT>(&IEnumMoniker::Reset);
    DSDevices::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumMoniker, ULONG, IMoniker **, ULONG *, HRESULT> >(std_arity3_member(&IEnumMoniker::Next), 1, &dwFetch);

    // DSFilterMapper, no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
    // uses same types as DSDevices so its the same template expansion, already initialized

    // DSPin
    DSPin::Fetch = new std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT>(&IPin::EnumMediaTypes);
    DSPin::iterator::Reset = new std_arity0pmf<IEnumMediaTypes, HRESULT>(&IEnumMediaTypes::Reset);
    DSPin::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumMediaTypes, DWORD, AM_MEDIA_TYPE **, DWORD *, HRESULT> >(std_arity3_member(&IEnumMediaTypes::Next), 1, &dwFetch);
}

// work around compiler bug as per above description
void DtorStaticDSExtendFwdSeqPMFs(void) {
    // DSGraphContainer
    delete DSGraphContainer::Fetch;
    delete DSGraphContainer::iterator::Reset;
    delete DSGraphContainer::iterator::Next;

    // DSFilter
    delete DSFilter::Fetch;
    delete DSFilter::iterator::Reset;
    delete DSFilter::iterator::Next;

    // DSDevices
    // DSDeviceSequence::Fetch,  no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
    delete DSDevices::iterator::Reset;
    delete DSDevices::iterator::Next;

    // DSFilterMapper, no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
    // uses same types as DSDevices so its the same template expansion, already initialized

    // DSPin
    delete DSPin::Fetch;
    delete DSPin::iterator::Reset;
    delete DSPin::iterator::Next;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSGraph
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT DSGraph::Connect(DSFilter &pStart, DSFilter &pStop, DSFilterList &Added, const DWORD dwFlags, PIN_DIRECTION pd)
{
    ASSERT(*this);
    ASSERT(pStart.GetGraph() == *this);
    ASSERT(pStop.GetGraph() == *this);
    try {
		DSFilterIDList AddedIDs;
        int origsize = Added.size();
        if (ConnectFilters(pStart, pStop, AddedIDs, dwFlags, pd)) {
			for (DSFilterIDList::iterator i = AddedIDs.begin(); i != AddedIDs.end(); ++i) {
				Added.push_back((*i).first);
			}
            return NOERROR;
        }
        ASSERT(!AddedIDs.size());
        ASSERT(Added.size() == origsize);
        return E_FAIL;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

bool DSGraph::Connect(DSFilter &pStart, DSFilterMoniker &pStop, DSFilter &pEndPointAdded, DSFilterList &IntermediatesAdded, const DWORD dwFlags, PIN_DIRECTION pd)
{
    ASSERT(*this);
    ASSERT(pStart.GetGraph() == *this);
    pEndPointAdded = AddMoniker(pStop);
    if (!pEndPointAdded) {
        return false;
    }
    ASSERT(pEndPointAdded.GetGraph() == *this);
    int origsize = IntermediatesAdded.size();
    if (SUCCEEDED(Connect(pStart, pEndPointAdded, IntermediatesAdded, dwFlags, pd))) {
        return true;
    }
    RemoveFilter(pEndPointAdded);
    pEndPointAdded.Release();
    ASSERT(IntermediatesAdded.size() == origsize);
    return false;
}


#ifdef ATTEMPT_DIRECT_CONNECT
// attempt to connect the given pin to some pin on the given filter
bool DSGraph::ConnectPinDirect(DSPin &pPin, DSFilter &pFilter, DWORD dwFlags) {
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinDirect() pPin = " << pPin << " pFilter = " << pFilter), "");
        TRACEINDENT();
        DSFilter::iterator i;
        for (i = pFilter.begin(); i != pFilter.end(); ++i) {
			if (!DSPin(*i).GetConnection()) {
				HRESULT hr = pPin.Connect(*i, NULL);
				if (SUCCEEDED(hr)) {
					TRACEOUTDENT();
					TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinDirect() connected " << pPin.GetFilter() << " " << pPin << " to " << DSPin(*i).GetFilter() << " " << *i), "");
					return true;
				}
			}
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by throwing, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    if (!cUseablePins) {
        TRACELM(TRACE_DETAIL, "ConnectPinDirect() no useable pins, throwing...");
        THROWCOM(HRESULT_FROM_WIN32(ERROR_OUT_OF_STRUCTURES));  // short cut the case where there aren't any useable pins by any criteria
    }
#endif
    TRACELM(TRACE_DETAIL, "ConnectPinDirect() failed");
    return false;
}
#endif

#ifndef ATTEMPT_DIRECT_CONNECT
// attempt to connect the given pin to some pin on the given filter
bool DSGraph::ConnectPinByMedium(DSPin &pPin, DSFilter &pFilter, DWORD dwFlags) {
    int cUseablePins = 0;
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinByMedium() pPin = " << pPin << " pFilter = " << pFilter), "");
        TRACEINDENT();
        DSFilter::iterator i;
        for (i = pFilter.begin(); i != pFilter.end(); ++i) {
            if (HasUnconnectedMedium(pPin, *i, cUseablePins)) {
                break;
            }
        }
        if (i != pFilter.end()) {
            HRESULT hr = pPin.Connect(*i, NULL);
            if (FAILED(hr)) {
                TRACEOUTDENT();
                TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMedium() can't connect pin " << pPin << " to " << *i), " with matching medium");
                return false;
            }
            TRACEOUTDENT();
            TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMedium() connected " << pPin.GetFilter() << " " << pPin << " to " << DSPin(*i).GetFilter() << " " << *i), "");
            return true;
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMedium() connect pin "), " THREWUP");
    }
#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by throwing, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    if (!cUseablePins) {
        TRACELM(TRACE_DETAIL, "ConnectPinByMedium() no useable pins, throwing...");
        THROWCOM(HRESULT_FROM_WIN32(ERROR_OUT_OF_STRUCTURES));  // short cut the case where there aren't any useable pins by any criteria
    }
#endif
    TRACELM(TRACE_DETAIL, "ConnectPinByMedium() failed");
    return false;
}
#endif

// attempt to connect the given pin to the given filter by hunting for an indirection through
// another filter already in the graph
// then attempt to connect the new filter to the original destination
bool DSGraph::FindPinByMedium(DSPin &pPin1, DSFilter &pFDest, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMedium() pPin1 = " << pPin1 << " pFDest = " << pFDest), "");
    KSMediumList ml;
    HRESULT hr = pPin1.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMedium() " << pPin1 << " has no mediums"), "");
        return false;
    }

    try {
        TRACEINDENT();
        // possibly in the future we should find all of the possible choices and
        // use the shortest available path.  but for now, we're just going to
        // find the first one that exists

        // try all the direct connections
		for (DSGraphContainer::iterator i = begin(); i != end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
			if (IsConnectable(pPin1, DSFilter(*i), pFDest, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
			if (IsConnectable(pPin1, DSFilter(*i), pFDest, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMedium))) {
#endif
                TRACEOUTDENT();
                TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMedium() succeeded");
				return true;
			}
		}
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMedium() can't connect pin to anything in graph");
    return false;
}

// we have already established that we can't connect directly or via other filters
// already in the graph so go hunt for a new filter to load
// if we fail we must leave the graph in its initial state
bool DSGraph::LoadPinByMedium(KSPinMedium &medium, DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    if (medium == NULL_MEDIUM || medium == HOST_MEMORY_MEDIUM) {
        TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() NULL Medium, don't bother");
        // don't build an enumerator for a null medium or we will search through every
        // single filter on the system that doesn't have mediums
        return false;
    }
    try {
        TRACEINDENT();
        TRACELSM(TRACE_PAINT, (dbgDump << "medium = " << medium), "");
        PIN_DIRECTION pd;
        HRESULT hr = pPin1->QueryDirection(&pd);
        if (FAILED(hr)) {
                TRACEOUTDENT();
                TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMedium() can't query direction");
                THROWCOM(E_UNEXPECTED);
        }


        bool fInReq = false, fOutReq = false;
        DSREGPINMEDIUM *pInMed = NULL, *pOutMed = NULL;

        switch (pd) {
        case PINDIR_INPUT:  // hunting through graph from right to left

#ifdef FILTERDATA
                    fOutReq = true;
                    pOutMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
#else
            // NOTE: because of mediums get registered from the .inf with an
            // incomplete registry blob, filtermapper thinks that any pin with a
            // medium is an input pin and we use the low flag bit in the second
            // medium dword to solve this problem. == 1 for input == 0 for output
                    fInReq = true;
                    pInMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
            medium.Flags &= ~(KSMEDIUM_INPUTFLAG);
#endif
            break;
        case PINDIR_OUTPUT: // hunting through graph from left to right
            fInReq = true;
            pInMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
#ifndef FILTERDATA
            medium.Flags |= KSMEDIUM_INPUTFLAG;
#endif
            break;
        }

        if (pInMed) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fInReq = " << fInReq << " pInMed = " << pInMed << " " << (*pInMed)), "");
        } else {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fInReq = " << fInReq << " pInMed = " << pInMed << " (NULL)"), "");
        }
        if (pOutMed) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fOutReq = " << fOutReq << " pOutMed = " << pOutMed << " " << (*pOutMed)), "");
        } else {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fOutReq = " << fOutReq << " pOutMed = " << pOutMed << " (Null)"), "");
        }
        // NOTE: since we're using mediums which are hw specific we include filters w/
        // MERIT_DO_NOT_USE since this is the default merit and most HW device filters
        // don't specify a merit.
        DSFilterMapper fmr(PQFilterMapper(*this),
                       0,
                       true,                                    // no wildcards
                       MERIT_DO_NOT_USE,                        // default merit for hw filters
                       fInReq,                                  // input required
                       0,
                       NULL,
                       pInMed,                                  // input medium
                       NULL,                                    // input pin cat
                       false,                                   // input rendered?
                       fOutReq,                                 // output required
                       0,
                       NULL,
                       pOutMed,                                 // output medium
                       NULL                                     // output pin cat
                      );
        if (fmr) {
            // try all the direct connections
			for (DSFilterMapper::iterator i = fmr.begin(); i != fmr.end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMedium))) {
#endif
                    TRACEOUTDENT();
                    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() succeeded");
					return true;
				}
			}
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() failed");

    return false;
}

bool DSGraph::LoadPinByAnyMedium(DSPin &pPin, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMedium()");
    try {
        KSMediumList ml;
        HRESULT hr = pPin.GetMediums(ml);
        if (FAILED(hr) || !ml.size()) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByAnyMedium() " << pPin << " has no mediums"), "");
            return false;
        }
		for (KSMediumList::iterator i = ml.begin(); i != ml.end(); ++i) {
			if (LoadPinByMedium(KSPinMedium(*i), pPin, pRight, IntermediatesAdded, dwFlags)) {
				return true;
			}
		}
	} catch(ComException& h) {
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByAnyMedium() rethrowing E_UNEXPECTED");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByAnyMedium() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    return false;
}

#ifndef ATTEMPT_DIRECT_CONNECT
// attempt to connect these two filters.  if we fail we must remove
// any intermediate filters that we may have added and leave the graph in the
// state we started with.
bool DSGraph::ConnectPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DWORD dwFlags) {
    ASSERT(pPin1.GetGraph() == *this);
    ASSERT(pFilter1.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    try {
        TRACEINDENT();
        // try media types
		DSFilter::iterator i;
		for (i = pFilter1.begin(); i != pFilter1.end(); ++i) {
			if (HasUnconnectedMediaType(pPin1, *i, dwFlags)) {
				break;
			}
		}
        if (i != pFilter1.end()) {
            ASSERT(*this);
            ASSERT(pPin1.GetGraph() == *this);
            ASSERT((*i).GetGraph() == *this);
            HRESULT hr = pPin1.Connect(*i, NULL);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) can't connect pin " << pPin1 << " to " << *i << " hr = " << hexdump(hr)), " with matching media type.");
#ifdef DEBUG
                if (dwTraceLevel >= TRACE_DETAIL) {
                    DumpHdr(dbgDump) << "pin1 " << pPin1.GetFilter() << " " << pPin1 << std::endl;
                    DumpHdr(dbgDump) << "pin2 " << (*i).GetFilter() << " " << *i << std::endl;
                    DumpMediaTypes(pPin1, *i);
                }
#endif
                if (!(dwFlags & IGNORE_MEDIATYPE_ERRORS)) {
                    THROWCOM(HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH));
                } else {
                    return false;
                }
            }
            TRACEOUTDENT();
            TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) connected " << pPin1.GetFilter() << " " << pPin1 << " to " << DSPin(*i).GetFilter() << " " << *i), "");
            return true;
        }
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if (h == E_UNEXPECTED || h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectPinByMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DEBUG, "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) failed");

    return false;
}
#endif

bool DSGraph::FindPinByMediaType(DSPin &pPinLeft, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    ASSERT(pPinLeft.GetGraph() == *this);
    ASSERT(pRight.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMediaType() pPinLeft = " << pPinLeft << " filter = " << pRight), "");
    // possibly in the future we should find all of the possible choices and
    // use the shortest available path.  but for now, we're just going to
    // find the first one that exists
    try {
        TRACEINDENT();
		// NOTE: IFilterGraph::ConnectDirect() bumps the graph version number which invalidates
		// all the enumerators.  thus we'll run through and make a list of all the filters in the 
		// graph and then check them
		DSFilterList l;
		for (DSGraphContainer::iterator i = begin(); i != end(); ++i) {
			l.push_back(*i);
		}
		for (DSFilterList::iterator li = l.begin(); li != l.end(); ++li) {
#ifdef ATTEMPT_DIRECT_CONNECT
			if (IsConnectable(pPinLeft, DSFilter(*li), pRight, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
			if (IsConnectable(pPinLeft, DSFilter(*li), pRight, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMediaType))) {
#endif
                TRACEOUTDENT();
                TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() succeeded");
				return true;
			}
		}
		TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() enumeration exhausted");
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if (h == E_UNEXPECTED) {
			TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() rethrowing E_UNEXPECTED");
			throw;
		}
		TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
    } catch(...) {
		TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() catch ...");
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() failed");

    return false;
}

bool DSGraph::LoadPinByAnyMediaType(DSPin &pPin, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByAnyMediaType() pPin = " << pPin.GetName() << " dwFlags = " << hexdump(dwFlags)), "");
    ASSERT(pPin.GetGraph() == *this);
    ASSERT(pRight.GetGraph() == *this);
#ifdef DEBUG
    BEGIN_TRACEL(TRACE_DETAIL)
        if (pPin.begin() == pPin.end()) {
            dbgDump << "DSGraph::LoadPinByAnyMediaType() pin has no media types\r\n";
            dbgDump.flush();
        }
    END_TRACEL
#endif
    try {
		DWORD dwMerit = MERIT_NORMAL;
		if (dwFlags & ATTEMPT_MERIT_UNLIKELY) {
			dwMerit = MERIT_UNLIKELY;
			TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() MERIT_UNLIKELY");
		} else if (dwFlags & ATTEMPT_MERIT_DO_NOT_USE) {
			dwMerit = MERIT_DO_NOT_USE;
			TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() MERIT_DO_NOT_USE");
		}

		return LoadPinByMediaType(pPin, pRight, IntermediatesAdded, dwFlags, dwMerit);
	} catch(ComException& h) {
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) ||
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByAnyMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByAnyMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() failed");

    return false;
}

// we are trying to connect Pin1 to the Destination Filter.  we have already
// established that we cannot connect them directly.
// Mapper is a moniker for a filter provided by the filtermapper enumerator that we're
// going to attempt to use as an intermediate filter
bool DSGraph::IsConnectable(DSPin &pPin1, DSFilter &pNew, DSFilter &pFDestination, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, ConnectPred_t ConnPred) {
    ASSERT(pPin1 != NULL);
    ASSERT(pPin1.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsConnectable() pPin1 = " << pPin1 << " pNew = " << pNew << " pFDestination = " << pFDestination), "");
    try {
        PIN_INFO pinfo;
        HRESULT hr = pPin1->QueryPinInfo(&pinfo);
		if (FAILED(hr)) {
			THROWCOM(E_UNEXPECTED);
		}
        DSFilter Pin1Filter;
        Pin1Filter.p = pinfo.pFilter;  // transfer refcount ownership

        if (pNew && pNew != pFDestination && pNew != Pin1Filter) {
            bool f1 = (this->*ConnPred)(pPin1, pNew, dwFlags);
            if (f1) {
                TRACELM(TRACE_DETAIL, "DSGraph::IsConnectable() connpred == true");
                PIN_DIRECTION direction;
                hr = pPin1->QueryDirection(&direction);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "DSGraph::IsConnectable() can't query direction");
                    THROWCOM(E_UNEXPECTED);
                }
                if (ConnectFilters(pNew, pFDestination, IntermediatesAdded, dwFlags, direction)) {
                    TRACELM(TRACE_DETAIL, "DSGraph::IsConnectable() succeeded");
                    return true;
                }
            }
        }
	} catch(ComException& h) {
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::IsConnectable() rethrowing E_UNEXPECTED");
			    pPin1.Disconnect();
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsConnectable() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsConnectable() disconnecting " << pPin1), "");
    pPin1.Disconnect();
    return false;
}

// we are trying to connect Pin1 to the Destination Filter.  we have already
// established that we cannot connect them directly.
// Mapper is a moniker for a filter provided by the filtermapper enumerator that we're
// going to attempt to use as an intermediate filter
bool DSGraph::IsLoadable(DSPin &pPin1, DSFilterMoniker &Mapper, DSFilter &Destination, DSFilterIDList &IntermediatesAdded, DWORD dwFlags, ConnectPred_t ConnPred) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() pPin1 = " << pPin1 << " " << pPin1.GetFilter() << " Destination = " << Destination), "");
    ASSERT(pPin1.GetGraph() == *this);
    DSFilter pNew;
    try {
		DSFilterIDList::iterator i = IntermediatesAdded.size() ? (IntermediatesAdded.end() - 1) : IntermediatesAdded.end();

		if (i != IntermediatesAdded.end()) {
			TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() checking duplicate moniker last = " << (*i).second << " new = " << Mapper.DisplayName()), "");
		} else {
			TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() first moniker can't be dup(no check) new = " << Mapper.DisplayName()), "");
		}

		// undone: if the chains get longer we should use a map for this.  this may explain why perf
        // collapses as soon as we end up over on the audio side of things
		int occurrences = 0;
		CString newmkrname = Mapper.DisplayName();
		for (i = IntermediatesAdded.begin(); i != IntermediatesAdded.end(); ++i) {
			if ((!(*i).second.IsEmpty()) && 
				(newmkrname == (*i).second)) {
				   ++occurrences;
			}
		}
		if (occurrences > MAX_OCCURRENCE_COUNT) {
			TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::IsLoadable() max occurrence count exceeded for mkr = " << newmkrname), "");
			return false;
		}
        pNew = AddMoniker(Mapper);
        IntermediatesAdded.push_back(DSFilterID(pNew, Mapper.DisplayName()));
// ???? implement flag
        if (pNew) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() added moniker pNew = " << pNew), "");
            bool f1 = (this->*ConnPred)(pPin1, pNew, dwFlags);
            if (f1) {
                TRACELM(TRACE_DETAIL, "DSGraph::IsLoadable() connpred succeeded");
                PIN_DIRECTION direction;
                HRESULT hr = pPin1->QueryDirection(&direction);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "DSGraph::IsLoadable() can't query direction");
                    THROWCOM(E_UNEXPECTED);
                }
		        if (!pNew.PinCount(direction)) {
                    if (!(dwFlags & DONT_TERMINATE_ON_RENDERER)) {
                        TRACELM(TRACE_DETAIL, "DSGraph::IsLoadable() throwing ERROR_NO_MORE_ITEMS");
                        THROWCOM(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
                    }
		        }
                if (ConnectFilters(pNew, Destination, IntermediatesAdded, dwFlags, direction)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() succeeded.  pPin1 = " << pPin1 << " pNew = " << pNew << " Destination = " << Destination), "");
                    return true;
                }
            }
        }
	} catch(ComException& h) {
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::IsLoadable() rethrowing");
				TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() disconnecting " << pPin1), "");
				pPin1.Disconnect();
				TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() removing " << pNew), "");
				IntermediatesAdded.pop_back();
				RemoveFilter(pNew);
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() disconnecting " << pPin1), "");
    pPin1.Disconnect();
	IntermediatesAdded.pop_back();
    if (pNew) {
        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() removing " << pNew), "");
        RemoveFilter(pNew);
    }
    return false;
}

bool DSGraph::ConnectPin(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, PIN_DIRECTION pin1dir) {
    // NOTE: this is where we enforce the desired directional assymetry.  from now on through the call tree
    // we can assume that pin1 is already the desired directional type. and we only have to check
    // pin2 at the end in hasunconnectedxxxx()
    // this ensures that all of our connection paths are unidirectional through the graph. in other words,
    // make sure that we don't go downstream then back upstream or vice versa.
    // this allows all of our connection routines to be useable from either direction
    // since there are times when we have an input side starting point and other times the opposite
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPin() pin1 = " << pPin1 << " " << pPin1.GetFilter() << " to " << pFilter1), "");
	TRACEINDENT();
    PIN_DIRECTION pd;

    HRESULT hr = pPin1->QueryDirection(&pd);
    if (pd != pin1dir) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() wrong dir");
        return false;
    }

	if (!(dwFlags & RENDER_ALL_PINS) &&  !pPin1.IsRenderable()) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() non-renderable");
		return false;
	}

    // make sure we're not trying to connect a filter to itself
    PIN_INFO pinfo;
    DSFilter PinFilter;
    hr = pPin1->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
		TRACEOUTDENT();
        TRACELM(TRACE_ERROR, "DSGraph::ConnectPin() can't get pin info");
        THROWCOM(E_UNEXPECTED);
    }
    PinFilter.p = pinfo.pFilter;  // transfer refcount ownership
    if (PinFilter == pFilter1) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() can't connect filter to itself");
        return false;
    }

    DSPin pConn = pPin1.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPin() pin1  = " << pPin1 << " connected, tracing through to next filter = " << pConn.GetFilter()), "");
        // a connected output pin should be traced through the next filter
        DSFilter pNext = pConn.GetFilter();
        if (!pNext) {
			TRACEOUTDENT();
            TRACELM(TRACE_ERROR, "DSGraph::ConnectPin() pNext has no filter");
            THROWCOM(E_UNEXPECTED);
        }
        if (pNext != pFilter1) {
	        bool rc = ConnectFilters(pNext, pFilter1, IntermediatesAdded, dwFlags, pin1dir);
			TRACEOUTDENT();
			return rc;
		} else {
			TRACEOUTDENT();
			TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() pNext == pFilter1");
			return true;
		}
    }

#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by returning, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() pin free");
	PIN_DIRECTION pd2;
	pd2 = OppositeDirection(pd);
	if (!pFilter1.HasFreePins(pd2)) {
		TRACEOUTDENT();
		TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() filter has no free pins");
		return false;
	}
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() filter has free pins");
#endif

    try {
#ifdef ATTEMPT_DIRECT_CONNECT
        if (ConnectPinDirect(pPin1, pFilter1) ||     // can these connect direct
#else
        if (ConnectPinByMedium(pPin1, pFilter1, dwFlags) ||     // can these connect direct
#endif
            FindPinByMedium(pPin1, pFilter1, IntermediatesAdded, dwFlags)    ||     // any paths in graph
            (!(dwFlags & DO_NOT_LOAD) && LoadPinByAnyMedium(pPin1, pFilter1, IntermediatesAdded, dwFlags))    ||     // any filters in system
#ifndef ATTEMPT_DIRECT_CONNECT
			ConnectPinByMediaType(pPin1, pFilter1, dwFlags) ||     // can these connect direct
#endif
            FindPinByMediaType(pPin1, pFilter1, IntermediatesAdded, dwFlags)    ||
            (!(dwFlags & DO_NOT_LOAD) && LoadPinByAnyMediaType(pPin1, pFilter1, IntermediatesAdded, dwFlags))) {
			TRACEOUTDENT();
            TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() succeeded");
            return true;
        }
        TRACEOUTDENT(); // to avoid outdenting too far in a catch case
    } catch (ComException &h) {
		TRACEOUTDENT();
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectPin() rethrowing E_UNEXPECTED");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPin() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch (...) {
		TRACEOUTDENT();
    }

	//TRACEOUTDENT();
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() failed");
    return false;
}

// attempt to disconnect this pin
bool DSGraph::DisconnectPin(DSPin &pPin, const bool fRecurseInputs, const bool fRecurseOutputs) {
    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectPin()");

    PIN_DIRECTION pd;
    HRESULT hr = pPin->QueryDirection(&pd);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectPin() can't get direction");
        THROWCOM(E_UNEXPECTED);
    }

    DSPin pConnection = pPin.GetConnection();
    if (!pConnection) {
        return false;
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::DisconnectPin() disconnecting " << pPin << " from " << pConnection), "");
    pPin.Disconnect();
    DSFilter pNext = pConnection.GetFilter();
    if (!pNext) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectPin() pConnection has no filter");
        THROWCOM(E_UNEXPECTED);
    }

    switch (pd) {
    case PINDIR_INPUT:
        if (fRecurseInputs) {
#if 0
            std::for_each(pNext.begin(),
                     pNext.end(),
                     bind_obj_2_3(*this,
                                  arity3_member(&DSGraph::DisconnectPin),
                                  fRecurseInputs,
                                  false));  // we moving inputward, don't backtrack
#endif
		    for (DSFilter::iterator i = pNext.begin(); i != pNext.end(); ++i) {
				DisconnectPin(*i, fRecurseInputs, false);
			}
        }
        break;
    case PINDIR_OUTPUT:
        if (fRecurseOutputs) {
#if 0
            std::for_each(pNext.begin(),
                     pNext.end(),
                     bind_obj_2_3(*this,
                                  arity3_member(&DSGraph::DisconnectPin),
                                  false,
                                  fRecurseOutputs));
#endif
			for (DSFilter::iterator i = pNext.begin(); i != pNext.end(); ++i) {
				DisconnectPin(*i, false, fRecurseOutputs);
			}
        }
        break;
    }

    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectPin() succeeded");
    return true;
}

// attempt to connect this from the graph
bool DSGraph::DisconnectFilter(DSFilter &pFilter, const bool fRecurseInputs, const bool fRecurseOutputs) {
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectFilter() can't disconnect NULL filter");
        return FALSE;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectFilter()");
    for (DSFilter::iterator i = pFilter.begin(); i != pFilter.end(); ++i) {
        DisconnectPin(*i, fRecurseInputs, fRecurseOutputs);
    }

    return true;
}


bool DSGraph::RemoveFilter(DSFilter &pFilter) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::RemoveFilter() removing " << pFilter), "");
    if (!pFilter) return false;

    DisconnectFilter(pFilter, false, false);

    HRESULT hr = (*this)->RemoveFilter(pFilter);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::RemoveFilter() can't remove filter");
        return false;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::RemoveFilter() complete");

    return true;
}

// pin matches medium
// requires an exact match, won't treat GUID_NULL as wildcard and treats 'host memory' as unmatchable
bool DSGraph::HasMedium(const KSPinMedium &Medium1, const DSPin &pPin2) const {
    DSPin junk(pPin2);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMedium() medium1 = " << Medium1 << " pPin2 = " << junk), "");
    if (Medium1 == NULL_MEDIUM || Medium1 == HOST_MEMORY_MEDIUM) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() medium1 == NULL");
        return false;
    }
    KSMediumList ml;

    HRESULT hr = pPin2.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        return false;
    }
#if 0
    KSMediumList::iterator i = std::find_if(ml.begin(),
                                       ml.end(),
                                       std::bind2nd(std::equal_to<KSPinMedium>(), Medium1));
    if (i != ml.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() succeeded");
        return true;
    }
#endif
	KSMediumList::iterator i;
	for (i = ml.begin(); i != ml.end(); ++i) {
		if (*i == Medium1) {
	        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() succeeded");
			return true;
		}
	}

    TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() no match");

    return false;
}

bool DSGraph::HasMediaType(const DSMediaType &LeftMedia, const DSPin &pPinRight) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMediaType() LeftMedia = " << LeftMedia << " LeftMedia.p " << LeftMedia.p << " pPinRight = " << pPinRight), "");

    if (pPinRight.IsKsProxied()) {
#if 0
        DSPin::iterator i = std::find_if(pPinRight.begin(),
                                         pPinRight.end(),
                                         std::bind2nd(std::equal_to<DSMediaType>(),
                                         LeftMedia) );
        if (i != pPinRight.end()) {
            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
            return true;
        }
#endif
		DSPin::iterator i;
		for (i = pPinRight.begin(); i != pPinRight.end(); ++i) {
            // NOTE: DSMediaType operator== enables wildcard matches
			if (*i == LeftMedia) {
	            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
				return true;
			}
		}
    } else {
        HRESULT hr = pPinRight->QueryAccept(LeftMedia);
        if (SUCCEEDED(hr) && hr != S_FALSE) {
            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
            return true;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMediaType() query accept refused hr = " << hexdump(hr)), "");
    }

    return false;
}

#ifndef ATTEMPT_DIRECT_CONNECT
// pin is unconnected, opposite direction, and has at least 1 matching medium
// requires an exact match, won't treat GUID_NULL as wildcard
bool DSGraph::HasUnconnectedMedium(const DSPin &pPin1, const DSPin &pPin2, int& cUseable) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnnconnectedMedium() pin1 = " << pPin1 << " pin2 = " << pPin2), "");
    PIN_DIRECTION pd1, pd2;
    HRESULT hr = pPin1->QueryDirection(&pd1);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::HasUnconnectedMedium() cant query pPin1 direction");
        return false;
    }
    hr = pPin2->QueryDirection(&pd2);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::HasUnconnectedMedium() cant query pPin2 direction");
        return false;
    }
    if (pd1 == pd2) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() can't connect two pins w/ same direction");
        return false;  // can't connect two of same type pins
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() checking connection status");

    DSPin pConn = pPin2.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnconnectedMedium() pPin2 = " << pPin2 << " already connected"), "");
        return false;
    }
    ++cUseable;

    KSMediumList ml;
    hr = pPin1.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() pin has no mediums");
        return false;
    }
    KSMediumList::iterator i;
    for (i = ml.begin(); i != ml.end(); ++i) {
        if (HasMedium(*i, pPin2)) {
            break;
        }
    }
    if (i != ml.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() succeeded");
        return true;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() pPin2 has no matching medium");
    return false;
}

// pin is unconnected, opposite direction,  and there is at least 1 matching media type
bool DSGraph::HasUnconnectedMediaType(const DSPin &pPin1, const DSPin &pPin2, DWORD dwFlags) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnnconnectedMediaType() pPin1 = " << pPin1 << " pPin2 = " << pPin2), "");
    if (pPin1.GetDirection() == pPin2.GetDirection()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMediaType() cant connect 2 pins w/ same direction");
        return false;  // can't connect two of same type pins
    }
    DSPin pConn = pPin2.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnconnectedMediaType() pPin2 connected to " << pConn), "");
        return false;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() finding");
    // pin right isn't connected to anything so hunt for a
    // compatible media type
	for (DSPin::iterator i = pPin1.begin(); i != pPin1.end(); ++i) {
		if (HasMediaType(*i, pPin2)) {
	        TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() succeeded forward");
			return true;
		}
	}
    if (dwFlags & BIDIRECTIONAL_MEDIATYPE_MATCHING) {
	    for (DSPin::iterator i = pPin2.begin(); i != pPin2.end(); ++i) {
		    if (HasMediaType(*i, pPin1)) {
	            TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() succeeded backward(bidi)");
			    return true;
		    }
	    }
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMediaType() no matching media types");
    return false;
}
#endif

// we are checking to see if pPin1 is connected(possibly indirectly) to pFDestionation by traveling in destdir direction through
// the graph
bool DSGraph::IsPinConnected(const DSPin &pPin1, const DSFilter &pFDestination, DSFilterIDList &IntermediatesAdded, PIN_DIRECTION destdir) const {
    PIN_DIRECTION direction;
    HRESULT hr = pPin1->QueryDirection(&direction);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::IsPinConnected() can't query direction");
        THROWCOM(E_UNEXPECTED);
    }
    if (direction != destdir) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() wrong direction");
        return false;
    }
    DSPin pConn = pPin1.GetConnection();
        if (!pConn) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() unconnected to anything");
        return false;
        }
    PIN_INFO pinfo;
    DSFilter PinFilter;
    if (pConn) {
        hr = pConn->QueryPinInfo(&pinfo);
        PinFilter.p = pinfo.pFilter;  // transfer refcount ownership
    }
    if (PinFilter == pFDestination) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() directly true");
        return true;
    }
#if 0
#if CRASH
    DSFilter::iterator i = std::find_if(PinFilter.begin(),
                                        PinFilter.end(),
                                        bind_const_obj_2_3_4(
                                            *this,
                                            arity4_const_member(&DSGraph::IsPinConnected),
                                            pFDestination,
                                            IntermediatesAdded,
                                            destdir));
#else
    DSFilter::iterator i = std::find_if(PinFilter.begin(),
                                        PinFilter.end(),
                                        bndr_const_obj_2_3_4<arity4pmf_const<const DSGraph, const DSPin&, const DSFilter&, DSFilterIDList &, const PIN_DIRECTION, bool> >(
                                            *this,
                                            arity4_const_member(&DSGraph::IsPinConnected),
                                            pFDestination,
                                            IntermediatesAdded,
                                            destdir));
#endif
    if (i != PinFilter.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() indirectly true");
        return true;
    }
#endif
	for (DSFilter::iterator i = PinFilter.begin(); i != PinFilter.end(); ++i) {
		if (IsPinConnected(*i, pFDestination, IntermediatesAdded, destdir)) {
			TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() indirectly true");
			return true;
		}
	}
    TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() unconnected to desired dest");
    return false;
}


#if 0
DSFilter DSGraph::LoadFilter(const PQMoniker &pM, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter()");
    csName = _T("");
    PQFilter pFilter;
    PQPropertyBag pPropBag;
    HRESULT hr = (pM)->BindToStorage(0, 0, IID_IPropertyBag, reinterpret_cast<LPVOID *>(&pPropBag));
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't bind to storage");
        THROWCOM(hr);
    }
    CComVariant vName;
    vName.vt = VT_BSTR;
    hr = pPropBag->Read(L"FriendlyName", &vName, NULL);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't read friendly name");
        THROWCOM(hr);
    }
    USES_CONVERSION;
    BSTR p = vName.bstrVal;
    csName = OLE2T(p);
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter() have propbag");
    hr = (pM)->BindToObject(0, 0, IID_IBaseFilter, reinterpret_cast<LPVOID *>(&pFilter));
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't bind to object");
        THROWCOM(hr);
    }
    return pFilter;
}
#else
DSFilter DSGraph::LoadFilter(const DSFilterMoniker &pM, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter()");
    CComBSTR p(pM.GetName());
        if (p) {
                USES_CONVERSION;
                csName = OLE2T(p);
        }
    return pM.GetFilter();
}
#endif

DSFilter DSGraph::AddMoniker(const DSFilterMoniker &pM) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddMoniker()");
    CString csName;

    DSFilter pFilter = LoadFilter(pM, csName);
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::AddMoniker() can't load filter");
        return pFilter;
    }

    TRACELM(TRACE_DETAIL, "DSGraph::AddMoniker() have pFilter");
    USES_CONVERSION;
    HRESULT hr = (*this)->AddFilter(pFilter, T2COLE(csName));
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddMoniker() can't add filter " << csName << " to graph"), "");
        return DSFilter();
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddMoniker() added " << csName), "");

    return pFilter;
}

HRESULT DSGraph::AddFilter(DSFilter &pFilter, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddFilter()");
    HRESULT hr;
    USES_CONVERSION;
    hr = (*this)->AddFilter(pFilter, T2COLE(csName));
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddFilter() can't add filter " << csName << " to graph"), "");
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddFilter() added " << csName), "");

    return hr;
}

DSFilter DSGraph::AddFilter(const CLSID &cls, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddFilter()");
    HRESULT hr;
    DSFilter pFilter(cls, NULL, CLSCTX_INPROC_SERVER);
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::AddFilter() can't create filter");
        return pFilter;
    }
    hr = AddFilter(pFilter, csName);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddFilter() can't add filter " << csName << " to graph"), "");
        THROWCOM(hr);
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddFilter() added " << csName), "");

    return pFilter;
}

// attempt to connect these two filters.  if we fail we must remove
// any intermediate filters that we've added and leave the graph in the
// state we started with.
// only look at pFilter1 pins of pFilter1Direction
bool DSGraph::ConnectFilters(DSFilter &pFilter1, DSFilter &pFilter2, DSFilterIDList &IntermediatesAdded, DWORD dwFlags, PIN_DIRECTION pFilter1Direction) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
    if (pFilter1 == pFilter2) {
        TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters same filter");
        return false;
    }
    try {
        TRACEINDENT();
		// undone: there should be some way to preserve the info
		// from the following check to speed up the actual connection in the event
		// that they aren't already connected.

        // see if these filters are already connected
		DSFilter::iterator i;
		if (!(dwFlags & IGNORE_EXISTING_CONNECTIONS)) {
#if 0
#if CRASH
			i = std::find_if(pFilter1.begin(),
 							 pFilter1.end(),
 							 bind_obj_2_3_4(
								 *this,
								 arity4_const_member(&DSGraph::IsPinConnected),
								 pFilter2,
								 IntermediatesAdded,
								 pFilter1Direction));
#else
			i = std::find_if(pFilter1.begin(),
							 pFilter1.end(),
							 bndr_const_obj_2_3_4<arity4pmf_const<const DSGraph, const DSPin&, const DSFilter&, DSFilterIDList &, const PIN_DIRECTION, bool> >(
								 *this,
								 arity4_const_member(&DSGraph::IsPinConnected),
								 pFilter2,
								 IntermediatesAdded,
								 pFilter1Direction));
#endif
			if (i != pFilter1.end()) {
				TRACEOUTDENT();
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectFilters already connected");
				return true;
			}
#endif
			for (DSFilter::iterator i = pFilter1.begin(); i != pFilter1.end(); ++i) {
				if (IsPinConnected(*i, pFilter2, IntermediatesAdded, pFilter1Direction)) {
					TRACEOUTDENT();
					TRACELM(TRACE_DEBUG, "DSGraph::ConnectFilters already connected");
					return true;
				}
			}
		}

        // they're not connected so see if we can connect them
        // connect every possible pin available and keep track of how many we connect
        int cConnected = 0;
		for (i = pFilter1.begin(); i != pFilter1.end(); ++i) {
			try {
				if (ConnectPin(DSPin(*i), pFilter2, IntermediatesAdded, dwFlags, pFilter1Direction)) {
					TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() pin connected");
					cConnected++;
				}
			} catch(ComException &h) {
				if (h != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
					try {
						TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() rethrowing");
					} catch(...) {
					}
					throw;
				}
			}
		}
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() cConnected = " << cConnected), "");
        if (cConnected) {
            TRACEOUTDENT();// just inside try
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() succeeded pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
            return true;    // we connected at least one pin
        }
        TRACEOUTDENT();// just inside try
	} catch (ComException &h) {
        TRACEOUTDENT();// just inside try
		if (h == E_UNEXPECTED) {
			throw;
		}
    } catch (...) {
        TRACEOUTDENT();  // just inside try
        TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() catch...");
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() failed pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
    return false;
}

// this function returns a list of pairs of input and output points
// that must be connected to activate the shortest path between two filters
// it returns the number of connections in the path.
// i.e if start is adjacent to stop then rc is 1. if a single filter is between them then 2, etc.
// 0 indicates no path found.
int DSGraph::BuildGraphPath(const DSFilter& pStart,
                            const DSFilter& pStop,
                            VWStream &path,
                            MediaMajorTypeList& MediaTypes,
                            PIN_DIRECTION direction,
                            const DSPin &InitialInput)
{
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() start = " << pStart << " stop = " << pStop), "");
    int pathlen = INT_MAX;
    VWStream returnpath;
    ASSERT(InitialInput || (!InitialInput && !pStart.IsXBar())); // first time in can't be an xbar unless original caller establishes InitialInput
    for (DSFilter::iterator i = pStart.begin(); i != pStart.end(); ++i) {
        DSPin pPin1(*i);
        if (pPin1.GetDirection() != direction) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ", " << pPin1 << " wrong direction"), "");
            continue;  // search forward
        }
        DSPin pConnection = pPin1.GetConnection();
        if (!pConnection) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ", " << pPin1 << " unconnected"), "");
            continue;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() checking " << pPin1 << " connected to " << pConnection.GetFilter() << " " << pConnection), "");
        if (InitialInput) {
            ASSERT(pPin1 != InitialInput);  // direction check should already have filtered for this

            DSMediaType amt(pPin1.GetConnectionMediaType());
            ASSERT(amt);
            if (amt->pUnk) {
                amt->pUnk->Release();
            }

            MediaMajorTypeList::iterator l;
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() searching for " << GUID2(amt.p->majortype)), "");
            l = std::find(MediaTypes.begin(), MediaTypes.end(), amt.p->majortype);
            if (l == MediaTypes.end()) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "major media type not matched"), "");
                continue;
            }

            if (!pPin1.CanRoute(InitialInput)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ",  " << InitialInput << " Can't Route to " << pPin1), "");
                continue;
            }
        }

        DSFilter nextFilter = pConnection.GetFilter();
        ASSERT(nextFilter);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSGraph::BuildGraphPath() nextFilter = " << nextFilter), "");

        if (nextFilter == pStop) {
            TRACELSM(TRACE_PAINT, (dbgDump << "DSGraph::BuildGraphPath() found stop filter"), "");
            // we found the destination, we're done with this one
                        if (pStart.IsXBar()) {
                // if we started on xbar then connected pin's outputpoint pairs with the
                // initialinput(&pin) to form the first pair in the return path
                    TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() pstart is xbar");
                ASSERT(DSXBarPin(InitialInput));
                PQPoint p1(DSXBarPin(InitialInput).GetPoint());
                ASSERT(!!p1);

                ASSERT(DSXBarPin(pPin1));
                PQPoint p2(DSXBarPin(pPin1).GetPoint());
                ASSERT(!!p2);

                switch (direction) {
                case DOWNSTREAM:
                    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p1 << ", " << p2), ")");
                    returnpath.push_back(CIOPoint(p1, p2));
                    break;
                case UPSTREAM:
                    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p2 << ", " << p1), ")");
                    returnpath.push_back(CIOPoint(p2, p1));
                    break;
                }
                        }
            pathlen = 1;
            break;
        } else {
            VWStream temp;
            int rc = BuildGraphPath(nextFilter, pStop, temp, MediaTypes, direction, pConnection);
            // undone: in win64 size() is really __int64.  fix output operator for
            // that type and remove cast

            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() recursed buildgraphpath returned rc = " << rc << " pathlen = " << pathlen << "sz = " << (long)temp.size()), "");

            // if we found a path and the new one is shorter then the current one
            if (rc && ((rc + 1) < pathlen)) {
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() accepting new path");
                // save the new path
                pathlen = rc + 1;
                returnpath.clear();
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() checking xbar adjacency");
                if (pStart.IsXBar()) {
                                        // if we started on xbar then connected pin's outputpoint pairs with the
                                        // initialinput(&pin) to form the next pair in the return path
                        TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() pstart is xbar");
                    ASSERT(DSXBarPin(InitialInput));
                    PQPoint p1(DSXBarPin(InitialInput).GetPoint());
                    ASSERT(!!p1);

                    ASSERT(DSXBarPin(pPin1));
                    PQPoint p2(DSXBarPin(pPin1).GetPoint());
                    ASSERT(!!p2);

                    switch (direction) {
                    case DOWNSTREAM:
                        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p1 << ", " << p2), ")");
                        returnpath.push_back(CIOPoint(p1, p2));
                        break;
                    case UPSTREAM:
                        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p2 << ", " << p1), ")");
                        returnpath.push_back(CIOPoint(p2, p1));
                        break;
                    }
                }
                                // append onto path any further downstream xbars found by recursion
                returnpath.splice(returnpath.end(), temp);
            } else {
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() discarding new path");
                // keep the old return path and cleanup the temp one we just got back
                temp.clear();
            }
        }
    }
    if (pathlen == INT_MAX) {  // didn't find anything
                return 0;
    }
    path = returnpath;
    return pathlen;
}

HRESULT DSGraph::AddToROT(DWORD *pdwObjectRegistration) {
    PQMoniker pGraphMK;
    PQROT pROT;
    if (FAILED(::GetRunningObjectTable(0, &pROT))) {
        return E_UNEXPECTED;
    }
    OLECHAR osz[256];
    // undone: in the ia64 case the following format spec isn't enough digits for an address
    //wsprintfW(osz, OLESTR("FilterGraph %08lx  pid %08lx"), (DWORD_PTR) this->p, ::GetCurrentProcessId());
    HRESULT hr = StringCchPrintfW(osz, sizeof(osz) / sizeof(osz[0]), OLESTR("FilterGraph %08lx  pid %08lx"), (DWORD_PTR) this->p, ::GetCurrentProcessId());
    if(FAILED(hr)){
        ASSERT(false);
    }
    hr = ::CreateItemMoniker(OLESTR("!"), osz, &pGraphMK);
    if (SUCCEEDED(hr)) {
        hr = pROT->Register(ROTFLAGS_REGISTRATIONKEEPSALIVE, *this, pGraphMK, pdwObjectRegistration);
    }
    return hr;
}

void DSGraph::RemoveFromROT(DWORD dwObjectRegistration) {
   PQROT pROT;
   if (SUCCEEDED(::GetRunningObjectTable(0, &pROT))) {
       pROT->Revoke(dwObjectRegistration);
   }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// DSFilter
///////////////////////////////////////////////////////////////////////////////////////////////

DSGraph DSFilter::GetGraph(void) {
    FILTER_INFO finfo;
    HRESULT hr = (*this)->QueryFilterInfo(&finfo);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSFilter::GetGraph() failed");
        return DSGraph();
    }
    DSGraph graph = finfo.pGraph;
    if (finfo.pGraph) finfo.pGraph->Release(); // transfer ref count
    return graph;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSFilter
///////////////////////////////////////////////////////////////////////////////////////////////
CString DSFilter::GetName(void) const {
    CString csName;
    FILTER_INFO finfo;
    if (*this) {
        HRESULT hr = (*this)->QueryFilterInfo(&finfo);
        if (SUCCEEDED(hr)) {
            csName = finfo.achName;
            if (csName.IsEmpty()) {
                csName = _T("");
            }
            if (finfo.pGraph) {
                finfo.pGraph->Release();
            }
        } else {
#ifdef _DEBUG
            csName = _T("**** UNKNOWN FILTER NAME ****");
#endif
        }
    } else {
#ifdef _DEBUG
        csName = _T("**** NULL FILTER POINTER ****");
#endif
    }
    return csName;
}

void DSFilter::GetPinCounts(ULONG &ulIn, ULONG &ulOut) const
{
    HRESULT hr;
    ulIn = ulOut = 0;
    PIN_DIRECTION pd;
    DSFilter::iterator i;
    for (i = begin(); i != end(); ++i) {
        hr = (*i)->QueryDirection(&pd);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "DSFilter:GetPinCounts() can't query pin direction hr = " << hr), "");
            THROWCOM(E_UNEXPECTED);
        }
        switch (pd) {
        case PINDIR_INPUT:
            ulIn++;
            break;
        case PINDIR_OUTPUT:
            ulOut++;
            break;
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSPin
///////////////////////////////////////////////////////////////////////////////////////////////

bool DSPin::HasCategory(const GUID2 &clsCategory, const PIN_DIRECTION pd) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::IsPinCategory() pin = " << this), "");
    PIN_DIRECTION pd1;
    HRESULT hr = (*this)->QueryDirection(&pd1);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSPIN::IsPinCategeory() cant query Pin direction");
        return false;
    }
    if (pd1 != pd) {
        TRACELM(TRACE_ERROR, "DSPin::IsPinCategeory() wrong direction");
        return false;
    }
    GUID2 pincat2;
    GetCategory(pincat2);
    return clsCategory == pincat2;
}

HRESULT DSPin::Connect(DSPin ConnectTo, const AM_MEDIA_TYPE *pMediaType) {
    DSGraph pGraph = GetGraph();
    DSGraph pConnGraph = ConnectTo.GetGraph();
    ASSERT(pGraph);
    ASSERT(pConnGraph);
    ASSERT(pGraph == pConnGraph);
    if (!pGraph || !pConnGraph || pGraph != pConnGraph) {
        TRACELM(TRACE_ERROR, "DSPin::Connect() pins not in same graph");
        THROWCOM(E_FAIL);
    }
	if (GetDirection() == PINDIR_OUTPUT) {
	    return pGraph->ConnectDirect(*this, ConnectTo, pMediaType);
	} else {
	    return pGraph->ConnectDirect(ConnectTo, *this, pMediaType);
	}
}

HRESULT DSPin::Disconnect(void) {
    DSPin ConnectedTo;
    HRESULT hr = (*this)->ConnectedTo(&ConnectedTo);
    if (FAILED(hr) || !ConnectedTo) {
        return NOERROR;  // not connected to anything
    }
    PIN_INFO pinfo;
    hr = (*this)->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSPin::Connect() can't call QueryPinInfo");
        THROWCOM(E_UNEXPECTED);
    }
    DSFilter PinFilter;
    PinFilter.p = pinfo.pFilter;  // directly transfer ownership of ref count
    DSGraph pGraph = PinFilter.GetGraph();
    if (!pGraph) {
        TRACELM(TRACE_ERROR, "DSPin::Disconnect() can't get graph from PinFilter");
        THROWCOM(E_UNEXPECTED);
    }
    hr = pGraph->Disconnect(ConnectedTo);
    if (FAILED(hr)) {
        return hr;
    }
    return pGraph->Disconnect(*this);
}

// for any pin to possibly route they must be on the same filter and different directions
bool DSPin::Routable(const DSPin pin2) const {
    if (GetFilter() != pin2.GetFilter()) {
        return false;
    }
    if (GetDirection() == pin2.GetDirection()) {
        return false;
    }
    return true;
}

bool DSPin::CanRoute(const DSPin pin2) const {
        ASSERT(GetFilter() == pin2.GetFilter());
    PQCrossbarSwitch px1(GetFilter());
    if (!px1) {
        return Routable(pin2);
    }

    return DSXBarPin(*this).CanRoute(DSXBarPin(pin2));
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSXBarPin
///////////////////////////////////////////////////////////////////////////////////////////////
#if 0
const DSXBarPin DSXBarPin::Find(const CPinPoints &pinpoints, const PQPoint &point, PIN_DIRECTION pindir) {
    CPinPoints::const_iterator i;
    TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() finding " << point << " direction = " << pindir), "");
    for (i = pinpoints.begin(); i != pinpoints.end(); ++i) {
        TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() checking " << DSPin((*i).first) << " direction " << DSPin((*i).first).GetDirection() << " " << (*i).second), "");
        if ((*i).second == point && DSPin((*i).first).GetDirection() == pindir) {
            DSPin p((*i).first);
            PQCrossbarSwitch px1(p.GetFilter());
            if (!px1) {
                TRACELSM(TRACE_ERROR,  (dbgDump << "DSXBarPin::Find() not an xbar " << p), "");
                THROWCOM(E_FAIL);
            }
            TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() found " << p), "");
            return DSXBarPin(p);
        }
    }
    THROWCOM(E_FAIL);
    return DSXBarPin();
}
#endif
// undone: cache this lookup
const PQPoint DSXBarPin::GetPoint() const {
    DSFilter f= GetFilter();
    PQCrossbarSwitch px(f);
    if (!px) {
        TRACELSM(TRACE_ERROR,  (dbgDump << "DSXBarPin::Pin2Point() not an xbar" << *this), "");
        THROWCOM(E_INVALIDARG);
    }

    PIN_DIRECTION dir = GetDirection();
    long idx = 0;
    DSFilter::iterator i;
    for (i = f.begin(); i != f.end() && *i != *this; ++i) {
        if ((*i).GetDirection() == dir) {  // output idx's start over at 0
            ++idx;
        }
    }

    if (i != f.end()) {
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::GetPoint() " << *this << " pt = " << idx), "");
        return PQPoint(px, idx);
    } else {
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::GetPoint() No Point"), "");
        return PQPoint();
    }
}

bool DSXBarPin::CanRoute(const DSXBarPin pin2) const {
    if (!Routable(pin2)) {
        // pins not on same filter or both pins same direction
        return false;
    }
    PQPoint pt1(GetPoint());
    if (!pt1.first) {
        // not on xbar or something corrupt
        return false;
    }
    PQPoint pt2(pin2.GetPoint());
    if (!pt2.first) {
        // not on xbar or something corrupt
        return false;
    }
    ASSERT(pt1.first == pt2.first);  // must be on same xbar

    HRESULT hr = E_FAIL;
    switch(GetDirection()) {
    case PINDIR_INPUT:
        hr = (pt1.first)->CanRoute(pt2.second, pt1.second);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::CanRoute() in 2.sec " << pt2.second << " 1.sec " << pt1.second << " hr = " << hr), "");
        break;
    case PINDIR_OUTPUT:
        hr = (pt1.first)->CanRoute(pt1.second, pt2.second);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::CanRoute() out 1.sec " << pt1.second << " 2.sec " << pt2.second << " hr = " << hr), "");
        break;
    }
    return hr == S_OK;
}

void VWStream::Route() {
    for (iterator i = begin(); i != end(); ++i) {
        CIOPoint p(*i);
        ASSERT(p.first.first == p.second.first);
        PQCrossbarSwitch px(p.first.first);
        HRESULT hr = px->Route(p.second.second, p.first.second);
        ASSERT(SUCCEEDED(hr));
                TRACELSM(TRACE_DETAIL, (dbgDump << "VWStream::Route() hr = " << hr << " px = " << px << " P.2.2 = " << p.second.second << " p.1.2 " << p.first.second), "");
    }
}

bool IsVideoFilter(const DSFilter& f) {
    DSFilter::iterator i;
    for (i = f.begin(); i != f.end(); ++i) {
        if (IsVideoPin(*i)) {
            return true;
        }
    }
    return false;
}

bool IsVideoPin(const DSPin& p) {
    DSPin::iterator i;
    for (i = p.begin(); i != p.end(); ++i) {
        if (IsVideoMediaType(*i)) {
            return true;
        }
    }
    return false;
}

#if 0
// disable until we have pinpoints cache
void DSXBarPin::GetRelations(const CPinPoints &pinpoints, CString &csName, CString &csType, CString &csRelName) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  examining xbar pin " << *this), "");
    CString csw;

    DSFilter f = GetFilter();
    PQCrossbarSwitch xbar(f);
    if (!xbar) {
        THROWCOM(E_FAIL);
    }
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  examining xbar filter" << f), "");
    long rel, phys;
    HRESULT hr = xbar->get_CrossbarPinInfo(IsInput(), Pin2Point(pinpoints).second, &rel, &phys);
    if (FAILED(hr)) {
        THROWCOM(hr);
    }

    TRACELSM(TRACE_DEBUG, (dbgDump << "DSXBarPin::GetRelations()  have xbar info.  pin = " << (*this) << " rel = " << rel << " phys = " << phys), "");

    TCHAR tphys[256];
    _ltot(phys, tphys, 10);

    csName = GetName();
    csType = tphys;

    ULONG inc, outc;
    f.GetPinCounts(inc, outc);
    long pincount = inc + outc;
    if (rel >= 0 && rel < pincount) {
        DSXBarPin RelPin(Find(pinpoints, PQPoint(xbar, rel), (*this).GetDirection()));
        if (!RelPin) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  can't build relpin.  rel = " << rel), "");
        } else {
            csRelName = RelPin.GetName();
        }
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSXBarPin::GetRelations()  Name " << csName << " Type " << csType << " RelName " << csRelName), "");

    return;
}
#endif

#ifdef _DEBUG
void DumpMediaTypes(DSPin &p1, DSPin &p2) {
    DSPin::iterator i;
    DumpHdr(dbgDump) << "DumpMediaTypes(): " << std::endl;
    TRACEINDENT();
    for (i = p1.begin(); i != p1.end(); ++i) {
        DumpHdr(dbgDump) << (*i) << " " << hexdump(p2->QueryAccept(*i)) << std::endl;
    }
    DumpHdr(dbgDump) << "----" << std::endl;
    for (i = p2.begin(); i != p2.end(); ++i) {
        DumpHdr(dbgDump) << (*i) << " " << hexdump(p1->QueryAccept(*i)) << std::endl;
    }
    TRACEOUTDENT();
    dbgDump.flush();
}
#endif

#pragma optimize("a", off)

bool DSGraph::LoadPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, const DWORD dwMerit) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    ASSERT(pPin1.GetGraph() == *this);
    ASSERT(pFilter1.GetGraph() == *this);

    GUID2* pInMedia = NULL;
    GUID2* pOutMedia = NULL;

    try {
        TRACEINDENT();
        // possibly in the future we should find all of the possible choices and
        // use the shortest available path.  but for now, we're just going to
        // find the first one that exists

        PIN_DIRECTION pd;
        HRESULT hr = pPin1->QueryDirection(&pd);
        if (FAILED(hr)) {
            TRACEOUTDENT();
            TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMedium() can't query direction");
            THROWCOM(E_UNEXPECTED);
        }
		PIN_DIRECTION pd2;
		switch (pd) {
		case PINDIR_INPUT:
			pd2 = PINDIR_OUTPUT;
			break;
		case PINDIR_OUTPUT:
			pd2 = PINDIR_INPUT;
			break;
		}

        bool fInReq = false, fOutReq = false;
        DWORD dwIn = 0;
        DWORD dwOut = 0;
        GUID2** ppMediaList = NULL;
        DWORD dwMediaCount = 0;

        for (DSPin::iterator i = pPin1.begin(); i != pPin1.end(); ++i) {
            ++dwMediaCount;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() pindir = " << pd << " mediacount = " << dwMediaCount), "");

        switch (pd) {
        case PINDIR_INPUT:
            // hunting through graph from right to left
            fOutReq = true;
            dwOut = dwMediaCount;
            pOutMedia = new GUID2[dwOut * 2];
            ppMediaList = &pOutMedia;
            break;
        case PINDIR_OUTPUT:
            // hunting through graph from left to right
            fInReq = true;
            dwIn = dwMediaCount;
            pInMedia = new GUID2[dwIn * 2];
            ppMediaList = &pInMedia;

            break;
        }
        DWORD idx = 0;
        // note: some buggy filters don't support the reuse of an IEnumMediaTypes even though
        // reset succeeds.  they AV during the next pass through the enumerator.  thus, we
        // just create a new iterator which fetches a new IEnumMediaTypes interface(and underlying object)
        for (DSPin::iterator i2 = pPin1.begin(); i2 != pPin1.end(); ++i2) {
            (*ppMediaList)[idx++] = (*i2)->majortype;
            (*ppMediaList)[idx++] =  (*i2)->subtype;
        }

        TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMediaType()  dwFlags = " << hexdump(dwFlags) << " Merit = " << hexdump(dwMerit) << " MediaList = ");
        TRACEINDENT();
        for (idx = 0; idx < dwMediaCount; ++idx) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "major = " << (*ppMediaList)[idx * 2] << " sub = " << (*ppMediaList)[(idx * 2) + 1] ), "");
        }
        TRACEOUTDENT();

        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() fInReq = " << fInReq), "");
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() fOutReq = " << fOutReq), "");

                // try normal first
        {DSFilterMapper fmr(PQFilterMapper(*this),
                       0,										// 0 flags
                       !(dwFlags & ALLOW_WILDCARDS),			// bExactMatch
                       dwMerit,						            // merit
                       fInReq,                                  // input required
                       dwIn,
                       pInMedia,
                       NULL,                                    // input medium
                       NULL,                                    // input pin cat
                       false,                                   // input rendered?
                       fOutReq,                                 // output required
                       dwOut,
                       pOutMedia,
                       NULL,                                    // output medium
                       NULL                                             // output pin cat
                      );
        if (fmr) {
            // direct connect
			for (DSFilterMapper::iterator i = fmr.begin(); i != fmr.end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMediaType))) {
#endif
                    TRACEOUTDENT();
                    TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMediaType() succeeded");
                    delete[] pInMedia;
                    delete[] pOutMedia;
					return true;
				}
			}
        }}
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) ||
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			) {
			try {
                delete[] pInMedia;
                delete[] pOutMedia;
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
        TRACEOUTDENT();
    }
    delete[] pInMedia;
    delete[] pOutMedia;
    TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMediaType() failed");
    return false;
}

#endif //TUNING_MODEL_ONLY

// end of file - dsextend.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\dsoundp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/10/96     angusm  Added CLSID for DirectSound
 *  2/11/96     angusm  Added DSERR_UNINITIALIZED
 *  2/12/96     angusm  Added DSSCL_UNINITIALIZED
 *  3/5/96      angusm  Removed DSSCL_UNINITIALIZED
 *  1/29/97     dereks  Added boundaries, LPC* and REFGUIDs
 *  4/10/97     dereks  Added IDirectSoundCapture
 *  4/11/97     dereks  Added IKsPropertySet
 *  4/25/97     johnnyl Added DSCCREATE_WAVEMAPPED flag
 *  5/7/97      johnnyl Added DirectSoundCaptureBuffer::Initialize method
 *  5/8/97      dereks  Backed out REFGUIDs
 *  5/9/97      johnnyl Changed DSCCREATE_WAVEMAPPED to DSCBCAPS_WAVEMAPPED
 *                      Added DSCBLOCK_ENTIREBUFFER flag
 *  5/29/97     dereks  IDirectSoundPropertySet => IKsPropertySet
 *  7/10/98     dereks  Added DirectX 6.1 features
 *  8/19/98     dereks  Moved private object to dsprv.h
 *  9/15/98     dereks  Added DirectX 7.0 features
 *  7/6/99      duganp  Added DirectX 8.0 features
 *  10/29/99    duganp  Added DirectX 7.1 features (sic)
 *  06/06/00    alanlu  Cleaned up DSFX_I3DL2* constants
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <float.h>

#ifndef DIRECTSOUND_VERSION
#define DIRECTSOUND_VERSION 0x0800  /* Version 8.0 */
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

/* Type definitions shared with Direct3D */

#ifndef DX_SHARED_DEFINES

typedef float D3DVALUE, *LPD3DVALUE;

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

#ifndef LPD3DCOLOR_DEFINED
typedef DWORD *LPD3DCOLOR;
#define LPD3DCOLOR_DEFINED
#endif

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef LPD3DVECTOR_DEFINED
typedef D3DVECTOR *LPD3DVECTOR;
#define LPD3DVECTOR_DEFINED
#endif

#define DX_SHARED_DEFINES
#endif // DX_SHARED_DEFINES

#define _FACDS  0x878   /* DirectSound's facility code */
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

// DirectSound Component GUID {47D4D946-62E8-11CF-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound 8.0 Component GUID {3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}
DEFINE_GUID(CLSID_DirectSound8, 0x3901cc3f, 0x84b5, 0x4fa4, 0xba, 0x35, 0xaa, 0x81, 0x72, 0xb8, 0xa0, 0x9b);

// DirectSound Capture Component GUID {B0210780-89CD-11D0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

// DirectSound 8.0 Capture Component GUID {E4BCAC13-7F99-4908-9A8E-74E3BF24B6E1}
DEFINE_GUID(CLSID_DirectSoundCapture8, 0xe4bcac13, 0x7f99, 0x4908, 0x9a, 0x8e, 0x74, 0xe3, 0xbf, 0x24, 0xb6, 0xe1);

// DirectSound Full Duplex Component GUID {FEA4300C-7959-4147-B26A-2377B9E7A91D}
DEFINE_GUID(CLSID_DirectSoundFullDuplex, 0xfea4300c, 0x7959, 0x4147, 0xb2, 0x6a, 0x23, 0x77, 0xb9, 0xe7, 0xa9, 0x1d);

//@@BEGIN_MSINTERNAL
// DirectSound Buffer Descriptor GUID {B2F586D4-5558-49D1-A07B3249DBBB33C2}
DEFINE_GUID(CLSID_DirectSoundBufferConfig, 0xb2f586d4, 0x5558, 0x49d1, 0xa0, 0x7b, 0x32, 0x49, 0xdb, 0xbb, 0x33, 0xc2);
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Magic private DirectSound buffer descriptor GUID {74A794F9-FDD2-4684-88831CB3CA6E6DA6}
DEFINE_GUID(CLSID_PRIVATE_CDirectSoundBufferConfig, 0x74a794f9, 0xfdd2, 0x4684, 0x88, 0x83, 0x1c, 0xb3, 0xca, 0x6e, 0x6d, 0xa6);
//@@END_MSINTERNAL

// DirectSound default playback device GUID {DEF00000-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultPlayback, 0xdef00000, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default capture device GUID {DEF00001-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultCapture, 0xdef00001, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice playback {DEF00002-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoicePlayback, 0xdef00002, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice capture {DEF00003-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoiceCapture, 0xdef00003, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);


//
// Forward declarations for interfaces.
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
//

#ifdef __cplusplus
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

//@@BEGIN_MSINTERNAL

//
// DirectSound 7.1 (Windows ME) interface.
//

#if DIRECTSOUND_VERSION >= 0x0701
#ifdef __cplusplus
struct IDirectSoundCaptureBuffer7_1;
#endif
#endif

//@@END_MSINTERNAL

//
// DirectSound 8.0 interfaces.
//

#if DIRECTSOUND_VERSION >= 0x0800

#ifdef __cplusplus
struct IDirectSound8;
struct IDirectSoundBuffer8;
struct IDirectSoundCaptureBuffer8;
//@@BEGIN_MSINTERNAL
struct IDirectSoundFXSend;
//@@END_MSINTERNAL
struct IDirectSoundFXGargle;
struct IDirectSoundFXChorus;
struct IDirectSoundFXFlanger;
struct IDirectSoundFXEcho;
struct IDirectSoundFXDistortion;
struct IDirectSoundFXCompressor;
struct IDirectSoundFXParamEq;
struct IDirectSoundFXWavesReverb;
//@@BEGIN_MSINTERNAL
///struct IDirectSoundFXI3DL2Source;
//@@END_MSINTERNAL
struct IDirectSoundFXI3DL2Reverb;
struct IDirectSoundCaptureFXAec;
struct IDirectSoundCaptureFXNoiseSuppress;
//@@BEGIN_MSINTERNAL
struct IDirectSoundCaptureFXAgc;
struct IDirectSoundCaptureFXMicArray;
struct IDirectSoundDMOProxy;
struct IDirectSoundFXI3DL2SourceEnv;
struct IDirectSound3DBufferPrivate;
//@@END_MSINTERNAL
struct IDirectSoundFullDuplex;
#endif // __cplusplus

// IDirectSound8, IDirectSoundBuffer8 and IDirectSoundCaptureBuffer8 are the
// only DirectSound 7.0 interfaces with changed functionality in version 8.0.
// The other level 8 interfaces as equivalent to their level 7 counterparts:

#define IDirectSoundCapture8            IDirectSoundCapture
#define IDirectSound3DListener8         IDirectSound3DListener
#define IDirectSound3DBuffer8           IDirectSound3DBuffer
#define IDirectSoundNotify8             IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IDirectSoundFXSend8             IDirectSoundFXSend
//@@END_MSINTERNAL
#define IDirectSoundFXGargle8           IDirectSoundFXGargle
#define IDirectSoundFXChorus8           IDirectSoundFXChorus
#define IDirectSoundFXFlanger8          IDirectSoundFXFlanger
#define IDirectSoundFXEcho8             IDirectSoundFXEcho
#define IDirectSoundFXDistortion8       IDirectSoundFXDistortion
#define IDirectSoundFXCompressor8       IDirectSoundFXCompressor
#define IDirectSoundFXParamEq8          IDirectSoundFXParamEq
#define IDirectSoundFXWavesReverb8      IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IDirectSoundFXI3DL2Source8      IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IDirectSoundFXI3DL2Reverb8      IDirectSoundFXI3DL2Reverb
#define IDirectSoundCaptureFXAec8       IDirectSoundCaptureFXAec
#define IDirectSoundCaptureFXNoiseSuppress8 IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IDirectSoundCaptureFXAgc8       IDirectSoundCaptureFXAgc
#define IDirectSoundCaptureFXMicArray8  IDirectSoundCaptureFXMicArray
#define IDirectSoundDMOProxy8           IDirectSoundDMOProxy
#define IDirectSoundFXI3DL2SourceEnv8   IDirectSoundFXI3DL2SourceEnv
#define IDirectSound3DBufferPrivate8    IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IDirectSoundFullDuplex8         IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800


typedef struct IDirectSound                 *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer           *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener       *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer         *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture          *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer    *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify           *LPDIRECTSOUNDNOTIFY;

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
typedef struct IDirectSoundCaptureBuffer7_1 *LPDIRECTSOUNDCAPTUREBUFFER7_1;
#endif
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend           *LPDIRECTSOUNDFXSEND;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef struct IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef struct IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef struct IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef struct IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef struct IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef struct IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef struct IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source    *LPDIRECTSOUNDFXI3DL2SOURCE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef struct IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef struct IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc     *LPDIRECTSOUNDCAPTUREFXAGC;
typedef struct IDirectSoundCaptureFXMicArray *LPDIRECTSOUNDCAPTUREFXMICARRAY;
typedef struct IDirectSoundDMOProxy         *LPDIRECTSOUNDDMOPROXY;
typedef struct IDirectSoundFXI3DL2SourceEnv *LPDIRECTSOUNDFXI3DL2SOURCEENV;
typedef struct IDirectSound3DBufferPrivate  *LPDIRECTSOUND3DBUFFERPRIVATE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef struct IDirectSound8                *LPDIRECTSOUND8;
typedef struct IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef struct IDirectSound3DListener8      *LPDIRECTSOUND3DLISTENER8;
typedef struct IDirectSound3DBuffer8        *LPDIRECTSOUND3DBUFFER8;
typedef struct IDirectSoundCapture8         *LPDIRECTSOUNDCAPTURE8;
typedef struct IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;
typedef struct IDirectSoundNotify8          *LPDIRECTSOUNDNOTIFY8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend8          *LPDIRECTSOUNDFXSEND8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle8        *LPDIRECTSOUNDFXGARGLE8;
typedef struct IDirectSoundFXChorus8        *LPDIRECTSOUNDFXCHORUS8;
typedef struct IDirectSoundFXFlanger8       *LPDIRECTSOUNDFXFLANGER8;
typedef struct IDirectSoundFXEcho8          *LPDIRECTSOUNDFXECHO8;
typedef struct IDirectSoundFXDistortion8    *LPDIRECTSOUNDFXDISTORTION8;
typedef struct IDirectSoundFXCompressor8    *LPDIRECTSOUNDFXCOMPRESSOR8;
typedef struct IDirectSoundFXParamEq8       *LPDIRECTSOUNDFXPARAMEQ8;
typedef struct IDirectSoundFXWavesReverb8   *LPDIRECTSOUNDFXWAVESREVERB8;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source8   *LPDIRECTSOUNDFXI3DL2SOURCE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb8   *LPDIRECTSOUNDFXI3DL2REVERB8;
typedef struct IDirectSoundCaptureFXAec8    *LPDIRECTSOUNDCAPTUREFXAEC8;
typedef struct IDirectSoundCaptureFXNoiseSuppress8 *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc8    *LPDIRECTSOUNDCAPTUREFXAGC8;
typedef struct IDirectSoundCaptureFXMicArray8 *LPDIRECTSOUNDCAPTUREFXMICARRAY8;
typedef struct IDirectSoundDMOProxy8        *LPDIRECTSOUNDDMOPROXY8;
typedef struct IDirectSoundFXI3DL2SourceEnv8 *LPDIRECTSOUNDFXI3DL2SOURCEENV8;
typedef struct IDirectSound3DBufferPrivate8 *LPDIRECTSOUND3DBUFFERPRIVATE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex8      *LPDIRECTSOUNDFULLDUPLEX8;

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IID definitions for the unchanged DirectSound 8.0 interfaces
//

#if DIRECTSOUND_VERSION >= 0x0800
#define IID_IDirectSoundCapture8            IID_IDirectSoundCapture
#define IID_IDirectSound3DListener8         IID_IDirectSound3DListener
#define IID_IDirectSound3DBuffer8           IID_IDirectSound3DBuffer
#define IID_IDirectSoundNotify8             IID_IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundFXSend8             IID_IDirectSoundFXSend
//@@END_MSINTERNAL
#define IID_IDirectSoundFXGargle8           IID_IDirectSoundFXGargle
#define IID_IDirectSoundFXChorus8           IID_IDirectSoundFXChorus
#define IID_IDirectSoundFXFlanger8          IID_IDirectSoundFXFlanger
#define IID_IDirectSoundFXEcho8             IID_IDirectSoundFXEcho
#define IID_IDirectSoundFXDistortion8       IID_IDirectSoundFXDistortion
#define IID_IDirectSoundFXCompressor8       IID_IDirectSoundFXCompressor
#define IID_IDirectSoundFXParamEq8          IID_IDirectSoundFXParamEq
#define IID_IDirectSoundFXWavesReverb8      IID_IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IID_IDirectSoundFXI3DL2Source8      IID_IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IID_IDirectSoundFXI3DL2Reverb8      IID_IDirectSoundFXI3DL2Reverb
#define IID_IDirectSoundCaptureFXAec8       IID_IDirectSoundCaptureFXAec
#define IID_IDirectSoundCaptureFXNoiseSuppress8 IID_IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundCaptureFXAgc8       IID_IDirectSoundCaptureFXAgc
#define IID_IDirectSoundCaptureFXMicArray8  IID_IDirectSoundCaptureFXMicArray
#define IID_IDirectSoundDMOProxy8           IID_IDirectSoundDMOProxy
#define IID_IDirectSoundFXI3DL2SourceEnv8   IID_IDirectSoundFXI3DL2SourceEnv
#define IID_IDirectSound3DBufferPrivate8    IID_IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IID_IDirectSoundFullDuplex8         IID_IDirectSoundFullDuplex
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800
typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTURE8 *LPLPDIRECTSOUNDCAPTURE8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
//@@BEGIN_MSINTERNAL
    // dwReserved1 == minor ver number, dwReserved2 == major ver number.
//@@END_MSINTERNAL
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

#if DIRECTSOUND_VERSION >= 0x0800

    typedef struct _DSEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSFXClass;
        DWORD_PTR   dwReserved1;
        DWORD_PTR   dwReserved2;
    } DSEFFECTDESC, *LPDSEFFECTDESC;
    typedef const DSEFFECTDESC *LPCDSEFFECTDESC;

    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002
//@@BEGIN_MSINTERNAL
    #define DSFX_OPTIONAL       0x00000004
    #define DSFX_VALIDFLAGS     (DSFX_LOCHARDWARE | DSFX_LOCSOFTWARE)
//@@END_MSINTERNAL

    enum
    {
        DSFXR_PRESENT,          // 0
        DSFXR_LOCHARDWARE,      // 1
        DSFXR_LOCSOFTWARE,      // 2
        DSFXR_UNALLOCATED,      // 3
        DSFXR_FAILED,           // 4
        DSFXR_UNKNOWN,          // 5
        DSFXR_SENDLOOP          // 6
    };

    typedef struct _DSCEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSCFXClass;
        GUID        guidDSCFXInstance;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSCEFFECTDESC, *LPDSCEFFECTDESC;
    typedef const DSCEFFECTDESC *LPCDSCEFFECTDESC;

    #define DSCFX_LOCHARDWARE   0x00000001
    #define DSCFX_LOCSOFTWARE   0x00000002
//@@BEGIN_MSINTERNAL
    #define DSCFX_RESERVED      0x00000020
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
    #define DSCFX_LOCMASK         (DSCFX_LOCHARDWARE | DSCFX_LOCSOFTWARE )
    #define DSCFX_VALIDFLAGS      (DSCFX_LOCMASK)
//@@END_MSINTERNAL

    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020
//@@BEGIN_MSINTERNAL
// Since we don't support LOCDEFER-style voice management on capture,
// and we don't have a DSCFX_OPTIONAL flag at the moment, none of the
// flags below can ever be returned.  So they're private for now.
    #define DSCFXR_UNALLOCATED  0x00000040
    #define DSCFXR_FAILED       0x00000080
    #define DSCFXR_UNKNOWN      0x00000100
//@@END_MSINTERNAL

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

// Older version of this structure:

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC1, *LPDSCBUFFERDESC1;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0800
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
#endif
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID pcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE *ppDSC, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

#if DIRECTSOUND_VERSION >= 0x0800
extern HRESULT WINAPI DirectSoundCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUND8 *ppDS8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE8 *ppDSC8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundFullDuplexCreate(LPCGUID pcGuidCaptureDevice, LPCGUID pcGuidRenderDevice,
        LPCDSCBUFFERDESC pcDSCBufferDesc, LPCDSBUFFERDESC pcDSBufferDesc, HWND hWnd,
        DWORD dwLevel, LPDIRECTSOUNDFULLDUPLEX* ppDSFD, LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8,
        LPDIRECTSOUNDBUFFER8 *ppDSBuffer8, LPUNKNOWN pUnkOuter);
#define DirectSoundFullDuplexCreate8 DirectSoundFullDuplexCreate

extern HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest);
#endif // DIRECTSOUND_VERSION >= 0x0800

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

DEFINE_GUID(IID_IReferenceClock, 0x56a86897, 0x0ad4, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#undef INTERFACE
#define INTERFACE IReferenceClock

DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IReferenceClock methods
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,
                                           HANDLE hEvent, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,
                                           HANDLE hSemaphore, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif // __IReferenceClock_INTERFACE_DEFINED__

#ifndef IReferenceClock_QueryInterface

#define IReferenceClock_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IReferenceClock_AddRef(p)                  IUnknown_AddRef(p)
#define IReferenceClock_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->lpVtbl->GetTime(p,a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->lpVtbl->AdviseTime(p,a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->lpVtbl->AdvisePeriodic(p,a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->lpVtbl->Unadvise(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->GetTime(a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->AdviseTime(a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->AdvisePeriodic(a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->Unadvise(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // IReferenceClock_QueryInterface

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound8
//

DEFINE_GUID(IID_IDirectSound8, 0xC50A7E93, 0xF395, 0x4834, 0x9E, 0xF6, 0x7F, 0xA9, 0x9D, 0xE5, 0x09, 0x66);

#undef INTERFACE
#define INTERFACE IDirectSound8

DECLARE_INTERFACE_(IDirectSound8, IDirectSound)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;

    // IDirectSound8 methods
    STDMETHOD(VerifyCertification)  (THIS_ LPDWORD pdwCertified) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
    STDMETHOD(CreateSoundBufferFromWave) (THIS_ LPUNKNOWN pDSWave, DWORD dwFlags, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
#endif
//@@END_MSINTERNAL
};

#define IDirectSound8_QueryInterface(p,a,b)       IDirectSound_QueryInterface(p,a,b)
#define IDirectSound8_AddRef(p)                   IDirectSound_AddRef(p)
#define IDirectSound8_Release(p)                  IDirectSound_Release(p)
#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  IDirectSound_CreateSoundBuffer(p,a,b,c)
#define IDirectSound8_GetCaps(p,a)                IDirectSound_GetCaps(p,a)
#define IDirectSound8_DuplicateSoundBuffer(p,a,b) IDirectSound_DuplicateSoundBuffer(p,a,b)
#define IDirectSound8_SetCooperativeLevel(p,a,b)  IDirectSound_SetCooperativeLevel(p,a,b)
#define IDirectSound8_Compact(p)                  IDirectSound_Compact(p)
#define IDirectSound8_GetSpeakerConfig(p,a)       IDirectSound_GetSpeakerConfig(p,a)
#define IDirectSound8_SetSpeakerConfig(p,a)       IDirectSound_SetSpeakerConfig(p,a)
#define IDirectSound8_Initialize(p,a)             IDirectSound_Initialize(p,a)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->lpVtbl->VerifyCertification(p,a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->lpVtbl->CreateSoundBufferFromWave(p,a,b,c)
#endif
//@@END_MSINTERNAL
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->VerifyCertification(a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->CreateSoundBufferFromWave(a,b,c)
#endif
//@@END_MSINTERNAL
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer8
//

DEFINE_GUID(IID_IDirectSoundBuffer8, 0x6825a449, 0x7524, 0x4d82, 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer8

DECLARE_INTERFACE_(IDirectSoundBuffer8, IDirectSoundBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;

    // IDirectSoundBuffer8 methods
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
    STDMETHOD(SetChannelVolume)     (THIS_ DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes) PURE;
#endif
//@@END_MSINTERNAL
};

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

#define IDirectSoundBuffer8_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer8_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundBuffer8_Release(p)                      IUnknown_Release(p)

#define IDirectSoundBuffer8_GetCaps(p,a)                    IDirectSoundBuffer_GetCaps(p,a)
#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)       IDirectSoundBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer8_GetFormat(p,a,b,c)              IDirectSoundBuffer_GetFormat(p,a,b,c)
#define IDirectSoundBuffer8_GetVolume(p,a)                  IDirectSoundBuffer_GetVolume(p,a)
#define IDirectSoundBuffer8_GetPan(p,a)                     IDirectSoundBuffer_GetPan(p,a)
#define IDirectSoundBuffer8_GetFrequency(p,a)               IDirectSoundBuffer_GetFrequency(p,a)
#define IDirectSoundBuffer8_GetStatus(p,a)                  IDirectSoundBuffer_GetStatus(p,a)
#define IDirectSoundBuffer8_Initialize(p,a,b)               IDirectSoundBuffer_Initialize(p,a,b)
#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)           IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer8_Play(p,a,b,c)                   IDirectSoundBuffer_Play(p,a,b,c)
#define IDirectSoundBuffer8_SetCurrentPosition(p,a)         IDirectSoundBuffer_SetCurrentPosition(p,a)
#define IDirectSoundBuffer8_SetFormat(p,a)                  IDirectSoundBuffer_SetFormat(p,a)
#define IDirectSoundBuffer8_SetVolume(p,a)                  IDirectSoundBuffer_SetVolume(p,a)
#define IDirectSoundBuffer8_SetPan(p,a)                     IDirectSoundBuffer_SetPan(p,a)
#define IDirectSoundBuffer8_SetFrequency(p,a)               IDirectSoundBuffer_SetFrequency(p,a)
#define IDirectSoundBuffer8_Stop(p)                         IDirectSoundBuffer_Stop(p)
#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)               IDirectSoundBuffer_Unlock(p,a,b,c,d)
#define IDirectSoundBuffer8_Restore(p)                      IDirectSoundBuffer_Restore(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->lpVtbl->SetFX(p,a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->lpVtbl->AcquireResources(p,a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->SetFX(a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->AcquireResources(a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->GetObjectInPath(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ D3DVECTOR* pvOrientFront, D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD pdwInsideConeAngle, LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC pcDSCBufferDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701

//
// IDirectSoundCaptureBuffer7_1
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer7_1, 0xd6b2a50d, 0x918e, 0x47de, 0x9b, 0xcd, 0x64, 0xd4, 0x9c, 0x5b, 0x1d, 0x75);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer7_1

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer7_1, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer7_1 methods
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(SetMicVolume)         (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetMicVolume)         (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(EnableMic)            (THIS_ BOOL fEnable) PURE;
    STDMETHOD(YieldFocus)           (THIS) PURE;
    STDMETHOD(ClaimFocus)           (THIS) PURE;
    STDMETHOD(SetFocusHWND)         (THIS_ HWND hwndMainWindow) PURE;
    STDMETHOD(GetFocusHWND)         (THIS_ HWND *phwndMainWindow) PURE;
    STDMETHOD(EnableFocusNotifications) (THIS_ HANDLE hFocusEvent) PURE;
};

#define IDirectSoundCaptureBuffer7_1_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer7_1_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer7_1_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->lpVtbl->SetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->lpVtbl->GetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->lpVtbl->YieldFocus(p)
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->lpVtbl->ClaimFocus(p)
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->lpVtbl->SetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->lpVtbl->GetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->lpVtbl->EnableFocusNotifications(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->Start(a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->Stop()
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->Unlock(a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->SetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->GetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->YieldFocus()
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->ClaimFocus()
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->SetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->GetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->EnableFocusNotifications(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0701
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundCaptureBuffer8
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer8, 0x990df4, 0xdbb, 0x4872, 0x83, 0x3e, 0x6d, 0x30, 0x3e, 0x80, 0xae, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer8

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer8, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer8 methods
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwFXCount, LPDWORD pdwFXStatus) PURE;
};

#define IDirectSoundCaptureBuffer8_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer8_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer8_Release(p)                       IUnknown_Release(p)

#define IDirectSoundCaptureBuffer8_GetCaps(p,a)                     IDirectSoundCaptureBuffer_GetCaps(p,a)
#define IDirectSoundCaptureBuffer8_GetCurrentPosition(p,a,b)        IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer8_GetFormat(p,a,b,c)               IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer8_GetStatus(p,a)                   IDirectSoundCaptureBuffer_GetStatus(p,a)
#define IDirectSoundCaptureBuffer8_Initialize(p,a,b)                IDirectSoundCaptureBuffer_Initialize(p,a,b)
#define IDirectSoundCaptureBuffer8_Lock(p,a,b,c,d,e,f,g)            IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer8_Start(p,a)                       IDirectSoundCaptureBuffer_Start(p,a)
#define IDirectSoundCaptureBuffer8_Stop(p)                          IDirectSoundCaptureBuffer_Stop(p))
#define IDirectSoundCaptureBuffer8_Unlock(p,a,b,c,d)                IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->lpVtbl->GetFXStatus(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->GetObjectInPath(a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->GetFXStatus(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength, PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID rguidPropSet, ULONG ulId, PULONG pulTypeSupport) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL

//
// IDirectSoundFXSend
//

DEFINE_GUID(IID_IDirectSoundFXSend, 0xb30f3564, 0x1698, 0x45ba, 0x9f, 0x75, 0xfc, 0x3c, 0x6c, 0x3b, 0x28, 0x10);

typedef struct _DSFXSend
{
    LONG lSendLevel;
} DSFXSend, *LPDSFXSend;

typedef const DSFXSend *LPCDSFXSend;

#undef INTERFACE
#define INTERFACE IDirectSoundFXSend

DECLARE_INTERFACE_(IDirectSoundFXSend, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXSend methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXSend pcDsFxSend) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXSend pDsFxSend) PURE;
};

#define IDirectSoundFXSend_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXSend_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXSend_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXGargle
//

DEFINE_GUID(IID_IDirectSoundFXGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);

typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle, *LPDSFXGargle;

#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1

typedef const DSFXGargle *LPCDSFXGargle;

#define DSFXGARGLE_RATEHZ_MIN           1
#define DSFXGARGLE_RATEHZ_MAX           1000

#undef INTERFACE
#define INTERFACE IDirectSoundFXGargle

DECLARE_INTERFACE_(IDirectSoundFXGargle, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXGargle methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle pDsFxGargle) PURE;
};

#define IDirectSoundFXGargle_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXGargle_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXGargle_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXChorus
//

DEFINE_GUID(IID_IDirectSoundFXChorus, 0x880842e3, 0x145f, 0x43e6, 0xa9, 0x34, 0xa7, 0x18, 0x06, 0xe5, 0x05, 0x47);

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus, *LPDSFXChorus;

typedef const DSFXChorus *LPCDSFXChorus;

#define DSFXCHORUS_WAVE_TRIANGLE        0
#define DSFXCHORUS_WAVE_SIN             1

#define DSFXCHORUS_WETDRYMIX_MIN        0.0f
#define DSFXCHORUS_WETDRYMIX_MAX        100.0f
#define DSFXCHORUS_DEPTH_MIN            0.0f
#define DSFXCHORUS_DEPTH_MAX            100.0f
#define DSFXCHORUS_FEEDBACK_MIN         -99.0f
#define DSFXCHORUS_FEEDBACK_MAX         99.0f
#define DSFXCHORUS_FREQUENCY_MIN        0.0f
#define DSFXCHORUS_FREQUENCY_MAX        10.0f
#define DSFXCHORUS_DELAY_MIN            0.0f
#define DSFXCHORUS_DELAY_MAX            20.0f
#define DSFXCHORUS_PHASE_MIN            0
#define DSFXCHORUS_PHASE_MAX            4

#define DSFXCHORUS_PHASE_NEG_180        0
#define DSFXCHORUS_PHASE_NEG_90         1
#define DSFXCHORUS_PHASE_ZERO           2
#define DSFXCHORUS_PHASE_90             3
#define DSFXCHORUS_PHASE_180            4

#undef INTERFACE
#define INTERFACE IDirectSoundFXChorus

DECLARE_INTERFACE_(IDirectSoundFXChorus, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXChorus methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus pDsFxChorus) PURE;
};

#define IDirectSoundFXChorus_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXChorus_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXChorus_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXFlanger
//

DEFINE_GUID(IID_IDirectSoundFXFlanger, 0x903e9878, 0x2c92, 0x4072, 0x9b, 0x2c, 0xea, 0x68, 0xf5, 0x39, 0x67, 0x83);

typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger, *LPDSFXFlanger;

typedef const DSFXFlanger *LPCDSFXFlanger;

#define DSFXFLANGER_WAVE_TRIANGLE       0
#define DSFXFLANGER_WAVE_SIN            1

#define DSFXFLANGER_WETDRYMIX_MIN       0.0f
#define DSFXFLANGER_WETDRYMIX_MAX       100.0f
#define DSFXFLANGER_FREQUENCY_MIN       0.0f
#define DSFXFLANGER_FREQUENCY_MAX       10.0f
#define DSFXFLANGER_DEPTH_MIN           0.0f
#define DSFXFLANGER_DEPTH_MAX           100.0f
#define DSFXFLANGER_PHASE_MIN           0
#define DSFXFLANGER_PHASE_MAX           4
#define DSFXFLANGER_FEEDBACK_MIN        -99.0f
#define DSFXFLANGER_FEEDBACK_MAX        99.0f
#define DSFXFLANGER_DELAY_MIN           0.0f
#define DSFXFLANGER_DELAY_MAX           4.0f

#define DSFXFLANGER_PHASE_NEG_180       0
#define DSFXFLANGER_PHASE_NEG_90        1
#define DSFXFLANGER_PHASE_ZERO          2
#define DSFXFLANGER_PHASE_90            3
#define DSFXFLANGER_PHASE_180           4

#undef INTERFACE
#define INTERFACE IDirectSoundFXFlanger

DECLARE_INTERFACE_(IDirectSoundFXFlanger, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXFlanger methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXFlanger pDsFxFlanger) PURE;
};

#define IDirectSoundFXFlanger_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXFlanger_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundFXFlanger_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->SetAllParameters(a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXEcho
//

DEFINE_GUID(IID_IDirectSoundFXEcho, 0x8bd28edf, 0x50db, 0x4e92, 0xa2, 0xbd, 0x44, 0x54, 0x88, 0xd1, 0xed, 0x42);

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho, *LPDSFXEcho;

typedef const DSFXEcho *LPCDSFXEcho;

#define DSFXECHO_WETDRYMIX_MIN      0.0f
#define DSFXECHO_WETDRYMIX_MAX      100.0f
#define DSFXECHO_FEEDBACK_MIN       0.0f
#define DSFXECHO_FEEDBACK_MAX       100.0f
#define DSFXECHO_LEFTDELAY_MIN      1.0f
#define DSFXECHO_LEFTDELAY_MAX      2000.0f
#define DSFXECHO_RIGHTDELAY_MIN     1.0f
#define DSFXECHO_RIGHTDELAY_MAX     2000.0f
#define DSFXECHO_PANDELAY_MIN       0
#define DSFXECHO_PANDELAY_MAX       1

#undef INTERFACE
#define INTERFACE IDirectSoundFXEcho

DECLARE_INTERFACE_(IDirectSoundFXEcho, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXEcho methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXEcho pDsFxEcho) PURE;
};

#define IDirectSoundFXEcho_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXEcho_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXEcho_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXDistortion
//

DEFINE_GUID(IID_IDirectSoundFXDistortion, 0x8ecf4326, 0x455f, 0x4d8b, 0xbd, 0xa9, 0x8d, 0x5d, 0x3e, 0x9e, 0x3e, 0x0b);

typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion, *LPDSFXDistortion;

typedef const DSFXDistortion *LPCDSFXDistortion;

#define DSFXDISTORTION_GAIN_MIN                     -60.0f
#define DSFXDISTORTION_GAIN_MAX                     0.0f
#define DSFXDISTORTION_EDGE_MIN                     0.0f
#define DSFXDISTORTION_EDGE_MAX                     100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN    100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX    8000.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MIN          100.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MAX          8000.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MIN         100.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MAX         8000.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXDistortion

DECLARE_INTERFACE_(IDirectSoundFXDistortion, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXDistortion methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion pDsFxDistortion) PURE;
};

#define IDirectSoundFXDistortion_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXDistortion_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXDistortion_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXCompressor
//

DEFINE_GUID(IID_IDirectSoundFXCompressor, 0x4bbd1154, 0x62f6, 0x4e2c, 0xa1, 0x5c, 0xd3, 0xb6, 0xc4, 0x17, 0xf7, 0xa0);

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor, *LPDSFXCompressor;

typedef const DSFXCompressor *LPCDSFXCompressor;

#define DSFXCOMPRESSOR_GAIN_MIN             -60.0f
#define DSFXCOMPRESSOR_GAIN_MAX             60.0f
#define DSFXCOMPRESSOR_ATTACK_MIN           0.01f
#define DSFXCOMPRESSOR_ATTACK_MAX           500.0f
#define DSFXCOMPRESSOR_RELEASE_MIN          50.0f
#define DSFXCOMPRESSOR_RELEASE_MAX          3000.0f
#define DSFXCOMPRESSOR_THRESHOLD_MIN        -60.0f
#define DSFXCOMPRESSOR_THRESHOLD_MAX        0.0f
#define DSFXCOMPRESSOR_RATIO_MIN            1.0f
#define DSFXCOMPRESSOR_RATIO_MAX            100.0f
#define DSFXCOMPRESSOR_PREDELAY_MIN         0.0f
#define DSFXCOMPRESSOR_PREDELAY_MAX         4.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXCompressor

DECLARE_INTERFACE_(IDirectSoundFXCompressor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXCompressor methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXCompressor pDsFxCompressor) PURE;
};

#define IDirectSoundFXCompressor_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXCompressor_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXCompressor_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXParamEq
//

DEFINE_GUID(IID_IDirectSoundFXParamEq, 0xc03ca9fe, 0xfe90, 0x4204, 0x80, 0x78, 0x82, 0x33, 0x4c, 0xd1, 0x77, 0xda);

typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq, *LPDSFXParamEq;

typedef const DSFXParamEq *LPCDSFXParamEq;

#define DSFXPARAMEQ_CENTER_MIN      80.0f
#define DSFXPARAMEQ_CENTER_MAX      16000.0f
#define DSFXPARAMEQ_BANDWIDTH_MIN   1.0f
#define DSFXPARAMEQ_BANDWIDTH_MAX   36.0f
#define DSFXPARAMEQ_GAIN_MIN        -15.0f
#define DSFXPARAMEQ_GAIN_MAX        15.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXParamEq

DECLARE_INTERFACE_(IDirectSoundFXParamEq, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXParamEq methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXParamEq pDsFxParamEq) PURE;
};

#define IDirectSoundFXParamEq_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXParamEq_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXParamEq_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if 0
//
// IDirectSoundFXI3DL2Source
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Source, 0x4363ff5c, 0x0410, 0x4507, 0xb3, 0x21, 0xea, 0x09, 0xf8, 0xf4, 0x56, 0x99);

typedef struct _DSFXI3DL2Obstruction
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.0
} DSFXI3DL2Obstruction, *LPDSFXI3DL2Obstruction;

typedef const DSFXI3DL2Obstruction *LPCDSFXI3DL2Obstruction;

typedef struct _DSFXI3DL2Occlusion
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.25
} DSFXI3DL2Occlusion, *LPDSFXI3DL2Occlusion;

typedef const DSFXI3DL2Occlusion *LPCDSFXI3DL2Occlusion;

typedef struct _DSFXI3DL2Source
{
    LONG                    lDirect;                // [-10000, 1000] default: 0 mB
    LONG                    lDirectHF;              // [-10000, 0]    default: 0 mB
    LONG                    lRoom;                  // [-10000, 1000] default: 0 mB
    LONG                    lRoomHF;                // [-10000, 0]    default: 0 mB
    FLOAT                   flRoomRolloffFactor;    // [0.0, 10.0]    default: 0.0
    DSFXI3DL2Obstruction  Obstruction;
    DSFXI3DL2Occlusion    Occlusion;
    DWORD                   dwFlags;                // default: DSFX_I3DL2SOURCE_OCC_LPF
} DSFXI3DL2Source, *LPDSFXI3DL2Source;

typedef const DSFXI3DL2Source *LPCDSFXI3DL2Source;

#define DSFX_I3DL2SOURCE_DIRECT_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_DIRECT_MAX                     1000
#define DSFX_I3DL2SOURCE_DIRECT_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_DIRECTHF_MIN                   (-10000)
#define DSFX_I3DL2SOURCE_DIRECTHF_MAX                   0
#define DSFX_I3DL2SOURCE_DIRECTHF_DEFAULT               0
                                                        
#define DSFX_I3DL2SOURCE_ROOM_MIN                       (-10000)
#define DSFX_I3DL2SOURCE_ROOM_MAX                        1000
#define DSFX_I3DL2SOURCE_ROOM_DEFAULT                   0
                                                        
#define DSFX_I3DL2SOURCE_ROOMHF_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_ROOMHF_MAX                     0
#define DSFX_I3DL2SOURCE_ROOMHF_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MIN          0.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MAX          10.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_DEFAULT      0.0f
                                                        
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MIN        (-10000)
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MAX        0
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_DEFAULT    0

#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MIN        0.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MAX        1.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_DEFAULT    0.0f

#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MIN          (-10000)
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MAX          0
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_DEFAULT      0
                                                        
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MIN          0.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MAX          1.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_DEFAULT      0.25f

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Source

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Source, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Source methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Source pcDsFxI3DL2Source) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Source pDsFxI3DL2Source) PURE;
    STDMETHOD(SetObstructionPreset) (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetObstructionPreset) (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetOcclusionPreset)   (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetOcclusionPreset)   (THIS_ LPDWORD pdwPreset) PURE;
};

#define IDirectSoundFXI3DL2Source_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Source_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Source_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->lpVtbl->SetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->lpVtbl->GetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->lpVtbl->SetOcclusionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->lpVtbl->GetOcclusionPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->SetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->GetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->SetOcclusionPreset(a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->GetOcclusionPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
#endif // 0
//@@END_MSINTERNAL

//
// IDirectSoundFXI3DL2Reverb
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Reverb, 0x4b166a6a, 0x0d66, 0x43f3, 0x80, 0xe3, 0xee, 0x62, 0x80, 0xde, 0xe1, 0xa4);

typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb, *LPDSFXI3DL2Reverb;

typedef const DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;

#define DSFX_I3DL2REVERB_ROOM_MIN                   (-10000)
#define DSFX_I3DL2REVERB_ROOM_MAX                   0
#define DSFX_I3DL2REVERB_ROOM_DEFAULT               (-1000)
                                                    
#define DSFX_I3DL2REVERB_ROOMHF_MIN                 (-10000)
#define DSFX_I3DL2REVERB_ROOMHF_MAX                 0
#define DSFX_I3DL2REVERB_ROOMHF_DEFAULT             (-100)
                                                    
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN      0.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX      10.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT  0.0f

#define DSFX_I3DL2REVERB_DECAYTIME_MIN              0.1f
#define DSFX_I3DL2REVERB_DECAYTIME_MAX              20.0f
#define DSFX_I3DL2REVERB_DECAYTIME_DEFAULT          1.49f
                                                    
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MIN           0.1f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MAX           2.0f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT       0.83f
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONS_MIN            (-10000)
#define DSFX_I3DL2REVERB_REFLECTIONS_MAX            1000
#define DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT        (-2602)
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN       0.0f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX       0.3f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT   0.007f

#define DSFX_I3DL2REVERB_REVERB_MIN                 (-10000)
#define DSFX_I3DL2REVERB_REVERB_MAX                 2000
#define DSFX_I3DL2REVERB_REVERB_DEFAULT             (200)
                                                    
#define DSFX_I3DL2REVERB_REVERBDELAY_MIN            0.0f
#define DSFX_I3DL2REVERB_REVERBDELAY_MAX            0.1f
#define DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT        0.011f
                                                    
#define DSFX_I3DL2REVERB_DIFFUSION_MIN              0.0f
#define DSFX_I3DL2REVERB_DIFFUSION_MAX              100.0f
#define DSFX_I3DL2REVERB_DIFFUSION_DEFAULT          100.0f
                                                    
#define DSFX_I3DL2REVERB_DENSITY_MIN                0.0f
#define DSFX_I3DL2REVERB_DENSITY_MAX                100.0f
#define DSFX_I3DL2REVERB_DENSITY_DEFAULT            100.0f
                                                    
#define DSFX_I3DL2REVERB_HFREFERENCE_MIN            20.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_MAX            20000.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        5000.0f
                                                    
#define DSFX_I3DL2REVERB_QUALITY_MIN                0
#define DSFX_I3DL2REVERB_QUALITY_MAX                3
#define DSFX_I3DL2REVERB_QUALITY_DEFAULT            2

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Reverb

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Reverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Reverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ LONG *plQuality) PURE;
};

#define IDirectSoundFXI3DL2Reverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Reverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Reverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->lpVtbl->SetPreset(p,a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->lpVtbl->GetPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->SetPreset(a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->GetPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
//
// IDirectSoundFXI3DL2SourceEnv - A private interface used by the I3DL2 source DMO
// to receive various bits of information about the environment it's operating in.
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2SourceEnv, 0xf6c55470, 0x7706, 0x4ce1, 0xa3, 0x54, 0x74, 0xb2, 0xf0, 0x3, 0x25, 0xe2);

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2SourceEnv

DECLARE_INTERFACE_(IDirectSoundFXI3DL2SourceEnv, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2SourceEnv methods
    STDMETHOD(SetEnvironmentReverb) (THIS_ LPDIRECTSOUNDFXI3DL2REVERB8) PURE;
    STDMETHOD(SetDS3DBuffer)        (THIS_ LPDIRECTSOUND3DBUFFER) PURE;
    STDMETHOD(SetDS3DListener)      (THIS_ LPDIRECTSOUND3DLISTENER) PURE;
};

#define IDirectSoundFXI3DL2SourceEnv_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2SourceEnv_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2SourceEnv_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->lpVtbl->SetEnvironmentReverb(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->lpVtbl->SetDS3DBuffer(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->lpVtbl->SetDS3DListener(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->SetEnvironmentReverb(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->SetDS3DBuffer(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->SetDS3DListener(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBufferPrivate - provided by our 3D buffer object so that the
// I3DL2 source DMO can discover the current attenuation of its host buffer.
//

DEFINE_GUID(IID_IDirectSound3DBufferPrivate, 0x7d8ef383, 0xca05, 0x4593, 0x82, 0xa1, 0x44, 0x4e, 0x80, 0x08, 0x71, 0xe1);

#undef INTERFACE
#define INTERFACE IDirectSound3DBufferPrivate

DECLARE_INTERFACE_(IDirectSound3DBufferPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBufferPrivate methods
    STDMETHOD(GetAttenuation)       (THIS_ FLOAT*) PURE;
};

#define IDirectSound3DBufferPrivate_QueryInterface(p,a,b)   IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBufferPrivate_AddRef(p)               IUnknown_AddRef(p)
#define IDirectSound3DBufferPrivate_Release(p)              IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->lpVtbl->GetAttenuation(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->GetAttenuation(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXWavesReverb
//

DEFINE_GUID(IID_IDirectSoundFXWavesReverb,0x46858c3a,0x0dc6,0x45e3,0xb7,0x60,0xd4,0xee,0xf1,0x6c,0xb3,0x25);

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb, *LPDSFXWavesReverb;

typedef const DSFXWavesReverb *LPCDSFXWavesReverb;

#define DSFX_WAVESREVERB_INGAIN_MIN                 -96.0f
#define DSFX_WAVESREVERB_INGAIN_MAX                 0.0f
#define DSFX_WAVESREVERB_INGAIN_DEFAULT             0.0f
#define DSFX_WAVESREVERB_REVERBMIX_MIN              -96.0f
#define DSFX_WAVESREVERB_REVERBMIX_MAX              0.0f
#define DSFX_WAVESREVERB_REVERBMIX_DEFAULT          0.0f
#define DSFX_WAVESREVERB_REVERBTIME_MIN             0.001f
#define DSFX_WAVESREVERB_REVERBTIME_MAX             3000.0f
#define DSFX_WAVESREVERB_REVERBTIME_DEFAULT         1000.0f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN        0.001f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX        0.999f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT    0.001f

#undef INTERFACE
#define INTERFACE IDirectSoundFXWavesReverb

DECLARE_INTERFACE_(IDirectSoundFXWavesReverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXWavesReverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXWavesReverb pDsFxWavesReverb) PURE;
};

#define IDirectSoundFXWavesReverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXWavesReverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXWavesReverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXAec
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAec, 0xad74143d, 0x903d, 0x4ab7, 0x80, 0x66, 0x28, 0xd3, 0x63, 0x03, 0x6d, 0x65);

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fNoiseFill;
    DWORD   dwMode;
} DSCFXAec, *LPDSCFXAec;

typedef const DSCFXAec *LPCDSCFXAec;

// These match the AEC_MODE_* constants in the DDK's ksmedia.h file
#define DSCFX_AEC_MODE_PASS_THROUGH                     0x0
#define DSCFX_AEC_MODE_HALF_DUPLEX                      0x1
#define DSCFX_AEC_MODE_FULL_DUPLEX                      0x2

// These match the AEC_STATUS_* constants in ksmedia.h
#define DSCFX_AEC_STATUS_HISTORY_UNINITIALIZED          0x0
#define DSCFX_AEC_STATUS_HISTORY_CONTINUOUSLY_CONVERGED 0x1
#define DSCFX_AEC_STATUS_HISTORY_PREVIOUSLY_DIVERGED    0x2
#define DSCFX_AEC_STATUS_CURRENTLY_CONVERGED            0x8

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAec

DECLARE_INTERFACE_(IDirectSoundCaptureFXAec, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetStatus)            (THIS_ PDWORD pdwStatus) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXAec_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAec_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAec_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundCaptureFXNoiseSuppress
//

DEFINE_GUID(IID_IDirectSoundCaptureFXNoiseSuppress, 0xed311e41, 0xfbae, 0x4175, 0x96, 0x25, 0xcd, 0x8, 0x54, 0xf6, 0x93, 0xca);

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
} DSCFXNoiseSuppress, *LPDSCFXNoiseSuppress;

typedef const DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXNoiseSuppress

DECLARE_INTERFACE_(IDirectSoundCaptureFXNoiseSuppress, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXNoiseSuppress_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXNoiseSuppress_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXNoiseSuppress_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL

//
// IDirectSoundCaptureFXAgc
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAgc, 0xe54f76b8, 0xe48f, 0x427b, 0xb7, 0xf7, 0xaf, 0xb8, 0xc7, 0x13, 0xa1, 0x25);

typedef struct _DSCFXAgc
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXAgc, *LPDSCFXAgc;

typedef const DSCFXAgc *LPCDSCFXAgc;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAgc

DECLARE_INTERFACE_(IDirectSoundCaptureFXAgc, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAgc methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAgc pcDscFxAgc) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAgc pDscFxAgc) PURE;
};

#define IDirectSoundCaptureFXAgc_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAgc_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAgc_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXMicArray
//

DEFINE_GUID(IID_IDirectSoundCaptureFXMicArray, 0x9AAB5F95, 0xCAF6, 0x4e2a, 0x9D, 0x16, 0x24, 0x5E, 0xBF, 0xDC, 0xFB, 0xE9);

typedef struct _DSCFXMicArray
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXMicArray, *LPDSCFXMicArray;

typedef const DSCFXMicArray *LPCDSCFXMicArray;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXMicArray

DECLARE_INTERFACE_(IDirectSoundCaptureFXMicArray, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXMicArray methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXMicArray pcDscFxMicArray) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXMicArray pDscFxMicArray) PURE;
};

#define IDirectSoundCaptureFXMicArray_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXMicArray_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXMicArray_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundDMOProxy
//

DEFINE_GUID(IID_IDirectSoundDMOProxy,0xe782c03b,0x8187,0x4110,0xb6,0x53,0xd1,0x53,0xff,0x8f,0x42,0xc7);

#undef INTERFACE
#define INTERFACE IDirectSoundDMOProxy

DECLARE_INTERFACE_(IDirectSoundDMOProxy, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundDMOProxy methods
    STDMETHOD(AcquireResources)     (THIS_ IKsPropertySet *pKsPropertySet) PURE;
    STDMETHOD(ReleaseResources)     (THIS) PURE;
    STDMETHOD(InitializeNode)       (THIS_ HANDLE hPin, ULONG ulNodeId) PURE;
};

#define IDirectSoundDMOProxy_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundDMOProxy_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundDMOProxy_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->lpVtbl->AcquireResources(p,a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->lpVtbl->ReleaseResources(p)
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->lpVtbl->InitializeNode(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->AcquireResources(a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->ReleaseResources()
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->InitializeNode(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@END_MSINTERNAL

//
// IDirectSoundFullDuplex
//

#ifndef _IDirectSoundFullDuplex_
#define _IDirectSoundFullDuplex_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSoundFullDuplex;
#endif // __cplusplus

typedef struct IDirectSoundFullDuplex *LPDIRECTSOUNDFULLDUPLEX;

DEFINE_GUID(IID_IDirectSoundFullDuplex, 0xedcb4c7a, 0xdaab, 0x4216, 0xa4, 0x2e, 0x6c, 0x50, 0x59, 0x6d, 0xdc, 0x1d);

#undef INTERFACE
#define INTERFACE IDirectSoundFullDuplex

DECLARE_INTERFACE_(IDirectSoundFullDuplex, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IDirectSoundFullDuplex methods 
    STDMETHOD(Initialize)     (THIS_ LPCGUID pCaptureGuid, LPCGUID pRenderGuid, LPCDSCBUFFERDESC lpDscBufferDesc, LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
};

#define IDirectSoundFullDuplex_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFullDuplex_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundFullDuplex_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->lpVtbl->Initialize(p,a,b,c,d,e,f,g,h)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->Initialize(a,b,c,d,e,f,g,h)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IDirectSoundFullDuplex_

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK
//@@BEGIN_MSINTERNAL
#define DS_OK_EXPLANATION TEXT("The function completed successfully")
//@@END_MSINTERNAL

// The call succeeded, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)
//@@BEGIN_MSINTERNAL
#define DS_NO_VIRTUALIZATION_EXPLANATION TEXT("The function succeeded, substituting the Pan3D algorithm")
//@@END_MSINTERNAL

// The call succeeded, but not all of the optional effects were obtained.
#define DS_INCOMPLETE                   MAKE_HRESULT(0, _FACDS, 20)
//@@BEGIN_MSINTERNAL
#define DS_INCOMPLETE_EXPLANATION TEXT("The function succeeded, but not all of the optional effects requested could be obtained")
//@@END_MSINTERNAL

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)
//@@BEGIN_MSINTERNAL
#define DSERR_ALLOCATED_EXPLANATION TEXT("The call failed because resources (such as a priority level) were already being used by another caller")
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
// An attempt was made to lock the area between the play and write cursors
#define DSERR_CANTLOCKPLAYCURSOR        MAKE_DSHRESULT(20)
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
#define DSERR_CANTLOCKPLAYCURSOR_EXPLANATION TEXT("An attempt was made to lock the area between the play and write cursors")
//@@END_MSINTERNAL

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)
//@@BEGIN_MSINTERNAL
#define DSERR_CONTROLUNAVAIL_EXPLANATION TEXT("The control (vol, pan, etc.) requested by the caller is not available")
//@@END_MSINTERNAL

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDPARAM_EXPLANATION TEXT("An invalid parameter was passed to the returning function")
//@@END_MSINTERNAL

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDCALL_EXPLANATION TEXT("This call is not valid for the current state of this object")
//@@END_MSINTERNAL

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL
//@@BEGIN_MSINTERNAL
#define DSERR_GENERIC_EXPLANATION TEXT("An undetermined error occurred inside the DirectSound subsystem")
//@@END_MSINTERNAL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)
//@@BEGIN_MSINTERNAL
#define DSERR_PRIOLEVELNEEDED_EXPLANATION TEXT("The caller does not have the priority level required for the function to succeed")
//@@END_MSINTERNAL

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY
//@@BEGIN_MSINTERNAL
#define DSERR_OUTOFMEMORY_EXPLANATION TEXT("Not enough free memory is available to complete the operation")
//@@END_MSINTERNAL

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)
//@@BEGIN_MSINTERNAL
#define DSERR_BADFORMAT_EXPLANATION TEXT("The specified WAVE format is not supported")
//@@END_MSINTERNAL

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL
//@@BEGIN_MSINTERNAL
#define DSERR_UNSUPPORTED_EXPLANATION TEXT("The function called is not supported at this time")
//@@END_MSINTERNAL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)
//@@BEGIN_MSINTERNAL
#define DSERR_NODRIVER_EXPLANATION TEXT("No sound device is available for use, or the given device ID isn't valid")
//@@END_MSINTERNAL

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)
//@@BEGIN_MSINTERNAL
#define DSERR_ALREADYINITIALIZED_EXPLANATION TEXT("This object is already initialized")
//@@END_MSINTERNAL

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION
//@@BEGIN_MSINTERNAL
#define DSERR_NOAGGREGATION_EXPLANATION TEXT("This object does not support aggregation")
//@@END_MSINTERNAL

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERLOST_EXPLANATION TEXT("The buffer memory has been lost, and must be restored")
//@@END_MSINTERNAL

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)
//@@BEGIN_MSINTERNAL
#define DSERR_OTHERAPPHASPRIO_EXPLANATION TEXT("Another app has a higher priority level, preventing this call from succeeding")
//@@END_MSINTERNAL

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)
//@@BEGIN_MSINTERNAL
#define DSERR_UNINITIALIZED_EXPLANATION TEXT("This object has not been initialized")
//@@END_MSINTERNAL

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE
//@@BEGIN_MSINTERNAL
#define DSERR_NOINTERFACE_EXPLANATION TEXT("The requested COM interface is not available")
//@@END_MSINTERNAL

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED
//@@BEGIN_MSINTERNAL
#define DSERR_ACCESSDENIED_EXPLANATION TEXT("Access is denied")
//@@END_MSINTERNAL

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            MAKE_DSHRESULT(180)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERTOOSMALL_EXPLANATION TEXT("Tried to create a CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds")
//@@END_MSINTERNAL

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              MAKE_DSHRESULT(190)
//@@BEGIN_MSINTERNAL
#define DSERR_DS8_REQUIRED_EXPLANATION TEXT("Attempt to use DirectSound 8 functionality on an older DirectSound object")
//@@END_MSINTERNAL

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  MAKE_DSHRESULT(200)
//@@BEGIN_MSINTERNAL
#define DSERR_SENDLOOP_EXPLANATION TEXT("A circular loop of send effects was detected")
//@@END_MSINTERNAL

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         MAKE_DSHRESULT(210)
//@@BEGIN_MSINTERNAL
#define DSERR_BADSENDBUFFERGUID_EXPLANATION TEXT("The GUID specified does not match a valid MIXIN buffer")
//@@END_MSINTERNAL

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            MAKE_DSHRESULT(4449)
//@@BEGIN_MSINTERNAL
// Can't just be #defined to DMUS_E_NOTFOUND because we don't include the header
#define DSERR_OBJECTNOTFOUND_EXPLANATION TEXT("The object was not found")
//@@END_MSINTERNAL

// The effects requested could not be found on the system, or they were found
// but in the wrong order, or in the wrong hardware/software locations.
#define DSERR_FXUNAVAILABLE             MAKE_DSHRESULT(220)
//@@BEGIN_MSINTERNAL
#define DSERR_FXUNAVAILABLE_EXPLANATION TEXT("The effects could not be found in the order and location requested")
//@@END_MSINTERNAL

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800
//@@BEGIN_MSINTERNAL
#define DSCAPS_PRIMARYFLAGS         (DSCAPS_PRIMARYMONO | DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY8BIT | DSCAPS_PRIMARY16BIT)
#define DSCAPS_SECONDARYFLAGS       (DSCAPS_SECONDARYMONO | DSCAPS_SECONDARYSTEREO | DSCAPS_SECONDARY8BIT | DSCAPS_SECONDARY16BIT)
#define DSCAPS_VALIDDRIVERFLAGS     (DSCAPS_PRIMARYFLAGS | DSCAPS_SECONDARYFLAGS | DSCAPS_CONTINUOUSRATE)
#define DSCAPS_VALIDFLAGS           (DSCAPS_VALIDDRIVERFLAGS | DSCAPS_EMULDRIVER | DSCAPS_CERTIFIED)
#define DSCAPS_FILENAMECOOKIE       179  // Must be less than 256.
#define DSCAPS_FILENAMEMODVALUE     247  // Must be less that 256.
//@@END_MSINTERNAL

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004
//@@BEGIN_MSINTERNAL
#define DSSCL_NONE                  0x00000000
#define DSSCL_FIRST                 DSSCL_NORMAL
#define DSSCL_LAST                  DSSCL_WRITEPRIMARY
//@@END_MSINTERNAL

#define DSSPEAKER_DIRECTOUT         0x00000000
#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006
#define DSSPEAKER_7POINT1           0x00000007
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_FIRST             DSSPEAKER_DIRECTOUT
#define DSSPEAKER_LAST              DSSPEAKER_7POINT1
#define DSSPEAKER_DEFAULT           DSSPEAKER_STEREO
//@@END_MSINTERNAL

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_CONFIG_MASK       0x000000FF
#define DSSPEAKER_GEOMETRY_MASK     0x00FF0000
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#ifndef _SPEAKER_POSITIONS_

// Speaker positions for SetChannelVolume()
#define _SPEAKER_POSITIONS_
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Not used in the DirectSound API
#define SPEAKER_ALL                     0x80000000

#endif // _SPEAKER_POSITIONS_
#endif // FUTURE_MULTIPAN_SUPPORT
//@@END_MSINTERNAL

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLFX              0x00000200
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#define DSBCAPS_CTRLCHANNELVOLUME   0x00000400
#endif
#define DSBCAPS_MIXIN               0x00002000
//@@END_MSINTERNAL
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000
//@@BEGIN_MSINTERNAL
#define DSBCAPS_SINKIN              0x00001000  // Means buffer will receive data from a DirectSound sink
#ifdef FUTURE_WAVE_SUPPORT
#define DSBCAPS_FROMWAVEOBJECT      0x00080000  // Means buffer was created with CreateSoundBufferFromWave()
#endif
#define DSBCAPS_DSBUFFERDESC1MASK   0x0003C1FF  // Flags valid for pre-DX7 applications
#define DSBCAPS_DSBUFFERDESC7MASK   (DSBCAPS_DSBUFFERDESC1MASK | DSBCAPS_LOCDEFER)  // Flags valid for DX7 apps
#define DSBCAPS_VALIDFLAGS          (DSBCAPS_DSBUFFERDESC7MASK | DSBCAPS_CTRLFX | DSBCAPS_MIXIN)  //...DX8 apps
#define DSBCAPS_CTRLATTENUATION     (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN)
#define DSBCAPS_CTRLNOVIRT          (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY)
#define DSBCAPS_LOCMASK             (DSBCAPS_LOCHARDWARE | DSBCAPS_LOCSOFTWARE)  // All valid location flags
#define DSBCAPS_FOCUSMASK           (DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS)  // All valid focus flags
#define DSBCAPS_DRIVERFLAGSMASK     (DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLATTENUATION | \
                                     DSBCAPS_CTRL3D | DSBCAPS_CTRLFREQUENCY)  // Flags of interest to a VxD driver
#define DSBCAPS_STREAMINGVALIDFLAGS (DSBCAPS_LOCMASK | DSBCAPS_FOCUSMASK | DSBCAPS_MIXIN | \
                                     DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | \
                                     DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE )
#define DSBCAPS_CHANVOLVALIDFLAGS   (DSBCAPS_VALIDFLAGS & ~(DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPAN | \
                                                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE))
#define DSBCAPS_FROMWAVEVALIDFLAGS  (DSBCAPS_LOCMASK | DSBCAPS_LOCDEFER | DSBCAPS_FOCUSMASK | DSBCAPS_CTRLPAN | \
                                     DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | DSBCAPS_CTRLFREQUENCY)
//@@END_MSINTERNAL

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020
//@@BEGIN_MSINTERNAL
#define DSBPLAY_LOCMASK             (DSBPLAY_LOCHARDWARE | DSBPLAY_LOCSOFTWARE)  // All valid location flags
#define DSBPLAY_TERMINATEBY_MASK    (DSBPLAY_TERMINATEBY_TIME | DSBPLAY_TERMINATEBY_DISTANCE | DSBPLAY_TERMINATEBY_PRIORITY)
#define DSBPLAY_LOCDEFERMASK        (DSBPLAY_LOCMASK | DSBPLAY_TERMINATEBY_MASK)
#define DSBPLAY_VALIDFLAGS          (DSBPLAY_LOCDEFERMASK | DSBPLAY_LOOPING)
//@@END_MSINTERNAL

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020
//@@BEGIN_MSINTERNAL
#define DSBSTATUS_ACTIVE            0x00000040
#define DSBSTATUS_RESOURCESACQUIRED 0x00000080
#define DSBSTATUS_STOPPEDBYFOCUS    0x00000100
#define DSBSTATUS_LOCMASK           (DSBSTATUS_LOCHARDWARE | DSBSTATUS_LOCSOFTWARE)
#define DSBSTATUS_LOCDEFERMASK      (DSBSTATUS_LOCMASK | DSBSTATUS_TERMINATED)
#define DSBSTATUS_USERMASK          (DSBSTATUS_LOCDEFERMASK | DSBSTATUS_PLAYING | DSBSTATUS_BUFFERLOST | DSBSTATUS_LOOPING)
//@@END_MSINTERNAL

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002
//@@BEGIN_MSINTERNAL
#define DSBLOCK_VALIDFLAGS          (DSBLOCK_FROMWRITECURSOR | DSBLOCK_ENTIREBUFFER)
//@@END_MSINTERNAL

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
#define DSBSIZE_FX_MIN              150  // NOTE: Milliseconds, not bytes

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002
//@@BEGIN_MSINTERNAL
#define DS3DMODE_FIRST              DS3DMODE_NORMAL
#define DS3DMODE_LAST               DS3DMODE_DISABLE
//@@END_MSINTERNAL

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001
//@@BEGIN_MSINTERNAL
#define DS3D_VALIDFLAGS             0x00000001
//@@END_MSINTERNAL

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

// IDirectSoundCapture attributes

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCCAPS_MULTIPLECAPTURE     0x00000001
#endif
//@@END_MSINTERNAL

// IDirectSoundCaptureBuffer attributes

#define DSCBCAPS_WAVEMAPPED         0x80000000

#if DIRECTSOUND_VERSION >= 0x0800
#define DSCBCAPS_CTRLFX             0x00000200
#endif

//@@BEGIN_MSINTERNAL
#define DSCBCAPS_LOCHARDWARE        0x00000004
#define DSCBCAPS_LOCSOFTWARE        0x00000008

#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBCAPS_CTRLVOLUME         0x10000000
#define DSCBCAPS_FOCUSAWARE         0x20000000
#define DSCBCAPS_STRICTFOCUS        0x40000000
#endif

#define DSCBCAPS_VALIDFLAGS         (DSCBCAPS_WAVEMAPPED | DSCBCAPS_STRICTFOCUS | DSCBCAPS_FOCUSAWARE | DSCBCAPS_CTRLVOLUME | DSCBCAPS_CTRLFX)
//@@END_MSINTERNAL

#define DSCBLOCK_ENTIREBUFFER       0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBLOCK_VALIDFLAGS         0x00000001
//@@END_MSINTERNAL

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBSTATUS_INFOCUS          0x00000004
#define DSCBSTATUS_LOSTFOCUS        0x00000008
#endif
#define DSCBSTATUS_STOPPING         0x80000000
#define DSCBSTATUS_STOPPED          0x40000000

#define DSCBSTATUS_USERMASK         0x0000FFFF
//@@END_MSINTERNAL

#define DSCBSTART_LOOPING           0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBSTART_VALIDFLAGS        DSCBSTART_LOOPING
//@@END_MSINTERNAL

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#define DS_CERTIFIED                0x00000000
#define DS_UNCERTIFIED              0x00000001

//@@BEGIN_MSINTERNAL

// Dsound system resource constants: these match the
// KSAUDIO_CPU_RESOURCES_xxx_HOST_CPU values in ksmedia.h
#define DS_SYSTEM_RESOURCES_NO_HOST_RESOURCES  0x00000000
#define DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES 0x7FFFFFFF
#define DS_SYSTEM_RESOURCES_UNDEFINED          0x80000000

#if 0
//
// Flags for the I3DL2 reverberation effect
//

enum
{
    DSFX_I3DL2SOURCE_OCC_LPF,
    DSFX_I3DL2SOURCE_OCC_VOLUME
};
#endif
//@@END_MSINTERNAL

//
// I3DL2 Material Presets
//

enum
{
    DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_THINDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_WOODWALL,
    DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL,
    DSFX_I3DL2_MATERIAL_PRESET_STONEWALL,
    DSFX_I3DL2_MATERIAL_PRESET_CURTAIN
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_MATERIAL_PRESET_MAX
//@@END_MSINTERNAL
};

#define I3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800,0.71f
#define I3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000,0.40f
#define I3DL2_MATERIAL_PRESET_THINDOOR        -1800,0.66f
#define I3DL2_MATERIAL_PRESET_THICKDOOR       -4400,0.64f
#define I3DL2_MATERIAL_PRESET_WOODWALL        -4000,0.50f
#define I3DL2_MATERIAL_PRESET_BRICKWALL       -5000,0.60f
#define I3DL2_MATERIAL_PRESET_STONEWALL       -6000,0.68f
#define I3DL2_MATERIAL_PRESET_CURTAIN         -1200,0.15f


enum
{
    DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CITY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS,
    DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_ENVIRONMENT_PRESET_MAX
//@@END_MSINTERNAL
};

//
// I3DL2 Reverberation Presets Values
//

#define I3DL2_ENVIRONMENT_PRESET_DEFAULT         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_GENERIC         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PADDEDCELL      -1000,-6000, 0.0f, 0.17f, 0.10f, -1204, 0.001f,   207, 0.002f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ROOM            -1000, -454, 0.0f, 0.40f, 0.83f, -1646, 0.002f,    53, 0.003f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_BATHROOM        -1000,-1200, 0.0f, 1.49f, 0.54f,  -370, 0.007f,  1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LIVINGROOM      -1000,-6000, 0.0f, 0.50f, 0.10f, -1376, 0.003f, -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONEROOM       -1000, -300, 0.0f, 2.31f, 0.64f,  -711, 0.012f,    83, 0.017f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_AUDITORIUM      -1000, -476, 0.0f, 4.32f, 0.59f,  -789, 0.020f,  -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CONCERTHALL     -1000, -500, 0.0f, 3.92f, 0.70f, -1230, 0.020f,    -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CAVE            -1000,    0, 0.0f, 2.91f, 1.30f,  -602, 0.015f,  -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ARENA           -1000, -698, 0.0f, 7.24f, 0.33f, -1166, 0.020f,    16, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HANGAR          -1000,-1000, 0.0f,10.05f, 0.23f,  -602, 0.020f,   198, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY -1000,-4000, 0.0f, 0.30f, 0.10f, -1831, 0.002f, -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HALLWAY         -1000, -300, 0.0f, 1.49f, 0.59f, -1219, 0.007f,   441, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR   -1000, -237, 0.0f, 2.70f, 0.79f, -1214, 0.013f,   395, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ALLEY           -1000, -270, 0.0f, 1.49f, 0.86f, -1204, 0.007f,    -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_FOREST          -1000,-3300, 0.0f, 1.49f, 0.54f, -2560, 0.162f,  -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CITY            -1000, -800, 0.0f, 1.49f, 0.67f, -2273, 0.007f, -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MOUNTAINS       -1000,-2500, 0.0f, 1.49f, 0.21f, -2780, 0.300f, -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_QUARRY          -1000,-1000, 0.0f, 1.49f, 0.83f,-10000, 0.061f,   500, 0.025f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLAIN           -1000,-2000, 0.0f, 1.49f, 0.50f, -2466, 0.179f, -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PARKINGLOT      -1000,    0, 0.0f, 1.65f, 1.50f, -1363, 0.008f, -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_SEWERPIPE       -1000,-1000, 0.0f, 2.81f, 0.14f,   429, 0.014f,   648, 0.021f,  80.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_UNDERWATER      -1000,-4000, 0.0f, 1.49f, 0.10f,  -449, 0.007f,  1700, 0.011f, 100.0f, 100.0f, 5000.0f

//
// Examples simulating 'musical' reverb presets
//
// Name       Decay time   Description
// Small Room    1.1s      A small size room with a length of 5m or so.
// Medium Room   1.3s      A medium size room with a length of 10m or so.
// Large Room    1.5s      A large size room suitable for live performances.
// Medium Hall   1.8s      A medium size concert hall.
// Large Hall    1.8s      A large size concert hall suitable for a full orchestra.
// Plate         1.3s      A plate reverb simulation.
//

#define I3DL2_ENVIRONMENT_PRESET_SMALLROOM       -1000, -600, 0.0f, 1.10f, 0.83f,  -400, 0.005f,   500, 0.010f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM      -1000, -600, 0.0f, 1.30f, 0.83f, -1000, 0.010f,  -200, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEROOM       -1000, -600, 0.0f, 1.50f, 0.83f, -1600, 0.020f, -1000, 0.040f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL      -1000, -600, 0.0f, 1.80f, 0.70f, -1300, 0.015f,  -800, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEHALL       -1000, -600, 0.0f, 1.80f, 0.70f, -2000, 0.030f, -1400, 0.060f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLATE           -1000, -200, 0.0f, 1.30f, 0.90f,     0, 0.002f,     0, 0.010f, 100.0f,  75.0f, 5000.0f

//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization (Pan3D) {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

//@@BEGIN_MSINTERNAL
// Original DirectSound3D ITD algorithm {1B5C9566-5E20-11d2-91BD-00C04FC28ACA}
DEFINE_GUID(DS3DALG_ITD, 0x1b5c9566, 0x5e20, 0x11d2, 0x91, 0xbd, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// DirectSound Internal Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Buffer Send {EF602176-BCBB-49E0-8CCA-E09A5A152B33}
DEFINE_GUID(GUID_DSFX_SEND, 0xef602176, 0xbcbb, 0x49e0, 0x8c, 0xca, 0xe0, 0x9a, 0x5a, 0x15, 0x2b, 0x33);
//@@END_MSINTERNAL

// Gargle {DAFD8210-5711-4B91-9FE3-F75B7AE279BF}
DEFINE_GUID(GUID_DSFX_STANDARD_GARGLE, 0xdafd8210, 0x5711, 0x4b91, 0x9f, 0xe3, 0xf7, 0x5b, 0x7a, 0xe2, 0x79, 0xbf);

// Chorus {EFE6629C-81F7-4281-BD91-C9D604A95AF6}
DEFINE_GUID(GUID_DSFX_STANDARD_CHORUS, 0xefe6629c, 0x81f7, 0x4281, 0xbd, 0x91, 0xc9, 0xd6, 0x04, 0xa9, 0x5a, 0xf6);

// Flanger {EFCA3D92-DFD8-4672-A603-7420894BAD98}
DEFINE_GUID(GUID_DSFX_STANDARD_FLANGER, 0xefca3d92, 0xdfd8, 0x4672, 0xa6, 0x03, 0x74, 0x20, 0x89, 0x4b, 0xad, 0x98);

// Echo/Delay {EF3E932C-D40B-4F51-8CCF-3F98F1B29D5D}
DEFINE_GUID(GUID_DSFX_STANDARD_ECHO, 0xef3e932c, 0xd40b, 0x4f51, 0x8c, 0xcf, 0x3f, 0x98, 0xf1, 0xb2, 0x9d, 0x5d);

// Distortion {EF114C90-CD1D-484E-96E5-09CFAF912A21}
DEFINE_GUID(GUID_DSFX_STANDARD_DISTORTION, 0xef114c90, 0xcd1d, 0x484e, 0x96, 0xe5, 0x09, 0xcf, 0xaf, 0x91, 0x2a, 0x21);

// Compressor/Limiter {EF011F79-4000-406D-87AF-BFFB3FC39D57}
DEFINE_GUID(GUID_DSFX_STANDARD_COMPRESSOR, 0xef011f79, 0x4000, 0x406d, 0x87, 0xaf, 0xbf, 0xfb, 0x3f, 0xc3, 0x9d, 0x57);

// Parametric Equalization {120CED89-3BF4-4173-A132-3CB406CF3231}
DEFINE_GUID(GUID_DSFX_STANDARD_PARAMEQ, 0x120ced89, 0x3bf4, 0x4173, 0xa1, 0x32, 0x3c, 0xb4, 0x06, 0xcf, 0x32, 0x31);

//@@BEGIN_MSINTERNAL
// I3DL2 Environmental Reverberation: Source Effect {EFBA364A-E606-451C-8E97-07D508119C65}
///DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2SOURCE, 0xefba364a, 0xe606, 0x451c, 0x8e, 0x97, 0x07, 0xd5, 0x08, 0x11, 0x9c, 0x65);
//@@END_MSINTERNAL

// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);

//
// DirectSound Capture Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Microphone Array Processor {830A44f2-A32D-476B-BE97-42845673B35A}
// Matches KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_MA, 0x830A44F2, 0xA32D, 0x476B,  0xBE, 0x97, 0x42, 0x84, 0x56, 0x73, 0xB3, 0x5A);

// Microsoft Microphone Array Processor {F4A49496-1481-44d7-9C4E-A0269CAF0597}
DEFINE_GUID(GUID_DSCFX_MS_MA, 0xF4A49496, 0x1481, 0x44d7, 0x9C, 0x4E, 0xA0, 0x26, 0x9C, 0xAF, 0x5, 0x97);

// System Microphone Array Processor {B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F}
DEFINE_GUID(GUID_DSCFX_SYSTEM_MA, 0xB6F5A0A0, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F );

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft Automatic Gain Control {5A86531E-8E2A-419f-B4CC-18EB8E891796}
DEFINE_GUID(GUID_DSCFX_MS_AGC, 0x5a86531e, 0x8e2a, 0x419f, 0xb4, 0xcc, 0x18, 0xeb, 0x8e, 0x89, 0x17, 0x96);

// System Automatic Gain Control {950E55B9-877C-4c67-BE08-E47B5611130A}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AGC, 0x950e55b9, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa);
//@@END_MSINTERNAL

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AEC, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft AEC {CDEBB919-379A-488a-8765-F53CFD36DE40}
DEFINE_GUID(GUID_DSCFX_MS_AEC, 0xcdebb919, 0x379a, 0x488a, 0x87, 0x65, 0xf5, 0x3c, 0xfd, 0x36, 0xde, 0x40);

// System AEC {1C22C56D-9879-4f5b-A389-27996DDC2810}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AEC, 0x1c22c56d, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_NS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Microsoft Noise Suppresion {11C5C73B-66E9-4ba1-A0BA-E814C6EED92D}
DEFINE_GUID(GUID_DSCFX_MS_NS, 0x11c5c73b, 0x66e9, 0x4ba1, 0xa0, 0xba, 0xe8, 0x14, 0xc6, 0xee, 0xd9, 0x2d);

// System Noise Suppresion {5AB0882E-7274-4516-877D-4EEE99BA4FD0}
DEFINE_GUID(GUID_DSCFX_SYSTEM_NS, 0x5ab0882e, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0);

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUND_INCLUDED__


//@@BEGIN_MSINTERNAL

#ifndef __DSOUNDP_INCLUDED__
#define __DSOUNDP_INCLUDED__

#if DIRECTSOUND_VERSION >= 0x0800

//
// Private DirectSound interfaces used by DMusic, DPlayVoice, etc.
// Eventually much of the MSINTERNAL stuff above should migrate here.
//

#ifdef __cplusplus
struct IDirectSoundPrivate;
struct IDirectSoundSynthSink;
struct IDirectSoundConnect;
struct IDirectSoundSinkSync;
struct IDirectSoundSource;
struct IDirectSoundWave;
#endif // __cplusplus

#define IDirectSoundPrivate8          IDirectSoundPrivate
#define IDirectSoundSynthSink8        IDirectSoundSynthSink
#define IDirectSoundConnect8          IDirectSoundConnect
#define IDirectSoundSinkSync8         IDirectSoundSinkSync
#define IDirectSoundSource8           IDirectSoundSource
#define IDirectSoundWave8             IDirectSoundWave

#define IID_IDirectSoundPrivate8      IID_IDirectSoundPrivate
#define IID_IDirectSoundSynthSink8    IID_IDirectSoundSynthSink
#define IID_IDirectSoundConnect8      IID_IDirectSoundConnect
#define IID_IDirectSoundSinkSync8     IID_IDirectSoundSinkSync
#define IID_IDirectSoundSource8       IID_IDirectSoundSource
#define IID_IDirectSoundWave8         IID_IDirectSoundWave

typedef struct IDirectSoundPrivate    *LPDIRECTSOUNDPRIVATE;
typedef struct IDirectSoundSynthSink  *LPDIRECTSOUNDSYNTHSINK;
typedef struct IDirectSoundConnect    *LPDIRECTSOUNDCONNECT;
typedef struct IDirectSoundSinkSync   *LPDIRECTSOUNDSINKSYNC;
typedef struct IDirectSoundSource     *LPDIRECTSOUNDSOURCE;
typedef struct IDirectSoundWave       *LPDIRECTSOUNDWAVE;

typedef struct IDirectSoundPrivate8   *LPDIRECTSOUNDPRIVATE8;
typedef struct IDirectSoundSynthSink8 *LPDIRECTSOUNDSYNTHSINK8;
typedef struct IDirectSoundConnect8   *LPDIRECTSOUNDCONNECT8;
typedef struct IDirectSoundSinkSync8  *LPDIRECTSOUNDSINKSYNC8;
typedef struct IDirectSoundSource8    *LPDIRECTSOUNDSOURCE8;
typedef struct IDirectSoundWave8      *LPDIRECTSOUNDWAVE8;

//
// IDirectSoundPrivate: used by DirectMusic to create DirectSoundSink objects
//

DEFINE_GUID(IID_IDirectSoundPrivate, 0xd6e525ae, 0xb125, 0x4ec4, 0xbe, 0x13, 0x12, 0x6d, 0x0c, 0xf7, 0xaf, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundPrivate

DECLARE_INTERFACE_(IDirectSoundPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundPrivate methods
    STDMETHOD(AllocSink)            (THIS_ LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) PURE;
};

#define IDirectSoundPrivate_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSoundPrivate_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSoundPrivate_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->lpVtbl->AllocSink(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->AllocSink(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSynthSink: used by the DirectMusic synthesiser
//

DEFINE_GUID(IID_IDirectSoundSynthSink, 0x73a6a85a, 0x493e, 0x4c87, 0xb4, 0xa5, 0xbe, 0x53, 0xeb, 0x92, 0x74, 0x4b);

#undef INTERFACE
#define INTERFACE IDirectSoundSynthSink

DECLARE_INTERFACE_(IDirectSoundSynthSink, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSynthSink methods
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime, REFERENCE_TIME *prtTime) PURE;
    STDMETHOD(RefToSampleTime)      (THIS_ REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
};

#define IDirectSoundSynthSink_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSynthSink_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundSynthSink_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->lpVtbl->GetLatencyClock(p,a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->lpVtbl->Activate(p,a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->lpVtbl->SampleToRefTime(p,a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->lpVtbl->RefToSampleTime(p,a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->lpVtbl->GetFormat(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->GetLatencyClock(a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->Activate(a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->SampleToRefTime(a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->RefToSampleTime(a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->GetFormat(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundConnect: used by DirectMusic to implement
// audio paths and connect the synthesiser to the sink
//

DEFINE_GUID(IID_IDirectSoundConnect, 0x5bee1fe0, 0x60d5, 0x4ef9, 0x88, 0xbc, 0x33, 0x67, 0xb9, 0x75, 0xc6, 0x11);

#undef INTERFACE
#define INTERFACE IDirectSoundConnect

DECLARE_INTERFACE_(IDirectSoundConnect, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundConnect methods
    STDMETHOD(AddSource)            (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(RemoveSource)         (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(CreateSoundBufferFromConfig) (THIS_ LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetSoundBuffer)       (THIS_ DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetBusCount)          (THIS_ LPDWORD pdwCount) PURE;
    STDMETHOD(GetBusIDs)            (THIS_ LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount) PURE;
    STDMETHOD(GetFunctionalID)      (THIS_ DWORD dwBusID, LPDWORD pdwFuncID) PURE;
    STDMETHOD(GetSoundBufferBusIDs) (THIS_ LPDIRECTSOUNDBUFFER pDSBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount) PURE;
};

#define IDirectSoundConnect_QueryInterface(p,a,b)               IUnknown_QueryInterface(p,a,b)
#define IDirectSoundConnect_AddRef(p)                           IUnknown_AddRef(p)
#define IDirectSoundConnect_Release(p)                          IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->lpVtbl->AddSource(p,a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->lpVtbl->RemoveSource(p,a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->lpVtbl->SetMasterClock(p,a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->lpVtbl->CreateSoundBuffer(p,a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->lpVtbl->CreateSoundBufferFromConfig(p,a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->lpVtbl->GetSoundBuffer(p,a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->lpVtbl->GetBusCount(p,a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->lpVtbl->GetBusIDs(p,a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->lpVtbl->GetFunctionalID(p,a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->lpVtbl->GetSoundBufferBusIDs(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->AddSource(a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->RemoveSource(a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->SetMasterClock(a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->CreateSoundBuffer(a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->CreateSoundBufferFromConfig(a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->GetSoundBuffer(a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->GetBusCount(a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->GetBusIDs(a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->GetFunctionalID(a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->GetSoundBufferBusIDs(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSinkSync: provided by the DirectMusic master clock
// to allow DirectSound to synchronize with it
//

DEFINE_GUID(IID_IDirectSoundSinkSync, 0xd28de0d0, 0x2794, 0x492f, 0xa3, 0xff, 0xe2, 0x41, 0x80, 0xd5, 0x43, 0x79);

#undef INTERFACE
#define INTERFACE IDirectSoundSinkSync

DECLARE_INTERFACE_(IDirectSoundSinkSync, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSinkSync methods
    STDMETHOD(SetClockOffset)       (THIS_ LONGLONG llOffset) PURE;
};

#define IDirectSoundSinkSync_QueryInterface(p,a,b)  IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSinkSync_AddRef(p)              IUnknown_AddRef(p)
#define IDirectSoundSinkSync_Release(p)             IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->lpVtbl->SetClockOffset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->SetClockOffset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSource (currently private)
//

DEFINE_GUID(IID_IDirectSoundSource, 0x536f7af3, 0xdb03, 0x4888, 0x93, 0x66, 0x54, 0x48, 0xb1, 0x1d, 0x4a, 0x19);

#undef INTERFACE
#define INTERFACE IDirectSoundSource

DECLARE_INTERFACE_(IDirectSoundSource, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSource methods
    STDMETHOD(SetSink)              (THIS_ LPDIRECTSOUNDCONNECT pSinkConnect) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(Seek)                 (THIS_ ULONGLONG ullPosition) PURE;
    STDMETHOD(Read)                 (THIS_ LPVOID *ppvBusBuffers, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchAdjust, DWORD dwBufferCount, ULONGLONG *ullLength) PURE;
    STDMETHOD(GetSize)              (THIS_ ULONGLONG *pullStreamSize) PURE;
};

#define IDirectSoundSource_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSource_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundSource_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->lpVtbl->SetSink(p,a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->lpVtbl->Seek(p,a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->lpVtbl->Read(p,a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->lpVtbl->GetSize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->SetSink(a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->GetFormat(a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->Seek(a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->Read(a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->GetSize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundWave (currently private)
//

DEFINE_GUID(IID_IDirectSoundWave, 0x69e934e4, 0x97f1, 0x4f1d, 0x88, 0xe8, 0xf2, 0xac, 0x88, 0x67, 0x13, 0x27);

#define DSWCS_F_DEINTERLEAVED   0x00000001
#define DSWCS_F_TOGGLE_8BIT     0x00000002

#undef INTERFACE
#define INTERFACE IDirectSoundWave

DECLARE_INTERFACE_(IDirectSoundWave, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundWave methods
    STDMETHOD(CreateSource)         (THIS_ LPDIRECTSOUNDSOURCE *ppDSSource, LPWAVEFORMATEX pwfxFormat, DWORD dwFlags) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStreamingParms)    (THIS_ LPDWORD pdwFlags, REFERENCE_TIME *prtReadAhead) PURE;
};

#define IDirectSoundWave_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundWave_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundWave_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->lpVtbl->CreateSource(p,a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->lpVtbl->GetStreamingParms(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->CreateSource(a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->GetFormat(a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->GetStreamingParms(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUNDP_INCLUDED__

//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\mmcommon.h ===
/***************************************************************************
 *  mmcommon.h
 *
 *  Copyright (c) Microsoft Corporation 1996. All rights reserved
 *
 *  private include file for definitions common to the NT project
 *
 *  History
 *
 *  16  Feb 96 - NoelC created
 *
 ***************************************************************************/

/***************************************************************************


 Common definitions needed for wx86


 ***************************************************************************/

#define WOD_MESSAGE          "wodMessage"
#define WID_MESSAGE          "widMessage"
#define MOD_MESSAGE          "modMessage"
#define MID_MESSAGE          "midMessage"
#define AUX_MESSAGE          "auxMessage"


#define MMDRVI_TYPE          0x000F  /* low 4 bits give driver type */
#define MMDRVI_WAVEIN        0x0001
#define MMDRVI_WAVEOUT       0x0002
#define MMDRVI_MIDIIN        0x0003
#define MMDRVI_MIDIOUT       0x0004
#define MMDRVI_AUX           0x0005
#define MMDRVI_MIDISTRM      0x0006

#define MMDRVI_MAPPER        0x8000  /* install this driver as the mapper */
#define MMDRVI_HDRV          0x4000  /* hDriver is a installable driver   */
#define MMDRVI_REMOVE        0x2000  /* remove the driver                 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\dvpp.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dvp.h
 *  Content:	DirectDrawVideoPort include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   11-jun-96	scottm	initial implementation
 *   29-jan-97	smac	Various API changes
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DVP_INCLUDED__
#define __DVP_INCLUDED__

/*
 * GUIDS used by DirectDrawVideoPort objects
 */
#if defined( _WIN32 ) && (!defined( _NO_COM ) || defined( DEFINE_GUID ))
DEFINE_GUID( IID_IDDVideoPortContainer,		0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawVideoPort,		0xB36D93E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDrawVideoPortNotify,    0xA655FB94,0x0589,0x4E57,0xB3,0x33,0x56,0x7A,0x89,0x46,0x8C,0x88);



DEFINE_GUID( DDVPTYPE_E_HREFH_VREFH, 0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFH_VREFL, 0x92783220L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFH, 0xA07A02E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFL, 0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_CCIR656,	     0xFCA326A0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_PHILIPS,	     0x332CF160L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
#endif

#ifndef GUID_DEFS_ONLY

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#endif //MAXULONG_PTR

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
struct IDirectDrawSurfaceComposition;
#endif
#ifdef STREAMING
struct IDirectDrawSurfaceStreaming;
#endif
//@@END_MSINTERNAL
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoPortContainer            FAR *LPDDVIDEOPORTCONTAINER;
typedef struct IDirectDrawVideoPort             FAR *LPDIRECTDRAWVIDEOPORT;
typedef struct IDirectDrawVideoPortNotify       FAR *LPDIRECTDRAWVIDEOPORTNOTIFY;

typedef struct _DDVIDEOPORTCONNECT              FAR *LPDDVIDEOPORTCONNECT;
typedef struct _DDVIDEOPORTCAPS                 FAR *LPDDVIDEOPORTCAPS;
typedef struct _DDVIDEOPORTDESC                 FAR *LPDDVIDEOPORTDESC;
typedef struct _DDVIDEOPORTINFO                 FAR *LPDDVIDEOPORTINFO;
typedef struct _DDVIDEOPORTBANDWIDTH            FAR *LPDDVIDEOPORTBANDWIDTH;
typedef struct _DDVIDEOPORTSTATUS               FAR *LPDDVIDEOPORTSTATUS;
typedef struct _DDVIDEOPORTNOTIFY               FAR *LPDDVIDEOPORTNOTIFY;

typedef struct IDDVideoPortContainerVtbl        DDVIDEOPORTCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoPortVtbl         DIRECTDRAWVIDEOPORTCALLBACKS;
typedef struct IDirectDrawVideoPortNotifyVtbl   DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS;


/*
 * API's
 */
typedef HRESULT (FAR PASCAL * LPDDENUMVIDEOCALLBACK)(LPDDVIDEOPORTCAPS, LPVOID);


/*
 * INTERACES FOLLOW:
 *	IDirectDrawVideoPort
 *	IVideoPort
 */

/*
 * IDirectDrawVideoPortContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoPortContainer
DECLARE_INTERFACE_( IDDVideoPortContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawVideoPort methods ***/
    STDMETHOD(CreateVideoPort)(THIS_ DWORD, LPDDVIDEOPORTDESC, LPDIRECTDRAWVIDEOPORT FAR *, IUnknown FAR *) PURE;
    STDMETHOD(EnumVideoPorts)(THIS_ DWORD, LPDDVIDEOPORTCAPS, LPVOID,LPDDENUMVIDEOCALLBACK ) PURE;
    STDMETHOD(GetVideoPortConnectInfo)(THIS_ DWORD, LPDWORD, LPDDVIDEOPORTCONNECT ) PURE;
    STDMETHOD(QueryVideoPortStatus)(THIS_ DWORD, LPDDVIDEOPORTSTATUS ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IVideoPortContainer_Release(p)                      (p)->lpVtbl->Release(p)
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->lpVtbl->CreateVideoPort(p, a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->lpVtbl->EnumVideoPorts(p, a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->lpVtbl->GetVideoPortConnectInfo(p, a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->lpVtbl->QueryVideoPortStatus(p, a, b)
#else
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->AddRef()
#define IVideoPortContainer_Release(p)                      (p)->Release()
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->CreateVideoPort(a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->EnumVideoPorts(a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->GetVideoPortConnectInfo(a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->QueryVideoPortStatus(a, b)
#endif

#endif


/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPort
DECLARE_INTERFACE_( IDirectDrawVideoPort, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBandwidthInfo)(THIS_ LPDDPIXELFORMAT, DWORD, DWORD, DWORD, LPDDVIDEOPORTBANDWIDTH) PURE;
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(GetInputFormats)(THIS_ LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetOutputFormats)(THIS_ LPDDPIXELFORMAT, LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetFieldPolarity)(THIS_ LPBOOL) PURE;
    STDMETHOD(GetVideoLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVideoSignalStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetTargetSurface)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(StartVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(StopVideo)(THIS) PURE;
    STDMETHOD(UpdateVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(WaitForSync)(THIS_ DWORD, DWORD, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPort_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPort_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IVideoPort_Release(p)                   (p)->lpVtbl->Release(p)
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->lpVtbl->SetTargetSurface(p,a,b)
#define IVideoPort_Flip(p,a,b)			(p)->lpVtbl->Flip(p,a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->lpVtbl->GetBandwidthInfo(p,a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->lpVtbl->GetColorControls(p,a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->lpVtbl->GetInputFormats(p,a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->lpVtbl->GetOutputFormats(p,a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->lpVtbl->GetFieldPolarity(p,a)
#define IVideoPort_GetVideoLine(p,a)		(p)->lpVtbl->GetVideoLine(p,a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->lpVtbl->GetVideoSignalStatus(p,a)
#define IVideoPort_SetColorControls(p,a)	(p)->lpVtbl->SetColorControls(p,a)
#define IVideoPort_StartVideo(p,a)		(p)->lpVtbl->StartVideo(p,a)
#define IVideoPort_StopVideo(p)			(p)->lpVtbl->StopVideo(p)
#define IVideoPort_UpdateVideo(p,a)		(p)->lpVtbl->UpdateVideo(p,a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->lpVtbl->WaitForSync(p,a,b,c)
#else
#define IVideoPort_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IVideoPort_AddRef(p)                    (p)->AddRef()
#define IVideoPort_Release(p)                   (p)->Release()
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->SetTargetSurface(a,b)
#define IVideoPort_Flip(p,a,b)			(p)->Flip(a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->GetBandwidthInfo(a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->GetColorControls(a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->GetInputFormats(a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->GetOutputFormats(a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->GetFieldPolarity(a)
#define IVideoPort_GetVideoLine(p,a)		(p)->GetVideoLine(a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->GetVideoSignalStatus(a)
#define IVideoPort_SetColorControls(p,a)	(p)->SetColorControls(a)
#define IVideoPort_StartVideo(p,a)		(p)->StartVideo(a)
#define IVideoPort_StopVideo(p)			(p)->StopVideo()
#define IVideoPort_UpdateVideo(p,a)		(p)->UpdateVideo(a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->WaitForSync(a,b,c)
#endif

#endif

/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPortNotify
DECLARE_INTERFACE_( IDirectDrawVideoPortNotify, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(AcquireNotification)(THIS_ HANDLE *, LPDDVIDEOPORTNOTIFY) PURE;
    STDMETHOD(ReleaseNotification)(THIS_ HANDLE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoPortNotify_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(p,a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(p,a)
#else
#define IVideoPortNotify_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoPortNotify_AddRef(p)                  (p)->AddRef()
#define IVideoPortNotify_Release(p)                 (p)->Release()
#define IVideoPortNotify_AcquireNotification(p,a,b) (p)->lpVtbl->AcquireNotification(a,b)
#define IVideoPortNotify_ReleaseNotification(p,a)   (p)->lpVtbl->ReleaseNotification(a)
#endif

#endif

/*
 * DDVIDEOPORTCONNECT
 */
typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    ULONG_PTR dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT;


/*
 * DDVIDEOPORTCAPS
 */
typedef struct _DDVIDEOPORTCAPS
{
    DWORD dwSize;			// size of the DDVIDEOPORTCAPS structure
    DWORD dwFlags;			// indicates which fields contain data
    DWORD dwMaxWidth;			// max width of the video port field
    DWORD dwMaxVBIWidth;		// max width of the VBI data
    DWORD dwMaxHeight; 			// max height of the video port field
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwCaps;			// Video port capabilities
    DWORD dwFX;				// More video port capabilities
    DWORD dwNumAutoFlipSurfaces;	// Max number of autoflippable surfaces allowed
    DWORD dwAlignVideoPortBoundary;	// Byte restriction of placement within the surface
    DWORD dwAlignVideoPortPrescaleWidth;// Byte restriction of width after prescaling
    DWORD dwAlignVideoPortCropBoundary;	// Byte restriction of left cropping
    DWORD dwAlignVideoPortCropWidth;	// Byte restriction of cropping width
    DWORD dwPreshrinkXStep;		// Width can be shrunk in steps of 1/x
    DWORD dwPreshrinkYStep;		// Height can be shrunk in steps of 1/x
    DWORD dwNumVBIAutoFlipSurfaces;	// Max number of VBI autoflippable surfaces allowed
    DWORD dwNumPreferredAutoflip;	// Optimal number of autoflippable surfaces for hardware
    WORD  wNumFilterTapsX;              // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    WORD  wNumFilterTapsY;              // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)
} DDVIDEOPORTCAPS;

/*
 * The dwMaxWidth and dwMaxVBIWidth members are valid
 */
#define DDVPD_WIDTH		0x00000001l

/*
 * The dwMaxHeight member is valid
 */
#define DDVPD_HEIGHT		0x00000002l

/*
 * The dwVideoPortID member is valid
 */
#define DDVPD_ID		0x00000004l

/*
 * The dwCaps member is valid
 */
#define DDVPD_CAPS		0x00000008l

/*
 * The dwFX member is valid
 */
#define DDVPD_FX		0x00000010l

/*
 * The dwNumAutoFlipSurfaces member is valid
 */
#define DDVPD_AUTOFLIP		0x00000020l

/*
 * All of the alignment members are valid
 */
#define DDVPD_ALIGN		0x00000040l

/*
 * The dwNumPreferredAutoflip member is valid
 */
#define DDVPD_PREFERREDAUTOFLIP 0x00000080l

/*
 * The wNumFilterTapsX and wNumFilterTapsY fields are valid
 */
#define DDVPD_FILTERQUALITY     0x00000100l

/*
 * DDVIDEOPORTDESC
 */
typedef struct _DDVIDEOPORTDESC
{
    DWORD dwSize;			// size of the DDVIDEOPORTDESC structure
    DWORD dwFieldWidth;			// width of the video port field
    DWORD dwVBIWidth;			// width of the VBI data
    DWORD dwFieldHeight;		// height of the video port field
    DWORD dwMicrosecondsPerField;	// Microseconds per video field
    DWORD dwMaxPixelsPerSecond;		// Maximum pixel rate per second
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwReserved1;			// Reserved for future use - set to zero (struct padding)
    DDVIDEOPORTCONNECT VideoPortType; 	// Description of video port connection
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved3;		// Reserved for future use - set to zero
} DDVIDEOPORTDESC;


/*
 * DDVIDEOPORTINFO
 */
typedef struct _DDVIDEOPORTINFO
{
    DWORD dwSize;			// Size of the structure
    DWORD dwOriginX;			// Placement of the video data within the surface.
    DWORD dwOriginY;			// Placement of the video data within the surface.
    DWORD dwVPFlags;			// Video port options
    RECT rCrop;				// Cropping rectangle (optional).
    DWORD dwPrescaleWidth;		// Determines pre-scaling/zooming in the X direction (optional).
    DWORD dwPrescaleHeight;		// Determines pre-scaling/zooming in the Y direction (optional).
    LPDDPIXELFORMAT lpddpfInputFormat;	// Video format written to the video port
    LPDDPIXELFORMAT lpddpfVBIInputFormat; // Input format of the VBI data
    LPDDPIXELFORMAT lpddpfVBIOutputFormat;// Output format of the data
    DWORD dwVBIHeight;			// Specifies the number of lines of data within the vertical blanking interval.
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTINFO;


/*
 * DDVIDEOPORTBANDWIDTH
 */
typedef struct _DDVIDEOPORTBANDWIDTH
{
    DWORD dwSize;			// Size of the structure
    DWORD dwCaps;
    DWORD dwOverlay;           		// Zoom factor at which overlay is supported
    DWORD dwColorkey;			// Zoom factor at which overlay w/ colorkey is supported
    DWORD dwYInterpolate;		// Zoom factor at which overlay w/ Y interpolation is supported
    DWORD dwYInterpAndColorkey;		// Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTBANDWIDTH;


/*
 * DDVIDEOPORTSTATUS
 */
typedef struct _DDVIDEOPORTSTATUS
{
    DWORD dwSize;			// Size of the structure
    BOOL  bInUse;			// TRUE if video port is currently being used
    DWORD dwFlags;           		// Currently not used
    DWORD dwReserved1;			// Reserved for future use
    DDVIDEOPORTCONNECT VideoPortType;	// Information about the connection
    ULONG_PTR dwReserved2;		// Reserved for future use
    ULONG_PTR dwReserved3;		// Reserved for future use
} DDVIDEOPORTSTATUS;

/*
 * DDVIDEOPORTNOTIFY
 */
typedef struct _DDVIDEOPORTNOTIFY
{
    LARGE_INTEGER ApproximateTimeStamp;	// Timestamp in the event notification
    LONG lField;                        // 0 if even, 1 if odd, -1 if unknown
    UINT dwSurfaceIndex;                // Index in the surface chain of the surface that received the sample
    LONG lDone;                         // Call InterlockedIncrement on this when done with sample
} DDVIDEOPORTNOTIFY;


/*============================================================================
 *
 * Video Port Flags
 *
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTCONNECT FLAGS
 *
 ****************************************************************************/

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of double clocking the data.
 * When this is set by the client, this indicates that the video port
 * should enable double clocking.  This flag is only valid with external
 * syncs.
 */
#define DDVPCONNECT_DOUBLECLOCK			0x00000001l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of using an external VACT
 * signal. When this is set by the client, this indicates that the
 * video port should use the external VACT signal.
 */
#define DDVPCONNECT_VACT			0x00000002l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l

/*
 * Indicates that any data written to the video port during the VREF
 * period will not be written into the frame buffer. This flag is read only.
 */
#define DDVPCONNECT_DISCARDSVREFDATA		0x00000008l

/*
 * When this is set be the driver and passed to the client, this
 * indicates that the device will write half lines into the frame buffer
 * if half lines are provided by the decoder.  If this is set by the client,
 * this indicates that the decoder will be supplying half lines.
 */
#define DDVPCONNECT_HALFLINE			0x00000010l

/*
 * Indicates that the signal is interlaced. This flag is only
 * set by the client.
 */
#define DDVPCONNECT_INTERLACED			0x00000020l

/*
 * Indicates that video port is shareable and that this video port
 * will use the even fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREEVEN			0x00000040l

/*
 * Indicates that video port is shareable and that this video port
 * will use the odd fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREODD			0x00000080l

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC CAPS
 *
 ****************************************************************************/

/*
 * Flip can be performed automatically to avoid tearing.
 */
#define DDVPCAPS_AUTOFLIP			0x00000001l

/*
 * Supports interlaced video
 */
#define DDVPCAPS_INTERLACED			0x00000002l

/*
 * Supports non-interlaced video
 */
#define DDVPCAPS_NONINTERLACED			0x00000004l

/*
 * Indicates that the device can return whether the current field
 * of an interlaced signal is even or odd.
 */
#define DDVPCAPS_READBACKFIELD			0x00000008l

/*
 * Indicates that the device can return the current line of video
 * being written into the frame buffer.
 */
#define DDVPCAPS_READBACKLINE			0x00000010l

/*
 * Allows two gen-locked video streams to share a single video port,
 * where one stream uses the even fields and the other uses the odd
 * fields. Separate parameters (including address, scaling,
 * cropping, etc.) are maintained for both fields.)
 */
#define DDVPCAPS_SHAREABLE			0x00000020l

/*
 * Even fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPEVENFIELDS			0x00000040l

/*
 * Odd fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPODDFIELDS			0x00000080l

/*
 * Indicates that the device is capable of driving the graphics
 * VSYNC with the video port VSYNC.
 */
#define DDVPCAPS_SYNCMASTER			0x00000100l

/*
 * Indicates that data within the vertical blanking interval can
 * be written to a different surface.
 */
#define DDVPCAPS_VBISURFACE			0x00000200l

/*
 * Indicates that the video port can perform color operations
 * on the incoming data before it is written to the frame buffer.
 */
#define DDVPCAPS_COLORCONTROL			0x00000400l

/*
 * Indicates that the video port can accept VBI data in a different
 * width or format than the regular video data.
 */
#define DDVPCAPS_OVERSAMPLEDVBI			0x00000800l

/*
 * Indicates that the video port can write data directly to system memory
 */
#define DDVPCAPS_SYSTEMMEMORY			0x00001000l

/*
 * Indicates that the VBI and video portions of the video stream can
 * be controlled by an independent processes.
 */
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l

/*
 * Indicates that the video port contains high quality hardware
 * de-interlacing hardware that should be used instead of the
 * bob/weave algorithms.
 */
#define DDVPCAPS_HARDWAREDEINTERLACE		0x00004000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC FX
 *
 ****************************************************************************/

/*
 * Limited cropping is available to crop out the vertical interval data.
 */
#define DDVPFX_CROPTOPDATA			0x00000001l

/*
 * Incoming data can be cropped in the X direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPX				0x00000002l

/*
 * Incoming data can be cropped in the Y direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPY				0x00000004l

/*
 * Supports interleaving interlaced fields in memory.
 */
#define DDVPFX_INTERLEAVE			0x00000008l

/*
 * Supports mirroring left to right as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORLEFTRIGHT			0x00000010l

/*
 * Supports mirroring top to bottom as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORUPDOWN			0x00000020l

/*
 * Data can be arbitrarily shrunk in the X direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKX			0x00000040l

/*
 * Data can be arbitrarily shrunk in the Y direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKY			0x00000080l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the X
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXB			0x00000100l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the Y
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYB			0x00000200l

/*
 * Data can be shrunk in increments of 1/x in the X direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXS			0x00000400l

/*
 * Data can be shrunk in increments of 1/x in the Y direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYS			0x00000800l

/*
 * Data can be arbitrarily stretched in the X direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHX			0x00001000l

/*
 * Data can be arbitrarily stretched in the Y direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHY			0x00002000l

/*
 * Data can be integer stretched in the X direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHXN			0x00004000l

/*
 * Data can be integer stretched in the Y direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHYN			0x00008000l

/*
 * Indicates that data within the vertical blanking interval can
 * be converted independently of the remaining video data.
 */
#define DDVPFX_VBICONVERT			0x00010000l

/*
 * Indicates that scaling can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOSCALE			0x00020000l

/*
 * Indicates that the video data can ignore the left and right
 * cropping coordinates when cropping oversampled VBI data.
 */
#define DDVPFX_IGNOREVBIXCROP			0x00040000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOINTERLEAVE			0x00080000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTINFO FLAGS
 *
 ****************************************************************************/

/*
 * Perform automatic flipping.   Auto-flipping is performed between
 * the overlay surface that was attached to the video port using
 * IDirectDrawVideoPort::AttachSurface and the overlay surfaces that
 * are attached to the surface via the IDirectDrawSurface::AttachSurface
 * method.  The flip order is the order in which the overlay surfaces
 * were. a