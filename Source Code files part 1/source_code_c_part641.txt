UNKNOWN = 99
};

typedef enum RAS_SUBAUTH_PROTO RAS_SUBAUTH_PROTO;

typedef struct _RAS_SUBAUTH_INFO
{
    RAS_SUBAUTH_PROTO   ProtocolType;
    DWORD               DataSize;
    UCHAR               Data[1];
} RAS_SUBAUTH_INFO, *PRAS_SUBAUTH_INFO;

#define CHAP_RESPONSE_SIZE      16

//
// The RAS_SUBAUTH_INFO 'Data' for ProtocolType RAS_SUBAUTH_PROTO_MD5CHAP.
//
typedef struct
_MD5CHAP_SUBAUTH_INFO
{
    // The packet sequence number of the challenge sent to peer.  PPP CHAP
    // includes this in the hashed information.
    //
    UCHAR uchChallengeId;

    // The challenge sent to peer.
    //
    UCHAR uchChallenge[ 16 ];

    // The challenge response received from peer.
    //
    UCHAR uchResponse[CHAP_RESPONSE_SIZE];
}
MD5CHAP_SUBAUTH_INFO;

//
// The RAS_SUBAUTH_INFO 'Data' for ProtocolType RAS_SUBAUTH_PROTO_MD5CHAP_EX.
//
typedef struct _MD5CHAP_EX_SUBAUTH_INFO
{
    // The packet sequence number of the challenge sent to peer.  PPP CHAP
    // includes this in the hashed information.
    //
    UCHAR uchChallengeId;

    // The challenge response received from peer.
    //
    UCHAR uchResponse[CHAP_RESPONSE_SIZE];

    // The challenge sent to peer.
    //
    UCHAR uchChallenge[ 1 ];

} MD5CHAP_EX_SUBAUTH_INFO;


#define MAX_ARAP_USER_NAMELEN   32
#define MAX_MAC_PWD_LEN         8

#define ARAP_SUBAUTH_LOGON_PKT      1
#define ARAP_SUBAUTH_CHGPWD_PKT     2
#define SFM_SUBAUTH_CHGPWD_PKT      3
#define SFM_SUBAUTH_LOGON_PKT       4
#define SFM_2WAY_SUBAUTH_LOGON_PKT  ARAP_SUBAUTH_LOGON_PKT

typedef struct _ARAP_CHALLENGE
{
    DWORD   high;
    DWORD   low;
} ARAP_CHALLENGE, *PARAP_CHALLENGE;

typedef struct _ARAP_SUBAUTH_REQ
{
    DWORD   PacketType;
    union
    {
        struct
        {
            DWORD           fGuestLogon;
            DWORD           NTChallenge1;
            DWORD           NTChallenge2;
            DWORD           MacResponse1;
            DWORD           MacResponse2;
            DWORD           MacChallenge1;
            DWORD           MacChallenge2;
            DWORD           NTResponse1;
            DWORD           NTResponse2;
            LARGE_INTEGER   PasswdCreateDate;
            LARGE_INTEGER   PasswdExpireDate;
        } Logon;

        struct
        {
            WCHAR   UserName[MAX_ARAP_USER_NAMELEN+1];
            UCHAR   OldMunge[MAX_ARAP_USER_NAMELEN+1];
            UCHAR   NewMunge[MAX_ARAP_USER_NAMELEN+1];
        } ChgPwd;
    };

} ARAP_SUBAUTH_REQ, *PARAP_SUBAUTH_REQ;

//
// NOTE: make sure this structure size doesn't exceed 16 because of our
// workaround in using SessionKey of MSV1_0_VALIDATION_INFO structure
//
typedef struct _ARAP_SUBAUTH_RESP
{
    DWORD           Result;
    ARAP_CHALLENGE  Response;

} ARAP_SUBAUTH_RESP, *PARAP_SUBAUTH_RESP;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\rasapip.h ===
/*++

Copyright (C) 1994-98 Microsft Corporation. All rights reserved.

Module Name:

    rasapip.h

Abstract:

    This file has definitions for private apis for ras connections.
    These apis are exported from rasapi32.dll

Author:

    Rao Salapaka (raos) 30-Jan-1998

Revision History:

--*/

#ifndef _RASAPIP_
#define _RASAPIP_

#include <windef.h> //for MAX_PATH

#ifdef __cplusplus
extern "C" {
#endif


#define RASAPIP_MAX_DEVICE_NAME     128
#define RASAPIP_MAX_ENTRY_NAME      256
#define RASAPIP_MAX_PHONE_NUMBER    128     // Must be same as RAS_MaxPhoneNumber

#define RAS_DEVICE_TYPE(_x)     ((_x) & 0x0000FFFF)

#define RAS_DEVICE_CLASS(_x)    ((_x) & 0xFFFF0000)

enum _RASDEVICETYPE
{
    RDT_Modem = 0,

    RDT_X25,

    RDT_Isdn,

    RDT_Serial,

    RDT_FrameRelay,

    RDT_Atm,

    RDT_Sonet,

    RDT_Sw56,

    RDT_Tunnel_Pptp,

    RDT_Tunnel_L2tp,

    RDT_Irda,

    RDT_Parallel,

    RDT_Other,

    RDT_PPPoE,

    //
    // The following flags when set
    // specify the class of the device
    //
    RDT_Tunnel = 0x00010000,

    RDT_Direct  = 0x00020000,

    RDT_Null_Modem = 0x00040000,

    RDT_Broadband = 0x00080000
};


typedef enum _RASDEVICETYPE RASDEVICETYPE;

// Private flags for RASENUMENTRYDETAILS
//
#define REED_F_Default 0x1      // default Internet connection

typedef struct _RASENUMENTRYDETAILS
{
    DWORD   dwSize;
    DWORD   dwFlags;                    // same as RASENTRYNAME.dwFlags
    DWORD   dwType;                     // same as RASENTRY.dwType
    GUID    guidId;                     // same as RASENTRY.guidId
    BOOL    fShowMonitorIconInTaskBar;  // same as RASENTRY.fShowMonitorIconInTaskBar
    RASDEVICETYPE rdt;
    WCHAR   szDeviceName[RASAPIP_MAX_DEVICE_NAME];
    WCHAR   szEntryName[RASAPIP_MAX_ENTRY_NAME + 1];
    WCHAR   szPhonebookPath[MAX_PATH + 1];
    DWORD   dwFlagsPriv;                // Private flags, not found in RASENTRY
    WCHAR   szPhoneNumber[RASAPIP_MAX_PHONE_NUMBER + 1];

} RASENUMENTRYDETAILS, *LPRASENUMENTRYDETAILS;

DWORD
APIENTRY
DwDeleteSubEntry(
    IN      LPCWSTR lpszPhonebook,
    IN      LPCWSTR lpszEntry,
    IN      DWORD   dwSubEntryId
    );

DWORD
APIENTRY
DwEnumEntryDetails (
    IN     LPCWSTR               lpszPhonebookPath,
    OUT    LPRASENUMENTRYDETAILS lprasentryname,
    IN OUT LPDWORD               lpcb,
    OUT    LPDWORD               lpcEntries
    );

DWORD
APIENTRY
DwCloneEntry(
    IN      LPCWSTR lpwszPhonebookPath,
    IN      LPCWSTR lpwszSrcEntryName,
    IN      LPCWSTR lpwszDstEntryName
    );


// Implemented in rasman.dll
//
DWORD
APIENTRY
RasReferenceRasman (
    IN BOOL fAttach
    );

DWORD 
APIENTRY RasInitialize () ;


// Implemented in netcfgx.dll
//
HRESULT
WINAPI
RasAddBindings (
    IN OUT UINT*    pcIpOut,
    IN OUT UINT*    pcNbfIn,
    IN OUT UINT*    pcNbfOut);

HRESULT
WINAPI
RasCountBindings (
    OUT UINT*   pcIpOut,
    OUT UINT*   pcNbfIn,
    OUT UINT*   pcNbfOut);

HRESULT
WINAPI
RasRemoveBindings (
    IN OUT UINT*        pcIpOutBindings,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut);

//+---------------------------------------------------------------------------
// RAS Event notifications into netman.
//
typedef enum _RASEVENTTYPE
{
    ENTRY_ADDED,
    ENTRY_DELETED,
    ENTRY_MODIFIED,
    ENTRY_RENAMED,
    ENTRY_CONNECTED,
    ENTRY_CONNECTING,
    ENTRY_DISCONNECTING,
    ENTRY_DISCONNECTED,
    INCOMING_CONNECTED,
    INCOMING_DISCONNECTED,
    SERVICE_EVENT,
    ENTRY_BANDWIDTH_ADDED,
    ENTRY_BANDWIDTH_REMOVED,
    DEVICE_ADDED,
    DEVICE_REMOVED,
    ENTRY_AUTODIAL
} RASEVENTTYPE;

typedef enum _SERVICEEVENTTYPE
{
    RAS_SERVICE_STARTED,
    RAS_SERVICE_STOPPED,
} SERVICEEVENTTYPE;

typedef enum _RASSERVICE
{
    RASMAN,
    RASAUTO,
    REMOTEACCESS,
} RASSERVICE;

typedef struct _RASEVENT
{
    RASEVENTTYPE    Type;

    union
    {
    // ENTRY_ADDED,
    // ENTRY_MODIFIED,
    // ENTRY_CONNECTED
    // ENTRY_CONNECTING
    // ENTRY_DISCONNECTING
    // ENTRY_DISCONNECTED
        struct
        {
            RASENUMENTRYDETAILS     Details;
        };

    // ENTRY_DELETED,
    // INCOMING_CONNECTED,
    // INCOMING_DISCONNECTED,
    // ENTRY_BANDWIDTH_ADDED
    // ENTRY_BANDWIDTH_REMOVED
    //  guidId is valid

    // ENTRY_RENAMED
    // ENTRY_AUTODIAL,
        struct
        {
            HANDLE  hConnection;
            RASDEVICETYPE rDeviceType;
            GUID    guidId;
            WCHAR   pszwNewName [RASAPIP_MAX_ENTRY_NAME + 1];
        };

    // SERVICE_EVENT,
        struct
        {
            SERVICEEVENTTYPE    Event;
            RASSERVICE          Service;
        };
        
        // DEVICE_ADDED
        // DEVICE_REMOVED
        RASDEVICETYPE DeviceType;
    };
} RASEVENT;

typedef struct _RASENTRYHEADER
{
    DWORD dwEntryType;
    WCHAR szEntryName[RASAPIP_MAX_ENTRY_NAME + 1];
} RASENTRYHEADER, *PRASENTRYHEADER;

// Implemented in netman.dll
//
typedef VOID (APIENTRY *RASEVENTNOTIFYPROC)(const RASEVENT* pEvent);

VOID
APIENTRY
RasEventNotify (
    const RASEVENT* pEvent);

DWORD
APIENTRY
DwEnumEntriesForAllUsers(
            DWORD *lpcb,
            DWORD *lpcEntries,
            RASENTRYHEADER * pRasEntryHeader);


#ifdef __cplusplus
}
#endif


#endif  // _RASAPIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\snmpexts.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    snmpexts.h

Abstract:

    Definitions for SNMP extension agents.

--*/

#ifndef _INC_SNMPEXTS_
#define _INC_SNMPEXTS_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib version                                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MIB_VERSION            0x01         // increment if structure changes

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view types (use opaque if SnmpExtensionQuery preferred)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MIB_VIEW_NORMAL        0x01         // callback via mib structure
#define MIB_VIEW_OPAQUE        0x02         // call directly with varbinds

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry access types                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MIB_ACCESS_NONE        0x00         // entry not accessible 
#define MIB_ACCESS_READ        0x01         // entry can be read 
#define MIB_ACCESS_WRITE       0x02         // entry can be written
#define MIB_ACCESS_ALL         0x03         // entry can be read and written
                                
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib callback request types                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MIB_ACTION_SET         ASN_RFC1157_SETREQUEST    
#define MIB_ACTION_GET         ASN_RFC1157_GETREQUEST    
#define MIB_ACTION_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_ACTION_GETFIRST    (ASN_PRIVATE|ASN_CONSTRUCTOR|0x00)
#define MIB_ACTION_VALIDATE    (ASN_PRIVATE|ASN_CONSTRUCTOR|0x01)
#define MIB_ACTION_CLEANUP     (ASN_PRIVATE|ASN_CONSTRUCTOR|0x02)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Callback definitions                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef UINT (* MIB_ACTION_FUNC)(
    IN     UINT           actionId,         // action requested
    IN OUT AsnAny *       objectArray,      // array of variables 
       OUT UINT *         errorIndex        // index of item in error 
);

typedef UINT (* MIB_EVENT_FUNC)();          // event callback

#define MIB_S_SUCCESS           ERROR_SUCCESS
#define MIB_S_NOT_SUPPORTED     ERROR_NOT_SUPPORTED
#define MIB_S_NO_MORE_ENTRIES   ERROR_NO_MORE_ITEMS
#define MIB_S_ENTRY_NOT_FOUND   ERROR_FILE_NOT_FOUND
#define MIB_S_INVALID_PARAMETER ERROR_INVALID_PARAMETER

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry definition                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SnmpMibEntry {
    AsnObjectIdentifier   mibOid;           // relative oid
    UCHAR                 mibType;          // asn scalar type
    UCHAR                 mibAccess;        // mib access type 
    UCHAR                 mibGetBufOff;     // index into get array
    UCHAR                 mibSetBufOff;     // index into set array
    USHORT                mibGetBufLen;     // total size of get array
    USHORT                mibSetBufLen;     // total size of set array
    MIB_ACTION_FUNC       mibGetFunc;       // user-supplied callback 
    MIB_ACTION_FUNC       mibSetFunc;       // user-supplied callback 
    INT                   mibMinimum;       // minimum value allowed
    INT                   mibMaximum;       // maximum value allowed
} SnmpMibEntry;

typedef struct _SnmpMibEntryList {
    SnmpMibEntry *        list;             // list of mib entries
    UINT                  len;              // list length
} SnmpMibEntryList;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib table definition                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SnmpMibTable {
    UINT            numColumns;             // number of table entries
    UINT            numIndices;             // number of table indices
    SnmpMibEntry *  tableEntry;             // pointer to table root
    SnmpMibEntry ** tableIndices;           // pointer to index indices
} SnmpMibTable;

typedef struct _SnmpMibTableList {
    SnmpMibTable *        list;             // list of mib tables
    UINT                  len;              // list length
} SnmpMibTableList;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view definition                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SnmpMibView {
    DWORD                 viewVersion;      // structure version  
    DWORD                 viewType;         // opaque or normal
    AsnObjectIdentifier   viewOid;          // root oid of view
    SnmpMibEntryList      viewScalars;      // list of entries 
    SnmpMibTableList      viewTables;       // list of tables 
} SnmpMibView;

typedef struct _SnmpMibViewList {
    SnmpMibView *         list;             // list of supported views
    UINT                  len;              // list length
} SnmpMibViewList;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib event definition                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SnmpMibEvent {
    HANDLE                event;            // subagent event handle
    MIB_EVENT_FUNC        eventFunc;        // subagent event callback 
} SnmpMibEvent;

typedef struct _SnmpMibEventList {
    SnmpMibEvent *        list;             // list of supported events
    UINT                  len;              // list length
} SnmpMibEventList;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Extension agent framework functions                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef LPVOID SnmpTfxHandle;

SnmpTfxHandle
SNMP_FUNC_TYPE
SnmpTfxOpen(
    DWORD         numViews,
    SnmpMibView * supportedViews
    );

BOOL
SNMP_FUNC_TYPE
SnmpTfxQuery(
    SnmpTfxHandle        tfxHandle,
    BYTE                 requestType,
    RFC1157VarBindList * vbl,
    AsnInteger *         errorStatus,
    AsnInteger *         errorIndex
    );

VOID
SNMP_FUNC_TYPE
SnmpTfxClose(
    SnmpTfxHandle tfxHandle
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Other definitions                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ASN_PRIVATE_EOM     (ASN_PRIVATE|ASN_PRIMATIVE|0x00)
#define ASN_PRIVATE_NODE    (ASN_PRIVATE|ASN_PRIMATIVE|0x01)

#define IDS_SIZEOF(ids)     (sizeof(ids)/sizeof(UINT))
#define MIB_OID(ids)        {IDS_SIZEOF(ids),(ids)}

#define ELIST_SIZEOF(x)     (sizeof(x)/sizeof(SnmpMibEntry))
#define MIB_ENTRIES(x)      {(x),ELIST_SIZEOF(x)}

#define TLIST_SIZEOF(x)     (sizeof(x)/sizeof(SnmpMibTable))
#define MIB_TABLES(x)       {(x),TLIST_SIZEOF(x)}

#define MIB_ADDR(x)         (&(x))
#define MIB_ID(x)           x

#define MIB_VIEW(x) \
        {MIB_VERSION, \
         MIB_VIEW_NORMAL, \
         MIB_OID(ids_ ## x), \
         MIB_ENTRIES(mib_ ## x), \
         MIB_TABLES(tbl_ ## x)}

#define MIB_GROUP(x) \
        {MIB_OID(ids_ ## x), \
         ASN_PRIVATE_NODE, \
         MIB_ACCESS_NONE, \
         0, \
         0, \
         0, \
         0, \
         NULL, \
         NULL, \
         0, \
         0}

#define MIB_END() \
        {{0,NULL}, \
         ASN_PRIVATE_EOM, \
         MIB_ACCESS_NONE, \
         0, \
         0, \
         0, \
         0, \
         NULL, \
         NULL, \
         0, \
         0}

#define MIB_ROOT(x)         MIB_GROUP(x)
#define MIB_TABLE_ROOT(x)   MIB_GROUP(x)
#define MIB_TABLE_ENTRY(x)  MIB_GROUP(x)

#define MIB_OFFSET(x,y)     (((UINT_PTR)&(((x *)0)->y))/sizeof(AsnAny))
#define MIB_OFFSET_GB(x)    MIB_OFFSET(MIB_ID(gb_ ## x),x)
#define MIB_OFFSET_SB(x)    MIB_OFFSET(MIB_ID(sb_ ## x),x)
#define MIB_SIZEOF_GB(x)    sizeof(MIB_ID(gb_ ## x))
#define MIB_SIZEOF_SB(x)    sizeof(MIB_ID(sb_ ## x))

#define MIB_ANY_RO_L(x,y,a,z) \
        {MIB_OID(ids_ ## x), \
         y, \
         MIB_ACCESS_READ, \
         MIB_OFFSET_GB(x), \
         0, \
         MIB_SIZEOF_GB(x), \
         0, \
         MIB_ID(gf_ ## x), \
         NULL, \
         a, \
         z}

#define MIB_ANY_RW_L(x,y,a,z) \
        {MIB_OID(ids_ ## x), \
         y, \
         MIB_ACCESS_ALL, \
         MIB_OFFSET_GB(x), \
         MIB_OFFSET_SB(x), \
         MIB_SIZEOF_GB(x), \
         MIB_SIZEOF_SB(x), \
         MIB_ID(gf_ ## x), \
         MIB_ID(sf_ ## x), \
         a, \
         z}

#define MIB_ANY_NA_L(x,y,a,z) \
        {MIB_OID(ids_ ## x), \
         y, \
         MIB_ACCESS_NONE, \
         MIB_OFFSET_GB(x), \
         0, \
         MIB_SIZEOF_GB(x), \
         0, \
         NULL, \
         NULL, \
         a, \
         z}

#define MIB_ANY_AC_L(x,y,a,z) \
        {MIB_OID(ids_ ## x), \
         y, \
         MIB_ACCESS_NONE, \
         MIB_OFFSET_GB(x), \
         MIB_OFFSET_SB(x), \
         MIB_SIZEOF_GB(x), \
         MIB_SIZEOF_SB(x), \
         NULL, \
         NULL, \
         a, \
         z}

#define MIB_ANY_RO(x,y)             MIB_ANY_RO_L(x,y,0,0)
#define MIB_ANY_RW(x,y)             MIB_ANY_RW_L(x,y,0,0)
#define MIB_ANY_NA(x,y)             MIB_ANY_NA_L(x,y,0,0)
#define MIB_ANY_AC(x,y)             MIB_ANY_AC_L(x,y,0,0)

#define MIB_INTEGER(x)              MIB_ANY_RO(x,ASN_INTEGER)
#define MIB_UNSIGNED32(x)           MIB_ANY_RO(x,ASN_RFC2578_UNSIGNED32)
#define MIB_OCTETSTRING(x)          MIB_ANY_RO(x,ASN_OCTETSTRING)
#define MIB_OBJECTIDENTIFIER(x)     MIB_ANY_RO(x,ASN_OBJECTIDENTIFIER)
#define MIB_IPADDRESS(x)            MIB_ANY_RO(x,ASN_RFC1155_IPADDRESS)
#define MIB_COUNTER(x)              MIB_ANY_RO(x,ASN_RFC1155_COUNTER)
#define MIB_GAUGE(x)                MIB_ANY_RO(x,ASN_RFC1155_GAUGE)
#define MIB_TIMETICKS(x)            MIB_ANY_RO(x,ASN_RFC1155_TIMETICKS)
#define MIB_OPAQUE(x)               MIB_ANY_RO(x,ASN_RFC1155_OPAQUE)
#define MIB_DISPSTRING(x)           MIB_ANY_RO(x,ASN_RFC1213_DISPSTRING)
#define MIB_PHYSADDRESS(x)          MIB_ANY_RO(x,ASN_OCTETSTRING)

#define MIB_INTEGER_RW(x)           MIB_ANY_RW(x,ASN_INTEGER)
#define MIB_UNSIGNED32_RW(x)        MIB_ANY_RW(x,ASN_RFC2578_UNSIGNED32)    
#define MIB_OCTETSTRING_RW(x)       MIB_ANY_RW(x,ASN_OCTETSTRING)
#define MIB_OBJECTIDENTIFIER_RW(x)  MIB_ANY_RW(x,ASN_OBJECTIDENTIFIER)
#define MIB_IPADDRESS_RW(x)         MIB_ANY_RW(x,ASN_RFC1155_IPADDRESS)
#define MIB_COUNTER_RW(x)           MIB_ANY_RW(x,ASN_RFC1155_COUNTER)
#define MIB_GAUGE_RW(x)             MIB_ANY_RW(x,ASN_RFC1155_GAUGE)
#define MIB_TIMETICKS_RW(x)         MIB_ANY_RW(x,ASN_RFC1155_TIMETICKS)
#define MIB_OPAQUE_RW(x)            MIB_ANY_RW(x,ASN_RFC1155_OPAQUE)
#define MIB_DISPSTRING_RW(x)        MIB_ANY_RW(x,ASN_RFC1213_DISPSTRING)
#define MIB_PHYSADDRESS_RW(x)       MIB_ANY_RW(x,ASN_OCTETSTRING)

#define MIB_INTEGER_NA(x)           MIB_ANY_NA(x,ASN_INTEGER)
#define MIB_UNSIGNED32_NA(x)        MIB_ANY_NA(x,ASN_RFC2578_UNSIGNED32)  
#define MIB_OCTETSTRING_NA(x)       MIB_ANY_NA(x,ASN_OCTETSTRING)
#define MIB_OBJECTIDENTIFIER_NA(x)  MIB_ANY_NA(x,ASN_OBJECTIDENTIFIER)
#define MIB_IPADDRESS_NA(x)         MIB_ANY_NA(x,ASN_RFC1155_IPADDRESS)
#define MIB_COUNTER_NA(x)           MIB_ANY_NA(x,ASN_RFC1155_COUNTER)
#define MIB_GAUGE_NA(x)             MIB_ANY_NA(x,ASN_RFC1155_GAUGE)
#define MIB_TIMETICKS_NA(x)         MIB_ANY_NA(x,ASN_RFC1155_TIMETICKS)
#define MIB_OPAQUE_NA(x)            MIB_ANY_NA(x,ASN_RFC1155_OPAQUE)
#define MIB_DISPSTRING_NA(x)        MIB_ANY_NA(x,ASN_RFC1213_DISPSTRING)
#define MIB_PHYSADDRESS_NA(x)       MIB_ANY_NA(x,ASN_OCTETSTRING)

#define MIB_INTEGER_AC(x)           MIB_ANY_AC(x,ASN_INTEGER)
#define MIB_UNSIGNED32_AC(x)        MIB_ANY_AC(x,ASN_RFC2578_UNSIGNED32)  
#define MIB_OCTETSTRING_AC(x)       MIB_ANY_AC(x,ASN_OCTETSTRING)
#define MIB_OBJECTIDENTIFIER_AC(x)  MIB_ANY_AC(x,ASN_OBJECTIDENTIFIER)
#define MIB_IPADDRESS_AC(x)         MIB_ANY_AC(x,ASN_RFC1155_IPADDRESS)
#define MIB_COUNTER_AC(x)           MIB_ANY_AC(x,ASN_RFC1155_COUNTER)
#define MIB_GAUGE_AC(x)             MIB_ANY_AC(x,ASN_RFC1155_GAUGE)
#define MIB_TIMETICKS_AC(x)         MIB_ANY_AC(x,ASN_RFC1155_TIMETICKS)
#define MIB_OPAQUE_AC(x)            MIB_ANY_AC(x,ASN_RFC1155_OPAQUE)
#define MIB_DISPSTRING_AC(x)        MIB_ANY_AC(x,ASN_RFC1213_DISPSTRING)
#define MIB_PHYSADDRESS_AC(x)       MIB_ANY_AC(x,ASN_OCTETSTRING)

#define MIB_INTEGER_L(x,a,z)        MIB_ANY_RO_L(x,ASN_INTEGER,a,z)
#define MIB_UNSIGNED32_L(x,a,z)     MIB_ANY_RO_L(x,ASN_RFC2578_UNSIGNED32,a,z)      
#define MIB_OCTETSTRING_L(x,a,z)    MIB_ANY_RO_L(x,ASN_OCTETSTRING,a,z)
#define MIB_OPAQUE_L(x,a,z)         MIB_ANY_RO_L(x,ASN_RFC1155_OPAQUE,a,z)
#define MIB_DISPSTRING_L(x,a,z)     MIB_ANY_RO_L(x,ASN_RFC1213_DISPSTRING,a,z)
#define MIB_PHYSADDRESS_L(x,a,z)    MIB_ANY_RO_L(x,ASN_OCTETSTRING,a,z)

#define MIB_INTEGER_RW_L(x,a,z)     MIB_ANY_RW_L(x,ASN_INTEGER,a,z)
#define MIB_UNSIGNED32_RW_L(x,a,z)  MIB_ANY_RW_L(x,ASN_RFC2578_UNSIGNED32,a,z)      
#define MIB_OCTETSTRING_RW_L(x,a,z) MIB_ANY_RW_L(x,ASN_OCTETSTRING,a,z)
#define MIB_OPAQUE_RW_L(x,a,z)      MIB_ANY_RW_L(x,ASN_RFC1155_OPAQUE,a,z)
#define MIB_DISPSTRING_RW_L(x,a,z)  MIB_ANY_RW_L(x,ASN_RFC1213_DISPSTRING,a,z)
#define MIB_PHYSADDRESS_RW_L(x,a,z) MIB_ANY_RW_L(x,ASN_OCTETSTRING,a,z)

#define MIB_INTEGER_NA_L(x,a,z)     MIB_ANY_NA_L(x,ASN_INTEGER,a,z)
#define MIB_UNSIGNED32_NA_L(x,a,z)  MIB_ANY_NA_L(x,ASN_RFC2578_UNSIGNED32,a,z)      
#define MIB_OCTETSTRING_NA_L(x,a,z) MIB_ANY_NA_L(x,ASN_OCTETSTRING,a,z)
#define MIB_OPAQUE_NA_L(x,a,z)      MIB_ANY_NA_L(x,ASN_RFC1155_OPAQUE,a,z)
#define MIB_DISPSTRING_NA_L(x,a,z)  MIB_ANY_NA_L(x,ASN_RFC1213_DISPSTRING,a,z)
#define MIB_PHYSADDRESS_NA_L(x,a,z) MIB_ANY_NA_L(x,ASN_OCTETSTRING,a,z)

#define MIB_INTEGER_AC_L(x,a,z)     MIB_ANY_AC_L(x,ASN_INTEGER,a,z)
#define MIB_UNSIGNED32_AC_L(x,a,z)  MIB_ANY_AC_L(x,ASN_RFC2578_UNSIGNED32,a,z)    
#define MIB_OCTETSTRING_AC_L(x,a,z) MIB_ANY_AC_L(x,ASN_OCTETSTRING,a,z)
#define MIB_OPAQUE_AC_L(x,a,z)      MIB_ANY_AC_L(x,ASN_RFC1155_OPAQUE,a,z)
#define MIB_DISPSTRING_AC_L(x,a,z)  MIB_ANY_AC_L(x,ASN_RFC1213_DISPSTRING,a,z)
#define MIB_PHYSADDRESS_AC_L(x,a,z) MIB_ANY_AC_L(x,ASN_OCTETSTRING,a,z)

#define MIB_ENTRY_PTR(x,y) \
        MIB_ADDR(MIB_ID(mib_ ## x)[MIB_ID(mi_ ## y)])

#define MIB_TABLE(x,y,z) \
        {MIB_ID(ne_ ## y), MIB_ID(ni_ ## y), MIB_ENTRY_PTR(x,y), z}

#define asn_t  asnType
#define asn_v  asnValue
#define asn_n  asnValue.number
#define asn_u  asnValue.unsigned32
#define asn_s  asnValue.string
#define asn_sl asnValue.string.length
#define asn_ss asnValue.string.stream
#define asn_sd asnValue.string.dynamic
#define asn_o  asnValue.object
#define asn_ol asnValue.object.idLength
#define asn_oi asnValue.object.ids
#define asn_l  asnValue.sequence
#define asn_a  asnValue.address
#define asn_c  asnValue.counter
#define asn_g  asnValue.gauge
#define asn_tt asnValue.timeticks
#define asn_x  asnValue.arbitrary

#endif // _INC_SNMPEXTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\snmputil.h ===
/*++

Copyright (C) 1992 - 1996 Microsoft Corporation

Module Name:

    snmputil.h

Abstract:

    Definitions for SNMP Extension Agent development (internal).

--*/

#ifndef _INC_SNMPUTIL
#define _INC_SNMPUTIL

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Additional header files                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// AUTH API type definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct {        
    RFC1157VarBindList  varBinds;
    AsnInteger          requestType;
    AsnInteger          requestId;
    AsnInteger          errorStatus;
    AsnInteger          errorIndex;
} RFC1157Pdu;

typedef struct {
    RFC1157VarBindList  varBinds;
    AsnObjectIdentifier enterprise;
    AsnNetworkAddress   agentAddr;
    AsnInteger          genericTrap;
    AsnInteger          specificTrap;
    AsnTimeticks        timeStamp;
} RFC1157TrapPdu;

typedef struct {
   BYTE pduType;
   union {
      RFC1157Pdu        pdu;
      RFC1157TrapPdu    trap;
   } pduValue;
} RFC1157Pdus;

typedef struct {
    AsnObjectIdentifier dstParty;
    AsnObjectIdentifier srcParty;
    RFC1157Pdus         pdu;
    AsnOctetString      community;
} SnmpMgmtCom;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// AUTH API prototypes                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE
SnmpSvcEncodeMessage(
    IN     UINT          snmpAuthType,       
    IN     SnmpMgmtCom * snmpMgmtCom, 
    IN OUT BYTE **       pBuffer,     
    IN OUT UINT *        nLength      
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpSvcDecodeMessage(
       OUT UINT *        snmpAuthType,       
       OUT SnmpMgmtCom * snmpMgmtCom, 
    IN     BYTE *        pBuffer,     
    IN     UINT          nLength,
    IN     BOOL          fAuthMsg
    );

SNMPAPI
SNMP_FUNC_TYPE
SnmpSvcReleaseMessage(
    IN OUT SnmpMgmtCom * snmpMgmtCom 
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal utility prototypes (publish via snmp.h as needed)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID 
SNMP_FUNC_TYPE
SnmpUtilPrintOid(
    IN AsnObjectIdentifier *Oid 
    );

LPSTR 
SNMP_FUNC_TYPE
SnmpUtilOidToA(
    IN AsnObjectIdentifier *Oid
    );

LPSTR 
SNMP_FUNC_TYPE
SnmpUtilIdsToA(
    IN UINT *Ids,
    IN UINT IdLength
    );

LONG 
SNMP_FUNC_TYPE
SnmpUtilUnicodeToAnsi(
    LPSTR   *ansi_string,
    LPWSTR  uni_string,
    BOOLEAN alloc_it
    );

LONG
SNMP_FUNC_TYPE
SnmpUtilUnicodeToUTF8(
    LPSTR   *pUtfString,
    LPWSTR  wcsString,
    BOOLEAN bAllocBuffer
    );

LONG 
SNMP_FUNC_TYPE
SnmpUtilAnsiToUnicode(
    LPWSTR  *uni_string,
    LPSTR   ansi_string,
    BOOLEAN alloc_it
    );

LONG
SNMP_FUNC_TYPE
SnmpUtilUTF8ToUnicode(
    LPWSTR  *pWcsString,
    LPSTR   utfString,
    BOOLEAN bAllocBuffer
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Service utility prototypes (leave these unpublished)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
SNMP_FUNC_TYPE
SnmpSvcInitUptime(
    );

DWORD
SNMP_FUNC_TYPE 
SnmpSvcGetUptime(
    );

DWORD
SNMP_FUNC_TYPE 
SnmpSvcGetUptimeFromTime(
    DWORD time
    );

SNMPAPI 
SNMP_FUNC_TYPE
SnmpSvcGenerateTrap(
    IN AsnObjectIdentifier * enterprise,
    IN AsnInteger            genericTrap,
    IN AsnInteger            specificTrap,
    IN AsnTimeticks          timeStamp,
    IN RFC1157VarBindList *  variableBindings
    );

SNMPAPI 
SNMP_FUNC_TYPE
SnmpSvcGenerateColdStartTrap(
    IN AsnInteger timeStamp
    );

SNMPAPI 
SNMP_FUNC_TYPE
SnmpSvcGenerateWarmStartTrap(
    IN AsnInteger timeStamp
    );

SNMPAPI 
SNMP_FUNC_TYPE
SnmpSvcGenerateLinkUpTrap(
    IN AsnInteger           timeStamp,
    IN RFC1157VarBindList * variableBindings
    );

SNMPAPI 
SNMP_FUNC_TYPE
SnmpSvcGenerateLinkDownTrap(
    IN AsnInteger           timeStamp,
    IN RFC1157VarBindList * variableBindings
    );

SNMPAPI 
SNMP_FUNC_TYPE
SnmpSvcGenerateAuthFailTrap(
    AsnInteger timeStamp
    );

VOID 
SNMP_FUNC_TYPE
SnmpSvcReportEvent(
    IN DWORD nMsgId,
    IN DWORD cSubStrings,
    IN LPSTR *SubStrings,
    IN DWORD nErrorCode
    );                  

VOID 
SNMP_FUNC_TYPE
SnmpSvcBufRevInPlace(
    IN OUT BYTE * pBuf, 
    IN     UINT   nLen   
    );

VOID 
SNMP_FUNC_TYPE
SnmpSvcBufRevAndCpy(
       OUT BYTE * pDstBuf,
    IN     BYTE * pSrcBuf,
    IN     UINT   nLen     
    );

BOOL 
SNMP_FUNC_TYPE
SnmpSvcAddrIsIpx(
    IN     LPSTR addrText,
       OUT char  pNetNum[],
       OUT char  pNodeNum[]
    );

BOOL 
SNMP_FUNC_TYPE
SnmpSvcAddrToSocket(
    IN     LPSTR             addrText,
       OUT struct sockaddr * addrEncoding
    );

AsnObjectIdentifier *
SNMP_FUNC_TYPE
SnmpSvcGetEnterpriseOID(
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP debugging definitions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_OUTPUT_TO_CONSOLE      0x1
#define SNMP_OUTPUT_TO_LOGFILE      0x2
#define SNMP_OUTPUT_TO_EVENTLOG     0x4
#define SNMP_OUTPUT_TO_DEBUGGER     0x8

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP debugging prototypes                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID 
SNMP_FUNC_TYPE
SnmpSvcSetLogLevel(
    IN INT nLevel
    );

VOID 
SNMP_FUNC_TYPE
SnmpSvcSetLogType(
    IN INT nOutput
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define asn_t                       asnType
#define asn_v                       asnValue
#define asn_n                       asnValue.number
#define asn_s                       asnValue.string
#define asn_sl                      asnValue.string.length
#define asn_ss                      asnValue.string.stream
#define asn_sd                      asnValue.string.dynamic
#define asn_o                       asnValue.object
#define asn_ol                      asnValue.object.idLength
#define asn_oi                      asnValue.object.ids
#define asn_l                       asnValue.sequence
#define asn_a                       asnValue.address
#define asn_c                       asnValue.counter
#define asn_g                       asnValue.gauge
#define asn_tt                      asnValue.timeticks
#define asn_x                       asnValue.arbitrary

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Support for old definitions (support disabled via SNMPSTRICT)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef SNMPSTRICT

#define dbgprintf                   SnmpUtilDbgPrint

#define SNMP_oiddisp                SnmpUtilPrintOid
#define SNMP_oidtoa                 SnmpUtilOidToA
#define SNMP_oidtoa2                SnmpUtilIdsToA

#define SNMP_bufrev                 SnmpUtilBufRevInPlace
#define SNMP_bufcpyrev              SnmpUtilBufRevAndCpy
#define addrtosocket                SnmpUtilAddrToSocket
#define isIPX                       SnmpUtilAddrIsIpx

#define DBGCONSOLEBASEDLOG          SNMP_OUTPUT_TO_CONSOLE 
#define DBGFILEBASEDLOG             SNMP_OUTPUT_TO_LOGFILE 
#define DBGEVENTLOGBASEDLOG         SNMP_OUTPUT_TO_EVENTLOG

#endif // SNMPSTRICT

#ifdef __cplusplus
}
#endif

#endif // _INC_SNMPUTIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\stropts.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stropts.h

Abstract:

    This module defines the STREAMS ioctl message interface.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/*
 * Streams ioctl message interface
 *
 * @(#)stropts.h	1.19 (Spider) 91/11/27
 */

#ifndef _SYS_STROPTS_
#define _SYS_STROPTS_

#ifndef _NTDDSTRM_
#include <ntddstrm.h>
#endif


/*
 * Read options
 */

#define RNORM	0x00			/* Normal - bytes stream */
#define RMSGD	0x01			/* Message, non-discard mode */
#define RMSGN	0x02			/* Message, discard mode */

#define RMASK	0x0F			/* mask for read options */

/*
 * Protocol read options
 */

#define	RPROTNORM	0x00		/* Fail reads with EBADMSG */
#define RPROTDIS	0x10		/* Discard proto part */
#define RPROTDAT	0x20		/* Turn proto part into data */

#define RPROTMASK	0xF0		/* mask for protocol read options */

/*
 * Values for I_ATMARK argument
 */

#define	ANYMARK		0		/* check if message is marked */
#define	LASTMARK	1		/* check if last one marked */

/*
 * Value for I_SWROPT argument
 */

#define	NOSNDZERO	0		/* disallow zero length sends */
#define	SNDZERO		1		/* permit zero length sends */

/*
 * STREAMS ioctl defines
 */

#define STR             ('S'<<8)
#define I_NREAD         (STR|1)
#define I_PUSH          (STR|2)
#define I_POP           (STR|3)
#define I_LOOK          (STR|4)
#define I_FLUSH         (STR|5)
#define I_SRDOPT        (STR|6)
#define I_GRDOPT        (STR|7)
#define I_STR           (STR|8)
#define I_SETSIG        (STR|9)
#define I_GETSIG        (STR|10)
#define I_FIND          (STR|11)
#define I_LINK          (STR|12)
#define I_UNLINK        (STR|13)
#define I_PEEK          (STR|15)
#define I_FDINSERT      (STR|16)
#define I_SENDFD        (STR|17)
#define I_RECVFD        (STR|18)
#ifdef SVR2
#define I_GETMSG        (STR|19)
#define I_PUTMSG        (STR|20)
#define I_GETID		(STR|21)
#define I_POLL		(STR|22)
#endif /*SVR2*/
#define	I_SWROPT	(STR|23)
#define	I_GWROPT	(STR|24)
#define	I_LIST		(STR|25)
#define	I_ATMARK	(STR|26)
#define	I_SETCLTIME	(STR|27)
#define	I_GETCLTIME	(STR|28)
#define	I_PLINK		(STR|29)
#define	I_PUNLINK	(STR|30)
#define I_DEBUG         (STR|31)
#define	I_CLOSE		(STR|32)


#define MUXID_ALL	-1

/*
 * Structure for I_FDINSERT ioctl
 */

struct strfdinsert {
        struct strbuf ctlbuf;
        struct strbuf databuf;
        long          flags;
        HANDLE        fildes;
        int           offset;
};


/*
 * Structures for I_DEBUG ioctl
 */
typedef enum _str_trace_options {
    MSG_TRACE_PRINT =      0x00000001,
    MSG_TRACE_FLUSH =      0x00000002,
    MSG_TRACE_ON =         0x00000004,
    MSG_TRACE_OFF =        0x00000008,
    POOL_TRACE_PRINT =     0x00000010,
    POOL_TRACE_FLUSH =     0x00000020,
    POOL_TRACE_ON =        0x00000040,
    POOL_TRACE_OFF =       0x00000080,
    POOL_FAIL_ON =         0x00000100,
    POOL_FAIL_OFF =        0x00000200,
    LOCK_TRACE_ON =        0x00000400,
    LOCK_TRACE_OFF =       0x00000800,
    QUEUE_PRINT =          0x00001000,
    BUFFER_PRINT =         0x00002000,
    POOL_LOGGING_ON =      0x00004000,
    POOL_LOGGING_OFF =     0x00008000
} str_trace_options;


struct strdebug {
    ULONG  trace_cmd;
};


/*
 * stream I_PEEK ioctl format
 */

struct strpeek {
	struct strbuf ctlbuf;
	struct strbuf databuf;
	long          flags;
};

/*
 * receive file descriptor structure
 */
struct strrecvfd {
#ifdef INKERNEL
        union {
                struct file *fp;
                int fd;
        } f;
#else
        int fd;
#endif
        unsigned short uid;
        unsigned short gid;
        char fill[8];
};

#define FMNAMESZ	8

struct str_mlist {
	char l_name[FMNAMESZ+1];
};

struct str_list {
	int sl_nmods;
	struct str_mlist *sl_modlist;
};

/*
 * get/putmsg flags
 */

#define RS_HIPRI	1	/* High priority message */

#define MORECTL		1
#define MOREDATA	2


/*
 * M_SETSIG flags
 */

#define S_INPUT		1
#define S_HIPRI		2
#define S_OUTPUT	4
#define S_MSG		8
#define S_ERROR		16
#define S_HANGUP	32

/*
 * Flags for MFLUSH messages
 */
#define FLUSHW		01	/* flush downstream */
#define FLUSHR		02	/* flush upstream */
#define FLUSHRW		(FLUSHR | FLUSHW)

#endif /* _SYS_STROPTS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\validate.h ===
/*++

Copyright (c) 2002 Microsoft Corporation


Module Name:

    validate.h

Abstract:

    This module contains declarations for the code to perform data
    validation for IPSec user mode componets

Authors:

    RaymondS

Environment

    User Level: Win32

Revision History:
    21 APR 2002: Added ValidateFilterAction
    

--*/

DWORD
ValidateFilterAction(
    FILTER_ACTION FilterAction
    );

DWORD
ValidateInterfaceType(
    IF_TYPE InterfaceType
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\tcpsvcs.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Tcpsvcs.h

Abstract:

    Header file fr TCP/IP services.

Author:

    David Treadwell (davidtr)   7-27-93

Revision History:

--*/

#ifndef _TCPSVCS_
#define _TCPSVCS_

//
// Service DLLs loaded into tcpsvcs.exe all export the same main
// entry point.  TCPSVCS_ENTRY_POINT defines that name.
//
// Note that TCPSVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define TCPSVCS_ENTRY_POINT         ServiceEntry
#define TCPSVCS_ENTRY_POINT_STRING  "ServiceEntry"

//
// Name for the common RPC pipe shared by all the RPC servers in tcpsvcs.exe.
// Note:  Because version 1.0 of WinNt had seperate names for each server's
// pipe, the client side names have remained the same.  Mapping to the new
// name is handled by the named pipe file system.
//

#define TCPSVCS_RPC_PIPE           L"nttcpsvcs"

//
// Start and stop RPC server entry point prototype.
//

typedef
DWORD
(*PTCPSVCS_START_RPC_SERVER_LISTEN) (
    VOID
    );

typedef
DWORD
(*PTCPSVCS_STOP_RPC_SERVER_LISTEN) (
    VOID
    );

//
// Structure containing "global" data for the various DLLs.
//

typedef struct _TCPSVCS_GLOBAL_DATA {

    //
    // Entry points provided by TCPSVCS.EXE.
    //

    PTCPSVCS_START_RPC_SERVER_LISTEN  StartRpcServerListen;
    PTCPSVCS_STOP_RPC_SERVER_LISTEN   StopRpcServerListen;

} TCPSVCS_GLOBAL_DATA, *PTCPSVCS_GLOBAL_DATA;

//
// Service DLL entry point prototype.
//

typedef
VOID
(*PTCPSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPTSTR argv[],
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );

#endif	// ndef _TCPSVCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\unimdmp.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1996
//
// File: unimdmp.h
//
// This file contains private modem structures and defines shared
// between Unimodem components, and components that invoke the Unimodem
// class installer.
//
//---------------------------------------------------------------------------

#ifndef __UNIMDMP_H__
#define __UNIMDMP_H__

#include <unimodem.h>

#ifdef __cplusplus
extern "C" {
#endif


#ifndef __ROVCOMM_H__
#define MAX_BUF_SHORT               32
#endif // __ROVCOMM_H__

// Unattended install parameters
// This structure is published in
// sdk\inc\unimodem.h as UM_INSTALLPARAMS;
// do not alter it
typedef struct _tagInstallParams
{
    DWORD   Flags;
    TCHAR   szPort[MAX_BUF_SHORT];
    TCHAR   szInfName[MAX_PATH];
    TCHAR   szInfSect[LINE_LEN];
    
} INSTALLPARAMS, FAR *LPINSTALLPARAMS;
    
// Unattended install flags;
// published in sdk\inc\unimodem.h;
// keep sinchronized with sdk\inc\unimodem.h
#define MIPF_NT4_UNATTEND       0x1
    // Take the information about what modem to install
    // from the unattended.txt file
#define MIPF_DRIVER_SELECTED    0x2
    // The modem driver is selected, just register
    // and install it
#define MIPF_CLONE_MODEM        0x4
    // The (hdi, pdevinfo) the class installer is called for
    // has to be installed on aditional ports

// This structure may be specified in
// the SP_INSTALLWIZARD_DATA's PrivateData field.
// It is published in sdk\inc\unimodem.h as
// UM_INSTALL_WIZARD; do not alter it
typedef struct tagMODEM_INSTALL_WIZARD
{
    DWORD       cbSize;
    DWORD       Flags;              // MIWF_ bit field
    DWORD       ExitButton;         // PSBTN_ value
    LPARAM      PrivateData;
    INSTALLPARAMS InstallParams;
    
} MODEM_INSTALL_WIZARD, * PMODEM_INSTALL_WIZARD;

// 
// Private Exports from MODEMUI.DLL
//

DWORD
APIENTRY
UnimodemGetDefaultCommConfig(
    IN        HKEY  hKey,
    IN OUT    LPCOMMCONFIG pcc,
    IN OUT    LPDWORD pdwSize
    );

typedef DWORD
(*PFNUNIMODEMGETDEFAULTCOMMCONFIG)(
    IN        HKEY  hKey,
    IN OUT    LPCOMMCONFIG pcc,
    IN OUT    LPDWORD pdwSize
    );

DWORD
APIENTRY
UnimodemDevConfigDialog(
    IN     LPCTSTR pszFriendlyName,
    IN     HWND hwndOwner,
    IN     DWORD dwType,                          // One of UMDEVCFGTYPE_*
    IN     DWORD dwFlags,                         // Reserved, must be 0
    IN     void *pvConfigBlobIn,
    OUT    void *pvConfigBlobOut,
    IN     LPPROPSHEETPAGE pExtPages,     OPTIONAL   // PPages to add
    IN     DWORD cExtPages
    );

typedef DWORD
(*PFNUNIMODEMDEVCONFIGDIALOG)(
    IN     LPCTSTR,
    IN     HWND,
    IN     DWORD,
    IN     DWORD,
    IN     void *,
    OUT    void *,
    IN     LPPROPSHEETPAGE,   OPTIONAL
    IN     DWORD
    );

DWORD
APIENTRY
UnimodemGetExtendedCaps(
    IN        HKEY  hKey,
    IN OUT    LPDWORD pdwTotalSize,
    OUT    MODEM_CONFIG_HEADER *pFirstObj // OPTIONAL
    );

typedef DWORD
(*PFNUNIMODEMGETEXTENDEDCAPS)(
    IN        HKEY  hKey,
    IN OUT    MODEM_CONFIG_HEADER *pFirstObj,
    IN OUT    LPDWORD pdwTotalSize
    );


#define UMDEVCFGTYPE_COMM 0x1

//
// TAPI3 CSA TSP-MSP BLOB
//
typedef struct
{
    DWORD dwSig; // Set to SIG_CSAMSPTSPBLOB
    #define SIG_CSATSPMSPBLOB 0x840cb29c

    DWORD dwTotalSize;

    DWORD dwCmd;        // One of the CSATSPMSPCMD_ constants.
        #define CSATSPMSPCMD_CONNECTED        0x1
        #define CSATSPMSPCMD_DISCONNECTED     0x2

    GUID  PermanentGuid;

} CSATSPMSPBLOB;

#ifdef __cplusplus
}
#endif


#endif  // __UNIMDMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\tunuser.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tunuser.h

Abstract:

    Constants and types to access the TUN driver.
    Users must also include ntddndis.h

Author:

Environment:

    User/Kernel mode.

Revision History:


--*/



#ifndef __TUNUSER__H
#define __TUNUSER__H


#define OID_CUSTOM_TUNMP_INSTANCE_ID            0xff54554e

#define IOCTL_TUN_GET_MEDIUM_TYPE \
        CTL_CODE (FILE_DEVICE_NETWORK, 0x301, METHOD_BUFFERED, FILE_WRITE_ACCESS | FILE_READ_ACCESS)

#define IOCTL_TUN_GET_MTU \
        CTL_CODE (FILE_DEVICE_NETWORK, 0x302, METHOD_BUFFERED, FILE_WRITE_ACCESS | FILE_READ_ACCESS)

#define IOCTL_TUN_GET_PACKET_FILTER \
        CTL_CODE (FILE_DEVICE_NETWORK, 0x303, METHOD_BUFFERED, FILE_WRITE_ACCESS | FILE_READ_ACCESS)

#define IOCTL_TUN_GET_MINIPORT_NAME \
        CTL_CODE (FILE_DEVICE_NETWORK, 0x304, METHOD_BUFFERED, FILE_WRITE_ACCESS | FILE_READ_ACCESS)

#define TUN_ETH_MAC_ADDR_LEN        6

#define TUN_CARD_ADDRESS                "\02\0TUN\01"

#include <pshpack1.h>

typedef struct _TUN_ETH_HEADER
{
    UCHAR       DstAddr[TUN_ETH_MAC_ADDR_LEN];
    UCHAR       SrcAddr[TUN_ETH_MAC_ADDR_LEN];
    USHORT      EthType;

} TUN_ETH_HEADER;

typedef struct _TUN_ETH_HEADER UNALIGNED * PTUN_ETH_HEADER;

#include <poppack.h>


#endif // __TUNUSER__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\unixapis.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    uemul.h

Abstract:

    Prototypes for Unix emulation routines used by libstcp and the tcpcmd
    utilities.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     10-29-91     created
    sampa       11-16-91     added getopt

Notes:

    Exports:

	getlogin
	getpass
    getopt

--*/


#define MAX_USERNAME_SIZE   256


int
getlogin(
    char *UserName,
    int   len
    );


char *
getpass(
    char *prompt
    );

char *
getusername(
    char *prompt
    );

int
getopt(
	int,
	char **,
	char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\wlbsctrl.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbsctrl.c

Abstract:

    Windows Load Balancing Service (WLBS)
    API - specification.  This set of API is for internal use only.  
        another set of WMI API is provided for public use.

Author:

    fengsun

--*/

#ifndef _WLBSCTRL_H_
#define _WLBSCTRL_H_

#include "wlbsparm.h"

/* These flags indicate which options are being used/specified and/or additional information for the remote protocol. */
#define NLB_OPTIONS_QUERY_CLUSTER_MEMBER   0x00000001               /* The initiator is part of the cluster it is querying. */
#define NLB_OPTIONS_QUERY_HOSTNAME         0x00000002               /* The hostname was returned as part of a remote query. */
#define NLB_OPTIONS_QUERY_CONVERGENCE      0x00000004               /* Convergence information was provided as part of a local query. */
#define NLB_OPTIONS_PORTS_VIP_SPECIFIED    0x00000001               /* A VIP has been specified to check against. */

/* These are the supported connection notifications. */
typedef enum {                 
    NLB_CONN_UP = 0,                                                /* A connection (session) is going up. */
    NLB_CONN_DOWN,                                                  /* A connection (session) is going down. */
    NLB_CONN_RESET                                                  /* A connection (session) is being reset. */
} NLB_OPTIONS_CONN_NOTIFICATION_OPERATION;

/* IOCTL input buffer for connection notification from user space.  This notification
   is initiated by an upper-layer protocol to inform NLB that a connection/session of
   a particular protocol type is going up between a client and server, which will allow
   NLB to track the session to provide session stickiness when bucket mappings change. */
typedef struct {
    NLB_OPTIONS_CONN_NOTIFICATION_OPERATION Operation;              /* The operation to perform - UP/DOWN/RESET. */    

    ULONG  ClientIPAddress;                                         /* The IP address of the client in network byte order. */
    ULONG  ServerIPAddress;                                         /* The IP address of the server in network byte order. */
    USHORT ClientPort;                                              /* The client port number (or other designation). */
    USHORT ServerPort;                                              /* The server port number (or other designation). */
    USHORT Protocol;                                                /* The protocol of the packet in question. */
    USHORT Reserved;                                                /* For byte alignment - reserved for later. */
} NLB_OPTIONS_CONN_NOTIFICATION, * PNLB_OPTIONS_CONN_NOTIFICATION;

/* This structure contains the configuration of an NLB port rule, used to relay
   port rule information from the kernel up to user-space. */
typedef struct {
    ULONG Valid;                                                    /* Whether or not the port rule is valid - not used in the kernel. */
    ULONG Code;                                                     /* The rule code used for error checking and cluster port rule consistency. */
    ULONG VirtualIPAddress;                                         /* The virtual IP address to which this rule applies. */
    ULONG StartPort;                                                /* The start port of the port range. */
    ULONG EndPort;                                                  /* The end port of the port range. */
    ULONG Protocol;                                                 /* The protocol(s) to which the rule applies. */
    ULONG Mode;                                                     /* The filtering mode for this rule. */

    union {
        struct {
            ULONG  Priority;                                        /* For single host filtering, this handling host's priority. */
        } SingleHost;

        struct {
            USHORT Equal;                                           /* For multiple host filtering, whether the distribution is equal or not. */
            USHORT Affinity;                                        /* For multiple host filtering, the client affinity setting. */
            ULONG  LoadWeight;                                      /* For multiple host filtering, the load weight for this host if the distribution is unequal. */
        } MultipleHost;
    };
} NLB_OPTIONS_PARAMS_PORT_RULE, * PNLB_OPTIONS_PARAMS_PORT_RULE;

/* This structure encapsulates the BDA teaming state for an NLB instance and is used
   to relay BDA static configuration information from the kernel up to user-space. */
typedef struct {
    WCHAR TeamID[CVY_MAX_BDA_TEAM_ID + 1];                          /* The team to which this adapter belongs - MUST be a {GUID}. */
    ULONG Active;                                                   /* Whether or not this adapter is part of a team. */
    ULONG Master;                                                   /* Whether or not this team member is the master of its team. */
    ULONG ReverseHash;                                              /* Whether or not this team member is reverse-hashing. */
} NLB_OPTIONS_PARAMS_BDA, * PNLB_OPTIONS_PARAMS_BDA;

/* This structure contains some statistics that may want to be monitored from user-space. */
typedef struct {
    ULONG ActiveConnections;                                        /* The current number of connections being serviced. */
    ULONG DescriptorsAllocated;                                     /* The number of descriptors allocated so far. */
} NLB_OPTIONS_PARAMS_STATISTICS, * PNLB_OPTIONS_PARAMS_STATISTICS;

/* This structure is used to retrieve the driver's snapshot of the NLB parameters
   for a given cluster on the local host.  Under normal circumstances, these should
   be the same as the parameters in the registry unless (1) the user has changed 
   the NLB registry parameters without performing a "wlbs reload", or (2) the para-
   meters in the registry are erred, in which case the driver will retain its current
   settings, rather than use the bad parameters in the registry (note that this only
   happens as the result of a "wlbs reload" - on bind, the driver uses the registry
   parameters regardless of whether or not they are valid. */
typedef struct {
    ULONG Version;                                                  /* The version of the parameters. */
    ULONG EffectiveVersion;                                         /* The effective version of NLB that this cluster is operating in. */
    ULONG HostPriority;                                             /* The host priority. */
    ULONG HeartbeatPeriod;                                          /* The periodicity of heartbeats, in miliseconds. */
    ULONG HeartbeatLossTolerance;                                   /* The tolerance for lost heartbeats from other cluster hosts. */
    ULONG NumActionsAlloc;                                          /* The number of actions to allocate for handling remote control requests. */
    ULONG NumPacketsAlloc;                                          /* The number of NDIS packets to initially allocate. */
    ULONG NumHeartbeatsAlloc;                                       /* The number of heartbeat frames to allocate. */
    ULONG InstallDate;                                              /* The NLB install date - essentially unused. */
    ULONG RemoteMaintenancePassword;                                /* The remote maintanance password - obsolete? */
    ULONG RemoteControlPassword;                                    /* The remote control password. */
    ULONG RemoteControlPort;                                        /* The remote control port, 2504 by default. */
    ULONG RemoteControlEnabled;                                     /* Whether or not remote control is enabled. It is load balanced if not enabled. */
    ULONG NumPortRules;                                             /* The number of configured port rules. */
    ULONG ConnectionCleanUpDelay;                                   /* The length of time to block "dirty" connections. */
    ULONG ClusterModeOnStart;                                       /* The preferred initial start state of this cluster on boot (or bind). */
    ULONG HostState;                                                /* The initial start state of this cluster on boot (or bind). */
    ULONG PersistedStates;                                          /* The states which will be persisted across reboots. */
    ULONG DescriptorsPerAlloc;                                      /* The number of connection descriptors to allocate per allocation. */
    ULONG MaximumDescriptorAllocs;                                  /* The maximum number of times to allocate connection descriptors. */
    ULONG ScaleClient;                                              /* Obsolete? */
    ULONG NBTSupport;                                               /* Whether or not to support NBT - this may not even work anymore? */
    ULONG MulticastSupport;                                         /* Whether or not this cluster is in multicast mode. */
    ULONG MulticastSpoof;                                           /* Whether or not to spoof MAC addresses in multicast mode. */
    ULONG IGMPSupport;                                              /* Whether or not this cluster is in IGMP multicast mode. */
    ULONG MaskSourceMAC;                                            /* Whether or not to mask the source MAC addresses from network switches. */
    ULONG NetmonReceiveHeartbeats;                                  /* Whether or not to allow heartbeats up the stack for netmon sniffing. */
    ULONG ClusterIPToMAC;                                           /* Whether or not to automatically generate cluster MAC addresses from cluster IP addresses. */
    ULONG IPChangeDelay;                                            /* The length of time to block ARPs after the cluster IP address has changed. */
    ULONG TCPConnectionTimeout;                                     /* The timeout for expired TCP connection descriptors. */
    ULONG IPSecConnectionTimeout;                                   /* The timeout for expired IPSec connection descriptors. */
    ULONG FilterICMP;                                               /* Whether or not ICMP filtering is enabled. */
    ULONG IdentityHeartbeatPeriod;                                  /* Period with which identity heartbeats are transmitted (in ms) */
    ULONG IdentityHeartbeatEnabled;                                 /* Whether or not identity heartbeats are transmitted */

    WCHAR ClusterIPAddress[CVY_MAX_CL_IP_ADDR + 1];                 /* The cluster IP address. */
    WCHAR ClusterNetmask[CVY_MAX_CL_NET_MASK + 1];                  /* The netmask for the cluster IP address. */
    WCHAR DedicatedIPAddress[CVY_MAX_DED_IP_ADDR + 1];              /* The dedicated IP address. */
    WCHAR DedicatedNetmask[CVY_MAX_DED_NET_MASK + 1];               /* The netmask for the dedicated IP address. */
    WCHAR ClusterMACAddress[CVY_MAX_NETWORK_ADDR + 1];              /* The cluster MAC address. */
    WCHAR DomainName[CVY_MAX_DOMAIN_NAME + 1];                      /* The cluster name - www.microsoft.com. */
    WCHAR IGMPMulticastIPAddress[CVY_MAX_CL_IGMP_ADDR + 1];         /* The IGMP multicast IP address. */
    WCHAR HostName[CVY_MAX_FQDN + 1];                               /* The hostname.domain for this host. */

    NLB_OPTIONS_PARAMS_BDA       BDATeaming;                        /* The BDA teaming parameters for this NLB instance. */
    NLB_OPTIONS_PARAMS_PORT_RULE PortRules[CVY_MAX_RULES - 1];      /* The port rules for this cluster. */

    NLB_OPTIONS_PARAMS_STATISTICS Statistics;                       /* Some driver-level statistics. */
} NLB_OPTIONS_PARAMS, * PNLB_OPTIONS_PARAMS;

/* This structure contains the configuration and state of a single BDA team
   member including its member ID and state.  This is used to relay BDA teaming
   membership and state information from the kernel up to user-level applications. */
typedef struct {
    ULONG ClusterIPAddress;                                         /* The cluster IP address of this team member. */
    ULONG Master;                                                   /* Whether or not this adapter is the master of its team. */
    ULONG ReverseHash;                                              /* Whether or not this adapter is configured to reverse-hash. */
    ULONG MemberID;                                                 /* This team member's unique host ID. */
} NLB_OPTIONS_BDA_MEMBER, * PNLB_OPTIONS_BDA_MEMBER;

/* This structure represents a BDA team, including the current state, membership
   and list of current members.  This is used to relay teaming state from the
   kernel up to user-level applications. */
typedef struct {
    ULONG Active;                                                   /* Whether or not the team is actively handling traffic. */
    ULONG MembershipCount;                                          /* The number of members in the team. */
    ULONG MembershipFingerprint;                                    /* A "fingerprint" of team members, used for consistency checking. */
    ULONG MembershipMap;                                            /* A bitmap of team members, indexed by unique host ID. */
    ULONG ConsistencyMap;                                           /* A bitmap of the team members in a consistent state. */
    ULONG Master;                                                   /* The cluster IP address of the team's master. */
    
    NLB_OPTIONS_BDA_MEMBER Members[CVY_MAX_ADAPTERS];               /* The state and configuration of each team member. */
} NLB_OPTIONS_BDA_TEAM, * PNLB_OPTIONS_BDA_TEAM;

/* This structure is used to convey the current state of a BDA team to a user-
   space application.  Given a team ID (GUID), the structure provides the team
   membership, state and the configuration of each member amongst other things. */
typedef struct {
    IN WCHAR TeamID[CVY_MAX_BDA_TEAM_ID + 1];                       /* The team ID - MUST be a {GUID}. */

    NLB_OPTIONS_BDA_TEAM Team;                                      /* The configuration and state of the given team. */
} NLB_OPTIONS_BDA_TEAMING, * PNLB_OPTIONS_BDA_TEAMING;

/* These are the possible responses from the load packet filter
   state query, which returns accept/reject status for a given
   IP tuple and protocol, based on the current driver state. */
typedef enum {
    NLB_REJECT_LOAD_MODULE_INACTIVE = 0,                            /* Packet rejected because the load module is inactive. */
    NLB_REJECT_CLUSTER_STOPPED,                                     /* Packet rejected because NLB is stopped on this adapter. */
    NLB_REJECT_PORT_RULE_DISABLED,                                  /* Packet rejected because the applicable port rule's filtering mode is disabled. */
    NLB_REJECT_CONNECTION_DIRTY,                                    /* Packet rejected because the connection was marked dirty.  */
    NLB_REJECT_OWNED_ELSEWHERE,                                     /* Packet rejected because the packet is owned by another host.  */
    NLB_REJECT_BDA_TEAMING_REFUSED,                                 /* Packet rejected because BDA teaming refused to process it. */
    NLB_REJECT_DIP,                                                 /* Packet rejected because its was sent to the DIP of another cluster member. */
    NLB_REJECT_HOOK,                                                /* Packet rejected because the query hook unconditionally accepted it. */
    NLB_ACCEPT_UNCONDITIONAL_OWNERSHIP,                             /* Packet accepted because this host owns it unconditionally (optimized mode). */
    NLB_ACCEPT_FOUND_MATCHING_DESCRIPTOR,                           /* Packet accepted because we found a matching connection descriptor. */
    NLB_ACCEPT_PASSTHRU_MODE,                                       /* Packet accepted because the cluster is in passthru mode. */
    NLB_ACCEPT_DIP,                                                 /* Packet accepted because its was sent to a bypassed address. */
    NLB_ACCEPT_BROADCAST,                                           /* Packet accepted because its was sent to a bypassed address. */
    NLB_ACCEPT_REMOTE_CONTROL_REQUEST,                              /* Packet accepted because it is an NLB remote control packet. */
    NLB_ACCEPT_REMOTE_CONTROL_RESPONSE,                             /* Packet accepted because it is an NLB remote control packet. */
    NLB_ACCEPT_HOOK,                                                /* Packet accepted because the query hook unconditionally accepted it. */
    NLB_ACCEPT_UNFILTERED,                                          /* Packet accepted because this packet type is not filtered by NLB. */
    NLB_UNKNOWN_NO_AFFINITY                                         /* Packet fate is unknown because a client port was not specified, but the 
                                                                       applicable port rule is configured for "No" affinity. */
} NLB_OPTIONS_QUERY_PACKET_FILTER_RESPONSE;

#define NLB_FILTER_FLAGS_CONN_DATA  0x0
#define NLB_FILTER_FLAGS_CONN_UP    0x1
#define NLB_FILTER_FLAGS_CONN_DOWN  0x2
#define NLB_FILTER_FLAGS_CONN_RESET 0x4

/* This structure is used to query packet filtering information from the driver
   about a particular connection.  Given a IP tuple (client IP, client port, 
   server IP, server port) and a protocol, determine whether or not this host 
   would accept the packet and why or why not. It is important that this is 
   performed completely unobtrusively and has no side-effects on the actual 
   operation of NLB and the load module. */
typedef struct {
    IN ULONG  ClientIPAddress;                                      /* The IP address of the client in network byte order. */
    IN ULONG  ServerIPAddress;                                      /* The IP address of the server in network byte order. */

    IN USHORT ClientPort;                                           /* The client port number. */
    IN USHORT ServerPort;                                           /* The server port number. */
    IN USHORT Protocol;                                             /* The protocol of the packet in question. */
    IN UCHAR  Flags;                                                /* Flags, including TCP SYN, FIN, RST, etc. */
    UCHAR Reserved1;                                                /* For byte alignment - reserved for later. */
    
    NLB_OPTIONS_QUERY_PACKET_FILTER_RESPONSE Accept;                /* The response - reason for accepting or rejecting the packet. */
    ULONG Reserved2;                                                /* To keep 8-byte alignment */
    
    struct {
        USHORT        Valid;                                        /* Whether or not the driver has filled in the descriptor information. */
        USHORT        Reserved1;                                    /* For byte alignment - reserved for later. */
        USHORT        Alloc;                                        /* Whether this descriptor is from the hash table or queue. */
        USHORT        Dirty;                                        /* Whether this connection is dirty or not. */
        ULONG         RefCount;                                     /* The number of references on this descriptor. */
        ULONG         Reserved2;                                    /* For 8-byte alignment */
    } DescriptorInfo;
    
    struct {
        USHORT        Valid;                                        /* Whether or not the driver has filled in the hashing information. */
        USHORT        Reserved1;                                    /* For byte alignment - reserved for later. */
        ULONG         Bin;                                          /* The "bucket" which this tuple mapped to - from 0 to 59. */
        ULONG         ActiveConnections;                            /* The number of active connections on this "bucket". */
        ULONG         Reserved2;                                    /* For 8-byte alignment */
        ULONGLONG     CurrentMap;                                   /* The current "bucket" map for the applicable port rule. */
        ULONGLONG     AllIdleMap;                                   /* The all idle "bucket" map for the applicable port rule. */
    } HashInfo;
} NLB_OPTIONS_PACKET_FILTER, * PNLB_OPTIONS_PACKET_FILTER;

/* These are the possible states of a port rule. */
typedef enum {
    NLB_PORT_RULE_NOT_FOUND = 0,                                    /* The port rule was not found. */
    NLB_PORT_RULE_ENABLED,                                          /* The port rule is enabled.  Load weight = User-specified load weight. */
    NLB_PORT_RULE_DISABLED,                                         /* The port rule is disabled.  Load weight = 0. */
    NLB_PORT_RULE_DRAINING                                          /* The port rule is draining.  Load weight = 0 and servicing exisiting connections. */
} NLB_OPTIONS_PORT_RULE_STATUS;

/* This structure contains some relevant packet handling statistics including 
   the number of packets and bytes accepted and dropped. */
typedef struct {
    struct {
        ULONGLONG Accepted;                                         /* The number of packets accepted on this port rule. */
        ULONGLONG Dropped;                                          /* The number of packets dropped on this port rule. */
    } Packets;

    struct {
        ULONGLONG Accepted;                                         /* The number of bytes accepted on this port rule.  Not yet used. */
        ULONGLONG Dropped;                                          /* The number of bytes dropped on this port rule.  Not yet used. */ 
    } Bytes;
} NLB_OPTIONS_PACKET_STATISTICS, * PNLB_OPTIONS_PACKET_STATISTICS;

/* This structure is used to query the state of a port rule.  Like the other port rule
   commands, the port rule is specified by a port within the port rule range.  This 
   operation will retrieve the state of the port rule and some packet handling statistics. */
typedef struct {
    IN ULONG  VirtualIPAddress;                                     /* The VIP to distinguish port rules whose ranges overlap. */
    IN USHORT Num;                                                  /* The port - used to identify the applicable port rule. */
    USHORT Reserved1;

    NLB_OPTIONS_PORT_RULE_STATUS  Status;                           /* The port rule state - enabled, disabled, draining, etc. */
    ULONG                         Reserved2;                        /* To preserve 8-byte alignment. */
     
    NLB_OPTIONS_PACKET_STATISTICS Statistics;                       /* Packet handling statistics for this port rule. */
} NLB_OPTIONS_PORT_RULE_STATE, * PNLB_OPTIONS_PORT_RULE_STATE;

#define NLB_QUERY_TIME_INVALID 0xffffffff

/* This structure is used by user-level applications who communicate with the NLB
   APIs, and who could care less whether the operation is local or remote. */
typedef union {
    struct {
        ULONG flags;                                                /* These flags indicate which options fields have been specified. */
        WCHAR hostname[CVY_MAX_HOST_NAME + 1];                      /* Host name filled in by NLB on remote control reply. */
        ULONG NumConvergences;                                      /* The number of convergences since this host joined the cluster. */
        ULONG LastConvergence;                                      /* The amount of time since the last convergence, in seconds. */
    } query;
    
    struct {
        IN ULONG                        flags;                      /* These flags indicate which options fields have been specified. */
        
        union {
            NLB_OPTIONS_PARAMS          params;                     /* This is the output buffer for querying the driver parameters & state. */
            NLB_OPTIONS_BDA_TEAMING     bda;                        /* This is the output buffer for querying the BDA teaming state. */
            NLB_OPTIONS_PORT_RULE_STATE port;                       /* This is the output buffer for querying the state of a port rule. */
            NLB_OPTIONS_PACKET_FILTER   filter;                     /* This is the output buffer for querying the filtering algorithm. */
        };
    } state;
    
    struct {
        ULONG flags;                                                /* These flags indicate which options fields have been specified. */
        ULONG vip;                                                  /* For virtual clusters, the VIP, which can be 0x00000000, 0xffffffff or a specific VIP. */
    } port;
    
    struct {
        ULONG                         flags;                        /* These flags indicate which options fields have been specified. */
        NLB_OPTIONS_CONN_NOTIFICATION conn;                         /* The input/output buffer for connection notifications from upper-layer protocols. */
    } notification;

    struct {
        WCHAR fqdn[CVY_MAX_FQDN + 1];                               /* Fully qualified domain name from from the local identity cache */
    } identity;
} NLB_OPTIONS, * PNLB_OPTIONS;

#ifndef KERNEL_MODE /* DO NOT include this malarky if this file is included in kernel mode.  The
                       data structures above are shared between kernel and user mode IOCTLs, so
                       the driver needs to include this file, but not the junk below. */

#define CVY_MAX_HOST_NAME        100

#define WLBS_API_VER_MAJOR       2       /* WLBS control API major version. */
#define WLBS_API_VER_MINOR       0       /* WLBS control API minor version. */
#define WLBS_API_VER             (WLBS_API_VER_MINOR | (WLBS_API_VER_MAJOR << 8))
                                         /* WLBS control API version. */
#define WLBS_PRODUCT_NAME        "WLBS"
                                         /* Default product name used for API
                                            initialization. */


#define WLBS_MAX_HOSTS           32      /* Maximum number of cluster hosts. */
#define WLBS_MAX_RULES           32      /* Maximum number of port rules. */



#define WLBS_ALL_CLUSTERS        0       /* Used to specify all clusters in
                                            WLBS...Set routines. */
#define WLBS_LOCAL_CLUSTER       0       /* Used to specify that cluster
                                            operations are to be performed on the
                                            local host. WLBS_LOCAL_HOST value
                                            below has to be used for the host
                                            argument when using
                                            WLBS_LOCAL_CLUSTER. */
#define WLBS_LOCAL_HOST          ((DWORD)-2) /* When specifying WLBS_LOCAL_CLUSTER,
                                            this value should be used for the
                                            host argument. */
#define WLBS_DEFAULT_HOST        0       /* Used to specify that remote cluster
                                            operations are to be performed on
                                            the default host. */
#define WLBS_ALL_HOSTS           0xffffffff
                                         /* Used to specify that remote cluster
                                            operation is to be performed on all
                                            hosts. */
#define WLBS_ALL_PORTS           0xffffffff
                                         /* Used to specify all load-balanced
                                            port rules as the target for
                                            enable/disable/drain commands. */


/* WLBS return values. Windows Sockets errors are returned 'as-is'. */

#define WLBS_OK                  1000    /* Success. */
#define WLBS_ALREADY             1001    /* Cluster mode is already stopped/
                                            started, or traffic handling is
                                            already enabled/disabled on specified
                                            port. */
#define WLBS_DRAIN_STOP          1002    /* Cluster mode stop or start operation
                                            interrupted connection draining
                                            process. */
#define WLBS_BAD_PARAMS          1003    /* Cluster mode could not be started
                                            due to configuration problems
                                            (bad registry parameters) on the
                                            target host. */
#define WLBS_NOT_FOUND           1004    /* Port number not found among port
                                            rules. */
#define WLBS_STOPPED             1005    /* Cluster mode is stopped on the
                                            host. */
#define WLBS_CONVERGING          1006    /* Cluster is converging. */
#define WLBS_CONVERGED           1007    /* Cluster or host converged
                                            successfully. */
#define WLBS_DEFAULT             1008    /* Host is converged as default host. */
#define WLBS_DRAINING            1009    /* Host is draining after
                                            WLBSDrainStop command. */
#define WLBS_PRESENT             1010    /* WLBS is installed on this host.
                                            Local operations possible. */
#define WLBS_REMOTE_ONLY         1011    /* WLBS is not installed on this host
                                            or is not functioning. Only remote
                                            control operations can be carried
                                            out. */
#define WLBS_LOCAL_ONLY          1012    /* WinSock failed to load. Only local
                                            operations can be carried out. */
#define WLBS_SUSPENDED           1013    /* Cluster control operations are
                                            suspended. */
#define WLBS_DISCONNECTED        1014    /* Media is disconnected. */
#define WLBS_REBOOT              1050    /* Reboot required in order for config
                                            changes to take effect. */
#define WLBS_INIT_ERROR          1100    /* Error initializing control module. */
#define WLBS_BAD_PASSW           1101    /* Specified remote control password
                                            was not accepted by the cluster. */
#define WLBS_IO_ERROR            1102    /* Local I/O error opening or
                                            communicating with WLBS driver. */
#define WLBS_TIMEOUT             1103    /* Timed-out awaiting response from
                                            remote host. */
#define WLBS_PORT_OVERLAP        1150    /* Port rule overlaps with existing
                                            port rules. */
#define WLBS_BAD_PORT_PARAMS     1151    /* Invalid parameter(s) in port rule. */
#define WLBS_MAX_PORT_RULES      1152    /* Maximum number of port rules reached. */
#define WLBS_TRUNCATED           1153    /* Return value truncated */
#define WLBS_REG_ERROR           1154    /* Error while accessing the registry */

#define WLBS_FAILURE             1501
#define WLBS_REFUSED             1502

/* Filtering modes for port rules */

#define WLBS_SINGLE              1       /* single server mode */
#define WLBS_MULTI               2       /* multi-server mode (load balanced) */
#define WLBS_NEVER               3       /* mode for never handled by this server */
#define WLBS_ALL                 4       /* all server mode */

/* Protocol qualifiers for port rules */

#define WLBS_TCP                 1       /* TCP protocol */
#define WLBS_UDP                 2       /* UDP protocol */
#define WLBS_TCP_UDP             3       /* TCP or UDP protocols */

/* Server affinity values for multiple filtering mode */

#define WLBS_AFFINITY_NONE       0       /* no affinity (scale single client) */
#define WLBS_AFFINITY_SINGLE     1       /* single client affinity */
#define WLBS_AFFINITY_CLASSC     2       /* Class C affinity */

/* Response value type returned by each of the cluster hosts during remote
   operation. */

typedef struct
{
    DWORD         id;                        /* Priority ID of the responding cluster host */
    DWORD         address;                   /* Dedicated IP address */
    DWORD         status;                    /* Status return value */
    DWORD         reserved1;                 /* Reserved for future use */
    PVOID         reserved2;
    
    NLB_OPTIONS   options;
}
WLBS_RESPONSE, * PWLBS_RESPONSE;

/* MACROS */


/* Local operations */

#define WlbsLocalQuery(host_map)                                  \
    WlbsQuery     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, \
                     host_map, NULL)

#define WlbsLocalSuspend()                                        \
    WlbsSuspend   (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalResume()                                         \
    WlbsResume    (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalStart()                                          \
    WlbsStart     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalStop()                                           \
    WlbsStop      (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalDrainStop()                                      \
    WlbsDrainStop (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalEnable(port)                                     \
    WlbsEnable    (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)

#define WlbsLocalDisable(port)                                    \
    WlbsDisable   (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)

#define WlbsLocalDrain(port)                                      \
    WlbsDrain     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)



/* Single host remote operations */

#define WlbsHostQuery(cluster, host, host_map)                    \
    WlbsQuery     (cluster, host, NULL, NULL, host_map, NULL)

#define WlbsHostSuspend(cluster, host)                            \
    WlbsSuspend   (cluster, host, NULL, NULL)

#define WlbsHostResume(cluster, host)                             \
    WlbsResume    (cluster, host, NULL, NULL)

#define WlbsHostStart(cluster, host)                              \
    WlbsStart     (cluster, host, NULL, NULL)

#define WlbsHostStop(cluster, host)                               \
    WlbsStop      (cluster, host, NULL, NULL)

#define WlbsHostDrainStop(cluster, host)                          \
    WlbsDrainStop (cluster, host, NULL, NULL)

#define WlbsHostEnable(cluster, host, port)                       \
    WlbsEnable    (cluster, host, NULL, NULL, port)

#define WlbsHostDisable(cluster, host, port)                      \
    WlbsDisable   (cluster, host, NULL, NULL, port)

#define WlbsHostDrain(cluster, host, port)                        \
    WlbsDrain     (cluster, host, NULL, NULL, port)

/* Cluster-wide remote operations */

#define WlbsClusterQuery(cluster, response, num_hosts, host_map)  \
    WlbsQuery     (cluster, WLBS_ALL_HOSTS, response, num_hosts,   \
                     host_map, NULL)

#define WlbsClusterSuspend(cluster, response, num_hosts)          \
    WlbsSuspend   (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterResume(cluster, response, num_hosts)           \
    WlbsResume    (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterStart(cluster, response, num_hosts)            \
    WlbsStart     (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterStop(cluster, response, num_hosts)             \
    WlbsStop      (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterDrainStop(cluster, response, num_hosts)        \
    WlbsDrainStop (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterEnable(cluster, response, num_hosts, port)     \
    WlbsEnable    (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)

#define WlbsClusterDisable(cluster, response, num_hosts, port)    \
    WlbsDisable   (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)

#define WlbsClusterDrain(cluster, response, num_hosts, port)      \
    WlbsDrain     (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)


/* PROCEDURES */

typedef VOID  (CALLBACK *PFN_QUERY_CALLBACK) (PWLBS_RESPONSE);

/*************************************
   Initialization and support routines
 *************************************/

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD WINAPI WlbsInit
(
    WCHAR*          Reservered1,    /* IN  - for backward compatibility */
    DWORD           version,    /* IN  - Pass WLBS_API_VER value. */
    PVOID           Reservered2    /* IN  - Pass NULL. Reserved for future use. */
);
/*
    Initialize WLBS control module.

    returns:
        WLBS_PRESENT        => WLBS is installed on this host. Local and remote
                               control operations can be executed.
        WLBS_REMOTE_ONLY    => WLBS is not installed on this system or is not
                               functioning properly. Only remote operations can
                               be carried out.
        WLBS_LOCAL_ONLY     => WinSock failed to load. Only local operations can
                               be carried out.
        WLBS_INIT_ERROR     => Error initializing control module. Cannot perform
                               control operations.
*/




/******************************************************************************
   Cluster control routines:

   The following routines can be used to control individual cluster hosts or the
   entire cluster, both locally and remotely. They are designed to be as generic
   as possible. Macros, defined above, are designed to provide simpler
   interfaces for particular types of operations.

   It is highly recommended to make all response arrays of size WLBS_MAX_HOSTS
   to make your implementation independent of the actual cluster size.

   Please note that cluster address has to correspond to the primary cluster
   address as entered in the WLBS Setup Dialog. WLBS will not recognize
   control messages sent to dedicated or additional multi-homed cluster
   addresses.
 ******************************************************************************/


extern DWORD WINAPI WlbsQuery
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    PDWORD          host_map,   /* OUT - Bitmap with ones in the bit positions
                                         representing priority IDs of the hosts
                                         currently present in the cluster. NULL
                                         if host map information is not
                                         needed. */
    PFN_QUERY_CALLBACK pfnQueryCallBack
                                /* IN  - Function pointer callback to return
                                         information on queried hosts as it is
                                         received. Caller must pass NULL if unused
                                         or implement a function with the prototype:
                                         VOID pfnQueryCallback(PWLBS_RESPONSE pResponse)
                                         */
);
/*
    Query status of specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_STOPPED     => Cluster mode on the host is stopped.
        WLBS_CONVERGING  => Host is converging.
        WLBS_DRAINING    => Host is draining.
        WLBS_CONVERGED   => Host converged.
        WLBS_DEFAULT     => Host converged as default host.

        Cluster-wide:

        <1..32>          => Number of active cluster hosts when the cluster
                            is converged.
        WLBS_SUSPENDED   => Entire cluster is suspended. All cluster hosts
                            reported as being suspended.
        WLBS_STOPPED     => Entire cluster is stopped. All cluster hosts reported
                            as being stopped.
        WLBS_DRAINING    => Entire cluster is draining. All cluster hosts
                            reported as being stopped or draining.
        WLBS_CONVERGING  => Cluster is converging. At least one cluster host
                            reported its state as converging.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the query.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system. Only remote
                            operations can be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsSuspend
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Suspend cluster operation control on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode control suspended.
        WLBS_ALREADY     => Cluster mode control already suspended.
        WLBS_STOPPED     => Cluster mode was stopped and control suspended.
        WLBS_DRAIN_STOP  => Suspending cluster mode control interrupted ongoing
                           connection draining.

        Cluster-wide:

        WLBS_OK          => Cluster mode control suspended on all hosts.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by at least one member of the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsResume
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Resume cluster operation control on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode control resumed.
        WLBS_ALREADY     => Cluster mode control already resumed.

        Cluster-wide:

        WLBS_OK          => Cluster mode control resumed on all hosts.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsStart
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Start cluster operations on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode started.
        WLBS_ALREADY     => Cluster mode already started.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_DRAIN_STOP  => Starting cluster mode interrupted ongoing connection
                            draining.
        WLBS_BAD_PARAMS  => Could not start cluster mode due to invalid configuration
                            parameters.

        Cluster-wide:

        WLBS_OK          => Cluster mode started on all hosts.
        WLBS_BAD_PARAMS  => Could not start cluster mode on at least one host
                            due to invalid configuration parameters.
        WLBS_SUSPENDED   => If at least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsStop
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE   response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Stop cluster operations on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode stopped.
        WLBS_ALREADY     => Cluster mode already stopped.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_DRAIN_STOP  => Starting cluster mode interrupted ongoing connection
                            draining.

        Cluster-wide:

        WLBS_OK          => Cluster mode stopped on all hosts.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDrainStop
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Enter draining mode on specified host or all cluster hosts. New connections
    will not be accepted. Cluster mode will be stopped when all existing
    connections finish. While draining, host will participate in convergence and
    remain part of the cluster.

    Draining mode can be interrupted by performing WlbsStop or WlbsStart.
    WlbsEnable, WlbsDisable and WlbsDrain commands cannot be executed
    while the host is draining.

    Note that this command is NOT equivalent to doing WlbsDrain with
    WLBS_ALL_PORTS parameter followed by WlbsStop. WlbsDrainStop affects all
    ports, not just the ones specified in the multiple host filtering mode port
    rules.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Host entered draining mode.
        WLBS_ALREADY     => Host is already draining.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_STOPPED     => Cluster mode is already stopped.

        Cluster-wide:

        WLBS_OK          => Draining mode entered on all hosts.
        WLBS_STOPPED     => Cluster mode is already stopped on all hosts.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsEnable
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           vip,        /* IN  - Virtual IP Address to specify the target port
                                         rule or WLBS_EVERY_VIP */ 
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Enable traffic handling for rule containing the specified port on specified
    host or all cluster hosts. Only rules that are set for multiple host
    filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Port rule enabled.
        WLBS_ALREADY     => Port rule already enabled.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot start handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot enable handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule enabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDisable
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           vip,        /* IN  - Virtual IP Address to specify the target port
                                         rule or WLBS_EVERY_VIP */ 
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Disable ALL traffic handling for rule containing the specified port on
    specified host or all cluster hosts. Only rules that are set for multiple
    host filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => All traffic handling on the port rule is disabled.
        WLBS_ALREADY     => Port rule already disabled.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot stop handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot stop handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule disabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDrain
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           vip,        /* IN  - Virtual IP Address to specify the target port
                                         rule or WLBS_EVERY_VIP */ 
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Disable NEW traffic handling for rule containing the specified port on
    specified host or all cluster hosts. Only rules that are set for multiple
    host filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => New traffic handling on the port rule is disabled.
        WLBS_ALREADY     => Port rule already being drained.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot stop handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot stop handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule disabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


/******************************************************************************
    "Sticky" options for remote operations. Parameters set by these routines will
    apply for all subsequent remote cluster control operations for the specified
    cluster. Use WLBS_ALL_CLUSTERS to adjust parameters for all clusters.
 ******************************************************************************/


extern VOID WINAPI WlbsPortSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    WORD            port        /* IN  - UDP port or 0 to revert to the
                                         default (2504). */
);
/*
    Set UDP port that will be used for sending control messages to the cluster.

    returns:
*/


extern VOID WINAPI WlbsPasswordSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    WCHAR*          password    /* IN  - Password or NULL to revert to the
                                         default (no password). */
);
/*
    Set password to be used in the subsequent control messages sent to the
    cluster.

    returns:
*/


extern VOID WINAPI WlbsCodeSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           password    /* IN  - Password or 0 to revert to the
                                         default (no password). */
);
/*
    Set password to be used in the subsequent control messages sent to the
    cluster.

    returns:
*/


extern VOID WINAPI WlbsDestinationSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           dest        /* IN  - Destination address or 0 to revert to
                                         the default (same as the cluster
                                         address specified during control
                                         calls). */
);
/*
    Set the destination address to send cluster control messages to. This
    parameter in only supplied for debugging or special purposes. By default
    all control messages are sent to the cluster primary address specified
    when invoking cluster control routines.

    returns:
*/


extern VOID WINAPI WlbsTimeoutSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           milliseconds /*IN  - Number of milliseconds or 0 to revert
                                         to the default (10 seconds). */
);
/*
    Set number of milliseconds to wait for replies from cluster hosts when
    performing remote operations.

    returns:
*/

DWORD WINAPI WlbsEnumClusters(OUT DWORD* pdwAddresses, OUT DWORD* pdwNum);

DWORD WINAPI WlbsGetAdapterGuid(IN DWORD cluster, OUT GUID* pAdapterGuid);

/*
 * Function: WlbsQueryState
 * Description: This function is a logical extension of WlbsQuery, which can be used
 *              to query state from an NLB cluster other than the conventional membership
 *              list and convergence state.  Retrievable state includes the driver-
 *              resident NLB parameters, the state of a BDA team, the state of a given
 *              port rule and the packet filtering decision for an arbitrary packet.
 * Parameters: IN cluster - cluster IP address or WLBS_ALL_CLUSTERS for all clusters.  For a 
 *                          IOCTL_CVY_QUERY_BDA_TEAMING operation, which is global to ALL NLB
 *                          instances on a given host, the cluster should be WLBS_ALL_CLUSTERS.
 *             IN host - host's dedicated address, priority ID, WLBS_DEFAULT_HOST for current default
 *                       host, WLBS_ALL_HOSTS for all hosts, or WLBS_LOCAL_HOST for local operation.
 *                       For IOCTL_CVY_QUERY_BDA_TEAMING and IOCTL_CVY_QUERY_PARAMS operations, which
 *                       can only be performed locally, the host should be WLBS_LOCAL_HOST.
 *             IN operation - one of IOCTL_CVY_QUERY_BDA_TEAMING, IOCTL_CVY_QUERY_PARAMS,
 *                            IOCTL_CVY_QUERY_PORT_STATE or IOCTL_CVY_QUERY_FILTER.
 *             IN/OUT pOptions - a pointer to an NLB_OPTIONS structure with all appropriate input
 *                               fields for the particular operation filled-in.  WlbsQueryState
 *                               operations utilize the "state" sub-structure of the NLB_OPTIONS
 *                               structure.  For the particular operation, the necessary input
 *                               parameters are marked as IN parameters in the definition of the 
 *                               OPTIONS sub-structure for that operation.  
 *             OUT pResonse - a pointer to an array of WLBS_RESPONSE structures that will be filled-in
 *                            at the successful completion of the request.  The array should be long 
 *                            enough to hold the maximum number of unique responses (one per cluster
 *                            host), which is bounded by WLBS_MAX_HOSTS.  Only responses for which 
 *                            there is room in this array will be returned; all others will be discarded.
 *             IN/OUT pcResponses - a pointer to a DWORD that contains that length of the WLBS_RESPONSE
 *                                  array on the way in and the number of successful responses received
 *                                  on the way out.
 * Returns: DWORD - one of:
 *              WLBS_INIT_ERROR - an initialization error occurred.
 *              WLBS_REMOTE_ONLY - the operation can be performed ONLY remotely.
 *              WLBS_LOCAL_ONLY - the operation can be performed ONLY locally.
 *              WLBS_IO_ERROR - an I/O error occurred.
 *              WLBS_TIMEOUT - no response from the cluster was returned before giving up.
 *              WLBS_OK - the request succeeded.
 *              >= WSABASEERR - a socket error occurred, see WSA documentation for details.
 * Notes: 
 */
extern DWORD WINAPI WlbsQueryState
(
    DWORD          cluster,
    DWORD          host,
    DWORD          operation,
    PNLB_OPTIONS   pOptions,
    PWLBS_RESPONSE pResponse,
    PDWORD         pcResponses
);

/* 
 * Function: WlbsConnectionUp
 * Description: This thread safe function notifies the NLB kernel-mode driver that a
 *              connection, or session, as defined by the caller of this function, is being 
 *              established.  If this type of connection is supported by NLB, it
 *              will provide affinity for the duration of the connection.  This 
 *              interface is reference counted and may be called multiple times with
 *              the same parameters.  If N connection-up notifications are given, N
 *              connection-down notifications (or ONE connection-reset notification)
 *              are necessary to remove the state that NLB creates to track this 
 *              connection.  The semantics of the information provided here must 
 *              EXACTLY match that which NLB is expecting.  For example, if a 
 *              notification for an IPSec session is given, then NLB expects the 
 *              protocol ID to be 50 (ESP) and the ports to be the UDP ports used
 *              in the IKE negotiation over UDP.
 * Parameters: IN ServerIp - the server IP address of this connection, in network byte order.
 *             IN ServerPort - the server port (if relevant) of this connection, in network byte order.
 *             IN ClientIp - the client IP address of this connection, in network byte order.
 *             IN ClientPort - the client port (if relevant) of this connection, in network byte order.
 *             IN Protocol - the IP protocol of this connection.  Support protocos = IPSec (50).
 *             OUT NLBStatusEx - the NLB-specific status of this request, as follows:
 *                 WLBS_OK, if the notification is accepted.
 *                 WLBS_REFUSED, if the notification is rejected (e.g., if the cluster is stopped)..
 *                 WLBS_BAD_PARAMS, if the arguments are invalid (e.g., an unsupported protocol ID).
 *                 WLBS_NOT_FOUND, if NLB was not bound to the specified adapter (identified by server IP address).
 *                 WLBS_FAILURE, if a non-specific error occurred.
 * Returns: DWORD - a Win32 error code, ERROR_SUCCESS, if successful.
 * Notes: 
 */
DWORD WINAPI WlbsConnectionUp
(
    ULONG  ServerIp,
    USHORT ServerPort,
    ULONG  ClientIp,
    USHORT ClientPort,
    BYTE   Protocol,
    PULONG NLBStatusEx
);

/* 
 * Function: WlbsConnectionDown
 * Description: This thread safe function notifies the NLB kernel-mode driver that a
 *              connection, or session, as defined by the caller of this function, is being 
 *              torn-down.  This interface is reference counted and must be called 
 *              the same number of times that the connection-up interface was called
 *              for this particular connection (that is, the number of Downs + Resets
 *              must be equal to the nubmer of Ups).  If N connection-up notifications 
 *              are given, N connection-down/reset notifications are necessary to remove
 *              the state that NLB creates to track this connection.  The semantics of
 *              the information provided here must EXACTLY match that which NLB is expecting.  
 *              For example, if a notification for an IPSec session is given, then NLB 
 *              expects the protocol ID to be 50 (ESP) and the ports to be the UDP ports 
 *              used in the IKE negotiation over UDP.
 * Parameters: IN ServerIp - the server IP address of this connection, in network byte order.
 *             IN ServerPort - the server port (if relevant) of this connection, in network byte order.
 *             IN ClientIp - the client IP address of this connection, in network byte order.
 *             IN ClientPort - the client port (if relevant) of this connection, in network byte order.
 *             IN Protocol - the IP protocol of this connection.  Support protocos = IPSec (50).
 *             OUT NLBStatusEx - the NLB-specific status of this request, as follows:
 *                 WLBS_OK, if the notification is accepted.
 *                 WLBS_REFUSED, if the notification is rejected (e.g., if the cluster is stopped)..
 *                 WLBS_BAD_PARAMS, if the arguments are invalid (e.g., an unsupported protocol ID).
 *                 WLBS_NOT_FOUND, if NLB was not bound to the specified adapter (identified by server IP address).
 *                 WLBS_FAILURE, if a non-specific error occurred.
 * Returns: DWORD - a Win32 error code, ERROR_SUCCESS, if successful.
 * Notes: 
 */
DWORD WINAPI WlbsConnectionDown
(
    ULONG  ServerIp,
    USHORT ServerPort,
    ULONG  ClientIp,
    USHORT ClientPort,
    BYTE   Protocol,
    PULONG NLBStatusEx
); 

/* 
 * Function: WlbsConnectionReset
 * Description: This function notifies the NLB kernel-mode driver that a connection,
 *              or session, as defined by the caller of this function, is being 
 *              closed immediately.  This interface is reference counted and must be called 
 *              the same number of times that the connection-up interface was called
 *              for this particular connection (that is, the number of Downs + Resets
 *              must be equal to the nubmer of Ups).  If N connection-up notifications 
 *              are given, N connection-down/reset notifications are necessary to remove
 *              the state that NLB creates to track this connection.  The semantics of
 *              the information provided here must EXACTLY match that which NLB is expecting.  
 *              For example, if a notification for an IPSec session is given, then NLB 
 *              expects the protocol ID to be 50 (ESP) and the ports to be the UDP ports 
 *              used in the IKE negotiation over UDP.
 * Parameters: IN ServerIp - the server IP address of this connection, in network byte order.
 *             IN ServerPort - the server port (if relevant) of this connection, in network byte order.
 *             IN ClientIp - the client IP address of this connection, in network byte order.
 *             IN ClientPort - the client port (if relevant) of this connection, in network byte order.
 *             IN Protocol - the IP protocol of this connection.  Support protocos = IPSec (50).
 *             OUT NLBStatusEx - the NLB-specific status of this request, as follows:
 *                 WLBS_OK, if the notification is accepted.
 *                 WLBS_REFUSED, if the notification is rejected (e.g., if the cluster is stopped)..
 *                 WLBS_BAD_PARAMS, if the arguments are invalid (e.g., an unsupported protocol ID).
 *                 WLBS_NOT_FOUND, if NLB was not bound to the specified adapter (identified by server IP address).
 *                 WLBS_FAILURE, if a non-specific error occurred.
 * Returns: DWORD - a Win32 error code, ERROR_SUCCESS, if successful.
 * Notes: 
 */
DWORD WINAPI WlbsConnectionReset
(
    ULONG  ServerIp,
    USHORT ServerPort,
    ULONG  ClientIp,
    USHORT ClientPort,
    BYTE   Protocol,
    PULONG NLBStatusEx
); 

/* 
 * Function: WlbsCancelConnectionNotify
 * Description: This thread safe function cleans up state maintained in the dll
 *              to support connection/session notifications to the NLB driver.
 *              The only usage constraint is that this API function must be the
 *              last notification call made by (any thread in) the process.
 *              Note that it is legal to cancel notifications then reestablish
 *              them within the lifetime of a thread of control.
 * Parameters: NONE
 * Returns: DWORD - a Win32 error code, ERROR_SUCCESS, if successful. No correction
 *                  action is needed if this call fails as it makes best effort.
 * Notes: 
 */
DWORD WINAPI WlbsCancelConnectionNotify();

/* Typedefs for GetProcAddress calls when dynamically loading wlbsctrl.dll. */
typedef DWORD (WINAPI * NLBNotificationConnectionUp)    (ULONG ServerIp, USHORT ServerPort, ULONG ClientIp, USHORT ClientPort, BYTE Protocol, PULONG NLBStatusEx);
typedef DWORD (WINAPI * NLBNotificationConnectionDown)  (ULONG ServerIp, USHORT ServerPort, ULONG ClientIp, USHORT ClientPort, BYTE Protocol, PULONG NLBStatusEx);
typedef DWORD (WINAPI * NLBNotificationConnectionReset) (ULONG ServerIp, USHORT ServerPort, ULONG ClientIp, USHORT ClientPort, BYTE Protocol, PULONG NLBStatusEx);
typedef DWORD (WINAPI * NLBNotificationCancelNotify)    ();

typedef HANDLE (WINAPI *WlbsOpen_FUNC)(); 
extern  HANDLE  WINAPI  WlbsOpen(); 

typedef DWORD  (WINAPI *WlbsLocalClusterControl_FUNC)
(
    IN  HANDLE       NlbHdl, 
    IN  const GUID * pAdapterGuid, 
    IN  LONG         ioctl,
    IN  DWORD        Vip,
    IN  DWORD        PortNum,
    OUT DWORD      * pdwHostMap
);
extern DWORD WINAPI WlbsLocalClusterControl
(
    IN  HANDLE       NlbHdl, 
    IN  const GUID * pAdapterGuid, 
    IN  LONG         ioctl,
    IN  DWORD        Vip,
    IN  DWORD        PortNum,
    OUT DWORD      * pdwHostMap
);

typedef DWORD  (WINAPI *WlbsGetClusterMembers_FUNC)
(
    IN  const GUID     * pAdapterGuid,
    OUT DWORD          * pNumHosts,
    OUT PWLBS_RESPONSE   pResponse
);
extern DWORD WINAPI WlbsGetClusterMembers
(
    IN  const GUID     * pAdapterGuid,
    OUT DWORD          * pNumHosts,
    OUT PWLBS_RESPONSE   pResponse
);

extern DWORD WINAPI WlbsGetSpecifiedClusterMember
(
    IN  const GUID     * pAdapterGuid,
    IN  ULONG            host_id,
    OUT PWLBS_RESPONSE   pResponse
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* KERNEL_MODE */

#endif /* _WLBSCTRL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\winscnst.h ===
#ifndef _WINSCNST_H_
#define _WINSCNST_H_

/*
  macros
*/


//
// Default values for the various time intervals
//

#define FORTY_MTS                               2400
#define TWO_HOURS                               7200
#define TWO_DAYS                                (172800)
#define ONEDAY                                  (TWO_DAYS/2)
#define FOUR_DAYS                               (TWO_DAYS * 2)
#define SIX_DAYS                                (TWO_DAYS * 3)
#define EIGHT_DAYS                              (TWO_DAYS * 4)
#define TWELVE_DAYS                             (TWO_DAYS * 6)
#define TWENTY_FOUR_DAYS                        (TWO_DAYS * 12)


#define WINSCNF_TIME_INT_W_SELF_FND_PNRS              TWO_HOURS
//
// Minimum number of updates that must be there before a push notification is
// sent
//
#define  WINSCNF_MIN_VALID_UPDATE_CNT        20  //the minimum no of updates
                                             //after which a notification
                                             //can be sent. Adjustable
                                             //via the registry
//
// This is the minimum valid Rpl interval.  All the scavenging time intervals
// are derived from it.
//
// refer WAIT_TIME_BEFORE_EXITING in rplpush.c
//
#define WINSCNF_MIN_VALID_RPL_INTVL        (600)  // 10 mts

// this is the minimum valid consistency check interval between the last time
// consistency check finished and the next one starts.
#define WINSCNF_MIN_VALID_INTER_CC_INTVL    (3*60*60) // 3 hours.

//
// default name of the db file that will contain the name-address mappings
//
#define  WINSCNF_DB_NAME                        TEXT(".\\wins\\wins.mdb")


#define  WINSCNF_DB_NAME_ASCII                        ".\\wins\\wins.mdb"

//
// NOTE NOTE NOTE
//
// If you change this define to a string that does not have an unexpanded
// string of the form %<string>% make a corresponding change in
// GetNamesOfDataFiles() in winscnf.c.
//
#define  WINSCNF_STATIC_DATA_NAME                TEXT("%SystemRoot%\\system32\\drivers\\etc\\lmhosts")


//
// Max. size of a file name
//
#define WINS_MAX_FILENAME_SZ		255

//
// Max. size of a line
//
// Used in winsprs.c
//
#define WINS_MAX_LINE_SZ		80	

//
// names of values stored under the Parameters key for WINS configuration
//
#if defined(DBGSVC) && !defined(WINS_INTERACTIVE)
#define  WINSCNF_DBGFLAGS_NM                TEXT("DBGFLAGS")
#endif
#define  WINSCNF_FILTER1BREQUESTS_NM        TEXT("Filter1BRequests")
#define  WINSCNF_ADD1BTO1CQUERIES_NM        TEXT("Prepend1BTo1CQueries")
#define  WINSCNF_LOG_DETAILED_EVTS_NM        TEXT("LogDetailedEvents")
#define  WINSCNF_REFRESH_INTVL_NM        TEXT("RefreshInterval")
#define  WINSCNF_INIT_CHL_RETRY_INTVL_NM        TEXT("InitChlRetryInterval")
#define  WINSCNF_CHL_MAX_RETRIES_NM        TEXT("ChlMaxNoOfRetries")
#define  WINSCNF_TOMBSTONE_INTVL_NM        TEXT("TombstoneInterval")
#define  WINSCNF_TOMBSTONE_TMOUT_NM        TEXT("TombstoneTimeout")
#define  WINSCNF_VERIFY_INTVL_NM        TEXT("VerifyInterval")
#define  WINSCNF_DB_FILE_NM                TEXT("DbFileNm")
#define  WINSCNF_DB_FILE_NM_ASCII        "DbFileNm"
#define  WINSCNF_STATIC_INIT_FLAG_NM        TEXT("DoStaticDataInit")
#define  WINSCNF_INIT_VERSNO_VAL_LW_NM        TEXT("VersCounterStartVal_LowWord")
#define  WINSCNF_INIT_VERSNO_VAL_HW_NM  TEXT("VersCounterStartVal_HighWord")
#define  WINSCNF_BACKUP_DIR_PATH_NM     TEXT("BackupDirPath")
#define  WINSCNF_PRIORITY_CLASS_HIGH_NM     TEXT("PriorityClassHigh")
#define  WINSCNF_MAX_NO_WRK_THDS_NM     TEXT("NoOfWrkThds")
#define  WINSCNF_INIT_TIME_PAUSE_NM     TEXT("InitTimePause")
#define  WINSCNF_CLUSTER_RESOURCE_NM    TEXT( "ClusterResourceName")

//
// To allow WINS to revert back to 351 jet and db
//
#define  WINSCNF_USE_351DB_NM           TEXT("Use351Db")
#define  WINSCNF_USE_4DB_NM           TEXT("Use4Db")

#if MCAST > 0
#define  WINSCNF_USE_SELF_FND_PNRS_NM    TEXT("UseSelfFndPnrs")
#define  WINSCNF_SELF_FND_NM             TEXT("SelfFnd")
#define  WINSCNF_MCAST_TTL_NM            TEXT("McastTtl")
#define  WINSCNF_MCAST_INTVL_NM          TEXT("McastIntvl")
#endif

#define  WINSCNF_WINS_PORT_NO_NM         TEXT("PortNo")

// persona grata/non-grata registry names have to be ASCII. The registry is queried
// through RegQueryValueExA() calls (see GetOwnerList() from winscnf.c)
#define  PERSMODE_NON_GRATA             0
#define  PERSMODE_GRATA                 1
#define  WINSCNF_PERSONA_MODE_NM        "PersonaMode"
#define  WINSCNF_PERSONA_NON_GRATA_NM   "PersonaNonGrata"
#define  WINSCNF_PERSONA_GRATA_NM       "PersonaGrata"

#if PRSCONN
#define WINSCNF_PRS_CONN_NM              TEXT("PersistentRplOn")
#endif

//
// Spoof reg/ref
//
#define  WINSCNF_BURST_HANDLING_NM    TEXT("BurstHandling")
#define  WINSCNF_BURST_QUE_SIZE_NM    TEXT("BurstQueSize")
// to enable round-robin list of 1C member addresses
#define  WINSCNF_RANDOMIZE_1C_LIST_NM TEXT("Randomize1CList")

//
//  NOTE NOTE NOTE
//
// This should never be set to FALSE in the registry unless we notice
// a major bug in WINS that is resulting in replication to stop. This
// parameter is a hatch door at best to get around an insidious bug
// that may escape us during our testing -- Good insurance policy
//
#define  WINSCNF_NO_RPL_ON_ERR_NM        TEXT("NoRplOnErr")

//
// FUTURES - remove when JetBackup is internationalized.  Also, update
// WinsCnfReadWinsInfo.
//
#define  WINSCNF_ASCII_BACKUP_DIR_PATH_NM   "BackupDirPath"
#define  WINSCNF_INT_VERSNO_NEXTTIME_LW_NM  TEXT("WinsInternalVersNoNextTime_LW")
#define  WINSCNF_INT_VERSNO_NEXTTIME_HW_NM  TEXT("WinsInternalVersNoNextTime_HW")
#define  WINSCNF_DO_BACKUP_ON_TERM_NM       TEXT("DoBackupOnTerm")
#define  WINSCNF_MIGRATION_ON_NM            TEXT("MigrateOn")
#define  WINSCNF_REG_QUE_MAX_LEN_NM         TEXT("RegQueMaxLen")

//
// Names to use in the registry for values of the PUSH/PULL sub-keys
//
#define  WINSCNF_ADDCHG_TRIGGER_NM          TEXT("RplOnAddressChg")
#define  WINSCNF_RETRY_COUNT_NM             TEXT("CommRetryCount")

//
// Under IP address of a Push pnr
//
#define  WINSCNF_SP_TIME_NM                 TEXT("SpTime")
#define  WINSCNF_RPL_INTERVAL_NM            TEXT("TimeInterval")
#define  WINSCNF_MEMBER_PREC_NM             TEXT("MemberPrecedence")

//
// Under IP address of a Pull pnr
//
#define  WINSCNF_UPDATE_COUNT_NM            TEXT("UpdateCount")

//
// Both pull/push pnr
//
#define  WINSCNF_ONLY_DYN_RECS_NM           TEXT("OnlyDynRecs")
//
// Value of the PULL/PUSH key
//
#define  WINSCNF_INIT_TIME_RPL_NM           TEXT("InitTimeReplication")

//
// Value of the PUSH key
//
#define  WINSCNF_PROP_NET_UPD_NTF          TEXT("PropNetUpdNtf")


//
// Indicate whether propagation is to be done or not
//
#define DO_PROP_NET_UPD_NTF    TRUE
#define DONT_PROP_NET_UPD_NTF    FALSE


//
// if "OnlyWithCnfPnrs" is set to TRUE, replication will be performed only
// with those partners that are listed under the Pull/Push key.  If not
// set to TRUE, replication can be initiated even with unlisted partners
// as a result of administrative action or as a result of receiving an
// update notification
//
#define  WINSCNF_RPL_ONLY_W_CNF_PNRS_NM TEXT("RplOnlyWCnfPnrs")

//
// This DWORD can be under the Partners, Partners\Pull,
// Partners\Push  keys or under a partner's ip address key.  If it is in more
// than in one place in the key heirarchy, the lower one overrides the upper
// one.
//
// Each bit indicates the kind of replication we want/don't want.
// If no bit is set or if this parameter is not defined, it means
// replicate everything (unless WINSCNF_ONLY_DYN_RECS_NM is defined - ideally
// that should be represented by a bit in this DWORD but that is river under
// the bridge and I don't want to get rid of that parameter since folks are
// used to it, it being in the doc set and all). Currently the following is
// defined

//
// All replication under the constraint of WINSCNF_ONLY_DYN_RECS_NM if defined
//
#define WINSCNF_RPL_DEFAULT_TYPE                 0x0

//
//  LSB - Replicate only the special group names (special groups - domains and
//  user defined special groups)
//
#define WINSCNF_RPL_SPEC_GRPS_N_PDC         0x1
#define WINSCNF_RPL_ONLY_DYN_RECS           0x80000000
#define WINSCNF_RPL_TYPE_NM                 TEXT("ReplicationType")

//
// Path to log file
//
#define  WINSCNF_LOG_FLAG_NM           TEXT("LoggingOn")
#define  WINSCNF_LOG_FILE_PATH_NM TEXT("LogFilePath")

#define  WINSCNF_MAX_CHL_RETRIES        3        //max. # of retries RFC 1002
                                                //page 83
#if 0
#define  WINSCNF_CHL_RETRY_INTERVAL        250        //Time interval (in msecs)
                                                //between retries -- RFC 1002
                                                //page 83
#endif
#define  WINSCNF_CHL_RETRY_INTERVAL        500        //Time interval (in msecs)

#define  WINSCNF_PROC_HIGH_PRIORITY_CLASS        HIGH_PRIORITY_CLASS
#define  WINSCNF_PROC_PRIORITY_CLASS        NORMAL_PRIORITY_CLASS
#define  WINSCNF_SCV_PRIORITY_LVL        THREAD_PRIORITY_BELOW_NORMAL




//
// The Retry timeout is kept as 10 secs.  It will be typically << the time
// interval for replication, allowing us to retry a number of times
// prior to the next replication cycle.
//
//
//  The Retry Time Interval is not used presently.  We are using the
//  replication time interval for retries.  This makes things simpler
//
#define         WINSCNF_RETRY_TIME_INT                10        //time interval for retries
                                                //if there is a comm failure
#define  WINSCNF_MAX_COMM_RETRIES         3     //max. number of retries before
                                               //giving up trying to set up
                                               //communications with a WINS

//
// Precedence of remote members (of special groups) registered by a WINS
// relative to the same registered by other WINS servers (used during
// pull replication)
//
// Locally registered members always have high precedence
//
// Make sure that WINSCNF_LOW_PREC < WINSCNF_HIGH_PREC (this fact is used in
// nmsnmh.c- UnionGrps())
//
//
#define    WINSCNF_LOW_PREC        0
#define    WINSCNF_HIGH_PREC        1


//
// After replication with a WINS has stopped because of persistent
// communication failure (i.e. after all retries have been exhausted),
// WINS will wait until the following number of replication time intervals
// have elapsed before starting the retries again.  If replication
// got stopped with more than one WINS partner with the same time interval
// (for pulling from it), then retry will be done for all these WINS when
// it is done for one (in other words, resumption of replication for a WINS
// may happen sooner than you think).
//
// We need to keep this number at least 2 since if we have not been able to
// communicate with the WINS server for WINSCNF_MAX_COMM_RETRIES times
// in the past WINSCNF_MAX_COMM_RETRIES * replication interval for the WINS,
// then it is highly probable that the WINS server is down for good.  We
// retry again after the 'backoff' time.  Hopefully, by then the admin would
// have corrected the problem. Now, it is possible (unlikely though) that
// the WINS server happened to be down only at the times this WINS tried to
// contact it. We have no way to determine that.
//
//
// This can be made a registry parameter. This can be called the sleep time
// between successive rounds of retries.
//
#define WINSCNF_RETRY_AFTER_THIS_MANY_RPL        2

//
// if the time interval for periodic replication with a partner with which
// a WINS server has had consecutive comm. failures is more than the
// following amount, we don't back off as explained above
//
//
#define WINSCNF_MAX_WAIT_BEFORE_RETRY_RPL       ONEDAY    //1 day

//
// The max. number of comcurrent static initializations that can be
// happening.  These may be due to commands from the admin. tool or
// due to registry notifications.
//
#define  WINSCNF_MAX_CNCRNT_STATIC_INITS        3

//
// No of records to handle at one time (used by the scavenger thread).  This
// number determines the size of the memory block that will be allocated
// by NmsDbGetDataRecs().
//
//#define  WINSCNF_SCV_CHUNK                1000
#define  WINSCNF_SCV_CHUNK                3000

//
// defines
//
//
// Refresh interval - time period after which the state of an ACTIVE entry in
//                            the db is set to NMSDB_E_RELEASED if it has not
//                      been refreshed
//

#define WINSCNF_MIN_REFRESH_INTERVAL            FORTY_MTS
#define WINSCNF_DEF_REFRESH_INTERVAL            SIX_DAYS   //FOUR_DAYS

#define REF_MULTIPLIER_FOR_ACTIVE           2

//
// The Tombstone Interval (the interval a record stays released) should be
// a multiple of the RefreshInterval by at least the following amount
//
// With 2 as the value and refresh time interval being 4 days, TombInterval
// is max(8 days, 2 * MaxRplInterval) i.e at least 8 days.
//
#define REF_MULTIPLIER_FOR_TOMB                   2

//
// Challenge Retry interval
//

#define WINSCNF_MIN_INIT_CHL_RETRY_INTVL        250
#define WINSCNF_DEF_INIT_CHL_RETRY_INTVL        500

//
// Challenge Max. No. of Retries
//

#define WINSCNF_MIN_CHL_MAX_RETRIES        1
#define WINSCNF_DEF_CHL_MAX_RETRIES        3

//
// Also the min. tombstone timeout should be
//  max(RefreshInterval, RPL_MULTIPLIER_FOR_TOMBTMOUT * MaxRplInterval)
//
// With Refresh Interval being 4 days, this will be atleast 4 days.
//
#define RPL_MULTIPLIER_FOR_TOMBTMOUT                4

//
// The verify interval should be a multiple of the tombstone time
// interval by at least the following amount.  Keep the total time high
//
// With with the min. tombstone interval being at least 8 days, it will be at
// least (3 * 8 = 24 days)
//
#define TOMB_MULTIPLIER_FOR_VERIFY         3

//
// Tombstone interval - time period after which the state of a released
//                         entry is changed to NMSDB_E_TOMBSTONE if it has not
//                     been refreshed
//
#define WINSCNF_MIN_TOMBSTONE_INTERVAL        (WINSCNF_MIN_REFRESH_INTERVAL * REF_MULTIPLIER_FOR_TOMB)

//
// Time period after which the tombstone should be deleted.  The min. value
// is 1 days.  This is to cut down on the possibility of a
// tombstone getting deleted prior to it getting replicated to another WINS.
//
#define WINSCNF_MIN_TOMBSTONE_TIMEOUT                max(WINSCNF_MIN_REFRESH_INTERVAL, ONEDAY)

//
// Minimum time period for doing verifications of the replicas in the db
//
// Should be atleast 24 days.
//
#define WINSCNF_MIN_VERIFY_INTERVAL                max(TWENTY_FOUR_DAYS, (WINSCNF_MIN_TOMBSTONE_INTERVAL * TOMB_MULTIPLIER_FOR_VERIFY))

#define  WINSCNF_CC_INTVL_NM            TEXT("TimeInterval")
#define  WINSCNF_CC_MAX_RECS_AAT_NM     TEXT("MaxRecsAtATime")
#define  WINSCNF_CC_USE_RPL_PNRS_NM     TEXT("UseRplPnrs")

#define WINSCNF_CC_DEF_INTERVAL               ONEDAY
#define WINSCNF_CC_MIN_INTERVAL               (ONEDAY/4)

#define WINSCNF_DEF_CC_SP_HR               2       //02 hrs - 2am


#define WINSCNF_CC_MIN_RECS_AAT        1000
#define WINSCNF_CC_DEF_RECS_AAT        30000

#define WINSCNF_CC_DEF_USE_RPL_PNRS    0

#if 0
//
// Make the refresh interval equal to twice the max. replication time interval
// if that is greater than the refresh interval.
//
#define  WINSCNF_MAKE_REF_INTVL_M(RefreshInterval, MaxRplIntvl)  max(REF_MULTIPLIER_FOR_ACTIVE * (MaxRplIntvl), RefreshInterval)
#endif

//
// The Tombstone interval should never be allowed to go over 4 days. We
// don't want a record to remain released for longer than that.  It should
// turn into a tombstone so that it gets replicated.
//
// The reason we change the state of a record to released is to avoid
// replication if the reason for the release is a temporary shutdown of
// the pc.  We have to consider a long weekend (3 days).  We however
// also need to consider the fact that if the refresh interval is 40 mts or
// some such low value, then we should not keep the record in the released
// state for more than a day at the most.  Consider a situation where
// a node registers with the backup because the primary is down and then
// goes back to the primary when it comes up.  The primary does not
// increment the version number because the record is stil active.  The
// record gets released at the backup and stays that way until it becomes
// a tombstone which results in replication and the backup again getting
// the active record from the primary.  For the above situaion, we should
// make sure of two things: first - the record does not have an overly large
// tombstone interval; second - the replication time interval is small. We
// don't want to change the replication time interval set by the admin. but
// we can do something about the former.
//
// As long as the user sticks with the default refresh interval, the tombstone
// interval will be the same as that.
//
// For the case where the user specifies a different refresh interval, we use
// a max. of the refresh interval and a multiple of the max. rpl. interval.
//
//

#define  WINSCNF_MAKE_TOMB_INTVL_M(RefreshInterval, MaxRplIntvl)  min(max(REF_MULTIPLIER_FOR_TOMB * (MaxRplIntvl), RefreshInterval), FOUR_DAYS)

#define  WINSCNF_MAKE_TOMB_INTVL_0_M(RefreshInterval)  min(RefreshInterval, FOUR_DAYS)

//
// macro to get the minimum tombstone timeout based on the maximum replication
// time interval.
//
#define  WINSCNF_MAKE_TOMBTMOUT_INTVL_M(MaxRplIntvl)  max(WINSCNF_MIN_TOMBSTONE_TIMEOUT,(RPL_MULTIPLIER_FOR_TOMBTMOUT * (MaxRplIntvl)))


//
// Macro to get the minimum verify interval based on tombstone interval
//
// Should be atleast 8 days.
//
#define  WINSCNF_MAKE_VERIFY_INTVL_M(TombstoneInterval)  max(TWENTY_FOUR_DAYS, (TOMB_MULTIPLIER_FOR_VERIFY * (TombstoneInterval)))


//
// Min. Mcast TTL
//
#define WINSCNF_MIN_MCAST_TTL              TTL_SUBNET_ONLY
#define WINSCNF_DEF_MCAST_TTL              TTL_REASONABLE_REACH
#define WINSCNF_MAX_MCAST_TTL              32
#define WINSCNF_MIN_MCAST_INTVL            FORTY_MTS
#define WINSCNF_DEF_MCAST_INTVL            FORTY_MTS

#define WINS_QUEUE_HWM        500
#define WINS_QUEUE_HWM_MAX      5000
#define WINS_QUEUE_HWM_MIN       50

#endif _WINSCNST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\wlbsconfig.h ===
//+----------------------------------------------------------------------------
//
// File:	 wlbsconfig.h
//
// Module:	 Network Load Balancing 
//
// Description: Internal APIs for cluster configuration.  Thes APIs are internal 
//              to WLBS team only, and no plan backward compatability.
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:	 fengsun Created    3/2/00
//
//+----------------------------------------------------------------------------



#ifndef _WLBSCONFIG_H
#define _WLBSCONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

#include "wlbsctrl.h"

/* Maximum lengths of parameter strings. */

#define WLBS_MAX_VIRTUAL_NIC     256
#define WLBS_MAX_CLUSTER_NIC     256
#define WLBS_MAX_NETWORK_ADDR    17
#define WLBS_MAX_CL_IP_ADDR      17
#define WLBS_MAX_CL_NET_MASK     17
#define WLBS_MAX_DED_IP_ADDR     17 
#define WLBS_MAX_DED_NET_MASK    17
#define WLBS_MAX_NETWORK_ADDR    17
#define WLBS_MAX_LICENSE_KEY     20
#define WLBS_MAX_DOMAIN_NAME     100
#define WLBS_MAX_BDA_TEAM_ID     40

/* Latest version number for WLBS_REG_PARAMS. Increment this when the structure is modified. */
#define WLBS_REG_PARAMS_VERSION  4093

/* Port group rule - used in registry parameters.
   NOTE! do not access value marked with I. These are for internal use only. */

#pragma pack(1)

typedef struct
{
    DWORD       start_port,             /* Starting port number. */
                end_port;               /* Ending port number. */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       code;                 /* I: Unique rule code. */
#else
    DWORD       Private1;               // Do not change these field directly
#endif

    DWORD       mode;                   /* Filtering mode. */
    DWORD       protocol;               /* WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       valid;                /* I: For rule management in user mode. */
#else
    DWORD       Private2;               // Do not change these field directly
#endif

    union
    {
        struct
        {
            DWORD       priority;       /* Mastership priority: 1..32 or 0 for
                                           not-specified. */
        }           single;             /* Data for single server mode. */
        struct
        {
            WORD        equal_load;     /* TRUE - Even load distribution. */
            WORD        affinity;       /* WLBS_AFFINITY_... */
            DWORD       load;           /* Percentage of load to handle
                                           locally 0..100. */
        }           multi;              /* Data for multi-server mode. */
    }           mode_data;              /* Data for appropriate port group mode. */
}
WLBS_OLD_PORT_RULE, * PWLBS_OLD_PORT_RULE;

/* Structure to hold the bi-directional affinity registry settings. */
typedef struct _CVY_BDA {
    WCHAR       team_id[WLBS_MAX_BDA_TEAM_ID + 1];  /* The team ID - MUST be a GUID. */
    ULONG       active;                             /* On write, this flag determines whether to create BDATeaming key - BDA on/off switch. */
    ULONG       master;                             /* Boolean indication of master status. */
    ULONG       reverse_hash;                       /* Sets direction of hashing - forward (normal) or reverse. */
} WLBS_BDA, * PWLBS_BDA;

typedef struct
{
    TCHAR       virtual_ip_addr [WLBS_MAX_CL_IP_ADDR + 1]; /* Virtual IP Address */
    DWORD       start_port,             /* Starting port number. */
                end_port;               /* Ending port number. */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       code;                 /* I: Unique rule code. */
#else
    DWORD       Private1;               // Do not change these field directly
#endif

    DWORD       mode;                   /* Filtering mode. */
    DWORD       protocol;               /* WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       valid;                /* I: For rule management in user mode. */
#else
    DWORD       Private2;               // Do not change these field directly
#endif

    union
    {
        struct
        {
            DWORD       priority;       /* Mastership priority: 1..32 or 0 for
                                           not-specified. */
        }           single;             /* Data for single server mode. */
        struct
        {
            WORD        equal_load;     /* TRUE - Even load distribution. */
            WORD        affinity;       /* WLBS_AFFINITY_... */
            DWORD       load;           /* Percentage of load to handle
                                           locally 0..100. */
        }           multi;              /* Data for multi-server mode. */
    }           mode_data;              /* Data for appropriate port group mode. */
}
WLBS_PORT_RULE, * PWLBS_PORT_RULE;

#pragma pack()


#ifdef __cplusplus
typedef struct __declspec(dllexport)
#else
typedef struct 
#endif
{
    /* public - can be modified by clients of this API */
    DWORD       struct_version;         /* Version of this structure. Update WLBS_REG_PARAMS_VERSION constant when this structure is modified. */
    DWORD       host_priority;          /* Host priority ID. */
    DWORD       alive_period;           /* Period for sending "I am alive" messages
                                           in milliseconds. */
    DWORD       alive_tolerance;        /* How many "I am alive" messages can be
                                           missed from other servers before assuming
                                           that the host is dead. */
    DWORD       num_actions;            /* Number of actions per allocation. */
    DWORD       num_packets;            /* number of packets per allocation. */
    DWORD       num_send_msgs;          /* Number of heartbeats per allocation. */
    DWORD       install_date;           /* Install time stamp, used to create a unique code for the host. */
    DWORD       rct_port;               /* Remote control UDP port. */
    DWORD       rct_enabled;            /* TRUE - remote control enabled. */
    DWORD       cluster_mode;           /* TRUE - join cluster on boot. */
    DWORD       persisted_states;       /* Bitmap of states that should be persisted across reboots. */
    DWORD       dscr_per_alloc;         /* Number of connection tracking
                                           descriptor per allocation. */
    DWORD       max_dscr_allocs;        /* Maximum number of connection tracking
                                           descriptor allocations. */
    DWORD       mcast_support;          /* TRUE - multicast mode,
                                           FALSE - unicast mode */
    DWORD       mask_src_mac;           /* TRUE - Mangle source MAC address to
                                           prevent switch learning. FALSE -
                                           cluster is on a hub, optimizes switch
                                           performance by re-enabling learning. */

    DWORD       tcp_dscr_timeout;       /* The TCP connection descriptor timeout, in seconds. */
    DWORD       ipsec_dscr_timeout;     /* The IPSec connection descriptor timeout, in seconds. */

    DWORD       filter_icmp;            /* Whether or not to filter ICMP traffic. */

    DWORD       identity_period;        /* Period for identity heartbeats in ms */
    DWORD       identity_enabled;       /* TRUE - identity heartbeats are transmitted */

    TCHAR       cl_mac_addr [WLBS_MAX_NETWORK_ADDR + 1];
                                        /* Cluster MAC address. */
    TCHAR       cl_ip_addr [WLBS_MAX_CL_IP_ADDR + 1];
                                        /* Cluster IP address. */
    TCHAR       cl_net_mask [WLBS_MAX_CL_NET_MASK + 1];
                                        /* Netmask for cluster IP. */
    TCHAR       ded_ip_addr [WLBS_MAX_DED_IP_ADDR + 1];
                                        /* Dedicated IP address or "" for none. */
    TCHAR       ded_net_mask [WLBS_MAX_DED_NET_MASK + 1];
                                        /* Netmask for dedicated IP address
                                           or "" for none */
    TCHAR       domain_name [WLBS_MAX_DOMAIN_NAME + 1];
                                        /* FQDN of the cluster. */

    //
    // IGMP support
    //
    BOOL        fIGMPSupport; // whether to send IGMP join periodically
    WCHAR       szMCastIpAddress[WLBS_MAX_CL_IP_ADDR + 1]; // multicast IP
    BOOL        fIpToMCastIp; // whether to generate multicast IP from cluster IP
    
    WLBS_BDA    bda_teaming;

#ifdef __cplusplus
#ifndef WLBSAPI_INTERNAL_ONLY

    //
    // private - should be treated as opaque 
    //
    // Do not change these field directly
    //
    private:

#endif
#endif


    /* obtained from the registry */

    DWORD       i_parms_ver;            /* I: Parameter structure version. */
    DWORD       i_verify_date;          /* I: Encoded install time stamp. */
    DWORD       i_rmt_password;         /* I: Remote maintenance password. */
    DWORD       i_rct_password;         /* I: Remote control password (use
                                            WlbsSetRemotePassword to set this
                                            value). */
    DWORD       i_num_rules;            /* I: # active port group rules (changed
                                            through WlbsAddPortRule and
                                            WlbsDelPortRule routines). */
    DWORD       i_cleanup_delay;        /* I: Dirty connection cleanup delay in
                                            milliseconds, 0 - delay. */
    DWORD       i_scale_client;         /* I: Legacy parameter. */
    DWORD       i_mcast_spoof;          /* I: TRUE - Provide ARP resolution in
                                            multicast mode. FALSE - clients
                                            will rely on static ARP entries. */
    DWORD       i_convert_mac;          /* I: TRUE - automatically generate MAC
                                            address based on cluster IP
                                            address in UI. */
    DWORD       i_ip_chg_delay;         /* I: Delay in milliseconds to block
                                            outgoing ARPs while IP address
                                            change is in process. */
    DWORD       i_nbt_support;          /* I: TRUE - NBT cluster name support
                                            enabled. */
    DWORD       i_netmon_alive;         /* I: TRUE - pass heartbeat messages
                                            to the protocols (netmon). */
    DWORD       i_effective_version;    /* I: Effective version of NLB */

    /* strings */

    TCHAR       i_virtual_nic_name [WLBS_MAX_VIRTUAL_NIC + 1];
                                        /* I: Virtual NIC name or GUID. */
//    TCHAR       cluster_nic_name [WLBS_MAX_CLUSTER_NIC + 1];
                                        /* I: Cluster NIC name or GUID. */
    TCHAR       i_license_key [WLBS_MAX_LICENSE_KEY + 1];
                                      /* I: Legacy parameter. */

    WLBS_PORT_RULE  i_port_rules [WLBS_MAX_RULES];
                                        /* I: Port rules (changed
                                              through WlbsAddPortRule and
                                              WlbsDelPortRule routines). */
    /* computed */

    DWORD       i_max_hosts;            /* Legacy parameter. */
    DWORD       i_max_rules;            /* Legacy parameter. */
//    DWORD       i_expiration;           /* Legacy parameter. */
//    DWORD       i_ft_rules_enabled;     /* Legacy parameter. */
//    DWORD       version;              /* Legacy parameter. */

    DWORD i_dwReserved;
}
WLBS_REG_PARAMS, * PWLBS_REG_PARAMS;



/* API commands for WlbsFormatMessage */
typedef enum
{
    CmdWlbsAddPortRule,
    CmdWlbsAddressToName,
    CmdWlbsAddressToString,
    CmdWlbsAdjust,
    CmdWlbsCommitChanges,
    CmdWlbsDeletePortRule,
    CmdWlbsDestinationSet,
    CmdWlbsDisable,
    CmdWlbsDrain,
    CmdWlbsDrainStop,
    CmdWlbsEnable,
    CmdWlbsFormatMessage,
    CmdWlbsGetEffectiveVersion,
    CmdWlbsGetNumPortRules,
    CmdWlbsEnumPortRules,
    CmdWlbsGetPortRule,
    CmdWlbsInit,
    CmdWlbsPasswordSet,
    CmdWlbsPortSet,
    CmdWlbsQuery,
    CmdWlbsReadReg,
    CmdWlbsResolve,
    CmdWlbsResume,
    CmdWlbsSetDefaults,
    CmdWlbsSetRemotePassword,
    CmdWlbsStart,
    CmdWlbsStop,
    CmdWlbsSuspend,
    CmdWlbsTimeoutSet,
    CmdWlbsWriteReg,
    CmdWlbsQueryPortState
}
WLBS_COMMAND;

extern BOOL WINAPI WlbsFormatMessage
(
    DWORD           error,      /* IN  - WLBS_... or WSA... return value. */
    WLBS_COMMAND    command,    /* IN  - Which routine returned the value. */
    BOOL            cluster,    /* IN  - TRUE - command was issued on entire
                                         cluster, FALSE - single host. */
    WCHAR*          messagep,   /* IN  - Pointer to user-allocated buffer. */
    PDWORD          lenp        /* IN  - Buffer size.
                                   OUT - The required buffer size if the current
                                         size is insufficient */
);
/*
    Return character string describing specified WLBS API return code. Note that
    message will depend on the command which returned the code and if it was
    issued in cluster-wide or single-host mode.

    returns:
        TRUE  => Message formatted successfully.
        FALSE => Bad error code (lenp will contain 0 on exit) or buffer is not
                 big enough to contain entire string (lenp will contain required
                 buffer size on exit).
*/

/* Support routines: */


extern DWORD WINAPI WlbsResolve
(
    const WCHAR*           address     /* IN  - Internet host name or IP address in
                                         dotted notation. */
);
/*
    Resolve Internet host name to its IP address. This routine can also be
    used to convert a string containing an IP address in dotted notation to a
    value that can be passed to cluster control routines.

    returns:
        0               => failed to resolve host name.
        <address>       => IP address corresponding to the specified address.
                           This value can be used in subsequent calls to
                           cluster control routines.
*/


extern BOOL WINAPI WlbsAddressToString
(
    DWORD           address,    /* IN  - IP address. */
    WCHAR*           buf,        /* OUT - Character buffer for resulting
                                         string. */
    PDWORD          lenp        /* IN  - Buffer size in characters.
                                   OUT - Characters written or required buffer
                                         size. */
);
/*
    Convert IP address to a string in dotted notation.

    returns:
        TRUE            => Successfully converted. lenp contains number of
                           character written.
        FALSE           => Buffer too small. lenp contains required buffer size
                           including terminating NULL character.
*/


extern BOOL WINAPI WlbsAddressToName
(
    DWORD    address,    /* IN  - IP address. */
    WCHAR*          buf,        /* OUT - Character buffer for resulting
                                         string. */
    PDWORD          lenp        /* IN  - Buffer size in characters.
                                   OUT - Characters written or required buffer
                                         size. */
);
/*
    Resolve IP address to Internet host name.

    returns:
        TRUE            => Successfully converted. lenp contains number of
                           character written.
        FALSE           => Buffer too small. lenp contains required buffer size
                           including terminating NULL character.
*/


/******************************************************************************
    Cluster host configuration routines. Note that in current implementation,
    cluster and host parameters need to be set to WLBS_LOCAL_CLUSTER and
    WLBS_LOCAL_HOST.
 ******************************************************************************/


extern DWORD WINAPI WlbsReadReg
(
    DWORD           cluster,    /* IN  - WLBS_LOCAL_CLUSTER */
    PWLBS_REG_PARAMS reg_data   /* OUT - Registry parameters */
);
/*
    Read WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => reg_data is NULL
    WLBS_REG_ERROR   => Error reading from the registry

    Local:

    WLBS_OK          => Registry parameters successfully read.

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsWriteReg
(
    DWORD           cluster,    /* IN  - WLBS_LOCAL_CLUSTER */
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Write WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_REG_ERROR   => Error accessing the registry.

    Local:

    WLBS_OK          => Registry parameters successfully written.

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsCommitChanges
(
    DWORD           cluster    /* IN  - WLBS_LOCAL_CLUSTER */
);
/*
    Write WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.

    Local:

    WLBS_OK          => Changes have been successfully applied.
    WLBS_BAD_PARAMS  => Registry parameters were not accepted by the driver.
                        Reload was not performed
    WLBS_REBOOT      => Reboot required in order for config changes to
                        take effect.
    WLBS_IO_ERROR    => Error while writing to the driver.
    WLBS_REG_ERROR   => Error while trying to write MAC address changes to the
                        registry

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


typedef DWORD  (WINAPI *WlbsSetDefaults_FUNC)
(
    PWLBS_REG_PARAMS       reg_data
); 
extern DWORD WINAPI WlbsSetDefaults
(
    PWLBS_REG_PARAMS       reg_data     /* OUT - Default values    */
);
/*
    Fills in the reg_data structure with default values

    returns:

    WLBS_INIT_ERROR    => Error initializing control module. Cannot perform
                          control operations.

    WLBS_BAD_PARAMS    => Invalid structure

    Local:

    WLBS_OK            => Structure was filled in with the default values.

    Remote:

    WLBS_LOCAL_ONLY    => This call is implemented for local only operation.

*/

/******************************************************************************
    Registry parameter manipulation routines. Note that these routines operate
    WLBS_REG_PARAMS structure filled out by calling WlbsReadReg. Some parameters
    can be manipulated directly. Please make sure to use manipulation routines
    for the ones that they are provided for.
 ******************************************************************************/

extern DWORD WINAPI WlbsGetEffectiveVersion
(
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Returns the effective version of cluster 

    returns:

    CVY_VERSION_FULL  => There is atleast one port rule that has a specific 
                         vip associated with it 
                        
    CVY_VERSION_LOWEST_CLIENT_FULL  => All port rules have the "All vip" associated with them

*/


extern DWORD WINAPI WlbsGetNumPortRules
(
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Returns number of port rules currently in the parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    1...WLBS_MAX_RULES

*/

typedef DWORD  (WINAPI *WlbsEnumPortRules_FUNC)
(
    const PWLBS_REG_PARAMS reg_data, 
    PWLBS_PORT_RULE rules, 
    PDWORD          num_rules
);
extern DWORD WINAPI WlbsEnumPortRules
(
    const PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    PWLBS_PORT_RULE rules,      /* OUT - Array of port rules. */
    PDWORD          num_rules   /* IN  - Size of rules array.
                                   OUT - Number of rules retrieved. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few rules that fit
                                         in the array are returned. */
);
/*
    Enumerate all port rules in the list of port rules in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_TRUNCATED   => All port rules did not fit into specified array.
    WLBS_OK          => Rule has been successfully retrieved.

*/


extern DWORD WINAPI WlbsGetPortRule
(
    const PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    DWORD           vip,        /* IN  - Virtual IP Address of the port rule to retreive */
    DWORD           port,       /* IN  - Port, which rule to retrieve. */
    PWLBS_PORT_RULE rule        /* OUT - Port rule. */
);
/*
    Retrieve port rule containing specified port from the list of port rules
    in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    WLBS_OK          => Rule has been successfully retrieved.
    WLBS_NOT_FOUND   => Port not found among port rules.

*/

typedef DWORD  (WINAPI *WlbsAddPortRule_FUNC)
(
    PWLBS_REG_PARAMS reg_data, 
    const PWLBS_PORT_RULE rule
);

extern DWORD WINAPI WlbsAddPortRule
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    const PWLBS_PORT_RULE rule        /* IN  - Port rule to add. */
);
/*
    Add port to list of port rules in parameter structure.

    returns:

    WLBS_INIT_ERROR     => Error initializing control module. Cannot perform
                           control operations.
    WLBS_BAD_PARAMS     => Registry parameter structure is invalid.
    WLBS_OK             => Rule has been successfully added.
    WLBS_PORT_OVERLAP   => Port rule overlaps with existing port rule.
    WLBS_BAD_PORT_PARAMS=> Invalid port rule parameters.
    WLBS_MAX_PORT_RULES => Maximum number of port rules already reached.
*/


extern DWORD WINAPI WlbsDeletePortRule
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    DWORD           vip,        /* IN  - Virtual IP Address of the port rule to retreive */
    DWORD           port        /* IN  - Port, which rule to delete. */
);
/*
    Remove port rule containing specified port from the list of port rules
    in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_NOT_FOUND   => Port not found among port rules.

    WLBS_OK          => Rule has been successfully deleted.

*/


typedef VOID   (WINAPI *WlbsDeleteAllPortRules_FUNC)
(
    PWLBS_REG_PARAMS reg_data
);
extern VOID WINAPI WlbsDeleteAllPortRules
(
    PWLBS_REG_PARAMS reg_data
);
/*
    Remove all port rules from the list of port rules.
*/


typedef DWORD   (WINAPI *WlbsSetRemotePassword_FUNC)
(
    PWLBS_REG_PARAMS paramp, 
    const WCHAR *password
);
extern DWORD WINAPI WlbsSetRemotePassword
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    const WCHAR*           password   /* IN  - Password or NULL for no password. */
);
/*
    Set remote password code to encrypted value of the specified password.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    WLBS_OK          => Password has been successfully set.

*/

DWORD WINAPI WlbsNotifyConfigChange(DWORD cluster);


typedef BOOL   (WINAPI *WlbsValidateParams_FUNC) (PWLBS_REG_PARAMS paramp);
extern  BOOL    WINAPI  WlbsValidateParams(PWLBS_REG_PARAMS paramp);

typedef BOOL   (WINAPI *WlbsParamReadReg_FUNC)
(
    const GUID*      pAdapterGuid, 
    PWLBS_REG_PARAMS reg_data
); 
extern  BOOL    WINAPI  WlbsParamReadReg
(
    const GUID*      pAdapterGuid, 
    PWLBS_REG_PARAMS reg_data 
); 

typedef DWORD  (WINAPI *WlbsWriteAndCommitChanges_FUNC)
(
    HANDLE             NlbHdl, 
    const GUID*        pAdapterGuid, 
    WLBS_REG_PARAMS*   p_new_reg_params
); 
extern DWORD    WINAPI  WlbsWriteAndCommitChanges
(
    HANDLE             NlbHdl, 
    const GUID*        pAdapterGuid, 
    WLBS_REG_PARAMS*   p_new_reg_params
); 


#ifdef __cplusplus
} /* extern "C" */
#endif


#endif _WLBSCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\wlbsparm.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbsparm.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Registry parameters specification

Author:

    kyrilf

Environment:


Revision History:


--*/


#ifndef _Params_h_
#define _Params_h_

//
// These constants from the now-obsolete wlbslic.h
//
#define LICENSE_STR_IMPORTANT_CHARS 16  /* number of characters from the string
                                           used for encoding */

#define LICENSE_DATA_GRANULARITY    8   /* granularity in bytes of data for
                                           encoding/decoding */

#define LICENSE_STR_NIBBLES         (LICENSE_STR_IMPORTANT_CHARS / LICENSE_DATA_GRANULARITY)

#define LICENSE_TRIAL_CODE          _TEXT("")

#ifdef KERNEL_MODE

#include <ndis.h>
#include <ntddndis.h>
typedef BOOLEAN                 BOOL;

#else

#include <windows.h>

#endif

// ###### ramkrish
#define CVY_MAX_ADAPTERS               16        /* maximum number of adapters to bind to */

/* CONSTANTS */

#define CVY_STR_SIZE                    256
#define PARAMS_MAX_STRING_SIZE          256

/* compile-time parameters */

//
// Heartbeat and remote control packet version
//
#define CVY_VERSION             L"V2.4"
#define CVY_VERSION_MAJOR       2
#define CVY_VERSION_MINOR       4
#define CVY_VERSION_FULL        (CVY_VERSION_MINOR | (CVY_VERSION_MAJOR << 8))

#define CVY_WIN2K_VERSION       L"V2.3"
#define CVY_WIN2K_VERSION_FULL  0x00000203

#define CVY_NT40_VERSION        L"V2.1"
#define CVY_NT40_VERSION_FULL   0x00000201


#define CVY_NAME                L"WLBS"
#define CVY_NAME_MULTI_NIC      L"WLBS Cluster " /* ###### added for multi nic support log messages -- ramkrish */
#define CVY_HELP_FILE           L"WLBS.CHM"
#define CVY_CTXT_HELP_FILE      L"WLBS.HLP"
#define CVY_DEVICE_NAME         L"\\Device\\WLBS"
#define CVY_DOSDEVICE_NAME      L"\\DosDevices\\WLBS"

#define CVY_PARAMS_VERSION      4       /* current version of parameter
                                           structure */
#define CVY_MAX_USABLE_RULES    32      /* maximum # port rules  */
#define CVY_MAX_RULES           33      /* maximum # port rules + 1 */
#define CVY_MAX_HOSTS           32      /* maximum # of hosts */

/* filtering modes for port groups */

#define CVY_SINGLE              1       /* single server mode */
#define CVY_MULTI               2       /* multi-server mode (load balanced) */
#define CVY_NEVER               3       /* mode for never handled by this server */

/* protocol qualifiers for port rules */

#define CVY_TCP                 1       /* TCP protocol */
#define CVY_UDP                 2       /* UDP protocol */
#define CVY_TCP_UDP             3       /* TCP or UDP protocols */

/* server affinity values for multiple filtering mode */

#define CVY_AFFINITY_NONE       0       /* no affinity (scale single client) */
#define CVY_AFFINITY_SINGLE     1       /* single client affinity */
#define CVY_AFFINITY_CLASSC     2       /* Class C affinity */

#define CVY_HOST_STATE_STOPPED      0          /* do NOT start the cluster */
#define CVY_HOST_STATE_STARTED      1          /* start the cluster */
#define CVY_HOST_STATE_SUSPENDED    2          /* suspend the cluster */

#define CVY_PERSIST_STATE_STOPPED   0x00000001 /* persist the stopped state across reboots. */
#define CVY_PERSIST_STATE_STARTED   0x00000002 /* persist the started state across reboots. */
#define CVY_PERSIST_STATE_SUSPENDED 0x00000004 /* persist the suspended state across reboots. */

/* registry key names */

#define CVY_NAME_NET_ADDR       L"NetworkAddress"
#define CVY_NAME_SAVED_NET_ADDR L"WLBSSavedNetworkAddress"
#define CVY_TYPE_NET_ADDR       REG_SZ

#define CVY_NAME_BDA_TEAMING      L"BDATeaming"
#define CVY_NAME_BDA_TEAM_ID      L"TeamID"
#define CVY_NAME_BDA_MASTER       L"Master"
#define CVY_NAME_BDA_REVERSE_HASH L"ReverseHash"

#define CVY_NAME_VERSION        L"ParametersVersion"
#define CVY_NAME_DED_IP_ADDR    L"DedicatedIPAddress"
#define CVY_NAME_DED_NET_MASK   L"DedicatedNetworkMask"
#define CVY_NAME_HOST_PRIORITY  L"HostPriority"
#define CVY_NAME_VIRTUAL_NIC    L"VirtualNICName"
#define CVY_NAME_CLUSTER_NIC    L"ClusterNICName"
#define CVY_NAME_NETWORK_ADDR   L"ClusterNetworkAddress"
#define CVY_NAME_CL_IP_ADDR     L"ClusterIPAddress"
#define CVY_NAME_CL_NET_MASK    L"ClusterNetworkMask"
#define CVY_NAME_CLUSTER_MODE   L"ClusterModeOnStart"
#define CVY_NAME_HOST_STATE       L"HostState"
#define CVY_NAME_PERSISTED_STATES L"PersistedStates"
#define CVY_NAME_ALIVE_PERIOD   L"AliveMsgPeriod"
#define CVY_NAME_ALIVE_TOLER    L"AliveMsgTolerance"
#define CVY_NAME_NUM_ACTIONS    L"NumActions"
#define CVY_NAME_NUM_PACKETS    L"NumPackets"
#define CVY_NAME_NUM_SEND_MSGS  L"NumAliveMsgs"
#define CVY_NAME_DOMAIN_NAME    L"ClusterName"
#define CVY_NAME_INSTALL_DATE   L"InstallDate"
#define CVY_NAME_VERIFY_DATE    L"VerifyDate"
#define CVY_NAME_LICENSE_KEY    L"LicenseKey"
#define CVY_NAME_RMT_PASSWORD   L"RemoteMaintenanceEnabled"
#define CVY_NAME_RCT_PASSWORD   L"RemoteControlCode"
#define CVY_NAME_RCT_PORT       L"RemoteControlUDPPort"
#define CVY_NAME_RCT_ENABLED    L"RemoteControlEnabled"
#define CVY_NAME_NUM_RULES      L"NumberOfRules"
#define CVY_NAME_CUR_VERSION    L"CurrentVersion"
#define CVY_NAME_OLD_PORT_RULES L"PortRules"            /* Path in registry to old port rules. api\params.cpp, driver params.c and answer file use this. */
#define CVY_NAME_PORT_RULES     L"PortRules"            /* Path in registry to current port rules */
#define CVY_NAME_DSCR_PER_ALLOC L"DescriptorsPerAlloc"
#define CVY_NAME_MAX_DSCR_ALLOCS L"MaxDescriptorAllocs"
#define CVY_NAME_SCALE_CLIENT   L"ScaleSingleClient"
#define CVY_NAME_CLEANUP_DELAY  L"ConnectionCleanupDelay"
#define CVY_NAME_NBT_SUPPORT    L"NBTSupportEnable"
#define CVY_NAME_MCAST_SUPPORT  L"MulticastSupportEnable"
#define CVY_NAME_MCAST_SPOOF    L"MulticastARPEnable"
#define CVY_NAME_MASK_SRC_MAC   L"MaskSourceMAC"
#define CVY_NAME_NETMON_ALIVE   L"NetmonAliveMsgs"
#define CVY_NAME_EFFECTIVE_VERSION   L"EffectiveVersion"
#define CVY_NAME_IP_CHG_DELAY   L"IPChangeDelay"
#define CVY_NAME_CONVERT_MAC    L"IPToMACEnable"
#define CVY_NAME_PORTS          L"Ports"                /* for answer file use only */
#define CVY_NAME_PASSWORD       L"RemoteControlPassword"/* for answer file use only */
#define CVY_NAME_PORTRULE_VIPALL     L"All"             /* for answer file use only */
#define CVY_NAME_FILTER_ICMP    L"FilterICMP"
#define CVY_NAME_ID_HB_PERIOD   L"IdentityHeartbeatPeriod"
#define CVY_NAME_ID_HB_ENABLED  L"IdentityHeartbeatEnabled"

/* Connection descriptor timeouts. */
#define CVY_NAME_TCP_TIMEOUT    L"TCPConnectionTimeout"
#define CVY_NAME_IPSEC_TIMEOUT  L"IPSecConnectionTimeout"

#define CVY_NAME_CODE           L"Private"
#define CVY_NAME_VIP            L"VirtualIPAddress"
#define CVY_NAME_START_PORT     L"StartPort"
#define CVY_NAME_END_PORT       L"EndPort"
#define CVY_NAME_PROTOCOL       L"Protocol"
#define CVY_NAME_MODE           L"Mode"
#define CVY_NAME_PRIORITY       L"Priority"
#define CVY_NAME_EQUAL_LOAD     L"EqualLoad"
#define CVY_NAME_LOAD           L"Load"
#define CVY_NAME_AFFINITY       L"Affinity"

//
// IGMP support registry entries
//
#define CVY_NAME_IGMP_SUPPORT   L"IGMPSupport"
#define CVY_NAME_MCAST_IP_ADDR  L"McastIPAddress"
#define CVY_NAME_IP_TO_MCASTIP  L"IPtoMcastIP"


/* registry key value ranges */

#define CVY_MIN_VERSION         1
#define CVY_MAX_VERSION         CVY_PARAMS_VERSION

#define CVY_MIN_HOST_PRIORITY   1
#define CVY_MAX_HOST_PRIORITY   CVY_MAX_HOSTS

#define CVY_MIN_ALIVE_PERIOD    100
#define CVY_MAX_ALIVE_PERIOD    10000

#define CVY_MIN_ALIVE_TOLER     5
#define CVY_MAX_ALIVE_TOLER     100

#define CVY_MIN_NUM_PACKETS     5
#define CVY_MAX_NUM_PACKETS     500    /* V2.1.1 */

#define CVY_MIN_NUM_ACTIONS     5
#define CVY_MAX_NUM_ACTIONS     500     /* V1.1.2 */

#define CVY_MIN_MAX_HOSTS       1
#define CVY_MAX_MAX_HOSTS       CVY_MAX_HOSTS

#define CVY_MIN_MAX_RULES       0
#define CVY_MAX_MAX_RULES       (CVY_MAX_RULES - 1)

#define CVY_MIN_RCT_CODE        0
#define CVY_MAX_RCT_CODE        LICENSE_STR_IMPORTANT_CHARS

#define CVY_MIN_NUM_RULES       0
#define CVY_MAX_NUM_RULES       (CVY_MAX_RULES - 1)

#define CVY_MIN_FT_RULES        0
#define CVY_MAX_FT_RULES        1

#define CVY_MIN_NUM_SEND_MSGS   (CVY_MAX_MAX_HOSTS + 1) * 2
#define CVY_MAX_NUM_SEND_MSGS   (CVY_MAX_MAX_HOSTS + 1) * 10

#define CVY_MIN_PORT            0
#define CVY_MAX_PORT            65535

#define CVY_MIN_PROTOCOL        CVY_TCP
#define CVY_MAX_PROTOCOL        CVY_TCP_UDP

#define CVY_MIN_MODE            CVY_SINGLE
#define CVY_MAX_MODE            CVY_NEVER

#define CVY_MIN_EQUAL_LOAD      0
#define CVY_MAX_EQUAL_LOAD      1

#define CVY_MIN_LOAD            0
#define CVY_MAX_LOAD            100

#define CVY_MIN_PRIORITY        1
#define CVY_MAX_PRIORITY        CVY_MAX_HOSTS

#define CVY_MIN_CLUSTER_MODE    0
#define CVY_MAX_CLUSTER_MODE    2

#define CVY_MIN_LIC_VERSION     0
#define CVY_MAX_LIC_VERSION     10

#define CVY_MIN_CUR_VERSION     5
#define CVY_MAX_CUR_VERSION     15

#define CVY_MIN_DSCR_PER_ALLOC  16
#define CVY_MAX_DSCR_PER_ALLOC  1024

#define CVY_MIN_MAX_DSCR_ALLOCS 1
#define CVY_MAX_MAX_DSCR_ALLOCS 1024

#define CVY_MIN_SCALE_CLIENT    0
#define CVY_MAX_SCALE_CLIENT    1

#define CVY_MIN_CLEANUP_DELAY   0
#define CVY_MAX_CLEANUP_DELAY   3600000

#define CVY_MIN_NBT_SUPPORT     0
#define CVY_MAX_NBT_SUPPORT     1

#define CVY_MIN_MCAST_SUPPORT   0
#define CVY_MAX_MCAST_SUPPORT   1

#define CVY_MIN_MCAST_SPOOF     0
#define CVY_MAX_MCAST_SPOOF     1

#define CVY_MIN_MASK_SRC_MAC    0
#define CVY_MAX_MASK_SRC_MAC    1

#define CVY_MIN_NETMON_ALIVE    0
#define CVY_MAX_NETMON_ALIVE    1

#define CVY_MIN_IP_CHG_DELAY    0
#define CVY_MAX_IP_CHG_DELAY    3600000

#define CVY_MIN_CONVERT_MAC     0
#define CVY_MAX_CONVERT_MAC     1

#define CVY_MIN_RCT_PORT        1
#define CVY_MAX_RCT_PORT        65535

#define CVY_MIN_RCT_ENABLED     0
#define CVY_MAX_RCT_ENABLED     1

#define CVY_MIN_ID_HB_PERIOD    10000           /* Units are ms */
#define CVY_MAX_ID_HB_PERIOD    0xFFFFFFFF

#define CVY_MIN_ID_HB_ENABLED   0
#define CVY_MAX_ID_HB_ENABLED   1

/* minimum and maximum string length */

#define CVY_MAX_PARAM_STR       100

#define CVY_MIN_VIRTUAL_NIC     0
#define CVY_MAX_VIRTUAL_NIC     256

#define CVY_MIN_CLUSTER_NIC     0
#define CVY_MAX_CLUSTER_NIC     256

#define CVY_MIN_CL_IP_ADDR      7
#define CVY_MAX_CL_IP_ADDR      17

#define CVY_MIN_CL_NET_MASK     7
#define CVY_MAX_CL_NET_MASK     17

#define CVY_MIN_DED_IP_ADDR     7
#define CVY_MAX_DED_IP_ADDR     17

#define CVY_MIN_DED_NET_MASK    7
#define CVY_MAX_DED_NET_MASK    17

#define CVY_MIN_CL_IGMP_ADDR    7
#define CVY_MAX_CL_IGMP_ADDR    17

#define CVY_MIN_VIRTUAL_IP_ADDR 7
#define CVY_MAX_VIRTUAL_IP_ADDR 17

#define CVY_MIN_NETWORK_ADDR    11
#define CVY_MAX_NETWORK_ADDR    17

#define CVY_MIN_LICENSE_KEY     1
#define CVY_MAX_LICENSE_KEY     20

#define CVY_MIN_DOMAIN_NAME     1
#define CVY_MAX_DOMAIN_NAME     100

#define CVY_MIN_HOST_NAME       1
#define CVY_MAX_HOST_NAME       100

#define CVY_MIN_FQDN            1
#define CVY_MAX_FQDN            255

#define CVY_MIN_AFFINITY        0
#define CVY_MAX_AFFINITY        2

#define CVY_MIN_PORTS           9
#define CVY_MAX_PORTS           (CVY_MAX_RULES * 40)

#define CVY_MIN_FILTER_ICMP     0
#define CVY_MAX_FILTER_ICMP     1

/* Connection descriptor timeouts (in seconds). */
#define CVY_MIN_TCP_TIMEOUT     0
#define CVY_MAX_TCP_TIMEOUT     300   /* 5 minutes - don't want this to get too big, or we'll start allocating LOTS of descriptors. */

#define CVY_MIN_IPSEC_TIMEOUT   0
#define CVY_MAX_IPSEC_TIMEOUT   86400 /* 24 hours - this is also the default, so we only allow this timeout to decrease, not increase. */

#define CVY_MAX_BDA_TEAM_ID     40

/* registry key types */

#define CVY_TYPE_VERSION        REG_DWORD
#define CVY_TYPE_HOST_PRIORITY  REG_DWORD
#define CVY_TYPE_VIRTUAL_NIC    REG_SZ
#define CVY_TYPE_CLUSTER_NIC    REG_SZ
#define CVY_TYPE_NETWORK_ADDR   REG_SZ
#define CVY_TYPE_CL_IP_ADDR     REG_SZ
#define CVY_TYPE_CL_NET_MASK    REG_SZ
#define CVY_TYPE_DED_IP_ADDR    REG_SZ
#define CVY_TYPE_DED_NET_MASK   REG_SZ
#define CVY_TYPE_ALIVE_PERIOD   REG_DWORD
#define CVY_TYPE_ALIVE_TOLER    REG_DWORD
#define CVY_TYPE_ALIVE_TOLER    REG_DWORD
#define CVY_TYPE_NUM_PACKETS    REG_DWORD
#define CVY_TYPE_NUM_ACTIONS    REG_DWORD
#define CVY_TYPE_NUM_SEND_MSGS  REG_DWORD
#define CVY_TYPE_DOMAIN_NAME    REG_SZ
#define CVY_TYPE_INSTALL_DATE   REG_DWORD
#define CVY_TYPE_VERIFY_DATE    REG_DWORD
#define CVY_TYPE_LICENSE_KEY    REG_SZ
#define CVY_TYPE_RMT_PASSWORD   REG_DWORD
#define CVY_TYPE_RCT_PASSWORD   REG_DWORD
#define CVY_TYPE_RCT_PORT       REG_DWORD
#define CVY_TYPE_RCT_ENABLED    REG_DWORD
#define CVY_TYPE_ID_HB_PERIOD   REG_DWORD
#define CVY_TYPE_ID_HB_ENABLED  REG_DWORD
#define CVY_TYPE_NUM_RULES      REG_DWORD
#define CVY_TYPE_CUR_VERSION    REG_DWORD
#define CVY_TYPE_PORT_RULES     REG_BINARY
#define CVY_TYPE_CLUSTER_MODE   REG_DWORD
#define CVY_TYPE_HOST_STATE       REG_DWORD
#define CVY_TYPE_PERSISTED_STATES REG_DWORD
#define CVY_TYPE_DSCR_PER_ALLOC REG_DWORD
#define CVY_TYPE_MAX_DSCR_ALLOCS REG_DWORD
#define CVY_TYPE_SCALE_CLIENT   REG_DWORD
#define CVY_TYPE_CLEANUP_DELAY  REG_DWORD
#define CVY_TYPE_NBT_SUPPORT    REG_DWORD
#define CVY_TYPE_MCAST_SUPPORT  REG_DWORD
#define CVY_TYPE_MCAST_SPOOF    REG_DWORD
#define CVY_TYPE_MASK_SRC_MAC   REG_DWORD
#define CVY_TYPE_NETMON_ALIVE   REG_DWORD
#define CVY_TYPE_EFFECTIVE_VERSION   REG_DWORD
#define CVY_TYPE_IP_CHG_DELAY   REG_DWORD
#define CVY_TYPE_CONVERT_MAC    REG_DWORD
#define CVY_TYPE_FILTER_ICMP    REG_DWORD

/* Connection descriptor timeouts. */
#define CVY_TYPE_TCP_TIMEOUT    REG_DWORD
#define CVY_TYPE_IPSEC_TIMEOUT  REG_DWORD

/* Registry key types for port rule */
#define CVY_TYPE_CODE           REG_DWORD
#define CVY_TYPE_VIP            REG_SZ
#define CVY_TYPE_START_PORT     REG_DWORD
#define CVY_TYPE_END_PORT       REG_DWORD
#define CVY_TYPE_PROTOCOL       REG_DWORD
#define CVY_TYPE_MODE           REG_DWORD
#define CVY_TYPE_PRIORITY       REG_DWORD
#define CVY_TYPE_EQUAL_LOAD     REG_DWORD
#define CVY_TYPE_LOAD           REG_DWORD
#define CVY_TYPE_AFFINITY       REG_DWORD

#define CVY_TYPE_IGMP_SUPPORT   REG_DWORD
#define CVY_TYPE_MCAST_IP_ADDR  REG_SZ
#define CVY_TYPE_IP_TO_MCASTIP  REG_DWORD

#define CVY_TYPE_BDA_TEAM_ID      REG_SZ
#define CVY_TYPE_BDA_MASTER       REG_DWORD
#define CVY_TYPE_BDA_REVERSE_HASH REG_DWORD

/* default values */

#define CVY_DEF_UNICAST_NETWORK_ADDR   L"02-bf-00-00-00-00"
#define CVY_DEF_MULTICAST_NETWORK_ADDR L"03-bf-00-00-00-00"
#define CVY_DEF_IGMP_NETWORK_ADDR      L"01-00-5e-7f-00-00"

#define CVY_DEF_HOST_PRIORITY   1
#define CVY_DEF_VERSION         CVY_PARAMS_VERSION
#define CVY_DEF_VIRTUAL_NIC     L""
#define CVY_DEF_CLUSTER_NIC     L""
#define CVY_DEF_DOMAIN_NAME     L"cluster.domain.com"
#define CVY_DEF_NETWORK_ADDR    L"00-00-00-00-00-00"
#define CVY_DEF_CL_IP_ADDR      L"0.0.0.0"
#define CVY_DEF_CL_NET_MASK     L"0.0.0.0"
#define CVY_DEF_DED_IP_ADDR     L"0.0.0.0"
#define CVY_DEF_DED_NET_MASK    L"0.0.0.0"
#define CVY_DEF_ALL_VIP         L"255.255.255.255"
#define CVY_DEF_ALIVE_PERIOD    1000
#define CVY_DEF_ALIVE_TOLER     5
#define CVY_DEF_NUM_PACKETS     200     /* V1.2.1 */
#define CVY_DEF_NUM_ACTIONS     100     /* V1.1.2 */
#define CVY_DEF_NUM_SEND_MSGS   (CVY_MAX_MAX_HOSTS + 1) * 2
#define CVY_DEF_INSTALL_DATE    0
#define CVY_DEF_CLUSTER_MODE    1
#define CVY_DEF_PERSISTED_STATES 0x00000000
#define CVY_DEF_LICENSE_KEY     LICENSE_TRIAL_CODE
#define CVY_DEF_RMT_PASSWORD    0
#define CVY_DEF_RCT_PASSWORD    0
#define CVY_DEF_RCT_PORT        2504
#define CVY_DEF_RCT_PORT_OLD    1717
#define CVY_DEF_RCT_ENABLED     0       /* V2.1.5 */
#define CVY_DEF_ID_HB_PERIOD    10000
#define CVY_DEF_ID_HB_ENABLED   1

#define CVY_DEF_PORT_START      0
#define CVY_DEF_PORT_END        65535
#define CVY_DEF_PROTOCOL        CVY_TCP_UDP
#define CVY_DEF_MODE            CVY_MULTI
#define CVY_DEF_EQUAL_LOAD      1
#define CVY_DEF_LOAD            50
#define CVY_DEF_PRIORITY        1
#define CVY_DEF_AFFINITY        CVY_AFFINITY_SINGLE

#define CVY_DEF_DSCR_PER_ALLOC  512
#define CVY_DEF_MAX_DSCR_ALLOCS 512
#define CVY_DEF_SCALE_CLIENT    0
#define CVY_DEF_CLEANUP_DELAY   300000
#define CVY_DEF_NBT_SUPPORT     1
#define CVY_DEF_MCAST_SUPPORT   0
#define CVY_DEF_MCAST_SPOOF     1
#define CVY_DEF_MASK_SRC_MAC    1
#define CVY_DEF_NETMON_ALIVE    0
#define CVY_DEF_IP_CHG_DELAY    60000
#define CVY_DEF_CONVERT_MAC     1
#define CVY_DEF_FILTER_ICMP     0

#define CVY_DEF_IGMP_SUPPORT    FALSE
#define CVY_DEF_MCAST_IP_ADDR   L"0.0.0.0"
#define CVY_DEF_IGMP_INTERVAL   60000
#define CVY_DEF_IP_TO_MCASTIP   TRUE

/* Connection descriptor timeouts (in seconds). */
#define CVY_DEF_TCP_TIMEOUT         60    /* 1 minute */
#define CVY_DEF_IPSEC_TIMEOUT       86400 /* 24 hours */

/* Connection descriptor cleanup paramters. */
#define CVY_DEF_DSCR_PURGE_INTERVAL 10000 /* Interval, in ms. */
#define CVY_DEF_DSCR_PURGE_LIMIT    50    /* Maximum number of descriptors to service per interval. */

#define CVY_DEF_BDA_ACTIVE       0
#define CVY_DEF_BDA_MASTER       0
#define CVY_DEF_BDA_REVERSE_HASH 0
#define CVY_DEF_BDA_TEAM_ID      '\0'

/* For virtual clusters, this the encoded "ALL VIPs".  Note: The user-level port
   rule sorting code DEPENDS on this value being 255.255.255.255.  If this value
   is changed, then the sorting code must also be change to ensure that port rules
   with this VIP are placed at the end of the sorted list.  By choosing 0xffffffff,
   this is done "automatically" by the sorting code; i.e. it is not a special case. */
#define CVY_ALL_VIP_NUMERIC_VALUE  0xffffffff


#define CVY_RULE_CODE_GET(rulep) ((rulep) -> code)
#define CVY_RULE_CODE_SET(rulep) ((rulep) -> code =                          \
                                 ((ULONG) (((rulep) -> start_port) <<  0) | \
                                   (ULONG) (((rulep) -> end_port)   << 12) | \
                                   (ULONG) (((rulep) -> protocol)   << 24) | \
                                   (ULONG) (((rulep) -> mode)       << 28) | \
                                   (ULONG) (((rulep) -> mode == CVY_MULTI ? \
                                   (rulep) -> mode_data . multi . affinity : 0) << 30) \
                                  ) ^ ~((DWORD)(IpAddressFromAbcdWsz((rulep) -> virtual_ip_addr))))

#define CVY_CHECK_MIN(x, y)      if ((x) < (y)) {(x) = (y);}
#define CVY_CHECK_MAX(x, y)      if ((x) > (y)) {(x) = (y);}


//
// WMI Event Tracing Constants
// These GUIDs and level constants are for internal use by NLB.
//

//
// See http://coreos/tech/tracing/ for details.
// Use TraceFormat(level, "fmt", ...) for tracing, where
// "level" is one of the arguments to WPP_DEFINE_BIT below.
// 
//
#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Regular, (e1f65b93,f32a,4ed6,aa72,b039e28f1574), \
        WPP_DEFINE_BIT(Critical)             \
        WPP_DEFINE_BIT(Informational)        \
        WPP_DEFINE_BIT(Verbose)              \
        WPP_DEFINE_BIT(Full)                 \
        WPP_DEFINE_BIT(Convergence)          \
        )    \
    WPP_DEFINE_CONTROL_GUID(Packets, (f498b9f5,9e67,446a,b9b8,1442ffaef434), \
        WPP_DEFINE_BIT(Heartbeats)           \
        WPP_DEFINE_BIT(AllPackets)           \
        WPP_DEFINE_BIT(Filtering)            \
        )

#endif /* _Params_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\inc\nsuacl.h ===
// Copyright (c) 1997-2002 Microsoft Corporation
//
// Module:
//
//     Network Security Utilities
//
// Abstract:
//
//     Acl API's
//
// Authors:
//
//     pmay 2/5/02
//     raymonds 03/20/02
//
// Environment:
//
//     User mode
//
// Revision History:
//

// Description:
//
//     Flags passed to NsuAclCreate*
//

#include <aclapi.h>
#include <sddl.h>

#define NSU_ACL_F_AdminFull		    0x1
#define NSU_ACL_F_LocalSystemFull	0x2

DWORD
NsuAclAttributesCreate(
    OUT PSECURITY_ATTRIBUTES* ppSecurityAttributes,
	IN DWORD dwFlags);

DWORD
NsuAclAttributesDestroy(
	IN OUT PSECURITY_ATTRIBUTES* ppAttributes);

DWORD
NsuAclDescriptorCreate (
    OUT PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
	IN DWORD dwFlags);
	
DWORD
NsuAclDescriptorDestroy(
	IN OUT PSECURITY_DESCRIPTOR* ppDescriptor);

DWORD
NsuAclDescriptorRestricts(
	IN CONST PSECURITY_DESCRIPTOR pSD,
	OUT BOOL* pbRestricts);

DWORD
NsuAclGetRegKeyDescriptor(
    IN  HKEY hKey,
    OUT PSECURITY_DESCRIPTOR* ppSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
FAR PASCAL
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (FAR PASCAL * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001
#define WSCNTL_TCPIP_ICMP_ECHO				0x00000002


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\wzcsapi.h ===
#pragma once

# ifdef     __cplusplus
extern "C" {
# endif

PVOID
MIDL_user_allocate(size_t NumBytes);

VOID
MIDL_user_free(void * MemPointer);

//---------------------------------------
// Macros for handling additional attributes on WZC_WLAN_CONFIG structures
// Coding of additional attributes in the Reserved bytes of WZC_WLAN_CONFIG objects:
// Reserved
// [1]      [0]
// ---SSSAA CCCCCCCC
// SSS = [0-7; used: 0-6] selection set category, one of VPI, VI, PI, VPA, VA, PA, N
// AA  = [0-3; used: 0-3] authentication mode, NDIS_802_11_AUTHENTICATION_MODE value
// CCCCCCCC = [0-255] retry counter for this object.
//
#define NWB_AUTHMODE_MASK       0x03
#define NWB_SELCATEG_MASK       0x1C

#define NWB_SET_AUTHMODE(pNWB, nAM)     (pNWB)->Reserved[1] = (((pNWB)->Reserved[1] & ~NWB_AUTHMODE_MASK) | ((nAM) & NWB_AUTHMODE_MASK))
#define NWB_GET_AUTHMODE(pNWB)          ((pNWB)->Reserved[1] & NWB_AUTHMODE_MASK)

#define NWB_SET_SELCATEG(pNWB, nSC)     (pNWB)->Reserved[1] = (((pNWB)->Reserved[1] & ~NWB_SELCATEG_MASK) | (((nSC)<<2) & NWB_SELCATEG_MASK))
#define NWB_GET_SELCATEG(pNWB)          (((pNWB)->Reserved[1] & NWB_SELCATEG_MASK)>>2)

//---------------------------------------
// [P]RAW_DATA: generic description of a BLOB
typedef struct
{
    DWORD   dwDataLen;
#if defined(MIDL_PASS)
    [unique, size_is(dwDataLen)] LPBYTE pData;
#else
    LPBYTE  pData;
#endif
} RAW_DATA, *PRAW_DATA;

#if !defined(MIDL_PASS)

#include <ntddndis.h>
#define WZCCTL_MAX_WEPK_MATERIAL   32
#define WZCCTL_WEPK_PRESENT        0x0001  // specifies whether the configuration includes or not a WEP key
#define WZCCTL_WEPK_XFORMAT        0x0002  // the WEP Key material (if any) is entered as hexadecimal digits
#define WZCCTL_VOLATILE            0x0004  // this configuration should not be stored
#define WZCCTL_POLICY              0x0008  // this configuration is enforced by the policy

//---------------------------------------
// [P]WZC_WLAN_CONFIG: like NDIS_WLAN_BSSID, but contains all the additional
// data that defines a [Preferred] Wireless Zero Configuration
typedef struct
{
    ULONG                               Length;             // Length of this structure
    DWORD                               dwCtlFlags;         // control flags (NON-NDIS) see WZC_WEPK* constants
    // fields from the NDIS_WLAN_BSSID structure
    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
    UCHAR                               Reserved[2];
    NDIS_802_11_SSID                    Ssid;               // SSID
    ULONG                               Privacy;            // WEP encryption requirement
    NDIS_802_11_RSSI                    Rssi;               // receive signal strength in dBm
    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
    NDIS_802_11_CONFIGURATION           Configuration;
    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
    NDIS_802_11_RATES                   SupportedRates;
    // fields from NDIS_802_11_WEP structure
    ULONG   KeyIndex;                               // 0 is the per-client key, 1-N are the global keys
    ULONG   KeyLength;                              // length of key in bytes
    UCHAR   KeyMaterial[WZCCTL_MAX_WEPK_MATERIAL];  // variable length depending on above field
    // aditional field for the Authentication mode
    NDIS_802_11_AUTHENTICATION_MODE     AuthenticationMode;
    RAW_DATA                            rdUserData;         // upper level buffer, attached to this config
} WZC_WLAN_CONFIG, *PWZC_WLAN_CONFIG;

//---------------------------------------
// [P]WZC_802_11_CONFIG_LIST: like NDIS_802_11_BSSID_LIST but indexes a
// set of [Preferred] Wireless Zero Configurations
typedef struct
{
    ULONG           NumberOfItems;  // number of elements in the array below
    ULONG           Index;          // [start] index in the array below
    WZC_WLAN_CONFIG Config[1];      // array of WZC_WLAN_CONFIGs
} WZC_802_11_CONFIG_LIST, *PWZC_802_11_CONFIG_LIST;

// WZC dialog codes have the 16th bit set to 1. This is what quickly sepparates them from EAPOL signals.
#define WZCDLG_IS_WZC(x)         (((x) & 0x00010000) == 0x00010000)
#define WZCDLG_FAILED            0x00010001     // 802.11 automatic configuration failed

// Dialog BLOB passed through the UI pipe to netman and wzcdlg
typedef struct _WZCDLG_DATA
{
    DWORD       dwCode;
    DWORD       lParam; // long numeric data
} WZCDLG_DATA, *PWZCDLG_DATA;

#endif

//---------------------------------------
// [P]INTF_ENTRY: describes the key info for one interface
// this is used in conjunction with [P]INTFS_KEY_TABLE and WZCEnumInterfaces
typedef struct
{
#if defined(MIDL_PASS)
    [unique, string] LPWSTR wszGuid;
#else
    LPWSTR wszGuid;
#endif
} INTF_KEY_ENTRY, *PINTF_KEY_ENTRY;

//---------------------------------------
// [P]INTFS_KEY_TABLE: describes the table of key info for all interfaces
// this is used in conjunction with [P]INTF_KEY_ENTRY and WZCEnumInterfaces
typedef struct
{
    DWORD dwNumIntfs;
#if defined(MIDL_PASS)
    [size_is(dwNumIntfs)] PINTF_KEY_ENTRY pIntfs;
#else
    PINTF_KEY_ENTRY pIntfs;
#endif
} INTFS_KEY_TABLE, *PINTFS_KEY_TABLE;

//---------------------------------------
// Bits used in conjunction with INTF_ENTRY, WZCQueryInterface
// and WZCSetInterface. They point to the relevant information
// that is requested from the service or to the relevant information
// to be set down to the interface. On the output, they point to
// the information that was processed (queried/set) successfully.
#define INTF_ALL            0xffffffff

#define INTF_ALL_FLAGS      0x0000ffff
#define INTF_CM_MASK        0x00000007   // mask for the configuration mode (NDIS_802_11_NETWORK_INFRASTRUCTURE value)
#define INTF_ENABLED        0x00008000   // zero conf enabled for this interface
#define INTF_FALLBACK       0x00004000   // attempt to connect to visible non-preferred networks also
#define INTF_OIDSSUPP       0x00002000   // 802.11 OIDs are supported by the driver/firmware (can't be set)
#define INTF_VOLATILE       0x00001000   // the service parameters are volatile.
#define INTF_POLICY         0x00000800   // the service parameters are enforced by the policy.

#define INTF_DESCR          0x00010000
#define INTF_NDISMEDIA      0x00020000
#define INTF_PREFLIST       0x00040000

#define INTF_ALL_OIDS       0xfff00000
#define INTF_HANDLE         0x00100000
#define INTF_INFRAMODE      0x00200000
#define INTF_AUTHMODE       0x00400000
#define INTF_WEPSTATUS      0x00800000
#define INTF_SSID           0x01000000
#define INTF_BSSID          0x02000000
#define INTF_BSSIDLIST      0x04000000
#define INTF_LIST_SCAN      0x08000000
#define INTF_ADDWEPKEY      0x10000000
#define INTF_REMWEPKEY      0x20000000
#define INTF_LDDEFWKEY      0x40000000  // reload the default WEP_KEY

//---------------------------------------
// Bits used to specify particular control options for the interface
// entry
#define INTFCTL_CM_MASK     0x0007   // mask for the configuration mode (NDIS_802_11_NETWORK_INFRASTRUCTURE value)
#define INTFCTL_ENABLED     0x8000   // zero conf enabled for this interface
#define INTFCTL_FALLBACK    0x4000   // attempt to connect to visible non-preferred networks also
#define INTFCTL_OIDSSUPP    0x2000   // 802.11 OIDs are supported by the driver/firmware (can't be set)
#define INTFCTL_VOLATILE    0x1000   // the service parameters are volatile.
#define INTFCTL_POLICY      0x0800   // the service parameters policy enforced.

//---------------------------------------
// [P]INTF_ENTRY: contains everything an RPC client needs to know
// about an interface. It is used in conjunction with RpcQueryInterface.
// Flags below are to be used to specify what info is queried for the
// interface. Guid field is not covered since this is the key of the
// structure so it has to be specified eather way.
typedef struct
{
#if defined(MIDL_PASS)
    [string] LPWSTR wszGuid;
#else
    LPWSTR          wszGuid;
#endif
#if defined(MIDL_PASS)
    [string] LPWSTR wszDescr;
#else
    LPWSTR          wszDescr;
#endif
    ULONG           ulMediaState;
    ULONG           ulMediaType;
    ULONG           ulPhysicalMediaType;
    INT             nInfraMode;
    INT             nAuthMode;
    INT             nWepStatus;
    DWORD           dwCtlFlags;     // control flags (see INTFCTL_* defines)
    RAW_DATA        rdSSID;         // encapsulates the SSID raw binary
    RAW_DATA        rdBSSID;        // encapsulates the BSSID raw binary
    RAW_DATA        rdBSSIDList;    // encapsulates one WZC_802_11_CONFIG_LIST structure
    RAW_DATA        rdStSSIDList;   // encapsulates one WZC_802_11_CONFIG_LIST structure
    RAW_DATA        rdCtrlData;     // data for various control actions on the interface
} INTF_ENTRY, *PINTF_ENTRY;


//---------------------------------------
// Defines and datastucture for handling the WZC Service Context (generic service params)

// Default values for WZC internal timers (WZC_CONTEXT.tmT* fields)
#define TMMS_DEFAULT_TR	0x00000bb8      // Timeout until a rescan completes: ms (3sec)
#define TMMS_DEFAULT_TC 0x0000ea60      // Timeout to retry a valid configuration: ms (1min) 
#define TMMS_DEFAULT_TP 0x000007d0      // Timeout to expect a media connect for a selected config: ms (2sec)
#define TMMS_DEFAULT_TF 0x0000ea60      // Timeout to recover from a failed configuration: ms (1min)
#define TMMS_DEFAULT_TD 0x00001388      // Timeout to delay the {SSr} processing: ms (5sec)

// Default turns logging on
#define WZC_CTXT_LOGGING_ON      0x00000001 

// Structure: WZC_CONTEXT holds all global service options that may be customized
typedef struct _wzc_context_t
{
  DWORD dwFlags;            //service flags (see WZC_CTXT_*)
  //Service specific timers
  DWORD tmTr;               //Rescan timeout
  DWORD tmTc;               //Retry valid config timeout
  DWORD tmTp;               //Timeout to expect a media connect
  DWORD tmTf;               //Timeout to recover from an invalid config
  DWORD tmTd;               //Timeout to delay {Ssr} processing
} WZC_CONTEXT, *PWZC_CONTEXT;

// Context control flags (see WZCSet/QueryContext() calls)
#define WZC_CONTEXT_CTL_LOG         0x00000001
#define WZC_CONTEXT_CTL_TIMER_TR	0x00000002
#define WZC_CONTEXT_CTL_TIMER_TC	0x00000004
#define WZC_CONTEXT_CTL_TIMER_TP	0x00000008
#define WZC_CONTEXT_CTL_TIMER_TF	0x00000010
#define WZC_CONTEXT_CTL_TIMER_TD	0x00000020


//---------------------------------------
// Utility Rpc memory management routines
#define RpcCAlloc(nBytes)   MIDL_user_allocate(nBytes)
#define RpcFree(pMem)       MIDL_user_free(pMem)

//---------------------------------------
// WZCDeleteIntfObj: cleans an INTF_ENTRY object that is
// allocated within any RPC call.
// 
// Parameters
// pIntf
//     [in] pointer to the INTF_ENTRY object to delete
VOID
WZCDeleteIntfObj(
    PINTF_ENTRY pIntf);

//---------------------------------------
// WZCEnumInterfaces: provides the table of key
// information for all the interfaces that are managed.
// For all subsequent calls the clients need to identify
// the Interface it operates on by providing the respective
// key info.
//
// Parameters:
//   pSrvAddr
//     [in] WZC Server to contact
//   pIntf
//     [out] table of key info for all interfaces
// Returned value:
//     Win32 error code 
DWORD
WZCEnumInterfaces(
    LPWSTR           pSrvAddr,
    PINTFS_KEY_TABLE pIntfs);

//---------------------------------------
// WZCQueryIterface: provides detailed information for a
// given interface.
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be queried (bitmask of INTF_*)
//   pIntf:
//     [in]  Key of the interface to query
//     [out] Requested data from the interface.
//   pdwOutFlags
//     [out] Fields successfully retrieved (bitmask of INTF_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCQueryInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags);

//---------------------------------------
// WZCSetIterface: sets specific information on the interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be set (bitmask of INTF_*)
//   pIntf:
//     [in]  Key of the interface to query and data to be set
//   pdwOutFlags:
//     [out] Fields successfully set (bitmask of INTF_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCSetInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags);

//---------------------------------------
// WZCRefreshInterface: refreshes specific information for the interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be refreshed and specific refresh actions to be
//           taken (bitmask of INTF_*)
//   pIntf:
//     [in]  Key of the interface to be refreshed
//   pdwOutFlags:
//     [out] Fields successfully refreshed (bitmask of INTF_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCRefreshInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags);


//---------------------------------------
// WZCQueryContext: retrieves the WZC service parameters
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be retrieved (bitmask of WZC_CONTEXT_CTL*)
//   pContext:
//     [in]  Placeholder for the service parameters
//   pdwOutFlags:
//     [out] Fields successfully retrieved (bitmask of WZC_CONTEXT_CTL*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCQueryContext(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PWZC_CONTEXT        pContext,
    LPDWORD             pdwOutFlags);


//---------------------------------------
// WZCSetContext: sets specific WZC service parameters
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be set (bitmask of WZC_CONTEXT_CTL*)
//   pContext:
//     [in]  Context buffer containing the specific parameters to be set
//   pdwOutFlags:
//     [out] Fields successfully set (bitmask of WZC_CONTEXT_CTL*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCSetContext(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PWZC_CONTEXT        pContext,
    LPDWORD             pdwOutFlags);

//============================================================================================
//
// EAPOL-related definitions
//

#define EAPOL_DISABLED                  0
#define EAPOL_ENABLED                   0x80000000

#define EAPOL_MACHINE_AUTH_DISABLED     0
#define EAPOL_MACHINE_AUTH_ENABLED      0x40000000

#define EAPOL_GUEST_AUTH_DISABLED       0
#define EAPOL_GUEST_AUTH_ENABLED        0x20000000

#define EAP_TYPE_MD5                    4
#define EAP_TYPE_TLS                    13
#define EAP_TYPE_PEAP                   25
#define EAP_TYPE_MSCHAPv2               26

#define DEFAULT_EAP_TYPE                EAP_TYPE_TLS
#define DEFAULT_EAPOL_STATE             EAPOL_ENABLED
#define DEFAULT_MACHINE_AUTH_STATE      EAPOL_MACHINE_AUTH_ENABLED
#define DEFAULT_GUEST_AUTH_STATE        EAPOL_GUEST_AUTH_DISABLED

#define DEFAULT_EAP_STATE               (DEFAULT_EAPOL_STATE | DEFAULT_MACHINE_AUTH_STATE | DEFAULT_GUEST_AUTH_STATE)

#define IS_EAPOL_ENABLED(x) \
    ((x & EAPOL_ENABLED)?1:0)
#define IS_MACHINE_AUTH_ENABLED(x) \
    ((x & EAPOL_MACHINE_AUTH_ENABLED)?1:0)
#define IS_GUEST_AUTH_ENABLED(x) \
    ((x & EAPOL_GUEST_AUTH_ENABLED)?1:0)

// Supplicant modes of operation depending on network state and 
// administrator decision

#define     SUPPLICANT_MODE_0       0
#define     SUPPLICANT_MODE_1       1
#define     SUPPLICANT_MODE_2       2
#define     SUPPLICANT_MODE_3       3
#define     MAX_SUPPLICANT_MODE     SUPPLICANT_MODE_3
#define     EAPOL_DEFAULT_SUPPLICANT_MODE   SUPPLICANT_MODE_2

// Auth modes of operation depending on administrator decision

#define     EAPOL_AUTH_MODE_0       0
#define     EAPOL_AUTH_MODE_1       1
#define     EAPOL_AUTH_MODE_2       2
#define     MAX_EAPOL_AUTH_MODE     EAPOL_AUTH_MODE_2
#define     EAPOL_DEFAULT_AUTH_MODE   EAPOL_AUTH_MODE_1

#define     GUID_STRING_LEN_WITH_TERM   39

//
// Heap-related functions
//
#define MALLOC(s)               HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define FREE(p)                 HeapFree(GetProcessHeap(), 0, (p))


// Double-threaded linked list node control block.  There is one node for each
// entry in a list.
//
// Applications should not access this structure directly.
//
typedef struct
_DTLNODE
{
    struct _DTLNODE* pdtlnodePrev; // Address of previous node or NULL if none
    struct _DTLNODE* pdtlnodeNext; // Address of next node or NULL if none
    VOID*    pData;        // Address of user's data
    LONG_PTR lNodeId;      // User-defined node identification code
}
DTLNODE;


//
// Double-threaded linked list control block.  There is one for each list.
//
// Applications should not access this structure directly.
//

typedef struct
_DTLLIST
{
    struct _DTLNODE* pdtlnodeFirst; // Address of first node or NULL if none
    struct _DTLNODE* pdtlnodeLast;  // Address of last node or NULL if none
    LONG     lNodes;        // Number of nodes in list
    LONG_PTR lListId;       // User-defined list identification code
}
DTLLIST;


// List node free function.  See FreeList.
//
typedef VOID (*PDESTROYNODE)( IN DTLNODE* );

#define DtlGetFirstNode( pdtllist )   ((pdtllist)->pdtlnodeFirst)
#define DtlGetNextNode( pdtlnode )    ((pdtlnode)->pdtlnodeNext)
#define DtlGetData( pdtlnode )        ((pdtlnode)->pData)

typedef enum _EAPTLS_CONNPROP_ATTRIBUTE_TYPE_
{

    ecatMinimum = 0,            //Undefined
    ecatFlagRegistryCert,       //Value is a pointer to BOOL
    ecatFlagScard,              //Value is a pointer to BOOL
    ecatFlagValidateServer,     //Value is a pointer to BOOL
    ecatFlagValidateName,       //Value is a pointer to BOOL
    ecatFlagDiffUser,           //Value is a pointer to BOOL
    ecatServerNames,            //Value is a pointer to NULL 
                                //terminated string of semi
                                //colon delimited server names
    ecatRootHashes              //Value is a pointer to 
                                //SHA1 hashes of Root certs.

}EAPTLS_CONNPROP_ATTRIBUTE_TYPE;

typedef struct _EAPTLS_CONNPROP_ATTRIBUTE
{

    EAPTLS_CONNPROP_ATTRIBUTE_TYPE  ecaType;
    DWORD                           dwLength;   //includes byte length of the value
                                                //if it is a LPWSTR, it includes
                                                //the null termination.
    PVOID                           Value;

}EAPTLS_CONNPROP_ATTRIBUTE, *PEAPTLS_CONNPROP_ATTRIBUTE;


// EAP configuration DLL entrypoints.  These definitions must match the
// raseapif.h prototypes for RasEapInvokeConfigUI and RasEapFreeUserData.

typedef DWORD (APIENTRY * RASEAPFREE)( PBYTE );
typedef DWORD (APIENTRY * RASEAPINVOKECONFIGUI)( DWORD, HWND, DWORD, PBYTE, DWORD, PBYTE*, DWORD*);
typedef DWORD (APIENTRY * RASEAPGETIDENTITY)( DWORD, HWND, DWORD, const WCHAR*, const WCHAR*, PBYTE, DWORD, PBYTE, DWORD, PBYTE*, DWORD*, WCHAR** );
typedef DWORD (APIENTRY * RASEAPINVOKEINTERACTIVEUI)( DWORD, HWND, PBYTE, DWORD, PBYTE*, DWORD* );
typedef DWORD (APIENTRY * RASEAPCREATECONNPROP)( PEAPTLS_CONNPROP_ATTRIBUTE, PVOID*, DWORD*, PVOID*, DWORD*);


#define RAS_EAP_VALUENAME_HIDEPEAPMSCHAPv2       TEXT("HidePEAPMSCHAPv2")

// Flags

#define EAPCFG_FLAG_RequireUsername   0x1
#define EAPCFG_FLAG_RequirePassword   0x2

// EAP configuration package definition.

typedef struct
_EAPCFG
{
    // The package's unique EAP algorithm code.
    //
    DWORD dwKey;

    // The friendly name of the package suitable for display to the user.
    //
    TCHAR* pszFriendlyName;

    // The SystemRoot-relative path to the package's configuration DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszConfigDll;

    // The SystemRoot-relative path to the package's identity DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszIdentityDll;

    // Flags that specify what standard credentials are required at dial
    // time.
    //
    DWORD dwStdCredentialFlags;

    // True if user is to be forced to run the configuration API for the
    // package, i.e. defaults are not sufficient.
    //
    BOOL fForceConfig;

    // True if the package provides MPPE encryption keys, false if not.
    //
    BOOL fProvidesMppeKeys;

    // The package's default configuration blob, which can be overwritten by
    // the configuration DLL.  May be NULL and 0 indicating there is none.
    //
    BYTE* pData;
    DWORD cbData;

    // EAP per user data to be stored in HKCU. This data is returned from
    // the EapInvokeConfigUI entrypoint in the eap dll.
    //
    BYTE* pUserData;
    DWORD cbUserData;

    // Set when the configuration DLL has been called on the package.  This is
    // not a registry setting.  It is provided for the convenience of the UI
    // only.
    //
    BOOL fConfigDllCalled;

    // Specifies the class ID of the configuration UI for remote machines.
    // Not used
    GUID guidConfigCLSID;
} EAPCFG;

VOID     DtlDestroyList( DTLLIST*, PDESTROYNODE );

DTLNODE *
CreateEapcfgNode(
    void);

VOID
DestroyEapcfgNode(
    IN OUT DTLNODE* pNode);

DTLNODE*
EapcfgNodeFromKey(
    IN DTLLIST* pList,
    IN DWORD dwKey);

#define     EAPOL_MUTUAL_AUTH_EAP_ONLY      0x00000001

DTLLIST*
ReadEapcfgList(IN DWORD   dwFlags);

#define MAX_SSID_LEN    32

//
// Structure : EAPOL_INTF_PARAMS
//

typedef struct _EAPOL_INTF_PARAMS
{
    DWORD   dwVersion;
    DWORD   dwReserved2;
    DWORD   dwEapFlags;
    DWORD   dwEapType;
    DWORD   dwSizeOfSSID;
    BYTE    bSSID[MAX_SSID_LEN];
} EAPOL_INTF_PARAMS, *PEAPOL_INTF_PARAMS;


//
// EAPOL states
//

typedef enum _EAPOL_STATE 
{
    EAPOLSTATE_LOGOFF = 0,
    EAPOLSTATE_DISCONNECTED,
    EAPOLSTATE_CONNECTING,
    EAPOLSTATE_ACQUIRED,
    EAPOLSTATE_AUTHENTICATING,
    EAPOLSTATE_HELD,
    EAPOLSTATE_AUTHENTICATED,
    EAPOLSTATE_UNDEFINED
} EAPOL_STATE;

//
// EAP UI State 
//

typedef enum _EAPUISTATE 
{
    EAPUISTATE_WAITING_FOR_IDENTITY = 1,
    EAPUISTATE_WAITING_FOR_UI_RESPONSE
} EAPUISTATE;


//
// Structure : EAPOL_INTF_STATE
//

typedef struct _EAPOL_INTF_STATE
{
#if defined(MIDL_PASS)
    [unique, string]    LPWSTR    pwszLocalMACAddr;
#else
    LPWSTR      pwszLocalMACAddr;
#endif
#if defined(MIDL_PASS)
    [unique, string]    LPWSTR    pwszRemoteMACAddr;
#else
    LPWSTR      pwszRemoteMACAddr;
#endif
    DWORD   dwSizeOfSSID;
    BYTE    bSSID[MAX_SSID_LEN+1];
#if defined(MIDL_PASS)
    [unique, string]    LPSTR    pszEapIdentity;
#else
    LPSTR       pszEapIdentity;
#endif
    EAPOL_STATE     dwState;
    EAPUISTATE      dwEapUIState;
    DWORD   dwEAPOLAuthMode;
    DWORD   dwEAPOLAuthenticationType;
    DWORD   dwEapType;
    DWORD   dwFailCount;
    DWORD   dwPhysicalMediumType;
} EAPOL_INTF_STATE, *PEAPOL_INTF_STATE;


#define     EAPOL_VERSION_1             1
#define     EAPOL_VERSION_2             2
#define     EAPOL_VERSION_3             3

#define     EAPOL_CURRENT_VERSION       EAPOL_VERSION_3

//
// Structure : EAPOL_AUTH_DATA
//
typedef struct _EAPOL_AUTH_DATA
{
    DWORD   dwEapType;
    DWORD   dwSize;
    BYTE    bData[1];
} EAPOL_AUTH_DATA, *PEAPOL_AUTH_DATA;

DWORD
WZCGetEapUserInfo (
        IN  WCHAR           *pwszGUID,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT PBYTE       pbUserInfo,
        IN  OUT DWORD       *pdwInfoSize
        );

// Structure used to define the UI Response.
// Currently it contains upto 3 blobs.
// If more are required, add to the structure

#define NUM_RESP_BLOBS 3

typedef struct _EAPOLUI_RESP
{
    RAW_DATA    rdData0;
    RAW_DATA    rdData1;
    RAW_DATA    rdData2;
} EAPOLUI_RESP, *PEAPOLUI_RESP;


//
// EAPOL Policy related parameters
//

#define     EAPOL_CERT_TYPE_SMARTCARD   1
#define     EAPOL_CERT_TYPE_MC_CERT     2

typedef struct _EAPOL_POLICY_DATA {
    BYTE  pbWirelessSSID[32];
    DWORD dwWirelessSSIDLen;
    DWORD dwEnable8021x;
    DWORD dw8021xMode;
    DWORD dwEAPType;
    DWORD dwMachineAuthentication;
    DWORD dwMachineAuthenticationType;
    DWORD dwGuestAuthentication;
    DWORD dwIEEE8021xMaxStart;
    DWORD dwIEEE8021xStartPeriod;
    DWORD dwIEEE8021xAuthPeriod;
    DWORD dwIEEE8021xHeldPeriod;
    DWORD dwEAPDataLen;
    LPBYTE pbEAPData;
} EAPOL_POLICY_DATA, *PEAPOL_POLICY_DATA;


typedef struct _EAPOL_POLICY_LIST  {
	DWORD			    dwNumberOfItems;
	EAPOL_POLICY_DATA	EAPOLPolicy[1];
} EAPOL_POLICY_LIST, *PEAPOL_POLICY_LIST;


#if !defined(MIDL_PASS)

//---------------------------------------
// WZCEapolGetCustomAuthData: Get EAP-specific configuration data for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   dwEapTypeId:
//     [in]  EAP type Id
//   dwSizeOfSSID:
//     [in]  Size of SSID for which data is to be stored
//   pbSSID:
//     [in]  SSID for which data is to be stored
//   pbConnInfo:
//     [in out]  Connection EAP info
//   pdwInfoSize:
//     [in out]  Size of pbConnInfo
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolGetCustomAuthData (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  DWORD         dwEapTypeId,
    IN  DWORD         dwSizeOfSSID,
    IN  BYTE          *pbSSID,
    IN OUT PBYTE      pbConnInfo,
    IN OUT PDWORD     pdwInfoSize
    );

//---------------------------------------
// WZCEapolSetCustomAuthData: Set EAP-specific configuration data for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   dwEapTypeId:
//     [in]  EAP type Id
//   dwSizeOfSSID:
//     [in]  Size of SSID for which data is to be stored
//   pbSSID:
//     [in]  SSID for which data is to be stored
//   pbConnInfo:
//     [in]  Connection EAP info
//   pdwInfoSize:
//     [in]  Size of pbConnInfo
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolSetCustomAuthData (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  DWORD         dwEapTypeId,
    IN  DWORD         dwSizeOfSSID,
    IN  BYTE          *pbSSID,
    IN  PBYTE         pbConnInfo,
    IN  DWORD         dwInfoSize
    );

//---------------------------------------
// WZCEapolGetInterfaceParams: Get configuration parameters for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfParams:
//     [in out]  Interface Parameters
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolGetInterfaceParams (
    IN  LPWSTR          pSrvAddr,
    IN  PWCHAR          pwszGuid,
    IN OUT EAPOL_INTF_PARAMS   *pIntfParams
    );

//---------------------------------------
// WZCEapolSetInterfaceParams: Set configuration parameters for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfParams:
//     [in]  Interface parameters
// Returned value:
//     Win32 error code 
DWORD
WZCEapolSetInterfaceParams (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  EAPOL_INTF_PARAMS   *pIntfParams
    );

//---------------------------------------
// WZCEapolReAuthenticate : Restart 802.1X authentication on an interface 
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
// Returned value:
//     Win32 error code 
DWORD
WZCEapolReAuthenticate (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid
    );

//---------------------------------------
// WZCEapolQueryState: Query the interface 802.1X/EAPOL state
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfState:
//     [in out]  EAPOL Interface State
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolQueryState (
    IN  LPWSTR              pSrvAddr,
    IN  PWCHAR              pwszGuid,
    IN OUT EAPOL_INTF_STATE *pIntfState
    );

#endif // MIDL_PASS

//
// Free EAPOL interface state information on the client side obtained via
// RPC query
//

DWORD
WZCEapolFreeState (
    IN  EAPOL_INTF_STATE    *pIntfState
    );


//
// Structure: EAPOL_EAP_UI_CONTEXT
//

typedef struct _EAPOL_EAP_UI_CONTEXT
{
    DWORD       dwEAPOLUIMsgType;
    WCHAR       wszGUID[39];
    DWORD       dwSessionId;
    DWORD       dwContextId;
    DWORD       dwEapId;
    DWORD       dwEapTypeId;
    DWORD       dwEapFlags;
    WCHAR       wszSSID[MAX_SSID_LEN+1];
    DWORD       dwSizeOfSSID;
    BYTE        bSSID[MAX_SSID_LEN];
    DWORD       dwEAPOLState;
    DWORD       dwRetCode;
    DWORD       dwSizeOfEapUIData;
    BYTE        bEapUIData[1];
} EAPOL_EAP_UI_CONTEXT, *PEAPOL_EAP_UI_CONTEXT;

//
// Defines for messaging between Service and Dialog DLL
//

#define     EAPOLUI_GET_USERIDENTITY            0x00000001
#define     EAPOLUI_GET_USERNAMEPASSWORD        0x00000002
#define     EAPOLUI_INVOKEINTERACTIVEUI         0x00000004
#define     EAPOLUI_EAP_NOTIFICATION            0x00000008
#define     EAPOLUI_REAUTHENTICATE              0x00000010
#define     EAPOLUI_CREATEBALLOON               0x00000020
#define     EAPOLUI_CLEANUP                     0x00000040
#define     EAPOLUI_DUMMY                       0x00000080

#define     NUM_EAPOL_DLG_MSGS      8


//---------------------------------------
// WZCEapolUIResponse: Send Dlg response to Service
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   EapolUIContext:
//     [in]  EAPOLUI Context data
//   EapolUI:
//     [in]  EAPOLUI response data
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolUIResponse (
    IN  LPWSTR                  pSrvAddr,
    IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
    IN  EAPOLUI_RESP            EapolUIResp
    );


# ifdef     __cplusplus
}
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\inc\wzcmon.h ===
#include <wzcsapi.h>

#pragma once
# ifdef     __cplusplus
extern "C" {
# endif


#define MAX_RECORD_ENUM_COUNT        100

#define MAX_RAW_DATA_SIZE       4096


//
// Component IDs
//

#define DBLOG_COMPID_WZCSVC 0x00000001
#define DBLOG_COMPID_EAPOL  0x00000002

//
// Categories
//

#define DBLOG_CATEG_INFO   0x00000000
#define DBLOG_CATEG_WARN   0x00000001
#define DBLOG_CATEG_ERR    0x00000002
#define DBLOG_CATEG_PACKET 0x00000003


typedef struct _Wzc_Db_Record {
    DWORD recordid;
    DWORD componentid;
    DWORD category;
    FILETIME timestamp;
    RAW_DATA message;
    RAW_DATA localmac;
    RAW_DATA remotemac;
    RAW_DATA ssid;
    RAW_DATA context;
} WZC_DB_RECORD, * PWZC_DB_RECORD;


DWORD
WINAPI
OpenWZCDbLogSession(
    LPWSTR pServerName,
    DWORD dwVersion,
    PHANDLE phSession
    );


DWORD
WINAPI
CloseWZCDbLogSession(
    HANDLE hSession
    );


DWORD
WINAPI
AddWZCDbLogRecord(
    LPWSTR pServerName,
    DWORD dwVersion,
    PWZC_DB_RECORD pWZCRecord,
    LPVOID pvReserved
    );


DWORD
WINAPI
EnumWZCDbLogRecords(
    HANDLE hSession,
    PWZC_DB_RECORD pTemplateRecord,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords,
    LPVOID pvReserved
    );


DWORD
WINAPI
FlushWZCDbLog(
    HANDLE hSession
    );


DWORD WINAPI
GetSpecificLogRecord(HANDLE hSession,
                     PWZC_DB_RECORD pwzcTemplate,
                     PWZC_DB_RECORD *ppWZCRecords,
                     LPDWORD        pdwNumRecords,
                     LPVOID  pvReserved);

# ifdef     __cplusplus
}
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\inc\safestr.h ===
/*

Copyright (c) 2002, Microsoft Corporation.  All rights reserved.


Module Name:

    safestr.h

Abstract:

    Safe, secure string handling routines.

Authors and History:
    23 Jan 2002 : RaymondS added:
                  SecStrCpyW, SecStrCatW
    
Environment:

    User Level: Win32

--*/


wchar_t * SecStrCpyW(
    wchar_t * strDest,          // Destination
    const wchar_t * strSource,  // Source
    SIZE_T destSize             // Total size of Destination in characters.
    );

wchar_t * SecStrCatW(
    wchar_t * strDest,          // Destination
    const wchar_t * strSource,  // Source
    SIZE_T destSize             // Total size of Destination in characters.
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\inc\policycf.h ===
#ifndef _POLICYCF_H
#define _POLICYCF_H

#define CFSTR_IPSECPOLICYOBJECT   L"IPSEC_POLICYOBJECT"
#define POByteOffset(base, offset) (((LPBYTE)base)+offset)

typedef struct
{
	DWORD m_dwInterfaceFlags;
	long  m_lMMCUpdateHandle;

	DWORD m_dwOffsetObjClass;
	DWORD m_dwOffsetObjPath;
	DWORD m_dwOffsetRemoteMachineName;
} POLICYOBJECTSTRUCT;

class POLICYOBJECT
{
public:
	// Policy Object flags
	#define POFLAG_INVALID  0x00000000
	#define POFLAG_NEW		0x00000002
	#define POFLAG_EDIT		0x00000004
	#define POFLAG_APPLY	0x00000008
	#define POFLAG_CANCEL	0x00000010
	#define POFLAG_LOCAL	0x00000020
	#define POFLAG_GLOBAL   0x00000040
	#define POFLAG_REMOTE	0x00000080


	POLICYOBJECT ()	
	{
		dwInterfaceFlags (POFLAG_INVALID);
		lMMCUpdateHandle (0);
	};
	~POLICYOBJECT () {};

	// memory allocation helpers
	int DataGlobalAllocLen ()
	{
		return (sizeof (POLICYOBJECTSTRUCT) + 
			m_sObjClass.GetLength()*sizeof(wchar_t)+sizeof(wchar_t) + 
			m_sObjPath.GetLength()*sizeof(wchar_t)+sizeof(wchar_t) +
			m_sRemoteMachineName.GetLength()*sizeof(wchar_t)+sizeof(wchar_t));
	}

	HRESULT FromObjMedium (STGMEDIUM* pObjMedium)
	{
		HRESULT hr = E_UNEXPECTED;
	    POLICYOBJECTSTRUCT* pPolicyStruct = (POLICYOBJECTSTRUCT*) pObjMedium->hGlobal;	
		if (pPolicyStruct)
		{
			m_dwInterfaceFlags = pPolicyStruct->m_dwInterfaceFlags;
			m_lMMCUpdateHandle = pPolicyStruct->m_lMMCUpdateHandle;

			m_sObjPath		 = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetObjPath);
			m_sObjClass		 = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetObjClass);
			m_sRemoteMachineName = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetRemoteMachineName);

			hr = S_OK;
		}
		return hr;
	}

	HRESULT ToPolicyStruct (POLICYOBJECTSTRUCT* pPolicyStruct)
	{
		HRESULT hr = E_UNEXPECTED;
		if (pPolicyStruct)
		{
			pPolicyStruct->m_dwInterfaceFlags = m_dwInterfaceFlags;
			pPolicyStruct->m_lMMCUpdateHandle = m_lMMCUpdateHandle;

			// store ObjPath
			int istrlenObjPath =  m_sObjPath.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			int iStructLen = sizeof (POLICYOBJECTSTRUCT);
			LONG_PTR addr = ((LONG_PTR)(pPolicyStruct)) + iStructLen;
			memcpy((void*)addr,m_sObjPath,istrlenObjPath);
			pPolicyStruct->m_dwOffsetObjPath=iStructLen;

			// store ObjClass
			// using the current istrlen (length of ObjPath) determine new address and offset for the class
			addr = addr + istrlenObjPath;
			pPolicyStruct->m_dwOffsetObjClass=iStructLen+istrlenObjPath;
			// get new strlen and copy the class in
			int istrlenObjClass = m_sObjClass.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			memcpy((void*)addr,m_sObjClass,istrlenObjClass);

			// store RemoteMachineName
			// using istrlenObjClass (length of ObjClass) determine new address and offset for the class
			addr = addr + istrlenObjClass;
			pPolicyStruct->m_dwOffsetRemoteMachineName=iStructLen+istrlenObjPath+istrlenObjClass;
			// get new strlen and copy the class in
			int istrlenRemoteMachineName = m_sRemoteMachineName.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			memcpy((void*)addr,m_sRemoteMachineName,istrlenRemoteMachineName);

			hr = S_OK;
		}
		return hr;
	}

	// member access methods
	DWORD dwInterfaceFlags() {return m_dwInterfaceFlags;}
	void dwInterfaceFlags (DWORD dw) {m_dwInterfaceFlags = dw;}

	long lMMCUpdateHandle() {return m_lMMCUpdateHandle;}
	void lMMCUpdateHandle (long l) {m_lMMCUpdateHandle = l;}

	CString ObjClass() {return m_sObjClass;}
	void ObjClass (CString s) {m_sObjClass = s;}

	CString ObjPath() {return m_sObjPath;}
	void ObjPath (CString s) {m_sObjPath = s;}

	CString RemoteMachineName() {return m_sRemoteMachineName;}
	void RemoteMachineName (CString s) {m_sRemoteMachineName = s;}

private:
	DWORD m_dwInterfaceFlags;
	long  m_lMMCUpdateHandle;

	CString m_sObjClass;
	CString m_sObjPath;
	CString m_sRemoteMachineName;
};

#endif // _POLICYCF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\inc\oakdll.h ===
#ifndef OAKDLL_H
#define OAKDLL_H

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"
#include "ipsec.h"
#include "oakdefs.h"
#include "winipsec.h"

typedef enum _POLICY_GUID_TYPE {
    POLICY_GUID_MM = 1,
    POLICY_GUID_QM,
    POLICY_GUID_AUTH,
    POLICY_GUID_MM_FILTER,
	POLICY_GUID_POWEREVENT_RESUME
} POLICY_GUID_TYPE, *PPOLICY_GUID_TYPE;

DWORD WINAPI IKEInit () ;
DWORD WINAPI IKEShutdown (DWORD dwFlags) ;

DWORD WINAPI IKEInitiateIKENegotiation( 
    PIPSEC_QM_FILTER Filter,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    DWORD dwFlags,
    IPSEC_UDP_ENCAP_CONTEXT UdpEncapContext,
    PHANDLE phNegotiationHandle);

DWORD WINAPI IKEQueryIKENegotiationStatus( 
    HANDLE hNegotiationHandle,
    SA_NEGOTIATION_STATUS_INFO *NegotiationStatus,
    DWORD dwFlags);

DWORD WINAPI IKECloseIKENegotiationHandle( 
                HANDLE hNegotiationHandle);

DWORD WINAPI IKEQueryStatistics( 
    PIKE_STATISTICS IKEStatistics);


DWORD WINAPI IKEDeleteAssociation( 
    IPSEC_MM_SA *MMTemplate,
    DWORD dwFlags);


DWORD WINAPI IKEQuerySpiChange( 
    HANDLE hNotifyHandle,
    LPDWORD dwListCount,
    IPSEC_QM_SA **FilterSpiList);

DWORD WINAPI IKERegisterNotifyClient( 
     DWORD dwClientProcessId,
     HANDLE hClientEvent,
     IPSEC_QM_SA QMInfo,  
     PHANDLE phNotifyHandle);

DWORD WINAPI IKECloseIKENotifyHandle(HANDLE hNotifyHandle);

DWORD WINAPI IKEInterfaceChange(); 

DWORD WINAPI IKEEnumMMs(IPSEC_MM_SA *MMTemplate,
                           IPSEC_MM_SA **MMArray,
                           LPDWORD pdwNumEntries,
                           LPDWORD pdwTotalMMsAvailable,
                           LPDWORD pdwEnumHandle,
                           DWORD dwFlags);

DWORD WINAPI
IKENotifyPolicyChange(GUID *pPolicyGuid, POLICY_GUID_TYPE GuidType);

DWORD WINAPI
IKEAddSAs(
    IPSEC_SA_DIRECTION SADirection,
    PIPSEC_QM_OFFER pQMOffer,
    PIPSEC_QM_FILTER pQMFilter,
    HANDLE *hLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *InboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *OutboundKeyMat,
    BYTE *ContextInfo,
    UDP_ENCAP_INFO EncapInfo,
    DWORD dwFlags
);

DWORD WINAPI
IKEGetConfigurationVariables(PIKE_CONFIG pIKEConfig);

DWORD WINAPI
IKESetConfigurationVariables(IKE_CONFIG IKEConfig);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\ikeutils.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    IKE utils

Abstract:

    Contains parameter validation 

Author:

    BrianSw  10-19-200

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
ValidateInitiateIKENegotiation(
    STRING_HANDLE pServerName,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    DWORD dwFlags,
    IPSEC_UDP_ENCAP_CONTEXT UdpEncapContext,
    IKENEGOTIATION_HANDLE * phIKENegotiation
    )
{

    DWORD dwError=ERROR_SUCCESS;

    if (pQMFilterContainer == NULL ||
        pQMFilterContainer->pQMFilters == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }

    if (pServerName && (wcscmp(pServerName,L"") != 0)) {
        if (uhClientEvent || phIKENegotiation || dwClientProcessId) {
            dwError=ERROR_NOT_SUPPORTED;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    } else {
        if (phIKENegotiation || dwClientProcessId || uhClientEvent) {
            if (!phIKENegotiation || !dwClientProcessId || !uhClientEvent) {
                dwError=ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
        }
    }

    if (!(pQMFilterContainer->pQMFilters) ||
        !(pQMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    
    dwError = ValidateIPSecQMFilter(
        pQMFilterContainer->pQMFilters
        );
    BAIL_ON_WIN32_ERROR(dwError);    

error:

    return dwError;
}


DWORD
ValidateQueryIKENegotiationStatus(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    SA_NEGOTIATION_STATUS_INFO *NegotiationStatus
    )

{

    DWORD dwError=ERROR_SUCCESS;
    
    if (!hIKENegotiation || !NegotiationStatus) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
error:
    return dwError;
}


DWORD
ValidateCloseIKENegotiationHandle(
    IKENEGOTIATION_HANDLE * phIKENegotiation
    )
{
    DWORD dwError=ERROR_SUCCESS;
    
    if (!phIKENegotiation) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}


DWORD
ValidateEnumMMSAs(
    STRING_HANDLE pServerName, 
    PMM_SA_CONTAINER pMMTemplate,
    PMM_SA_CONTAINER *ppMMSAContainer,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    DWORD dwFlags
    )
{
    DWORD dwError=ERROR_SUCCESS;

    if (pMMTemplate == NULL ||
        pMMTemplate->pMMSAs == NULL ||
        pMMTemplate->dwNumMMSAs == 0 ||
        ppMMSAContainer == NULL ||
        *ppMMSAContainer == NULL ||
        pdwNumEntries == NULL ||
        pdwTotalMMsAvailable == NULL ||
        pdwEnumHandle == NULL ) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pMMTemplate->pMMSAs->Me));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pMMTemplate->pMMSAs->Peer));
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return dwError;
}


DWORD
ValidateDeleteMMSAs(
    STRING_HANDLE pServerName, 
    PMM_SA_CONTAINER pMMTemplate,
    DWORD dwFlags
    )

{
    DWORD dwError=ERROR_SUCCESS;

    if (pMMTemplate == NULL ||
        pMMTemplate->dwNumMMSAs == 0 ||
        pMMTemplate->pMMSAs == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pMMTemplate->pMMSAs->Me));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pMMTemplate->pMMSAs->Peer));
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return dwError;
}


DWORD
ValidateQueryIKEStatistics(
    STRING_HANDLE pServerName, 
    IKE_STATISTICS *pIKEStatistics
    )

{

    DWORD dwError=ERROR_SUCCESS;

    if (pIKEStatistics == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}


DWORD
ValidateRegisterIKENotifyClient(
    STRING_HANDLE pServerName,    
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    PQM_SA_CONTAINER pQMSATemplateContainer,
    IKENOTIFY_HANDLE *phNotifyHandle,
    DWORD dwFlags
    )
{
    DWORD dwError=ERROR_SUCCESS;

    if (pServerName && (wcscmp(pServerName,L"") != 0)) {
        return ERROR_NOT_SUPPORTED;
    }

    if (pQMSATemplateContainer == NULL ||
        pQMSATemplateContainer->pQMSAs == NULL ||
        pQMSATemplateContainer->dwNumQMSAs == 0 || 
        phNotifyHandle == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    } 
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateQMFilterAddresses(
                  &pQMSATemplateContainer->pQMSAs->IpsecQMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return dwError;
}

DWORD ValidateQueryNotifyData(
    IKENOTIFY_HANDLE uhNotifyHandle,
    PDWORD pdwNumEntries,
    PQM_SA_CONTAINER *ppQMSAContainer,
    DWORD dwFlags
    )

{

    DWORD dwError=ERROR_SUCCESS;

    if (ppQMSAContainer == NULL ||
        *ppQMSAContainer == NULL ||
        pdwNumEntries == NULL ||
        *pdwNumEntries == 0) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);        

error:
    return dwError;

}

DWORD ValidateCloseNotifyHandle(
    IKENOTIFY_HANDLE *phHandle
    )
{
    DWORD dwError=ERROR_SUCCESS;

    if (phHandle == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}

DWORD ValidateIPSecAddSA(
    STRING_HANDLE pServerName,
    IPSEC_SA_DIRECTION SADirection,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD *uhLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *pOutboundKeyMat,
    BYTE *pContextInfo,
    UDP_ENCAP_INFO EncapInfo,
    DWORD dwFlags)

{
    DWORD dwError=ERROR_SUCCESS;
    DWORD dwNumOffers=1;

    if (!pQMFilterContainer ||
        !pQMPolicyContainer ||
        pContextInfo == NULL) {
        dwError= ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    if (uhLarvalContext == NULL){
        dwError= ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (SADirection >= SA_DIRECTION_MAX ||
        SADirection < SA_DIRECTION_BOTH) {
        dwError= ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMFilterContainer->pQMFilters) ||
        !(pQMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicyContainer->pPolicies) ||
        !(pQMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateIPSecQMFilter(
        pQMFilterContainer->pQMFilters
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ValidateQMOffers(
        dwNumOffers,
        pQMPolicyContainer->pPolicies->pOffers);
    BAIL_ON_WIN32_ERROR(dwError);

    if (EncapInfo.SAEncapType < SA_UDP_ENCAP_TYPE_NONE ||
        EncapInfo.SAEncapType >= SA_UDP_ENCAP_TYPE_MAX) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    if (EncapInfo.SAEncapType == SA_UDP_ENCAP_TYPE_OTHER) {
        dwError=ERROR_NOT_SUPPORTED;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    if (EncapInfo.SAEncapType != SA_UDP_ENCAP_TYPE_NONE) {
        if (EncapInfo.PeerAddrVersion != IPSEC_PROTOCOL_V4) {
            dwError=ERROR_INVALID_PARAMETER;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (EncapInfo.PeerPrivateAddr.AddrType != IP_ADDR_UNIQUE) {
            dwError=ERROR_INVALID_PARAMETER;
        }
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError=VerifyAddresses(&EncapInfo.PeerPrivateAddr,
                                FALSE,
                                TRUE);
        }
        BAIL_ON_WIN32_ERROR(dwError);
error:
    return dwError;
}

DWORD ValidateSetConfigurationVariables(
    LPWSTR pServerName,
    IKE_CONFIG IKEConfig
    )
{
    DWORD dwError = ERROR_SUCCESS;

    if (IKEConfig.dwStrongCRLCheck > 2) {
        dwError= ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (IKEConfig.dwNLBSFlags >= FLAGS_NLBS_MAX) {
        dwError= ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    if (IKEConfig.dwFlags != 0) {
        dwError= ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}

DWORD ValidateGetConfigurationVariables(
    LPWSTR pServerName,
    PIKE_CONFIG pIKEConfig
    )
{
    DWORD dwError = ERROR_SUCCESS;

    if (pIKEConfig == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}


DWORD WINAPI ConvertExtMMAuthToInt(PMM_AUTH_METHODS pMMAuthMethods,
                                   PINT_MM_AUTH_METHODS *pIntMMAuthMethods)
{

    PINT_MM_AUTH_METHODS pIntAuth=NULL;
    DWORD dwError;
    DWORD dwNumIntAuths=0;
    DWORD i,j;
    PIPSEC_MM_AUTH_INFO pAuthInfo;
    PINT_IPSEC_MM_AUTH_INFO pIntAuthInfo;
    DWORD dwCurIndex=0;
    PCERT_ROOT_CONFIG pInboundCertArray;

    dwError=AllocateSPDMemory(sizeof(INT_MM_AUTH_METHODS),&pIntAuth);
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(&pIntAuth->gMMAuthID,&pMMAuthMethods->gMMAuthID,sizeof(GUID));
    pIntAuth->dwFlags=pMMAuthMethods->dwFlags;
    
    for (i=0; i < pMMAuthMethods->dwNumAuthInfos; i++) {
        pAuthInfo=&pMMAuthMethods->pAuthenticationInfo[i];
        switch(pAuthInfo->AuthMethod) {
        case IKE_PRESHARED_KEY:
        case IKE_SSPI:
            dwNumIntAuths++;
            break;
        case IKE_RSA_SIGNATURE:
            dwNumIntAuths += pAuthInfo->CertAuthInfo.dwInboundRootArraySize;
            break;
        }
    }
    pIntAuth->dwNumAuthInfos=dwNumIntAuths;
    
    dwError=AllocateSPDMemory(sizeof(INT_IPSEC_MM_AUTH_INFO) * dwNumIntAuths,
                                 &pIntAuth->pAuthenticationInfo);
    BAIL_ON_WIN32_ERROR(dwError);

    for (i=0; i < pMMAuthMethods->dwNumAuthInfos; i++) {
        pAuthInfo=&pMMAuthMethods->pAuthenticationInfo[i];
        pIntAuthInfo=&pIntAuth->pAuthenticationInfo[dwCurIndex];
        pIntAuthInfo->AuthMethod=pAuthInfo->AuthMethod;
        switch(pAuthInfo->AuthMethod) {
        case IKE_PRESHARED_KEY:
            dwError=AllocateSPDMemory(pAuthInfo->GeneralAuthInfo.dwAuthInfoSize,
                                      &pIntAuthInfo->pAuthInfo);
            BAIL_ON_WIN32_ERROR(dwError);
            memcpy(pIntAuthInfo->pAuthInfo,
                   pAuthInfo->GeneralAuthInfo.pAuthInfo,
                   pAuthInfo->GeneralAuthInfo.dwAuthInfoSize);
            pIntAuthInfo->dwAuthInfoSize=pAuthInfo->GeneralAuthInfo.dwAuthInfoSize;
            dwCurIndex++;
            break;
        case IKE_SSPI:
            dwCurIndex++;
            break;
        case IKE_RSA_SIGNATURE:
            pInboundCertArray=pAuthInfo->CertAuthInfo.pInboundRootArray;
            for (j=0;j< pAuthInfo->CertAuthInfo.dwInboundRootArraySize;j++) {
                pIntAuthInfo=&pIntAuth->pAuthenticationInfo[dwCurIndex];
                dwError=AllocateSPDMemory(pInboundCertArray[j].dwCertDataSize,
                                             &pIntAuthInfo->pAuthInfo);
                BAIL_ON_WIN32_ERROR(dwError);
                memcpy(pIntAuthInfo->pAuthInfo,pInboundCertArray[j].pCertData,
                       pInboundCertArray[j].dwCertDataSize);
                pIntAuthInfo->dwAuthInfoSize=pInboundCertArray[j].dwCertDataSize;        
                pIntAuthInfo->AuthMethod=IKE_RSA_SIGNATURE;
                pIntAuthInfo->dwAuthFlags=pInboundCertArray[j].dwFlags;
                dwCurIndex++;
            }
            break;
        }
    }
    
    *pIntMMAuthMethods=pIntAuth;
    return ERROR_SUCCESS;
    
error:
    
    FreeIntMMAuthMethods(pIntAuth);
    return (dwError);
}

#define INVALID_INDEX 0xffff


DWORD WINAPI ConvertIntMMAuthToExt(PINT_MM_AUTH_METHODS pIntMMAuthMethods,
                                   PMM_AUTH_METHODS *pMMAuthMethods)

{

    PMM_AUTH_METHODS pExtAuth=NULL;
    DWORD dwError;
    DWORD dwNumExtAuths=0;
    DWORD i;
    PINT_IPSEC_MM_AUTH_INFO pAuthInfo;
    PIPSEC_MM_AUTH_INFO pExtAuthInfo;
    PMM_CERT_INFO pCertInfo;
    DWORD dwCurCertIndex=0;
    PCERT_ROOT_CONFIG pInboundCertArray;

    DWORD dwNumCerts=0;
    DWORD dwCertIndex=INVALID_INDEX;
    DWORD dwPSKeyIndex=INVALID_INDEX;
    DWORD dwKerbIndex=INVALID_INDEX;

    dwError=AllocateSPDMemory(sizeof(MM_AUTH_METHODS),&pExtAuth);
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(&pExtAuth->gMMAuthID,&pIntMMAuthMethods->gMMAuthID,sizeof(GUID));
    pExtAuth->dwFlags=pIntMMAuthMethods->dwFlags;
    
    for (i=0; i < pIntMMAuthMethods->dwNumAuthInfos; i++) {
        pAuthInfo=&pIntMMAuthMethods->pAuthenticationInfo[i];
        switch(pAuthInfo->AuthMethod) {
        case IKE_PRESHARED_KEY:
            dwPSKeyIndex=dwNumExtAuths;
            dwNumExtAuths++;
            break;
        case IKE_SSPI:
            dwKerbIndex=dwNumExtAuths;
            dwNumExtAuths++;
            break;
        case IKE_RSA_SIGNATURE:
            if (dwCertIndex == INVALID_INDEX) {
                dwCertIndex=dwNumExtAuths;
                dwNumExtAuths++;
            }
            dwNumCerts++;
            break;
        }
    }
    pExtAuth->dwNumAuthInfos=dwNumExtAuths;

    dwError=AllocateSPDMemory(sizeof(IPSEC_MM_AUTH_INFO) * dwNumExtAuths,
                              &pExtAuth->pAuthenticationInfo);
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwCertIndex != INVALID_INDEX) {
        pCertInfo=&pExtAuth->pAuthenticationInfo[dwCertIndex].CertAuthInfo;
        dwError=AllocateSPDMemory(sizeof(CERT_ROOT_CONFIG) * dwNumCerts,
                                &pCertInfo->pInboundRootArray);
        BAIL_ON_WIN32_ERROR(dwError);
        dwError=AllocateSPDMemory(sizeof(CERT_ROOT_CONFIG) * dwNumCerts,
                                &pCertInfo->pOutboundRootArray);
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i=0; i < pIntMMAuthMethods->dwNumAuthInfos; i++) {
        pAuthInfo=&pIntMMAuthMethods->pAuthenticationInfo[i];
        switch(pAuthInfo->AuthMethod) {
        case IKE_PRESHARED_KEY:
            pExtAuthInfo=&pExtAuth->pAuthenticationInfo[dwPSKeyIndex];
            dwError=AllocateSPDMemory(pAuthInfo->dwAuthInfoSize,
                                      &pExtAuthInfo->GeneralAuthInfo.pAuthInfo);
            BAIL_ON_WIN32_ERROR(dwError);
            memcpy(pExtAuthInfo->GeneralAuthInfo.pAuthInfo,
                   pAuthInfo->pAuthInfo,
                   pAuthInfo->dwAuthInfoSize);
            pExtAuthInfo->GeneralAuthInfo.dwAuthInfoSize=pAuthInfo->dwAuthInfoSize;
            pExtAuthInfo->AuthMethod=IKE_PRESHARED_KEY;
            break;
        case IKE_SSPI:
            pExtAuthInfo=&pExtAuth->pAuthenticationInfo[dwKerbIndex];
            pExtAuthInfo->AuthMethod=IKE_SSPI;
            break;
        case IKE_RSA_SIGNATURE:
            pExtAuthInfo=&pExtAuth->pAuthenticationInfo[dwCertIndex];
            pExtAuthInfo->AuthMethod=IKE_RSA_SIGNATURE;
            pCertInfo=&pExtAuthInfo->CertAuthInfo;
            dwError=AllocateSPDMemory(pAuthInfo->dwAuthInfoSize,
                                      &pCertInfo->pInboundRootArray[dwCurCertIndex].pCertData);
            BAIL_ON_WIN32_ERROR(dwError);
            memcpy(pCertInfo->pInboundRootArray[dwCurCertIndex].pCertData,
                   pAuthInfo->pAuthInfo,
                   pAuthInfo->dwAuthInfoSize);
            pCertInfo->pInboundRootArray[dwCurCertIndex].dwCertDataSize=pAuthInfo->dwAuthInfoSize;
            pCertInfo->pInboundRootArray[dwCurCertIndex].dwFlags = pAuthInfo->dwAuthFlags;

            // Copy same info into *pOutboundRootArray as well.
            dwError=AllocateSPDMemory(pAuthInfo->dwAuthInfoSize,
                                      &pCertInfo->pOutboundRootArray[dwCurCertIndex].pCertData);
            BAIL_ON_WIN32_ERROR(dwError);
            memcpy(pCertInfo->pOutboundRootArray[dwCurCertIndex].pCertData,
                   pAuthInfo->pAuthInfo,
                   pAuthInfo->dwAuthInfoSize);
            pCertInfo->pOutboundRootArray[dwCurCertIndex].dwCertDataSize=pAuthInfo->dwAuthInfoSize;
            pCertInfo->pOutboundRootArray[dwCurCertIndex].dwFlags = pAuthInfo->dwAuthFlags;
            
            dwCurCertIndex++;
            break;
        }
    }

    if (dwCertIndex != INVALID_INDEX) {
        pExtAuth->pAuthenticationInfo[dwCertIndex].CertAuthInfo.dwInboundRootArraySize = dwCurCertIndex;
        pExtAuth->pAuthenticationInfo[dwCertIndex].CertAuthInfo.dwOutboundRootArraySize = dwCurCertIndex;
    }
    
    *pMMAuthMethods=pExtAuth;
    return ERROR_SUCCESS;
    
error:
    
    FreeExtMMAuthMethods(pExtAuth);
    return (dwError);
}

DWORD WINAPI SPDConvertIntMMAuthToExt(PINT_MM_AUTH_METHODS pIntMMAuthMethods,
                                      PMM_AUTH_METHODS *pMMAuthMethods)

{

    PMM_AUTH_METHODS pExtAuth=NULL;
    DWORD dwError;
    DWORD dwNumExtAuths=0;
    DWORD i;
    PINT_IPSEC_MM_AUTH_INFO pAuthInfo;
    PIPSEC_MM_AUTH_INFO pExtAuthInfo;
    PMM_CERT_INFO pCertInfo;
    DWORD dwCurCertIndex=0;
    PCERT_ROOT_CONFIG pInboundCertArray;

    DWORD dwNumCerts=0;
    DWORD dwCertIndex=INVALID_INDEX;
    DWORD dwPSKeyIndex=INVALID_INDEX;
    DWORD dwKerbIndex=INVALID_INDEX;

    dwError=SPDApiBufferAllocate(sizeof(MM_AUTH_METHODS),&pExtAuth);
    BAIL_ON_WIN32_ERROR(dwError);
    
    memcpy(&pExtAuth->gMMAuthID,&pIntMMAuthMethods->gMMAuthID,sizeof(GUID));
    pExtAuth->dwFlags=pIntMMAuthMethods->dwFlags;
    
    for (i=0; i < pIntMMAuthMethods->dwNumAuthInfos; i++) {
        pAuthInfo=&pIntMMAuthMethods->pAuthenticationInfo[i];
        switch(pAuthInfo->AuthMethod) {
        case IKE_PRESHARED_KEY:
            dwPSKeyIndex=dwNumExtAuths;
            dwNumExtAuths++;
            break;
        case IKE_SSPI:
            dwKerbIndex=dwNumExtAuths;
            dwNumExtAuths++;
            break;
        case IKE_RSA_SIGNATURE:
            if (dwCertIndex == INVALID_INDEX) {
                dwCertIndex=dwNumExtAuths;
                dwNumExtAuths++;
            }
            dwNumCerts++;
            break;
        }
    }
    pExtAuth->dwNumAuthInfos=dwNumExtAuths;
    dwError=SPDApiBufferAllocate(sizeof(IPSEC_MM_AUTH_INFO) * dwNumExtAuths,
                                 &pExtAuth->pAuthenticationInfo);
    BAIL_ON_WIN32_ERROR(dwError);
    if (dwCertIndex != INVALID_INDEX) {
        pCertInfo=&pExtAuth->pAuthenticationInfo[dwCertIndex].CertAuthInfo;
        dwError=SPDApiBufferAllocate(sizeof(CERT_ROOT_CONFIG) * dwNumCerts,
                                     &pCertInfo->pInboundRootArray);
        BAIL_ON_WIN32_ERROR(dwError);                                     
        dwError=SPDApiBufferAllocate(sizeof(CERT_ROOT_CONFIG) * dwNumCerts,
                                     &pCertInfo->pOutboundRootArray);
                                     
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i=0; i < pIntMMAuthMethods->dwNumAuthInfos; i++) {
        pAuthInfo=&pIntMMAuthMethods->pAuthenticationInfo[i];
        switch(pAuthInfo->AuthMethod) {
        case IKE_PRESHARED_KEY:
            pExtAuthInfo=&pExtAuth->pAuthenticationInfo[dwPSKeyIndex];
            dwError=SPDApiBufferAllocate(pAuthInfo->dwAuthInfoSize,
                                         &pExtAuthInfo->GeneralAuthInfo.pAuthInfo);
            BAIL_ON_WIN32_ERROR(dwError);
            memcpy(pExtAuthInfo->GeneralAuthInfo.pAuthInfo,
                   pAuthInfo->pAuthInfo,
                   pAuthInfo->dwAuthInfoSize);
            pExtAuthInfo->GeneralAuthInfo.dwAuthInfoSize=pAuthInfo->dwAuthInfoSize;
            pExtAuthInfo->AuthMethod=IKE_PRESHARED_KEY;
            break;
        case IKE_SSPI:
            pExtAuthInfo=&pExtAuth->pAuthenticationInfo[dwKerbIndex];
            pExtAuthInfo->AuthMethod=IKE_SSPI;
            break;
        case IKE_RSA_SIGNATURE:
            pExtAuthInfo=&pExtAuth->pAuthenticationInfo[dwCertIndex];
            pExtAuthInfo->AuthMethod=IKE_RSA_SIGNATURE;
            pCertInfo=&pExtAuthInfo->CertAuthInfo;
            dwError=SPDApiBufferAllocate(pAuthInfo->dwAuthInfoSize,
                                         &pCertInfo->pInboundRootArray[dwCurCertIndex].pCertData);
            BAIL_ON_WIN32_ERROR(dwError);
            memcpy(pCertInfo->pInboundRootArray[dwCurCertIndex].pCertData,
                   pAuthInfo->pAuthInfo,
                   pAuthInfo->dwAuthInfoSize);
            pCertInfo->pInboundRootArray[dwCurCertIndex].dwCertDataSize=pAuthInfo->dwAuthInfoSize;
            pCertInfo->pInboundRootArray[dwCurCertIndex].dwFlags = pAuthInfo->dwAuthFlags;

            // Copy same info into *pOutboundRootArray as well.
            dwError=SPDApiBufferAllocate(pAuthInfo->dwAuthInfoSize,
                                         &pCertInfo->pOutboundRootArray[dwCurCertIndex].pCertData);
            BAIL_ON_WIN32_ERROR(dwError);
            memcpy(pCertInfo->pOutboundRootArray[dwCurCertIndex].pCertData,
                   pAuthInfo->pAuthInfo,
                   pAuthInfo->dwAuthInfoSize);
            pCertInfo->pOutboundRootArray[dwCurCertIndex].dwCertDataSize=pAuthInfo->dwAuthInfoSize;
            pCertInfo->pOutboundRootArray[dwCurCertIndex].dwFlags = pAuthInfo->dwAuthFlags;
            
            dwCurCertIndex++;
            break;
        }
    }

    if (dwCertIndex != INVALID_INDEX) {
        pExtAuth->pAuthenticationInfo[dwCertIndex].CertAuthInfo.dwInboundRootArraySize = dwCurCertIndex;
        pExtAuth->pAuthenticationInfo[dwCertIndex].CertAuthInfo.dwOutboundRootArraySize = dwCurCertIndex;
    }
    
    *pMMAuthMethods=pExtAuth;
    return ERROR_SUCCESS;
    
error:
    
    SPDFreeExtMMAuthMethods(pExtAuth);
    return (dwError);
}

DWORD
WINAPI
SPDConvertArrayIntMMAuthToExt(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods,
    PMM_AUTH_METHODS *ppMMAuthMethods,
    DWORD dwNumAuthMeths)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwConvertIdx = 0;
    PMM_AUTH_METHODS *ppTempAuthMethods = NULL;
    PMM_AUTH_METHODS pExtAuthMethods = NULL;

    dwError = SPDApiBufferAllocate(
                  dwNumAuthMeths * sizeof(MM_AUTH_METHODS),
                  &pExtAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  dwNumAuthMeths * sizeof(PMM_AUTH_METHODS),
                  (LPVOID *) &ppTempAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (dwConvertIdx = 0; dwConvertIdx < dwNumAuthMeths; dwConvertIdx++) {
        dwError = SPDConvertIntMMAuthToExt(&pIntMMAuthMethods[dwConvertIdx],
                                           &ppTempAuthMethods[dwConvertIdx]);
                                           
        BAIL_ON_WIN32_ERROR(dwError);
        memcpy(
            &pExtAuthMethods[dwConvertIdx],
            ppTempAuthMethods[dwConvertIdx],
            sizeof(MM_AUTH_METHODS)
            );
    }

    // Shallow free ppTempAuthMethods[i] (pExtAuthMethods has copies.)
    for (dwConvertIdx = 0; dwConvertIdx < dwNumAuthMeths; dwConvertIdx++) {
        SPDApiBufferFree(ppTempAuthMethods[dwConvertIdx]);
    }
    SPDApiBufferFree(ppTempAuthMethods);

    *ppMMAuthMethods = pExtAuthMethods;
    
    return dwError;
    
error:
    // ASSERT: dwConvertIdx == number of internal auth methods successfully
    //         converted.
    for (; dwConvertIdx ; dwConvertIdx--) {
        SPDFreeExtMMAuthMethods(ppTempAuthMethods[dwConvertIdx-1]);
    }
    SPDApiBufferFree(ppTempAuthMethods);
    
    SPDApiBufferFree(pExtAuthMethods);

    *ppMMAuthMethods = NULL;
    
    return dwError;
}


DWORD WINAPI FreeIntMMAuthMethods(PINT_MM_AUTH_METHODS pIntMMAuthMethods)
{
    DWORD i;
    PINT_IPSEC_MM_AUTH_INFO pIntAuthInfo;

    if (pIntMMAuthMethods) {
        if (pIntMMAuthMethods->pAuthenticationInfo) {
            for (i=0; i < pIntMMAuthMethods->dwNumAuthInfos; i++) {
                pIntAuthInfo=&pIntMMAuthMethods->pAuthenticationInfo[i];
                FreeSPDMemory(pIntAuthInfo->pAuthInfo);
            }
            FreeSPDMemory(pIntMMAuthMethods->pAuthenticationInfo);
        }
        FreeSPDMemory(pIntMMAuthMethods);
    }
    return ERROR_SUCCESS;
}


DWORD
WINAPI
SPDFreeIntMMAuthMethods(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods,
    BOOLEAN FreeTop)
{
    DWORD i;
    PINT_IPSEC_MM_AUTH_INFO pIntAuthInfo;

    if (pIntMMAuthMethods) {
        if (pIntMMAuthMethods->pAuthenticationInfo) {
            for (i=0; i < pIntMMAuthMethods->dwNumAuthInfos; i++) {
                pIntAuthInfo=&pIntMMAuthMethods->pAuthenticationInfo[i];
                SPDApiBufferFree(pIntAuthInfo->pAuthInfo);
            }
            SPDApiBufferFree(pIntMMAuthMethods->pAuthenticationInfo);
        }
        if (FreeTop)
            SPDApiBufferFree(pIntMMAuthMethods);
    }
    return ERROR_SUCCESS;
}

DWORD
WINAPI
SPDFreeIntMMAuthMethodsArray(
    PINT_MM_AUTH_METHODS pIntMMAuthMethods,
    DWORD dwNumAuthMeths) 
{
    DWORD Idx;

    for (Idx = 0; Idx < dwNumAuthMeths; Idx++) {
        SPDFreeIntMMAuthMethods(&pIntMMAuthMethods[Idx], FALSE);
    }
    SPDApiBufferFree(pIntMMAuthMethods);

    return ERROR_SUCCESS;
}
    
        


VOID FreeMMAuthInfo(PIPSEC_MM_AUTH_INFO pAuthInfo)
{
    PMM_CERT_INFO pCertInfo;
    DWORD i;

    if (pAuthInfo->AuthMethod == IKE_PRESHARED_KEY) {
        FreeSPDMemory(pAuthInfo->GeneralAuthInfo.pAuthInfo);
    }
    if (pAuthInfo->AuthMethod == IKE_RSA_SIGNATURE) {
        pCertInfo=&pAuthInfo->CertAuthInfo;
        
        if (pCertInfo->pInboundRootArray) {
            for (i=0; i < pCertInfo->dwInboundRootArraySize; i++) {
                FreeSPDMemory(pCertInfo->pInboundRootArray[i].pCertData);
                // The following is unused, but included for completeness
                FreeSPDMemory(pCertInfo->pInboundRootArray[i].pAuthorizationData);
            }
            FreeSPDMemory(pCertInfo->pInboundRootArray);
        }

        if (pCertInfo->pOutboundRootArray) {
            for (i=0; i < pCertInfo->dwOutboundRootArraySize; i++) {
                FreeSPDMemory(pCertInfo->pOutboundRootArray[i].pCertData);
                // The following is unused, but included for completeness
                FreeSPDMemory(pCertInfo->pOutboundRootArray[i].pAuthorizationData);
            }
            FreeSPDMemory(pCertInfo->pOutboundRootArray);
        }

        // The following is unused.
        FreeSPDMemory(pCertInfo->pMyCertHash);
    }

}

VOID SPDFreeMMAuthInfo(PIPSEC_MM_AUTH_INFO pAuthInfo)
{
    PMM_CERT_INFO pCertInfo;
    DWORD i;

    if (pAuthInfo->AuthMethod == IKE_PRESHARED_KEY) {
        SPDApiBufferFree(pAuthInfo->GeneralAuthInfo.pAuthInfo);
    }
    if (pAuthInfo->AuthMethod == IKE_RSA_SIGNATURE) {
        pCertInfo=&pAuthInfo->CertAuthInfo;
        
        if (pCertInfo->pInboundRootArray) {
            for (i=0; i < pCertInfo->dwInboundRootArraySize; i++) {
                SPDApiBufferFree(pCertInfo->pInboundRootArray[i].pCertData);
                // The following is unused, but included for completeness
                SPDApiBufferFree(pCertInfo->pInboundRootArray[i].pAuthorizationData);
            }
            SPDApiBufferFree(pCertInfo->pInboundRootArray);
        }

        if (pCertInfo->pOutboundRootArray) {
            for (i=0; i < pCertInfo->dwOutboundRootArraySize; i++) {
                SPDApiBufferFree(pCertInfo->pOutboundRootArray[i].pCertData);
                // The following is unused, but included for completeness
                SPDApiBufferFree(pCertInfo->pOutboundRootArray[i].pAuthorizationData);
            }
            SPDApiBufferFree(pCertInfo->pOutboundRootArray);
        }

        // The following is unused.
        SPDApiBufferFree(pCertInfo->pMyCertHash);      
    }

}


DWORD WINAPI FreeExtMMAuthMethods(PMM_AUTH_METHODS pMMAuthMethods)
{
    DWORD i;
    PIPSEC_MM_AUTH_INFO pAuthInfo;

    if (pMMAuthMethods) {
        if (pMMAuthMethods->pAuthenticationInfo) {
            for (i=0; i < pMMAuthMethods->dwNumAuthInfos; i++) {
                pAuthInfo=&pMMAuthMethods->pAuthenticationInfo[i];
                FreeMMAuthInfo(pAuthInfo);
            }
            FreeSPDMemory(pMMAuthMethods->pAuthenticationInfo);
        }
        FreeSPDMemory(pMMAuthMethods);
    }
    return ERROR_SUCCESS;
}

DWORD WINAPI SPDFreeExtMMAuthMethods(PMM_AUTH_METHODS pMMAuthMethods)
{
    DWORD i;
    PIPSEC_MM_AUTH_INFO pAuthInfo;

    if (pMMAuthMethods) {
        if (pMMAuthMethods->pAuthenticationInfo) {
            for (i=0; i < pMMAuthMethods->dwNumAuthInfos; i++) {
                pAuthInfo=&pMMAuthMethods->pAuthenticationInfo[i];
                SPDFreeMMAuthInfo(pAuthInfo);
            }
            SPDApiBufferFree(pMMAuthMethods->pAuthenticationInfo);
        }
        SPDApiBufferFree(pMMAuthMethods);
    }
    return ERROR_SUCCESS;
}

BOOLEAN
IsSpecialServ(
    ADDR_TYPE AddrType
    )
{
    switch (AddrType) {
        case IP_ADDR_DNS_SERVER:
        case IP_ADDR_WINS_SERVER:
        case IP_ADDR_DHCP_SERVER:
        case IP_ADDR_DEFAULT_GATEWAY:
            return TRUE;
        default:
            return FALSE;
     }
}

ADDR_TYPE 
ExTypeToAddrType(
    UCHAR ExType
    )
{
    ExType &= ~EXT_DEST;
    switch (ExType) {
        case EXT_DNS_SERVER:
            return IP_ADDR_DNS_SERVER;
        case EXT_WINS_SERVER:
            return IP_ADDR_WINS_SERVER;
        case EXT_DHCP_SERVER:
            return IP_ADDR_DHCP_SERVER;
        case EXT_DEFAULT_GATEWAY:
            return IP_ADDR_DEFAULT_GATEWAY;
    }
    return IP_ADDR_UNIQUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\nsustring.c ===
// Copyright (c) 1997-2002 Microsoft Corporation
//
// Module:
//
//     Network Security Utilities
//     nsustring.c
//
// Abstract:
//
//     Wrappers for strsafe.h and safe string functions
//
// Author:
//
//     RaymondS     1 February-2002
//
// Environment:
//
//     User mode
//
// Revision History:

#include <precomp.h>
#include "NsuString.h"
#include "strsafe.h"

// Description:
//
//     Copies not more than cchDest characters from pszSrc to pszDest, including the null
//     terminator. If the length of pszSrc is more than cchDest, ERROR_INSUFFICIENT_BUFFER
//     is returned but cchDest characters from pszSrc are still copied to pszDest.
//     Always null terminates pszDest.  
//
// Arguments:
//
//     pszDest - destination string.
//     cchDest - maximum number of characters to copy including null character.
//     pszSrc  - souce string.
//
// Return Value:
//      ERROR_INVALID_PARAMETER - if one of the parameters is invalid.  pszDest unchanged.
//      ERROR_INSUFFICIENT_BUFFER - if length of pszSrc is greater than cchDest.
//      ERROR_SUCCESS
//      Other WIN32 errors possible.
//

DWORD
NsuStringCopyW(
    OUT LPWSTR pszDest,
    IN  size_t cchDest,
    IN  LPCWSTR pszSrc
    )
{
    HRESULT hr = S_OK;

    hr = StringCchCopyW(
             pszDest,
             cchDest,
             pszSrc
             );

    return HRESULT_CODE(hr);
}

// Description:
// 
//     See NsuStringCopyW.    
//

DWORD
NsuStringCopyA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszSrc
    )
{
    HRESULT hr = S_OK;

    hr = StringCchCopyA(
             pszDest,
             cchDest,
             pszSrc
             );

    return HRESULT_CODE(hr);
}


// Description:
//
//      Converts pszSrc from MBCS to an Unicode string and pass the result back in *ppszDest.
//      *ppszDest is allocated enough space to store the output string.
//      Always null terminates *ppszDest.  
//      Use NsuFree to free the allocate string.
//
// Arguments:
//  
//      ppszDest - pointer to output string that is returned.      
//      cchLimit - specifies the maximum size of the output string to allocate including
//                 the NULL character.
//                 Pass 0 if no maximum should be enforced.  if cchLimit is
//                 less than the required output string buffer, only cchLimit characters
//                 are converted, and ERROR_INSUFFICIENT_BUFFER is returned.
//
// Return Value:
//
//      ERROR_INVALID_PARAMETER - if one of the parameters is invalid.
//      ERROR_INSUFFICIENT_BUFFER - cchLimit is less than required output string lenghth.
//      ERROR_SUCCESS
//      Other WIN32 errors
//

DWORD
NsuStringCopyAtoWAlloc(
    OUT LPWSTR* ppszDest,
    IN size_t  cchLimit,    
    IN LPCSTR  pszSrc
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPWSTR lpWideCharStr = NULL;
    int cchWideChar = 0;

    cchWideChar = MultiByteToWideChar(
                    CP_ACP,                 // ANSI Code page
                    0,                      // No special options
                    pszSrc,                 // string to map
                    -1,                     // Assume string is null terminated.
                    NULL,                   // wide-character buffer
                    0                       // size of buffer
                    );
    if (cchWideChar <= 0) {
       dwError = GetLastError();
       NSU_BAIL_ON_ERROR(dwError);
    } else if (cchLimit && (size_t) cchWideChar > cchLimit) {
       cchWideChar = cchLimit;
    }

    lpWideCharStr = NsuAlloc(
                        cchWideChar * sizeof(WCHAR),
                        0
                        );
    NSU_BAIL_ON_NULL(lpWideCharStr, dwError);
    
    cchWideChar = MultiByteToWideChar(
                    CP_ACP,                 // ANSI Code page
                    0,                      // No special options
                    pszSrc,                 // string to map
                    -1,                     // Assume string is null terminated.
                    lpWideCharStr,          // wide-character buffer
                    cchWideChar             // size of buffer
                    );
    if (cchWideChar == 0) {
       dwError = GetLastError();
        //  If ERROR_INSUFFICIENT_BUFFER user set limit 
        //  so just null terminate.
        
        if (dwError == ERROR_INSUFFICIENT_BUFFER && cchWideChar) {
            lpWideCharStr[cchLimit-1] = L'\0';
        } else {
            NSU_BAIL_ON_ERROR(dwError);
        }
    }

    *ppszDest = lpWideCharStr;
    
    return dwError;
NSU_CLEANUP:
    if (lpWideCharStr) {
        // Don't want to overwrite dwError so ignore NsuFree errors 
        //
    
        (VOID) NsuFree0(&lpWideCharStr);
    }
    
    *ppszDest = NULL;
    
    return dwError;    
}


// Description:
//
//      Converts pszSrc from Unicode string to an MBCS and passes the result in *ppszDest.
//      *ppszDest is allocated enough space to store the output string.
//      Always null terminates *ppszDest.  
//      Use NsuFree to free the allocate string.
//
// Arguments:
//  
//      ppszDest - pointer to output string that is returned.      
//      cbLimit -  specifies the maximum size of the output string to allocate including
//                 the NULL character.
//                 Pass 0 if no maximum should be enforced.  if cbLimit is
//                 less than the required output string buffer, only cbLimit bytes
//                 are converted, and ERROR_INSUFFICIENT_BUFFER is returned.
//
// Return Value:
//
//      ERROR_INVALID_PARAMETER - if one of the parameters is invalid.  *ppszDest set to NULL.
//      ERROR_INSUFFICIENT_BUFFER - cbLimit is less than required output string length.
//      ERROR_SUCCESS
//      Other WIN32 errors possible. *ppszDest set to NULL.
//

DWORD
NsuStringCopyWtoAAlloc(
    OUT LPSTR* ppszDest,
    IN size_t cbLimit,
    IN LPCWSTR pszSrc
    )
{
    DWORD dwError = ERROR_SUCCESS;
    int cbMultiByte = 0;
    LPSTR lpMultiByteStr = NULL;
    
    cbMultiByte = WideCharToMultiByte(
                      CP_ACP,       // code page
                      0,            // performance and mapping flags
                      pszSrc,       // string to map
                      -1,           // assume null termination
                      NULL,         // buffer for new string
                      0,            // find out size of buffer
                      NULL,         // default for unmappable chars
                      NULL          // set when default char used
                      );
    if (cbMultiByte <= 0) {
       dwError = GetLastError();
       NSU_BAIL_ON_ERROR(dwError);
    } else if (cbLimit && (size_t) cbMultiByte > cbLimit) {
        cbMultiByte = cbLimit;
    }

    lpMultiByteStr = NsuAlloc(
                        cbMultiByte,
                        0
                        );
    NSU_BAIL_ON_NULL(lpMultiByteStr, dwError);

    cbMultiByte = WideCharToMultiByte(
                      CP_ACP,          // code page
                      0,               // performance and mapping flags
                      pszSrc,          // string to map
                      -1,              // assume null termination
                      lpMultiByteStr,  // buffer for new string
                      cbMultiByte,     // size of buffer
                      NULL,            // default for unmappable chars
                      NULL             // set when default char used
                      );
    if (cbMultiByte == 0) {
       dwError = GetLastError();
        //  If ERROR_INSUFFICIENT_BUFFER user set limit 
        //  so just null terminate.
        
        if (dwError == ERROR_INSUFFICIENT_BUFFER && cbLimit) {
            lpMultiByteStr[cbLimit-1] = '\0';
        } else {
            NSU_BAIL_ON_ERROR(dwError);
        }

    }

   *ppszDest = lpMultiByteStr;
    
    return dwError;
NSU_CLEANUP:
    if (lpMultiByteStr) {
        // Don't want to overwrite dwError so ignore NsuFree errors 
        //
    
        (VOID) NsuFree0(&lpMultiByteStr);
    }
    
    *ppszDest = NULL;
    
    return dwError;        
}


// Description:
//
//      Converts pszSrc from MBCS to an Unicode string and pass the result back in pszDest.
//      Always null terminates pszDest.
//      Use NsuFree to free the allocated string.
//
// Arguments:
//
//      ppszDest - pointer to output string that is returned.
//      cchDest - maximum number of characters to place in pszDest including null character.
//                    If cchDest is less than the required output string buffer, only cchDest bytes
//                    are converted, and ERROR_INSUFFICIENT_BUFFER is returned.
//     pszSrc  source string.  
// 
// Return Value:
//
//      ERROR_INVALID_PARAMETER - if one of the parameters is invalid.
//      ERROR_INSUFFICIENT_BUFFER - cchLimit is less than required output string lenghth.
//      ERROR_SUCCESS
//      Other WIN32 errors
//

DWORD
NsuStringCopyAtoW(
    OUT LPWSTR pszDest,
    IN size_t  cchDest,
    IN LPCSTR  pszSrc
    )
{
    DWORD dwError = ERROR_SUCCESS;
    int cchWideChar = 0;

    cchWideChar = MultiByteToWideChar(
                    CP_ACP,                 // ANSI Code page
                    0,                      // No special options
                    pszSrc,                 // string to map
                    -1,                     // Assume string is null terminated.
                    pszDest,                // wide-character buffer
                    cchDest                 // size of buffer
                    );
    if (cchWideChar == 0) {
       dwError = GetLastError();
        //  If ERROR_INSUFFICIENT_BUFFER just null terminate.
        
        if (dwError == ERROR_INSUFFICIENT_BUFFER && cchDest) {
            pszDest[cchDest-1] = L'\0';
        }
    }

    
    return dwError;
}



// Description:
//
//      Converts pszSrc from Unicode string to an MBCS and puts the result in pszDest.
//      Always null terminates pszDest.  
//
// Arguments:
//  
//
//     pszDest - destination string.
//     cchDest - maximum number of characters to place in pszDest including null character.
//                    If cchDest is less than the required output string buffer, only cchDest bytes
//                    are converted, and ERROR_INSUFFICIENT_BUFFER is returned.
//     pszSrc  source string.  
//
// Return Value:
//
//      ERROR_INVALID_PARAMETER - if one of the parameters is invalid.  *ppszDest set to NULL.
//      ERROR_INSUFFICIENT_BUFFER - cchDest is less than required output string length.
//      ERROR_SUCCESS
//      Other WIN32 errors possible. 
//

DWORD
NsuStringCopyWtoA(
    OUT LPSTR pszDest,
    IN size_t cbDest,
    IN LPCWSTR pszSrc
    )
{
    DWORD dwError = ERROR_SUCCESS;
    int cbMultiByte = 0;

    cbMultiByte = WideCharToMultiByte(
                      CP_ACP,          // code page
                      0,               // performance and mapping flags
                      pszSrc,          // string to map
                      -1,              // assume null termination
                      pszDest,         // buffer for new string
                      cbDest,          // size of buffer
                      NULL,            // default for unmappable chars
                      NULL             // set when default char used
                      );
    if (cbMultiByte == 0) {
       dwError = GetLastError();
        //  If ERROR_INSUFFICIENT_BUFFER just null terminate.
        
        if (dwError == ERROR_INSUFFICIENT_BUFFER && cbDest) {
            pszDest[cbDest-1] = '\0';
        }

    }

  
    return dwError;
}


// Description:
//
//      Makes a duplicate deep memory copy of pszSrc and returns the result in *ppszDest.
//      *ppszDest is allocated enough space to store the output string.
//      Always null terminates *ppszDest.  
//      Use NsuFree to free the allocate string.
//
// Arguments:
//  
//      ppszDest - pointer to output string that is returned.      
//      cchLimit - specifies the maximum size of the output string to allocate including
//                 the NULL character.
//                 Pass 0 if no maximum should be enforced.  if cchLimit is
//                 less than the required output string buffer, only cchLimit characters
//                 are duplicated, and ERROR_INSUFFICIENT_BUFFER is returned.
//
// Return Value:
//
//      ERROR_INVALID_PARAMETER - if one of the parameters is invalid.  pszDest unchanged.
//      ERROR_INSUFFICIENT_BUFFER - cchLimit is less than required output string length.
//      ERROR_SUCCESS
//      Other WIN32 errors possible.
//

DWORD
NsuStringDupW(
    OUT LPWSTR* ppszDest,
    IN size_t cchLimit,
    IN LPCWSTR pszSrc
    )
{
    DWORD dwError = ERROR_SUCCESS;    
    size_t cchToCopy = 0;
    LPWSTR pszDest = NULL;

    dwError = NsuStringLenW(
                pszSrc,
                &cchToCopy
                );
    NSU_BAIL_ON_ERROR(dwError);

    cchToCopy++; 
    if (cchLimit && cchToCopy >= cchLimit) {
        cchToCopy = cchLimit;
    }

    pszDest = NsuAlloc(
                cchToCopy * sizeof(WCHAR),
                0
                );
    NSU_BAIL_ON_NULL(pszDest, dwError);
    
    dwError = NsuStringCopyW(
                pszDest,
                cchToCopy,
                pszSrc
                );
    //  ERROR_INSUFFICIENT_BUFFER is expected if user
    //  set a limit on the length of duplicate.
    //
    
    if (dwError != ERROR_INSUFFICIENT_BUFFER) {
        NSU_BAIL_ON_ERROR(dwError);
    }

    
    *ppszDest = pszDest;
    
    return dwError;
NSU_CLEANUP:
    if (pszDest) {
        // Don't want to overwrite dwError so ignore NsuFree errors 
        //
        
        (VOID) NsuFree0(
                    &pszDest
                    );
    }

    *ppszDest = NULL;
        
    return dwError;    
}
    

// Description:
//
//      See NsuStringDupW
//

DWORD
WINAPI
NsuStringDupA(
    OUT LPSTR* ppszDest,
    IN size_t cchLimit,
    IN LPCSTR pszSrc
    )
{
    DWORD dwError = ERROR_SUCCESS;    
    size_t cchToCopy = 0;
    LPSTR pszDest = NULL;

    dwError = NsuStringLenA(
                pszSrc,
                &cchToCopy
                );
    NSU_BAIL_ON_ERROR(dwError);

    cchToCopy++; 
    if (cchLimit && cchToCopy >= cchLimit) {
        cchToCopy = cchLimit;
    }

    pszDest = NsuAlloc(
                cchToCopy,
                0
                );
    NSU_BAIL_ON_NULL(pszDest, dwError);
    
    dwError = NsuStringCopyA(
                pszDest,
                cchToCopy,
                pszSrc
                );
    //  ERROR_INSUFFICIENT_BUFFER is expected if user
    //  set a limit on the length of duplicate.
    //
    
    if (dwError != ERROR_INSUFFICIENT_BUFFER) {
        NSU_BAIL_ON_ERROR(dwError);
    }
    
    *ppszDest = pszDest;
    
    return dwError;
NSU_CLEANUP:
    if (pszDest) {

        // Ignoring errors from NsuFree because want to return
        // original cause of bailing out.
        //
        
        (VOID) NsuFree0(
                    &pszDest
                    );
    }

    *ppszDest = NULL;
        
    return dwError;    
}


// Description:
//
//     Concatenates characters from pszSrc to pszDest and makes sure that the
//     the resulting is not longer than cchDest characters, including
//     the NULL character.
//     If not enough space was available in pszDest to concatanenate the whole of pszSrc,
//     ERROR_INSUFFICIENT_BUFFER is returned but as much as the space that was available in pszDest
//     is filled with characters from pszSrc.
//     Always null terminates pszDest.  
//
// Arguments:
//
//     pszDest - destination string.
//     cchDest - maximum number length allowed for resulting string including null character.
//     pszSrc  - souce string.
//
// Return Value:
//      ERROR_INVALID_PARAMETER - if one of the parameters is invalid.
//      ERROR_INSUFFICIENT_BUFFER - if not enough space in pszDest to cat the whole of pszSrc.
//      ERROR_SUCCESS
//      Other WIN32 errors possible.
//

DWORD
NsuStringCatW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszSrc
    )
{
    HRESULT hr = S_OK;

    hr = StringCchCatW(
            pszDest,
            cchDest,
            pszSrc
            );
    
    return HRESULT_CODE(hr);
}

// Description:
//
//      See NsuStringCatW
//

DWORD
NsuStringCatA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszSrc
    )
{
    HRESULT hr = S_OK;

    hr = StringCchCatA(
            pszDest,
            cchDest,
            pszSrc
            );
    
    return HRESULT_CODE(hr);
}

// Description:
//
//     Safe version of sprintf.  Formats and writes a string to pszDest
//     sure that the result is not longer than cchDest characters, including
//     the NULL character.
//     If more space is required than cchDest characteters, ERROR_INSUFFICIENT_BUFFER
//     is returned but cchDest characters are always written to pszDest.
//     Always null terminates pszDest.  
//
// Arguments:
//
//     pszDest - destination string.
//     cchDest - maximum number length allowed for resulting string including null character.
//     pszFormat - printf-style format string.
//     Optional arguments to format and write to pszDest.
//
// Return Value:
//      ERROR_INVALID_PARAMETER - if one of the parameters is invalid.
//      ERROR_INSUFFICIENT_BUFFER - if length of the  is greater than cchDest.
//      ERROR_SUCCESS
//      Other WIN32 errors possible.
//

DWORD
NsuStringSprintW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszFormat,
    ...
    )
{
    HRESULT hr = S_OK;
    va_list pArguments = NULL;

    va_start(pArguments, pszFormat);

    hr = StringCchVPrintfW(    
            pszDest,
            cchDest,
            pszFormat,
            pArguments
            );
    
    va_end(pArguments);

    return HRESULT_CODE(hr);
}
    

// Description:
//
//  See NsuStringPrintA
//

DWORD
NsuStringSprintA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszFormat,
    ...
    )
{
    HRESULT hr = S_OK;
    va_list pArguments = NULL;

    va_start(pArguments, pszFormat);

    hr = StringCchVPrintfA(    
            pszDest,
            cchDest,
            pszFormat,
            pArguments
            );
    
    va_end(pArguments);

    return HRESULT_CODE(hr);

}


// Description:
//
//     Fail Safe version of NsuStringSprint.  Formats and writes a string to pszDest
//     sure that the result is not longer than cchDest characters, including
//     the NULL character.
//     If more space is required than cchDest characteters, no error
//     is returned but cchDest characters are always written to pszDest.
//     Always null terminates pszDest.  
//     This function differs from the normal NsuStringSprint in that it does not return an error code,
//     and if the function fails for some reason, pszDest will be set to an empty string.
//
// Arguments:
//
//     pszDest - destination string.
//     cchDest - maximum number length allowed for resulting string including null character.
//     pszFormat - printf-style format string.
//     Optional arguments to format and write to pszDest.
//
// Return Value:
//      None

VOID
NsuStringSprintFailSafeW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszFormat,
    ...
    )
{
    HRESULT hr = S_OK;
    va_list pArguments = NULL;

    va_start(pArguments, pszFormat);
    
    if (cchDest) {
        hr = StringCchVPrintfW(    
                pszDest,
                cchDest,
                pszFormat,
                pArguments
                );
    } else {
        hr = STRSAFE_E_INVALID_PARAMETER;
        NSU_BAIL_OUT;
    }
    
    va_end(pArguments);

    if (hr != STRSAFE_E_INSUFFICIENT_BUFFER && FAILED(hr)) {
        NSU_BAIL_OUT;
    }
    
    return;
NSU_CLEANUP:
    if (cchDest) {
        pszDest[0] = L'\0';
    }
    return;
}
    

// Description:
//
//  See NsuStringPrintFailSafeA
//

VOID
NsuStringSprintFailSafeA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszFormat,
    ...
    )
{
    HRESULT hr = S_OK;
    va_list pArguments = NULL;

    va_start(pArguments, pszFormat);
    if (cchDest) {
        hr = StringCchVPrintfA(    
                pszDest,
                cchDest,
                pszFormat,
                pArguments
                );
    } else {
        hr = STRSAFE_E_INVALID_PARAMETER;
        NSU_BAIL_OUT;
    }
    
    va_end(pArguments);

    if (hr != STRSAFE_E_INSUFFICIENT_BUFFER && FAILED(hr)) {
        NSU_BAIL_OUT;
    }

    return;
NSU_CLEANUP:
    if (cchDest) {
        pszDest[0] = '\0';
    }
    return;
}


// Description:
//
//     Fail Safe version of NsuStringSprint that accepts a va_list of arguments.
//     Formats and writes a string to pszDest sure that the result is not longer
//     than cchDest characters, including the NULL character.
//     If more space is required than cchDest characteters, no error
//     is returned but cchDest characters are always written to pszDest.
//     Always null terminates pszDest.  
//
// Arguments:
//
//     pszDest - destination string.
//     cchDest - maximum number length allowed for resulting string including null character.
//     pszFormat - printf-style format string.
//     vaArguments - Arguments to format and write to pszDest.
//
// Return Value:
//      None
//

VOID
NsuStringVSprintFailSafeW(
    OUT LPWSTR pszDest,
    IN size_t cchDest,
    IN LPCWSTR pszFormat,
    IN va_list vaArguments
    )
{
    HRESULT hr = S_OK;
    if (cchDest) {
        hr = StringCchVPrintfW(    
                pszDest,
                cchDest,
                pszFormat,
                vaArguments
                );
    } else {
        hr = STRSAFE_E_INVALID_PARAMETER;
        NSU_BAIL_OUT;
    }
    
    if (hr != STRSAFE_E_INSUFFICIENT_BUFFER && FAILED(hr)) {
        NSU_BAIL_OUT;
    }

    return;
NSU_CLEANUP:
    if (cchDest) {
        pszDest[0] = L'\0';
    }
    return;
}
    

// Description:
//
//  See NsuStringVPrintFailSafeW
//

VOID
NsuStringVSprintFailSafeA(
    OUT LPSTR pszDest,
    IN size_t cchDest,
    IN LPCSTR pszFormat,
    IN va_list vaArguments
    )
{
    HRESULT hr = S_OK;

    if (cchDest) {
        hr = StringCchVPrintfA(    
                pszDest,
                cchDest,
                pszFormat,
                vaArguments
                );

    } else {
        hr = STRSAFE_E_INVALID_PARAMETER;
        NSU_BAIL_OUT;
    }

    if (hr != STRSAFE_E_INSUFFICIENT_BUFFER && FAILED(hr)) {
        NSU_BAIL_OUT;
    }

    return;
NSU_CLEANUP:
    if (cchDest) {
        pszDest[0] = '\0';
    }
    return;
}


// Description:
//
//     Safe version of strlen, that will not Access Violate if
//     passed a bad pointer or a non-null terminated string.
//     A non-null terminated string is detected by making
//     sure we do not read past the string into memory we do not own.
//       
//
// Arguments:
//
//     pszStr - Input string.
//     pcchStrLen - pointer to variable in which to return string length.
//
// Return Value:
//      ERROR_INVALID_PARAMETER - if pszStr points to an invalid string.
//      ERROR_SUCCESS
//

DWORD
NsuStringLenW(
    IN LPCWSTR pszStr,
    OUT size_t* pcchStrLen
    )
{
    BOOL fBadStr = TRUE;
    DWORD dwError = ERROR_SUCCESS;
    size_t cchStrLen = 0;

    if (!pszStr) {
        dwError = ERROR_INVALID_PARAMETER;
        NSU_BAIL_ON_ERROR(dwError);
    }

    __try {
        cchStrLen = wcslen(pszStr);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_PARAMETER;
    }
    NSU_BAIL_ON_ERROR(dwError);

    *pcchStrLen = cchStrLen;
    
    return dwError;

NSU_CLEANUP:
    *pcchStrLen = 0;
    
    return dwError;
}

// Description:
//
//      See NsuStringLenW
//

DWORD
NsuStringLenA(
    IN LPCSTR pszStr,
    OUT size_t* pcbStrLen
    )
{
    BOOL fBadStr = TRUE;
    DWORD dwError = ERROR_SUCCESS;
    size_t cbStrLen;

    if (!pszStr) {
        dwError = ERROR_INVALID_PARAMETER;
        NSU_BAIL_ON_ERROR(dwError);
    }
    
    __try {
        cbStrLen = strlen(pszStr);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_PARAMETER;
    }
    NSU_BAIL_ON_ERROR(dwError);

    *pcbStrLen = cbStrLen;
    
    return dwError;

NSU_CLEANUP:
    *pcbStrLen = 0;
    
    return dwError;

}

// Description:
//
//     Safe string searching routine that will not Access Violate if
//     passed bad pointers or non-null terminated strings.
//     pszStartOfMatch is a pointer to the start of the first match
//     of the string to search for in the string to search.
//
//
// Arguments:
//
//     pszStrToSearch - Input string to search in.
//     pszStrToFind - Input string to search for.
//     bIsCaseSensitive - if true, perform case sensitive search
//     pszStartOfMatch - pointer to first occurrance of pszStrToFind
//                       within pszStrToSearch
//
// Return Value:
//      ERROR_INVALID_PARAMETER - if either input string points to an invalid string.
//      ERROR_SUCCESS
//

DWORD
WINAPI
NsuStringFindW(
	IN LPCWSTR pszStrToSearch,
	IN LPCWSTR pszStrToFind,
	IN BOOL bIsCaseSensitive,
	OUT LPCWSTR* ppszStartOfMatch
	)
{
	DWORD dwError = ERROR_SUCCESS;
	size_t uiSearchLen;
	size_t uiFindLen;
	size_t i;

	*ppszStartOfMatch = 0;

	NsuStringLenW(pszStrToSearch, &uiSearchLen);
	NSU_BAIL_ON_ERROR(dwError);
	NsuStringLenW(pszStrToFind, &uiFindLen);
	NSU_BAIL_ON_ERROR(dwError);

	i = 0;
	if (bIsCaseSensitive)
	{
		while ((*ppszStartOfMatch == 0) && ((uiSearchLen - i) >= uiFindLen))
		{
			if (wcsncmp(&pszStrToSearch[i], pszStrToFind, uiFindLen) == 0)
			{
				*ppszStartOfMatch = &pszStrToSearch[i];
			}
			++i;
		}
	}
	else
	{
		while ((*ppszStartOfMatch == 0) && ((uiSearchLen - i) >= uiFindLen))
		{
			if (_wcsnicmp(&pszStrToSearch[i], pszStrToFind, uiFindLen) == 0)
			{
				*ppszStartOfMatch = &pszStrToSearch[i];
			}
			++i;
		}
	}

NSU_CLEANUP:
	return dwError;
}

// Description:
//
//      See NsuStringFindW
//

DWORD
WINAPI
NsuStringFindA(
	IN LPCSTR pszStrToSearch,
	IN LPCSTR pszStrToFind,
	IN BOOL bIsCaseSensitive,
	OUT LPCSTR* ppszStartOfMatch
	)
{
	DWORD dwError = ERROR_SUCCESS;
	size_t uiSearchLen;
	size_t uiFindLen;
	size_t i;

	*ppszStartOfMatch = 0;

	NsuStringLenA(pszStrToSearch, &uiSearchLen);
	NSU_BAIL_ON_ERROR(dwError);
	NsuStringLenA(pszStrToFind, &uiFindLen);
	NSU_BAIL_ON_ERROR(dwError);

	i = 0;
	if (bIsCaseSensitive)
	{
		while ((*ppszStartOfMatch == 0) && ((uiSearchLen - i) >= uiFindLen))
		{
			if (strncmp(&pszStrToSearch[i], pszStrToFind, uiFindLen) == 0)
			{
				*ppszStartOfMatch = &pszStrToSearch[i];
			}
			++i;
		}
	}
	else
	{
		while ((*ppszStartOfMatch == 0) && ((uiSearchLen - i) >= uiFindLen))
		{
			if (_strnicmp(&pszStrToSearch[i], pszStrToFind, uiFindLen) == 0)
			{
				*ppszStartOfMatch = &pszStrToSearch[i];
			}
			++i;
		}
	}

NSU_CLEANUP:
	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\nsumem.c ===
// Copyright (c) 1997-2002 Microsoft Corporation
//
// Module:
//
//     NSU memory utilities
//
// Abstract:
//
//     Contains the code that provides memory allocation deallocation routines.
//
// Author:
//
//     kmurthy 2/5/02
//
// Environment:
//
//     User mode
//
// Revision History:
//

#include <precomp.h>
#include "Nsu.h"

//
// Description:
//
//		Allocates memory from the Heap.
//
// Arguments:
//
//		dwBytes [IN]: Number of bytes to allocate 
//		dwFlags [IN]: Flags that could be HEAP_ZERO_MEMORY
//
// Return Value: 
//
//		Pointer to allocated memory, NULL on error
//
PVOID NsuAlloc(SIZE_T dwBytes,DWORD dwFlags)
{
	return HeapAlloc(GetProcessHeap(), dwFlags, dwBytes);
}


//
// Description:
//
//		Frees previously allocated memory and sets pointer to 
//		memory, to FREED_POINTER.
//
// Arguments:
//
//		ppMem [IN-OUT]: Pointer to pointer to allocated memory
//
// Return Value:
//
//		ERROR_SUCCESS on success. 
//		ERROR_INVALID_PARAMETER, if pointer is invalid or has
//		already been freed.
//		Other Win32 errors on failure.
//
DWORD NsuFree(PVOID *ppMem)
{
	BOOL fRet = TRUE;
	DWORD dwErr = ERROR_SUCCESS;

	//Check if pointer is invalid or if
	//allocated pointer is pointing to FREED_POINTER
	if((!ppMem) || (*ppMem == FREED_POINTER)){
		dwErr = ERROR_INVALID_PARAMETER;
		NSU_BAIL_OUT
	}

	fRet = HeapFree(GetProcessHeap(), 0, *ppMem);

	if(fRet){
		*ppMem = FREED_POINTER;
	}
	else{
		dwErr = GetLastError();
		NSU_BAIL_OUT
	}

NSU_CLEANUP:
	return dwErr;
}


// Description:
//
//		Frees previously allocated memory and sets pointer to 
//		memory, to FREED_POINTER. In addition, it checks if pointer is 
//		already NULL, in which case it will simply return ERROR_SUCCESS.
//
// Arguments:
//
//		ppMem [IN-OUT]: Pointer to pointer to allocated memory
//
// Return Value: 
//		
//		ERROR_SUCCESS on success. 
//		ERROR_INVALID_PARAMETER, if pointer is invalid or has
//		already been freed.
//		Other Win32 errors on failure.
//
DWORD NsuFree0(PVOID *ppMem)
{
	BOOL fRet = TRUE;
	DWORD dwErr = ERROR_SUCCESS;

	//Check if pointer is invalid or if
	//allocated pointer is pointing to FREED_POINTER
	if((!ppMem) || (*ppMem == FREED_POINTER)){
		dwErr = ERROR_INVALID_PARAMETER;
		NSU_BAIL_OUT
	}

	//Check if the memory was not allocated
	//
	if(*ppMem == NULL){
		NSU_BAIL_OUT
	}
	
	fRet = HeapFree(GetProcessHeap(), 0, *ppMem);

	if(fRet){
		*ppMem = FREED_POINTER;
	}
	else{
		dwErr = GetLastError();
		NSU_BAIL_OUT
	}

NSU_CLEANUP:
	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocSPDMem(
    DWORD cb
);

BOOL
FreeSPDMem(
   LPVOID pMem
);

LPVOID
ReallocSPDMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocSPDStr(
    LPWSTR pStr
);

BOOL
FreeSPDStr(
   LPWSTR pStr
);


BOOL
ReallocSPDStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

DWORD
AllocateSPDMemory(
    DWORD cb,
    LPVOID * ppMem
    );

void
FreeSPDMemory(
    LPVOID pMem
    );

DWORD
AllocateSPDString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    );

void
FreeSPDString(
    LPWSTR pszString
    );


#if DBG

extern LIST_ENTRY SPDMemList ;

extern CRITICAL_SECTION SPDMemCritSect ;

VOID InitSPDMem(
    VOID
    ) ;

VOID AssertSPDMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitSPDMem()
#define AssertSPDMemLeaks()

#define DumpMemoryTracker()



#endif


#ifdef __cplusplus
}
#endif

/*
inline void * _CRTAPI1
operator new(size_t size)
{
    return AllocSPDMem(size);
}

inline void  _CRTAPI1
operator delete(void * pv)
{
    FreeSPDMem(pv);
}*/


#endif // _MEMORY_H_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <wchar.h>
#include <dsgetdc.h>
#include <lm.h>

#define UNICODE

#include <winldap.h>
#include <ipsec.h>
#include <oakdefs.h>
#include <oleauto.h>
#include <polstructs.h>

#include "winsock2.h"
#include "winsock.h"
#include "spd_c.h"
#include "memory.h"
#include "ipsecshr.h"
#include "nsuacl.h"

#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {                   \
        goto error;                  \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\nsuacl.c ===
// Copyright (c) 1997-2002 Microsoft Corporation
//
// Module:
//
//     Network Security Utilities
//
// Abstract:
//
//     Acl API's
//
// Authors:
//
//     pmay 2/5/02
//     raymonds 03/20/02
//
// Environment:
//
//     User mode
//
// Revision History:
//

#include <precomp.h>

// Private declarations
//

// Maximum string security descriptor length
//

#define MAX_STR_SD_LEN  128

// TBD: Remove these when incorporated into main NSU utilities

#define CLEANUP Cleanup

#define BAIL_ON_ERROR(err) if((err) != ERROR_SUCCESS) {goto CLEANUP;}
#define BAIL_ON_NULL(ptr, err) if ((ptr) == NULL) {(err) = ERROR_NOT_ENOUGH_MEMORY; goto CLEANUP;}
#define BAIL_OUT {goto CLEANUP;}


// Description:
//
//     Allocates and initializes a SECURITY_ATTRIBUTES structure that gives
//     access according to the flags passed in.  (contained SD is self-relative).
//
// Arguments:
//
//     ppSecurityAttributes - pointer to SECURITY_ATTRIBUTES created.
//                            Use NsuAclAttributesDestroy to destroy.
//     dwFlags - see NSU_ACL_F_* values
//
// Return Value:
//      
//     An allocated security attributes structure or NULL if out of memory.
//
//
//  TBD: use NsuString and Nsu mem functions

DWORD
NsuAclAttributesCreate(
    OUT PSECURITY_ATTRIBUTES* ppSecurityAttributes,
	IN DWORD dwFlags)
{
    DWORD dwError = ERROR_SUCCESS;
    SECURITY_ATTRIBUTES *pSecurityAttributes = NULL;

    pSecurityAttributes = LocalAlloc(LPTR, sizeof(SECURITY_ATTRIBUTES));
    BAIL_ON_NULL(pSecurityAttributes, dwError);

    dwError = NsuAclDescriptorCreate(
                (PSECURITY_DESCRIPTOR*) &pSecurityAttributes->lpSecurityDescriptor,
                dwFlags
                );
    BAIL_ON_ERROR(dwError);
    pSecurityAttributes->nLength = sizeof(SECURITY_ATTRIBUTES);
    pSecurityAttributes->bInheritHandle = FALSE; 
    
    *ppSecurityAttributes = pSecurityAttributes;

    return dwError;
    
CLEANUP:
    if (pSecurityAttributes) {
        NsuAclAttributesDestroy(&pSecurityAttributes);
    }

    *ppSecurityAttributes = NULL;
    return dwError;
}

// Description:
//
//     Deallocates return value of NsuAclCreateAttributes.
//
DWORD 
NsuAclAttributesDestroy(
	IN OUT PSECURITY_ATTRIBUTES* ppSecurityAttributes)
{
    DWORD dwError = ERROR_SUCCESS;

    if (!ppSecurityAttributes) {
        BAIL_OUT;
    }

    // Destroy Security descriptor, ignoring any errors, since there's not much we
    // can do and want to clean up the rest of the attributes as much as possible.
    //
        
    (VOID) NsuAclDescriptorDestroy((*ppSecurityAttributes)->lpSecurityDescriptor);

    (VOID) LocalFree(*ppSecurityAttributes);

    *ppSecurityAttributes = NULL;
    return dwError;

CLEANUP:    
    return dwError;
}

// Description:
//
//     Allocates and initializes a self-relative SECURITY_DESCRIPTOR structure that gives
//     access according to the flags passed in.
//
// Arguments:
//
//     ppSecurityDescriptor - security descriptor created.  Use NsuAclDescriptorDestroy
//                            to destroy.
//     dwFlags - see NSU_ACL_F_* values
//
// Return Value:
//      
//     An allocated security attributes structure or NULL if out of memory.
//
DWORD
NsuAclDescriptorCreate (
    OUT PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
	IN DWORD dwFlags)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL  fSucceeded = TRUE;
    WCHAR szStringSecurityDescriptor[MAX_STR_SD_LEN] = {0};
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    wcscpy(szStringSecurityDescriptor, L"D:AIAR");
    if (dwFlags & NSU_ACL_F_AdminFull) {
        wcscat(szStringSecurityDescriptor, L"(A;OICI;GA;;;BA)");
    }

    if (dwFlags & NSU_ACL_F_LocalSystemFull) {
        wcscat(szStringSecurityDescriptor, L"(A;OICI;GA;;;SY)");
    }
    
    fSucceeded = ConvertStringSecurityDescriptorToSecurityDescriptorW(
                      szStringSecurityDescriptor, 
                      SDDL_REVISION_1, 
                      &pSecurityDescriptor, 
                      NULL
                      );
    if (!fSucceeded) {
        dwError = GetLastError();
        BAIL_OUT;
    }

    *ppSecurityDescriptor = pSecurityDescriptor;

    return dwError;
CLEANUP:
    NsuAclDescriptorDestroy(&pSecurityDescriptor);
    *ppSecurityDescriptor = NULL;
    return dwError;
}

// Description:
//
//     Deallocates return value of NsuAclCreateDescriptor.
//
DWORD 
NsuAclDescriptorDestroy(
	IN OUT PSECURITY_DESCRIPTOR* ppDescriptor)
{
    DWORD dwError = ERROR_SUCCESS;

    if (!ppDescriptor) {
        BAIL_OUT;
    }
    
    (VOID) LocalFree(*ppDescriptor);

    *ppDescriptor = NULL;

    return dwError;
CLEANUP:    
    return dwError;
}

// Description:
//
//     Used to determine whether a given security descriptor grants
//     full access to everyone.
//
// Arguments:
//
//     pSD - the security descriptor
//	 pbRestricts - TRUE if non-Everyone-full-access, FALSE otherwise
//
// Return Value:
//      
//	 Standard win32 error
//
DWORD
NsuAclDescriptorRestricts(
	IN CONST PSECURITY_DESCRIPTOR pSD,
	OUT BOOL* pbRestricts)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

// Description:
//
//     Gets security descriptor of a regkey.     
//
//
// Arguments:
//
//     ppSecurityDescriptor - security descriptor returned.  Use NsuAclDescriptorDestroy
//                            to destroy.
//     hKey - open handle of registry key
//
// Return Value:
//      
//     An allocated security attributes structure or NULL if out of memory.
//

DWORD
NsuAclGetRegKeyDescriptor(
    IN  HKEY hKey,
    OUT PSECURITY_DESCRIPTOR* ppSecurityDescriptor
    )
{    
    PSECURITY_DESCRIPTOR pSecurityDescriptor = 0;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSecurityDescriptor = 0;
  
    cbSecurityDescriptor = 0;
    dwError = RegGetKeySecurity(
                      hKey, 
                      DACL_SECURITY_INFORMATION,
                      NULL, 
                      &cbSecurityDescriptor
                      );
    if (dwError != ERROR_INSUFFICIENT_BUFFER) {
        BAIL_ON_ERROR(dwError);
    }

    pSecurityDescriptor = LocalAlloc(LPTR, cbSecurityDescriptor);
    BAIL_ON_NULL(pSecurityDescriptor, dwError);
    dwError = RegGetKeySecurity(
                      hKey, 
                      DACL_SECURITY_INFORMATION,
                      pSecurityDescriptor, 
                      &cbSecurityDescriptor
                      );
    BAIL_ON_ERROR(dwError);

    *ppSecurityDescriptor = pSecurityDescriptor;
CLEANUP:
    if (dwError) {
        if (pSecurityDescriptor) {
            LocalFree(pSecurityDescriptor);
        }
        *ppSecurityDescriptor = NULL;
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\memory.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "precomp.h"

//#include "oledsdbg.h"

#define SPDAssert(x)    NULL

#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemoryLog = 0;

#define MAXDEPTH 10

typedef struct _SPDMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} SPDMEMTAG, *PSPDMEMTAG ;

LIST_ENTRY       SPDMemList ;
DWORD            SPDMemCount ;
CRITICAL_SECTION SPDMemCritSect ;

/*++

Routine Description:

    This function initializes the SPD mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitSPDMem(
    VOID
)
{
    InitializeCriticalSection(&SPDMemCritSect) ;
    InitializeListHead(&SPDMemList) ;
    SPDMemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertSPDMemLeaks(
    VOID
)
{
    SPDAssert(IsListEmpty(&SPDMemList)) ;
}

#endif

LPVOID
AllocSPDMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    LPVOID pMem = NULL;

    pMem = LocalAlloc(LPTR, cb);

    if (pMem) {
        memset((LPBYTE) pMem, 0, cb);
    }
    return (pMem);
}

BOOL
FreeSPDMem(
   LPVOID pMem
)
{
    return(LocalFree(pMem) == NULL);
}

LPVOID
ReallocSPDMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocSPDMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreeSPDMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocSPDStr(
    LPWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocSPDMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreeSPDStr(
   LPWSTR pStr
)
{
   return pStr ? FreeSPDMem(pStr)
               : FALSE;
}

BOOL
ReallocSPDStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   FreeSPDStr(*ppStr);
   *ppStr=AllocSPDStr(pStr);

   return TRUE;
}

DWORD
AllocateSPDMemory(
    DWORD cb,
    LPVOID * ppMem
    )
{
    DWORD dwError = 0;

    LPBYTE pMem = NULL;

    pMem = AllocSPDMem(cb);

    if (!pMem) {
        dwError = GetLastError();
    }

    *ppMem = pMem;

    return(dwError);
}

void
FreeSPDMemory(
    LPVOID pMem
    )
{
    if (pMem) {
        FreeSPDMem(pMem);
    }

    return;
}


DWORD
AllocateSPDString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    )
{
    LPWSTR pszNewString = NULL;
    DWORD dwError = 0;

    pszNewString = AllocSPDStr(pszString);

    if (!pszNewString) {
        dwError = GetLastError();
    }

    *ppszNewString = pszNewString;

    return(dwError);
}

void
FreeSPDString(
    LPWSTR pszString
    )
{
    if (pszString) {
        FreeSPDStr(pszString);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\validate.c ===
/*++

Copyright (c) 2002 Microsoft Corporation


Module Name:

    validate.c

Abstract:

    This module contains all of the code to perform data
    validation for IPSec user mode componets

Authors:

    RaymondS

Environment

    User Level: Win32

Revision History:
    21 APR 2002: Added ValidateFilterAction
    

--*/

#include <precomp.h>

DWORD
ValidateFilterAction(
    FILTER_ACTION FilterAction
    )
{
    DWORD dwError = ERROR_SUCCESS;

    if (FilterAction == 0 ||
        FilterAction >= FILTER_ACTION_MAX) 
    { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
error:
    return (dwError);
}

DWORD
ValidateInterfaceType(
    IF_TYPE InterfaceType
    )
{
    DWORD dwError = ERROR_SUCCESS;

    if (InterfaceType == 0 ||
        InterfaceType >= INTERFACE_TYPE_MAX)
    {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
error:
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\template.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    template.c

Abstract:

    Contains common template matching code

Author:

    BrianSw  10-19-200

Environment:

    User Level: Win32/kernel
    NOTE:  Since this is used by user and kernel mode, code accordingly

Revision History:


--*/

#include "precomp.h"



BOOL
WINAPI IsAllZero(BYTE *c, DWORD dwSize)
{

    DWORD i;
    for (i=0;i<dwSize;i++) {
        if (c[i] != 0) {
            return FALSE;
        }
    }
    return TRUE;

}

BOOL 
WINAPI CmpBlob(IPSEC_BYTE_BLOB* c1, IPSEC_BYTE_BLOB *c2)
{

    if (c1->dwSize == 0) {
        return TRUE;
    }
    if (c1->dwSize != c2->dwSize) {
        return FALSE;
    }
    if (memcmp(c1->pBlob,c2->pBlob,c1->dwSize) == 0) {
        return TRUE;
    }
    return FALSE;
}

BOOL 
WINAPI CmpData(BYTE* c1, BYTE *c2, DWORD size) 
{

    if ((!IsAllZero(c1,size)) && 
        (memcmp(c1,c2,size) != 0)) {
        return FALSE;
    }
    
    return TRUE;
}


/*
  For comparing structs like:

  typedef struct _PROTOCOL {
  PROTOCOL_TYPE ProtocolType;
  DWORD dwProtocol;
  } PROTOCOL, * PPROTOCOL;
  
  dwTypeSize is sizeof PROTOCOL_TYPE, dwStructSize is sizeof(PROTOCOL)

  Assumes type info is first in struct

  Template symantics:

  Template is:
  All 0, everything matches
  Type 0, rest non-0, exact match of rest of data
  Type non-0, rest 0, all entries of given type
  Type non-0, rest non-0, exact match

 */
BOOL 
WINAPI CmpTypeStruct(BYTE *Template, BYTE *comp,
                   DWORD dwTypeSize, DWORD dwStructSize)
{
    
    if (IsAllZero(Template,dwStructSize)) {
        return TRUE;
    }
    
    if (IsAllZero(Template,dwTypeSize)) {
        if (memcmp(Template+dwTypeSize,comp+dwTypeSize,
                   dwStructSize-dwTypeSize) == 0) {
            return TRUE;
        }
        return FALSE;
    }
    
    // Know here that Template.TypeInfo is non-0
    if (memcmp(Template,comp,dwTypeSize) != 0) {
        return FALSE;
    }
    
    if (IsAllZero(Template+dwTypeSize,dwStructSize-dwTypeSize)) {
        return TRUE;
    }
    if (memcmp(Template+dwTypeSize,comp+dwTypeSize,dwStructSize-dwTypeSize) == 0) {
        return TRUE;
    }
    
    return FALSE;

}

BOOL
WINAPI CmpAddr(ADDR *Template, ADDR *a2)
{
    if (Template->AddrType == IP_ADDR_UNIQUE && Template->uIpAddr) {
        if (Template->uIpAddr != (a2->uIpAddr)) {
            return FALSE;
        }
        if (a2->AddrType != IP_ADDR_UNIQUE) {
            return FALSE;
        }
    }

   if (IsSpecialServ(Template->AddrType) &&
       !(Template->AddrType == a2->AddrType)) {
        return FALSE;
   }
    
    if (Template->AddrType == IP_ADDR_SUBNET && Template->uIpAddr) {
        if ((Template->uIpAddr & Template->uSubNetMask)
            != (a2->uIpAddr & Template->uSubNetMask)) {
            return FALSE;
        }
        // Make sure template subnet contains a2's subnet (if a2 is unique, any subnet is superset of unique filter
        if (a2->AddrType == IP_ADDR_SUBNET && 
            ((Template->uSubNetMask & a2->uSubNetMask) != Template->uSubNetMask)) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL 
WINAPI CmpFilter(IPSEC_QM_FILTER *Template, IPSEC_QM_FILTER* f2) 
{


    if (!CmpTypeStruct((BYTE*)&Template->Protocol,
                           (BYTE*)&f2->Protocol,
                           sizeof(PROTOCOL_TYPE),
                           sizeof(PROTOCOL))) {
        return FALSE;
    }

    if (!CmpTypeStruct((BYTE*)&Template->SrcPort,
                       (BYTE*)&f2->SrcPort,
                       sizeof(PORT_TYPE),
                       sizeof(PORT))) {
        return FALSE;
    }

    if (!CmpTypeStruct((BYTE*)&Template->DesPort,
                       (BYTE*)&f2->DesPort,
                       sizeof(PORT_TYPE),
                       sizeof(PORT))) {
        return FALSE;
    }
    
    if (Template->QMFilterType) {
        if (Template->QMFilterType != f2->QMFilterType) {
            return FALSE;
        }
    }


    if (!CmpData((BYTE*)&Template->MyTunnelEndpt,
                 (BYTE*)&f2->MyTunnelEndpt,
                 sizeof(ADDR))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->PeerTunnelEndpt,
                 (BYTE*)&f2->PeerTunnelEndpt,
                 sizeof(ADDR))) {
        return FALSE;
    }

    if (!CmpAddr(&Template->SrcAddr,&f2->SrcAddr)) {
        return FALSE;
    }
    if (!CmpAddr(&Template->DesAddr,&f2->DesAddr)) {
        return FALSE;
    }
    
    return TRUE;

}

BOOL 
WINAPI CmpQMAlgo(PIPSEC_QM_ALGO Template, PIPSEC_QM_ALGO a2)
{
    
    if (!CmpData((BYTE*)&Template->Operation,
                 (BYTE*)&a2->Operation,
                 sizeof(IPSEC_OPERATION))) {
        return FALSE;
    }
    
    if (!CmpData((BYTE*)&Template->uAlgoIdentifier,
                 (BYTE*)&a2->uAlgoIdentifier,
                 sizeof(ULONG))) {
        return FALSE;
    }
    
    if (!CmpData((BYTE*)&Template->uSecAlgoIdentifier,
                 (BYTE*)&a2->uSecAlgoIdentifier,
                 sizeof(HMAC_AUTH_ALGO_ENUM))) {
        return FALSE;
    }
    
    if (!CmpData((BYTE*)&Template->MySpi,
                 (BYTE*)&a2->MySpi,
                 sizeof(IPSEC_QM_SPI))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->PeerSpi,
                 (BYTE*)&a2->PeerSpi,
                 sizeof(IPSEC_QM_SPI))) {
        return FALSE;
    }
    
    return TRUE;

}

BOOL 
WINAPI CmpQMOffer(PIPSEC_QM_OFFER Template, PIPSEC_QM_OFFER o2)
{

    DWORD i;

    if (!CmpData((BYTE*)&Template->Lifetime,
                 (BYTE*)&o2->Lifetime,
                 sizeof(KEY_LIFETIME))) {
        return FALSE;
    }

    if (Template->bPFSRequired) {
        if (Template->bPFSRequired != o2->bPFSRequired) {
            return FALSE;
        }
    }
    if (Template->dwPFSGroup) {
        if (Template->dwPFSGroup != o2->dwPFSGroup) {
            return FALSE;
        }
    }
    if (Template->dwNumAlgos) {
        if (Template->dwNumAlgos != o2->dwNumAlgos) {
            return FALSE;
        }
        for (i=0; i < Template->dwNumAlgos; i++) {
            if (!CmpQMAlgo(&Template->Algos[i],
                           &o2->Algos[i])) {
                return FALSE;
            }
        }
    }   

    return TRUE;

}

/*
  True if this NotifyListEntry Template matches the CurInfo

 */
BOOL 
WINAPI MatchQMSATemplate(IPSEC_QM_SA *Template,IPSEC_QM_SA *CurInfo)
{

    if (Template == NULL) {
        return TRUE;
    }

    if (!CmpFilter(&Template->IpsecQMFilter,
                   &CurInfo->IpsecQMFilter)) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->MMSpi.Initiator,
                 (BYTE*)&CurInfo->MMSpi.Initiator,sizeof(IKE_COOKIE))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->MMSpi.Responder,
                 (BYTE*)&CurInfo->MMSpi.Responder,sizeof(IKE_COOKIE))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->gQMPolicyID,
                 (BYTE*)&CurInfo->gQMPolicyID,sizeof(GUID))) {
        return FALSE;
    }
    
    if (!CmpQMOffer(&Template->SelectedQMOffer,
                    &CurInfo->SelectedQMOffer)) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->EncapInfo.SAEncapType,
                 (BYTE*)&CurInfo->EncapInfo.SAEncapType,
                 sizeof(IPSEC_SA_UDP_ENCAP_TYPE))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->EncapInfo.UdpEncapContext,
                 (BYTE*)&CurInfo->EncapInfo.UdpEncapContext,
                 sizeof(IPSEC_UDP_ENCAP_CONTEXT))) {
        return FALSE;
    }
    
    if (!CmpAddr(&Template->EncapInfo.PeerPrivateAddr,&CurInfo->EncapInfo.PeerPrivateAddr)) {
        return FALSE;
    }    
                    
    return TRUE;
}


BOOL 
WINAPI MatchMMSATemplate(IPSEC_MM_SA *MMTemplate, IPSEC_MM_SA *SaData)
{
    
    if (MMTemplate == NULL) {
        return TRUE;
    }
    if (!CmpData((BYTE*)&MMTemplate->gMMPolicyID,
                 (BYTE*)&SaData->gMMPolicyID,sizeof(GUID))) {
        return FALSE;
    }
    if (!CmpData((BYTE*)&MMTemplate->MMSpi.Initiator,
                 (BYTE*)&SaData->MMSpi.Initiator,sizeof(COOKIE))) {
        return FALSE;
    }
    if (!CmpData((BYTE*)&MMTemplate->MMSpi.Responder,
                 (BYTE*)&SaData->MMSpi.Responder,sizeof(COOKIE))) {
        return FALSE;
    }
    if (!CmpAddr(&MMTemplate->Me,&SaData->Me)) {
        return FALSE;
    }
    if (!CmpAddr(&MMTemplate->Peer,&SaData->Peer)) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.EncryptionAlgorithm,(BYTE*)&SaData->SelectedMMOffer.EncryptionAlgorithm,sizeof(IPSEC_MM_ALGO))) {
        return FALSE;
    }
    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.HashingAlgorithm,(BYTE*)&SaData->SelectedMMOffer.HashingAlgorithm,sizeof(IPSEC_MM_ALGO))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.dwDHGroup,(BYTE*)&SaData->SelectedMMOffer.dwDHGroup,sizeof(DWORD))) {
        return FALSE;
    }
    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.Lifetime,(BYTE*)&SaData->SelectedMMOffer.Lifetime,sizeof(KEY_LIFETIME))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.dwQuickModeLimit,(BYTE*)&SaData->SelectedMMOffer.dwQuickModeLimit,sizeof(DWORD))) {
        return FALSE;
    }

    if (!CmpBlob(&MMTemplate->MyId,&SaData->MyId)) {
        return FALSE;
    }
    if (!CmpBlob(&MMTemplate->PeerId,&SaData->PeerId)) {
        return FALSE;
    }
    if (!CmpBlob(&MMTemplate->MyCertificateChain,&SaData->MyCertificateChain)) {
        return FALSE;
    }
    if (!CmpBlob(&MMTemplate->PeerCertificateChain,&SaData->PeerCertificateChain)) {
        return FALSE;
    }

    //
    // TBD - Add UDP encapsulation context comparison later on.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\ipsecshr\utils.c ===
#include "precomp.h"
#include "Nsu.h"


#define PADDR_NET_PORTION(pAddr) ((pAddr)->uSubNetMask & (pAddr)->uIpAddr)
#define PADDR_HOST_PORTION(pAddr) ((0xffffffff ^ (pAddr)->uSubNetMask) & (pAddr)->uIpAddr)


DWORD
ValidateAddr(
    PADDR pAddr
    )
{
    DWORD dwError = 0;

    if (pAddr->AddrType == IP_ADDR_INTERFACE) {
        if (!(pAddr->pgInterfaceID)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        if (pAddr->pgInterfaceID) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
IsMulticastAddress(PADDR pAddr)
{
	ASSERT (pAddr != NULL);
	return IN_MULTICAST(pAddr->uIpAddr);
}


BOOL
IsBroadcastAddress(PADDR pAddr)
{
	ASSERT (pAddr != NULL);
	return (pAddr->uIpAddr == INADDR_BROADCAST || IsSubnetBroadcastAddress(pAddr));
}


BOOL
IsSubnetBroadcastAddress(
	PADDR pAddr
	)
{
	ASSERT (pAddr != NULL);

	return (((pAddr->uSubNetMask == 0) ||bIsValidIPMask(pAddr->uSubNetMask)) &&
		(PADDR_NET_PORTION(pAddr) != 0) &&
		(pAddr->uSubNetMask != 0xffffffff) &&
		((PADDR_HOST_PORTION(pAddr) | pAddr->uSubNetMask) == 0xffffffff));
}


BOOL
IsUnicastAddress(PADDR pAddr)
{
	ASSERT (pAddr != NULL);
	return (!(IsMulticastAddress(pAddr) || IsBroadcastAddress(pAddr)));
}


// This will go away if/when we change the code to accept any unicast address; at that time IsUnicastAddress() will
// be the correct function to call
BOOL
IsSupportedAddress(PADDR pAddr)
{
	ASSERT (pAddr != NULL);

	if (!IsSpecialServer(pAddr) && (
		(IN_CLASSE(pAddr->uIpAddr)) ||
		((IN_CLASSA_NET & pAddr->uIpAddr) == 0) || // first octet can't be 0
		(IsLoopbackAddress(pAddr))
		))
	{
		return FALSE;
	}

	return TRUE;
}


BOOL
IsLoopbackAddress(PADDR pAddr)
{
	ASSERT (pAddr != NULL);
	return (pAddr->uIpAddr == INADDR_LOOPBACK);
}


BOOL
IsValidTunnelEndpointAddress(PADDR pAddr)
{
	ASSERT (pAddr != NULL);
	return IsUnicastAddress(pAddr);
}


BOOL
IsSpecialServer(PADDR pAddr)
{
	ASSERT (pAddr != NULL);
	return IsSpecialServ(pAddr->AddrType);
}


BOOL
IsValidSubnet(
	PADDR pAddr
	)
{
	ASSERT (pAddr != NULL);
	return ((PADDR_NET_PORTION(pAddr) != 0) && (PADDR_HOST_PORTION(pAddr) == 0));
}


BOOL
IsValidSubnettedAddress(
	PADDR pAddr
	)
{
	ASSERT (pAddr != NULL);
	if ((pAddr->AddrType != IP_ADDR_UNIQUE) || (!bIsValidIPMask(pAddr->uSubNetMask)))
	{
		return FALSE;
	}

	return ((PADDR_NET_PORTION(pAddr) != 0) && (PADDR_HOST_PORTION(pAddr) != 0));
}


DWORD
ValidateMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;


    if (!pMMPolicy) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMPolicy->pszPolicyName) || !(*(pMMPolicy->pszPolicyName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateMMOffers(
                  pMMPolicy->dwOfferCount,
                  pMMPolicy->pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
ValidateMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    DWORD dwError = 0;
    DWORD i = 0;


    if (!dwOfferCount || !pOffers || (dwOfferCount > IPSEC_MAX_MM_OFFERS)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}

DWORD CompareCertRootConfig(PCERT_ROOT_CONFIG pCertRootConfig1,
                            PCERT_ROOT_CONFIG pCertRootConfig2)
{
    
    DWORD dwError = ERROR_SUCCESS;
    
    if (pCertRootConfig1->dwCertDataSize != pCertRootConfig2->dwCertDataSize) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    if (memcmp(pCertRootConfig1->pCertData,
               pCertRootConfig2->pCertData,
               pCertRootConfig1->dwCertDataSize) != 0) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    // Don't need to compare AuthorizationData since this must currently always be 0.

error:

    return (dwError);
}


DWORD ValidateCertRootConfig(PCERT_ROOT_CONFIG pCertRootConfig)
{

    DWORD dwError = 0;

    if (pCertRootConfig->dwCertDataSize == 0 || 
        pCertRootConfig->pCertData == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pCertRootConfig->dwAuthorizationDataSize || 
        pCertRootConfig->pAuthorizationData) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
error:
    return (dwError);

}


DWORD ValidateCertAuthInfo(PMM_CERT_INFO pCertInfo)
{
    DWORD dwError = 0;
    DWORD i;

    if (pCertInfo->dwVersion != 0) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pCertInfo->dwMyCertHashSize || pCertInfo->pMyCertHash) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    // Outbound root array MUST be idential to inbound
    if (pCertInfo->dwInboundRootArraySize != pCertInfo->dwOutboundRootArraySize) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i=0; i < pCertInfo->dwInboundRootArraySize; i++) {
        dwError = ValidateCertRootConfig(&pCertInfo->pInboundRootArray[i]);
        BAIL_ON_WIN32_ERROR(dwError);

        // Outbound root array MUST be idential to inbound
        dwError = CompareCertRootConfig(&pCertInfo->pInboundRootArray[i],
                     &pCertInfo->pOutboundRootArray[i]);
        BAIL_ON_WIN32_ERROR(dwError);
    }

    
error:

    return (dwError);
}

DWORD
ValidateMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;
    DWORD dwNumAuthInfos = 0;
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    BOOL bSSPI = FALSE;
    BOOL bPresharedKey = FALSE;
    BOOL bRSASig= FALSE;


    if (!pMMAuthMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumAuthInfos = pMMAuthMethods->dwNumAuthInfos;
    pAuthenticationInfo = pMMAuthMethods->pAuthenticationInfo;

    if (!dwNumAuthInfos || !pAuthenticationInfo) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Need to catch the exception when the number of auth infos
    // specified is more than the actual number of auth infos.
    //


    pTemp = pAuthenticationInfo;

    for (i = 0; i < dwNumAuthInfos; i++) {

        if ((pTemp->AuthMethod != IKE_PRESHARED_KEY) &&
            (pTemp->AuthMethod != IKE_RSA_SIGNATURE) &&
            (pTemp->AuthMethod != IKE_SSPI)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pTemp->AuthMethod == IKE_RSA_SIGNATURE) {
            dwError = ValidateCertAuthInfo(&pTemp->CertAuthInfo);
            BAIL_ON_WIN32_ERROR(dwError);
            if (bRSASig) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bRSASig = TRUE;
        }

        if (pTemp->AuthMethod == IKE_SSPI) {
            if (bSSPI) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bSSPI = TRUE;
        }

        if (pTemp->AuthMethod == IKE_PRESHARED_KEY) {
            if (!(pTemp->GeneralAuthInfo.dwAuthInfoSize) || 
                !(pTemp->GeneralAuthInfo.pAuthInfo)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            if (bPresharedKey) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bPresharedKey = TRUE;
        }

        pTemp++;

    }

error:

    return (dwError);
}

DWORD
ValidateQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;


    if (!pQMPolicy) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicy->pszPolicyName) || !(*(pQMPolicy->pszPolicyName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateQMOffers(
                  pQMPolicy->dwOfferCount,
                  pQMPolicy->pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
ValidateQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    DWORD dwError = 0;

    if (!dwOfferCount || !pOffers || (dwOfferCount > IPSEC_MAX_QM_OFFERS)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}


DWORD
ValidateMMFilter(
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function validates an external generic MM filter.

Arguments:

    pMMFilter - Filter to validate.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pMMFilter->SrcAddr), TRUE , FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pMMFilter->DesAddr), TRUE , TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = HtoNAddressesConflict(
                     pMMFilter->SrcAddr,
                     pMMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilter->pszFilterName) || !(*(pMMFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateInterfaceType(pMMFilter->InterfaceType);
    BAIL_ON_WIN32_ERROR(dwError);

    if (pMMFilter->dwFlags &&
        !(pMMFilter->dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY) &&
        !(pMMFilter->dwFlags & IPSEC_MM_AUTH_DEFAULT_AUTH)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ApplyMulticastFilterValidation(
                  pMMFilter->DesAddr,
                  pMMFilter->bCreateMirror
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
VerifyAddresses(
    PADDR pAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    )
{
    DWORD   dwError = 0;
    BOOL    bIsValid = FALSE;

    switch (pAddr->AddrType) {

    case IP_ADDR_UNIQUE:
        bIsValid = bIsValidIPAddress(
                       ntohl(pAddr->uIpAddr),
                       bAcceptMe,
                       bIsDesAddr
                       );
        if (!bIsValid) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        if (pAddr->pgInterfaceID) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    case IP_ADDR_SUBNET:
        dwError = VerifySubNetAddress(
                      ntohl(pAddr->uIpAddr),
                      ntohl(pAddr->uSubNetMask),
                      bIsDesAddr
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        if (pAddr->pgInterfaceID) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    case IP_ADDR_INTERFACE:
        if (pAddr->uIpAddr) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        if (!(pAddr->pgInterfaceID)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
    default:
        if (!IsSpecialServ(pAddr->AddrType)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
    }

error:

    return (dwError);
}


DWORD
VerifySubNetAddress(
    ULONG uSubNetAddr,
    ULONG uSubNetMask,
    BOOL bIsDesAddr
    )
{
    DWORD dwError = 0;
    BOOL  bIsValid = FALSE;

    if (uSubNetAddr == SUBNET_ADDRESS_ANY) {
        if (uSubNetMask != SUBNET_MASK_ANY) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        bIsValid = bIsValidSubnet(
                       uSubNetAddr,
                       uSubNetMask,
                       bIsDesAddr
                       );
        if (!bIsValid) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
bIsValidIPMask(
    ULONG uMask
    )
{
	BOOL bValidMask = FALSE;
	ULONG uTestMask = 0;

	//
	// Mask must be contiguous bits.
	//

	for (uTestMask = 0xFFFFFFFF; uTestMask; uTestMask <<= 1) {
		if (uTestMask == uMask) {
			bValidMask = TRUE;
			break;
		}
	}

	return (bValidMask);
}


BOOL
bIsValidIPAddress(
    ULONG uIpAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    )
{
    ULONG uHostMask = IN_CLASSA_HOST;   // Default host mask.


    //
    // Accept the address if its "me".
    //

    if (bAcceptMe) {
        if (uIpAddr == IP_ADDRESS_ME) {
            return TRUE;
        }
    }

    //
    // Reject if its a multicast address and is not the 
    // destination address.
    //

    if (IN_CLASSD(uIpAddr)) {
        if (bIsDesAddr) {
            return TRUE;
        }
        else {
            return FALSE;
        }
    }

    //
    // Reject if its a Class E address.
    //

    if (IN_CLASSE(uIpAddr)) {
        return FALSE;
    }

    //
    // Reject if the first octet is zero.
    //

    if (!(IN_CLASSA_NET & uIpAddr)) {
        return FALSE;
    }

    //
    // Use default mask based on Class when none is provided.
    //

    if (IN_CLASSA(uIpAddr)) {
        uHostMask = IN_CLASSA_HOST;
    }
    else if (IN_CLASSB(uIpAddr)) {
        uHostMask = IN_CLASSB_HOST;
    }
    else if (IN_CLASSC(uIpAddr)) {
        uHostMask = IN_CLASSC_HOST;
    }

    //
    // Accept address when host portion is non-zero.
    //

    if (uHostMask & uIpAddr) {
        return TRUE;
    }

    return FALSE;
}


BOOL
bIsValidSubnet(
    ULONG uIpAddr,
    ULONG uMask,
    BOOL bIsDesAddr
    )
{
    ULONG uHostMask = 0;


    //
    // Reject if its a multicast address and is not the 
    // destination address.
    //

    if (IN_CLASSD(uIpAddr)) {
        if (!bIsDesAddr) {
            return FALSE;
        }
    }

    //
    // Reject if its a Class E address.
    //

    if (IN_CLASSE(uIpAddr)) {
        return FALSE;
    }

    //
    // Reject if the first octet is zero.
    //

    if (!(IN_CLASSA_NET & uIpAddr)) {
        return FALSE;
    }

    //
    // If the mask is invalid then return.
    //

    if (!bIsValidIPMask(uMask)) {
        return FALSE;
    }

    //
    // Use the provided subnet mask to generate the host mask.
    //

    uHostMask = 0xFFFFFFFF ^ uMask;

    //
    // Accept address only when the host portion is zero, network
    // portion is non-zero and first octet is non-zero.
    //

    if (!(uHostMask & uIpAddr) &&
        (uMask & uIpAddr) &&
        (IN_CLASSA_NET & uIpAddr)) {
        return TRUE;
    }

    return FALSE;
}


// AddressesConflict requires addresses in network byte order.
//
BOOL
AddressesConflict(
    ADDR    SrcAddr,
    ADDR    DesAddr
    )
{
	if ((SrcAddr.AddrType == IP_ADDR_UNIQUE) &&
		(DesAddr.AddrType == IP_ADDR_UNIQUE) &&
		(SrcAddr.uIpAddr == DesAddr.uIpAddr))
	{
		return (TRUE);
	}

	if ((SrcAddr.AddrType == IP_ADDR_INTERFACE) &&
		(DesAddr.AddrType == IP_ADDR_INTERFACE))
	{
		return (TRUE);
	}

	if (IsSpecialServer(&SrcAddr) &&
		(SrcAddr.AddrType == DesAddr.AddrType))
	{
		return (TRUE);
	}

	if (IsMulticastAddress(&SrcAddr) || IsBroadcastAddress(&SrcAddr))
	{
		return (TRUE);
	}

	return (FALSE);
}


// Special version of AddressesConflict for Winipsec.dll functions that requires 
// addresses in Host order. This fix was made for bug# 708188
// "IPSec validation functions must convert from host to network order before validation"
// for RC2 and given test and dev resources was the safest and quickest fix.

BOOL
HtoNAddressesConflict(
    ADDR    SrcAddr,
    ADDR    DesAddr
    )
{
	SrcAddr.uIpAddr=htonl(SrcAddr.uIpAddr);
	SrcAddr.uSubNetMask=htonl(SrcAddr.uSubNetMask);

	DesAddr.uIpAddr=htonl(DesAddr.uIpAddr);
	DesAddr.uSubNetMask=htonl(DesAddr.uSubNetMask);

   return AddressesConflict(SrcAddr, DesAddr);
}


DWORD
ValidateTransportFilter(
    PTRANSPORT_FILTER pTransportFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTransportFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pTransportFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTransportFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = HtoNAddressesConflict(
                     pTransportFilter->SrcAddr,
                     pTransportFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pTransportFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTransportFilter->SrcPort,
                  pTransportFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTransportFilter->DesPort,
                  pTransportFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!(pTransportFilter->pszFilterName) || !(*(pTransportFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateInterfaceType(pTransportFilter->InterfaceType);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateFilterAction(pTransportFilter->InboundFilterAction);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateFilterAction(pTransportFilter->OutboundFilterAction);
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTransportFilter->dwFlags &&
        !(pTransportFilter->dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ApplyMulticastFilterValidation(
                  pTransportFilter->DesAddr,
                  pTransportFilter->bCreateMirror
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}

DWORD
ValidateIPSecQMFilter(
    PIPSEC_QM_FILTER pQMFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;

    if (!pQMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pQMFilter->SrcAddr), FALSE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pQMFilter->DesAddr), FALSE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = HtoNAddressesConflict(
                     pQMFilter->SrcAddr,
                     pQMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pQMFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pQMFilter->SrcPort,
                  pQMFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pQMFilter->DesPort,
                  pQMFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    if (pQMFilter->QMFilterType == QM_TUNNEL_FILTER) {

        if (pQMFilter->MyTunnelEndpt.AddrType != IP_ADDR_UNIQUE) {
            dwError=ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        if (pQMFilter->PeerTunnelEndpt.AddrType != IP_ADDR_UNIQUE) {
            dwError=ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        dwError = VerifyAddresses(&(pQMFilter->MyTunnelEndpt), FALSE, FALSE);
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = VerifyAddresses(&(pQMFilter->PeerTunnelEndpt), FALSE, FALSE);
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        dwError = ValidateAddr(&(pQMFilter->MyTunnelEndpt));
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = ValidateAddr(&(pQMFilter->PeerTunnelEndpt));
        BAIL_ON_WIN32_ERROR(dwError);

    }

    if (pQMFilter->QMFilterType != QM_TUNNEL_FILTER &&
        pQMFilter->QMFilterType != QM_TRANSPORT_FILTER) {
        dwError=ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}

DWORD
VerifyProtocols(
    PROTOCOL Protocol
    )
{
    DWORD dwError = 0;

    switch (Protocol.ProtocolType) {

    case PROTOCOL_UNIQUE:
        if (Protocol.dwProtocol > 255) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


DWORD
VerifyPortsForProtocol(
    PORT Port,
    PROTOCOL Protocol
    )
{
    DWORD dwError = 0;

    switch (Port.PortType) {

    case PORT_UNIQUE:

        if (Port.wPort < 0) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        switch (Protocol.ProtocolType) {

        case PROTOCOL_UNIQUE:
            if ((Protocol.dwProtocol != IPPROTO_TCP) &&
                (Protocol.dwProtocol != IPPROTO_UDP)) {
                if (Port.wPort != 0) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
            }
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
            break;

        }

        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


DWORD
ValidateMMFilterTemplate(
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pMMFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pMMFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = HtoNAddressesConflict(
                     pMMFilter->SrcAddr,
                     pMMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->dwDirection) {
        if ((pMMFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pMMFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


DWORD
ValidateTxFilterTemplate(
    PTRANSPORT_FILTER pTxFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTxFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pTxFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTxFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = HtoNAddressesConflict(
                     pTxFilter->SrcAddr,
                     pTxFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pTxFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTxFilter->SrcPort,
                  pTxFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTxFilter->DesPort,
                  pTxFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTxFilter->dwDirection) {
        if ((pTxFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pTxFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


DWORD
ValidateTunnelFilter(
    PTUNNEL_FILTER pTunnelFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTunnelFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pTunnelFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTunnelFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = HtoNAddressesConflict(
                     pTunnelFilter->SrcAddr,
                     pTunnelFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateAddr(&(pTunnelFilter->SrcTunnelAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTunnelFilter->DesTunnelAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyProtocols(pTunnelFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTunnelFilter->SrcPort,
                  pTunnelFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTunnelFilter->DesPort,
                  pTunnelFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!(pTunnelFilter->pszFilterName) || !(*(pTunnelFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateInterfaceType(pTunnelFilter->InterfaceType);
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTunnelFilter->bCreateMirror) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateFilterAction(pTunnelFilter->InboundFilterAction);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateFilterAction(pTunnelFilter->OutboundFilterAction);
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTunnelFilter->dwFlags &&
        !(pTunnelFilter->dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // No need to call ApplyMulticastFilterValidation as bCreateMirror
    // is always false for a tunnel filter.
    //

error:

    return (dwError);
}


DWORD
ValidateTnFilterTemplate(
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pTnFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTnFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = HtoNAddressesConflict(
                     pTnFilter->SrcAddr,
                     pTnFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateAddr(&(pTnFilter->SrcTunnelAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTnFilter->DesTunnelAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyProtocols(pTnFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->SrcPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->DesPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTnFilter->dwDirection) {
        if ((pTnFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pTnFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


DWORD
ApplyMulticastFilterValidation(
    ADDR Addr,
    BOOL bCreateMirror
    )
{
    DWORD dwError = 0;


    if (((Addr.AddrType == IP_ADDR_UNIQUE) ||
        (Addr.AddrType == IP_ADDR_SUBNET)) &&
        (IN_CLASSD(ntohl(Addr.uIpAddr))) &&
        bCreateMirror) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}


DWORD
ValidateQMFilterAddresses(
    PIPSEC_QM_FILTER pIpsecQMFilter
    )
{
    DWORD dwError = 0;


    dwError = ValidateAddr(&(pIpsecQMFilter->SrcAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pIpsecQMFilter->DesAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pIpsecQMFilter->MyTunnelEndpt));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pIpsecQMFilter->PeerTunnelEndpt));
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\dynamicadd.h ===
////////////////////////////////////////////////////////////////////////
//
// 	Module: Dynamic/DynamicAdd.h
//
// 	Purpose			: Dynamic add and set commands for IPSec
//
//
// 	Developers Name	: Bharat/Radhika
//
//	History			:
//
//  Date			Author		Comments
//  10-8-2001   	Bharat		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#ifndef _DYNAMICADD_H_
#define _DYNAMICADD_H_

#define NAME_PREFIX			_TEXT("IPSec") 				//Prefix to the all created names

DWORD
AddMainModePolicy(
	IN LPTSTR pPolicyName,
	IN IPSEC_MM_POLICY& ParserMMPol
	);

DWORD
SetMainModePolicy(
	IN LPTSTR pPolicyName,
	IN IPSEC_MM_POLICY& ParserMMPol
	);

DWORD
LoadMMOffersDefaults(
	IN OUT IPSEC_MM_POLICY & MMPolicy
	);

DWORD
AddQuickModePolicy(
	IN LPTSTR pPolicyName,
	IN BOOL bDefault,
	IN BOOL bSoft,
	IN IPSEC_QM_POLICY& QMPol
	);

DWORD
SetQuickModePolicy(
	IN LPTSTR pPolicyName,
	IN PIPSEC_QM_POLICY pQMPol
	);

DWORD
AddQuickModeFilter(
	IN LPTSTR pFilterName,
	IN LPTSTR pPolicyName,
	IN TUNNEL_FILTER& ParserTunnelFltr
	);

DWORD
AddQuickModeFilter(
	IN LPTSTR pFilterName,
	IN LPTSTR pPolicyName,
	IN TRANSPORT_FILTER& ParserTrpFltr
	);

DWORD
SetQuickModeTransportFilter(
	IN LPTSTR pFilterName,
	IN LPTSTR pNewFilterName,
	IN LPTSTR pPolicyName,
	IN LPTSTR pMMFilterName,
	IN FILTER_ACTION Inbound,
	IN FILTER_ACTION Outbound
	);

DWORD
SetTransportRule(
	IN TRANSPORT_FILTER& TrpFltr,
	IN LPTSTR pFilterActionName,
	IN FILTER_ACTION Inbound,
	IN FILTER_ACTION Outbound
	);

DWORD
SetQuickModeTunnelFilter(
	IN LPTSTR pFilterName,
	IN LPTSTR pNewFilterName,
	IN LPTSTR pPolicyName,
	IN LPTSTR pMMFilterName,
	IN FILTER_ACTION Inbound,
	IN FILTER_ACTION Outbound
	);

DWORD
SetTunnelRule(
	IN TUNNEL_FILTER& TunnelFltr,
	IN LPTSTR pFilterActionName,
	IN FILTER_ACTION Inbound,
	IN FILTER_ACTION Outbound
	);

BOOL
FindAndGetMMFilterRule(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE dwConType,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	OUT PMM_FILTER *pMMFilterRule,
	OUT DWORD& dwReturn
	);
BOOL
FindAndGetTransportRule(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN DWORD dwProtocol,
	IN DWORD dwSrcPort,
	IN DWORD dwDstPort,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	OUT PTRANSPORT_FILTER *pQMFilterRule,
	OUT DWORD& dwReturn
	);

BOOL
FindAndGetTunnelRule(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN DWORD dwProtocol,
	IN DWORD dwSrcPort,
	IN DWORD dwDstPort,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN ADDR SrcTunnel,
	IN ADDR DstTunnel,
	OUT PTUNNEL_FILTER *pQMFilterRule,
	OUT DWORD& dwReturn
	);

DWORD
AddMainModeFilter(
	IN LPTSTR pFilterName,
	IN LPTSTR pPolicyName,
	IN MM_FILTER& ParserMMFilter,
	IN STA_AUTH_METHODS& ParserAuthMethod
	);

DWORD
SetDynamicMMFilter(
	IN LPTSTR pszFilterName,
	IN LPTSTR pszNewFilterName,
	IN LPTSTR pszPolicyName,
	IN MM_FILTER& ParserMMFilter,
	IN INT_MM_AUTH_METHODS& MMAuthMethod
	);

DWORD
SetDynamicMMFilterRule(
	IN LPTSTR pszPolicyName,
	IN MM_FILTER& ParserMMFilter,
	IN STA_AUTH_METHODS& MMAuthMethod
	);

DWORD
LoadMMFilterDefaults(
	IN OUT MM_FILTER& MMFilter
	);

DWORD
AddAuthMethods(
	IN OUT STA_AUTH_METHODS& ParserAuthMethod
	);


DWORD
DynamicDecodeCertificateName(
	IN BYTE *EncodedName,
	IN DWORD EncodedNameLength,
	IN OUT LPTSTR *ppszSubjectName
	);

DWORD
ConnectDynamicMachine(
	IN  LPCWSTR  pwszMachine
	);
DWORD
CreateName(
	IN LPTSTR * ppszQMFilterName
	);

BOOL
IsLastRuleOfMMFilter(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN OUT DWORD& dwStatus
	);
	
DWORD
FloorCountTransportRuleOfMMFilter(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN OUT DWORD& dwStatus
	);

DWORD
FloorCountTunnelRuleOfMMFilter(
	IN ADDR SrcTunnel,
	IN ADDR DstTunnel,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	OUT DWORD& dwStatus
	);

#endif //_DYNAMICADD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\dynamic.cpp ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: Dynamic/Dynamic.cpp
//
// 	Purpose			: Dynamic Module Implementation.
//
//
// 	Developers Name	: Bharat/Radhika
//
//  Description     : All functions are netshell dynamic context interface and
//					  calls appropriate functions.
//
//	History			:
//
//  Date			Author		Comments
//  8-10-2001   	Bharat		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"
#include "nshcertmgmt.h"

extern HINSTANCE g_hModule;
extern HKEY g_hGlobalRegistryKey;
extern _TCHAR* g_szDynamicMachine;
extern STORAGELOCATION g_StorageLocation;

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicAddQMPolicy
//
//	Date of Creation: 9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		: Netshell Dynamic handle for add quick mode policy.
//
//	Revision History:
//
//  Date			Author		Comments
//  8-10-2001   	Bharat		Initial Version. V1.0
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicAddQMPolicy(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	IPSEC_QM_POLICY   QMPol;

	LPTSTR pszPolicyName = NULL;
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwPFSGr = 0;
	DWORD dwNameLen = 0;
	DWORD dwCount = 0, j=0;
	BOOL bSoft=FALSE, bDefault=FALSE,  bQmpfs=FALSE;

	const TAG_TYPE vcmdDynamicAddQMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_PRESENT,		FALSE },
		{ CMD_TOKEN_STR_SOFT,			NS_REQ_ZERO,		FALSE },
		{ CMD_TOKEN_STR_PFSGROUP, 		NS_REQ_ZERO,		FALSE },
		{ CMD_TOKEN_STR_DEFRESPONSE,	NS_REQ_ZERO,  		FALSE },
		{ CMD_TOKEN_STR_NEGOTIATION,	NS_REQ_ZERO,	  	FALSE }
	};

	const TOKEN_VALUE vtokDynamicAddQMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 			},
		{ CMD_TOKEN_STR_SOFT,			CMD_TOKEN_SOFT			},
		{ CMD_TOKEN_STR_PFSGROUP, 		CMD_TOKEN_PFSGROUP		},
		{ CMD_TOKEN_STR_DEFRESPONSE,	CMD_TOKEN_DEFRESPONSE	},
		{ CMD_TOKEN_STR_NEGOTIATION,	CMD_TOKEN_NEGOTIATION	}
	};


	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	memset(&QMPol, 0, sizeof(IPSEC_QM_POLICY));
	QMPol.pOffers = NULL;
	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	parser.ValidTok   = vtokDynamicAddQMPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicAddQMPolicy);

	parser.ValidCmd   = vcmdDynamicAddQMPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicAddQMPolicy);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicAddQMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					//allocate memory for  QMPolicy name
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pszPolicyName = new _TCHAR[dwNameLen];
					if(pszPolicyName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pszPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			case CMD_TOKEN_SOFT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bSoft = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_DEFRESPONSE	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bDefault = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_PFSGROUP		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					//
					// Make the pfs required flag true.Since only group is accepted from the user.
					//
					bQmpfs = TRUE;
					dwPFSGr = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_NEGOTIATION	:
				IPSEC_QM_OFFER *SecMethod;
				if (parser.Cmd[dwCount].dwStatus != 0)
				{
					if(QMPol.pOffers)
					{
						//
						// Default loads deleted
						//
						delete [] QMPol.pOffers;
						QMPol.pOffers = NULL;
					}
					QMPol.dwOfferCount = parser.Cmd[dwCount].dwStatus;
					QMPol.pOffers = new IPSEC_QM_OFFER[QMPol.dwOfferCount];
					if(QMPol.pOffers == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					for(j=0;j<QMPol.dwOfferCount;j++)
					{
						//
						// Copy the QM offers given by the user or defaults provided by parser
						//
						SecMethod = ((IPSEC_QM_OFFER **)parser.Cmd[dwCount].pArg)[j];
						memcpy(&(QMPol.pOffers[j]), SecMethod, sizeof(IPSEC_QM_OFFER));
					}
				}
				break;
			default						:
				break;
		}
	}

	for(j=0;j<QMPol.dwOfferCount;j++)
	{
		// Check for the user given pfsgroup
		if(bQmpfs)
		{
			switch(dwPFSGr)
			{
				case 0:
					QMPol.pOffers[j].dwPFSGroup = 0;
					QMPol.pOffers[j].bPFSRequired = FALSE;
					break;
				case 1:
					QMPol.pOffers[j].dwPFSGroup = PFS_GROUP_1;
					QMPol.pOffers[j].bPFSRequired = TRUE;
					break;
				case 2:
					QMPol.pOffers[j].dwPFSGroup = PFS_GROUP_2;
					QMPol.pOffers[j].bPFSRequired = TRUE;
					break;
				case 3:
					QMPol.pOffers[j].dwPFSGroup = PFS_GROUP_2048;
					QMPol.pOffers[j].bPFSRequired = TRUE;
					break;
				case 4:
					QMPol.pOffers[j].dwPFSGroup = PFS_GROUP_MM;
					QMPol.pOffers[j].bPFSRequired = TRUE;
					break;
				default:
					break;
			}
		}
		else
		{
			QMPol.pOffers[j].dwPFSGroup = dwPFSGr;
			QMPol.pOffers[j].bPFSRequired = bQmpfs;
		}
	}
	//
	// Add the quick mode policy to SPD.
	//
	dwReturn = AddQuickModePolicy( pszPolicyName, bDefault, bSoft, QMPol);

error:
	//clean up heap used...
	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if(pszPolicyName)
	{
		delete [] pszPolicyName;
	}
	if(QMPol.pOffers)
	{
		if(QMPol.dwOfferCount)
		{
			delete [] (QMPol.pOffers);
		}
		else
		{
			delete QMPol.pOffers;
		}
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE) &&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicSetQMPolicy
//
//	Date of Creation: 9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  Netshell Dynamic handle for set quick mode policy
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicSetQMPolicy(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{

	LPTSTR pszPolicyName = NULL;
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwNameLen = 0;
	DWORD dwCount = 0, j=0;
	DWORD dwPFSGr = 0;
	DWORD dwOldPFSGr = 0;
	DWORD dwVersion = 0;
	BOOL bQmpfs = FALSE, bOldQmpfs = FALSE;
	PIPSEC_QM_POLICY   pOldQMPol = NULL;
	PIPSEC_QM_POLICY   pQMPol = NULL;
	const TAG_TYPE vcmdDynamicSetQMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_PRESENT,		FALSE },
		{ CMD_TOKEN_STR_SOFT,			NS_REQ_ZERO,		FALSE },
		{ CMD_TOKEN_STR_PFSGROUP, 		NS_REQ_ZERO,		FALSE },
		{ CMD_TOKEN_STR_DEFRESPONSE,	NS_REQ_ZERO,  		FALSE },
		{ CMD_TOKEN_STR_NEGOTIATION,	NS_REQ_ZERO,	  	FALSE }
	};

	const TOKEN_VALUE vtokDynamicSetQMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 			},
		{ CMD_TOKEN_STR_SOFT,			CMD_TOKEN_SOFT			},
		{ CMD_TOKEN_STR_PFSGROUP,	 	CMD_TOKEN_PFSGROUP		},
		{ CMD_TOKEN_STR_DEFRESPONSE,	CMD_TOKEN_DEFRESPONSE	},
		{ CMD_TOKEN_STR_NEGOTIATION,	CMD_TOKEN_NEGOTIATION	}
	};
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}
	parser.ValidTok   = vtokDynamicSetQMPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicSetQMPolicy);

	parser.ValidCmd   = vcmdDynamicSetQMPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicSetQMPolicy);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicSetQMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{

			case CMD_TOKEN_NAME			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pszPolicyName = new _TCHAR[dwNameLen];
					if(pszPolicyName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pszPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
		}
	}
	//
	// Get the user given QMpolicy from SPD
	//
	dwReturn = GetQMPolicy(g_szDynamicMachine, dwVersion, pszPolicyName, 0, &pOldQMPol, NULL);

	if((dwReturn != ERROR_SUCCESS) || !pOldQMPol)
	{
		BAIL_OUT;
	}

	pQMPol = new IPSEC_QM_POLICY;
	if(pQMPol == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	//
	// Copy old record into the local pointer
	//
	memcpy(pQMPol, pOldQMPol, sizeof(IPSEC_QM_POLICY));

	dwNameLen = _tcslen(pOldQMPol->pszPolicyName) + 1;

	pQMPol->pszPolicyName = new _TCHAR[dwNameLen];
	if(pQMPol->pszPolicyName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	_tcsncpy(pQMPol->pszPolicyName, pOldQMPol->pszPolicyName, dwNameLen);

	//
	// Copy old qmoffer
	//
	pQMPol->pOffers = new IPSEC_QM_OFFER[pQMPol->dwOfferCount];
	if(pQMPol->pOffers == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	for(j=0; j<pQMPol->dwOfferCount; j++)
	{
		memcpy(&(pQMPol->pOffers[j]), &(pOldQMPol->pOffers[j]), sizeof(IPSEC_QM_OFFER));
	}

	SPDApiBufferFree(pOldQMPol);
	pOldQMPol = NULL;

	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicSetQMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_SOFT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					//
					// Set the soft flag
					//
					if(*(BOOL *)parser.Cmd[dwCount].pArg)
					{
						pQMPol->dwFlags |= IPSEC_QM_POLICY_ALLOW_SOFT;
					}
					else
					{
						pQMPol->dwFlags &= ~IPSEC_QM_POLICY_ALLOW_SOFT;
					}
				}
				break;
			case CMD_TOKEN_DEFRESPONSE	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					//
					// Set the default_rule flag.
					//
					if(*(BOOL *)parser.Cmd[dwCount].pArg)
					{
						pQMPol->dwFlags |= IPSEC_MM_POLICY_DEFAULT_POLICY;
					}
					else
					{
						pQMPol->dwFlags &= ~IPSEC_MM_POLICY_DEFAULT_POLICY;
					}
				}
				break;
			case CMD_TOKEN_PFSGROUP		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					//
					// Check if pfsgroup is given, as pfs required parameter also needs to be set.
					//
					bQmpfs = TRUE;
					dwPFSGr = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_NEGOTIATION	:
				IPSEC_QM_OFFER *SecMethod;
				if (parser.Cmd[dwCount].dwStatus > 0)
				{
					if((pQMPol->pOffers)&&(pQMPol->dwOfferCount))
					{
						dwOldPFSGr = pQMPol->pOffers[0].dwPFSGroup;
						bOldQmpfs = pQMPol->pOffers[0].bPFSRequired;
						if(pQMPol->dwOfferCount)
						{
							delete [] pQMPol->pOffers;
						}
						else
						{
							delete pQMPol->pOffers;
						}
					}
					pQMPol->dwOfferCount = parser.Cmd[dwCount].dwStatus;
					pQMPol->pOffers = new IPSEC_QM_OFFER[pQMPol->dwOfferCount];
					if(pQMPol->pOffers == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}

					//
					// Copy user given offer.
					//
					for(j=0;j<pQMPol->dwOfferCount;j++)
					{
						SecMethod = ((IPSEC_QM_OFFER **)parser.Cmd[dwCount].pArg)[j];
						if(SecMethod->dwNumAlgos > 0)
						{
							pQMPol->pOffers[j].dwNumAlgos = SecMethod->dwNumAlgos;
							memcpy(&(pQMPol->pOffers[j].Algos), &(SecMethod->Algos), sizeof(IPSEC_QM_ALGO[QM_MAX_ALGOS]));
						}
						pQMPol->pOffers[j].Lifetime.uKeyExpirationKBytes = SecMethod->Lifetime.uKeyExpirationKBytes;
						pQMPol->pOffers[j].Lifetime.uKeyExpirationTime = SecMethod->Lifetime.uKeyExpirationTime;
						pQMPol->pOffers[j].bPFSRequired = bOldQmpfs;
						pQMPol->pOffers[j].dwPFSGroup = dwOldPFSGr;
					}
				}
				break;
			default						:
				break;
		}
	}

	//
	// If only pfs group is given without the qm offer then copy it separately.
	//
	for(j=0;j<pQMPol->dwOfferCount;j++)
	{
		if(bQmpfs)
		{
			pQMPol->pOffers[j].bPFSRequired = bQmpfs;
			switch(dwPFSGr)
			{
				case 0:
					pQMPol->pOffers[j].dwPFSGroup = 0;
					pQMPol->pOffers[j].bPFSRequired = FALSE;
					break;
				case 1:
					pQMPol->pOffers[j].dwPFSGroup = PFS_GROUP_1;
					pQMPol->pOffers[j].bPFSRequired = TRUE;
					break;
				case 2:
					pQMPol->pOffers[j].dwPFSGroup = PFS_GROUP_2;
					pQMPol->pOffers[j].bPFSRequired = TRUE;
					break;
				case 3:
					pQMPol->pOffers[j].dwPFSGroup = PFS_GROUP_2048;
					pQMPol->pOffers[j].bPFSRequired = TRUE;
					break;
				case 4:
					pQMPol->pOffers[j].dwPFSGroup = PFS_GROUP_MM;
					pQMPol->pOffers[j].bPFSRequired = TRUE;
					break;
			}
		}
	}
	//
	// Set the quick mode policy
	//
	dwReturn = SetQuickModePolicy( pszPolicyName, pQMPol);

error:

	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if(pszPolicyName)
	{
		delete [] pszPolicyName;
	}
	//
	// error clean up path.
	//
	if((pQMPol) && (pQMPol->pOffers))
	{
		if(pQMPol->dwOfferCount)
		{
			delete [] pQMPol->pOffers;
		}
		else
		{
			delete pQMPol->pOffers;
		}
	}
	if((pQMPol) && (pQMPol->pszPolicyName))
	{
		delete [] pQMPol->pszPolicyName;
	}

	if(pOldQMPol)
	{
		SPDApiBufferFree(pOldQMPol);
		pOldQMPol = NULL;
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE) &&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicAddMMPolicy
//
//	Date of Creation: 9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  	Netshell Dynamic handle for add main mode policy
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicAddMMPolicy(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwNameLen = 0;
	DWORD dwCount = 0;
	IPSEC_MM_POLICY   MMPol;
	LPTSTR pszPolicyName = NULL;

	DWORD dwQmperMM = 0;
	DWORD dwKbLife = 0;
	DWORD dwSecLife = POTF_DEFAULT_P1REKEY_TIME, j=0;
	const TAG_TYPE vcmdDynamicAddMMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_PRESENT,	  	FALSE	},
		{ CMD_TOKEN_STR_QMPERMM,		NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_MMLIFETIME, 	NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_SOFTSAEXPTIME,	NS_REQ_ZERO,	  	FALSE 	},
		{ CMD_TOKEN_STR_DEFRESPONSE,	NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_MMSECMETHODS,	NS_REQ_ZERO,	  	FALSE	}
	};
	const TOKEN_VALUE vtokDynamicAddMMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 				},
		{ CMD_TOKEN_STR_QMPERMM,		CMD_TOKEN_QMPERMM			},
		{ CMD_TOKEN_STR_MMLIFETIME,	CMD_TOKEN_MMLIFETIME			},
		{ CMD_TOKEN_STR_SOFTSAEXPTIME,	CMD_TOKEN_SOFTSAEXPTIME	 	},
		{ CMD_TOKEN_STR_DEFRESPONSE,	CMD_TOKEN_DEFRESPONSE		},
		{ CMD_TOKEN_STR_MMSECMETHODS,	CMD_TOKEN_MMSECMETHODS		}
	};
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	memset(&MMPol, 0, sizeof(IPSEC_MM_POLICY));
	MMPol.uSoftExpirationTime = POTF_DEF_P1SOFT_TIME;
	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}
	parser.ValidTok   = vtokDynamicAddMMPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicAddMMPolicy);

	parser.ValidCmd   = vcmdDynamicAddMMPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicAddMMPolicy);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicAddMMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME				:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pszPolicyName = new _TCHAR[dwNameLen];
					if(pszPolicyName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pszPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			case CMD_TOKEN_DEFRESPONSE		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if(*(BOOL *)parser.Cmd[dwCount].pArg)
					{
						MMPol.dwFlags |= IPSEC_MM_POLICY_DEFAULT_POLICY;
					}
				}
				break;
			case CMD_TOKEN_MMLIFETIME		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwSecLife = ((*(DWORD *)parser.Cmd[dwCount].pArg ) * 60);
				}
				break;
			case CMD_TOKEN_QMPERMM			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwQmperMM = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_SOFTSAEXPTIME	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					MMPol.uSoftExpirationTime = ((*(DWORD *)parser.Cmd[dwCount].pArg) * 60);
				}
				break;
			case CMD_TOKEN_MMSECMETHODS		:
				IPSEC_MM_OFFER *SecMethod;
				if (parser.Cmd[dwCount].dwStatus != 0)
				{
					MMPol.dwOfferCount = parser.Cmd[dwCount].dwStatus;
					MMPol.pOffers = new IPSEC_MM_OFFER[MMPol.dwOfferCount];
					if(MMPol.pOffers == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					//
					// Copy security methods.
					//
					for(j=0;j<MMPol.dwOfferCount;j++)
					{
						SecMethod = ((IPSEC_MM_OFFER **)parser.Cmd[dwCount].pArg)[j];
						memcpy(&(MMPol.pOffers[j]), SecMethod, sizeof(IPSEC_MM_OFFER));
					}
				}
				break;
			default							:
				break;
		}
	}

	for(j=0;j<MMPol.dwOfferCount;j++)
	{
		MMPol.pOffers[j].dwQuickModeLimit = dwQmperMM;
		MMPol.pOffers[j].Lifetime.uKeyExpirationKBytes = dwKbLife;
		MMPol.pOffers[j].Lifetime.uKeyExpirationTime = dwSecLife;
	}

	dwReturn = AddMainModePolicy( pszPolicyName, MMPol);
error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}
	//
	// Error cleanup path
	//
	if(pszPolicyName)
	{
		delete [] pszPolicyName;
	}
	if(MMPol.pOffers)
	{
		if(MMPol.dwOfferCount > 1)
		{
			delete [] (MMPol.pOffers);
		}
		else
		{
			delete MMPol.pOffers;
		}
	}
	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicSetMMPolicy
//
//	Date of Creation: 9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  Netshell Dynamic handle for set main mode policy
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicSetMMPolicy(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwCount = 0, j=0;
	DWORD dwNameLen = 0;
	LPTSTR pszPolicyName = NULL;
	IPSEC_MM_POLICY MMPol;
	PIPSEC_MM_POLICY pMMPol = NULL;

	BOOL bSeclife = FALSE, bQmpermm = FALSE;

	DWORD dwQmperMM = 0;
	DWORD dwSecLife = POTF_DEFAULT_P1REKEY_TIME;

	DWORD dwOldQmperMM = 0;
	DWORD dwOldKbLife = 0;
	DWORD dwOldSecLife = 0;
	DWORD dwVersion = 0;

	const TAG_TYPE vcmdDynamicSetMMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_PRESENT,	  	FALSE	},
		{ CMD_TOKEN_STR_QMPERMM,		NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_MMLIFETIME, 	NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_SOFTSAEXPTIME,	NS_REQ_ZERO,	  	FALSE 	},
		{ CMD_TOKEN_STR_DEFRESPONSE,	NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_MMSECMETHODS,	NS_REQ_ZERO,	  	FALSE	}
	};
	const TOKEN_VALUE vtokDynamicSetMMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 				},
		{ CMD_TOKEN_STR_QMPERMM,		CMD_TOKEN_QMPERMM			},
		{ CMD_TOKEN_STR_MMLIFETIME,	    CMD_TOKEN_MMLIFETIME		},
		{ CMD_TOKEN_STR_SOFTSAEXPTIME,	CMD_TOKEN_SOFTSAEXPTIME	 	},
		{ CMD_TOKEN_STR_DEFRESPONSE,	CMD_TOKEN_DEFRESPONSE		},
		{ CMD_TOKEN_STR_MMSECMETHODS,	CMD_TOKEN_MMSECMETHODS		}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	memset(&MMPol, 0, sizeof(IPSEC_MM_POLICY));

	MMPol.uSoftExpirationTime = POTF_DEF_P1SOFT_TIME;
	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}
	parser.ValidTok   = vtokDynamicSetMMPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicSetMMPolicy);

	parser.ValidCmd   = vcmdDynamicSetMMPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicSetMMPolicy);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicSetMMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME				:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pszPolicyName = new _TCHAR[dwNameLen];
					if(pszPolicyName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pszPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			default :
				break;
		}
	}
	//
	// Get the corresponding MMPolicy for the user given mmpolicy name
	//
	dwReturn = GetMMPolicy(g_szDynamicMachine,dwVersion, pszPolicyName, &pMMPol, NULL);

	if((dwReturn != ERROR_SUCCESS) || (!pMMPol))
	{
		BAIL_OUT;
	}
	//
	// Copy old data into local variables
	//
	memcpy( &MMPol, pMMPol, sizeof(IPSEC_MM_POLICY));

	dwNameLen = _tcslen(pMMPol->pszPolicyName)+1;
	MMPol.pszPolicyName = new _TCHAR[dwNameLen];
	if(MMPol.pszPolicyName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	_tcsncpy(MMPol.pszPolicyName, pMMPol->pszPolicyName, dwNameLen);

	MMPol.pOffers = new IPSEC_MM_OFFER[MMPol.dwOfferCount];
	if(MMPol.pOffers == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	for(j=0; j<MMPol.dwOfferCount; j++)
	{
		memcpy(&(MMPol.pOffers[j]), &(pMMPol->pOffers[j]), sizeof(IPSEC_MM_OFFER));
	}

	SPDApiBufferFree(pMMPol);
	pMMPol = NULL;
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicSetMMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_DEFRESPONSE		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if(*(BOOL *)parser.Cmd[dwCount].pArg)
					{
						MMPol.dwFlags |= IPSEC_MM_POLICY_DEFAULT_POLICY;
					}
					else
					{
						MMPol.dwFlags &= ~IPSEC_MM_POLICY_DEFAULT_POLICY;
					}
				}
				break;
			case CMD_TOKEN_MMLIFETIME		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwSecLife = ((*(DWORD *)parser.Cmd[dwCount].pArg ) * 60);
					bSeclife = TRUE;
				}
				break;
			case CMD_TOKEN_QMPERMM			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwQmperMM = *(DWORD *)parser.Cmd[dwCount].pArg;
					bQmpermm = TRUE;
				}
				break;
			case CMD_TOKEN_SOFTSAEXPTIME	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					MMPol.uSoftExpirationTime = ((*(DWORD *)parser.Cmd[dwCount].pArg) * 60);
				}
				break;
			case CMD_TOKEN_MMSECMETHODS		:
				IPSEC_MM_OFFER *SecMethod;
				if (parser.Cmd[dwCount].dwStatus != 0)
				{
					if((MMPol.pOffers)&&(MMPol.dwOfferCount))
					{
						dwOldQmperMM = MMPol.pOffers[0].dwQuickModeLimit;
						dwOldKbLife = MMPol.pOffers[0].Lifetime.uKeyExpirationKBytes;
						dwOldSecLife = MMPol.pOffers[0].Lifetime.uKeyExpirationTime;

						if(MMPol.dwOfferCount)
						{
							delete [] (MMPol.pOffers);
						}
						else
						{
							delete (MMPol.pOffers);
						}
					}
					MMPol.dwOfferCount = parser.Cmd[dwCount].dwStatus;
					MMPol.pOffers = new IPSEC_MM_OFFER[MMPol.dwOfferCount];
					if(MMPol.pOffers == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					//
					// Copy user given new security methods
					//
					for(j=0;j<MMPol.dwOfferCount;j++)
					{
						SecMethod = ((IPSEC_MM_OFFER **)parser.Cmd[dwCount].pArg)[j];
						MMPol.pOffers[j].dwDHGroup = SecMethod->dwDHGroup;
						MMPol.pOffers[j].EncryptionAlgorithm = SecMethod->EncryptionAlgorithm;
						MMPol.pOffers[j].HashingAlgorithm = SecMethod->HashingAlgorithm;
						MMPol.pOffers[j].dwQuickModeLimit = dwOldQmperMM;
						MMPol.pOffers[j].Lifetime.uKeyExpirationKBytes = dwOldKbLife;
						MMPol.pOffers[j].Lifetime.uKeyExpirationTime = dwOldSecLife;
					}
				}
				break;
			default							:
				break;
		}
	}
	//
	// Copy qmpermm and lifetime separately if mm offer is not given by user.
	//
	for(j=0;j<MMPol.dwOfferCount;j++)
	{
		if(bQmpermm)
		{
			MMPol.pOffers[j].dwQuickModeLimit = dwQmperMM;
		}
		if(bSeclife)
		{
			MMPol.pOffers[j].Lifetime.uKeyExpirationTime = dwSecLife;
		}

	}

	dwReturn = SetMainModePolicy( pszPolicyName, MMPol);

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}
	//
	// error cleanup path.
	//
	if(pszPolicyName)
	{
		delete [] pszPolicyName;
	}

	if(MMPol.pszPolicyName)
		delete [] MMPol.pszPolicyName;

	if(MMPol.pOffers)
	{
		if(MMPol.dwOfferCount)
		{
			delete [] (MMPol.pOffers);
		}
		else
		{
			delete (MMPol.pOffers);
		}
	}

	if(pMMPol)
	{
		SPDApiBufferFree(pMMPol);
		pMMPol = NULL;
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}
	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicShowAll
//
//	Date of Creation: 9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:  Netshell Dynamic handle for show all
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicShowAll(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE,dwCount;
	ADDR SrcAddr,DesAddr;
	BOOL bResolveDNS = FALSE;
	BOOL bSrcMask = FALSE;
	BOOL bDstMask = FALSE;

	SrcAddr.uIpAddr = 0xFFFFFFFF;
	DesAddr.uIpAddr = 0xFFFFFFFF;
	SrcAddr.AddrType = IP_ADDR_UNIQUE;
	DesAddr.AddrType = IP_ADDR_UNIQUE;

	DWORD dwProtocol = 0xFFFFFFFF;

	QM_FILTER_VALUE_BOOL QMBoolValue;
	QMBoolValue.bSrcPort = FALSE;
    QMBoolValue.bDstPort= FALSE;
    QMBoolValue.bProtocol= FALSE;
    QMBoolValue.bActionInbound = FALSE;
    QMBoolValue.bActionOutbound= FALSE;

	NshHashTable addressHash;

	//
    // To take care of PASS in test tool, as show is being tested only for parser output.
	//
    UpdateGetLastError(NULL);

	const TAG_TYPE vcmdDynamicShowAll[] =
	{
		{ CMD_TOKEN_STR_RESDNS,		NS_REQ_ZERO,	  FALSE	}
	};
	const TOKEN_VALUE vtokDynamicShowAll[] =
	{
		{ CMD_TOKEN_STR_RESDNS,		CMD_TOKEN_RESDNS	}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	if(dwArgCount == 3)
	{
		//if no argument specified print with default options
		goto PRINT;
	}
	else if(dwArgCount < 3)
	{
		//
		// Bail out as user has not given sufficient arguments.
		//
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	parser.ValidTok   = vtokDynamicShowAll;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowAll);

	parser.ValidCmd   = vcmdDynamicShowAll;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowAll);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowAll[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_RESDNS	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bResolveDNS = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			default					:
				break;
		}
	}

PRINT:
	// Show all GPO information
	POLICY_INFO policyInfo;
	ZeroMemory(&policyInfo, sizeof(POLICY_INFO));
	policyInfo.dwLocation=IPSEC_REGISTRY_PROVIDER;
	PGPO pGPO=new GPO;
	if(pGPO==NULL)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturn = ERROR_SUCCESS;
		BAIL_OUT;
	}
	ZeroMemory(pGPO, sizeof(GPO));
	ShowLocalGpoPolicy(policyInfo, pGPO);

	//
	// Show all mmpolicy details
	//
	dwReturn = ShowMMPolicy(NULL);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all qmpolicy details
	//
	dwReturn = ShowQMPolicy(NULL);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all generic mmfilter details
	//
	dwReturn = ShowMMFilters(NULL, TRUE, SrcAddr, DesAddr, addressHash, bResolveDNS, bSrcMask, bDstMask);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all specific mmfilter details
	//
	dwReturn = ShowMMFilters(NULL, FALSE, SrcAddr, DesAddr, addressHash, bResolveDNS, bSrcMask, bDstMask);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all generic qmfilter details
	//
	dwReturn = ShowQMFilters(NULL, TRUE, SrcAddr, DesAddr, addressHash, bResolveDNS, bSrcMask, bDstMask, QMBoolValue);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all specific qmfilter details
	//
	dwReturn = ShowQMFilters(NULL, FALSE, SrcAddr, DesAddr, addressHash, bResolveDNS, bSrcMask, bDstMask, QMBoolValue);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all main mode security associations
	//
	dwReturn = ShowMMSas(SrcAddr, DesAddr, FALSE, addressHash, bResolveDNS);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all quick mode security associations
	//
	dwReturn = ShowQMSas(SrcAddr,DesAddr, dwProtocol, addressHash, bResolveDNS);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all Ipsec related registry keys
	//
	dwReturn = ShowRegKeys();
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//
	// Show all IPSec and IKE statistics
	//
	dwReturn = ShowStats(STATS_ALL);
	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
	}

	// all the errors have been displayed...
	// as such send ERROR_SUCCESS to netsh

	dwReturn = ERROR_SUCCESS;
error:
	if(pGPO)  // clean up the GPO structure
	{
		if(pGPO->pszGPODisplayName) delete [] pGPO->pszGPODisplayName;
		if(pGPO->pszGPODNName) delete [] pGPO->pszGPODNName;
		if(pGPO->pszPolicyName) delete [] pGPO->pszPolicyName;
		if(pGPO->pszLocalPolicyName) delete [] pGPO->pszLocalPolicyName;
		if(pGPO->pszPolicyDNName) delete [] pGPO->pszPolicyDNName;
		if(pGPO->pszDomainName) delete [] pGPO->pszDomainName;
		if(pGPO->pszDCName) delete [] pGPO->pszDCName;
		if(pGPO->pszOULink) delete [] pGPO->pszOULink;
		delete pGPO;
		pGPO = NULL;
	}
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicShowRegKeys
//
//	Date of Creation: 9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:  Netshell Dynamic handle for show registry keys of ipsec driver.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
HandleDynamicShowRegKeys(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;

	//No errors should be displayed in test tool,
	//as show commands are only tested for parser output.
    UpdateGetLastError(NULL);

	if(dwArgCount > 2)
	{
		dwReturn = ShowRegKeys();
	}
	else
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, ERRCODE_SHOW_REG_16);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;

}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicShowStats
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  Netshell Dynamic handle for show statistics
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicShowStats(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwShow = STATS_ALL;
	DWORD dwCount = 0;
	const TAG_TYPE vcmdDynamicShowStatistics[] =
	{
		{ CMD_TOKEN_STR_TYPE,		NS_REQ_ZERO,	  FALSE	}
	};
	const TOKEN_VALUE vtokDynamicShowStatistics[] =
	{
		{ CMD_TOKEN_STR_TYPE,		CMD_TOKEN_TYPE		}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	if(dwArgCount == 3)
	{
		dwReturn = ShowStats(dwShow);
		BAIL_OUT;
	}
	//
	// Bail out as user has not given sufficient arguments.
	//
	else if(dwArgCount < 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	parser.ValidTok   = vtokDynamicShowStatistics;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowStatistics);

	parser.ValidCmd   = vcmdDynamicShowStatistics;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowStatistics);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowStatistics[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_TYPE	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwShow = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			default					:
				break;
		}
	}

	switch(dwShow)
	{
		case STATS_ALL:
		case STATS_IKE:
		case STATS_IPSEC:
				dwReturn = ShowStats(dwShow);
				break;
		default:
				PrintMessageFromModule(g_hModule, ERROR_PARSER_STATS);
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
				break;
	}

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicShowMMSas
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:  Netshell Dynamic handle for show main mode security associations
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicShowMMSas(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwCount = 0;
	BOOL bFormat = FALSE;
	BOOL bResolveDNS = FALSE;
	ADDR SrcAddr,DesAddr;

	NshHashTable addressHash;

	//
	// Default values
	//
	SrcAddr.uIpAddr = 0xFFFFFFFF;
	DesAddr.uIpAddr = 0xFFFFFFFF;
	SrcAddr.AddrType = IP_ADDR_UNIQUE;
	DesAddr.AddrType = IP_ADDR_UNIQUE;

	const TAG_TYPE vcmdDynamicShowMMSAs[] =
	{
		{ CMD_TOKEN_STR_ALL,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SRCADDR,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTADDR,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_FORMAT,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_RESDNS,			NS_REQ_ZERO,	  FALSE }
	};

	const TOKEN_VALUE vtokDynamicShowMMSAs[] =
	{
		{ CMD_TOKEN_STR_ALL,			CMD_TOKEN_ALL		 },
		{ CMD_TOKEN_STR_SRCADDR,		CMD_TOKEN_SRCADDR	 },
		{ CMD_TOKEN_STR_DSTADDR,		CMD_TOKEN_DSTADDR	 },
		{ CMD_TOKEN_STR_FORMAT,			CMD_TOKEN_FORMAT	 },
		{ CMD_TOKEN_STR_RESDNS,			CMD_TOKEN_RESDNS	 }
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	if(dwArgCount == 3)
	{
		//
		// all the records are to be displayed
		//
		dwReturn = ShowMMSas(SrcAddr, DesAddr, bFormat, addressHash, bResolveDNS);
		BAIL_OUT;
	}
	//
	// Bail out as user has not given sufficient arguments.
	//
	else if(dwArgCount < 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	parser.ValidTok   = vtokDynamicShowMMSAs;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowMMSAs);

	parser.ValidCmd   = vcmdDynamicShowMMSAs;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowMMSAs);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine, ppwcArguments, dwCurrentIndex, dwArgCount, &parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowMMSAs[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_ALL			:
				break;
			case CMD_TOKEN_RESDNS 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bResolveDNS = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_SRCADDR	:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							SrcAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							SrcAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							SrcAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							SrcAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(SrcAddr, parser.Cmd[dwCount].dwStatus);
							break;
						case NOT_SPLSERVER:
							//
							// If it is not special server get the user given IP address
							//
							SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTADDR	:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// Special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							DesAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							DesAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							DesAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							DesAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(DesAddr, parser.Cmd[dwCount].dwStatus);
							break;
						case NOT_SPLSERVER:
							//
							// If it is not special server get the user given IP address
							//
							DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_FORMAT	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bFormat = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			default					:
				break;
		}
	}

	dwReturn = ShowMMSas(SrcAddr, DesAddr, bFormat, addressHash, bResolveDNS);

error:

	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function:	HandleDynamicShowQMSas
//
//Date of Creation: 9-23-2001
//
//Parameters:
//				IN 		LPCWSTR    pwszMachine,
//				IN OUT  LPWSTR     *ppwcArguments,
//				IN      DWORD      dwCurrentIndex,
//				IN      DWORD      dwArgCount,
//				IN      DWORD      dwFlags,
//				IN      LPCVOID    pvData,
//				OUT     BOOL       *pbDone
//Return: 		DWORD
//
//Description:  Netshell Dynamic handle for show quick mode security associations.
//
//Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
HandleDynamicShowQMSas(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwCount = 0;
	BOOL bFormat = FALSE;
	BOOL bResolveDNS = FALSE;
	ADDR SrcAddr,DesAddr;

	//
	// Default values
	//
	SrcAddr.uIpAddr = 0xFFFFFFFF;
	DesAddr.uIpAddr = 0xFFFFFFFF;
	SrcAddr.AddrType = IP_ADDR_UNIQUE;
	DesAddr.AddrType = IP_ADDR_UNIQUE;
	SrcAddr.uSubNetMask = 0x55555555;
	DesAddr.uSubNetMask = 0x55555555;

	DWORD dwProtocol = 0xFFFFFFFF;

	NshHashTable addressHash;

	const TAG_TYPE vcmdDynamicShowQMSAs[] =
	{
		{ CMD_TOKEN_STR_ALL,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SRCADDR,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTADDR,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_PROTO,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_FORMAT,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_RESDNS,			NS_REQ_ZERO,	  FALSE }
	};

	const TOKEN_VALUE vtokDynamicShowQMSAs[] =
	{
		{ CMD_TOKEN_STR_ALL,			CMD_TOKEN_ALL		 },
		{ CMD_TOKEN_STR_SRCADDR,		CMD_TOKEN_SRCADDR	 },
		{ CMD_TOKEN_STR_DSTADDR,		CMD_TOKEN_DSTADDR	 },
		{ CMD_TOKEN_STR_PROTO,			CMD_TOKEN_PROTO		 },
		{ CMD_TOKEN_STR_FORMAT,			CMD_TOKEN_FORMAT	 },
		{ CMD_TOKEN_STR_RESDNS,			CMD_TOKEN_RESDNS	 }
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	parser.ValidTok   = vtokDynamicShowQMSAs;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowQMSAs);

	parser.ValidCmd   = vcmdDynamicShowQMSAs;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowQMSAs);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}

	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowQMSAs[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_ALL 		:
				break;
			case CMD_TOKEN_SRCADDR	:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// Special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							SrcAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							SrcAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							SrcAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							SrcAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(SrcAddr, parser.Cmd[dwCount].dwStatus);
							break;
						case NOT_SPLSERVER:
							//
							// If it is not special server get the user given IP address
							//
							SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTADDR	:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// Special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							DesAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							DesAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							DesAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							DesAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(DesAddr, parser.Cmd[dwCount].dwStatus);
							break;
						case NOT_SPLSERVER:
							//
							// If it is not special server get the user given IP address
							//
							DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;

			case CMD_TOKEN_PROTO	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwProtocol = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_FORMAT	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bFormat = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_RESDNS   :
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bResolveDNS = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			default					:
				break;
		}
	}

	dwReturn = ShowQMSas(SrcAddr, DesAddr, dwProtocol, addressHash, bResolveDNS);

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicShowMMPolicy
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  Netshell Dynamic handle for show main mode policy.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicShowMMPolicy(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwCount = 0;
	DWORD dwNameLen = 0;
	LPTSTR pszPolicyName = NULL;
	BOOL bAll = FALSE;
	const TAG_TYPE vcmdDynamicShowMMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokDynamicShowMMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	parser.ValidTok   = vtokDynamicShowMMPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowMMPolicy);

	parser.ValidCmd   = vcmdDynamicShowMMPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowMMPolicy);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}

	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowMMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if((LPTSTR)parser.Cmd[dwCount].pArg != NULL)
					{
						dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
						pszPolicyName = new _TCHAR[dwNameLen];
						if(pszPolicyName == NULL)
						{
							dwReturn = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						_tcsncpy(pszPolicyName, (PTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
					}
				}
				break;
			case CMD_TOKEN_ALL :
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bAll = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			default:
				break;
		}
	}

	dwReturn = ShowMMPolicy(pszPolicyName);

error:

	if(dwArgCount > 3)
	{
		CleanUp();
	}
	if(pszPolicyName)
	{
		delete [] pszPolicyName;
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicShowQMPolicy
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  Netshell Dynamic handle for show quick mode policy
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////


DWORD WINAPI
HandleDynamicShowQMPolicy(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwNameLen = 0;
	DWORD dwCount = 0;
	LPTSTR pszPolicyName = NULL;
	BOOL bAll = FALSE;
	const TAG_TYPE vcmdDynamicShowQMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokDynamicShowQMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	parser.ValidTok   = vtokDynamicShowQMPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowQMPolicy);

	parser.ValidCmd   = vcmdDynamicShowQMPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowQMPolicy);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}

	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowQMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME:
				//
				// Dynamic variables initialization
				//
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if((LPTSTR)parser.Cmd[dwCount].pArg != NULL)
					{
						dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
						pszPolicyName = new _TCHAR[dwNameLen];
						if(pszPolicyName == NULL)
						{
							dwReturn = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						_tcsncpy(pszPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
					}
				}
				break;

			case CMD_TOKEN_ALL :
				//
				// Dynamic variables initialization
				//
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bAll = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			default:
				break;
		}
	}

	dwReturn = ShowQMPolicy(pszPolicyName);

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if(pszPolicyName)
	{
		delete [] pszPolicyName;
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicShowMMFilter
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  Netshell Dynamic handle for show main mode filter.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicShowMMFilter(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwCount = 0;
	DWORD dwNameLen = 0;
	LPTSTR pszFilterName = NULL;
	LPTSTR pszPolicyName = NULL;
	BOOL bAll = FALSE;
	BOOL bType = TRUE;
	DWORD dwType = FILTER_GENERIC;								//default initialization to GENERIC,
	BOOL bResolveDNS = FALSE;
	ADDR DesAddr, SrcAddr;
	BOOL bSrcMask = FALSE;
	BOOL bDstMask = FALSE;

	NshHashTable addressHash;

	const TAG_TYPE vcmdDynamicShowMMFilter[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_TYPE,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_SRCADDR,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DSTADDR,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_SRCMASK,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DSTMASK,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_RESDNS,		NS_REQ_ZERO,	FALSE }
	};
	const TOKEN_VALUE vtokDynamicShowMMFilter[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		},
		{ CMD_TOKEN_STR_TYPE,		CMD_TOKEN_TYPE		},
		{ CMD_TOKEN_STR_SRCADDR,	CMD_TOKEN_SRCADDR 	},
		{ CMD_TOKEN_STR_DSTADDR,	CMD_TOKEN_DSTADDR	},
		{ CMD_TOKEN_STR_SRCMASK,	CMD_TOKEN_SRCMASK	},
		{ CMD_TOKEN_STR_DSTMASK,	CMD_TOKEN_DSTMASK	},
		{ CMD_TOKEN_STR_RESDNS,		CMD_TOKEN_RESDNS	}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	SrcAddr.uIpAddr = 0xFFFFFFFF;
	DesAddr.uIpAddr = 0xFFFFFFFF;
	SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
	DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
	SrcAddr.AddrType = IP_ADDR_UNIQUE;
	DesAddr.AddrType = IP_ADDR_UNIQUE;

	parser.ValidTok   = vtokDynamicShowMMFilter;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowMMFilter);

	parser.ValidCmd   = vcmdDynamicShowMMFilter;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowMMFilter);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}

	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowMMFilter[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if((LPTSTR)parser.Cmd[dwCount].pArg != NULL)
					{
						dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
						pszFilterName = new _TCHAR[dwNameLen];
						if(pszFilterName == NULL)
						{
							dwReturn = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						_tcsncpy(pszFilterName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
					}
				}
				break;
			case CMD_TOKEN_ALL 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bAll = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_TYPE     :
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwType = *(DWORD *)parser.Cmd[dwCount].pArg;
					if(dwType == FILTER_GENERIC)
					{
						bType = TRUE;
					}
					else if(dwType == FILTER_SPECIFIC)
					{
						bType = FALSE;
					}
				}
				break;
			case CMD_TOKEN_SRCADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							SrcAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							SrcAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							SrcAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							SrcAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(SrcAddr, parser.Cmd[dwCount].dwStatus);
							bSrcMask = TRUE;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_SRCMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					SrcAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bSrcMask = TRUE;
				}
				break;
			case CMD_TOKEN_DSTADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					// special servers id is available in dwStatus
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							DesAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							DesAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							DesAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							DesAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(DesAddr, parser.Cmd[dwCount].dwStatus);
							bDstMask = TRUE;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					DesAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bDstMask = TRUE;
				}
				break;
			case CMD_TOKEN_RESDNS 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bResolveDNS = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			default:
				break;
		}
	}
	//
	// if name is NULL then all the filters are displayed.
	//
	dwReturn = ShowMMFilters(pszFilterName, bType, SrcAddr, DesAddr, addressHash, bResolveDNS, bSrcMask, bDstMask);

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if(pszFilterName)
	{
		delete [] pszFilterName;
	}
	if(pszPolicyName)
	{
		delete [] pszPolicyName;
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicShowQMFilter
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:  Netshell Dynamic handle for quick mode filter.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicShowQMFilter(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwCount = 0;
	DWORD dwNameLen = 0;
	LPTSTR pszFilterName = NULL;
	BOOL bAll = FALSE;
	BOOL bType = TRUE;
	DWORD dwType = FILTER_GENERIC;				// Default initialization to GENERIC

	BOOL bResolveDNS = FALSE;
	ADDR DesAddr, SrcAddr;
	BOOL bSrcMask = FALSE;
	BOOL bDstMask = FALSE;
	QM_FILTER_VALUE_BOOL QmBoolValue;

	NshHashTable addressHash;

	const TAG_TYPE vcmdDynamicShowQMFilter[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_TYPE,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_SRCADDR,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DSTADDR,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_SRCMASK,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DSTMASK,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_PROTO,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_SRCPORT,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DSTPORT,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_INBOUND,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_OUTBOUND,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_RESDNS,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokDynamicShowQMFilter[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		},
		{ CMD_TOKEN_STR_TYPE,		CMD_TOKEN_TYPE		},
		{ CMD_TOKEN_STR_SRCADDR,	CMD_TOKEN_SRCADDR 	},
		{ CMD_TOKEN_STR_DSTADDR,	CMD_TOKEN_DSTADDR	},
		{ CMD_TOKEN_STR_SRCMASK,	CMD_TOKEN_SRCMASK	},
		{ CMD_TOKEN_STR_DSTMASK,	CMD_TOKEN_DSTMASK	},
		{ CMD_TOKEN_STR_PROTO,		CMD_TOKEN_PROTO		},
		{ CMD_TOKEN_STR_SRCPORT,	CMD_TOKEN_SRCPORT 	},
		{ CMD_TOKEN_STR_DSTPORT,	CMD_TOKEN_DSTPORT	},
		{ CMD_TOKEN_STR_INBOUND,	CMD_TOKEN_INBOUND	},
		{ CMD_TOKEN_STR_OUTBOUND,	CMD_TOKEN_OUTBOUND	},
		{ CMD_TOKEN_STR_RESDNS,		CMD_TOKEN_RESDNS	}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	QmBoolValue.bSrcPort = FALSE;
	QmBoolValue.bDstPort = FALSE;
	QmBoolValue.bProtocol = FALSE;
	QmBoolValue.bActionInbound = FALSE;
	QmBoolValue.bActionOutbound = FALSE;

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	SrcAddr.uIpAddr = 0xFFFFFFFF;
	DesAddr.uIpAddr = 0xFFFFFFFF;
	SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
	DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
	SrcAddr.AddrType = IP_ADDR_UNIQUE;
	DesAddr.AddrType = IP_ADDR_UNIQUE;

	parser.ValidTok   = vtokDynamicShowQMFilter;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowQMFilter);

	parser.ValidCmd   = vcmdDynamicShowQMFilter;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowQMFilter);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowQMFilter[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if((LPTSTR)parser.Cmd[dwCount].pArg != NULL)
					{
						dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
						pszFilterName = new _TCHAR[dwNameLen];
						if(pszFilterName == NULL)
						{
							dwReturn = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						_tcsncpy(pszFilterName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
					}
				}
				break;
			case CMD_TOKEN_ALL :
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bAll = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_TYPE     :
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwType = *(DWORD *)parser.Cmd[dwCount].pArg;
					if(dwType == FILTER_GENERIC)
					{
						bType = TRUE;
					}
					else if(dwType == FILTER_SPECIFIC)
					{
						bType = FALSE;
					}
				}
				break;
			case CMD_TOKEN_SRCADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							SrcAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							SrcAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							SrcAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							SrcAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(SrcAddr, parser.Cmd[dwCount].dwStatus);
							bSrcMask = TRUE;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_SRCMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					SrcAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bSrcMask = TRUE;
				}
				break;
			case CMD_TOKEN_DSTADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							DesAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							DesAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							DesAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							DesAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(DesAddr, parser.Cmd[dwCount].dwStatus);
							bDstMask = TRUE;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					DesAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bDstMask = TRUE;
				}
				break;
			case CMD_TOKEN_RESDNS 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bResolveDNS = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_INBOUND			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if(*(DWORD *)parser.Cmd[dwCount].pArg==1)
					{
						QmBoolValue.dwActionInbound = PASS_THRU;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
					{
						QmBoolValue.dwActionInbound = BLOCKING;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==3)
					{
						QmBoolValue.dwActionInbound = NEGOTIATE_SECURITY;
					}
					QmBoolValue.bActionOutbound = TRUE;
				}
				break;
			case CMD_TOKEN_OUTBOUND			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if(*(DWORD *)parser.Cmd[dwCount].pArg==1)
					{
						QmBoolValue.dwActionOutbound = PASS_THRU;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
					{
						QmBoolValue.dwActionOutbound = BLOCKING;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==3)
					{
						QmBoolValue.dwActionOutbound = NEGOTIATE_SECURITY;
					}
					QmBoolValue.bActionInbound = TRUE;
				}
				break;
			case CMD_TOKEN_SRCPORT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					QmBoolValue.dwSrcPort = *(DWORD *)parser.Cmd[dwCount].pArg;
					QmBoolValue.bSrcPort = TRUE;
				}
				break;
			case CMD_TOKEN_DSTPORT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					QmBoolValue.dwDstPort = *(DWORD *)parser.Cmd[dwCount].pArg;
					QmBoolValue.bDstPort = TRUE;
				}
				break;
			case CMD_TOKEN_PROTO			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					QmBoolValue.dwProtocol = *(DWORD *)parser.Cmd[dwCount].pArg;
					QmBoolValue.bProtocol = TRUE;
				}
				break;
			default:
				break;
		}
	}

	//
	// if pszFilterName is null then all the qmfilters will be displayed
	//
	dwReturn = ShowQMFilters(pszFilterName, bType, SrcAddr, DesAddr, addressHash, bResolveDNS, bSrcMask, bDstMask, QmBoolValue);

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}
	if(pszFilterName)
	{
		delete [] pszFilterName;
	}
	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}
	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
// 	Function		:	HandleDynamicShowRule
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:  Netshell Dynamic handle for quick mode filter.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicShowRule(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwCount = 0;
	DWORD dwType = 0;						// Default initialization to show both Transport and tunnel

	BOOL bResolveDNS = FALSE;
	ADDR DesAddr, SrcAddr;
	BOOL bSrcMask = FALSE;
	BOOL bDstMask = FALSE;
	QM_FILTER_VALUE_BOOL QmBoolValue;

	NshHashTable addressHash;

	const TAG_TYPE vcmdDynamicShowRule[] =
	{
		{ CMD_TOKEN_STR_TYPE,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_SRCADDR,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DSTADDR,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_SRCMASK,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DSTMASK,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_PROTO,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_SRCPORT,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DSTPORT,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_INBOUND,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_OUTBOUND,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_RESDNS,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokDynamicShowRule[] =
	{
		{ CMD_TOKEN_STR_TYPE,		CMD_TOKEN_TYPE		},
		{ CMD_TOKEN_STR_SRCADDR,	CMD_TOKEN_SRCADDR 	},
		{ CMD_TOKEN_STR_DSTADDR,	CMD_TOKEN_DSTADDR	},
		{ CMD_TOKEN_STR_SRCMASK,	CMD_TOKEN_SRCMASK	},
		{ CMD_TOKEN_STR_DSTMASK,	CMD_TOKEN_DSTMASK	},
		{ CMD_TOKEN_STR_PROTO,		CMD_TOKEN_PROTO		},
		{ CMD_TOKEN_STR_SRCPORT,	CMD_TOKEN_SRCPORT 	},
		{ CMD_TOKEN_STR_DSTPORT,	CMD_TOKEN_DSTPORT	},
		{ CMD_TOKEN_STR_INBOUND,	CMD_TOKEN_INBOUND	},
		{ CMD_TOKEN_STR_OUTBOUND,	CMD_TOKEN_OUTBOUND	},
		{ CMD_TOKEN_STR_RESDNS,		CMD_TOKEN_RESDNS	}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	QmBoolValue.bSrcPort = FALSE;
	QmBoolValue.bDstPort = FALSE;
	QmBoolValue.bProtocol = FALSE;
	QmBoolValue.bActionInbound = FALSE;
	QmBoolValue.bActionOutbound = FALSE;

	SrcAddr.uIpAddr = 0xFFFFFFFF;
	DesAddr.uIpAddr = 0xFFFFFFFF;
	SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
	DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
	SrcAddr.AddrType = IP_ADDR_UNIQUE;
	DesAddr.AddrType = IP_ADDR_UNIQUE;

	//
	// if no arguments are given show all the rules
	//
	if(dwArgCount == 3)
	{
		dwReturn = ShowRule(dwType, SrcAddr, DesAddr, addressHash, bResolveDNS, bSrcMask, bDstMask, QmBoolValue);
		BAIL_OUT;
	}

	//
	// Bail out as user has not given sufficient arguments.
	//
	else if(dwArgCount < 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	parser.ValidTok   = vtokDynamicShowRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicShowRule);

	parser.ValidCmd   = vcmdDynamicShowRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicShowRule);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}

	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicShowRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_TYPE     :
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwType = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_SRCADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							SrcAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							SrcAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							SrcAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							SrcAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(SrcAddr, parser.Cmd[dwCount].dwStatus);
							bSrcMask = TRUE;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_SRCMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					SrcAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bSrcMask = TRUE;
				}
				break;
			case CMD_TOKEN_DSTADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
							DesAddr.AddrType = IP_ADDR_WINS_SERVER;
							break;
						case SERVER_DHCP:
							DesAddr.AddrType = IP_ADDR_DHCP_SERVER;
							break;
						case SERVER_DNS:
							DesAddr.AddrType = IP_ADDR_DNS_SERVER;
							break;
						case SERVER_GATEWAY:
							DesAddr.AddrType = IP_ADDR_DEFAULT_GATEWAY;
							break;
						case IP_ME:
						case IP_ANY:
							AddSplAddr(DesAddr, parser.Cmd[dwCount].dwStatus);
							bDstMask = TRUE;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					DesAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bDstMask = TRUE;
				}
				break;
			case CMD_TOKEN_RESDNS 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bResolveDNS = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_INBOUND			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if(*(DWORD *)parser.Cmd[dwCount].pArg==1)
					{
						QmBoolValue.dwActionInbound = PASS_THRU;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
					{
						QmBoolValue.dwActionInbound = BLOCKING;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==3)
					{
						QmBoolValue.dwActionInbound = NEGOTIATE_SECURITY;
					}
					QmBoolValue.bActionOutbound = TRUE;
				}
				break;
			case CMD_TOKEN_OUTBOUND			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if(*(DWORD *)parser.Cmd[dwCount].pArg==1)
					{
						QmBoolValue.dwActionOutbound = PASS_THRU;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
					{
						QmBoolValue.dwActionOutbound = BLOCKING;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==3)
					{
						QmBoolValue.dwActionOutbound = NEGOTIATE_SECURITY;
					}
					QmBoolValue.bActionInbound = TRUE;
				}
				break;
			case CMD_TOKEN_SRCPORT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					QmBoolValue.dwSrcPort = *(DWORD *)parser.Cmd[dwCount].pArg;
					QmBoolValue.bSrcPort = TRUE;
				}
				break;
			case CMD_TOKEN_DSTPORT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					QmBoolValue.dwDstPort = *(DWORD *)parser.Cmd[dwCount].pArg;
					QmBoolValue.bDstPort = TRUE;
				}
				break;
			case CMD_TOKEN_PROTO			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					QmBoolValue.dwProtocol = *(DWORD *)parser.Cmd[dwCount].pArg;
					QmBoolValue.bProtocol = TRUE;
				}
				break;
			default:
				break;
		}
	}

	dwReturn = ShowRule(dwType, SrcAddr, DesAddr, addressHash, bResolveDNS, bSrcMask, bDstMask, QmBoolValue);

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicDeleteQMPolicy
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  Netshell Dynamic handle for quick mode policy.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicDeleteQMPolicy(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwNameLen = 0;
	DWORD dwCount = 0;
	LPTSTR pPolicyName = NULL;
	const TAG_TYPE vcmdDynamicDeleteQMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokDynamicDeleteQMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}
	parser.ValidTok   = vtokDynamicDeleteQMPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicDeleteQMPolicy);

	parser.ValidCmd   = vcmdDynamicDeleteQMPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicDeleteQMPolicy);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}

	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicDeleteQMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pPolicyName = new _TCHAR[dwNameLen];
					if(pPolicyName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			case CMD_TOKEN_ALL		:		// if pPolicyName is NULL, deletes all
				break;
			default					:
				break;
		}
	}
	dwReturn = DeleteQMPolicy(pPolicyName);
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_NO_QMPOLICY);
	}

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}
	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}
	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}
    return dwReturn;
}
///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicDeleteMMPolicy
//
//	Date of Creation: 	9-23-2001
//
//	Parameters:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:  	Netshell Dynamic handle for delete main mode policy
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicDeleteMMPolicy(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwNameLen = 0;
	DWORD dwCount = 0;
	LPTSTR pPolicyName = NULL;
	const TAG_TYPE vcmdDynamicDeleteMMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokDynamicDeleteMMPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}
	parser.ValidTok   = vtokDynamicDeleteMMPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicDeleteMMPolicy);

	parser.ValidCmd   = vcmdDynamicDeleteMMPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicDeleteMMPolicy);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			//
			// This is to avoid multiple error messages display
			//
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicDeleteMMPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pPolicyName = new _TCHAR[dwNameLen];
					if(pPolicyName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			case CMD_TOKEN_ALL		:	// if pPolicyName is NULL, deletes all
				break;
			default					:
				break;
		}
	}

	dwReturn = DeleteMMPolicy(pPolicyName);
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_NO_MMPOLICY);
	}

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}
	if(pPolicyName)
	{
		delete [] pPolicyName;
	}
	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}
	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}
    return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicDeleteAll
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:  	Netshell Dynamic handle for delete all.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicDeleteAll(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
    DWORD dwReturn = ERROR_SHOW_USAGE;

    //to take care no errors at test tool
    UpdateGetLastError(NULL);

	dwReturn = DeleteTunnelFilters();
	if(dwReturn != ERROR_SUCCESS)
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	dwReturn = DeleteTransportFilters();
	if(dwReturn != ERROR_SUCCESS)
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	dwReturn = DeleteQMPolicy(NULL);
	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	dwReturn = DeleteMMFilters();
	if(dwReturn != ERROR_SUCCESS)
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	dwReturn = DeleteMMPolicy(NULL);
	if((dwReturn != ERROR_SUCCESS)&& (dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	dwReturn = DeleteAuthMethods();
	if(dwReturn != ERROR_SUCCESS)
	{
		//api errors
		if(dwReturn == WIN32_AUTH_BEING_USED)		//Win32 Error [13012] message is same as 13002.
		{											//So, it is converted to meaningful IPSec error code
			PrintErrorMessage(IPSEC_ERR, dwReturn, ERRCODE_DELETE_AUTH_BEING_USED);
		}
		else
		{
			PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		}
		dwReturn = ERROR_SUCCESS;
	}
    return dwReturn;

}

//////////////////////////////////////////////////////////////////////////////////////////
//
// WriteRegKey
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
WriteRegKey(
	LPTSTR lpValueName,
	BYTE* data,
	size_t uiDataSize,
	DWORD dwDataType
	)
{
	DWORD dwReturn = 0;
	HKEY hRegistryKey;
	DWORD dwDisposition = 0;

	dwReturn = RegCreateKeyEx(
		g_hGlobalRegistryKey,
		REGKEY_GLOBAL,
		0,
		NULL,
		0,
		KEY_ALL_ACCESS,
		NULL,
		&hRegistryKey,
		&dwDisposition
		);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	dwReturn = RegSetValueEx(
		hRegistryKey,
		lpValueName,
		0,
		dwDataType,
		data,
		uiDataSize
		);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

error:
	if(hRegistryKey)
	{
		RegCloseKey(hRegistryKey);
	}

	return dwReturn;
}

DWORD
WriteRegKey(
	LPTSTR lpValueName,
	DWORD dwData
	)
{
	return WriteRegKey(lpValueName, (BYTE*)&dwData, sizeof(DWORD), REG_DWORD);
}

DWORD
ParseProtocol(
	LPTSTR lpData,
	BYTE* pProtocol
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	BYTE value = 0;

	// get protocol
	if (_tcsicmp(lpData, IF_TYPE_UDP) == 0)
	{
		value = PROT_ID_UDP;
	}
	else if (_tcsicmp(lpData, IF_TYPE_TCP) == 0)
	{
		value = PROT_ID_TCP;
	}
	else if (_tcsicmp(lpData, IF_TYPE_ICMP) == 0)
	{
		value = PROT_ID_ICMP;
	}
	else if (_tcsicmp(lpData, IF_TYPE_RAW) == 0)
	{
		value = PROT_ID_RAW;
	}
	else // try to parse it as an integer
	{
		DWORD dwValue = 0;
		dwReturn = ConvertStringToDword(lpData, &dwValue);
		if ((dwReturn != ERROR_SUCCESS) || (dwValue < 1) || (dwValue > 255))
		{
			dwReturn = ERRCODE_INVALID_ARGS;
			BAIL_OUT;
		}
		value = (BYTE)dwValue;
	}
	*pProtocol = value;

error:
	return dwReturn;
}

DWORD
ParsePort(
	LPTSTR lpData,
	USHORT* pPort
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwValue = 0;
	dwReturn = ConvertStringToDword(lpData, &dwValue);
	if ((dwReturn != ERROR_SUCCESS) || (dwValue > 65535))
	{
		dwReturn = ERRCODE_INVALID_ARGS;
		BAIL_OUT;
	}
	*pPort = (USHORT)dwValue;

error:
	return dwReturn;
}

DWORD
ParseDirection(
	LPTSTR lpData,
	BYTE* pDirection
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	BYTE value = 0;

	// get direction
	if (_tcsicmp(lpData, TOKEN_STR_INBOUND) == 0)
	{
		value = EXEMPT_DIRECTION_INBOUND;
	}
	else if (_tcsicmp(lpData, TOKEN_STR_OUTBOUND) == 0)
	{
		value = EXEMPT_DIRECTION_OUTBOUND;
	}
	else
	{
		dwReturn = ERRCODE_INVALID_ARGS;
		BAIL_OUT;
	}
	*pDirection = value;

error:
	return dwReturn;
}

DWORD
ParseBootExemptions(
	IN LPTSTR lpData
	)
{
	DWORD dwReturn = ERROR_SUCCESS;

	// allocate 1024 tuples
	PIPSEC_EXEMPT_ENTRY aEntries = new IPSEC_EXEMPT_ENTRY[MAX_EXEMPTION_ENTRIES];
	ZeroMemory(aEntries, sizeof(*aEntries));
	
	size_t uiNumExemptions = 0;

	// check for keyword 'none', skip loop in this case
	if (_tcsicmp(lpData, TOKEN_STR_NONE) != 0)
	{
		LPTSTR lpDelimiter = TOKEN_FIELD_DELIMITER;
		LPTSTR lpCurrentToken = _tcstok(lpData, lpDelimiter);
		size_t i = 0;
		size_t state = 0;

		// while not at end of string...
		while ((lpCurrentToken != NULL) && (i < MAX_EXEMPTION_ENTRIES))
		{
			switch (state)
			{
			case 0:
				// set the constant values (type and size)
				aEntries[i].Type = EXEMPT_ENTRY_TYPE_DEFAULT;
				aEntries[i].Size = EXEMPT_ENTRY_SIZE_DEFAULT;
				dwReturn = ParseProtocol(lpCurrentToken, &(aEntries[i].Protocol));
				if (dwReturn != ERROR_SUCCESS)
				{
					BAIL_OUT;
				}
				if ((aEntries[i].Protocol != PROT_ID_TCP) && (aEntries[i].Protocol != PROT_ID_UDP))
				{
					// unless TCP or UDP are specified, we don't support
					// srcport or destport, fill them in with 0
					aEntries[i].SrcPort = 0;
					aEntries[i].DestPort = 0;
					state += 2;
				}
				break;
			case 1:
				dwReturn = ParsePort(lpCurrentToken, &(aEntries[i].SrcPort));
				break;
			case 2:
				dwReturn = ParsePort(lpCurrentToken, &(aEntries[i].DestPort));
				break;
			case 3:
				dwReturn = ParseDirection(lpCurrentToken, &(aEntries[i].Direction));
				if (dwReturn == ERROR_SUCCESS)
				{
					if (((aEntries[i].Protocol != PROT_ID_TCP) && (aEntries[i].Protocol != PROT_ID_UDP))
							&& ((aEntries[i].SrcPort != 0) || (aEntries[i].DestPort != 0)))
					{
						dwReturn = ERRCODE_INVALID_ARGS;
					}
				}
				++i;
				break;
			}
			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			state = (state + 1) % 4;
			if (state == 3)
			{
				lpDelimiter = TOKEN_TUPLE_DELIMITER;
			}
			else
			{
				lpDelimiter = TOKEN_FIELD_DELIMITER;
			}
			lpCurrentToken = _tcstok(NULL, lpDelimiter);
		}

		// on exiting the loop, make sure we have only had complete tuples
		if ((state % 4) != 0)
		{
			dwReturn = ERRCODE_INVALID_ARGS;
			BAIL_OUT;
		}

		// were we given more than we can handle?
		if (i == MAX_EXEMPTION_ENTRIES)
		{
			dwReturn = ERRCODE_TOO_MANY_EXEMPTS;
			BAIL_OUT;
		}

		uiNumExemptions = i;
	}

	if (dwReturn == ERROR_SUCCESS)
	{
		dwReturn = WriteRegKey(
						BOOTEXEMPTKEY,
						(BYTE*)aEntries,
						sizeof(IPSEC_EXEMPT_ENTRY) * uiNumExemptions,
						REG_BINARY
						);
	}

error:
	delete [] aEntries;

	return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicSetConfig
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:   This command sets the IPSec registry keys
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicSetConfig(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwKeyType = 0;
	DWORD dwKeyValue = 0;
	DWORD dwCount = 0;

	LPTSTR lpKeyValue = NULL;

	IKE_CONFIG IKEConfig;

	const TAG_TYPE vcmdDynamicSetConfig[] =
	{
		{ CMD_TOKEN_STR_PROPERTY,	NS_REQ_PRESENT,	FALSE },
		{ CMD_TOKEN_STR_VALUE,		NS_REQ_PRESENT,	FALSE }
	};

	const TOKEN_VALUE vtokDynamicSetConfig[] =
	{
		{ CMD_TOKEN_STR_PROPERTY,	CMD_TOKEN_PROPERTY	},
		{ CMD_TOKEN_STR_VALUE,		CMD_TOKEN_VALUE		}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	ZeroMemory( &IKEConfig, sizeof(IKE_CONFIG) );

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}
	parser.ValidTok   = vtokDynamicSetConfig;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicSetConfig);

	parser.ValidCmd   = vcmdDynamicSetConfig;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicSetConfig);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}

	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicSetConfig[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_PROPERTY	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwKeyType = *(DWORD*)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_VALUE	:
				lpKeyValue = (LPTSTR)parser.Cmd[dwCount].pArg;
				// if it's supposed to be numeric, convert now
				switch (dwKeyType)
				{
				case PROPERTY_BOOTMODE:
					break;
				case PROPERTY_BOOTEXEMP:
					break;
				default:
					dwReturn = ConvertStringToDword(lpKeyValue, &dwKeyValue);
					if (dwReturn)
					{
						dwReturn = ERROR_SHOW_USAGE;
						BAIL_OUT;
					}
					else
					{
						parser.Cmd[dwCount].dwStatus = VALID_TOKEN;
					}
					break;
				}
				break;
			default					:
				break;
		}
	}

	dwReturn = GetConfigurationVariables(g_szDynamicMachine, &IKEConfig);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	switch(dwKeyType)
	{
		case PROPERTY_ENABLEDIGNO:
			//
			// range is from 0-7 for enable diagnostics
			//
			if( dwKeyValue > 7)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_CONFIG_1);
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}

			dwReturn = WriteRegKey(ENABLE_DIAG, dwKeyValue);
			if(dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			break;

		case PROPERTY_IKELOG:
			//
			// range is from 0-2 for IKE dwEnableLogging
			//
			if( dwKeyValue >2)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_CONFIG_2);
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
			IKEConfig.dwEnableLogging = dwKeyValue;
			dwReturn = SetConfigurationVariables(g_szDynamicMachine, IKEConfig);
			if(dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			break;

		case PROPERTY_CRLCHK:
			//
			// range is from 0-2 for dwStrongCRLCheck
			//
			if( dwKeyValue >2)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_CONFIG_3);
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
			IKEConfig.dwStrongCRLCheck = dwKeyValue;
			dwReturn = SetConfigurationVariables(g_szDynamicMachine, IKEConfig);
			if(dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			break;

		case PROPERTY_LOGINTER:
			//
			// range is from 60-86400 for ENABLE_LOGINT
			//
			if(dwKeyValue < 60 || dwKeyValue > 86400)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_CONFIG_4);
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}

			dwReturn = WriteRegKey(ENABLE_LOGINT, dwKeyValue);
			if(dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			break;
		case PROPERTY_EXEMPT:
			//
			// range is from 0-3 for ENABLE_EXEMPT
			//
			if( dwKeyValue >3)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_CONFIG_5);
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}

			dwReturn = WriteRegKey(ENABLE_EXEMPT, dwKeyValue);
			if(dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			break;

		case PROPERTY_BOOTMODE:
			// valid values are stateful, block, permit
			if( _tcsicmp(lpKeyValue, VALUE_TYPE_STATEFUL) == 0)
			{
				dwKeyValue = VALUE_STATEFUL;
			}
			else if( _tcsicmp(lpKeyValue, VALUE_TYPE_BLOCK) == 0)
			{
				dwKeyValue = VALUE_BLOCK;
			}
			else if( _tcsicmp(lpKeyValue, VALUE_TYPE_PERMIT) == 0)
			{
				dwKeyValue = VALUE_PERMIT;
			}
			else
			{
				dwReturn = ERROR_SHOW_USAGE;
				BAIL_OUT;
			}

			dwReturn = WriteRegKey(BOOTMODEKEY, dwKeyValue);
			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			break;

		case PROPERTY_BOOTEXEMP:
			dwReturn = ParseBootExemptions(lpKeyValue);
			if (dwReturn != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR, 0, dwReturn);
				dwReturn = ERROR_SHOW_USAGE;
				BAIL_OUT;
			}
			break;

		default :
			break;
	}

error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}

	else if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}
    return dwReturn;
}
///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicAddRule
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:	Function adds a rule (As good as Adding QMF+MMF)
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////


DWORD WINAPI
HandleDynamicAddRule(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	TRANSPORT_FILTER ParserTransportlFltr;
	TUNNEL_FILTER ParserTunnelFltr;
	MM_FILTER   MMFilter;
	ADDR DesAddr, SrcAddr;
	FILTER_ACTION Inbound = NEGOTIATE_SECURITY, Outbound = NEGOTIATE_SECURITY;
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwNameLen = 0;
	DWORD dwCount = 0, j = 0;
	DWORD dwProtocol = 0;
	DWORD dwSrcPort = 0;
	DWORD dwDstPort = 0;
	DWORD dwSrcSplServer = NOT_SPLSERVER;
	DWORD dwDstSplServer = NOT_SPLSERVER;

	BOOL bTunnel = FALSE;
	BOOL bPort = FALSE;
	BOOL bAuth = FALSE;
	BOOL bFailMMIfExists = FALSE;
	BOOL bSrcMe = FALSE;
	BOOL bIsOutboundBroadcast = FALSE;

	LPTSTR pszMMPolicyName = NULL;
	LPTSTR pszFilterActionName = NULL;
	LPTSTR pszMMFilterName = NULL;
	LPTSTR pszQMFilterName = NULL;

	PRULEDATA pRuleData = new RULEDATA;
	if (pRuleData == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	ZeroMemory(pRuleData, sizeof(RULEDATA));
	PSTA_AUTH_METHODS pKerbAuth = NULL;
	PSTA_AUTH_METHODS pPskAuth = NULL;
	PSTA_MM_AUTH_METHODS *ppRootcaMMAuth = NULL;

	const TAG_TYPE vcmdDynamicAddRule[] =
	{
		{ CMD_TOKEN_STR_SRCADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_DSTADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_MMPOLICY,		NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_QMPOLICY,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_PROTO,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SRCPORT,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_DSTPORT,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_MIRROR,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_CONNTYPE,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_INBOUND,	    NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_OUTBOUND,	    NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SRCMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_TUNNELDST,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_FAILMMIFEXISTS, NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_KERB,	        NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_PSK,	        NS_REQ_ZERO,	  FALSE	}
	};
	const TOKEN_VALUE vtokDynamicAddRule[] =
	{
		{ CMD_TOKEN_STR_SRCADDR,		CMD_TOKEN_SRCADDR 		},
		{ CMD_TOKEN_STR_DSTADDR,		CMD_TOKEN_DSTADDR 		},
		{ CMD_TOKEN_STR_MMPOLICY,		CMD_TOKEN_MMPOLICY		},
		{ CMD_TOKEN_STR_QMPOLICY,		CMD_TOKEN_QMPOLICY		},
		{ CMD_TOKEN_STR_PROTO,			CMD_TOKEN_PROTO			},
		{ CMD_TOKEN_STR_SRCPORT,		CMD_TOKEN_SRCPORT		},
		{ CMD_TOKEN_STR_DSTPORT,		CMD_TOKEN_DSTPORT		},
		{ CMD_TOKEN_STR_MIRROR,			CMD_TOKEN_MIRROR		},
		{ CMD_TOKEN_STR_CONNTYPE,		CMD_TOKEN_CONNTYPE		},
		{ CMD_TOKEN_STR_INBOUND,	    CMD_TOKEN_INBOUND		},
		{ CMD_TOKEN_STR_OUTBOUND,	    CMD_TOKEN_OUTBOUND		},
		{ CMD_TOKEN_STR_SRCMASK,		CMD_TOKEN_SRCMASK		},
		{ CMD_TOKEN_STR_DSTMASK,		CMD_TOKEN_DSTMASK		},
		{ CMD_TOKEN_STR_TUNNELDST,		CMD_TOKEN_TUNNELDST		},
		{ CMD_TOKEN_STR_FAILMMIFEXISTS, CMD_TOKEN_FAILMMIFEXISTS},
		{ CMD_TOKEN_STR_KERB,	        CMD_TOKEN_KERB          },
		{ CMD_TOKEN_STR_PSK,	        CMD_TOKEN_PSK	        }
	};

	const TOKEN_VALUE	vlistDynamicAddRule[] =
	{
		{ CMD_TOKEN_STR_ROOTCA,	        CMD_TOKEN_ROOTCA	    }
	};


	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	memset(&MMFilter, 0, sizeof(MM_FILTER));
	memset(&ParserTunnelFltr, 0, sizeof(TUNNEL_FILTER));
	memset(&ParserTransportlFltr, 0, sizeof(TRANSPORT_FILTER));

	SrcAddr.uIpAddr 	= 0x0;
	SrcAddr.AddrType 	= IP_ADDR_UNIQUE;
	SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

	DesAddr.uIpAddr 	= 0x0;
	DesAddr.AddrType 	= IP_ADDR_UNIQUE;
	DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

	ParserTunnelFltr.SrcTunnelAddr.AddrType 	= IP_ADDR_UNIQUE;
	ParserTunnelFltr.SrcTunnelAddr.uIpAddr 		= SUBNET_ADDRESS_ANY;
	ParserTunnelFltr.SrcTunnelAddr.uSubNetMask 	= IP_ADDRESS_MASK_NONE;

	ParserTunnelFltr.DesTunnelAddr.AddrType 	= IP_ADDR_UNIQUE;
	ParserTunnelFltr.DesTunnelAddr.uIpAddr 		= SUBNET_ADDRESS_ANY;
	ParserTunnelFltr.DesTunnelAddr.uSubNetMask 	= IP_ADDRESS_MASK_NONE;

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}
	dwReturn = LoadMMFilterDefaults(MMFilter);

	parser.ValidTok   = vtokDynamicAddRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicAddRule);

	parser.ValidCmd   = vcmdDynamicAddRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicAddRule);

	parser.ValidList  = vlistDynamicAddRule;
	parser.MaxList    = SIZEOF_TOKEN_VALUE(vlistDynamicAddRule);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//Check for user given tokens from the parser and copy into local variables
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicAddRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_FAILMMIFEXISTS:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bFailMMIfExists = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_MMPOLICY		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN && (LPTSTR)parser.Cmd[dwCount].pArg)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pszMMPolicyName = new _TCHAR[dwNameLen];
					if(pszMMPolicyName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pszMMPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			case CMD_TOKEN_QMPOLICY	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN && (LPTSTR)parser.Cmd[dwCount].pArg)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pszFilterActionName = new _TCHAR[dwNameLen];
					if(pszFilterActionName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pszFilterActionName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			case CMD_TOKEN_MIRROR		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					MMFilter.bCreateMirror = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_CONNTYPE		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					switch(*(DWORD *)parser.Cmd[dwCount].pArg)
					{
						case INTERFACE_TYPE_ALL:
							MMFilter.InterfaceType = INTERFACE_TYPE_ALL;
							break;
						case INTERFACE_TYPE_LAN:
							MMFilter.InterfaceType = INTERFACE_TYPE_LAN;
							break;
						case INTERFACE_TYPE_DIALUP:
							MMFilter.InterfaceType = INTERFACE_TYPE_DIALUP;
							break;
						default :
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					// special servers id is available in dwStatus
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ME:
						case IP_ANY:
							dwDstSplServer = parser.Cmd[dwCount].dwStatus;
							break;
						case NOT_SPLSERVER:
							//if it is not special server get the user given IP address
							MMFilter.DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					MMFilter.DesAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					DesAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_SRCADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					// special servers id is available in dwStatus
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case IP_ME:
							bSrcMe = TRUE;
							// fallthrough
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ANY:
							dwSrcSplServer = parser.Cmd[dwCount].dwStatus;
							break;
						case NOT_SPLSERVER:
							//if it is not special server get the user given IP address
							MMFilter.SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_SRCMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					MMFilter.SrcAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					SrcAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_INBOUND			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if(*(DWORD *)parser.Cmd[dwCount].pArg==1)
					{
						Inbound = PASS_THRU;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
					{
						Inbound = BLOCKING;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==3)
					{
						Inbound = NEGOTIATE_SECURITY;
					}
				}
				break;
			case CMD_TOKEN_OUTBOUND			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					if(*(DWORD *)parser.Cmd[dwCount].pArg==1)
					{
						Outbound = PASS_THRU;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
					{
						Outbound = BLOCKING;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==3)
					{
						Outbound = NEGOTIATE_SECURITY;
					}
				}
				break;
			case CMD_TOKEN_SRCPORT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwSrcPort = *(DWORD *)parser.Cmd[dwCount].pArg;
					bPort = TRUE;
				}
				break;
			case CMD_TOKEN_DSTPORT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwDstPort = *(DWORD *)parser.Cmd[dwCount].pArg;
					bPort = TRUE;
				}
				break;
			case CMD_TOKEN_PROTO			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwProtocol = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_TUNNELDST		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// Special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case NOT_SPLSERVER:
							//
							// If it is not special server get the user given IP address
							//
							ParserTunnelFltr.DesTunnelAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							bTunnel = TRUE;
							ADDR addr;
							addr.uIpAddr = htonl(ParserTunnelFltr.DesTunnelAddr.uIpAddr);
							addr.uSubNetMask = IP_ADDRESS_MASK_NONE;
							if (!IsValidTunnelEndpointAddress(&addr))
							{
								dwReturn = ERROR_INVALID_PARAMETER;
								BAIL_OUT;
							}
							break;
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ME:
						case IP_ANY:
						default:
							PrintMessageFromModule(g_hModule, ADD_STATIC_RULE_INVALID_TUNNEL);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_KERB             :
							if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pKerbAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_PSK			:
							if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pPskAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_ROOTCA		:
							// this case is special, handled below...
							break;
			default						:
							break;
		}
	}

	size_t uiRootcaIndex = parser.MaxTok;
	if (parser.Cmd[uiRootcaIndex].dwStatus > 0)
	{
		pRuleData->bAuthMethodSpecified = TRUE;
		pRuleData->AuthInfos.dwNumAuthInfos += parser.Cmd[uiRootcaIndex].dwStatus;
		ppRootcaMMAuth = (PSTA_MM_AUTH_METHODS *)(parser.Cmd[uiRootcaIndex].pArg);
	}

	dwReturn = AddAllAuthMethods(pRuleData, pKerbAuth, pPskAuth, ppRootcaMMAuth, TRUE);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	//
	// Checking Invalid conditions.
	//
	if((dwSrcSplServer != NOT_SPLSERVER) && (dwDstSplServer != NOT_SPLSERVER)
		&& (dwSrcSplServer != IP_ME) && (dwSrcSplServer != IP_ANY)
		&& (dwDstSplServer != IP_ME) && (dwDstSplServer != IP_ANY) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_PARSER_ADDRTYPE);
		dwReturn = ERROR_NO_DISPLAY;
		BAIL_OUT;
	}

	//
	// If qmpolicy name is not given and inbound and outbound are negotiate security, then bail out
	//
	if((Inbound == NEGOTIATE_SECURITY || Outbound == NEGOTIATE_SECURITY) && !pszFilterActionName)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_RULE_WARNING_3);
		dwReturn = ERROR_NO_DISPLAY;
		BAIL_OUT;
	}
	//
	// If tunnel rule is added with mirror = yes, bail out
	//
	if(bTunnel && MMFilter.bCreateMirror)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_RULE_WARNING_4);
		dwReturn = ERROR_NO_DISPLAY;
		BAIL_OUT;
	}

	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	ADDR srcAddr;
	ADDR dstAddr;

	srcAddr.uIpAddr = ntohl(SrcAddr.uIpAddr);
	srcAddr.uSubNetMask = ntohl(SrcAddr.uSubNetMask);

	dstAddr.uIpAddr = ntohl(DesAddr.uIpAddr);
	dstAddr.uSubNetMask = ntohl(DesAddr.uSubNetMask);

	if (IsBroadcastAddress(&dstAddr) || IsMulticastAddress(&dstAddr))
	{
		if (MMFilter.bCreateMirror || !bSrcMe ||
			((Inbound == NEGOTIATE_SECURITY) || (Outbound == NEGOTIATE_SECURITY))
			)
		{
			dwReturn = ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}
		if (IsBroadcastAddress(&dstAddr))
		{
			bIsOutboundBroadcast = TRUE;
		}
	}

	// don't accept subnetX <-> subnetX (same subnet) if mirrored=no
	// reject subnetx-subnetx
	if (!MMFilter.bCreateMirror)
	{
		if (IsValidSubnet(&srcAddr) && IsValidSubnet(&dstAddr) && (srcAddr.uIpAddr == dstAddr.uIpAddr))
		{
			dwReturn = ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}
	}

	//Src Dst addr's of MM filter should be tunnel end points if present
	//
	if(bTunnel)
	{
		AddSplAddr(MMFilter.SrcAddr, IP_ME);
		MMFilter.DesAddr.uIpAddr = ParserTunnelFltr.DesTunnelAddr.uIpAddr;
		MMFilter.DesAddr.AddrType = IP_ADDR_UNIQUE;
		MMFilter.DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
		MMFilter.bCreateMirror = TRUE;
	}
	else
	{
		if(dwSrcSplServer == NOT_SPLSERVER)
		{
			MMFilter.SrcAddr.AddrType = (MMFilter.SrcAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
		}
		else
		{
			AddSplAddr(MMFilter.SrcAddr, dwSrcSplServer);
		}

		if(dwDstSplServer == NOT_SPLSERVER)
		{
			MMFilter.DesAddr.AddrType = (MMFilter.DesAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
		}
		else
		{
			AddSplAddr(MMFilter.DesAddr, dwDstSplServer);
		}
	}

	dwReturn = CreateName(&pszMMFilterName);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	// we create a MM filter for any tunnel rule and for any non-tunnel rule that is not to broadcast
	if (!bIsOutboundBroadcast || bTunnel)
	{
		dwReturn = AddMainModeFilter( pszMMFilterName, pszMMPolicyName, MMFilter, pRuleData->AuthInfos);
		if (!bFailMMIfExists && (dwReturn == ERROR_IPSEC_MM_AUTH_EXISTS || dwReturn == ERROR_IPSEC_MM_FILTER_EXISTS))
		{
			dwReturn = ERROR_SUCCESS; 	// it's not actually an error, functionality requires.
										// Even if MMFilter already exists, continue for QMFilter creation.
		}
		else if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
	}

	if(dwSrcSplServer == NOT_SPLSERVER)
	{
		SrcAddr.AddrType = (SrcAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
	}
	else
	{
		AddSplAddr(SrcAddr, dwSrcSplServer);
	}

	//
	// Destination address setting up
	//
	if(dwDstSplServer == NOT_SPLSERVER)
	{
		DesAddr.AddrType = (DesAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
	}
	else
	{
		AddSplAddr(DesAddr, dwDstSplServer);
	}
	//
	// Transport Filter data setup
	//
	if(!bTunnel)
	{
		ParserTransportlFltr.Protocol.ProtocolType = PROTOCOL_UNIQUE;
		ParserTransportlFltr.Protocol.dwProtocol   = dwProtocol;
		ParserTransportlFltr.SrcPort.PortType = PORT_UNIQUE;
		ParserTransportlFltr.SrcPort.wPort = (WORD)dwSrcPort;
		ParserTransportlFltr.DesPort.PortType = PORT_UNIQUE;
		ParserTransportlFltr.DesPort.wPort = (WORD)dwDstPort;
		ParserTransportlFltr.SrcAddr.AddrType = SrcAddr.AddrType;
		ParserTransportlFltr.SrcAddr.uIpAddr = SrcAddr.uIpAddr;
		ParserTransportlFltr.SrcAddr.uSubNetMask = SrcAddr.uSubNetMask;
		ParserTransportlFltr.DesAddr.AddrType = DesAddr.AddrType;
		ParserTransportlFltr.DesAddr.uIpAddr = DesAddr.uIpAddr;
		ParserTransportlFltr.DesAddr.uSubNetMask = DesAddr.uSubNetMask;
		ParserTransportlFltr.InterfaceType = MMFilter.InterfaceType;
		ParserTransportlFltr.bCreateMirror = MMFilter.bCreateMirror;
		ParserTransportlFltr.InboundFilterAction = Inbound;
		ParserTransportlFltr.OutboundFilterAction = Outbound;

		if(!((ParserTransportlFltr.Protocol.dwProtocol == PROT_ID_TCP) || (ParserTransportlFltr.Protocol.dwProtocol == PROT_ID_UDP)))
		{
			ParserTransportlFltr.SrcPort.wPort = 0;
			ParserTransportlFltr.DesPort.wPort = 0;
			if(bPort)
			{
				PrintMessageFromModule(g_hModule, ERR_DYN_INVALID_PORT);
			}
		}
		dwReturn = CreateName(&pszQMFilterName);
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
		dwReturn = AddQuickModeFilter( pszQMFilterName, pszFilterActionName, ParserTransportlFltr);
	}
	//
	// Tunnel filter data setup
	//
	else
	{
		ParserTunnelFltr.Protocol.ProtocolType = PROTOCOL_UNIQUE;
		ParserTunnelFltr.Protocol.dwProtocol   = dwProtocol;
		ParserTunnelFltr.SrcPort.PortType = PORT_UNIQUE;
		ParserTunnelFltr.SrcPort.wPort = (WORD)dwSrcPort;
		ParserTunnelFltr.DesPort.PortType = PORT_UNIQUE;
		ParserTunnelFltr.DesPort.wPort = (WORD)dwDstPort;
		ParserTunnelFltr.InterfaceType = MMFilter.InterfaceType;
		ParserTunnelFltr.bCreateMirror = FALSE;
		ParserTunnelFltr.InboundFilterAction = Inbound;
		ParserTunnelFltr.OutboundFilterAction = Outbound;
		ParserTunnelFltr.SrcAddr.AddrType = SrcAddr.AddrType;
		ParserTunnelFltr.SrcAddr.uIpAddr = SrcAddr.uIpAddr;
		ParserTunnelFltr.SrcAddr.uSubNetMask = SrcAddr.uSubNetMask;
		ParserTunnelFltr.DesAddr.AddrType = DesAddr.AddrType;
		ParserTunnelFltr.DesAddr.uIpAddr = DesAddr.uIpAddr;
		ParserTunnelFltr.DesAddr.uSubNetMask = DesAddr.uSubNetMask;

		//
		// Fill addr type, mask and uIpaddr for special server for tunnel source
		//
		AddSplAddr(ParserTunnelFltr.SrcTunnelAddr, IP_ANY);
		ParserTunnelFltr.SrcTunnelAddr.pgInterfaceID = NULL;

		//
		// Fill addr type, mask and uIpaddr for special server for tunnel destination
		//
		ParserTunnelFltr.DesTunnelAddr.AddrType = (ParserTunnelFltr.DesTunnelAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
		ParserTunnelFltr.DesTunnelAddr.pgInterfaceID = NULL;

		if(!((ParserTunnelFltr.Protocol.dwProtocol == PROT_ID_TCP) || (ParserTunnelFltr.Protocol.dwProtocol == PROT_ID_UDP)))
		{
			ParserTunnelFltr.SrcPort.wPort = 0;
			ParserTunnelFltr.DesPort.wPort = 0;
			if(bPort)
			{
				PrintMessageFromModule(g_hModule, ERR_DYN_INVALID_PORT);
			}
		}
		dwReturn = CreateName(&pszQMFilterName);
		if(dwReturn == ERROR_SUCCESS)
		{
			dwReturn = AddQuickModeFilter( pszQMFilterName, pszFilterActionName, ParserTunnelFltr);
		}
	}

error:
	CleanupAuthData(&pKerbAuth, &pPskAuth, ppRootcaMMAuth);
	CleanUpLocalRuleDataStructure(pRuleData);
	pRuleData = NULL;
	
	if(ParserTransportlFltr.pszFilterName)
	{
		delete [] ParserTransportlFltr.pszFilterName;
	}

	if(ParserTunnelFltr.pszFilterName)
	{
		delete[] ParserTunnelFltr.pszFilterName;
	}

	if(MMFilter.pszFilterName)
	{
		delete [] MMFilter.pszFilterName;
	}

	if(pszMMPolicyName)
	{
		delete [] pszMMPolicyName;
	}

	if(pszFilterActionName)
	{
		delete [] pszFilterActionName;
	}

	if(pszMMFilterName)
	{
		delete [] pszMMFilterName;
	}

	if(pszQMFilterName)
	{
		delete [] pszQMFilterName;
	}

	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE) && (dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

	return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicSetRule
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
HandleDynamicSetRule(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	PTRANSPORT_FILTER pTransportFltr = NULL;
	PTUNNEL_FILTER pTunnelFltr = NULL;
	PMM_FILTER   pMMFltr = NULL;
	ADDR DesAddr, SrcAddr, SrcTunnel, DstTunnel;
	FILTER_ACTION Inbound = FILTER_ACTION_MAX, Outbound = FILTER_ACTION_MAX;
	IF_TYPE InterfaceType = INTERFACE_TYPE_ALL;
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwNameLen = 0;
	DWORD dwCount = 0, j = 0;
	DWORD dwProtocol = 0;
	DWORD dwSrcPort = 0;
	DWORD dwDstPort = 0;
	DWORD dwSrcSplServer = NOT_SPLSERVER;
	DWORD dwDstSplServer = NOT_SPLSERVER;

	BOOL bTunnel = FALSE;
	BOOL bSrcMask = FALSE;
	BOOL bDstMask = FALSE;
	BOOL bInbound = FALSE;
	BOOL bOutbound = FALSE;
	BOOL bAuth = FALSE;
	BOOL bMirror = TRUE;
	BOOL bSrcMe = FALSE;
	BOOL bIsOutboundBroadcast = FALSE;

	LPTSTR pszMMPolicyName = NULL;
	LPTSTR pszFilterActionName = NULL;

	PRULEDATA pRuleData = new RULEDATA;
	if (pRuleData == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	ZeroMemory(pRuleData, sizeof(RULEDATA));
	PSTA_AUTH_METHODS pKerbAuth = NULL;
	PSTA_AUTH_METHODS pPskAuth = NULL;
	PSTA_MM_AUTH_METHODS *ppRootcaMMAuth = NULL;

	const TAG_TYPE vcmdDynamicSetRule[] =
	{
		{ CMD_TOKEN_STR_SRCADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_DSTADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_PROTO,			NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_SRCPORT,		NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_DSTPORT,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_MIRROR,			NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_CONNTYPE,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_SRCMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_TUNNELDST,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_MMPOLICY,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_QMPOLICY,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_INBOUND,	    NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_OUTBOUND,	    NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_KERB,	        NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_PSK,	        NS_REQ_ZERO,	  FALSE	}
	};
	const TOKEN_VALUE vtokDynamicSetRule[] =
	{
		{ CMD_TOKEN_STR_SRCADDR,		CMD_TOKEN_SRCADDR 		},
		{ CMD_TOKEN_STR_DSTADDR,		CMD_TOKEN_DSTADDR 		},
		{ CMD_TOKEN_STR_PROTO,			CMD_TOKEN_PROTO			},
		{ CMD_TOKEN_STR_SRCPORT,		CMD_TOKEN_SRCPORT		},
		{ CMD_TOKEN_STR_DSTPORT,		CMD_TOKEN_DSTPORT		},
		{ CMD_TOKEN_STR_MIRROR,			CMD_TOKEN_MIRROR		},
		{ CMD_TOKEN_STR_CONNTYPE,		CMD_TOKEN_CONNTYPE		},
		{ CMD_TOKEN_STR_SRCMASK,		CMD_TOKEN_SRCMASK		},
		{ CMD_TOKEN_STR_DSTMASK,		CMD_TOKEN_DSTMASK		},
		{ CMD_TOKEN_STR_TUNNELDST,		CMD_TOKEN_TUNNELDST		},
		{ CMD_TOKEN_STR_MMPOLICY,		CMD_TOKEN_MMPOLICY		},
		{ CMD_TOKEN_STR_QMPOLICY,		CMD_TOKEN_QMPOLICY		},
		{ CMD_TOKEN_STR_INBOUND,	    CMD_TOKEN_INBOUND		},
		{ CMD_TOKEN_STR_OUTBOUND,	    CMD_TOKEN_OUTBOUND		},
		{ CMD_TOKEN_STR_KERB,	        CMD_TOKEN_KERB          },
		{ CMD_TOKEN_STR_PSK,	        CMD_TOKEN_PSK	        }
	};

	const TOKEN_VALUE	vlistDynamicSetRule[] =
	{
		{ CMD_TOKEN_STR_ROOTCA,	        CMD_TOKEN_ROOTCA	    },
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	SrcAddr.uIpAddr = 0x0;
	SrcAddr.AddrType = IP_ADDR_UNIQUE;
	SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

	DesAddr.uIpAddr = 0x0;
	DesAddr.AddrType = IP_ADDR_UNIQUE;
	DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

	SrcTunnel.uIpAddr = 0x0;
	SrcTunnel.AddrType = IP_ADDR_UNIQUE;
	SrcTunnel.uSubNetMask = IP_ADDRESS_MASK_NONE;

	DstTunnel.uIpAddr = 0x0;
	DstTunnel.AddrType = IP_ADDR_UNIQUE;
	DstTunnel.uSubNetMask = IP_ADDRESS_MASK_NONE;

	// Bail out as user has not given sufficient arguments.
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

	parser.ValidTok   = vtokDynamicSetRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicSetRule);

	parser.ValidCmd   = vcmdDynamicSetRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicSetRule);

	parser.ValidList  = vlistDynamicSetRule;
	parser.MaxList    = SIZEOF_TOKEN_VALUE(vlistDynamicSetRule);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicSetRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_MMPOLICY		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN && (LPTSTR)parser.Cmd[dwCount].pArg)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pszMMPolicyName = new _TCHAR[dwNameLen];
					if(pszMMPolicyName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pszMMPolicyName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			case CMD_TOKEN_QMPOLICY	:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN && (LPTSTR)parser.Cmd[dwCount].pArg)
				{
					dwNameLen = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg)+1;
					pszFilterActionName = new _TCHAR[dwNameLen];
					if(pszFilterActionName == NULL)
					{
						dwReturn = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pszFilterActionName, (LPTSTR)parser.Cmd[dwCount].pArg, dwNameLen);
				}
				break;
			case CMD_TOKEN_MIRROR		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bMirror = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_CONNTYPE		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					switch(*(DWORD *)parser.Cmd[dwCount].pArg)
					{
						case INTERFACE_TYPE_ALL:
							InterfaceType = INTERFACE_TYPE_ALL;
							break;
						case INTERFACE_TYPE_LAN:
							InterfaceType = INTERFACE_TYPE_LAN;
							break;
						case INTERFACE_TYPE_DIALUP:
							InterfaceType = INTERFACE_TYPE_DIALUP;
							break;
						default :
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ME:
						case IP_ANY:
							dwDstSplServer = parser.Cmd[dwCount].dwStatus;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					DesAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bDstMask = TRUE;
				}
				break;
			case CMD_TOKEN_SRCADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case IP_ME:
							bSrcMe = TRUE;
							// fallthrough
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ANY:
							dwSrcSplServer = parser.Cmd[dwCount].dwStatus;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_SRCMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					SrcAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bSrcMask = TRUE;
				}
				break;
			case CMD_TOKEN_INBOUND		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bInbound = TRUE;
					if(*(DWORD *)parser.Cmd[dwCount].pArg==1)
					{
						Inbound = PASS_THRU;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
					{
						Inbound = BLOCKING;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==3)
					{
						Inbound = NEGOTIATE_SECURITY;
					}
					else
					{
						bInbound = FALSE;
					}
				}
				break;
			case CMD_TOKEN_OUTBOUND			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bOutbound = TRUE;
					if(*(DWORD *)parser.Cmd[dwCount].pArg==1)
					{
						Outbound = PASS_THRU;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
					{
						Outbound = BLOCKING;
					}
					else if(*(DWORD *)parser.Cmd[dwCount].pArg==3)
					{
						Outbound = NEGOTIATE_SECURITY;
					}
					else
					{
						bOutbound = FALSE;
					}
				}
				break;
			case CMD_TOKEN_SRCPORT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwSrcPort = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_DSTPORT			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwDstPort = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_PROTO			:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwProtocol = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_TUNNELDST		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							DstTunnel.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							ADDR addr;
							addr.uIpAddr = htonl(DstTunnel.uIpAddr);
							addr.uSubNetMask = IP_ADDRESS_MASK_NONE;
							bTunnel = TRUE;
							if (!IsValidTunnelEndpointAddress(&addr))
							{
								dwReturn = ERROR_INVALID_PARAMETER;
								BAIL_OUT;
							}
							break;
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ME:
						case IP_ANY:
						default:
							PrintMessageFromModule(g_hModule, ADD_STATIC_RULE_INVALID_TUNNEL);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_KERB             :
							if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pKerbAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_PSK			:
							if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pPskAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_ROOTCA		:
							// this case is special, handled below...
							break;
			default							:
				break;
		}
	}

	size_t uiRootcaIndex = parser.MaxTok;
	if (parser.Cmd[uiRootcaIndex].dwStatus > 0)
	{
		pRuleData->bAuthMethodSpecified = TRUE;
		pRuleData->AuthInfos.dwNumAuthInfos += parser.Cmd[uiRootcaIndex].dwStatus;
		ppRootcaMMAuth = (PSTA_MM_AUTH_METHODS *)(parser.Cmd[uiRootcaIndex].pArg);
	}

	dwReturn = AddAllAuthMethods(pRuleData, pKerbAuth, pPskAuth, ppRootcaMMAuth, FALSE);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	//
	// Invalid conditions
	//
	if((dwSrcSplServer != NOT_SPLSERVER) && (dwDstSplServer != NOT_SPLSERVER)
		&& (dwSrcSplServer != IP_ME) && (dwSrcSplServer != IP_ANY)
		&& (dwDstSplServer != IP_ME) && (dwDstSplServer != IP_ANY))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_PARSER_ADDRTYPE);
		dwReturn = ERROR_NO_DISPLAY;
		BAIL_OUT;
	}

	//
	// Source address setting up
	//
	if(dwSrcSplServer == NOT_SPLSERVER)
	{
		SrcAddr.AddrType = (SrcAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
	}
	else
	{
		AddSplAddr(SrcAddr, dwSrcSplServer);
	}

	//
	// Destination address setting up
	//
	if(dwDstSplServer == NOT_SPLSERVER)
	{
		DesAddr.AddrType = (DesAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
	}
	else
	{
		AddSplAddr(DesAddr, dwDstSplServer);
	}

	ADDR tmpAddr;
	tmpAddr.uIpAddr = ntohl(DesAddr.uIpAddr);
	tmpAddr.uSubNetMask = ntohl(DesAddr.uSubNetMask);
	if (IsBroadcastAddress(&tmpAddr) || IsMulticastAddress(&tmpAddr))
	{
		if (bMirror || !bSrcMe ||
			((Inbound == NEGOTIATE_SECURITY) || (Outbound == NEGOTIATE_SECURITY))
			)
		{
			dwReturn = ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}
		if (IsBroadcastAddress(&tmpAddr))
		{
			bIsOutboundBroadcast = TRUE;
		}
	}

	//
	// Check if the given MMFilter spec exists
	if (bTunnel)
	{
		AddSplAddr(SrcTunnel, IP_ME);
		if(FindAndGetMMFilterRule(SrcTunnel, DstTunnel, TRUE, InterfaceType, bSrcMask, bDstMask, &pMMFltr, dwReturn))
		{
			dwReturn = SetDynamicMMFilterRule( pszMMPolicyName, *(pMMFltr), pRuleData->AuthInfos);
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_RULE_NO_MMFILTER);
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
	}
	else
	{
		// no MM filter if outbound is broadcast and not a tunnel rule
		if (!bIsOutboundBroadcast)
		{
			if(FindAndGetMMFilterRule(SrcAddr, DesAddr, bMirror, InterfaceType, bSrcMask, bDstMask, &pMMFltr, dwReturn))
			{
				dwReturn = SetDynamicMMFilterRule( pszMMPolicyName, *(pMMFltr), pRuleData->AuthInfos);
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_RULE_NO_MMFILTER);
				dwReturn = ERROR_SUCCESS;
				BAIL_OUT;
			}
		}
	}
	//
	// Check if the given Transport spec exists
	//
	if(!bTunnel)
	{
		if(FindAndGetTransportRule(SrcAddr, DesAddr, bMirror, InterfaceType, dwProtocol, dwSrcPort, dwDstPort,
								bSrcMask, bDstMask, &pTransportFltr, dwReturn))
		{
			dwReturn = SetTransportRule(*(pTransportFltr), pszFilterActionName, Inbound, Outbound);
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_RULE_NO_TRANSPORT);
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
	}
	//
	// Check if the given Tunnel spec exists
	//
	else
	{
		AddSplAddr(SrcTunnel, IP_ANY);
		if(FindAndGetTunnelRule(SrcAddr, DesAddr, bMirror, InterfaceType, dwProtocol, dwSrcPort, dwDstPort,
				bSrcMask, bDstMask, SrcTunnel, DstTunnel, &pTunnelFltr, dwReturn))
		{
			dwReturn = SetTunnelRule(*(pTunnelFltr), pszFilterActionName, Inbound, Outbound);
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_RULE_NO_TUNNEL);
			dwReturn = ERROR_SUCCESS;
		}
	}

error:
	CleanupAuthData(&pKerbAuth, &pPskAuth, ppRootcaMMAuth);
	CleanUpLocalRuleDataStructure(pRuleData);
	pRuleData = NULL;

	if(pszMMPolicyName)
	{
		delete [] pszMMPolicyName;
	}

	if(pszFilterActionName)
	{
		delete [] pszFilterActionName;
	}

	if(pMMFltr)
	{
		if(pMMFltr->pszFilterName)
		{
			delete [] pMMFltr->pszFilterName;
		}
		delete pMMFltr;
	}

	if(pTransportFltr)
	{
		if(pTransportFltr->pszFilterName)
		{
			delete [] pTransportFltr->pszFilterName;
		}
		delete pTransportFltr;
	}

	if(pTunnelFltr)
	{
		if(pTunnelFltr->pszFilterName)
		{
			delete [] pTunnelFltr->pszFilterName;
		}
		delete pTunnelFltr;
	}

	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}

	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	DeleteIfLastRuleOfMMFilter
//
//	Date of Creation:	05-19-02
//
//	Parameters		:	IN ADDR SrcAddr,
//						IN ADDR DstAddr,
//						IN BOOL bMirror,
//						IN IF_TYPE ConType,
//						IN BOOL bSrcMask,
//						IN BOOL bDstMask,
//						IN OUT DWORD& dwStatus
//
//Return			:	BOOL
//
//Description		:	Deterimines if there exists any transport or tunnel filters
//                      may require a MM filter.  If not, then it deletes the
//                      respective MM filter.
//
//Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
DeleteIfLastRuleOfMMFilter(
	IN ADDR SrcAddr,
	IN ADDR DesAddr,
	IN BOOL bMirror,
	IN IF_TYPE InterfaceType,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN OUT DWORD& dwStatus
	)
{
	BOOL bLastRuleOfMMFilter = FALSE;
	DWORD dwReturn = ERROR_SUCCESS;
	PMM_FILTER   pMMFltr = NULL;
	
	bLastRuleOfMMFilter = IsLastRuleOfMMFilter(
							SrcAddr,
							DesAddr,
							bMirror,
							InterfaceType,
							bSrcMask,
							bDstMask,
							dwReturn
							);
	if (!dwReturn && bLastRuleOfMMFilter) {
		//
		// Check if the given MMFilter spec exists
		//
		
		if(FindAndGetMMFilterRule(SrcAddr, DesAddr, bMirror, InterfaceType, bSrcMask, bDstMask, &pMMFltr, dwReturn))
		{
			dwReturn = DeleteMMFilterRule(*(pMMFltr));
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_RULE_NO_MMFILTER);
			dwReturn = ERROR_SUCCESS;		//This is to support multiple QMFilters will have
			BAIL_OUT;						//single MMFilter
		}
	}

error:
	dwStatus = dwReturn;
	
	if(pMMFltr)
	{
		if(pMMFltr->pszFilterName)
			delete [] pMMFltr->pszFilterName;
		delete pMMFltr;
	}
	
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleDynamicDeleteRule
//
//	Date of Creation: 	9-23-2001
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			:	DWORD
//
//	Description		:
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleDynamicDeleteRule(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	PTRANSPORT_FILTER pTransportFltr = NULL;
	PTUNNEL_FILTER pTunnelFltr = NULL;
	ADDR DesAddr, SrcAddr, SrcTunnel, DstTunnel;
	IF_TYPE InterfaceType = INTERFACE_TYPE_ALL;
	DWORD dwReturn = ERROR_SHOW_USAGE;
	DWORD dwCount = 0;
	DWORD dwProtocol = 0;
	DWORD dwSrcPort = 0;
	DWORD dwDstPort = 0;
	DWORD dwSrcSplServer = NOT_SPLSERVER;
	DWORD dwDstSplServer = NOT_SPLSERVER;
	BOOL bTunnel = FALSE;
	BOOL bSrcMask = FALSE;
	BOOL bDstMask = FALSE;
	BOOL bMirror = TRUE;
	const TAG_TYPE vcmdDynamicDeleteRule[] =
	{
		{ CMD_TOKEN_STR_SRCADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_DSTADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_PROTO,			NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_SRCPORT,		NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_DSTPORT,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_MIRROR,			NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_CONNTYPE,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_SRCMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_TUNNELDST,		NS_REQ_ZERO,	  FALSE	}
	};
	const TOKEN_VALUE vtokDynamicDeleteRule[] =
	{
		{ CMD_TOKEN_STR_SRCADDR,		CMD_TOKEN_SRCADDR 		},
		{ CMD_TOKEN_STR_DSTADDR,		CMD_TOKEN_DSTADDR 		},
		{ CMD_TOKEN_STR_PROTO,			CMD_TOKEN_PROTO			},
		{ CMD_TOKEN_STR_SRCPORT,		CMD_TOKEN_SRCPORT		},
		{ CMD_TOKEN_STR_DSTPORT,		CMD_TOKEN_DSTPORT		},
		{ CMD_TOKEN_STR_MIRROR,			CMD_TOKEN_MIRROR		},
		{ CMD_TOKEN_STR_CONNTYPE,		CMD_TOKEN_CONNTYPE		},
		{ CMD_TOKEN_STR_SRCMASK,		CMD_TOKEN_SRCMASK		},
		{ CMD_TOKEN_STR_DSTMASK,		CMD_TOKEN_DSTMASK		},
		{ CMD_TOKEN_STR_TUNNELDST,		CMD_TOKEN_TUNNELDST		}
	};
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	SrcAddr.uIpAddr = 0x0;
	SrcAddr.AddrType = IP_ADDR_UNIQUE;
	SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

	DesAddr.uIpAddr = 0x0;
	DesAddr.AddrType = IP_ADDR_UNIQUE;
	DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

	SrcTunnel.uIpAddr = 0x0;
	SrcTunnel.AddrType = IP_ADDR_UNIQUE;
	SrcTunnel.uSubNetMask = IP_ADDRESS_MASK_NONE;

	DstTunnel.uIpAddr = 0x0;
	DstTunnel.AddrType = IP_ADDR_UNIQUE;
	DstTunnel.uSubNetMask = IP_ADDRESS_MASK_NONE;

	//
	// Bail out as user has not given sufficient arguments.
	//
	if(dwArgCount <= 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}
	parser.ValidTok   = vtokDynamicDeleteRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokDynamicDeleteRule);

	parser.ValidCmd   = vcmdDynamicDeleteRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdDynamicDeleteRule);

	//
	// Get the user input after parsing the data
	//
	dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturn != ERROR_SUCCESS)
	{
		if(dwReturn == RETURN_NO_ERROR)
		{
			dwReturn = ERROR_NO_DISPLAY;
			BAIL_OUT;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
			BAIL_OUT;
		}
	}
	//
	// Check for user given tokens from the parser and copy into local variables
	//
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokDynamicDeleteRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_MIRROR		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					bMirror = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_CONNTYPE		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					switch(*(DWORD *)parser.Cmd[dwCount].pArg)
					{
						case INTERFACE_TYPE_ALL:
							InterfaceType = INTERFACE_TYPE_ALL;
							break;
						case INTERFACE_TYPE_LAN:
							InterfaceType = INTERFACE_TYPE_LAN;
							break;
						case INTERFACE_TYPE_DIALUP:
							InterfaceType = INTERFACE_TYPE_DIALUP;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ME:
						case IP_ANY:
							dwDstSplServer = parser.Cmd[dwCount].dwStatus;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							DesAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_SRCADDR 		:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// Special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ME:
						case IP_ANY:
							dwSrcSplServer = parser.Cmd[dwCount].dwStatus;
							break;
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							SrcAddr.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							break;
						default:
							PrintMessageFromModule(g_hModule, ERROR_PARSER_ADDR);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			case CMD_TOKEN_DSTMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					DesAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bDstMask = TRUE;
				}
				break;
			case CMD_TOKEN_SRCMASK 		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					SrcAddr.uSubNetMask = *(IPAddr *)parser.Cmd[dwCount].pArg;
					bSrcMask = TRUE;
				}
				break;
			case CMD_TOKEN_SRCPORT		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwSrcPort = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_DSTPORT		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwDstPort = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_PROTO		:
				if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
				{
					dwProtocol = *(DWORD *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_TUNNELDST	:
				if (parser.Cmd[dwCount].dwStatus)
				{
					//
					// Special servers id is available in dwStatus
					//
					switch(parser.Cmd[dwCount].dwStatus)
					{
						case NOT_SPLSERVER:
							//
							// if it is not special server get the user given IP address
							//
							DstTunnel.uIpAddr = *(IPAddr *)parser.Cmd[dwCount].pArg;
							bTunnel = TRUE;
							ADDR addr;
							addr.uIpAddr = htonl(DstTunnel.uIpAddr);
							addr.uSubNetMask = IP_ADDRESS_MASK_NONE;
							
							if (!IsValidTunnelEndpointAddress(&addr))
							{
								dwReturn = ERROR_INVALID_PARAMETER;
								BAIL_OUT;
							}
							break;
						case SERVER_WINS:
						case SERVER_DHCP:
						case SERVER_DNS:
						case SERVER_GATEWAY:
						case IP_ME:
						case IP_ANY:
						default:
							PrintMessageFromModule(g_hModule, ADD_STATIC_RULE_INVALID_TUNNEL);
							dwReturn = ERROR_NO_DISPLAY;
							BAIL_OUT;
							break;
					}
				}
				break;
			default						:
				break;
		}
	}

	if((dwSrcSplServer != NOT_SPLSERVER) && (dwDstSplServer != NOT_SPLSERVER)
		&& (dwSrcSplServer != IP_ME) && (dwSrcSplServer != IP_ANY)
		&& (dwDstSplServer != IP_ME) && (dwDstSplServer != IP_ANY))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_PARSER_ADDRTYPE);
		dwReturn = ERROR_NO_DISPLAY;
		BAIL_OUT;
	}

	//
	// Source address setting up
	//
	if(dwSrcSplServer == NOT_SPLSERVER)
	{
		SrcAddr.AddrType = (SrcAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
	}
	else
	{
		AddSplAddr(SrcAddr, dwSrcSplServer);
	}

	//
	// Destination address setting up
	//
	if(dwDstSplServer == NOT_SPLSERVER)
	{
		DesAddr.AddrType = (DesAddr.uSubNetMask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
	}
	else
	{
		AddSplAddr(DesAddr, dwDstSplServer);
	}

	if(!bTunnel)
	{
		//
		// Check if the given Transport  filter spec exists
		//
		if(FindAndGetTransportRule(SrcAddr, DesAddr, bMirror, InterfaceType, dwProtocol, dwSrcPort, dwDstPort,
											bSrcMask, bDstMask, &pTransportFltr, dwReturn))
		{
			dwReturn = DeleteTransportRule(*(pTransportFltr));

			BAIL_ON_WIN32_ERROR(dwReturn);
			dwReturn = DeleteIfLastRuleOfMMFilter(
							SrcAddr,
							DesAddr,
							bMirror,
							InterfaceType,
							bSrcMask,
							bDstMask,
							dwReturn
							);
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_RULE_NO_TRANSPORT);
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

	}
	//
	// Check if the given Tunnel filter spec exists
	//
	else
	{
		AddSplAddr(SrcTunnel, IP_ANY);

		if(FindAndGetTunnelRule(SrcAddr, DesAddr, bMirror, InterfaceType, dwProtocol, dwSrcPort, dwDstPort,
				bSrcMask, bDstMask, SrcTunnel, DstTunnel, &pTunnelFltr, dwReturn))
		{
			dwReturn = DeleteTunnelRule(*(pTunnelFltr));
			BAIL_ON_WIN32_ERROR(dwReturn);

			AddSplAddr(SrcTunnel, IP_ME);
			dwReturn = DeleteIfLastRuleOfMMFilter(
							SrcTunnel,
							DstTunnel,
							TRUE,
							InterfaceType,
							FALSE, 			// bSrcMask
							FALSE, 			// bDstMask
							dwReturn
							);
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_RULE_NO_TUNNEL);
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
	}


error:
	if(dwArgCount > 3)
	{
		CleanUp();
	}

	if(pTransportFltr)
	{
		if(pTransportFltr->pszFilterName)
			delete [] pTransportFltr->pszFilterName;
		delete pTransportFltr;
	}
	if(pTunnelFltr)
	{
		if(pTunnelFltr->pszFilterName)
			delete [] pTunnelFltr->pszFilterName;
		delete pTunnelFltr;
	}
	if((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_SHOW_USAGE)&&(dwReturn != ERROR_NO_DISPLAY))
	{
		//api errors
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_SUCCESS;
	}
	//already one error displayed.
	if(dwReturn == ERROR_NO_DISPLAY)
	{
		dwReturn = ERROR_SUCCESS;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	AddSplAddr
//
//	Date of Creation: 	11-23-2001
//
//	Parameters		:
//						IN OUT ADDR& Addr,
//						IN DWORD dwSplServer
//	Return			: 	VOID
//
//	Description		: 	Adds a special server addr.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
AddSplAddr(
	IN OUT ADDR& Addr,
	IN DWORD dwSplServer
	)
{
	//
	// Fill up addr type, mask and uIpaddr for special servers
	//
	switch(dwSplServer)
	{
		case SERVER_WINS:
			Addr.AddrType  	 = IP_ADDR_WINS_SERVER;
			Addr.uIpAddr 	 = IP_ADDRESS_ME;
			Addr.uSubNetMask = IP_ADDRESS_MASK_NONE;
			break;
		case SERVER_DHCP:
			Addr.AddrType 	 = IP_ADDR_DHCP_SERVER;
			Addr.uIpAddr 	 = IP_ADDRESS_ME;
			Addr.uSubNetMask = IP_ADDRESS_MASK_NONE;
			break;
		case SERVER_DNS:
			Addr.AddrType    = IP_ADDR_DNS_SERVER;
			Addr.uIpAddr 	 = IP_ADDRESS_ME;
			Addr.uSubNetMask = IP_ADDRESS_MASK_NONE;
			break;
		case SERVER_GATEWAY:
			Addr.AddrType 	 = IP_ADDR_DEFAULT_GATEWAY;
			Addr.uIpAddr 	 = IP_ADDRESS_ME;
			Addr.uSubNetMask = IP_ADDRESS_MASK_NONE;
			break;
		case IP_ME:
			Addr.AddrType 	 = IP_ADDR_UNIQUE;
			Addr.uIpAddr 	 = IP_ADDRESS_ME;
			Addr.uSubNetMask = IP_ADDRESS_MASK_NONE;
			break;
		case IP_ANY:
			Addr.AddrType 	 = IP_ADDR_SUBNET;
			Addr.uIpAddr 	 = SUBNET_ADDRESS_ANY;
			Addr.uSubNetMask = SUBNET_MASK_ANY;
			break;
		default:
			break;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\dynamicdelete.h ===
////////////////////////////////////////////////////////////////////////
//
// 	Module: Dynamic/dyanamicDelete.h
//
// 	Purpose			: Dynamic Delete Implementation.
//
//
// 	Developers Name	: Bharat/Radhika
//
//
//	History			:
//
//  Date			Author		Comments
//  9-13-2001   	Radhika		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#ifndef _DYNAMICDELETE_H_
#define _DYNAMICDELETE_H_

DWORD
DeleteQMPolicy(
	IN LPTSTR pszShowPolicyName
	);

DWORD
DeleteMMPolicy(
	IN LPTSTR pszShowPolicyName
	);

DWORD
DeleteMMFilters(
	VOID
	);

DWORD
DeleteMMFilterRule(
	IN MM_FILTER& MMFilter
	);

DWORD
DeleteTransportFilters(
	VOID
	);

DWORD
DeleteTunnelFilters(
	VOID
	);

DWORD
DeleteTransportRule(
	IN TRANSPORT_FILTER& TransportFilter
	);

DWORD
DeleteTunnelRule(
	IN TUNNEL_FILTER& TunnelFilter
	);

DWORD
DeleteAuthMethods(
	VOID
	);

DWORD
GetMaxCountMMFilters(
	DWORD& dwMaxCount
	);

DWORD
GetMaxCountTransportFilters(
	DWORD& dwMaxCount
	);

DWORD
GetMaxCountTunnelFilters(
	DWORD& dwMaxCount
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\dynamicadd.cpp ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: Dynamic/DyanamicAdd.cpp
//
// 	Purpose			: Dynamic Module Implementation.
//
//
// 	Developers Name	: Bharat/Radhika
//
//  Description     : All functions are related to add and set functionality.
//
//
//	History			:
//
//  Date			Author		Comments
//  8-10-2001   	Bharat		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern HKEY g_hGlobalRegistryKey;
extern _TCHAR* g_szDynamicMachine;

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	AddMainModePolicy
//
//	Date of Creation:	09-22-01
//
//	Parameters		: 	IN LPTSTR pPolicyName,
//						IN IPSEC_MM_POLICY& MMPol
//
//	Return			:	DWORD
//
//	Description		:	This function adds a Main Mode policy into the SPD
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
AddMainModePolicy(
	IN LPTSTR pPolicyName,
	IN IPSEC_MM_POLICY& MMPol
	)
{
	PIPSEC_MM_POLICY   pMMPol = NULL;
	RPC_STATUS RpcStat;

	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	DWORD dwNameLen = 0;

	BOOL bExists = FALSE;

	//
	// check if policy already exists
	//
	dwReturn = GetMMPolicy(g_szDynamicMachine, dwVersion, pPolicyName, &pMMPol, NULL);

	if (dwReturn == ERROR_SUCCESS)
	{
		bExists = TRUE;
		BAIL_OUT;
	}

	//
	// allocate memory for the policy name
	//
	MMPol.pszPolicyName = NULL;
	dwNameLen = _tcslen(pPolicyName) + 1;

	MMPol.pszPolicyName = new _TCHAR[dwNameLen];
	if(MMPol.pszPolicyName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	_tcsncpy(MMPol.pszPolicyName,pPolicyName,dwNameLen);

	//
	// generate GUID for mmpolicy id
	//
	RpcStat = UuidCreate(&(MMPol.gPolicyID));
	if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}
	//dwReturn value is checked in the parent function for success or failure
	dwReturn = AddMMPolicy(g_szDynamicMachine, dwVersion, 0, &MMPol, NULL);

error:

	if(bExists)
	{
		//functionality error
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_MMP_MMPOLICY_EXISTS);
		dwReturn = ERROR_NO_DISPLAY;
	}
	//error path clean up
	if(MMPol.pszPolicyName)
	{
		delete [] MMPol.pszPolicyName;
		MMPol.pszPolicyName = NULL;
	}

	if(pMMPol)
	{
		SPDApiBufferFree(pMMPol);
		pMMPol = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	SetMainModePolicy
//
//	Date of Creation:	22-09-01
//
//	Parameters		: 	IN LPTSTR pPolicyName,
//						IN IPSEC_MM_POLICY& MMPol
//
//	Return			:	DWORD
//
//	Description		:	This Function sets a main mode policy. It sets all the parameters
//            			except the name.
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
SetMainModePolicy(
	IN LPTSTR pPolicyName,
	IN IPSEC_MM_POLICY& MMPol
	)
{

	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	//dwReturn value is checked in the parent function
	dwReturn = SetMMPolicy(g_szDynamicMachine, dwVersion, pPolicyName, &MMPol, NULL);

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	LoadMMOffersDefaults
//
//	Date of Creation:	09-22-01
//
//	Parameters		: 	OUT IPSEC_MM_POLICY & MMPolicy
//
//	Return			:	DWORD
//
//	Description		: 	Loads the Main Mode policy defaults into the IPSEC_MM_POLICY structure.
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
LoadMMOffersDefaults(
	OUT IPSEC_MM_POLICY & MMPolicy
	)
{
	DWORD dwReturn = ERROR_SUCCESS;

	MMPolicy.dwOfferCount = 3;
	MMPolicy.pOffers = NULL;
	MMPolicy.pOffers = new IPSEC_MM_OFFER[MMPolicy.dwOfferCount];
	if(MMPolicy.pOffers == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	memset(MMPolicy.pOffers, 0, sizeof(IPSEC_MM_OFFER) * MMPolicy.dwOfferCount);

	//
	// initialize
	//
	for (UINT i = 0; i < MMPolicy.dwOfferCount; ++i)
	{
	  MMPolicy.pOffers[i].dwQuickModeLimit = POTF_DEFAULT_P1REKEY_QMS;
	  MMPolicy.pOffers[i].Lifetime.uKeyExpirationKBytes = 0;
	  MMPolicy.pOffers[i].Lifetime.uKeyExpirationTime = POTF_DEFAULT_P1REKEY_TIME;
	}

	MMPolicy.pOffers[0].EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
	MMPolicy.pOffers[0].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	MMPolicy.pOffers[0].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;
	MMPolicy.pOffers[0].HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_SHA1;
	MMPolicy.pOffers[0].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	MMPolicy.pOffers[0].dwDHGroup = (DWORD)POTF_OAKLEY_GROUP2;

	MMPolicy.pOffers[1].EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
	MMPolicy.pOffers[1].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	MMPolicy.pOffers[1].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;
	MMPolicy.pOffers[1].HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_MD5;
	MMPolicy.pOffers[1].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	MMPolicy.pOffers[1].dwDHGroup = (DWORD)POTF_OAKLEY_GROUP2;

	MMPolicy.pOffers[2].EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
	MMPolicy.pOffers[2].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	MMPolicy.pOffers[2].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;
	MMPolicy.pOffers[2].HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_SHA1;
	MMPolicy.pOffers[2].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	MMPolicy.pOffers[2].dwDHGroup = (DWORD)POTF_OAKLEY_GROUP2048;

error:
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	AddQuickModePolicy
//
//	Date of Creation:	09-22-01
//
//	Parameters		: 	IN LPTSTR pPolicyName,
//						IN BOOL bDefault,
//						IN BOOL bSoft,
//						IN IPSEC_QM_POLICY& QMPol
//	Return			: 	DWORD
//
//	Description		:	This function adds a quick mode policy into the SPD
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
AddQuickModePolicy(
	IN LPTSTR pPolicyName,
	IN BOOL bDefault,
	IN BOOL bSoft,
	IN IPSEC_QM_POLICY& QMPol)
{
	PIPSEC_QM_POLICY pQMPol = NULL;
	RPC_STATUS RpcStat = RPC_S_OK;

	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	DWORD dwNameLen = 0;

	BOOL bExists = FALSE;

	//
	// Check if the policy already exists
	//
	dwReturn = GetQMPolicy(g_szDynamicMachine, dwVersion, pPolicyName, 0, &pQMPol, NULL);
	if (dwReturn == ERROR_SUCCESS)
	{
		bExists = TRUE;
		BAIL_OUT;
	}

	//
	// Fill up QM policy GUID
	//
	RpcStat = UuidCreate(&(QMPol.gPolicyID));

	if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}
	dwNameLen = _tcslen(pPolicyName) + 1;

	//
	// Allocate memory for the name
	//
	QMPol.pszPolicyName = NULL;
	QMPol.pszPolicyName = new _TCHAR[dwNameLen];
	if(QMPol.pszPolicyName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	_tcsncpy(QMPol.pszPolicyName, pPolicyName, dwNameLen);

	if(bDefault)
	{
		QMPol.dwFlags |= IPSEC_QM_POLICY_DEFAULT_POLICY;
	}
	if(bSoft)
	{
		QMPol.dwFlags |= IPSEC_QM_POLICY_ALLOW_SOFT;
	}

	//
	// Add the QM Policy
	//
	dwReturn = AddQMPolicy(g_szDynamicMachine, dwVersion,0, &QMPol, NULL);

error:
	if(bExists)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_QMP_QMPOLICY_EXISTS);
		dwReturn = ERROR_NO_DISPLAY;
	}
	//error path clean up
	if(QMPol.pszPolicyName)
	{
		delete[] QMPol.pszPolicyName;
		QMPol.pszPolicyName = NULL;
	}

	if(pQMPol)
	{
		SPDApiBufferFree(pQMPol);
		pQMPol = NULL;
	}
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	SetQuickModePolicy
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	IN LPTSTR pPolicyName,
//						IN PIPSEC_QM_POLICY pQMPol
//
//	Return: 			DWORD
//
//	Description		:	This sets the quick mode policy into the SPD.
//						Except the name, all other parameters can be modified
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
SetQuickModePolicy(
	IN LPTSTR pPolicyName,
	IN PIPSEC_QM_POLICY pQMPol
	)
{

	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;

	dwReturn = SetQMPolicy(g_szDynamicMachine, dwVersion, pPolicyName, pQMPol, NULL);

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	AddQuickModeFilter
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	IN LPTSTR pFilterName,
//						IN LPTSTR pPolicyName,
//						IN TRANSPORT_FILTER& TrpFltr
//
//	Return			:	DWORD
//
//	Description		:	This function adds the Quick Mode Transport Filter into SPD
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
AddQuickModeFilter(
	IN LPTSTR pFilterName,
	IN LPTSTR pPolicyName,
	IN TRANSPORT_FILTER& TrpFltr
	)
{
	PIPSEC_QM_POLICY   pQMPol = NULL;
	RPC_STATUS RpcStat = RPC_S_OK;
	HANDLE hTrpFilter = NULL;
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwNameLen = 0;
	DWORD dwVersion = 0;
	BOOL bQMPExists = FALSE;
	TrpFltr.pszFilterName = NULL;

	if(pPolicyName == NULL)
	{
		//
		// Create a NULL GUID if qmpolicy does not exist
		//
		RpcStat = UuidCreateNil(&(TrpFltr.gPolicyID));
		if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
		{
			dwReturn = ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}
		bQMPExists = TRUE;
	}
	else
	{
		//
		// Get the corresponding QMPolicy GUID if it exists
		//
		dwReturn = GetQMPolicy(g_szDynamicMachine, dwVersion, pPolicyName, 0, &pQMPol, NULL);
		if (!((dwReturn == ERROR_SUCCESS) && pQMPol))
		{
			BAIL_OUT;
		}

		TrpFltr.gPolicyID = pQMPol->gPolicyID;
		bQMPExists = TRUE;
	}

	//
	// Create Transport Filter GUID
	//
	RpcStat = UuidCreate(&(TrpFltr.gFilterID));
	if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}
	dwNameLen = _tcslen(pFilterName) + 1;

	//
	// Allocate memory for the name field
	//
	TrpFltr.pszFilterName = new _TCHAR[dwNameLen];
	if(TrpFltr.pszFilterName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	_tcsncpy(TrpFltr.pszFilterName, pFilterName, dwNameLen);

	TrpFltr.dwFlags = 0;
	TrpFltr.IpVersion = IPSEC_PROTOCOL_V4;
	dwReturn = AddTransportFilter(g_szDynamicMachine, dwVersion, 0, &TrpFltr,NULL, &hTrpFilter);

	if (dwReturn == ERROR_SUCCESS)
	{
		dwReturn = CloseTransportFilterHandle(hTrpFilter);
	}

error:

	if(!bQMPExists)
	{
		//functionality errors
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_QMF_NO_QMPOLICY);
		dwReturn = ERROR_NO_DISPLAY;
	}

	//error path clean up
	if(TrpFltr.pszFilterName)
	{
		delete [] TrpFltr.pszFilterName;
		TrpFltr.pszFilterName = NULL;
	}
	if(pQMPol)
	{
		SPDApiBufferFree(pQMPol);
		pQMPol = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function:AddQuickModeFilter
//
//Date of Creation:09-22-01
//
//Parameters:		IN LPTSTR pFilterName,
//					IN LPTSTR pPolicyName,
//					IN TUNNEL_FILTER& TunnelFltr
//
//Return: 			DWORD
//
//Description:This function adds the quick mode tunnel filter into the SPD
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
AddQuickModeFilter(
	IN LPTSTR pFilterName,
	IN LPTSTR pPolicyName,
	IN TUNNEL_FILTER& TunnelFltr
	)
{
	PIPSEC_QM_POLICY pQMPol = NULL;
	RPC_STATUS RpcStat = RPC_S_OK;
	HANDLE hTrpFilter = NULL;
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwNameLen = 0;
	DWORD dwVersion = 0;
	BOOL bQMPExists = FALSE;
	TunnelFltr.pszFilterName = NULL;

	if(pPolicyName == NULL)
	{
		//Create a NULL GUID if qmpolicy does not exist
		RpcStat = UuidCreateNil(&(TunnelFltr.gPolicyID));
		if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
		{
			dwReturn = ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}
		bQMPExists = TRUE;
	}
	else
	{
		//Get the corresponding QMPolicy GUID if it exists
		dwReturn = GetQMPolicy(g_szDynamicMachine,dwVersion, pPolicyName, 0, &pQMPol, NULL);
		if (!((dwReturn == ERROR_SUCCESS) && pQMPol))
		{
			BAIL_OUT;
		}
		TunnelFltr.gPolicyID = pQMPol->gPolicyID;
		bQMPExists = TRUE;
	}
	//Create Tunnel Filter GUID
	RpcStat = UuidCreate(&(TunnelFltr.gFilterID));
	if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}

	dwNameLen = _tcslen(pFilterName) + 1;
	// Allocate memory for the name field
	TunnelFltr.pszFilterName = new _TCHAR[dwNameLen];
	if(TunnelFltr.pszFilterName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	_tcsncpy(TunnelFltr.pszFilterName, pFilterName, dwNameLen);
	TunnelFltr.dwFlags = 0;

	TunnelFltr.IpVersion = IPSEC_PROTOCOL_V4;
	dwReturn = AddTunnelFilter(g_szDynamicMachine, dwVersion, 0, &TunnelFltr, NULL, &hTrpFilter);
	if (dwReturn == ERROR_SUCCESS)
	{
		dwReturn = CloseTunnelFilterHandle(hTrpFilter);

	}

error:

	if(!bQMPExists)
	{
		//functionality errors
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_QMF_NO_QMPOLICY);
		dwReturn = ERROR_NO_DISPLAY;
	}
	//error path clean up
	if(pQMPol)
	{
		SPDApiBufferFree(pQMPol);
		pQMPol = NULL;
	}

	if(TunnelFltr.pszFilterName)
	{
		delete [] TunnelFltr.pszFilterName;
		TunnelFltr.pszFilterName = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function:AddMainModeFilter
//
//Date of Creation:09-22-01
//
//Parameters:			IN LPTSTR pFilterName,
//						IN LPTSTR pPolicyName,
//						IN MM_FILTER& MMFilter,
//						IN INT_MM_AUTH_METHODS& ParserAuthMethod
//
//Return: 				DWORD
//
//Description:This function adds the main mode filter into the SPD
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
AddMainModeFilter(
	IN LPTSTR pFilterName,
	IN LPTSTR pPolicyName,
	IN MM_FILTER& MMFilter,
	IN STA_AUTH_METHODS& ParserAuthMethod
	)
{
	PIPSEC_MM_POLICY pMMPol = NULL;
	RPC_STATUS RpcStat = RPC_S_OK;
	HANDLE hMMFilter = NULL;
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwNameLen = 0;
	DWORD dwVersion = 0;
	BOOL bPolExists = FALSE;
	MMFilter.pszFilterName = NULL;

	//check if policy exists
	dwReturn = GetMMPolicy(g_szDynamicMachine,dwVersion, pPolicyName, &pMMPol,NULL);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	bPolExists = TRUE;

	//
	// Generate GUID for Main mode filter
	//
	RpcStat = UuidCreate(&(MMFilter.gFilterID));
	if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}
	dwNameLen = _tcslen(pFilterName) + 1;

	//
	// allocate memory for main mode filter name
	//
	MMFilter.pszFilterName = new _TCHAR[dwNameLen];
	if(MMFilter.pszFilterName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	_tcsncpy(MMFilter.pszFilterName,pFilterName, dwNameLen);

	//
	// Add the corresponding authentication methods to the main mode filter
	//
	dwReturn = AddAuthMethods(ParserAuthMethod);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	MMFilter.gMMAuthID = ParserAuthMethod.gMMAuthID;
	MMFilter.gPolicyID = pMMPol->gPolicyID;
	MMFilter.IpVersion = IPSEC_PROTOCOL_V4;
	MMFilter.SrcAddr.pgInterfaceID = NULL;
	MMFilter.DesAddr.pgInterfaceID = NULL;

	dwReturn = AddMMFilter(g_szDynamicMachine, dwVersion, 0, &MMFilter, NULL, &hMMFilter);
	if(dwReturn == ERROR_SUCCESS)
	{
		dwReturn = CloseMMFilterHandle(hMMFilter);
	}

error:
	// functionality errors
	if(!bPolExists)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_MMF_NO_MMPOLICY);
		dwReturn = ERROR_NO_DISPLAY;
	}
	//error path clean up
	if(pMMPol)
	{
		SPDApiBufferFree(pMMPol);
		pMMPol = NULL;
	}

	if(MMFilter.pszFilterName)
	{
		delete [] MMFilter.pszFilterName;
		MMFilter.pszFilterName = NULL;
	}
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	AddAuthMethods
//
//	Date of Creation	:	09-22-01
//
//	Parameters			: 	IN MM_AUTH_METHODS& ParserAuthMethod
//
//	Return				:	DWORD
//
//	Description			:	This function adds authentication methods into the SPD.
//
//	Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
AddAuthMethods(
	IN STA_AUTH_METHODS& ParserAuthMethod
	)
{
	DWORD dwReturn = 0;
	DWORD dwVersion = 0;
	RPC_STATUS RpcStat = RPC_S_OK;
	PMM_AUTH_METHODS pExtMMAuth;
	LPVOID lpVoid = NULL;

	//
	// Generate Authentication GUID
	//
 	RpcStat = UuidCreate(&(ParserAuthMethod.gMMAuthID));
 	if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
 	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}
	//
	// Conversion between old and new data structures
	//
	INT_MM_AUTH_METHODS Methods;
	ZeroMemory(&Methods, sizeof(INT_MM_AUTH_METHODS));
	memcpy(&(Methods.gMMAuthID), &(ParserAuthMethod.gMMAuthID), sizeof(GUID));
	Methods.dwFlags = ParserAuthMethod.dwFlags;
	Methods.dwNumAuthInfos = ParserAuthMethod.dwNumAuthInfos;
	PINT_IPSEC_MM_AUTH_INFO pAuthInfos = new INT_IPSEC_MM_AUTH_INFO[Methods.dwNumAuthInfos];
	if (pAuthInfos == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	for (size_t i = 0; i < Methods.dwNumAuthInfos; ++i)
	{
		memcpy(&pAuthInfos[i], ParserAuthMethod.pAuthMethodInfo[i].pAuthenticationInfo, sizeof(INT_IPSEC_MM_AUTH_INFO));
	}
	Methods.pAuthenticationInfo = pAuthInfos;
	ParserAuthMethod.dwFlags = 0;
	dwReturn = ConvertIntMMAuthToExt(&Methods, &pExtMMAuth);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	dwReturn = AddMMAuthMethods(g_szDynamicMachine, dwVersion, 0, pExtMMAuth, lpVoid);
	if (dwReturn == ERROR_SUCCESS)
	{
		dwReturn = FreeExtMMAuthMethods(pExtMMAuth);
	}
error:
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	ConnectDynamicMachine
//
//	Date of Creation	:	09-22-01
//
//	Parameters			:	IN  LPCWSTR  pwszMachine
//
//	Return				:	DWORD
//
//	Description			:	This function is a call back for Connect.
//							Check for PA is running and reg connectivity.
//
//	Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ConnectDynamicMachine(
	IN  LPCWSTR  pwszMachine
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	HKEY hLocal = NULL;

	dwReturn = RegConnectRegistry(pwszMachine,  HKEY_LOCAL_MACHINE,  &hLocal );
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
	if (g_hGlobalRegistryKey)
	{
	    RegCloseKey(g_hGlobalRegistryKey);
	    g_hGlobalRegistryKey = NULL;
	}
	
	//
	// Check if policy agent is running..
	//
	PAIsRunning(dwReturn, (LPTSTR)pwszMachine);
	
	g_hGlobalRegistryKey = hLocal;

error:
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	SetDynamicMMFilterRule
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	IN LPTSTR pszPolicyName,
//						IN MM_FILTER& ParserMMFilter,
//						IN INT_MM_AUTH_METHODS& MMAuthMethod
//
//	Return			:	DWORD
//
//	Description		:	This function sets MMFilter parameters.
//		            	Authentication methods and mmpolicy name only can be set
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
SetDynamicMMFilterRule(
	IN LPTSTR pszPolicyName,
	IN MM_FILTER& ParserMMFilter,
	IN STA_AUTH_METHODS& MMAuthMethod
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	GUID  gDefaultGUID = {0};      // NULL GUID value
	BOOL bPolExists = FALSE;
	PIPSEC_MM_POLICY pMMPol = NULL;
	HANDLE hFilter = NULL;
	LPVOID pvReserved = NULL;

	if(pszPolicyName)
	{
		//
		// Get the corresponding main mode policy to set the name parameter
 		//
 		dwReturn = GetMMPolicy(g_szDynamicMachine, dwVersion, pszPolicyName, &pMMPol, NULL);

 		if (dwReturn != ERROR_SUCCESS)
 		{
			BAIL_OUT;
 		}
 		else
 		{
			bPolExists = TRUE;
 		}
	}
	else
	{
		bPolExists = TRUE;
	}

	ParserMMFilter.IpVersion = IPSEC_PROTOCOL_V4;
	dwReturn = OpenMMFilterHandle(g_szDynamicMachine, dwVersion, &ParserMMFilter, NULL, &hFilter);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	if(pszPolicyName)
	{
		ParserMMFilter.gPolicyID = pMMPol->gPolicyID;
	}
	//
	// set the new authentication methods.
	//
	if(MMAuthMethod.dwNumAuthInfos)
	{
		gDefaultGUID = ParserMMFilter.gMMAuthID;
		dwReturn = AddAuthMethods(MMAuthMethod);
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
		ParserMMFilter.gMMAuthID = MMAuthMethod.gMMAuthID;
	}

	dwReturn = SetMMFilter(hFilter,dwVersion, &ParserMMFilter, pvReserved);

	if((dwReturn == ERROR_SUCCESS) && (MMAuthMethod.dwNumAuthInfos))
	{
		//
		// remove the orphan MMAuthMethods
		//
		dwReturn = DeleteMMAuthMethods(g_szDynamicMachine, dwVersion, gDefaultGUID, NULL);
	}


error:
	if(!bPolExists)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_MMF_NO_MMPOLICY);
		dwReturn = ERROR_NO_DISPLAY;
	}
	//error path clean up
	if(hFilter)
	{
		CloseMMFilterHandle(hFilter);
	}

	if(pMMPol)
	{
		SPDApiBufferFree(pMMPol);
		pMMPol = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	SetTransportRule
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	IN TRANSPORT_FILTER& TrpFltr,
//						IN LPTSTR pFilterActionName,
//						IN FILTER_ACTION Inbound,
//						IN FILTER_ACTION Outbound
//
//	Return			: 	DWORD
//
//	Description		:	This function sets TransportFilter parameters.
//			            Filteraction name, inbound and outbound filteraction can be set
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
SetTransportRule(
	IN TRANSPORT_FILTER& TrpFltr,
	IN LPTSTR pFilterActionName,
	IN FILTER_ACTION Inbound,
	IN FILTER_ACTION Outbound
	)
{
	PIPSEC_QM_POLICY pQMPol = NULL;
	HANDLE hTrpFilter = NULL;
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	BOOL bFAFound = FALSE;

	if(pFilterActionName)
	{
		//
		// Get the corresponding quick mode policy to set the name parameter
		//
		dwReturn = GetQMPolicy(g_szDynamicMachine,dwVersion, pFilterActionName, 0, &pQMPol, NULL);

		if (!((dwReturn == ERROR_SUCCESS) && pQMPol))
		{
			BAIL_OUT;
		}

		bFAFound = TRUE;
	}
	else
	{
		bFAFound = TRUE;
	}

	TrpFltr.IpVersion = IPSEC_PROTOCOL_V4;
	dwReturn = OpenTransportFilterHandle(g_szDynamicMachine,dwVersion, &TrpFltr, NULL, &hTrpFilter);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
	//
	// Set the new filteraction (quick mode policy name)
	//
	if(pFilterActionName)
	{
		TrpFltr.gPolicyID = pQMPol->gPolicyID;
	}
	//
	// Set inbound filter action
	//
	if(Inbound != FILTER_ACTION_MAX)
	{
		TrpFltr.InboundFilterAction = Inbound;
	}
	//
	// Set outbound filter action
	//
	if(Outbound != FILTER_ACTION_MAX)
	{
		TrpFltr.OutboundFilterAction = Outbound;
	}

	dwReturn = SetTransportFilter(hTrpFilter,dwVersion, &TrpFltr, NULL);
	if (dwReturn == ERROR_SUCCESS)
	{
		dwReturn = CloseTransportFilterHandle(hTrpFilter);
	}

error:
	if(!bFAFound)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_QMF_NO_QMPOLICY);
		dwReturn = ERROR_NO_DISPLAY;
	}
	//error path clean up
	if(pQMPol)
	{
		SPDApiBufferFree(pQMPol);
		pQMPol = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	SetTunnelRule
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	IN TUNNEL_FILTER& TunnelFltr,
//						IN LPTSTR pFilterActionName,
//						IN FILTER_ACTION Inbound,
//						IN FILTER_ACTION Outbound
//
//	Return			:	DWORD
//
//	Description		:	This function sets TunnelFilter parameters.
//             			Filteraction name, inbound and outbound filteraction can be set
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
SetTunnelRule(
	IN TUNNEL_FILTER& TunnelFltr,
	IN LPTSTR pFilterActionName,
	IN FILTER_ACTION Inbound,
	IN FILTER_ACTION Outbound
	)
{
	PIPSEC_QM_POLICY pQMPol = NULL;
	HANDLE hTrpFilter = NULL;
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	BOOL bFAFound = FALSE;

	if(pFilterActionName)
	{
		//
		// Get the corresponding QM policy
		//
		dwReturn = GetQMPolicy(g_szDynamicMachine,dwVersion, pFilterActionName, 0, &pQMPol, NULL);

		if (!((dwReturn == ERROR_SUCCESS) && pQMPol))
		{
			BAIL_OUT;
		}
		bFAFound = TRUE;
	}
	else
	{
		bFAFound = TRUE;
	}

	TunnelFltr.IpVersion = IPSEC_PROTOCOL_V4;
	dwReturn = OpenTunnelFilterHandle(g_szDynamicMachine,dwVersion, &TunnelFltr, NULL, &hTrpFilter);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	//
	// Set the new filteraction (quick mode policy name)
	//
	if(pFilterActionName)
	{
		TunnelFltr.gPolicyID = pQMPol->gPolicyID;
	}

	//
	// Set inbound filter action
	//
	if(Inbound != FILTER_ACTION_MAX)
	{
		TunnelFltr.InboundFilterAction = Inbound;
	}

	//
	// Set outbound filter action
	//
	if(Outbound != FILTER_ACTION_MAX)
	{
		TunnelFltr.OutboundFilterAction = Outbound;
	}

	dwReturn = SetTunnelFilter(hTrpFilter,dwVersion, &TunnelFltr, NULL);
	if (dwReturn == ERROR_SUCCESS)
	{
		dwReturn = CloseTunnelFilterHandle(hTrpFilter);
	}

error:
	if(!bFAFound)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_QMF_NO_QMPOLICY);
		dwReturn = ERROR_NO_DISPLAY;
	}
	//error path clean up
	if(pQMPol)
	{
		SPDApiBufferFree(pQMPol);
		pQMPol = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CreateName
//
//	Date of Creation	: 	9-23-2001
//
//	Parameters			: 	IN LPTSTR * ppszName
//
//	Return				: 	DWORD
//
//	Description			: 	Creates a name for MMFilter, Transport and Tunnel Filter
//
//	Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
CreateName(IN LPTSTR* ppszName)
{
	RPC_STATUS RpcStat = RPC_S_OK;
	_TCHAR StringTxt[MAX_STR_LEN] = {0};
	GUID gID = {0};
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwNameLen = 0;
	LPTSTR pName = NULL;

	//
	// The name is combination of keyword 'IPSEC' and the generated GUID.
	//

	RpcStat = UuidCreate(&gID);
	if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}
	_tcsncpy(StringTxt, NAME_PREFIX, _tcslen(NAME_PREFIX)+1);

	dwReturn = StringFromGUID2(gID, StringTxt + _tcslen(StringTxt), (MAX_STR_LEN - _tcslen(StringTxt)));

	if(dwReturn != 0)
	{
		dwReturn = ERROR_SUCCESS;
	}
	else
	{
		dwReturn = GetLastError();
		BAIL_OUT;
	}

	dwNameLen = _tcslen(StringTxt)+1;
	pName = new _TCHAR[dwNameLen];
	if(pName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	else
	{
		_tcsncpy(pName, StringTxt,dwNameLen);
	}

error:
	if(dwReturn == ERROR_SUCCESS)
	{
		if(ppszName != NULL)
		{
			*ppszName = pName;
		}
		else
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	FindAndGetMMFilterRule
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	IN ADDR SrcAddr,
//						IN ADDR DstAddr,
//						IN BOOL bMirror,
//						IN IF_TYPE ConType,
//						IN BOOL bSrcMask,
//						IN BOOL bDstMask,
//						OUT PMM_FILTER *pMMFilterRule
//						IN OUT DWORD& dwStatus
//
//	Return			: 	BOOL
//
//	Description		:	This function enumerates mmfilter and gets back filled filter structure.
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL
FindAndGetMMFilterRule(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN OUT PMM_FILTER *pMMFilterRule,
	IN OUT DWORD& dwStatus
	)
{
	PMM_FILTER pMMFilterRule_local = NULL;
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwNameLen = 0;
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0, j=0;
	DWORD dwVersion = 0;
	BOOL  bFoundFilter = FALSE;
	PMM_FILTER pMMFilter = NULL;

	for (i = 0; ;i+=dwCount)
	{
		dwStatus = EnumMMFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS,
						gDefaultGUID, 0, &pMMFilter,  &dwCount, &dwResumeHandle, NULL);

		if ( (dwStatus == ERROR_NO_DATA) || (dwCount == 0) || (dwStatus != ERROR_SUCCESS))
		{
			dwStatus = ERROR_SUCCESS;
			BAIL_OUT;
		}
		else if(!(pMMFilter && dwCount > 0))
		{
			BAIL_OUT; // not required to continue.
		}
		for (j = 0; j < dwCount; j++)
		{
			//
			// Match the user given input with the enumerated structure to get the exact match.
			//
			if((pMMFilter[j].SrcAddr.uIpAddr == SrcAddr.uIpAddr) &&
			(pMMFilter[j].SrcAddr.AddrType == SrcAddr.AddrType) &&
			(pMMFilter[j].DesAddr.uIpAddr == DstAddr.uIpAddr)	&&
			(pMMFilter[j].DesAddr.AddrType == DstAddr.AddrType)	&&
			(pMMFilter[j].bCreateMirror == bMirror) &&
			(pMMFilter[j].InterfaceType == ConType))
			{
				// If mask is an user input then validate for mask
				///////////////////////////////////////////////////
				// If both source and destination mask are not given
				if((!bDstMask) && (!bSrcMask))
				{
					pMMFilterRule_local = new MM_FILTER;
					if(pMMFilterRule_local == NULL)
					{
						dwStatus = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					memcpy(pMMFilterRule_local, &pMMFilter[j], sizeof(MM_FILTER));
					dwNameLen = _tcslen(pMMFilter[j].pszFilterName) + 1;
					pMMFilterRule_local->pszFilterName = NULL;
					pMMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
					if((pMMFilterRule_local->pszFilterName) == NULL)
					{
						dwStatus = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pMMFilterRule_local->pszFilterName , pMMFilter[j].pszFilterName, dwNameLen);
					bFoundFilter = TRUE;
					break;
				}
				//
				// If source mask is given
				//
				else if((!bDstMask) && (bSrcMask))
				{
					if(pMMFilter[j].SrcAddr.uSubNetMask == SrcAddr.uSubNetMask)
					{
						pMMFilterRule_local = new MM_FILTER;
						if(pMMFilterRule_local == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}

						memcpy(pMMFilterRule_local, &pMMFilter[j],sizeof(MM_FILTER));
						dwNameLen = _tcslen(pMMFilter[j].pszFilterName) + 1;
						pMMFilterRule_local->pszFilterName = NULL;
						pMMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
						if((pMMFilterRule_local->pszFilterName) == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}

						_tcsncpy(pMMFilterRule_local->pszFilterName , pMMFilter[j].pszFilterName, dwNameLen);
						bFoundFilter = TRUE;
						break;
					}
				}
				//
				// If destination mask is given
				//
				else if((bDstMask) && (!bSrcMask))
				{
					if(pMMFilter[j].DesAddr.uSubNetMask == DstAddr.uSubNetMask)
					{
						pMMFilterRule_local = new MM_FILTER;
						if(pMMFilterRule_local == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}

						memcpy(pMMFilterRule_local, &pMMFilter[j],sizeof(MM_FILTER));
						dwNameLen = _tcslen(pMMFilter[j].pszFilterName) + 1;
						pMMFilterRule_local->pszFilterName = NULL;
						pMMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
						if((pMMFilterRule_local->pszFilterName) == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}

						_tcsncpy(pMMFilterRule_local->pszFilterName , pMMFilter[j].pszFilterName, dwNameLen);
						bFoundFilter = TRUE;
						break;
					}
				}
				//
				// If source mask and destination mask are given
				//
				else if((bDstMask) && (bSrcMask))
				{
					if(pMMFilter[j].DesAddr.uSubNetMask == DstAddr.uSubNetMask)
					{
						if(pMMFilter[j].SrcAddr.uSubNetMask == SrcAddr.uSubNetMask)
						{
							pMMFilterRule_local = new MM_FILTER;
							if(pMMFilterRule_local == NULL)
							{
								dwStatus = ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}

							memcpy(pMMFilterRule_local, &pMMFilter[j],sizeof(MM_FILTER));

							dwNameLen = _tcslen(pMMFilter[j].pszFilterName) + 1;

							pMMFilterRule_local->pszFilterName = NULL;
							pMMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
							if((pMMFilterRule_local->pszFilterName) == NULL)
							{
								dwStatus = ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}

							_tcsncpy(pMMFilterRule_local->pszFilterName , pMMFilter[j].pszFilterName, dwNameLen);
							bFoundFilter = TRUE;
							break;
						}
					}
				}
			}
		}

		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;
		if(bFoundFilter)
		{
			*pMMFilterRule = pMMFilterRule_local;
			break;
		}
	}

error:
	//error path clean up
	if(pMMFilter)
	{
		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;
	}

	return bFoundFilter;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	FindAndGetTransportRule
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	IN ADDR SrcAddr,
//						IN ADDR DstAddr,
//						IN BOOL bMirror,
//						IN IF_TYPE ConType,
//						IN DWORD dwProtocol,
//						IN DWORD dwSrcPort,
//						IN DWORD dwDstPort,
//						IN BOOL bSrcMask,
//						IN BOOL bDstMask,
//						OUT PTRANSPORT_FILTER *pQMFilterRule
//						IN OUT DWORD& dwStatus
//
//Return			:	BOOL
//
//Description		:	This function enumerates transport filter and gets filled transport filter.
//
//Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

BOOL
FindAndGetTransportRule(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN DWORD dwProtocol,
	IN DWORD dwSrcPort,
	IN DWORD dwDstPort,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	OUT PTRANSPORT_FILTER *pQMFilterRule,
	IN OUT DWORD& dwStatus
	)
{
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwVersion = 0;
	DWORD dwNameLen = 0;
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0, j=0;
	BOOL bFoundFilter = FALSE;
	PTRANSPORT_FILTER pQMFilterRule_local = NULL;
	PTRANSPORT_FILTER pTransF = NULL;


	for (i = 0; ;i+=dwCount)
	{
		dwStatus = EnumTransportFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS,
										gDefaultGUID, 0, &pTransF, &dwCount, &dwResumeHandle, NULL);

		if ( (dwStatus == ERROR_NO_DATA) || (dwCount == 0) || (dwStatus != ERROR_SUCCESS))
		{
			dwStatus = ERROR_SUCCESS;
			BAIL_OUT;
		}
		else if(!(pTransF && dwCount > 0))
		{
			BAIL_OUT; // not required to continue.
		}
		for (j = 0; j < dwCount; j++)
		{
			// Match the user given input with the enumerated structure to get the exact match
			if((pTransF[j].SrcAddr.uIpAddr == SrcAddr.uIpAddr) &&
			(pTransF[j].SrcAddr.AddrType == SrcAddr.AddrType) &&
			(pTransF[j].DesAddr.uIpAddr == DstAddr.uIpAddr)	&&
			(pTransF[j].DesAddr.AddrType == DstAddr.AddrType)	&&
			(pTransF[j].bCreateMirror == bMirror) &&
			(pTransF[j].InterfaceType == ConType) &&
			(pTransF[j].Protocol.dwProtocol== dwProtocol) &&
			(pTransF[j].SrcPort.wPort == dwSrcPort) &&
			(pTransF[j].DesPort.wPort == dwDstPort))
			{
				// if both source and destination mask are not given
				if((!bDstMask) && (!bSrcMask))
				{
					pQMFilterRule_local = new TRANSPORT_FILTER;
					if(pQMFilterRule_local == NULL)
					{
						dwStatus = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					memcpy(pQMFilterRule_local, &pTransF[j],sizeof(TRANSPORT_FILTER));
					dwNameLen = _tcslen(pTransF[j].pszFilterName) + 1;
					pQMFilterRule_local->pszFilterName = NULL;
					pQMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
					if((pQMFilterRule_local->pszFilterName) == NULL)
					{
						dwStatus = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pQMFilterRule_local->pszFilterName, pTransF[j].pszFilterName, dwNameLen);
					bFoundFilter = TRUE;
					break;
				}
				//
				// If source mask is given
				//
				else if((!bDstMask) && (bSrcMask))
				{
					if(pTransF[j].SrcAddr.uSubNetMask == SrcAddr.uSubNetMask)
					{
						pQMFilterRule_local = new TRANSPORT_FILTER;
						if(pQMFilterRule_local == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						memcpy(pQMFilterRule_local, &pTransF[j],sizeof(TRANSPORT_FILTER));
						dwNameLen = _tcslen(pTransF[j].pszFilterName) + 1;
						pQMFilterRule_local->pszFilterName = NULL;
						pQMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
						if(pQMFilterRule_local->pszFilterName == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						_tcsncpy(pQMFilterRule_local->pszFilterName, pTransF[j].pszFilterName, dwNameLen);
						bFoundFilter = TRUE;
						break;
					}
				}
				//
				// If destination mask is given
				//
				else if((bDstMask) && (!bSrcMask))
				{
					if(pTransF[j].DesAddr.uSubNetMask == DstAddr.uSubNetMask)
					{
						pQMFilterRule_local = new TRANSPORT_FILTER;
						if(pQMFilterRule_local == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						memcpy(pQMFilterRule_local, &pTransF[j],sizeof(TRANSPORT_FILTER));
						dwNameLen = _tcslen(pTransF[j].pszFilterName) + 1;
						pQMFilterRule_local->pszFilterName = NULL;
						pQMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
						if((pQMFilterRule_local->pszFilterName) == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						_tcsncpy(pQMFilterRule_local->pszFilterName, pTransF[j].pszFilterName, dwNameLen);
						bFoundFilter = TRUE;
						break;
					}
				}
				//
				// If source mask and destination mask are given
				//
				else if((bDstMask) && (bSrcMask))
				{
					if(pTransF[j].DesAddr.uSubNetMask == DstAddr.uSubNetMask)
					{
						if(pTransF[j].SrcAddr.uSubNetMask == SrcAddr.uSubNetMask)
						{
							pQMFilterRule_local = new TRANSPORT_FILTER;
							if(pQMFilterRule_local == NULL)
							{
								dwStatus = ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							memcpy(pQMFilterRule_local, &pTransF[j],sizeof(TRANSPORT_FILTER));
							dwNameLen = _tcslen(pTransF[j].pszFilterName) + 1;
							pQMFilterRule_local->pszFilterName = NULL;
							pQMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
							if((pQMFilterRule_local->pszFilterName) == NULL)
							{
								dwStatus = ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							_tcsncpy(pQMFilterRule_local->pszFilterName, pTransF[j].pszFilterName, dwNameLen);
							bFoundFilter = TRUE;
							break;
						}
					}
				}
			}
		}

		SPDApiBufferFree(pTransF);
		pTransF = NULL;

		//
		// copy the structure pointer.
		//
		if(bFoundFilter)
		{
			*pQMFilterRule = pQMFilterRule_local;
			break;
		}
	}

error:
	//error path cleanup
	if(pTransF)
	{
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}
	return bFoundFilter;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	FindAndGetTunnelRule
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	IN ADDR SrcAddr,
//						IN ADDR DstAddr,
//						IN BOOL bMirror,
//						IN IF_TYPE ConType,
//						IN DWORD dwProtocol,
//						IN DWORD dwSrcPort,
//						IN DWORD dwDstPort,
//						IN BOOL bSrcMask,
//						IN BOOL bDstMask,
//						IN ADDR SrcTunnel,
//						IN ADDR DstTunnel,
//						OUT PTUNNEL_FILTER * pQMFilterRule,
//						IN OUT DWORD& dwStatus
//
//	Return			: 	BOOL
//
//	Description		:	This function enumerates tunnel filter and gets filled tunnel filter.
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

BOOL
FindAndGetTunnelRule(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN DWORD dwProtocol,
	IN DWORD dwSrcPort,
	IN DWORD dwDstPort,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN ADDR SrcTunnel,
	IN ADDR DstTunnel,
	OUT PTUNNEL_FILTER * pQMFilterRule,
	OUT DWORD& dwStatus
	)
{
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwVersion = 0;
	DWORD dwNameLen = 0;
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0, j=0;
	BOOL bFoundFilter = FALSE;
	PTUNNEL_FILTER pQMFilterRule_local = NULL;
	PTUNNEL_FILTER pTransF = NULL;

	for (i = 0; ;i+=dwCount)
	{
		dwStatus = EnumTunnelFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS,
							gDefaultGUID, 0, &pTransF, &dwCount, &dwResumeHandle, NULL);

		if ( (dwStatus == ERROR_NO_DATA) || (dwCount == 0) || (dwStatus != ERROR_SUCCESS))
		{
			dwStatus = ERROR_SUCCESS;
			break;
		}
		else if(!(pTransF && dwCount > 0))
		{
			break; // not required to continue.
		}
		for (j = 0; j < dwCount; j++)
		{
			//
			// Match the user given input with the enumerated structure to get the exact match
			//
			if((pTransF[j].SrcAddr.uIpAddr == SrcAddr.uIpAddr) &&
			(pTransF[j].SrcAddr.AddrType == SrcAddr.AddrType) &&
			(pTransF[j].DesAddr.uIpAddr == DstAddr.uIpAddr)	&&
			(pTransF[j].DesAddr.AddrType == DstAddr.AddrType)	&&
			(pTransF[j].bCreateMirror == bMirror) &&
			(pTransF[j].InterfaceType == ConType) &&
			(pTransF[j].Protocol.dwProtocol== dwProtocol) &&
			(pTransF[j].SrcPort.wPort == dwSrcPort) &&
			(pTransF[j].DesPort.wPort == dwDstPort) &&
			(pTransF[j].DesTunnelAddr.uIpAddr == DstTunnel.uIpAddr)	&&
			(pTransF[j].DesTunnelAddr.AddrType == DstTunnel.AddrType))
			{
				// If both source and destination mask are not given
				if((!bDstMask) && (!bSrcMask))
				{
					pQMFilterRule_local = new TUNNEL_FILTER;
					if(pQMFilterRule_local == NULL)
					{
						dwStatus = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					memcpy(pQMFilterRule_local, &pTransF[j],sizeof(TUNNEL_FILTER));
					dwNameLen = _tcslen(pTransF[j].pszFilterName) + 1;
					pQMFilterRule_local->pszFilterName = NULL;
					pQMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
					if((pQMFilterRule_local->pszFilterName) == NULL)
					{
						dwStatus = ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}
					_tcsncpy(pQMFilterRule_local->pszFilterName, pTransF[j].pszFilterName, dwNameLen);
					bFoundFilter = TRUE;
					break;
				}
				//
				// If source mask is given
				//
				else if((!bDstMask) && (bSrcMask))
				{
					if(pTransF[j].SrcAddr.uSubNetMask == SrcAddr.uSubNetMask)
					{
						pQMFilterRule_local = new TUNNEL_FILTER;
						if(pQMFilterRule_local == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						memcpy(pQMFilterRule_local, &pTransF[j],sizeof(TUNNEL_FILTER));

						dwNameLen = _tcslen(pTransF[j].pszFilterName) + 1;

						pQMFilterRule_local->pszFilterName = NULL;
						pQMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
						if((pQMFilterRule_local->pszFilterName) == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						_tcsncpy(pQMFilterRule_local->pszFilterName, pTransF[j].pszFilterName, dwNameLen);
						bFoundFilter = TRUE;
						break;
					}
				}
				//
				// If destination mask is given
				//
				else if((bDstMask) && (!bSrcMask))
				{
					if(pTransF[j].DesAddr.uSubNetMask == DstAddr.uSubNetMask)
					{
						pQMFilterRule_local = new TUNNEL_FILTER;
						if(pQMFilterRule_local == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						memcpy(pQMFilterRule_local, &pTransF[j],sizeof(TUNNEL_FILTER));
						dwNameLen = _tcslen(pTransF[j].pszFilterName) + 1;
						pQMFilterRule_local->pszFilterName = NULL;
						pQMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
						if((pQMFilterRule_local->pszFilterName) == NULL)
						{
							dwStatus = ERROR_OUTOFMEMORY;
							BAIL_OUT;
						}
						_tcsncpy(pQMFilterRule_local->pszFilterName, pTransF[j].pszFilterName, dwNameLen);
						bFoundFilter = TRUE;
						break;
					}
				}
				//
				// If source mask and destination mask are given
				//
				else if((bDstMask) && (bSrcMask))
				{
					if(pTransF[j].DesAddr.uSubNetMask == DstAddr.uSubNetMask)
					{
						if(pTransF[j].SrcAddr.uSubNetMask == SrcAddr.uSubNetMask)
						{
							pQMFilterRule_local = new TUNNEL_FILTER;
							if(pQMFilterRule_local == NULL)
							{
								dwStatus = ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							memcpy(pQMFilterRule_local, &pTransF[j],sizeof(TUNNEL_FILTER));

							dwNameLen = _tcslen(pTransF[j].pszFilterName) + 1;

							pQMFilterRule_local->pszFilterName = NULL;
							pQMFilterRule_local->pszFilterName = new _TCHAR[dwNameLen];
							if((pQMFilterRule_local->pszFilterName) == NULL)
							{
								dwStatus = ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							_tcsncpy(pQMFilterRule_local->pszFilterName, pTransF[j].pszFilterName, dwNameLen);
							bFoundFilter = TRUE;
							break;
						}
					}
				}
			}
		}
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
		//
		//copy the pointer structure
		//
		if(bFoundFilter)
		{
			*pQMFilterRule = pQMFilterRule_local;
			break;
		}
	}

error:
	//error path clean up
	if(pTransF)
	{
		SPDApiBufferFree(pTransF);
	}
	return bFoundFilter;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	LoadMMFilterDefaults
//
//	Date of Creation:	09-22-01
//
//	Parameters		:	OUT MM_FILTER& MMFilter
//
//	Return			: 	DWORD
//
//	Description		:	This function loads the Main mode filter structure defaults.
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
LoadMMFilterDefaults(
	OUT MM_FILTER& MMFilter
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	GUID gInterfaceId = {0};
	RPC_STATUS RpcStat = RPC_S_OK;

	memset(&MMFilter, 0, sizeof(MM_FILTER));

	MMFilter.InterfaceType 			= INTERFACE_TYPE_ALL;
	MMFilter.bCreateMirror 			= TRUE;
	MMFilter.dwFlags 				= 0;
	MMFilter.dwDirection 			= FILTER_DIRECTION_OUTBOUND;
	MMFilter.dwWeight 				= 0;

	MMFilter.SrcAddr.AddrType 		= IP_ADDR_UNIQUE;
	MMFilter.SrcAddr.uSubNetMask 	= IP_ADDRESS_MASK_NONE;

	MMFilter.DesAddr.AddrType 		= IP_ADDR_UNIQUE;
	MMFilter.DesAddr.uSubNetMask 	= IP_ADDRESS_MASK_NONE;

	RpcStat = UuidCreateNil(&(gInterfaceId));

	if(!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn = GetLastError();
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = ERROR_NO_DISPLAY;
	}

    MMFilter.DesAddr.pgInterfaceID 	= NULL;
    MMFilter.SrcAddr.pgInterfaceID 	= NULL;

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	IsLastRuleOfMMFilter
//
//	Date of Creation:	05-19-02
//
//	Parameters		:	IN ADDR SrcAddr,
//						IN ADDR DstAddr,
//						IN BOOL bMirror,
//						IN IF_TYPE ConType,
//						IN BOOL bSrcMask,
//						IN BOOL bDstMask,
//						IN OUT DWORD& dwStatus
//
//Return			:	BOOL
//
//Description		:	Deterimines if there exists any transport or tunnel filters
//                      may require a MM filter.  This is called before deleting an MM filter
//                      so that we make sure we don't delete any MM filter if more than
//                      on tranport or tunnel filters may be using it.
//
//Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

BOOL
IsLastRuleOfMMFilter(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN OUT DWORD& dwStatus
	)
{
	DWORD dwTransFFloorCount = 0;          
	DWORD dwTunnFFloorCount = 0;          
	BOOL bLastRuleOfMMFilter = FALSE;

	dwTransFFloorCount = FloorCountTransportRuleOfMMFilter(
							SrcAddr,
							DstAddr,
							bMirror,
							ConType,
							bSrcMask,
							bDstMask,
							dwStatus
							);
	BAIL_ON_WIN32_ERROR(dwStatus);
	dwTunnFFloorCount = FloorCountTunnelRuleOfMMFilter(
							SrcAddr,
							DstAddr,
							bMirror,
							ConType,
							dwStatus
							);
	BAIL_ON_WIN32_ERROR(dwStatus);
	
error:	
	bLastRuleOfMMFilter = (dwTransFFloorCount + dwTunnFFloorCount == 0);
	
	
	return bLastRuleOfMMFilter;
}



///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	FloorCountTransportRuleOfMMFilter
//
//	Date of Creation:	05-19-02
//
//	Parameters		:	IN ADDR SrcAddr,
//						IN ADDR DstAddr,
//						IN BOOL bMirror,
//						IN IF_TYPE ConType,
//						IN BOOL bSrcMask,
//						IN BOOL bDstMask,
//						IN OUT DWORD& dwStatus
//
//Return			:	DWORD
//
//Description		:	Counts if there is at least one transport filter that matches the
//						given keys.   We are not interested in getting the exact count,
//                      just whether we have more than one.
//                      
//                      
//                      
//
//Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
FloorCountTransportRuleOfMMFilter(
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN OUT DWORD& dwStatus
	)
{
	const DWORD MIN_MATCH_REQUIRED = 1;	// At least one filter required to match.
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwVersion = 0;
	DWORD dwNameLen = 0;
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0, j=0;
	BOOL bFoundFilter = FALSE;
	PTRANSPORT_FILTER pQMFilterRule_local = NULL;
	PTRANSPORT_FILTER pTransF = NULL;
	DWORD dwTransFFloorCount = 0;
	BOOL bLastTransportRuleOfFilter = FALSE;

	for (i = 0; ;i+=dwCount)
	{
		dwStatus = EnumTransportFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS,
										gDefaultGUID, 0, &pTransF, &dwCount, &dwResumeHandle, NULL);

		if ( (dwStatus == ERROR_NO_DATA) || (dwCount == 0) || (dwStatus != ERROR_SUCCESS))
		{
			dwStatus = ERROR_SUCCESS;
			BAIL_OUT;
		}
		else if(!(pTransF && dwCount > 0))
		{
			BAIL_OUT; // not required to continue.
		}
		for (j = 0; j < dwCount; j++)
		{
			// Match the user given input with the enumerated structure to get the exact match
			if((pTransF[j].SrcAddr.uIpAddr == SrcAddr.uIpAddr) &&
			(pTransF[j].SrcAddr.AddrType == SrcAddr.AddrType) &&
			(pTransF[j].DesAddr.uIpAddr == DstAddr.uIpAddr)	&&
			(pTransF[j].DesAddr.AddrType == DstAddr.AddrType)	&&
			(pTransF[j].bCreateMirror == bMirror) &&
			(pTransF[j].InterfaceType == ConType))
			{
				// if both source and destination mask are not given
				if((!bDstMask) && (!bSrcMask))
				{
					dwTransFFloorCount++;
					if (dwTransFFloorCount >= MIN_MATCH_REQUIRED) 
					{
						break;
					}
				}
				//
				// If source mask is given
				//
				else if((!bDstMask) && (bSrcMask))
				{
					if(pTransF[j].SrcAddr.uSubNetMask == SrcAddr.uSubNetMask)
					{
						dwTransFFloorCount++;
						if (dwTransFFloorCount >= MIN_MATCH_REQUIRED) 
						{
							break;
						}
					}
				}
				//
				// If destination mask is given
				//
				else if((bDstMask) && (!bSrcMask))
				{
					if(pTransF[j].DesAddr.uSubNetMask == DstAddr.uSubNetMask)
					{
						dwTransFFloorCount++;
						if (dwTransFFloorCount >= MIN_MATCH_REQUIRED) 
						{
							break;
						}
					}
				}
				//
				// If source mask and destination mask are given
				//
				else if((bDstMask) && (bSrcMask))
				{
					if(pTransF[j].DesAddr.uSubNetMask == DstAddr.uSubNetMask)
					{
						if(pTransF[j].SrcAddr.uSubNetMask == SrcAddr.uSubNetMask)
						{
							dwTransFFloorCount++;
							if (dwTransFFloorCount >= MIN_MATCH_REQUIRED) 
							{
								break;
							}
						}
					}
				}
			}
		}

		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}

error:
	if(pTransF)
	{
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}

	return dwTransFFloorCount;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	FloorCountTunnelRuleOfMMFilter
//
//	Date of Creation:	05-19-02
//
//	Parameters		:	IN ADDR SrcAddr,
//						IN ADDR DstAddr,
//						IN BOOL bMirror,
//						IN IF_TYPE ConType,
//						IN BOOL bSrcMask,
//						IN BOOL bDstMask,
//						IN OUT DWORD& dwStatus
//
//Return			:	DWORD
//
//Description		:	Counts if there is at least one tunnel filter that matches the
//						given keys.   We are not interested in getting the exact count,
//                      just whether we have more than one.
//                      
//                      
//                      
//
//Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
FloorCountTunnelRuleOfMMFilter(
	IN ADDR SrcTunnel,
	IN ADDR DstTunnel,
	IN BOOL bMirror,
	IN IF_TYPE ConType,
	OUT DWORD& dwStatus
	)
{
	const DWORD MIN_MATCH_REQUIRED = 1;	// At least one filter required to match.
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwVersion = 0;
	DWORD dwNameLen = 0;
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0, j=0;
	PTUNNEL_FILTER pTransF = NULL;
	DWORD dwTransFFloorCount = 0;
	
	for (i = 0; ;i+=dwCount)
	{
		dwStatus = EnumTunnelFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS,
							gDefaultGUID, 0, &pTransF, &dwCount, &dwResumeHandle, NULL);

		if ( (dwStatus == ERROR_NO_DATA) || (dwCount == 0) || (dwStatus != ERROR_SUCCESS))
		{
			dwStatus = ERROR_SUCCESS;
			BAIL_OUT;
		}
		else if(!(pTransF && dwCount > 0))
		{
			break; // not required to continue.
		}
		for (j = 0; j < dwCount; j++)
		{
			//
			// Match the user given input with the enumerated structure to get the exact match
			//
			if( (pTransF[j].bCreateMirror == bMirror) &&
				(pTransF[j].InterfaceType == ConType) &&
				(pTransF[j].DesTunnelAddr.uIpAddr == DstTunnel.uIpAddr)	&&
				(pTransF[j].DesTunnelAddr.AddrType == DstTunnel.AddrType)	&&
				(pTransF[j].SrcTunnelAddr.uIpAddr == SrcTunnel.uIpAddr) &&
				(pTransF[j].SrcTunnelAddr.AddrType == SrcTunnel.AddrType))
			{
				dwTransFFloorCount++;
				if (dwTransFFloorCount >= MIN_MATCH_REQUIRED) 
				{
					break;
				}
			}
		}
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}

error:
	if(pTransF)
	{
		SPDApiBufferFree(pTransF);
	}
	return dwTransFFloorCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\dynamicdelete.cpp ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: Dynamic/dyanamicDelete.cpp
//
// 	Purpose			: Dynamic Delete Implementation.
//
//
// 	Developers Name	: Bharat/Radhika
//
//
//	History			:
//
//  Date			Author		Comments
//  9-13-2001   	Radhika		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern _TCHAR* g_szDynamicMachine;

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteMMPolicy
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN LPTSTR pszPolicyName
//
//Return: 		DWORD
//
//Description: This function deletes Mainmode Policy for the given name or
//             deletes all main mode policies if name is not given.
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
DeleteMMPolicy(
	IN LPTSTR pszPolicyName
	)
{
	DWORD dwCount = 0;                 		// counting objects here
	DWORD dwResumeHandle = 0;
	DWORD dwOldResumeHandle = 0; 			// handle for continuation calls
	DWORD dwVersion = 0;
	DWORD i=0, j=0;
	DWORD dwReturn = ERROR_SUCCESS;			// assume success
	BOOL bNameFin = FALSE;
	BOOL bRemoved = FALSE;

	PIPSEC_MM_POLICY pIPSecMMP = NULL;      // for MM policy calls

	for (i = 0; ;i+=dwCount)
	{
		bRemoved = FALSE;
		dwOldResumeHandle = dwResumeHandle;
		dwReturn = EnumMMPolicies(g_szDynamicMachine, dwVersion, NULL, 0, 0,
										&pIPSecMMP, &dwCount, &dwResumeHandle, NULL);

		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pIPSecMMP && dwCount > 0))
		{
			BAIL_OUT;	// not required to continue.
		}
		// Policy name is not given, hence delete all policies
		if(pszPolicyName == NULL)
		{
			for (j = 0; j < dwCount; j++)
			{
				dwReturn = DeleteMMPolicy(g_szDynamicMachine, dwVersion, pIPSecMMP[j].pszPolicyName, NULL);
				if (dwReturn == ERROR_SUCCESS)
				{
					bRemoved = TRUE;
				}
				bNameFin = TRUE;
			}
		}
		// Delete  policy with the given name
		else if(pszPolicyName)
		{
			for (j = 0; j < dwCount; j++)
			{
				if(_tcsicmp(pIPSecMMP[j].pszPolicyName,pszPolicyName) == 0)
				{
					dwReturn = DeleteMMPolicy(g_szDynamicMachine, dwVersion, pIPSecMMP[j].pszPolicyName, NULL);

					if (dwReturn == ERROR_SUCCESS)
					{
						bRemoved = TRUE;
					}
					bNameFin = TRUE;
					BAIL_OUT;	// found the policy, come out from the loop
				}
			}
		}
		SPDApiBufferFree(pIPSecMMP);
		pIPSecMMP=NULL;
		if(bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration for deleting all
		}
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
	}

error:

	//functionality errors are displayed here and ERROR_SUCCESS is passed to parent function.
	if(pszPolicyName && !bNameFin)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_MMF_NO_MMPOLICY);
		dwReturn = ERROR_SUCCESS;
	}
	else if(!bNameFin)
	{
		//Error Message printed in parent function
		//as this is also called by delete all function
		//where the error message should not be displayed
		dwReturn = ERROR_NO_DISPLAY;
	}
	if(pIPSecMMP)
	{
		//error path clean up
		SPDApiBufferFree(pIPSecMMP);
		pIPSecMMP=NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteQMPolicy
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN LPTSTR pszPolicyName
//
//Return: 		DWORD
//
//Description: This function deletes quickmode Policy for the given name
//             or deletes all the policies if the name is not given.
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
DeleteQMPolicy(
	IN LPTSTR pszPolicyName
	)
{
	DWORD dwCount = 0;                 		// counting objects here
	DWORD dwResumeHandle = 0;
	DWORD dwOldResumeHandle = 0; 			// handle for continuation calls
	DWORD i=0, j=0;
	DWORD dwReturn = ERROR_SUCCESS;			// assume success
	DWORD dwVersion = 0;
	BOOL bNameFin = FALSE;
	BOOL bRemoved = FALSE;
	PIPSEC_QM_POLICY pIPSecQMP = NULL;      // for QM policy calls

	for (i = 0; ;i+=dwCount)
	{
		bRemoved = FALSE;
		dwOldResumeHandle = dwResumeHandle;
		dwReturn = EnumQMPolicies(g_szDynamicMachine, dwVersion, NULL, 0, 0,
													&pIPSecQMP, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
		if(!(pIPSecQMP && dwCount > 0))
		{
			BAIL_OUT;			// not required to continue.
		}
		// Deletes all the policies
		if(pszPolicyName == NULL)
		{
			for (j = 0; j < dwCount; j++)
			{
				dwReturn = DeleteQMPolicy(g_szDynamicMachine, dwVersion, pIPSecQMP[j].pszPolicyName, NULL);
				if (dwReturn == ERROR_SUCCESS)
				{
					bRemoved = TRUE;
				}
				bNameFin = TRUE;
			}
		}
		// Deletes the policy for the given name
		else if(pszPolicyName)
		{
			for (j = 0; j < dwCount; j++)
			{
				if(_tcsicmp(pIPSecQMP[j].pszPolicyName,pszPolicyName) == 0)
				{
					dwReturn = DeleteQMPolicy(g_szDynamicMachine, dwVersion, pIPSecQMP[j].pszPolicyName, NULL);
					if (dwReturn == ERROR_SUCCESS)
					{
						bRemoved = TRUE;
					}
					bNameFin = TRUE;
					BAIL_OUT;
				}
			}
		}
		SPDApiBufferFree(pIPSecQMP);
		pIPSecQMP=NULL;
		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration!
		}
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
	}

error:
	//functionality errors are displayed here and ERROR_SUCCESS is passed to parent function.
	if(pszPolicyName && !bNameFin)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_QMF_NO_QMPOLICY);
		dwReturn = ERROR_SUCCESS;
	}
	else if(!bNameFin)
	{
		//Error Message printed in parent function
		//as this is also called by delete all function
		//where the error message should not be displayed
		dwReturn = ERROR_NO_DISPLAY;
	}

	if(pIPSecQMP)
	{
		//error path clean up
		SPDApiBufferFree(pIPSecQMP);
		pIPSecQMP=NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteMMFilters
//
//Date of Creation: 9-3-2001
//
//Parameters: 	VOID
//
//Return: 		DWORD
//
//Description: This function deletes all the mainmode filters and
//					corresponding authentication methods.
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
DeleteMMFilters(
	VOID
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;
	DWORD dwOldResumeHandle = 0; 			// handle for continuation calls
	DWORD dwCount = 0;                 		// counting objects here
	DWORD dwMaxCount = 0;                 	// Max objects count
	DWORD dwLocalCount = 0;                	// local total count
	DWORD dwVersion = 0;
	DWORD dwTmpCount1 = 0, dwTmpCount2 = 0;
	GUID  gDefaultGUID = {0};    	  		// NULL GUID value
	DWORD i=0, j=0;
	BOOL bRemoved = FALSE;
	PMM_FILTER pMMFilter = NULL;
	HANDLE hFilter = NULL;

	dwReturn = GetMaxCountMMFilters(dwMaxCount);
	if((dwReturn != ERROR_SUCCESS) || (dwMaxCount == 0))
	{
		BAIL_OUT;
	}

	for (i = 0; ;i+=dwCount)
	{
		bRemoved = FALSE;
		dwOldResumeHandle = dwResumeHandle;
		dwReturn = EnumMMFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS,
										gDefaultGUID, 0, &pMMFilter, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pMMFilter && dwCount > 0))
		{
			BAIL_OUT; // not required to continue.
		}

		dwReturn = GetMaxCountMMFilters(dwTmpCount1);
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		// Deletes all Main Mode filters and the corresponding authentication methods.
		for (j = 0; j < dwCount; j++)
		{
			dwReturn = OpenMMFilterHandle(g_szDynamicMachine, dwVersion, &(pMMFilter[j]), NULL, &hFilter);
			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			dwReturn = DeleteMMFilter(hFilter);
			if(dwReturn == ERROR_SUCCESS)
			{
				dwReturn = DeleteMMAuthMethods(g_szDynamicMachine, dwVersion,
													pMMFilter[j].gMMAuthID, NULL);
			}
			else
			{
				dwReturn = CloseMMFilterHandle(hFilter);
				if(dwReturn != ERROR_SUCCESS)
				{
					BAIL_OUT;
				}
			}
		}

		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;

		dwLocalCount += dwCount;
		if(dwLocalCount >= dwMaxCount)
		{
			break;
		}

		//
		//DeleteMMFilter api returns success for if try to delete Policyagent Objects,
		//even though those are not deleted.
		//This code mitigates by comparing current objects count with old objects count in SPD.
		//
		dwReturn = GetMaxCountMMFilters(dwTmpCount2);
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(dwTmpCount2 != dwTmpCount1)
		{
			bRemoved = TRUE;
		}
		else
		{
			bRemoved = FALSE;
		}

		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration to delete all the filters!
		}
	}

	dwReturn = GetMaxCountMMFilters(dwMaxCount);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	if(dwMaxCount > 0)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_MMF_OBJ_NOTDEL, dwMaxCount);
	}


error:
	//error path clean up
	if(pMMFilter)
	{
		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteTransportFilters
//
//Date of Creation: 9-3-2001
//
//Parameters: 	VOID
//
//Return: 		DWORD
//
//Description: This function deletes all the quickmode Transport filters.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
DeleteTransportFilters(
	VOID
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;
	DWORD dwOldResumeHandle = 0; 			// handle for continuation calls
	DWORD dwCount = 0;                 		// counting objects here
	DWORD dwMaxCount = 0;                 	// Max objects count
	DWORD dwLocalCount = 0;                	// local total count
	GUID  gDefaultGUID = {0};      			// NULL GUID value
	DWORD i=0, j=0;
	DWORD dwVersion = 0;
	DWORD dwTmpCount1 = 0, dwTmpCount2 = 0;
	BOOL bRemoved = FALSE;
	PTRANSPORT_FILTER pTransF = NULL;
	HANDLE hFilter = NULL;

	dwReturn = GetMaxCountTransportFilters(dwMaxCount);
	if((dwReturn != ERROR_SUCCESS) || (dwMaxCount == 0))
	{
		BAIL_OUT;
	}

	for (i = 0; ;i+=dwCount)
	{
		bRemoved = FALSE;
		dwOldResumeHandle = dwResumeHandle;

		dwReturn = GetMaxCountTransportFilters(dwTmpCount1);
		if((dwReturn != ERROR_SUCCESS) || (dwTmpCount1 == 0))
		{
			BAIL_OUT;
		}

		dwReturn = EnumTransportFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0,
															&pTransF, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pTransF && dwCount > 0))
		{
			BAIL_OUT; // no need continue.
		}

		//GetMaxCountTransportFilters(dwTmpCount1);
		// Deletes all the Transport filters.
		for (j = 0; j < dwCount; j++)
		{
			dwReturn = OpenTransportFilterHandle(g_szDynamicMachine, dwVersion, &(pTransF[j]), NULL, &hFilter);
			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			dwReturn = DeleteTransportFilter(hFilter);

			if (dwReturn != ERROR_SUCCESS)
			{
				dwReturn = CloseTransportFilterHandle(hFilter);
				if(dwReturn != ERROR_SUCCESS)
				{
					BAIL_OUT;
				}
			}
		}

		SPDApiBufferFree(pTransF);
		pTransF = NULL;

		dwLocalCount += dwCount;
		if(dwLocalCount >= dwMaxCount)
		{
			break;
		}

		//
		//DeleteTransportFilter api returns success for if try to delete Policyagent Objects,
		//even though those are not deleted.
		//This code mitigates by comparing current objects count with old objects count in SPD.
		//

		dwReturn = GetMaxCountTransportFilters(dwTmpCount2);
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(dwTmpCount1 != dwTmpCount2)
		{
			bRemoved = TRUE;
		}
		else
		{
			bRemoved = FALSE;
		}

		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; 			// need to restart enumeration to delete all the filters!
		}
	}

	dwReturn = GetMaxCountTransportFilters(dwMaxCount);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	if(dwMaxCount > 0)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_TRANSPORT_OBJ_NOTDEL, dwMaxCount);
	}

error:
	if(pTransF)
	{
		//error path clean up
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}

	return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteTunnelFilters
//
//Date of Creation: 9-3-2001
//
//Parameters: 	VOID
//
//Return: 		DWORD
//
//Description: This function deletes all the quickmode Tunnel filters.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
DeleteTunnelFilters(
	VOID
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;
	DWORD dwOldResumeHandle = 0; 			// handle for continuation calls
	DWORD dwCount = 0;                 		// counting objects here
	DWORD dwMaxCount = 0;                 	// Max objects count
	DWORD dwLocalCount = 0;                	// local total count
	DWORD dwTmpCount1 = 0, dwTmpCount2 = 0;
	GUID  gDefaultGUID = {0};      			// NULL GUID value
	DWORD i=0, j=0;
	DWORD dwVersion = 0;
	BOOL bRemoved = FALSE;
	HANDLE hFilter = NULL;
	PTUNNEL_FILTER pTunnelF = NULL;

	dwReturn = GetMaxCountTunnelFilters(dwMaxCount);
	if((dwReturn != ERROR_SUCCESS) || (dwMaxCount == 0))
	{
		BAIL_OUT;
	}

	for (i = 0; ;i+=dwCount)
	{
		bRemoved = FALSE;
		dwOldResumeHandle = dwResumeHandle;

		dwReturn = EnumTunnelFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0, &pTunnelF, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pTunnelF && dwCount > 0))
		{
			BAIL_OUT; // not required to continue.
		}

		dwReturn = GetMaxCountTunnelFilters(dwTmpCount1);
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		for (j = 0; j < dwCount; j++)
		{
			// Deletes all the Tunnel filters.
			dwReturn = OpenTunnelFilterHandle(g_szDynamicMachine, dwVersion, &(pTunnelF[j]), NULL, &hFilter);
			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			dwReturn = DeleteTunnelFilter(hFilter);
			if (dwReturn == ERROR_SUCCESS)
			{

			}
			else
			{
				dwReturn = CloseTunnelFilterHandle(hFilter);
				if(dwReturn != ERROR_SUCCESS)
				{
					BAIL_OUT;
				}
			}
		}

		SPDApiBufferFree(pTunnelF);
		pTunnelF = NULL;

		dwLocalCount += dwCount;
		if(dwLocalCount >= dwMaxCount)
		{
			break;
		}

		//
		//DeleteTunnelFilter api returns success for if try to delete Policyagent Objects,
		//even though those are not deleted.
		//This code mitigates by comparing current objects count with old objects count in SPD.
		//
		dwReturn = GetMaxCountTunnelFilters(dwTmpCount2);
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(dwTmpCount2 != dwTmpCount1)
		{
			bRemoved = TRUE;
		}
		else
		{
			bRemoved = FALSE;
		}

		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration!
		}
	}

	dwReturn = GetMaxCountTunnelFilters(dwMaxCount);
	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	if(dwMaxCount > 0)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DELETE_TUNNEL_OBJ_NOTDEL, dwMaxCount);
	}

error:
	//error path clean up
	if(pTunnelF)
	{
		SPDApiBufferFree(pTunnelF);
		pTunnelF = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteAuthMethods
//
//Date of Creation: 9-3-2001
//
//Parameters: 	VOID
//
//Return: 		DWORD
//
//Description: This function deletes all the remaining authentication methods.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
DeleteAuthMethods(
	VOID
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwAuthResumeHandle = 0;
	DWORD dwOldResumeHandle = 0; 		// handle for continuation calls
	DWORD dwCountAuth = 0;             	// counting Authentication objects here
	DWORD k=0, l=0;
	DWORD dwVersion = 0;
	BOOL bAuthRemoved = FALSE;
	PMM_AUTH_METHODS   pAuthMeth = NULL;

	for (k = 0; ;k+=dwCountAuth)
	{
		bAuthRemoved = FALSE;
		dwOldResumeHandle = dwAuthResumeHandle;

		dwReturn = EnumMMAuthMethods(g_szDynamicMachine, dwVersion, NULL, 0, 0, &pAuthMeth, &dwCountAuth, &dwAuthResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCountAuth == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		//Deletes all the auth methods. Called by delete all handle.
		for(l=0; l<dwCountAuth; l++)
		{
			dwReturn = DeleteMMAuthMethods(g_szDynamicMachine, dwVersion, pAuthMeth[l].gMMAuthID, NULL);
			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}
			bAuthRemoved = TRUE;

		}
		SPDApiBufferFree(pAuthMeth);
		pAuthMeth = NULL;

		if (bAuthRemoved)
		{
			dwAuthResumeHandle = dwOldResumeHandle; // need to restart enumeration!

		}
	}

error:
	//error path clean up
	if(pAuthMeth)
	{
		SPDApiBufferFree(pAuthMeth);
		pAuthMeth = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteMMFilterRule
//
//Date of Creation: 9-3-2001
//
//Parameters: 		MM_FILTER& MMFilter
//
//Return: 			DWORD
//
//Description: This function deletes the mmfilter for matched rule.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
DeleteMMFilterRule(
	MM_FILTER& MMFilter
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	HANDLE hFilter = NULL;

	dwReturn = OpenMMFilterHandle(g_szDynamicMachine, dwVersion, &MMFilter, NULL, &hFilter);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
    //Delete the matched filter which is passed from the parent function
	dwReturn = DeleteMMFilter(hFilter);

	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = CloseMMFilterHandle(hFilter);
		BAIL_OUT;
	}

	dwReturn = DeleteMMAuthMethods(g_szDynamicMachine, dwVersion, MMFilter.gMMAuthID, NULL);

error:
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteTransportRule
//
//Date of Creation: 9-3-2001
//
//Parameters: 	TRANSPORT_FILTER& TransportFilter
//
//Return: 		DWORD
//
//Description: This function deletes the Transport filter for matched rule.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
DeleteTransportRule(
	TRANSPORT_FILTER& TransportFilter
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	HANDLE hFilter = NULL;

	dwReturn = OpenTransportFilterHandle(g_szDynamicMachine, dwVersion, &TransportFilter, NULL, &hFilter);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
    //Delete the matched filter which is passed from the parent function
	dwReturn = DeleteTransportFilter(hFilter);

	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn  = CloseTransportFilterHandle(hFilter);
	}

error:
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteTunnelRule
//
//Date of Creation: 9-3-2001
//
//Parameters: 	TUNNEL_FILTER& TunnelFilter
//
//Return: 		DWORD
//
//Description: This function deletes the tunnel filter for matched rule.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
DeleteTunnelRule(
	TUNNEL_FILTER& TunnelFilter
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwVersion = 0;
	HANDLE hFilter = NULL;

	dwReturn = OpenTunnelFilterHandle(g_szDynamicMachine, dwVersion, &TunnelFilter, NULL, &hFilter);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
    //Delete the matched filter which is passed from the parent function
	dwReturn = DeleteTunnelFilter(hFilter);

	if(dwReturn != ERROR_SUCCESS)
	{
		PrintErrorMessage(WIN32_ERR, dwReturn, NULL);
		dwReturn = CloseTunnelFilterHandle(hFilter);
	}

error:
	return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//Function:				GetMaxCountMMFilters
//
//Date of Creation:		1-31-2002
//
//Parameters:			DWORD& dwMaxCount
//
//Return: 				DWORD
//
//Description:			Gets the maximum MMFilters count.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
GetMaxCountMMFilters(
	DWORD& dwMaxCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwVersion = 0;
	GUID  gDefaultGUID = {0};    	  	// NULL GUID value
	DWORD i=0;
	PMM_FILTER pMMFilter = NULL;

	dwMaxCount = 0;

	for (i = 0; ;i+=dwCount)
	{

		dwReturn = EnumMMFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS,
										gDefaultGUID, 0, &pMMFilter, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pMMFilter && dwCount > 0))
		{
			BAIL_OUT; // not required to continue.
		}

		dwMaxCount += dwCount;
		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;

	}

error:
	if(pMMFilter)
	{
		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;
	}
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function:				GetMaxCountTransportFilters
//
//Date of Creation:		1-31-2002
//
//Parameters:			DWORD& dwMaxCount
//
//Return: 				DWORD
//
//Description:			Gets the maximum TransportFilters count.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
GetMaxCountTransportFilters(
	DWORD& dwMaxCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;
	DWORD dwCount = 0;                 	// counting objects here
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0;
	DWORD dwVersion = 0;
	PTRANSPORT_FILTER pTransF = NULL;

	dwMaxCount = 0;

	for (i = 0; ;i+=dwCount)
	{
		dwReturn = EnumTransportFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0,
															&pTransF, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pTransF && dwCount > 0))
		{
			BAIL_OUT; // no need continue.
		}

		dwMaxCount += dwCount;
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}
error:
	if(pTransF)
	{
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function:				GetMaxCountTunnelFilters
//
//Date of Creation:		1-31-2002
//
//Parameters:			DWORD& dwMaxCount
//
//Return: 				DWORD
//
//Description:			Gets the maximum TunnelFilters count.
//
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
GetMaxCountTunnelFilters(
	DWORD& dwMaxCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;
	DWORD dwCount = 0;                 	// counting objects here
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0;
	DWORD dwVersion = 0;
	PTUNNEL_FILTER pTunnelF = NULL;

	dwMaxCount = 0;

	for (i = 0; ;i+=dwCount)
	{
		dwReturn = EnumTunnelFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID,
										0, &pTunnelF, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pTunnelF && dwCount > 0))
		{
			BAIL_OUT; // not required to continue.
		}

		dwMaxCount += dwCount;
		SPDApiBufferFree(pTunnelF);
		pTunnelF = NULL;
	}
error:
	if(pTunnelF)
	{
		SPDApiBufferFree(pTunnelF);
		pTunnelF = NULL;
	}
	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\memory.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Module: Dynamic/Memory.h
//
// Purpose: 	Smartdefaults/Relevant Declarations.
//
// Developers Name: Bharat/Radhika
//
// History:
//
//   Date    	Author    	Comments
//	10-8-2001	Bharat		Initial Version.
//  <creation>  <author>
//
//   <modification> <author>  <comments, references to code sections,
//								in case of bug fixes>
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MEMORY_H_
#define _MEMORY_H_

//
//This function will allocates heap memory.
//
LPVOID
AllocADsMem(
	IN DWORD cb
	);

//
//This function will deallocates memory.
//
BOOL
FreeADsMem(
	IN LPVOID pMem
	);

//
//This function will allocate enough local memory to store the specified
//				  string, and copy that string to the allocated memory
//
LPWSTR
AllocADsStr(
	IN OUT LPWSTR pStr
	);

//
//This function deallocates LPWSTR
//
BOOL
FreeADsStr(
	IN LPWSTR pStr
	);
#endif // _MEMORY_H_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\nshcertmgmt.h ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: Dynamic/Nshcertmgmt.h
//
// 	Purpose			: Smartdefaults implementation.
//
// 	Developers Name	: Bharat/Radhika
//
//	History			:
//
//  Date			Author		Comments
//  10-13-2001   	Bharat		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////


#ifndef _NSHCERTMGMT_H_
#define _NSHCERTMGMT_H_

#define MY_ENCODING_TYPE_CERT					X509_ASN_ENCODING

#define BAIL_ON_WIN32ERROR(dwError) \
    if (dwError){ \
        goto error; \
    }


#define BAILOUT									goto error

#define MACHINE_NAME 	(2048)

typedef struct _cert_node
	{
	    LPWSTR pszSubjectName;
	    struct _cert_node * pNext;
	} CERT_NODE, *PCERT_NODE;

BOOL
fIsCertStoreEmpty(
	IN HCERTSTORE hCertStore
	);


extern
DWORD EncodeCertificateName (
	LPTSTR pszSubjectName,
	BYTE **EncodedName,
	DWORD *EncodedNameLength
	);


DWORD
ListCertsInStore(
	IN HCERTSTORE hCertStore,
	OUT INT_IPSEC_MM_AUTH_INFO ** ppAuthInfo,
	OUT PDWORD pdwNumCertificates
	);

DWORD
CopyCertificateNode(
	OUT PINT_IPSEC_MM_AUTH_INFO pCurrentAuth,
	IN PCERT_NODE pTemp
	);

PCERT_NODE
AppendCertificateNode(
	OUT PCERT_NODE pCertificateList,
	IN LPWSTR pszSubjectName
	);

VOID
FreeCertificateList(
	IN PCERT_NODE pCertificateList
	);

DWORD
GetCertificateName(
	IN CERT_NAME_BLOB * pCertNameBlob,
	IN LPWSTR * ppszSubjectName
	);

DWORD
GenerateCertificatesList(
	OUT INT_IPSEC_MM_AUTH_INFO  ** ppAuthInfo,
	OUT PDWORD pdwNumCertificates,
	OUT BOOL *pfIsMyStoreEmpty
	);

VOID
FreeCertificatesList(
	IN INT_IPSEC_MM_AUTH_INFO * pAuthInfo,
	IN DWORD dwNumCertificates
	);

BOOL
FindCertificateInList(
	IN PCERT_NODE pCertificateList,
	IN LPWSTR pszSubjectName
	);

DWORD
ListCertChainsInStore(
	IN HCERTSTORE hCertStore,
	OUT INT_IPSEC_MM_AUTH_INFO ** ppAuthInfo,
	IN PDWORD pdwNumCertificates,
	IN LPCSTR pszUsageIdentifier);

DWORD
CopyCertificate(
	IN PINT_IPSEC_MM_AUTH_INFO pCurrentAuth,
	IN PINT_IPSEC_MM_AUTH_INFO pCurrentAuthFrom
	);

BOOL
IsDomainMember(
	IN LPTSTR pszMachine
	);

DWORD
SmartDefaults(
	IN PINT_IPSEC_MM_AUTH_INFO* ppAuthInfo,
	IN LPTSTR pszMachine,
	IN DWORD * pdwNumberOfAuth,
	IN BOOL bIsDomainPolicy
	);

#endif //_NSHCERTMGMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\nshcache.cpp ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: Static/NshCache.cpp
//
// 	Purpose			: Cache implementation
//
//
// 	Developers Name	: surya
//
//  Description     : Functions implementation for the class NshPolNegFilData
//					  for improving performance by caching the Policy,Filterlist and negpols
//					  (in BatchMode only.)
//
//	History			:
//
//  Date			Author		Comments
//  18-12-2001   	Surya		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"


extern CNshPolNegFilData g_NshPolNegFilData;
extern CNshPolStore g_NshPolStoreHandle;
extern HINSTANCE g_hModule;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction For Class CNshPolStore
//////////////////////////////////////////////////////////////////////

CNshPolStore::CNshPolStore()
{
	hPolicyStorage=NULL;
	bBatchModeOn=FALSE;
}

CNshPolStore::~CNshPolStore()
{
	if(hPolicyStorage)
	{
		IPSecClosePolicyStore(hPolicyStorage);
		//hPolicyStorage=NULL;
	}
	bBatchModeOn=FALSE;
}

//////////////////////////////////////////////////////////////////////
// public member functions For Class CNshPolStore
//////////////////////////////////////////////////////////////////////

DWORD
CNshPolStore::SetBatchmodeStatus(
	 BOOL bStatus
	 )
{
    return ERROR_SUCCESS;
}

BOOL
CNshPolStore::GetBatchmodeStatus()
{
	return FALSE;
}

HANDLE
CNshPolStore::GetStorageHandle()
{
	return hPolicyStorage;
}

VOID
CNshPolStore::SetStorageHandle(
	HANDLE hPolicyStore
	)
{
	if(hPolicyStore)
	{
		if(hPolicyStorage)
		{
			IPSecClosePolicyStore(hPolicyStorage);
			hPolicyStorage=NULL;
		}
		hPolicyStorage=hPolicyStore;
	}
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction For Class CNshPolNegFilData
//////////////////////////////////////////////////////////////////////

CNshPolNegFilData::CNshPolNegFilData()
{
	pPolicyData = NULL;
	pFilterData = NULL;
	pNegPolData = NULL;
}

CNshPolNegFilData::~CNshPolNegFilData()
{
	if (pPolicyData)
	{
		IPSecFreePolicyData(pPolicyData);
		pPolicyData = NULL;
	}
	if(pFilterData)
	{
		IPSecFreeFilterData(pFilterData);
		pFilterData = NULL;
	}
	if(pNegPolData)
	{
		IPSecFreeNegPolData(pNegPolData);
		pNegPolData = NULL;
	}
}

//////////////////////////////////////////////////////////////////////
// public member functions For Class CNshPolNegFilData
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Set member functions
//////////////////////////////////////////////////////////////////////

VOID
CNshPolNegFilData::SetPolicyInCache(
	PIPSEC_POLICY_DATA pPolicy
	)
{
	if (pPolicyData)
	{
		if (!IsEqualGUID(pPolicyData->PolicyIdentifier,pPolicy->PolicyIdentifier))
		{
			IPSecFreePolicyData(pPolicyData);
			pPolicyData=pPolicy;
		}
	}
	else
	{
		pPolicyData=pPolicy;
	}
}

VOID
CNshPolNegFilData::SetFilterListInCache(
	PIPSEC_FILTER_DATA pFilter
	)
{
	if (pFilterData)
	{
		if (!IsEqualGUID(pFilterData->FilterIdentifier,pFilter->FilterIdentifier))
		{
			IPSecFreeFilterData(pFilterData);
			pFilterData=pFilter;
		}
	}
	else
	{
		pFilterData=pFilter;
	}
}

VOID
CNshPolNegFilData::SetNegPolInCache(
	PIPSEC_NEGPOL_DATA pNegPol
	)
{
	if (pNegPolData)
	{
		if (!IsEqualGUID(pNegPolData->NegPolIdentifier,pNegPol->NegPolIdentifier))
		{
			IPSecFreeNegPolData(pNegPolData);
			pNegPolData=pNegPol;
		}
	}
	else
	{
		pNegPolData=pNegPol;
	}
}

//////////////////////////////////////////////////////////////////////
// Get member functions For Class CNshPolNegFilData
//////////////////////////////////////////////////////////////////////

BOOL
CNshPolNegFilData::GetPolicyFromCacheByName(
	LPTSTR pszPolicyName,
	PIPSEC_POLICY_DATA * ppPolicy
	)
{
	BOOL bPolExists=FALSE;

	if (pPolicyData)
	{
		if (_tcscmp(pszPolicyName,pPolicyData->pszIpsecName)==0)
		{
			bPolExists=TRUE;

			if(ppPolicy)
			{
				*ppPolicy=pPolicyData;
			}
		}
	}
	return bPolExists;
}


BOOL
CNshPolNegFilData::GetFilterListFromCacheByName(
	LPTSTR pszFilterListName,
	PIPSEC_FILTER_DATA * ppFilter
	)
{
	BOOL bFLExists=FALSE;

	if (pFilterData)
	{
		if (_tcscmp(pszFilterListName,pFilterData->pszIpsecName)==0)
		{
			bFLExists=TRUE;

			if(ppFilter)
			{
				*ppFilter=pFilterData;
			}
		}
	}
	return bFLExists;
}

BOOL
CNshPolNegFilData::GetNegPolFromCacheByName(
	LPTSTR pszNegPolName,
	PIPSEC_NEGPOL_DATA * ppNegPol
	)
{
	BOOL bNegPolExists=FALSE;

	if (pNegPolData)
	{
		if (_tcscmp(pszNegPolName,pNegPolData->pszIpsecName)==0)
		{
			bNegPolExists=TRUE;

			if(ppNegPol)
			{
				*ppNegPol=pNegPolData;
			}
		}
	}
	return bNegPolExists;
}

//////////////////////////////////////////////////////////////////////
// check member functions For Class CNshPolNegFilData
//////////////////////////////////////////////////////////////////////

BOOL
CNshPolNegFilData::CheckPolicyInCacheByName(
	LPTSTR pszPolicyName
	)
{
	BOOL bPolExists=FALSE;

	if (pPolicyData)
	{
		if (_tcscmp(pszPolicyName,pPolicyData->pszIpsecName)==0)
		{
			bPolExists=TRUE;
		}
	}
	return bPolExists;
}

BOOL
CNshPolNegFilData::CheckFilterListInCacheByName(
	LPTSTR pszFilterListName
	)
{
	BOOL bFLExists=FALSE;

	if (pFilterData)
	{
		if (_tcscmp(pszFilterListName,pFilterData->pszIpsecName)==0)
		{
			bFLExists=TRUE;
		}
	}
	return bFLExists;
}

BOOL
CNshPolNegFilData::CheckNegPolInCacheByName(
	LPTSTR pszNegPolName
	)
{
	BOOL bNegPolExists=FALSE;

	if (pNegPolData)
	{
		if (_tcscmp(pszNegPolName,pNegPolData->pszIpsecName)==0)
		{
			bNegPolExists=TRUE;
		}
	}
	return bNegPolExists;
}

//////////////////////////////////////////////////////////////////////
// Delete member functions For Class CNshPolNegFilData
//////////////////////////////////////////////////////////////////////

VOID
CNshPolNegFilData::DeletePolicyFromCache(
	PIPSEC_POLICY_DATA pPolicy
	)
{
	if (pPolicyData)
	{
		if (IsEqualGUID(pPolicyData->PolicyIdentifier,pPolicy->PolicyIdentifier))
		{
			IPSecFreePolicyData(pPolicyData);
			pPolicyData=NULL;
		}
	}
}

VOID
CNshPolNegFilData::DeleteFilterListFromCache(
	GUID FilterListGUID
	)
{
	if (pFilterData)
	{
		if (IsEqualGUID(pFilterData->FilterIdentifier,FilterListGUID))
		{
			IPSecFreeFilterData(pFilterData);
			pFilterData=NULL;
		}
	}
}

VOID
CNshPolNegFilData::DeleteNegPolFromCache(
	GUID NegPolGUID
	)
{
	if (pNegPolData)
	{
		if (IsEqualGUID(pNegPolData->NegPolIdentifier,NegPolGUID))
		{
			IPSecFreeNegPolData(pNegPolData);
			pNegPolData=NULL;
		}
	}
}

VOID
CNshPolNegFilData::FlushAll()
{
	if (pPolicyData)
	{
		IPSecFreePolicyData(pPolicyData);
		pPolicyData = NULL;
	}
	if(pFilterData)
	{
		IPSecFreeFilterData(pFilterData);
		pFilterData = NULL;
	}
	if(pNegPolData)
	{
		IPSecFreeNegPolData(pNegPolData);
		pNegPolData = NULL;
	}
}

//
// Other Functions implemetation (Wrapper functions for the APIs)
//

/////////////////////////////////////////////////////////////
//
//	Function		: 	CreatePolicyData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore,
//  					PIPSEC_POLICY_DATA pIpsecPolicyData
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Wrapper Function for updating cache
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////


DWORD
CreatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	dwReturnCode=IPSecCreatePolicyData(hPolicyStore,pIpsecPolicyData);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.SetPolicyInCache(pIpsecPolicyData);
		}
	}

	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	CreateFilterData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore,
//  					PIPSEC_FILTER_DATA pIpsecFilterData
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Wrapper Function for updating cache
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
CreateFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	dwReturnCode=IPSecCreateFilterData(hPolicyStore,pIpsecFilterData);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.SetFilterListInCache(pIpsecFilterData);
		}
	}
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	CreateNegPolData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore,
//  					PIPSEC_NEGPOL_DATA pIpsecNegPolData
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Wrapper Function for updating cache
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
CreateNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	dwReturnCode=IPSecCreateNegPolData(hPolicyStore,pIpsecNegPolData);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.SetNegPolInCache(pIpsecNegPolData);
		}
	}
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	SetPolicyData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore,
//  					PIPSEC_POLICY_DATA pIpsecPolicyData
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Wrapper Function for updating cache
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
SetPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	dwReturnCode=IPSecSetPolicyData(hPolicyStore,pIpsecPolicyData);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.SetPolicyInCache(pIpsecPolicyData);
		}
	}
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	SetFilterData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore,
//  					PIPSEC_FILTER_DATA pIpsecFilterData
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Wrapper Function for updating cache
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
SetFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	dwReturnCode=IPSecSetFilterData(hPolicyStore,pIpsecFilterData);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.SetFilterListInCache(pIpsecFilterData);
		}
	}
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	DeletePolicyData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore,
//  					PIPSEC_POLICY_DATA pIpsecPolicyData
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Wrapper Function for deleting Policy
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
DeletePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	dwReturnCode=IPSecDeletePolicyData(hPolicyStore,pIpsecPolicyData);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.DeletePolicyFromCache(pIpsecPolicyData);
		}
	}
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	DeleteFilterData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore,
//  					GUID FilterIdentifier
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Wrapper Function for deleting Filter
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
DeleteFilterData(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    )
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	dwReturnCode=IPSecDeleteFilterData(hPolicyStore,FilterIdentifier);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.DeleteFilterListFromCache(FilterIdentifier);
		}
	}
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	DeleteNegPolData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore,
//  					GUID NegPolIdentifier
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Wrapper Function for deleting NegPol
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
DeleteNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    )
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	dwReturnCode=IPSecDeleteNegPolData(hPolicyStore,NegPolIdentifier);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.DeleteNegPolFromCache(NegPolIdentifier);
		}
	}
	return dwReturnCode;

}

/////////////////////////////////////////////////////////////
//
//	Function		: 	FreePolicyData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//  					PIPSEC_POLICY_DATA pIpsecPolicyData
//
//	Return			: 	VOID
//
//	Description		:	Wrapper Function for Free Policy cache
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

VOID
FreePolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
	if(!g_NshPolStoreHandle.GetBatchmodeStatus())
	{
		if(pIpsecPolicyData)
		{
			IPSecFreePolicyData(pIpsecPolicyData);
			pIpsecPolicyData=NULL;
		}
	}
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	FreeNegPolData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//  					PIPSEC_NEGPOL_DATA pIpsecNegPolData
//
//	Return			: 	VOID
//
//	Description		:	Wrapper Function for Free NegPol Cache
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

VOID
FreeNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
	if(!g_NshPolStoreHandle.GetBatchmodeStatus())
	{
		if(pIpsecNegPolData)
		{
			IPSecFreeNegPolData(pIpsecNegPolData);
			pIpsecNegPolData=NULL;
		}
	}
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	FreeFilterData()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//  					PIPSEC_FILTER_DATA pIpsecFilterData
//
//	Return			: 	VOID
//
//	Description		:	Wrapper Function for Free Filter Cache
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

VOID
FreeFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
	if(!g_NshPolStoreHandle.GetBatchmodeStatus())
	{
		if(pIpsecFilterData)
		{
			IPSecFreeFilterData(pIpsecFilterData);
			pIpsecFilterData=NULL;
		}
	}
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	OpenPolicyStore()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						LPWSTR pszMachineName,
//   					DWORD dwTypeOfStore,
//   					LPWSTR pszFileName,
//   					HANDLE * phPolicyStore
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Implementation for the Openingpolstore in batch mode
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
OpenPolicyStore(
    HANDLE * phPolicyStore
    )
{
	DWORD dwReturnCode = ERROR_SUCCESS;

	if (g_NshPolStoreHandle.GetStorageHandle())
	{
		*phPolicyStore = g_NshPolStoreHandle.GetStorageHandle();
		dwReturnCode = ERROR_SUCCESS;
	}
	else
	{
		dwReturnCode = ERROR_INVALID_DATA;
	}

	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//	Function		: 	ClosePolicyStore()
//
//	Date of Creation: 	21st Aug 2001
//
//	Parameters		:
//						HANDLE hPolicyStore
//
//	Return			: 	DWORD (Win32 Error Code)
//
//	Description		:	Implementation for the ClosingPolstore in batch mode
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
ClosePolicyStore(
    HANDLE hPolicyStore
    )
{
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\dynamicshow.h ===
////////////////////////////////////////////////////////////////////////
//
// 	Module: Dynamic/Dyanamicshow.h
//
// 	Purpose			: Dynamic Show commands for IPSec
//
//
// 	Developers Name	: Bharat/Radhika
//
//
//	History			:
//
//  Date			Author		Comments
//  09-23-2001   	Bharat		Initial Version. V1.0
//  11-21-2001   	Bharat		Initial Version. V1.1
//
////////////////////////////////////////////////////////////////////////

#ifndef _DYNAMICSHOW_H_
#define _DYNAMICSHOW_H_

#include "Nsu.h"

//Registry keys path for IPSec
#define REGKEY_GLOBAL 						_TEXT("System\\CurrentControlSet\\Services\\IPSEC")

//Registry keys default values
#define IPSEC_DIAG_DEFAULT					0
#define	IKE_LOG_DEFAULT						0
#define STRONG_CRL_DEFAULT					0
#define ENABLE_LOGINT_DEFAULT 				3600
#define ENABLE_EXEMPT_DEFAULT				0

#define MY_ENCODING_TYPE 					(X509_ASN_ENCODING)
#define SHA_LENGTH 							21 						//Thumbprint string length + Null

typedef struct _QM_FILTER_VALUE_BOOL{
    BOOL bSrcPort;
    BOOL bDstPort;
    BOOL bProtocol;
    BOOL bActionInbound ;
    BOOL bActionOutbound;
	DWORD dwSrcPort;
	DWORD dwDstPort;
	DWORD dwProtocol;
	DWORD dwActionInbound;
	DWORD dwActionOutbound;
}	 QM_FILTER_VALUE_BOOL, * PQM_FILTER_VALUE_BOOL;


#ifdef __cplusplus

class NshHashTable;

DWORD
ShowMMPolicy(
	IN LPTSTR pszShowPolicyName
	);

VOID
PrintMMPolicy(
	IN IPSEC_MM_POLICY mmPolicy
	);

VOID
PrintMMOffer(
	IN IPSEC_MM_OFFER mmOffer
	);

DWORD
ShowQMPolicy(
	IN LPTSTR pszShowPolicyName
	);

VOID
PrintQMOffer(
	IN IPSEC_QM_OFFER mmOffer
	);

VOID
PrintFilterAction(
	IN IPSEC_QM_POLICY qmPolicy
	);

DWORD
ShowMMFilters(
	IN LPTSTR pszShowFilterName,
	IN BOOL bType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask
);

DWORD
PrintMainmodeFilter(
	IN MM_FILTER MMFltr,
	IN IPSEC_MM_POLICY MMPol,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bType
);

DWORD
ShowQMFilters(
	IN LPTSTR pszShowFilterName,
	IN BOOL bType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue
	);


DWORD
ShowTunnelFilters(
	IN LPTSTR pszShowFilterName,
	IN BOOL bType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue,
	IN OUT BOOL& bNameFin
	);


DWORD
PrintQuickmodeFilter(
	IN TRANSPORT_FILTER TransF,
	IN LPWSTR pszQMName,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bType,
	IN DWORD dwActionFlag
	);

DWORD
PrintQuickmodeFilter(
	IN TUNNEL_FILTER TunnelF,
	IN LPWSTR pszQMName,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bType,
	IN DWORD dwActionFlag
	);

VOID
PrintMYID(
	VOID
	);

VOID
PrintMMSas(
	IN IPSEC_MM_SA MMsas,
	IN BOOL bFormat,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	);

VOID
PrintSACertInfo(
	IN IPSEC_MM_SA& MMsas
	);

DWORD
PrintIkeStats(
	VOID
	);

DWORD
PrintIpsecStats(
	VOID
	);

DWORD
GetNameAudit(
	IN CRYPT_DATA_BLOB *NameBlob,
	IN OUT LPTSTR Name,
	IN DWORD NameBufferSize
	);

DWORD
CertGetSHAHash(
	IN PCCERT_CONTEXT pCertContext,
	IN OUT BYTE* OutHash
	);

VOID
print_vpi(
	IN unsigned char *vpi,
	IN int vpi_len,
	IN OUT char *msg
	);

VOID
GetSubjectAndThumbprint(
	IN PCCERT_CONTEXT pCertContext,
	IN LPTSTR pszSubjectName,
	IN LPSTR pszThumbPrint
	);

VOID
PrintMask(
	IN ADDR addr
	);

BOOL
IsDefaultMMOffers(
	IN IPSEC_MM_POLICY MMPol
	);

VOID
PrintMMFilterOffer(
	IN IPSEC_MM_OFFER MMOffer
	);

VOID
PrintAddrStr(
	IN PADDR pResolveAddress,
	IN NshHashTable& addressHash,
	IN UINT uiFormat = DYNAMIC_SHOW_ADDR_STR
	);

DWORD
CheckMMFilter(
		IN MM_FILTER MMFltr,
		IN ADDR SrcAddr,
		IN ADDR DstAddr,
		IN BOOL bDstMask,
		IN BOOL bSrcMask,
		IN LPWSTR pszShowFilterName
		);

DWORD
CheckQMFilter(
	IN TUNNEL_FILTER TunnelF,
	IN ADDR	SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bDstMask,
	IN BOOL bSrcMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue,
	IN LPWSTR pszShowFilterName
	);

DWORD
CheckQMFilter(
	IN TRANSPORT_FILTER TransF,
	IN ADDR	SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bDstMask,
	IN BOOL bSrcMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue,
	IN LPWSTR pszShowFilterName
	);

DWORD
PrintTransportRuleFilter(
	IN PMM_FILTER pMMFltr,
	IN PIPSEC_MM_POLICY pMMPol,
	IN TRANSPORT_FILTER TransF,
	IN LPWSTR pszQMName,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	);

DWORD
PrintTunnelRuleFilter(
	IN PMM_FILTER pMMFltr,
	IN PIPSEC_MM_POLICY pMMPol,
	IN TUNNEL_FILTER TunnelF,
	IN LPWSTR pszQMName,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	);

DWORD
ShowMMSas(
	IN ADDR Source,
	IN ADDR Destination,
	IN BOOL bFormat,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	);

DWORD
ShowQMSas(
	IN ADDR Source,
	IN ADDR Destination,
	IN DWORD dwProtocol,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	);

VOID
PrintQMSas(
	IN IPSEC_QM_OFFER QMOffer,
	IN BOOL bResolveDNS
	);

DWORD
PrintQMSAFilter(
	IN IPSEC_QM_SA QMsa,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	);

DWORD
ShowRule(
	IN DWORD dwType,
	IN ADDR SrcAddr,
	IN ADDR DesAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN QM_FILTER_VALUE_BOOL QmBoolValue
	);

DWORD
ShowTunnelRule(
	IN DWORD dwType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue,
	IN OUT BOOL& bNameFin
	);

DWORD
ShowStats(
	IN DWORD dwShow
	);

DWORD
ShowRegKeys(
	VOID
	);

VOID
PrintAddr(
	IN ADDR addr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	);

DWORD
AscAddUint(
	IN LPSTR cSum,
	IN LPSTR cA,
	IN LPSTR cB
	);

DWORD
AscMultUint(
	IN LPSTR cProduct,
	IN LPSTR cA,
	IN LPSTR cB
	);

LPSTR
LongLongToString(
	IN DWORD dwHigh,
	IN DWORD dwLow,
	IN int iPrintCommas
	);


#define NSHHASHTABLESIZE 101

class NshHashTable
{
public:
	NshHashTable() throw ();
	~NshHashTable() throw ();

	// insert key, data pair into table
	// failure cases (return value):
	//	key already exists (ERROR_DUPLICATE_TAG)
	//	can't allocate new item in hash table (ERROR_NOT_ENOUGH_MEMORY)
	DWORD Insert(UINT uiNewKey, const char* const szNewData) throw ();

	// clear the HashTable
	void Clear() throw ();

	// find data from key
	// return NULL if key doesnt exist in table
	const char* Find(UINT uiKey) const throw ();

private:
	NSU_LIST table[NSHHASHTABLESIZE];

	// allows us to pass in a good hash value rather than recompute it several times
	const char* Find(UINT uiKey, size_t hash) const throw ();

	size_t Hash(UINT uiKey) const throw ();

	class HashEntry;
	const HashEntry* FindEntry(UINT uiKey, size_t hash) const throw ();

	// not implemented
	NshHashTable(const NshHashTable&) throw ();
	NshHashTable& operator=(const NshHashTable&) throw ();

	class HashEntry
	{
	public:
			HashEntry(
				PNSU_LIST pList,
				const UINT uiNewKey,
				const char* szNewData
				) throw ();
			~HashEntry() throw ();

			static const HashEntry* Get(PNSU_LIST pList) throw ();

			UINT Key() const throw ();
			const char* Data() const throw ();

	private:
			NSU_LIST_ENTRY listEntry;
			const UINT key;
			const char* data;

			// not implemented
			HashEntry& operator=(const HashEntry&) throw ();
	};
};

#endif // __cplusplus

#endif //_DYNAMICSHOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\memory.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//	Module			: 	Dynamic/Memory.cpp
//
//	Purpose			: 	Smartdefaults/Relevant Functions
//
//	Developers Name	: 	Bharat/Radhika
//
//	History			:
//
//  Date    	Author    	Comments
//
//	10-8-2001	Bharat		Initial Version.
//
///////////////////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "memory.h"

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function:	AllocADsMem
//
//	Date of Creation: 10-10-2001
//
//	Parameters		:
//						IN DWORD cb - The amount of memory to allocate
//	Return			: 	LPVOID
//
//						NON-NULL 	- A pointer to the allocated memory
//						FALSE/NULL 	- The operation failed. Extended error status is available using GetLastError.
//
//	Description		:  	This function will allocates heap memory.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////////////////////////
LPVOID
AllocADsMem(
	IN DWORD cb
	)
{
    return(LocalAlloc(LPTR, cb));
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	FreeADsMem
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		:	IN LPVOID pMem
//
//	Return			:	BOOL
//	Description		:  	This function will deallocates memory.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL
FreeADsMem(
	IN LPVOID pMem
	)
{
    return(LocalFree(pMem) == NULL);
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	AllocADsStr
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		:
//						IN LPWSTR pStr - Pointer to the string that needs to be allocated and stored
//
//	Return			:	LPVOID
//						NON-NULL 	- A pointer to the allocated memory
//						FALSE/NULL 	- The operation failed. Extended error status is available using GetLastError.
//
//	Description		:  	This function will allocate enough local memory to store the specified
//				  		string, and copy that string to the allocated memory
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
LPWSTR
AllocADsStr(
	IN LPWSTR pStr
	)
{
	LPWSTR pMem = NULL;

	if (pStr)
	{
		pMem = (LPWSTR)AllocADsMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) );
		if (pMem)
		{
		   wcscpy(pMem, pStr);
		}
	}

	return pMem;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	FreeADsStr
//
//	Date of Creation	: 	10-10-2001
//
//	Parameters			:	IN LPWSTR pStr
//
//	Return				:	BOOL
//
//	Description			:  	This function deallocates LPWSTR.
//
//	Revision History	:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL
FreeADsStr(
	IN LPWSTR pStr
	)
{
   return pStr ? FreeADsMem(pStr)
               : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\nshcache.h ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: NshCache.h
//
// 	Purpose			: Interface for the PolicyStore Handle, Policy, FilterList
//					  and NegPol Data
//
// 	Developers Name	: Surya
//
//	History			:
//
//  Date			Author		Comments
//  12-16-2001   	surya		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////


#ifndef _NSHCACHE_H_
#define _NSHCACHE_H_

//
// Class for caching PolStore Handle
//
class CNshPolStore
{
	HANDLE hPolicyStorage;
	BOOL bBatchModeOn;
public:
	CNshPolStore();
	virtual ~CNshPolStore();
	DWORD SetBatchmodeStatus(BOOL bStatus);
	BOOL GetBatchmodeStatus();
	HANDLE GetStorageHandle();
	VOID SetStorageHandle(HANDLE hPolicyStore);
};

//
// Class for caching Policy, FilterList & NegPol
//
class CNshPolNegFilData
{
private:

	PIPSEC_POLICY_DATA pPolicyData;
	PIPSEC_FILTER_DATA pFilterData;
	PIPSEC_NEGPOL_DATA pNegPolData;

public:
	//contructor
	CNshPolNegFilData();
	//destructor
	virtual ~CNshPolNegFilData();
	//other member functions
	VOID
	SetPolicyInCache(
		PIPSEC_POLICY_DATA pPolicy
		);
	VOID
	SetFilterListInCache(
		PIPSEC_FILTER_DATA pFilter
		);
	VOID
	SetNegPolInCache(
		PIPSEC_NEGPOL_DATA pNegPol
		);
	BOOL
	GetPolicyFromCacheByName(
		LPTSTR pszPolicyName,
		PIPSEC_POLICY_DATA * ppPolicy
		);
	BOOL
	GetFilterListFromCacheByName(
		LPTSTR pszFilterListName,
		PIPSEC_FILTER_DATA * ppFilter
		);
	BOOL
	GetNegPolFromCacheByName(
		LPTSTR pszNegPolName,
		PIPSEC_NEGPOL_DATA * ppNegPol
		);
	BOOL
	CheckPolicyInCacheByName(
		LPTSTR pszPolicyName
		);
	BOOL
	CheckFilterListInCacheByName(
		LPTSTR pszFilterListName
		);
	BOOL
	CheckNegPolInCacheByName(
		LPTSTR pszNegPolName
		);
	VOID
	DeletePolicyFromCache(
		PIPSEC_POLICY_DATA pPolicy
		);
	VOID
	DeleteFilterListFromCache(
		GUID FilterListGUID
		);
	VOID
	DeleteNegPolFromCache(
		GUID NegPolGUID
		);
	VOID
	FlushAll();
};

//Wrapper API function ProtoTypes

DWORD
CreatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
CreateFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
CreateNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
SetPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
SetFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
DeletePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DeleteFilterData(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    );

DWORD
DeleteNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    );

VOID
FreePolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

VOID
FreeNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

VOID
FreeFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
OpenPolicyStore(
	HANDLE * phPolicyStore
	);

DWORD
ClosePolicyStore(
	HANDLE hPolicyStore
	);


#endif // _NSHCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\dynamicshow.cpp ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: Dynamic/DyanamicShow.cpp
//
// 	Purpose			: Dynamic Show commands Implementation.
//
//
// 	Developers Name	: Bharat/Radhika
//
//	History			:
//
//  Date			Author		Comments
//  9-23-2001   	Bharat		Initial Version. V1.0
//  11-21-2001   	Bharat		Version. V1.1
//
////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"
#include "staticshowutils.h"

extern HINSTANCE g_hModule;
extern HKEY g_hGlobalRegistryKey;
extern _TCHAR* g_szDynamicMachine;
extern STORAGELOCATION g_StorageLocation;

UINT QMPFSDHGroup(DWORD dwPFSGroup);

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	ShowMMPolicy
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN LPTSTR pszShowPolicyName
//
//	Return			: 	DWORD
//
//	Description		: 	This function prepares data to display Mainmode Policies.
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowMMPolicy(
	IN LPTSTR pszShowPolicyName
	)
{
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD i=0, j=0;
	DWORD dwReturn = ERROR_SUCCESS;		// assume success
	DWORD dwVersion = 0;
	BOOL bNameFin = FALSE;
	PIPSEC_MM_POLICY pIPSecMMP = NULL;	// for MM policy calls

	for(i = 0; ;i+=dwCount)
	{
		dwReturn = EnumMMPolicies(g_szDynamicMachine, dwVersion, NULL, 0, 0, &pIPSecMMP, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			if (i == 0)
			{
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_MMP_6);
				//This is to avoid one more error message show up!!
				bNameFin = TRUE;
			}
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pIPSecMMP && dwCount > 0))
		{
			// not required to continue.
			BAIL_OUT;
		}
		// Show all the main mode policies
		if(!pszShowPolicyName)
		{
			for (j = 0; j < dwCount; j++)
			{
				PrintMMPolicy(pIPSecMMP[j]);

			}
		}
		// Show main mode policy for the given policy name.
		else if(pszShowPolicyName)
		{
			for (j = 0; j < dwCount; j++)
			{
				if(_tcsicmp(pIPSecMMP[j].pszPolicyName,pszShowPolicyName) == 0)
				{
					PrintMMPolicy(pIPSecMMP[j]);
					bNameFin = TRUE;
					BAIL_OUT;
				}
			}
		}

		SPDApiBufferFree(pIPSecMMP);
		pIPSecMMP=NULL;
	}

error:
	if(pszShowPolicyName && !bNameFin)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_MMP_5);
		dwReturn = ERROR_SUCCESS;
	}

	if(pIPSecMMP)
	{
		//error path clean up
		SPDApiBufferFree(pIPSecMMP);
		pIPSecMMP=NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	PrintMMPolicy
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN IPSEC_MM_POLICY MMPolicy
//
//	Return			: 	DWORD
//
//	Description		: 	This function displays headings and policy name for Mainmode Policy.
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintMMPolicy(
	IN IPSEC_MM_POLICY MMPolicy
	)
{
	DWORD i = 0;

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_POLNAME, MMPolicy.pszPolicyName );
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SOFTSA,  MMPolicy.uSoftExpirationTime);

	if(MMPolicy.dwOfferCount>0)				//offers are greater than 0, print the header for it
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_COLUMN_HEADING);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_COLUMN_HEADING_UNDERLINE);
	}
	for (i = 0; i < MMPolicy.dwOfferCount; i++)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintMMOffer(MMPolicy.pOffers[i]);

	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintMMOffer
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN IPSEC_MM_OFFER MMOffer
//
//Return:		VOID
//
//Description: This function displays offer details for each Mainmode Policy.
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintMMOffer(
	IN IPSEC_MM_OFFER MMOffer
	)
{
	//This is to display DH2048 as 3
	if(MMOffer.dwDHGroup == DH_GROUP_2048)
	{
		MMOffer.dwDHGroup = 2048;
	}
	//Display of Encryption algorithm
	switch(MMOffer.EncryptionAlgorithm.uAlgoIdentifier)
	{
		case 1:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_ESP_DES_ALGO);
			break;
		case 2:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_ESP_UNKNOWN_ALGO);
			break;
		case 3:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_ESP_3DES_ALGO);
			break;
		case 0:
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_ESP_NONE_ALGO);
			break;

	}
	//Display of Hash algorithm
	switch(MMOffer.HashingAlgorithm.uAlgoIdentifier)
	{

		case 1:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_AH_MD5_ALGO);
			break;
		case 2:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_AH_SHA1_ALGO);
			break;
		case 0:
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_AH_NONE_ALGO);
			break;

	}
	//IF QMPERMM is 1 then 1 (MMPFS) is displayed.
	if(MMOffer.dwQuickModeLimit != 1)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_DH_LIFE_QMLIMIT,MMOffer.dwDHGroup, MMOffer.Lifetime.uKeyExpirationKBytes, MMOffer.Lifetime.uKeyExpirationTime, MMOffer.dwQuickModeLimit );
	}
	else
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_DH_LIFE_QMLIMIT_MMPFS,MMOffer.dwDHGroup, MMOffer.Lifetime.uKeyExpirationKBytes, MMOffer.Lifetime.uKeyExpirationTime);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: ShowQMPolicy
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN LPTSTR pszShowPolicyName
//
//Return: 		DWORD
//
//Description: This function prepares data to display quickmode Policy.
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowQMPolicy(
	IN LPTSTR pszShowPolicyName
	)
{
	DWORD dwCount = 0;                 // counting objects here
	DWORD dwResumeHandle = 0;          // handle for continuation calls
	DWORD i=0, j=0;
	DWORD dwReturn = ERROR_SUCCESS;		// assume success
	DWORD dwVersion = 0;
	BOOL bNameFin = FALSE;
	PIPSEC_QM_POLICY pIPSecQMP = NULL;      // for QM policy calls

	for (i = 0; ;i+=dwCount)
	{
		dwReturn = EnumQMPolicies(g_szDynamicMachine, dwVersion, NULL, 0, 0, &pIPSecQMP, &dwCount, &dwResumeHandle, NULL);
		//If there is no data Bail out.
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			if (i == 0)
			{
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_QMP_6);
				//This is to avoid one more error message show up!!
				bNameFin = TRUE;
			}
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		if(!(pIPSecQMP && dwCount > 0))
		{
			BAIL_OUT; // not required to continue.
		}
		//Show all QMPolicies
		if(!pszShowPolicyName)
		{
			for (j = 0; j < dwCount; j++)
			{
				PrintFilterAction(pIPSecQMP[j]);
			}
		}
		//Show QMPolicy for the given name
		else if(pszShowPolicyName)
		{
			for (j = 0; j < dwCount; j++)
			{
				if(_tcsicmp(pIPSecQMP[j].pszPolicyName,pszShowPolicyName) == 0)
				{
					PrintFilterAction(pIPSecQMP[j]);
					bNameFin = TRUE;
					BAIL_OUT;
				}

			}
		}

		SPDApiBufferFree(pIPSecQMP);
		pIPSecQMP=NULL;
	}

error:
	if(pszShowPolicyName && !bNameFin)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_QMP_5);
		dwReturn = ERROR_SUCCESS;
	}

	if(pIPSecQMP)
	{
		//error path cleanup
		SPDApiBufferFree(pIPSecQMP);
		pIPSecQMP=NULL;
	}
	return dwReturn;

}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintFilterAction
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN IPSEC_QM_POLICY QMPolicy
//
//Return:		VOID
//
//Description: This function displays quickmode Policy name and headers.
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintFilterAction(
	IN IPSEC_QM_POLICY QMPolicy
	)
{
	DWORD i = 0;
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_NEGOTIATION_NAME, QMPolicy.pszPolicyName);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	if(QMPolicy.dwOfferCount>0)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_COLUMN_HEADING);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_COLUMN_HEADING_UNDERLINE);
	}

	for (i = 0; i < QMPolicy.dwOfferCount; i++)
	{
		PrintQMOffer(QMPolicy.pOffers[i]);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintQMOffer
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN IPSEC_QM_OFFER QMOffer
//
//Return:		VOID
//
//Description: This function displays quickmode Policy offers.
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintQMOffer(
	IN IPSEC_QM_OFFER QMOffer
	)
{
	DWORD i=0;
	DWORD dwFlag = 0;
	if(QMOffer.dwNumAlgos > 0)
	{
  		for (i = 0; i < QMOffer.dwNumAlgos; i++)
		{
			//If the number algos is exactly one (either Authentication or encryption)
			//print the Pfs group and lifetime after the algo is printed
			if(QMOffer.dwNumAlgos == 1)
				dwFlag = 2;
			// '+' is required to be printed if both encryption and
			// authentication algo are present in an offer
			if(dwFlag == 1 )
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_PLUS);

			if(QMOffer.Algos[i].Operation == AUTHENTICATION)
			{

				switch(QMOffer.Algos[i].uAlgoIdentifier)
				{
					case 1:
						if(QMOffer.dwNumAlgos == 1)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_AH_MD5_ALGO);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_AH_MD5);
							//Increment the flag for printing lifetime and pfs group
							dwFlag++;
						}
						break;
					case 2:
						if(QMOffer.dwNumAlgos == 1)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_AH_SHA1_ALGO);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_AH_SHA1);
							dwFlag++;
						}
						break;
					case 0:
						if(QMOffer.dwNumAlgos == 1)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_AH_NONE_ALGO);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_AH_NONE);
							dwFlag++;
						}
						break;
					default:
						if(QMOffer.dwNumAlgos == 1)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_AH_ERR_SPACE);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_AH_ERR);
							dwFlag++;
						}
						break;
				}
			}
			else if(QMOffer.Algos[i].Operation == ENCRYPTION)
			{
				switch(QMOffer.Algos[i].uAlgoIdentifier)
				{
					case 1:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_ESP_DES_ALGO);
						break;
					case 2:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_ESP_ERR_ALGO);
						break;
					case 3:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_ESP_3DES_ALGO);
						break;
					case 0:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_ESP_NONE_ALGO);
						break;
					default:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_ESP_ERR_ALGO);
						break;
				}
				switch(QMOffer.Algos[i].uSecAlgoIdentifier)
				{
					case 1:
						if(QMOffer.dwNumAlgos == 1)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_MD5_ALGO);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							//Increment the flag for printing lifetime and pfs group
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_MD5);
							dwFlag++;
						}
						break;
					case 2:
						if(QMOffer.dwNumAlgos == 1)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SHA1_ALGO);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SHA1);
							dwFlag++;
						}
						break;
					case 0:
						if(QMOffer.dwNumAlgos == 1)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_NONE_ALGO);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_NONE);
							dwFlag++;
						}
						break;
					default:
						if(QMOffer.dwNumAlgos == 1)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_ERR_SPACE);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_ERR);
							dwFlag++;
						}
						break;
				}
			}
			else
			{
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_ERROR_ALGO);
			}
			//Print lifetime and pfsgroup only if all the 2 algos are printed with a plus sign
			// or printed only if one algo is present in the qmoffer.
			if(dwFlag == 2)
			{
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_LIFETIME, QMOffer.Lifetime.uKeyExpirationKBytes, QMOffer.Lifetime.uKeyExpirationTime);
				if(QMOffer.bPFSRequired)
				{
					PrintMessageFromModule(g_hModule, QMPFSDHGroup(QMOffer.dwPFSGroup));
				}
				else
				{
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_PFS_NONE);
				}
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		    }
		}
	}

}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: ShowMMFilters
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN LPTSTR pszShowFilterName,
//				IN LPTSTR pszShowPolicyName
//
//Return: 		DWORD
//
//Description: This function displays both generic and specific mainmode filters.
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowMMFilters(
	IN LPTSTR pszShowFilterName,
	IN BOOL bType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;
	DWORD dwSpecificResumeHandle = 0;  	// handle for continuation calls
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwSpecificCount = 0;         	// counting objects here
	DWORD dwVersion = 0;
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0, j=0, l=0;
	DWORD dwTempCnt = 0;
	BOOL bNameFin=FALSE;
	BOOL bPrint = FALSE;
	BOOL bPrintIN = FALSE;
	PIPSEC_MM_POLICY pMMPolicy = NULL;
	PMM_FILTER pMMFilter = NULL;
	PMM_FILTER pSpecificMMFilter = NULL;
	//Print generic filters
	if(bType)
	{

		for (i = 0; ;i+=dwCount)
		{
			dwReturn = EnumMMFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0, &pMMFilter, &dwCount, &dwResumeHandle, NULL);

			if (dwReturn == ERROR_NO_DATA || dwCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;
			}
			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pMMFilter && dwCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (j = 0; j < dwCount; j++)
			{
				//Get the corresponding MMPolicy associated with the filter.
				dwReturn = GetMMPolicyByID(g_szDynamicMachine, dwVersion, pMMFilter[j].gPolicyID, &pMMPolicy, NULL);
				if(dwReturn != ERROR_SUCCESS)
				{
					BAIL_OUT;
				}
				//Check for the user given parameters. If exists prints the corresponding record
				//otherwise continues for next iteration
				dwReturn = CheckMMFilter(pMMFilter[j], SrcAddr, DstAddr, bDstMask, bSrcMask, pszShowFilterName);
				if(dwReturn == ERROR_SUCCESS)
				{
					if(!bPrint)
					{
						//If it is first time print the header.
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SUB_HEADING);
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_GENERIC_HEADING);
						bPrint = TRUE;
					}
					//Print the filter data.
					dwReturn = PrintMainmodeFilter(pMMFilter[j], pMMPolicy[0], addressHash, bResolveDNS, bType);
					dwTempCnt++;
					bNameFin = TRUE;
				}

				SPDApiBufferFree(pMMPolicy);
				pMMPolicy = NULL;
			}
			SPDApiBufferFree(pMMFilter);
			pMMFilter = NULL;

		}

		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_GENERIC_FILTERS, dwTempCnt);
		}

	}
	//Print specific filters
	else if(!bType)
	{
		for (i = 0; ;i+=dwSpecificCount)
		{
			dwReturn = EnumMMFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_SPECIFIC_FILTERS, gDefaultGUID, 0, &pSpecificMMFilter, &dwSpecificCount, &dwSpecificResumeHandle, NULL);
			if (dwReturn == ERROR_NO_DATA || dwSpecificCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pSpecificMMFilter && dwSpecificCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (l = 0; l < dwSpecificCount; l++)
			{
				//Get the corresponding MMPolicy associated with the filter.
				dwReturn = GetMMPolicyByID(g_szDynamicMachine, dwVersion, pSpecificMMFilter[l].gPolicyID, &pMMPolicy, NULL);
				if(dwReturn!=ERROR_SUCCESS)
				{
					BAIL_OUT;
				}
				//First print all specific outbound filters.
				if(pSpecificMMFilter[l].dwDirection == FILTER_DIRECTION_OUTBOUND)
				{
					//Check for the user given parameters. If exists prints the corresponding record
					//otherwise continues for next iteration
					dwReturn = CheckMMFilter(pSpecificMMFilter[l], SrcAddr, DstAddr, bDstMask, bSrcMask, pszShowFilterName);
					if(dwReturn == ERROR_SUCCESS)
					{
						if(!bPrint)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SUB_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SPECIFIC_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OUTBOUND_HEADING);
							bPrint = TRUE;
						}
						//Print the filter data.
						dwReturn = PrintMainmodeFilter(pSpecificMMFilter[l], pMMPolicy[0], addressHash, bResolveDNS, bType);
						dwTempCnt++;
						bNameFin = TRUE;
					}

					SPDApiBufferFree(pMMPolicy);
					pMMPolicy = NULL;
				}
			}

			SPDApiBufferFree(pSpecificMMFilter);
			pSpecificMMFilter = NULL;

		}
		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_SPECIFIC_OUTBOUND, dwTempCnt);
		}

		dwSpecificCount = 0;
		dwSpecificResumeHandle = 0;
		pSpecificMMFilter = NULL;
		dwTempCnt = 0;

		for (i = 0; ;i+=dwSpecificCount)
		{
			dwReturn = EnumMMFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_SPECIFIC_FILTERS, gDefaultGUID, 0, &pSpecificMMFilter, &dwSpecificCount, &dwSpecificResumeHandle, NULL);
			if (dwReturn == ERROR_NO_DATA || dwSpecificCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pSpecificMMFilter && dwSpecificCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (l = 0; l < dwSpecificCount; l++)
			{
				//Get the corresponding MMPolicy associated with the filter.
				dwReturn = GetMMPolicyByID(g_szDynamicMachine, dwVersion, pSpecificMMFilter[l].gPolicyID, &pMMPolicy, NULL);
				if(dwReturn!=ERROR_SUCCESS)
				{
					BAIL_OUT;
				}
				//Then print all the specific inbound filters
				if(pSpecificMMFilter[l].dwDirection == FILTER_DIRECTION_INBOUND)
				{
					//Check for the user given parameters. If exists prints the corresponding record
					//otherwise continues for next iteration
					dwReturn = CheckMMFilter(pSpecificMMFilter[l],SrcAddr, DstAddr, bDstMask, bSrcMask, pszShowFilterName);

					if(dwReturn == ERROR_SUCCESS)
					{
						if(!bPrintIN)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SUB_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SPECIFIC_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_INBOUND_HEADING);
							bPrintIN = TRUE;

						}
						//Print the filter data.
						dwReturn = PrintMainmodeFilter(pSpecificMMFilter[l], pMMPolicy[0], addressHash, bResolveDNS, bType);
						dwTempCnt++;
						bNameFin = TRUE;
					}

					SPDApiBufferFree(pMMPolicy);
					pMMPolicy = NULL;
				}
			}
			SPDApiBufferFree(pSpecificMMFilter);
			pSpecificMMFilter = NULL;
		}
		//print number of filters
		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_SPECIFIC_INBOUND, dwTempCnt);
		}
	}

error:
	if(!bNameFin)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		if(pszShowFilterName)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_MMF_8);
		}
		else
		{
			if(bType)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_MMF_6);
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_MMF_7);
			}
		}
		dwReturn = ERROR_SUCCESS;
	}
	// error path clean up
	if(pMMPolicy)
	{
		SPDApiBufferFree(pMMPolicy);
		pMMPolicy = NULL;
	}

	if(pMMFilter)
	{
		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;
	}

	if(pSpecificMMFilter)
	{
		SPDApiBufferFree(pSpecificMMFilter);
		pSpecificMMFilter = NULL;
	}

	return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: CheckMMFilter
//
//Date of Creation: 11-21-2001
//
//Parameters: 	IN MM_FILTER MMFltr,
//				IN ADDR SrcAddr,
//				IN ADDR DstAddr,
//				IN BOOL bDstMask,
//				IN BOOL bSrcMask,
//              IN LPWSTR pszShowFilterName
//
//Return: 		DWORD
//
//Description: This function prepares data for displaying mainmode filter
//             and validates the input.
//
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
CheckMMFilter(
		IN MM_FILTER MMFltr,
		IN ADDR SrcAddr,
		IN ADDR DstAddr,
		IN BOOL bDstMask,
		IN BOOL bSrcMask,
		IN LPWSTR pszShowFilterName)
{

	DWORD dwReturn = ERROR_SUCCESS;

	while(1)
	{
		//Validates user given input for Source address
		switch(SrcAddr.AddrType)
		{
			case IP_ADDR_WINS_SERVER:
			case IP_ADDR_DHCP_SERVER:
			case IP_ADDR_DNS_SERVER:
			case IP_ADDR_DEFAULT_GATEWAY:
				if(MMFltr.SrcAddr.AddrType != SrcAddr.AddrType)
				{
					dwReturn = ERROR_NO_DISPLAY;
					BAIL_OUT;
				}
				break;
			default:
				if(SrcAddr.uIpAddr != 0xFFFFFFFF)
				{
					if(MMFltr.SrcAddr.uIpAddr != SrcAddr.uIpAddr)
					{
						dwReturn = ERROR_NO_DISPLAY;
						BAIL_OUT;
					}
				}
				break;
		}
		//Validates user given input for Destination address
		switch(DstAddr.AddrType)
		{
			case IP_ADDR_WINS_SERVER:
			case IP_ADDR_DHCP_SERVER:
			case IP_ADDR_DNS_SERVER:
			case IP_ADDR_DEFAULT_GATEWAY:
				if(MMFltr.DesAddr.AddrType != DstAddr.AddrType)
				{
					dwReturn = ERROR_NO_DISPLAY;
					BAIL_OUT;
				}
				break;
			default:
				if(DstAddr.uIpAddr != 0xFFFFFFFF)
				{
					if(MMFltr.DesAddr.uIpAddr != DstAddr.uIpAddr)
					{
						dwReturn = ERROR_NO_DISPLAY;
						BAIL_OUT;
					}
				}
				break;
		}
		//Validates user given input for Destination mask
		if(bDstMask)
		{
			if(MMFltr.DesAddr.uSubNetMask != DstAddr.uSubNetMask)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Source mask
		if(bSrcMask)
		{
			if(MMFltr.SrcAddr.uSubNetMask != SrcAddr.uSubNetMask)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Filter name
		if(pszShowFilterName!=NULL)
		{
			if(_tcsicmp(MMFltr.pszFilterName, pszShowFilterName) != 0)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}

		//everything fine... all matched
		BAIL_OUT;
	}

error:
	return dwReturn;

}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintMainmodeFilter
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN MM_FILTER MMFltr
//				IN NshHashTable& addressHash
//
//Return: 		DWORD
//
//Description: This function displays quickmode Policy in verbose.
//
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
PrintMainmodeFilter(
	IN MM_FILTER MMFltr,
	IN IPSEC_MM_POLICY MMPol,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bType
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD i = 0;
	DWORD dwVersion = 0;
	LPTSTR pszCertStr = NULL;

	PINT_MM_AUTH_METHODS pIntMMAuth = NULL;
	PMM_AUTH_METHODS pMMAM = NULL;

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNDERLINE);

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NAME, MMFltr.pszFilterName);

	//Print Weight
	if(!bType)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_FILTER_WEIGHT, MMFltr.dwWeight);
	}

	//Print Connection Type
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_HEADING);
	switch(MMFltr.InterfaceType)
	{
		case INTERFACE_TYPE_ALL:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_ALL);
			break;
		case INTERFACE_TYPE_LAN:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_LAN);
			break;
		case INTERFACE_TYPE_DIALUP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_DIALUP);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_UNKNOWN);
			break;
	}
	//Print Source Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_ADDR_HEADING);
	PrintAddr(MMFltr.SrcAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(MMFltr.SrcAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}

	//Print Destination Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DST_ADDR_HEADING);
	PrintAddr(MMFltr.DesAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(MMFltr.DesAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}
	//Print Authentication Methods.
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_AUTH_HEADING);

	dwReturn = GetMMAuthMethods(g_szDynamicMachine, dwVersion, MMFltr.gMMAuthID, &pMMAM, NULL);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
	//This is conversion from old structure to the new structure.
	dwReturn = ConvertExtMMAuthToInt(pMMAM, &pIntMMAuth);

	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	for (i = 0; i < pIntMMAuth[0].dwNumAuthInfos; i++)
	{
		switch(pIntMMAuth[0].pAuthenticationInfo[i].AuthMethod)
		{
			case IKE_PRESHARED_KEY:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_PRE_KEY_HEADING);
				break;
			case IKE_DSS_SIGNATURE:
			case IKE_RSA_SIGNATURE:
			case IKE_RSA_ENCRYPTION:
				dwReturn = DecodeCertificateName(pIntMMAuth[0].pAuthenticationInfo[i].pAuthInfo, pIntMMAuth[0].pAuthenticationInfo[i].dwAuthInfoSize, &pszCertStr);
				if (dwReturn != ERROR_SUCCESS)
				{
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNKNOWN_CERT);
				}
				else
				{
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NEWLINE_TAB);
					if (pszCertStr)
					{
							DisplayCertInfo(pszCertStr, pIntMMAuth->pAuthenticationInfo[i].dwAuthFlags);
							delete [] pszCertStr;
							pszCertStr = NULL;
					}
				}

				break;
			case IKE_SSPI:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_KERB);
				break;
			default:
				break;
		}
	}

error:
	//Print Security Methods
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SEC_METHOD_HEADING);
	// Count
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_CNT,MMPol.dwOfferCount);

	if(IsDefaultMMOffers(MMPol))
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_DEFAULT_OFFER);
	}

	for (i = 0; i < MMPol.dwOfferCount; i++)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintMMFilterOffer(MMPol.pOffers[i]);
	}
	//error path clean up
	if(pMMAM)
	{
		SPDApiBufferFree(pMMAM);
		pMMAM = NULL;
	}

	if(pIntMMAuth)
	{
		SPDApiBufferFree(pIntMMAuth);
		pIntMMAuth = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: IsDefaultMMOffers
//
//Date of Creation: 11-21-2001
//
//Parameters: 	IN IPSEC_MM_POLICY MMPol
//
//Return: 		BOOL
//
//Description: This function checks for default MM offers
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL
IsDefaultMMOffers(
	IN IPSEC_MM_POLICY MMPol
	)
{
	BOOL bDefaultOffer = FALSE;

	if(MMPol.dwOfferCount == 3)
	{
		if((MMPol.pOffers[0].EncryptionAlgorithm.uAlgoIdentifier == CONF_ALGO_3_DES)
		   &&(MMPol.pOffers[0].HashingAlgorithm.uAlgoIdentifier == AUTH_ALGO_SHA1)
		   &&(MMPol.pOffers[0].dwDHGroup == POTF_OAKLEY_GROUP2)
		   &&(MMPol.pOffers[1].EncryptionAlgorithm.uAlgoIdentifier == CONF_ALGO_3_DES)
		   &&(MMPol.pOffers[1].HashingAlgorithm.uAlgoIdentifier == AUTH_ALGO_MD5)
		   &&(MMPol.pOffers[1].dwDHGroup == POTF_OAKLEY_GROUP2)
		   &&(MMPol.pOffers[2].EncryptionAlgorithm.uAlgoIdentifier == CONF_ALGO_3_DES)
		   &&(MMPol.pOffers[2].HashingAlgorithm.uAlgoIdentifier == AUTH_ALGO_SHA1)
		   &&(MMPol.pOffers[2].dwDHGroup == POTF_OAKLEY_GROUP2048))
		   {
			   bDefaultOffer=TRUE;
		   }
	}

	return bDefaultOffer;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintMMFilterOffer
//
//Date of Creation: 11-21-2001
//
//Parameters: 	IN IPSEC_MM_OFFER MMOffer
//
//Return: 		VOID
//
//Description: This function prints MM offers
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintMMFilterOffer(
	IN IPSEC_MM_OFFER MMOffer
	)
{
	//This is to display DH2048 as 3
	if(MMOffer.dwDHGroup == DH_GROUP_2048)
	{
		MMOffer.dwDHGroup = 3;
	}
	//Print Encryption algorithm
	switch(MMOffer.EncryptionAlgorithm.uAlgoIdentifier)
	{
		case 1:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_DES_ALGO);
			break;
		case 2:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_UNKNOWN_ALGO);
			break;
		case 3:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_3DES_ALGO);
			break;
		case 0:
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_NONE_ALGO);
			break;
	}
	//Print Hash algorithm
	switch(MMOffer.HashingAlgorithm.uAlgoIdentifier)
	{

		case 1:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_MD5_ALGO);
			break;
		case 2:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_SHA1_ALGO);
			break;
		case 0:
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_AH_NONE_ALGO);
			break;

	}
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_DH_QMLIMIT,MMOffer.dwDHGroup, MMOffer.Lifetime.uKeyExpirationTime, MMOffer.dwQuickModeLimit );
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: ShowQMFilters
//
//Date of Creation: 11-21-2001
//
//Parameters: 	IN LPTSTR pszShowFilterName,
//				IN LPTSTR pszShowPolicyName
//
//Return: 		DWORD
//
//Description: This function prepares data for displaying quick mode filters.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowQMFilters(
	IN LPTSTR pszShowFilterName,
	IN BOOL bType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwSpecificResumeHandle = 0;  	// handle for continuation calls
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwSpecificCount = 0;
	DWORD dwActionFlag = 0;
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0, j=0, l=0;
	DWORD dwVersion = 0;
	BOOL bNameFin = FALSE;
	DWORD dwTempCnt = 0;
	LPWSTR pszQMName = NULL;
	BOOL bPrint = FALSE;
	BOOL bPrintIN = FALSE;
	PIPSEC_QM_POLICY pQMPolicy = NULL;
	PTRANSPORT_FILTER pTransF = NULL;
	PTRANSPORT_FILTER pSpecificTransF = NULL;
	//Print generic filters
	if(bType)
	{
		for (i = 0; ;i+=dwCount)
		{
			dwReturn = EnumTransportFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS,
													gDefaultGUID, 0, &pTransF, &dwCount, &dwResumeHandle, NULL);

			if (dwReturn == ERROR_NO_DATA || dwCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pTransF && dwCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (j = 0; j < dwCount; j++)
			{
				//Get the corresponding QMPolicy for the Transport filter
				dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, pTransF[j].gPolicyID, 0, &pQMPolicy, NULL);
				if(dwReturn == ERROR_SUCCESS)
				{
					pszQMName = pQMPolicy[0].pszPolicyName;
				}
				else
				{
					//If there is no corresponding filter NULL is passed to the function,
					//so that it is not printed.
					pszQMName = NULL;
					dwReturn = ERROR_SUCCESS;
				}
				//To print inbound and outbound action
				dwActionFlag = 0;

				//Check for the user given parameters. If exists prints the corresponding record
				//otherwise continues for next iteration
				dwReturn = CheckQMFilter(pTransF[j], SrcAddr, DstAddr,
										 bDstMask, bSrcMask, QMBoolValue,
										 pszShowFilterName);
				if(dwReturn == ERROR_SUCCESS )
				{
					if(!bPrint)
					{
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TRANSPORT_HEADING);
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_GENERIC_HEADING);
						bPrint = TRUE;
					}
					bNameFin = TRUE;
					dwTempCnt++;
					//Print the transport filter
					dwReturn = PrintQuickmodeFilter(pTransF[j], pszQMName, addressHash, bResolveDNS, bType, dwActionFlag);
				}

				if(pQMPolicy)
				{
					SPDApiBufferFree(pQMPolicy);
					pQMPolicy = NULL;
				}
			}
			SPDApiBufferFree(pTransF);
			pTransF = NULL;
		}
		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_GENERIC_FILTERS, dwTempCnt);
		}
	}
	//Print specific filters
	else if(!bType)
	{
		for (i = 0; ;i+=dwSpecificCount)
		{
			dwReturn = EnumTransportFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_SPECIFIC_FILTERS,
									gDefaultGUID, 0, &pSpecificTransF, &dwSpecificCount, &dwSpecificResumeHandle, NULL);
			if (dwReturn == ERROR_NO_DATA || dwSpecificCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pSpecificTransF && dwSpecificCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (l = 0; l < dwSpecificCount; l++)
			{
				//get the corresponding QMPolicy
				dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, pSpecificTransF[l].gPolicyID, 0, &pQMPolicy, NULL);
				if(dwReturn==ERROR_SUCCESS)
				{
					pszQMName = pQMPolicy[0].pszPolicyName;
				}
				else
				{
					//If there is no corresponding policy pass NULL, so that it is not displayed.
					pszQMName = NULL;
					dwReturn = ERROR_SUCCESS;
				}
				//print outbound filters
				if(pSpecificTransF[l].dwDirection == FILTER_DIRECTION_OUTBOUND)
				{
					dwActionFlag = 1;
					//validate user input parameters.
					dwReturn = CheckQMFilter(pSpecificTransF[l], SrcAddr, DstAddr,
											 bDstMask, bSrcMask,QMBoolValue,
											 pszShowFilterName);
					if(dwReturn==ERROR_SUCCESS)
					{
						if(!bPrint)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TRANSPORT_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SPECIFIC_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OUTBOUND_HEADING);
							bPrint = TRUE;
						}
						dwTempCnt++;
						bNameFin = TRUE;
						//print specific filters
						dwReturn = PrintQuickmodeFilter(pSpecificTransF[l], pszQMName, addressHash, bResolveDNS, bType, dwActionFlag);
					}
					if(pQMPolicy)
					{
						SPDApiBufferFree(pQMPolicy);
						pQMPolicy = NULL;
					}
				}
			}

			SPDApiBufferFree(pSpecificTransF);
			pSpecificTransF = NULL;
		}
		//print number of filters
		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_SPECIFIC_OUTBOUND, dwTempCnt);
		}

		dwTempCnt = 0;
		dwSpecificCount = 0;
		dwSpecificResumeHandle = 0;
		pSpecificTransF = NULL;

		for (i = 0; ;i+=dwSpecificCount)
		{
			dwReturn = EnumTransportFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_SPECIFIC_FILTERS, gDefaultGUID, 0, &pSpecificTransF, &dwSpecificCount, &dwSpecificResumeHandle, NULL);
			if (dwReturn == ERROR_NO_DATA || dwSpecificCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pSpecificTransF && dwSpecificCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}


			for (l = 0; l < dwSpecificCount; l++)
			{
				//get the corresponding QMPolicy
				dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, pSpecificTransF[l].gPolicyID, 0, &pQMPolicy, NULL);
				if(dwReturn==ERROR_SUCCESS)
				{
					pszQMName = pQMPolicy[0].pszPolicyName;
				}
				else
				{
					//if there is no corresponding policy pass NULL, so that it is not printed.
					pszQMName = NULL;
					dwReturn = ERROR_SUCCESS;
				}
				//Print inbound filters
				if(pSpecificTransF[l].dwDirection == FILTER_DIRECTION_INBOUND)
				{
					//To print inbound and outbound filteraction
					dwActionFlag = 2;

					//validate user input data
					dwReturn = CheckQMFilter(pSpecificTransF[l], SrcAddr, DstAddr,
											 bDstMask, bSrcMask,QMBoolValue,
											 pszShowFilterName);
					if(dwReturn==ERROR_SUCCESS)
					{
						if(!bPrintIN)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TRANSPORT_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SPECIFIC_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_INBOUND_HEADING);
							bPrintIN = TRUE;
						}
						dwTempCnt++;
						bNameFin = TRUE;
						//print specific filter data
						dwReturn = PrintQuickmodeFilter(pSpecificTransF[l], pszQMName, addressHash, bResolveDNS, bType, dwActionFlag);
					}

					if(pQMPolicy)
					{
						SPDApiBufferFree(pQMPolicy);
						pQMPolicy = NULL;
					}
				}
			}

			SPDApiBufferFree(pSpecificTransF);
			pSpecificTransF = NULL;
		}
		//print number of filters
		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_SPECIFIC_INBOUND, dwTempCnt);
		}
	}

error:
	//even if there is no transport filters, tunnel can be shown

    dwReturn = ShowTunnelFilters(pszShowFilterName, bType, SrcAddr, DstAddr, addressHash,
                                 bResolveDNS, bSrcMask, bDstMask, QMBoolValue, bNameFin);

	if(!bNameFin)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		if(pszShowFilterName)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_QMF_8);
		}
		else
		{
			if(bType)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_QMF_6);
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_QMF_7);
			}
		}
		dwReturn = ERROR_SUCCESS;
	}
	//error path clean up
	if(pQMPolicy)
	{
		SPDApiBufferFree(pQMPolicy);
		pQMPolicy = NULL;
	}

	if(pTransF)
	{
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}

	if(pSpecificTransF)
	{
		SPDApiBufferFree(pSpecificTransF);
		pSpecificTransF = NULL;
	}

	return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: ShowTunnelFilters
//
//Date of Creation: 11-21-2001
//
//Parameters: 		IN LPTSTR pszShowFilterName,
//	                IN BOOL bType,
//					IN ADDR SrcAddr,
//					IN ADDR DstAddr,
//					IN NshHashTable& addressHash,
//					IN BOOL bResolveDNS,
//					IN BOOL bSrcMask,
//					IN BOOL bDstMask,
//					IN QM_FILTER_VALUE_BOOL QMBoolValue,
//					IN OUT BOOL& bNameFin
//
//
//Return: 		DWORD
//
//Description: This function prepares data for displaying Tunnel filters.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ShowTunnelFilters(
	IN LPTSTR pszShowFilterName,
	IN BOOL bType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue,
	IN OUT BOOL& bNameFin
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwSpecificResumeHandle = 0;  	// handle for continuation calls
	DWORD dwCount = 0;                 	// counting objects here
	DWORD dwSpecificCount = 0;
	GUID  gDefaultGUID = {0};      		// NULL GUID value
	DWORD i=0, j=0, l=0;
	DWORD dwVersion = 0;
	DWORD dwTempCnt = 0;
	LPWSTR pszQMName = NULL;
	BOOL bPrint = FALSE;
	BOOL bPrintIN = FALSE;

	PIPSEC_QM_POLICY pQMPolicy = NULL;
	PTUNNEL_FILTER pTunnelF = NULL;
	PTUNNEL_FILTER pSpecificTunnelF = NULL;

	DWORD dwActionFlag = 0;
	//print generic filters
	if(bType)
	{
		for (i = 0; ;i+=dwCount)
		{
			dwReturn = EnumTunnelFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0, &pTunnelF, &dwCount, &dwResumeHandle, NULL);

			if (dwReturn == ERROR_NO_DATA || dwCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pTunnelF && dwCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (j = 0; j < dwCount; j++)
			{
				//get the corresponding QMPolicy
				dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, pTunnelF[j].gPolicyID, 0, &pQMPolicy, NULL);
				if(dwReturn == ERROR_SUCCESS)
				{
					pszQMName = pQMPolicy[0].pszPolicyName;
				}
				else
				{
					//if there is no policy pass NULL, for not printing the policy
					pszQMName = NULL;
					dwReturn = ERROR_SUCCESS;
				}
				dwActionFlag = 0;
				//validate the user input data.
				dwReturn = CheckQMFilter(pTunnelF[j], SrcAddr, DstAddr,
										 bDstMask, bSrcMask, QMBoolValue,
										 pszShowFilterName);
				if(dwReturn == ERROR_SUCCESS )
				{
					if(!bPrint)
					{
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_HEADING);
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_GENERIC_HEADING);
						bPrint = TRUE;
					}
					bNameFin = TRUE;
					dwTempCnt++;
					//print the filter data
					dwReturn = PrintQuickmodeFilter(pTunnelF[j], pszQMName, addressHash, bResolveDNS, bType, dwActionFlag);
				}

				if(pQMPolicy)
				{
					SPDApiBufferFree(pQMPolicy);
					pQMPolicy = NULL;
				}
			}

			SPDApiBufferFree(pTunnelF);
			pTunnelF = NULL;
		}
		//print the number of filters.
		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_GENERIC_FILTERS, dwTempCnt);
		}
	}
	//print for Specific filters
	else if(!bType)
	{
		for (i = 0; ;i+=dwSpecificCount)
		{
			dwReturn = EnumTunnelFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_SPECIFIC_FILTERS, gDefaultGUID, 0, &pSpecificTunnelF, &dwSpecificCount, &dwSpecificResumeHandle, NULL);
			if (dwReturn == ERROR_NO_DATA || dwSpecificCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;								//Still more to show up, break from the loop...
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pSpecificTunnelF && dwSpecificCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (l = 0; l < dwSpecificCount; l++)
			{
				//get the corresponding QMPolicy
				dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, pSpecificTunnelF[l].gPolicyID, 0, &pQMPolicy, NULL);
				if(dwReturn==ERROR_SUCCESS)
				{
					pszQMName = pQMPolicy[0].pszPolicyName;
				}
				else
				{
					//If there is no corresponding policy is not there,
					//pass NULL so that policy is not printed.
					pszQMName = NULL;
					dwReturn = ERROR_SUCCESS;
				}
				//First print outbound filters
				if(pSpecificTunnelF[l].dwDirection == FILTER_DIRECTION_OUTBOUND)
				{
					dwActionFlag = 1;
					//Validate user input data.
					dwReturn = CheckQMFilter(pSpecificTunnelF[l], SrcAddr, DstAddr,
											 bDstMask, bSrcMask, QMBoolValue,
											 pszShowFilterName);
					if(dwReturn==ERROR_SUCCESS)
					{
						if(!bPrint)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SPECIFIC_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OUTBOUND_HEADING);
							bPrint = TRUE;
						}
						dwTempCnt++;
						bNameFin = TRUE;
						//print specific filter data.
						dwReturn = PrintQuickmodeFilter(pSpecificTunnelF[l], pszQMName, addressHash, bResolveDNS, bType, dwActionFlag);
					}

					if(pQMPolicy == NULL)
					{
						SPDApiBufferFree(pQMPolicy);
						pQMPolicy = NULL;
					}
				}
			}

			SPDApiBufferFree(pSpecificTunnelF);
			pSpecificTunnelF = NULL;
		}

		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_SPECIFIC_OUTBOUND, dwTempCnt);
		}

		dwTempCnt = 0;
		dwSpecificCount = 0;
		dwSpecificResumeHandle = 0;
		pSpecificTunnelF = NULL;

		for (i = 0; ;i+=dwSpecificCount)
		{
			dwReturn = EnumTunnelFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_SPECIFIC_FILTERS, gDefaultGUID, 0, &pSpecificTunnelF, &dwSpecificCount, &dwSpecificResumeHandle, NULL);
			if (dwReturn == ERROR_NO_DATA || dwSpecificCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				break;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pSpecificTunnelF && dwSpecificCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (l = 0; l < dwSpecificCount; l++)
			{
				//get the corresponding QMPolicy for the filter
				dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, pSpecificTunnelF[l].gPolicyID, 0, &pQMPolicy, NULL);
				if(dwReturn==ERROR_SUCCESS)
				{
					pszQMName = pQMPolicy[0].pszPolicyName;
				}
				else
				{
					//if the corresponding filter name is not present, pass NULL so that it is not printed.
					pszQMName = NULL;
					dwReturn = ERROR_SUCCESS;
				}
				// then print all inbound filters
				if(pSpecificTunnelF[l].dwDirection == FILTER_DIRECTION_INBOUND)
				{
					dwActionFlag = 2;
					//validate user input
					dwReturn = CheckQMFilter(pSpecificTunnelF[l], SrcAddr, DstAddr,
											 bDstMask, bSrcMask, QMBoolValue,
											 pszShowFilterName);
					if(dwReturn==ERROR_SUCCESS)
					{
						if(!bPrintIN)
						{
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SPECIFIC_HEADING);
							PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_INBOUND_HEADING);
							bPrintIN = TRUE;
						}
						dwTempCnt++;
						bNameFin = TRUE;
						//print tunnel specific filter data
						dwReturn = PrintQuickmodeFilter(pSpecificTunnelF[l], pszQMName, addressHash, bResolveDNS, bType, dwActionFlag);
					}

					if(pQMPolicy)
					{
						SPDApiBufferFree(pQMPolicy);
						pQMPolicy = NULL;
					}
				}
			}
			SPDApiBufferFree(pSpecificTunnelF);
			pSpecificTunnelF = NULL;
		}
		//print number of filters
		if(dwTempCnt > 0)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NO_OF_SPECIFIC_INBOUND, dwTempCnt);
		}
	}

error:
	if(pQMPolicy)
	{
		SPDApiBufferFree(pQMPolicy);
		pQMPolicy = NULL;
	}
	//error path clean up
	if(pTunnelF)
	{
		SPDApiBufferFree(pTunnelF);
		pTunnelF = NULL;
	}

	if(pSpecificTunnelF)
	{
		SPDApiBufferFree(pSpecificTunnelF);
		pSpecificTunnelF = NULL;
	}

	return dwReturn;
}



///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: CheckQMFilter
//
//Date of Creation: 11-21-2001
//
//Parameters: 		IN TRANSPORT_FILTER TransF,
//					IN ADDR	SrcAddr,
//					IN ADDR DstAddr,
//					IN BOOL bDstMask,
//					IN BOOL bSrcMask,
//					IN QM_FILTER_VALUE_BOOL QMBoolValue,
//                  IN LPWSTR pszShowFilterName
//
//
//Return: 			DWORD
//
//Description: This function prepares data for QM Transport Filter and validates the input
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
CheckQMFilter(
	IN TRANSPORT_FILTER TransF,
	IN ADDR	SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bDstMask,
	IN BOOL bSrcMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue,
	IN LPWSTR pszShowFilterName
	)
{
	DWORD dwReturn = ERROR_SUCCESS;

	while(1)
	{
		//Validates user given input for Source address
		switch(SrcAddr.AddrType)
		{
			case IP_ADDR_WINS_SERVER:
			case IP_ADDR_DHCP_SERVER:
			case IP_ADDR_DNS_SERVER:
			case IP_ADDR_DEFAULT_GATEWAY:
				if(TransF.SrcAddr.AddrType != SrcAddr.AddrType)
				{
					dwReturn = ERROR_NO_DISPLAY;
					BAIL_OUT;
				}
				break;
			default:
				if(SrcAddr.uIpAddr != 0xFFFFFFFF)
				{
					if(TransF.SrcAddr.uIpAddr != SrcAddr.uIpAddr)
					{
						dwReturn = ERROR_NO_DISPLAY;
						BAIL_OUT;
					}
				}
				break;
		}
		//Validates user given input for Destination address
		switch(DstAddr.AddrType)
		{
			case IP_ADDR_WINS_SERVER:
			case IP_ADDR_DHCP_SERVER:
			case IP_ADDR_DNS_SERVER:
			case IP_ADDR_DEFAULT_GATEWAY:
				if(TransF.DesAddr.AddrType != DstAddr.AddrType)
				{
					dwReturn = ERROR_NO_DISPLAY;
					BAIL_OUT;
				}
				break;
			default:
				if(DstAddr.uIpAddr != 0xFFFFFFFF)
				{
					if(TransF.DesAddr.uIpAddr != DstAddr.uIpAddr)
					{
						dwReturn = ERROR_NO_DISPLAY;
						BAIL_OUT;
					}
				}
				break;
		}
		//Validates user given input for Source port
		if(QMBoolValue.bSrcPort)
		{
			if(TransF.SrcPort.wPort != (WORD)QMBoolValue.dwSrcPort)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Destination port
		if(QMBoolValue.bDstPort)
		{
			if(TransF.DesPort.wPort != (WORD)QMBoolValue.dwDstPort)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Protocol
		if(QMBoolValue.bProtocol)
		{
			if(TransF.Protocol.dwProtocol != QMBoolValue.dwProtocol)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Inbound action
		if(QMBoolValue.bActionInbound)
		{
			if(TransF.InboundFilterAction != (FILTER_ACTION)QMBoolValue.dwActionInbound)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Outbound action
		if(QMBoolValue.bActionOutbound)
		{
			if(TransF.OutboundFilterAction != (FILTER_ACTION)QMBoolValue.dwActionOutbound)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Source Mask
		if(bSrcMask)
		{
			if(TransF.SrcAddr.uSubNetMask != SrcAddr.uSubNetMask)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Destination address
		if(bDstMask)
		{
			if(TransF.DesAddr.uSubNetMask != DstAddr.uSubNetMask)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Filtername
		if(pszShowFilterName!=NULL)
		{
			if(_tcsicmp(TransF.pszFilterName, pszShowFilterName) != 0)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}

		//Every thing fine... All matched
		BAIL_OUT;
	}

error:
	return dwReturn;

}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: CheckQMFilter
//
//Date of Creation: 11-21-2001
//
//Parameters: 	IN TUNNEL_FILTER TunnelF,
//				IN ADDR	SrcAddr,
//				IN ADDR DstAddr,
//				IN BOOL bDstMask,
//				IN BOOL bSrcMask,
//				IN QM_FILTER_VALUE_BOOL QMBoolValue,
//              IN LPWSTR pszShowFilterName
//Return: 		DWORD
//
//Description: This function prepares data for QM Tunnel Filter and validates the input
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
CheckQMFilter(
	IN TUNNEL_FILTER TunnelF,
	IN ADDR	SrcAddr,
	IN ADDR DstAddr,
	IN BOOL bDstMask,
	IN BOOL bSrcMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue,
	IN LPWSTR pszShowFilterName
	)
{
	DWORD dwReturn = ERROR_SUCCESS;

	while(1)
	{
		//Validates user given input for Source address
		switch(SrcAddr.AddrType)
		{
			case IP_ADDR_WINS_SERVER:
			case IP_ADDR_DHCP_SERVER:
			case IP_ADDR_DNS_SERVER:
			case IP_ADDR_DEFAULT_GATEWAY:
				if(TunnelF.SrcAddr.AddrType != SrcAddr.AddrType)
				{
					dwReturn = ERROR_NO_DISPLAY;
					BAIL_OUT;
				}
				break;
			default:
				if(SrcAddr.uIpAddr != 0xFFFFFFFF)
				{
					if(TunnelF.SrcAddr.uIpAddr != SrcAddr.uIpAddr)
					{
						dwReturn = ERROR_NO_DISPLAY;
						BAIL_OUT;
					}
				}
				break;
		}
		//Validates user given input for Destination address
		switch(DstAddr.AddrType)
		{
			case IP_ADDR_WINS_SERVER:
			case IP_ADDR_DHCP_SERVER:
			case IP_ADDR_DNS_SERVER:
			case IP_ADDR_DEFAULT_GATEWAY:
				if(TunnelF.DesAddr.AddrType != DstAddr.AddrType)
				{
					dwReturn = ERROR_NO_DISPLAY;
					BAIL_OUT;
				}
				break;
			default:
				if(DstAddr.uIpAddr != 0xFFFFFFFF)
				{
					if(TunnelF.DesAddr.uIpAddr != DstAddr.uIpAddr)
					{
						dwReturn = ERROR_NO_DISPLAY;
						BAIL_OUT;
					}
				}
				break;
		}
		//Validates user given input for Source port
		if(QMBoolValue.bSrcPort)
		{
			if(TunnelF.SrcPort.wPort != (WORD)QMBoolValue.dwSrcPort)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Destination port
		if(QMBoolValue.bDstPort)
		{
			if(TunnelF.DesPort.wPort != (WORD)QMBoolValue.dwDstPort)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for protocol
		if(QMBoolValue.bProtocol)
		{
			if(TunnelF.Protocol.dwProtocol != QMBoolValue.dwProtocol)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Inbound action
		if(QMBoolValue.bActionInbound)
		{
			if(TunnelF.InboundFilterAction != (FILTER_ACTION)QMBoolValue.dwActionInbound)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for outbound action
		if(QMBoolValue.bActionOutbound)
		{
			if(TunnelF.OutboundFilterAction != (FILTER_ACTION)QMBoolValue.dwActionOutbound)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Source Mask
		if(bSrcMask)
		{
			if(TunnelF.SrcAddr.uSubNetMask != SrcAddr.uSubNetMask)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for Destination mask
		if(bDstMask)
		{
			if(TunnelF.DesAddr.uSubNetMask != DstAddr.uSubNetMask)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}
		//Validates user given input for filter name
		if(pszShowFilterName!=NULL)
		{
			if(_tcsicmp(TunnelF.pszFilterName, pszShowFilterName) != 0)
			{
				dwReturn = ERROR_NO_DISPLAY;
				BAIL_OUT;
			}
		}

		//Every thing fine... All matched
		BAIL_OUT;

	}

error:
	return dwReturn;

}


///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintQuickmodeFilter
//
//Date of Creation: 11-21-2001
//
//Parameters:
//			IN TRANSPORT_FILTER TransF,
//			IN LPWSTR pszQMName,
//			IN NshHashTable& addressHash
//			IN BOOL bResolveDNS,
//			IN BOOL bType,
//			IN DWORD dwActionFlag
//
//Return: 	DWORD
//
//Description: This function prints Transport filter details
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
PrintQuickmodeFilter(
	IN TRANSPORT_FILTER TransF,
	IN LPWSTR pszQMName,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bType,
	IN DWORD dwActionFlag
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNDERLINE);

	//Print FilterName
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NAME, TransF.pszFilterName);
	//Print Connection Type
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_HEADING);
	switch(TransF.InterfaceType)
	{
		case INTERFACE_TYPE_ALL:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_ALL);
			break;
		case INTERFACE_TYPE_LAN:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_LAN);
			break;
		case INTERFACE_TYPE_DIALUP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_DIALUP);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_UNKNOWN);
			break;
	}
	//Print Weight
	if(!bType)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_FILTER_WEIGHT, TransF.dwWeight);
	}
	//Print Source Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_ADDR_HEADING);
	PrintAddr(TransF.SrcAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(TransF.SrcAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}
	//Print Destination Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DST_ADDR_HEADING);
	PrintAddr(TransF.DesAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(TransF.DesAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}
	//Print Protocol
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_HEADING);
	switch(TransF.Protocol.dwProtocol)
	{
		case PROT_ID_ICMP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_ICMP);
			break;
		case PROT_ID_TCP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TCP);
			break;
		case PROT_ID_UDP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_UDP);
			break;
		case PROT_ID_RAW:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_RAW);
			break;
		case PROT_ID_ANY:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_ANY);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DEFAULT_PROTOCOL, TransF.Protocol.dwProtocol);
			break;

	}
	//Print Src, Des Port
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_DST_PORT,TransF.SrcPort.wPort,TransF.DesPort.wPort);
	//Print Mirror
	if(TransF.bCreateMirror)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MIRR_YES);
	}
	else
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MIRR_NO);
	}
	// Print Qm Policy Name
	if(pszQMName != NULL)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_NAME,pszQMName);
	}
	//Print Action Flag
	if(dwActionFlag == 0 || dwActionFlag == 2)
	{
		switch(TransF.InboundFilterAction)
		{
			case PASS_THRU:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_PASSTHRU);
				break;
			case NEGOTIATE_SECURITY:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_NEGOTIATE);
				break;
			case BLOCKING:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_BLOCK);
				break;
			default:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_UNKNOWN);
				break;
		}
	}
	if(dwActionFlag == 0 || dwActionFlag == 1)
	{
		switch(TransF.OutboundFilterAction)
		{
			case PASS_THRU:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_PASSTHRU);
				break;
			case NEGOTIATE_SECURITY:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_NEGOTIATE);
				break;
			case BLOCKING:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_BLOCK);
				break;
			default:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_UNKNOWN);
				break;
		}
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintQuickmodeFilter
//
//Date of Creation: 11-21-2001
//
//Parameters:
//				IN TUNNEL_FILTER TunnelF,
//				IN LPWSTR pszQMName,
//				IN NshHashTable& addressHash
//				IN BOOL bResolveDNS,
//				IN BOOL bType,
//				IN DWORD dwActionFlag
//
//Return: 		DWORD
//
//Description: This function prints Tunnel filter details
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
PrintQuickmodeFilter(
	IN TUNNEL_FILTER TunnelF,
	IN LPWSTR pszQMName,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bType,
	IN DWORD dwActionFlag
	)
{
	DWORD dwReturn = ERROR_SUCCESS;

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNDERLINE);

	//Print FilterName
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NAME, TunnelF.pszFilterName);

	//Print Connection Type
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_HEADING);

	switch(TunnelF.InterfaceType)
	{
		case INTERFACE_TYPE_ALL:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_ALL);
			break;
		case INTERFACE_TYPE_LAN:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_LAN);
			break;
		case INTERFACE_TYPE_DIALUP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_DIALUP);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_UNKNOWN);
			break;
	}
	//Print Weight
	if(!bType)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_FILTER_WEIGHT, TunnelF.dwWeight);
	}

	//Print Source Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_ADDR_HEADING);
	PrintAddr(TunnelF.SrcAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(TunnelF.SrcAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}
	//Print Destination Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DST_ADDR_HEADING);
	PrintAddr(TunnelF.DesAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(TunnelF.DesAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}
	//Print Tunnel Src
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_SRC);
	PrintAddr(TunnelF.SrcTunnelAddr, addressHash, bResolveDNS);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_DST);
	PrintAddr(TunnelF.DesTunnelAddr, addressHash, bResolveDNS);

	//Print Protocol
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_HEADING);
	switch(TunnelF.Protocol.dwProtocol)
	{
		case PROT_ID_ICMP:																	//1
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_ICMP);
			break;
		case PROT_ID_TCP:																	//6
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TCP);
			break;
		case PROT_ID_UDP:																	//17
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_UDP);
			break;
		case PROT_ID_RAW:																	//255
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_RAW);
			break;
		case PROT_ID_ANY:																	//0
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_ANY);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DEFAULT_PROTOCOL, TunnelF.Protocol.dwProtocol);
			break;

	}
	//Print Src, Des Port
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_DST_PORT,TunnelF.SrcPort.wPort,TunnelF.DesPort.wPort);
	//Print Mirror
	if(TunnelF.bCreateMirror)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MIRR_YES);
	}
	else
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MIRR_NO);
	}
	// Print Qm Policy Name
	if(pszQMName != NULL)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_NAME,pszQMName);
	}
	//Print Action Flag
	if(dwActionFlag == 0 || dwActionFlag == 2)
	{
		switch(TunnelF.InboundFilterAction)
		{
			case PASS_THRU:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_PASSTHRU);
				break;
			case NEGOTIATE_SECURITY:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_NEGOTIATE);
				break;
			case BLOCKING:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_BLOCK);
				break;
			default:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_UNKNOWN);
				break;
		}
	}

	if(dwActionFlag == 0 || dwActionFlag == 1)
	{
		switch(TunnelF.OutboundFilterAction)
		{
			case PASS_THRU:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_PASSTHRU);
				break;
			case NEGOTIATE_SECURITY:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_NEGOTIATE);
				break;
			case BLOCKING:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_BLOCK);
				break;
			default:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_UNKNOWN);
				break;
		}
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: ShowRule
//
//Date of Creation: 9-3-2001
//
//Parameters:
//			IN DWORD dwType,
//			IN ADDR SrcAddr,
//			IN ADDR DstAddr,
//			IN NshHashTable& addressHash,
//			IN BOOL bResolveDNS,
//			IN BOOL bSrcMask,
//			IN BOOL bDstMask,
//			IN QM_FILTER_VALUE_BOOL QMBoolValue
//
//Return: 	DWORD
//
//Description: This function prepares data for displaying quick mode filters.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowRule(
	IN DWORD dwType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;          		// handle for continuation calls
	DWORD dwCount = 0;                 		// counting objects here
	DWORD dwQMResumeHandle = 0;          	// handle for continuation calls
	DWORD dwQMCount = 0;                 	// counting objects here
	GUID  gDefaultGUID = {0};      			// NULL GUID value
	DWORD i=0, j=0, k=0, l=0;
	DWORD dwVersion = 0;
	DWORD dwTempCnt = 0;
	DWORD dwActionFlag = 0;
	LPWSTR pszQMName = NULL;
	BOOL bPrint = FALSE;
	BOOL bMMFound = FALSE;
	BOOL bNameFin = FALSE;

	PIPSEC_QM_POLICY pQMPolicy = NULL;
	PTRANSPORT_FILTER pTransF = NULL;
	PIPSEC_MM_POLICY pMMPolicy = NULL;
	PMM_FILTER pMMFilter = NULL;


	if(dwType == 1 || dwType == 0)//either transport or all
	{
		for (k = 0; ;k+=dwQMCount)
		{
			dwReturn = EnumTransportFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0,
																	&pTransF, &dwQMCount, &dwQMResumeHandle, NULL);

			if (dwReturn == ERROR_NO_DATA || dwQMCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				BAIL_OUT;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pTransF && dwQMCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (l = 0; l < dwQMCount; l++)
			{
				dwResumeHandle = 0;
				pMMFilter = 0;
				dwCount = 0;

				dwReturn = CheckQMFilter(pTransF[l], SrcAddr, DstAddr, bDstMask, bSrcMask,QMBoolValue, NULL);

				if(dwReturn != ERROR_SUCCESS)
				{
					//Though not matched check for other filters
					dwReturn = ERROR_SUCCESS;
					continue;
				}
				for (i = 0; ;i+=dwCount)
				{
					dwReturn = EnumMMFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0,
																	&pMMFilter, &dwCount, &dwResumeHandle, NULL);

					if (dwReturn == ERROR_NO_DATA || dwCount == 0)
					{
						dwReturn = ERROR_SUCCESS;
						break;
					}

					if (dwReturn != ERROR_SUCCESS)
					{
						break;
					}

					if(!(pMMFilter && dwCount > 0))
					{
						break;  // not required to continue.
					}

					for (j = 0; j < dwCount; j++)
					{
						//Match QMfilter data with MMFilter data to get the corresponding MMFilter details to print
						if((pTransF[l].SrcAddr.AddrType == pMMFilter[j].SrcAddr.AddrType) &&
						   (pTransF[l].SrcAddr.uIpAddr == pMMFilter[j].SrcAddr.uIpAddr) &&
						   (pTransF[l].DesAddr.AddrType == pMMFilter[j].DesAddr.AddrType) &&
						   (pTransF[l].DesAddr.uIpAddr == pMMFilter[j].DesAddr.uIpAddr) &&
						   (pTransF[l].SrcAddr.uSubNetMask == pMMFilter[j].SrcAddr.uSubNetMask) &&
						   (pTransF[l].DesAddr.uSubNetMask == pMMFilter[j].DesAddr.uSubNetMask) &&
						   (pTransF[l].InterfaceType == pMMFilter[j].InterfaceType) &&
						   (pTransF[l].bCreateMirror == pMMFilter[j].bCreateMirror)
						   )
						{
							//Get the corresponding MMPolicy details
							pMMPolicy = NULL;
							dwReturn = GetMMPolicyByID(g_szDynamicMachine, dwVersion, pMMFilter[j].gPolicyID,
																		&pMMPolicy, NULL);
							if(dwReturn != ERROR_SUCCESS)
							{
								BAIL_OUT;
							}
							//Get the corresponding QMPolicy details
							dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, pTransF[l].gPolicyID, 0, &pQMPolicy, NULL);
							if(dwReturn == ERROR_SUCCESS)
							{
								pszQMName = pQMPolicy[0].pszPolicyName;
							}
							else
							{
								//If there is no corresponding policy pass NULL, so it is not printed
								pszQMName = NULL;
								dwReturn = ERROR_SUCCESS;
							}
							dwActionFlag = 0;
							if(!bPrint)
							{
								PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TRANSPORT_RULE_HEADING);
								bPrint = TRUE;
							}
							dwTempCnt++;
							//print Transport Rule details
							dwReturn = PrintTransportRuleFilter(&pMMFilter[j], &pMMPolicy[0], pTransF[l], pszQMName, addressHash, bResolveDNS);
							bNameFin = TRUE;
							bMMFound = TRUE;

							if(pQMPolicy)
							{
								SPDApiBufferFree(pQMPolicy);
								pQMPolicy = NULL;
							}

							if(pMMPolicy)
							{
								SPDApiBufferFree(pMMPolicy);
								pMMPolicy = NULL;
							}
						}
					}
					if(pMMFilter)
					{
						SPDApiBufferFree(pMMFilter);
						pMMFilter = NULL;
					}
				}
			}

			SPDApiBufferFree(pTransF);
			pTransF = NULL;
		}
	}

error:
	//print the number of transport rules
	if(dwTempCnt > 0)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NO_OF_TRANSPORT_FILTERS, dwTempCnt);
	}
	//Then print tunnel filters
	dwReturn = ShowTunnelRule(dwType, SrcAddr, DstAddr, addressHash, bResolveDNS, bSrcMask, bDstMask, QMBoolValue, bNameFin);

	if(!bNameFin)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_QMF_17);
		dwReturn = ERROR_SUCCESS;
	}
	//error path clean up
	if(pQMPolicy)
	{
		SPDApiBufferFree(pQMPolicy);
		pQMPolicy = NULL;
	}

	if(pMMPolicy)
	{
		SPDApiBufferFree(pMMPolicy);
		pMMPolicy = NULL;
	}

	if(pMMFilter)
	{
		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;
	}

	if(pTransF)
	{
		SPDApiBufferFree(pTransF);
		pTransF = NULL;
	}

	return dwReturn;
}
///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	ShowTunnelRule
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		:
//						IN DWORD dwType,
//						IN ADDR SrcAddr,
//						IN ADDR DstAddr,
//						IN NshHashTable& addressHash,
//						IN BOOL bResolveDNS,
//						IN BOOL bSrcMask,
//						IN BOOL bDstMask,
//						IN QM_FILTER_VALUE_BOOL QMBoolValue
//						IN OUT BOOL& bNameFin
//
//	Return			: 	DWORD
//
//	Description		: 	This function prepares data for displaying quick mode filters.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowTunnelRule(
	IN DWORD dwType,
	IN ADDR SrcAddr,
	IN ADDR DstAddr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS,
	IN BOOL bSrcMask,
	IN BOOL bDstMask,
	IN QM_FILTER_VALUE_BOOL QMBoolValue,
	IN OUT BOOL& bNameFin
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwResumeHandle = 0;          		// handle for continuation calls
	DWORD dwCount = 0;                 		// counting objects here
	DWORD dwQMResumeHandle = 0;          	// handle for continuation calls
	DWORD dwQMCount = 0;                 	// counting objects here
	GUID  gDefaultGUID = {0};      			// NULL GUID value
	DWORD i=0, j=0, k=0, l=0;
	DWORD dwVersion = 0;
	DWORD dwTempCnt = 0;
	DWORD dwActionFlag = 0;
	LPWSTR pszQMName = NULL;
	BOOL bPrint = FALSE;
	BOOL bMMFound = FALSE;
	PIPSEC_QM_POLICY pQMPolicy = NULL;
	PTUNNEL_FILTER pTunnelF = NULL;
	PIPSEC_MM_POLICY pMMPolicy = NULL;
	PMM_FILTER pMMFilter = NULL;

	if(dwType == 2 || dwType == 0)//either tunnel or all
	{
		for (k = 0; ;k+=dwQMCount)
		{
			dwReturn = EnumTunnelFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0, &pTunnelF, &dwQMCount, &dwQMResumeHandle, NULL);
			if (dwReturn == ERROR_NO_DATA || dwQMCount == 0)
			{
				dwReturn = ERROR_SUCCESS;
				BAIL_OUT;
			}

			if (dwReturn != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			if(!(pTunnelF && dwQMCount > 0))
			{
				BAIL_OUT; // not required to continue.
			}

			for (l = 0; l < dwQMCount; l++)
			{
				dwResumeHandle = 0;
				pMMFilter = 0;
				dwCount = 0;
				//Validate user input data.
				dwReturn = CheckQMFilter(pTunnelF[l], SrcAddr, DstAddr, bDstMask, bSrcMask,QMBoolValue, NULL);

				if(dwReturn != ERROR_SUCCESS)
				{
					//Though not matched continue for other filters
					dwReturn = ERROR_SUCCESS;
					continue;
				}

				for (i = 0; ;i+=dwCount)
				{
					dwReturn = EnumMMFilters(g_szDynamicMachine, dwVersion, NULL, ENUM_GENERIC_FILTERS, gDefaultGUID, 0, &pMMFilter, &dwCount, &dwResumeHandle, NULL);

					if (dwReturn == ERROR_NO_DATA || dwCount == 0)
					{
						dwReturn = ERROR_SUCCESS;
						break;
					}

					if (dwReturn != ERROR_SUCCESS)
					{
						break;
					}

					if(!(pMMFilter && dwCount > 0))
					{
						break; // not required to continue.
					}

					for (j = 0; j < dwCount; j++)
					{
						//Match QMfilter data with MMFilter data to get the corresponding MMFilter details to print
						if((pTunnelF[l].DesTunnelAddr.AddrType == pMMFilter[j].DesAddr.AddrType) &&
							(pTunnelF[l].DesTunnelAddr.uIpAddr == pMMFilter[j].DesAddr.uIpAddr) &&
							(pTunnelF[l].InterfaceType == pMMFilter[j].InterfaceType)
							)
						{
							//get the corresponding MMpolicy
							pMMPolicy = NULL;
							dwReturn = GetMMPolicyByID(g_szDynamicMachine, dwVersion, pMMFilter[j].gPolicyID, &pMMPolicy, NULL);
							if(dwReturn != ERROR_SUCCESS)
							{
								BAIL_OUT;
							}

							//get the corresponding QMpolicy
							dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, pTunnelF[l].gPolicyID, 0, &pQMPolicy, NULL);
							if(dwReturn == ERROR_SUCCESS)
							{
								pszQMName = pQMPolicy[0].pszPolicyName;
							}
							else
							{
								//If the corresponding policy is not found, pass NULL so that it is not printed.
								pszQMName = NULL;
								dwReturn = ERROR_SUCCESS;
							}
							dwActionFlag = 0;

							if(!bPrint)
							{
								PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_RULE_HEADING);
								bPrint = TRUE;
							}
							dwTempCnt++;

							//print tunnel rule details
							dwReturn = PrintTunnelRuleFilter(&pMMFilter[j], &pMMPolicy[0], pTunnelF[l], pszQMName, addressHash, bResolveDNS);
							bNameFin = TRUE;
							bMMFound = TRUE;
							if(pQMPolicy == NULL)
							{
								SPDApiBufferFree(pQMPolicy);
								pQMPolicy = NULL;
							}

							if(pMMPolicy)
							{
								SPDApiBufferFree(pMMPolicy);
								pMMPolicy = NULL;
							}
						}
					}
					if(pMMFilter)
					{
						SPDApiBufferFree(pMMFilter);
						pMMFilter = NULL;
					}

				}
			}
			SPDApiBufferFree(pTunnelF);
			pTunnelF = NULL;
		}
	}

error:
	if(dwTempCnt > 0)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NO_OF_TUNNEL_FILTERS, dwTempCnt);
	}
	// error path clean up
	if(pTunnelF)
	{
		SPDApiBufferFree(pTunnelF);
		pTunnelF = NULL;
	}
	if(pQMPolicy == NULL)
	{
		SPDApiBufferFree(pQMPolicy);
		pQMPolicy = NULL;
	}

	if(pMMFilter)
	{
		SPDApiBufferFree(pMMFilter);
		pMMFilter = NULL;
	}

	if(pMMPolicy)
	{
		SPDApiBufferFree(pMMPolicy);
		pMMPolicy = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	PrintTunnelRuleFilter
//
//	Date of Creation: 	11-21-2001
//
//	Parameters		:
//						IN PMM_FILTER pMMFltr,
//						IN PIPSEC_MM_POLICY pMMPol,
//						IN TUNNEL_FILTER TunnelF,
//						IN LPWSTR pszQMName,
//						IN NshHashTable& addressHash
//						IN BOOL bResolveDNS
//
//	Return			:	DWORD
//
//	Description		: 	This function prints Tunnel filter details
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
PrintTunnelRuleFilter(
	IN PMM_FILTER pMMFltr,
	IN PIPSEC_MM_POLICY pMMPol,
	IN TUNNEL_FILTER TunnelF,
	IN LPWSTR pszQMName,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD i = 0;
	DWORD dwVersion = 0;
	LPTSTR pszCertStr = NULL;
	PINT_MM_AUTH_METHODS pIntMMAuth = NULL;
	PMM_AUTH_METHODS pMMAM = NULL;

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNDERLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//Print MMMFilter name
	if(pMMFltr)
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMFILTER_NAME, pMMFltr->pszFilterName);

	//Print Tunnel FilterName
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMF_NAME, TunnelF.pszFilterName);

	//Print Connection Type
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_HEADING);
	switch(TunnelF.InterfaceType)
	{
		case INTERFACE_TYPE_ALL:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_ALL);
			break;
		case INTERFACE_TYPE_LAN:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_LAN);
			break;
		case INTERFACE_TYPE_DIALUP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_DIALUP);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_UNKNOWN);
			break;
	}

	//Print Source Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_ADDR_HEADING);
	PrintAddr(TunnelF.SrcAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(TunnelF.SrcAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}

	//Print Destination Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DST_ADDR_HEADING);
	PrintAddr(TunnelF.DesAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(TunnelF.DesAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}

	//Print Tunnel Src
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_SRC);
	PrintAddr(TunnelF.SrcTunnelAddr, addressHash, bResolveDNS);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_DST);
	PrintAddr(TunnelF.DesTunnelAddr, addressHash, bResolveDNS);

	//Print Protocol
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_HEADING);
	switch(TunnelF.Protocol.dwProtocol)
	{
		case PROT_ID_ICMP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_ICMP);
			break;
		case PROT_ID_TCP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TCP);
			break;
		case PROT_ID_UDP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_UDP);
			break;
		case PROT_ID_RAW:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_RAW);
			break;
		case PROT_ID_ANY:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_ANY);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DEFAULT_PROTOCOL, TunnelF.Protocol.dwProtocol);
			break;

	}

	//Print Src, Des Port
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_DST_PORT,TunnelF.SrcPort.wPort,TunnelF.DesPort.wPort);

	//Print Mirror
	if(TunnelF.bCreateMirror)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MIRR_YES);
	}
	else
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MIRR_NO);
	}

	if(pMMPol)
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_NAME,pMMPol->pszPolicyName);

	//Print Authentication Methods.
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_AUTH_HEADING);

	if(pMMFltr)
	{
		dwReturn = GetMMAuthMethods(g_szDynamicMachine, dwVersion, pMMFltr->gMMAuthID, &pMMAM, NULL);
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		dwReturn = ConvertExtMMAuthToInt(pMMAM, &pIntMMAuth);

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		for (i = 0; i < pIntMMAuth[0].dwNumAuthInfos; i++)
		{
			switch(pIntMMAuth[0].pAuthenticationInfo[i].AuthMethod)
			{
				case IKE_PRESHARED_KEY:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_PRE_KEY_HEADING);
					break;
				case IKE_DSS_SIGNATURE:
				case IKE_RSA_SIGNATURE:
				case IKE_RSA_ENCRYPTION:
					dwReturn = DecodeCertificateName(pIntMMAuth[0].pAuthenticationInfo[i].pAuthInfo, pIntMMAuth[0].pAuthenticationInfo[i].dwAuthInfoSize, &pszCertStr);
					if (dwReturn != ERROR_SUCCESS)
					{
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNKNOWN_CERT);
					}
					else
					{
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NEWLINE_TAB);
						if (pszCertStr)
						{
							DisplayCertInfo(pszCertStr, pIntMMAuth->pAuthenticationInfo[i].dwAuthFlags);
							delete [] pszCertStr;
							pszCertStr = NULL;
						}
					}

					break;
				case IKE_SSPI:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_KERB);
					break;
				default:
					break;
			}
		}
	}

error:

	//Print Security Methods
	if(pMMPol)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SEC_METHOD_HEADING);
		// Count
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_CNT,pMMPol->dwOfferCount);

		if(IsDefaultMMOffers(*pMMPol))
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_DEFAULT_OFFER);
		}
		for (i = 0; i < pMMPol->dwOfferCount; i++)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
			PrintMMFilterOffer(pMMPol->pOffers[i]);
		}
	}

	// Print Qm Policy Name
	if(pszQMName != NULL)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_NAME,pszQMName);
	}

	//Print Action Flag
	switch(TunnelF.InboundFilterAction)
	{
		case PASS_THRU:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_PASSTHRU);
			break;
		case NEGOTIATE_SECURITY:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_NEGOTIATE);
			break;
		case BLOCKING:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_BLOCK);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_UNKNOWN);
			break;
	}

	switch(TunnelF.OutboundFilterAction)
	{
		case PASS_THRU:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_PASSTHRU);
			break;
		case NEGOTIATE_SECURITY:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_NEGOTIATE);
			break;
		case BLOCKING:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_BLOCK);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_UNKNOWN);
			break;
	}

	if(pIntMMAuth)
	{
		FreeIntMMAuthMethods(pIntMMAuth);
		pIntMMAuth = NULL;
	}

	if(pMMAM)
	{
		SPDApiBufferFree(pMMAM);
		pMMAM = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	PrintTransportRuleFilter
//
//	Date of Creation: 	11-21-2001
//
//	Parameters		:
//						IN PMM_FILTER pMMFltr,
//						IN PIPSEC_MM_POLICY pMMPol,
//						IN TRANSPORT_FILTER TransF,
//						IN LPWSTR pszQMName,
//						IN NshHashTable& addressHash
//						IN BOOL bResolveDNS
//
//	Return			: 	DWORD
//
//	Description		: 	This function prints Transport filter details
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
PrintTransportRuleFilter(
	IN PMM_FILTER pMMFltr,
	IN PIPSEC_MM_POLICY pMMPol,
	IN TRANSPORT_FILTER TransF,
	IN LPWSTR pszQMName,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD i = 0;
	DWORD dwVersion = 0;
	LPTSTR pszCertStr = NULL;
	PINT_MM_AUTH_METHODS pIntMMAuth = NULL;
	PMM_AUTH_METHODS pMMAM = NULL;

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNDERLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

	//Print Mmfilter name
	if(pMMFltr)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMFILTER_NAME, pMMFltr->pszFilterName);
	}

	//Print Tunnel FilterName
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMF_NAME, TransF.pszFilterName);

	//Print Connection Type
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_HEADING);
	switch(TransF.InterfaceType)
	{
		case INTERFACE_TYPE_ALL:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_ALL);
			break;
		case INTERFACE_TYPE_LAN:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_LAN);
			break;
		case INTERFACE_TYPE_DIALUP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_DIALUP);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_CONN_UNKNOWN);
			break;
	}

	//Print Source Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_ADDR_HEADING);
	PrintAddr(TransF.SrcAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(TransF.SrcAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}

	//Print Destination Address
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DST_ADDR_HEADING);
	PrintAddr(TransF.DesAddr, addressHash, bResolveDNS);
	if(!bResolveDNS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_LEFTBRACKET);
		PrintMask(TransF.DesAddr);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_RIGHTBRACKET);
	}

	//Print Protocol
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_HEADING);
	switch(TransF.Protocol.dwProtocol)
	{
		case PROT_ID_ICMP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_ICMP);
			break;
		case PROT_ID_TCP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TCP);
			break;
		case PROT_ID_UDP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_UDP);
			break;
		case PROT_ID_RAW:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_RAW);
			break;
		case PROT_ID_ANY:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_ANY);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DEFAULT_PROTOCOL, TransF.Protocol.dwProtocol);
			break;
	}
	//Print Src, Des Port
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_DST_PORT,TransF.SrcPort.wPort,TransF.DesPort.wPort);
	//Print Mirror
	if(TransF.bCreateMirror)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MIRR_YES);
	}
	else
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MIRR_NO);
	}

	if(pMMPol)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMP_NAME,pMMPol->pszPolicyName);
	}
	//Print Authentication Methods.
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_AUTH_HEADING);

	if(pMMFltr)
	{
		dwReturn = GetMMAuthMethods(g_szDynamicMachine, dwVersion, pMMFltr->gMMAuthID, &pMMAM, NULL);
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		dwReturn = ConvertExtMMAuthToInt(pMMAM, &pIntMMAuth);
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		for (i = 0; i < pIntMMAuth[0].dwNumAuthInfos; i++)
		{
			switch(pIntMMAuth[0].pAuthenticationInfo[i].AuthMethod)
			{
				case IKE_PRESHARED_KEY:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_PRE_KEY_HEADING);
					break;
				case IKE_DSS_SIGNATURE:
				case IKE_RSA_SIGNATURE:
				case IKE_RSA_ENCRYPTION:
					dwReturn = DecodeCertificateName(pIntMMAuth[0].pAuthenticationInfo[i].pAuthInfo, pIntMMAuth[0].pAuthenticationInfo[i].dwAuthInfoSize, &pszCertStr);
					if (dwReturn != ERROR_SUCCESS)
					{
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNKNOWN_CERT);
					}
					else
					{
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NEWLINE_TAB);
						if (pszCertStr)
						{
							DisplayCertInfo(pszCertStr, pIntMMAuth->pAuthenticationInfo[i].dwAuthFlags);
							delete [] pszCertStr;
							pszCertStr = NULL;
						}
					}
					break;
				case IKE_SSPI:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_KERB);
					break;
				default:
				break;
			}
		}
	}

error:
	// Print Security Methods
	// Count
	if(pMMPol)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_SEC_METHOD_HEADING);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_OFFER_CNT,pMMPol->dwOfferCount);
		if(IsDefaultMMOffers(*pMMPol))
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_DEFAULT_OFFER);
		}
		for (i = 0; i < pMMPol->dwOfferCount; i++)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
			PrintMMFilterOffer(pMMPol->pOffers[i]);
		}
	}
	// Print Qm Policy Name
	if(pszQMName != NULL)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_NAME,pszQMName);
	}
	//Print Action Flag
	switch(TransF.InboundFilterAction)
	{
		case PASS_THRU:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_PASSTHRU);
			break;
		case NEGOTIATE_SECURITY:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_NEGOTIATE);
			break;
		case BLOCKING:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_BLOCK);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_INBOUND_UNKNOWN);
			break;
	}

	switch(TransF.OutboundFilterAction)
	{
		case PASS_THRU:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_PASSTHRU);
			break;
		case NEGOTIATE_SECURITY:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_NEGOTIATE);
			break;
		case BLOCKING:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_BLOCK);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OUTBOUND_UNKNOWN);
			break;
	}

	if(pIntMMAuth)
		{
			FreeIntMMAuthMethods(pIntMMAuth);
			pIntMMAuth = NULL;
		}

		if(pMMAM)
		{
			SPDApiBufferFree(pMMAM);
			pMMAM = NULL;
		}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	ShowStats
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		:	IN DWORD dwShow
//
//	Return			:	DWORD
//
//	Description		: 	This function calls appropriate IKE and IPSEC statistics display.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowStats(
	IN DWORD dwShow
	)
{
	DWORD dwReturn = ERROR_SUCCESS;			// assume success

	if(dwShow != STATS_IPSEC)				//is the show is for IKE or all
	{
		dwReturn = PrintIkeStats();
		if(dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
	}

	if(dwShow != STATS_IKE)		//is the show is for IPSEC or all
	{
		dwReturn = PrintIpsecStats();
	}

error:

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintIkeStats
//
//Date of Creation: 28-1-2002
//
//Parameters:
//
//Return: 		DWORD
//
//Description: This function Prints IkeStatistics
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
PrintIkeStats(
	VOID
	)
{
	DWORD dwReturn = ERROR_SUCCESS;			// assume success
	DWORD dwVersion = 0;
	LPSTR pszLLString = NULL;
	IKE_STATISTICS IKEStats;

	//Query IKE Statistics
	dwReturn = QueryIKEStatistics(g_szDynamicMachine,dwVersion, &IKEStats, NULL);
	if (dwReturn != ERROR_SUCCESS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_NOT_FOUND_MSG);
		BAIL_OUT;
	}

	//Heading
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_HEADING);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_IKE_HEADING_UNDERLINE);
	//Print IKE statistics
	pszLLString = LongLongToString(0, IKEStats.dwOakleyMainModes, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_MAIN_MODE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwOakleyQuickModes, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_QUICK_MODE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwSoftAssociations, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_SOFT_SA, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwAuthenticationFailures, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_AUTH_FAIL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwActiveAcquire, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_ACTIVE_ACQUIRE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwActiveReceive, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_ACTIVE_RECEIVE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwAcquireFail, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_ACQUIRE_FAIL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwReceiveFail, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_RECEIVE_FAIL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwSendFail, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_SEND_FAIL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwAcquireHeapSize, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_ACQ_HEAP_SIZE, pszLLString);

		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwReceiveHeapSize, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_RECEIVE_HEAP_SIZE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwNegotiationFailures, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_NEG_FAIL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwInvalidCookiesReceived, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_INVALID_COOKIE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwTotalAcquire, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_TOTAL_ACQUIRE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwTotalGetSpi, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_TOT_GET_SPI, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwTotalKeyAdd, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_TOT_KEY_ADD, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwTotalKeyUpdate, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_TOT_KEY_UPDATE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwGetSpiFail, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_GET_SPI_FAIL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwKeyAddFail, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_KEY_ADD_FAIL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwKeyUpdateFail, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_KEY_UPDATE_FAIL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwIsadbListSize, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_DB_LIST, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwConnListSize, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_CONN_LIST_SIZE, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, IKEStats.dwInvalidPacketsReceived, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_INVLD_PKTS, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

error:
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintIpsecStats
//
//Date of Creation: 28-1-2002
//
//Parameters:
//
//Return: 		DWORD
//
//Description: This function Prints IpsecStatistics
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
PrintIpsecStats(
	VOID
	)
{
	DWORD dwReturn = ERROR_SUCCESS;			// assume success
	DWORD dwVersion = 0;
	LPSTR pszLLString = NULL;
	PIPSEC_STATISTICS pIPSecStats = NULL;

	dwReturn = QueryIPSecStatistics(g_szDynamicMachine, dwVersion, &pIPSecStats, NULL);
	//Query IPSec Statistics
	if (dwReturn != ERROR_SUCCESS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_IPSEC_NOT_FOUND);
		BAIL_OUT;
	}

	//Heading
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_IPSEC_HEADING);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_IPSEC_HEADING_UNDERLINE);
	//Print IPSec statistics.
	pszLLString = LongLongToString(0, pIPSecStats->dwNumActiveAssociations, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_ACTIVE_ASSOC, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumOffloadedSAs, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_OFFLOAD_SAS, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumPendingKeyOps, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_PEND_KEY, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumKeyAdditions, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_KEY_ADDS, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumKeyDeletions, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_KEY_DELETES, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumReKeys, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_REKEYS, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumActiveTunnels, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_ACT_TUNNEL, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumBadSPIPackets, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_BAD_SPI, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumPacketsNotDecrypted, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_NOT_DECRYPT, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumPacketsNotAuthenticated, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_NOT_AUTH, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(0, pIPSecStats->dwNumPacketsWithReplayDetection, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_REPLAY, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uConfidentialBytesSent.HighPart,pIPSecStats->uConfidentialBytesSent.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_CONF_BYTES_SENT, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uConfidentialBytesReceived.HighPart,pIPSecStats->uConfidentialBytesReceived.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_CONF_BYTES_RECV, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uAuthenticatedBytesSent.HighPart,pIPSecStats->uAuthenticatedBytesSent.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_AUTH_BYTES_SENT, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uAuthenticatedBytesReceived.HighPart,pIPSecStats->uAuthenticatedBytesReceived.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_AUTH_BYTE_RECV, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uTransportBytesSent.HighPart,pIPSecStats->uTransportBytesSent.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_TRANSPORT_BYTES_SENT, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uTransportBytesReceived.HighPart,pIPSecStats->uTransportBytesReceived.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_TRANSPORT_BYTES_RCVD, pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uBytesSentInTunnels.HighPart,pIPSecStats->uBytesSentInTunnels.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_BYTES_SENT_TUNNEL,  pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uBytesReceivedInTunnels.HighPart,pIPSecStats->uBytesReceivedInTunnels.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_BYTES_RECV_TUNNEL,  pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uOffloadedBytesSent.HighPart,pIPSecStats->uOffloadedBytesSent.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_OFFLOAD_BYTES_SENT,  pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pszLLString = LongLongToString(pIPSecStats->uOffloadedBytesReceived.HighPart,pIPSecStats->uOffloadedBytesReceived.LowPart, 1);
	if(pszLLString)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_STATS_OFFLOAD_BYTES_RECV,  pszLLString);
		free(pszLLString);
		pszLLString = NULL;
	}
	else
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

error:

	if(pIPSecStats)
	{
		SPDApiBufferFree(pIPSecStats);
		pIPSecStats = NULL;
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: ShowMMSas
//
//Date of Creation: 9-3-2001
//
//Parameters:
//				IN ADDR Source,
//				IN ADDR Destination,
//				IN BOOL bFormat
//				IN NshHashTable& addressHash,
//				IN BOOL bResolveDNS
//
//Return: 		DWORD
//
//Description: This function prepares data for MMsas
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowMMSas(
	IN ADDR Source,
	IN ADDR Destination,
	IN BOOL bFormat,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	)
{
	DWORD dwReturn = ERROR_SUCCESS; 	// success by default
	int i=0, j=0;
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwCount = 2;                 	// counting objects here min 2 required

	      								// for MM SA calls
	DWORD dwReserved = 0;              	// reserved container
	DWORD dwVersion = 0;
	BOOL bHeader = FALSE;
	BOOL bFound = FALSE;
	_TCHAR szTime[BUFFER_SIZE] = {0};

	PIPSEC_MM_SA pIPSecMMSA=NULL;
	IPSEC_MM_SA mmsaTemplate;
	memset(&mmsaTemplate, 0, sizeof(IPSEC_MM_SA));

	// Display main mode SAs
	time_t Time;

	time(&Time);
	FormatTime(Time,szTime);

	// make the call(s)
	for (i = 0; ;i+=dwCount)
	{
		dwReturn = EnumMMSAs(g_szDynamicMachine, dwVersion, &mmsaTemplate, 0, 0, &pIPSecMMSA, &dwCount, &dwReserved, &dwResumeHandle, NULL);

		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			if (i == 0)
			{
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_MMSAS_3);
				bHeader = TRUE;											//To Block other error message
			}
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		for (j = 0; j < (int) dwCount; j++)
		{
			bHeader = FALSE;
			//Enumerate all MMSAs
			if((Source.AddrType == IP_ADDR_UNIQUE) && (Destination.AddrType == IP_ADDR_UNIQUE) &&
			(Source.uIpAddr == 0xFFFFFFFF ) && (Destination.uIpAddr == 0xFFFFFFFF))
			{
				bFound = TRUE;
			}
			//Enumerate me/any as source
			else if((Source.AddrType != IP_ADDR_UNIQUE) && (Destination.AddrType == IP_ADDR_UNIQUE) &&
			(Source.uIpAddr != 0xFFFFFFFF ) && (Destination.uIpAddr == 0xFFFFFFFF))
			{
				if((pIPSecMMSA[j].Me.AddrType == Source.AddrType) &&
					(pIPSecMMSA[j].Me.uIpAddr == Source.uIpAddr) && (pIPSecMMSA[j].Me.uSubNetMask == Source.uSubNetMask))
				{
					bFound = TRUE;
				}

			}
			//Enumerate me/any as dst
			else if((Source.AddrType == IP_ADDR_UNIQUE) && (Destination.AddrType != IP_ADDR_UNIQUE) &&
			(Source.uIpAddr == 0xFFFFFFFF ) && (Destination.uIpAddr != 0xFFFFFFFF))
			{
				if( (pIPSecMMSA[j].Peer.AddrType == Destination.AddrType)
					&& (pIPSecMMSA[j].Peer.uIpAddr == Destination.uIpAddr)
					&& (pIPSecMMSA[j].Peer.uSubNetMask == Destination.uSubNetMask))
				{
					bFound = TRUE;
				}
			}
			//Enumerate me/any as source/dst
			else if((Source.AddrType != IP_ADDR_UNIQUE) && (Destination.AddrType != IP_ADDR_UNIQUE) &&
			(Source.uIpAddr != 0xFFFFFFFF ) && (Destination.uIpAddr != 0xFFFFFFFF))
			{
				if((pIPSecMMSA[j].Me.AddrType == Source.AddrType)
					&& (pIPSecMMSA[j].Me.uIpAddr == Source.uIpAddr)
					&& (pIPSecMMSA[j].Me.uSubNetMask == Source.uSubNetMask)
					&& (pIPSecMMSA[j].Peer.AddrType == Destination.AddrType)
					&& (pIPSecMMSA[j].Peer.uIpAddr == Destination.uIpAddr)
					&& (pIPSecMMSA[j].Peer.uSubNetMask == Destination.uSubNetMask))
				{
					bFound = TRUE;
				}

			}
			//Enumerate Only given source SPL_SRVR MMSAs
			else if((Source.AddrType != IP_ADDR_UNIQUE) && (Destination.AddrType == IP_ADDR_UNIQUE) &&
			(Source.uIpAddr == 0xFFFFFFFF ) && (Destination.uIpAddr == 0xFFFFFFFF))
			{
				if(pIPSecMMSA[j].Me.AddrType == Source.AddrType)
				{
					bFound = TRUE;
				}

			}
			//Enumerate Only given dst SPL_SRVR MMSAs
			else if((Source.AddrType == IP_ADDR_UNIQUE) && (Destination.AddrType != IP_ADDR_UNIQUE) &&
			(Source.uIpAddr == 0xFFFFFFFF ) && (Destination.uIpAddr == 0xFFFFFFFF))
			{
				if(pIPSecMMSA[j].Peer.AddrType == Destination.AddrType)
				{
					bFound = TRUE;
				}
			}
			//Enumerate Only given src&dst MMSAs
			else if((Source.uIpAddr != 0xFFFFFFFF) && (Destination.uIpAddr != 0xFFFFFFFF))
			{
				if((pIPSecMMSA[j].Me.uIpAddr == Source.uIpAddr) && (pIPSecMMSA[j].Peer.uIpAddr == Destination.uIpAddr))
				{
					bFound = TRUE;
				}
			}
			//Enumerate Only given source MMSAs
			else if((Source.uIpAddr != 0xFFFFFFFF) && (Destination.uIpAddr == 0xFFFFFFFF))
			{
				if(pIPSecMMSA[j].Me.uIpAddr == Source.uIpAddr)
				{
					bFound = TRUE;
				}
			}
			//Enumerate Only given dst MMSAs
			else if((Source.uIpAddr == 0xFFFFFFFF) && (Destination.uIpAddr != 0xFFFFFFFF))
			{
				if(pIPSecMMSA[j].Peer.uIpAddr == Destination.uIpAddr)
				{
					bFound = TRUE;
				}
			}

			//Finally print it is found...
			if(bFound)
			{
				if(!bHeader)
				{
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_IKE_SA_HEADING,szTime);
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_UNDERLINE);
					if(bFormat)
					{
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DST_SEC_HEADING);
						//This is place holder for date and time created...
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNDERLINE);
					}
					bHeader = TRUE;
				}
				PrintMMSas(pIPSecMMSA[j], bFormat, addressHash, bResolveDNS);
			}

		}

		SPDApiBufferFree(pIPSecMMSA);
		pIPSecMMSA=NULL;

		if(dwReserved == 0)								//this is API requirement
		{
			BAIL_OUT;
		}
	}

error:
	if(pIPSecMMSA)
	{
		SPDApiBufferFree(pIPSecMMSA);
		pIPSecMMSA=NULL;
	}
	if(bHeader == FALSE)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_MMSAS_6);
	}


	return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintMMSas
//
//Date of Creation: 9-3-2001
//
//Parameters:
//
//			IN IPSEC_MM_SA MMsas,
//			IN BOOL bFormat
//			IN NshHashTable& addressHash
//			IN BOOL bResolveDNS
//
//Return:	VOID
//
//Description: This function prints data for MMsas
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintMMSas(
		IN IPSEC_MM_SA MMsas,
		IN BOOL bFormat,
		IN NshHashTable& addressHash,
		IN BOOL bResolveDNS
		)
{
	DWORD i = 0;
	BYTE* pbData = NULL;
	DWORD dwLenth = 0;

	if(!bFormat)//List
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_COOKIE_PAIR);
		pbData = (BYTE*)&(MMsas.MMSpi.Initiator);
		dwLenth = sizeof(IKE_COOKIE);
		for(i=0; i<dwLenth; i++)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_COOKIE,pbData[i]);
		}

		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_COLON);

		pbData = (BYTE*)&(MMsas.MMSpi.Responder);
		for(i=0; i<dwLenth; i++)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_COOKIE,pbData[i]);
		}

		//Created time required clarification
		//Security Methods
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SEC_METHOD_HEADING);

		switch(MMsas.SelectedMMOffer.EncryptionAlgorithm.uAlgoIdentifier)
		{
			case CONF_ALGO_NONE:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NONE_ALGO);
					break;
			case CONF_ALGO_DES:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DES_ALGO);
					break;
			case CONF_ALGO_3_DES:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NO_SA_FOUND_MSGDES_ALGO);
					break;
			default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO);
					break;
		}

		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SLASH);

		switch(MMsas.SelectedMMOffer.HashingAlgorithm.uAlgoIdentifier)
		{
			case AUTH_ALGO_NONE:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NONE_ALGO);
					break;
			case AUTH_ALGO_MD5:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_MD5_ALGO);
					break;
			case AUTH_ALGO_SHA1:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SHA1_ALGO);
					break;
			default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO);
					break;
		}
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DH_LIFETIME,MMsas.SelectedMMOffer.dwDHGroup, MMsas.SelectedMMOffer.Lifetime.uKeyExpirationTime);

		//Authentication Mode
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_AUTH_MODE_HEADING);
		switch(MMsas.MMAuthEnum)
		{
			case IKE_PRESHARED_KEY:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_PRE_KEY);
					break;
    		case IKE_DSS_SIGNATURE:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DSS_SIGN);
					break;
    		case IKE_RSA_SIGNATURE:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_RSA_SIGN);
					break;
    		case IKE_RSA_ENCRYPTION:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_RSA_ENCRYPT);
					break;
    		case IKE_SSPI:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_KERBEROS);
					break;
    		default:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO);
					break;
		}

		//Source	address:
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SRC_HEADING);
		PrintAddr(MMsas.Me, addressHash, false);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_PORT,MMsas.UdpEncapContext.wSrcEncapPort);
		if(bResolveDNS)
		{
			PrintAddrStr(&(MMsas.Me), addressHash);
		}
		switch(MMsas.MMAuthEnum)
		{
			case IKE_PRESHARED_KEY:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ID_HEADING);
					PrintAddr(MMsas.Me, addressHash, bResolveDNS);
					break;
    		case IKE_DSS_SIGNATURE:
    		case IKE_RSA_SIGNATURE:
    		case IKE_RSA_ENCRYPTION:
    				if(MMsas.MyCertificateChain.pBlob) {
    					PrintSACertInfo(MMsas);
    				}
    				else if(MMsas.MyId.pBlob){
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ID_VALUE,(LPTSTR)(MMsas.MyId.pBlob));
    				}
    				break;
    		case IKE_SSPI:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ID_VALUE,(LPTSTR)(MMsas.MyId.pBlob));
					break;
    		default:
					break;
		}

		//Destination	address:
 		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DST_HEADING);
		PrintAddr(MMsas.Peer, addressHash, false);
 		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_PORT,MMsas.UdpEncapContext.wDesEncapPort);
 		if(bResolveDNS)
 		{
			PrintAddrStr(&(MMsas.Peer), addressHash);
		}
		switch(MMsas.MMAuthEnum)
		{
			case IKE_PRESHARED_KEY:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ID_HEADING);
					PrintAddr(MMsas.Peer, addressHash, bResolveDNS);
					break;
    		case IKE_DSS_SIGNATURE:
    		case IKE_RSA_SIGNATURE:
    		case IKE_RSA_ENCRYPTION:
    				if(MMsas.PeerCertificateChain.pBlob) {
    					PrintSACertInfo(MMsas);
    				}
    				else if(MMsas.PeerId.pBlob){
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ID_VALUE,(LPTSTR)(MMsas.PeerId.pBlob));
    				}
    				break;
    		case IKE_SSPI:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ID_VALUE,(LPTSTR)(MMsas.PeerId.pBlob));
					break;
    		default:
					break;
		}
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	}
	else // Table output
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

		PrintAddr(MMsas.Me, addressHash, bResolveDNS);
		switch(MMsas.MMAuthEnum)
		{
			case IKE_PRESHARED_KEY:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SPACE_ADJ);
					break;
    		case IKE_DSS_SIGNATURE:
    		case IKE_RSA_SIGNATURE:
    		case IKE_RSA_ENCRYPTION:
    				//This is a place holder for id
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SPACE_ADJ);
    				break;
    		case IKE_SSPI:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_KERB_ID, (LPTSTR)(MMsas.MyId.pBlob));
					break;
    		default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SPACE_ADJ);
					break;
		}

		//Security  Methods
		switch(MMsas.SelectedMMOffer.EncryptionAlgorithm.uAlgoIdentifier)
		{
			case CONF_ALGO_NONE:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NONE_ALGO);
					break;
			case CONF_ALGO_DES:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DES_ALGO);
					break;
			case CONF_ALGO_3_DES:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NO_SA_FOUND_MSGDES_ALGO);
					break;
			default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO);
					break;
		}

		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SLASH);

		switch(MMsas.SelectedMMOffer.HashingAlgorithm.uAlgoIdentifier)
		{
			case AUTH_ALGO_NONE:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NONE_ALGO);
					break;
			case AUTH_ALGO_MD5:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_MD5_ALGO);
					break;
			case AUTH_ALGO_SHA1:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SHA1_ALGO);
					break;
			default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO);
					break;
		}
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DH_LIFETIME,MMsas.SelectedMMOffer.dwDHGroup, MMsas.SelectedMMOffer.Lifetime.uKeyExpirationTime);

		if(bResolveDNS)
		{
			PrintAddrStr(&(MMsas.Me), addressHash, DYNAMIC_SHOW_MMSAS_DNS);
		}


		//One set over next set  starts
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

		PrintAddr(MMsas.Peer, addressHash, bResolveDNS);
		switch(MMsas.MMAuthEnum)
		{
			case IKE_PRESHARED_KEY:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SPACE_ADJ);
					//"                                          "
					break;
    		case IKE_DSS_SIGNATURE:
    		case IKE_RSA_SIGNATURE:
    		case IKE_RSA_ENCRYPTION:
		    		//This is a place holder for id
		    		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SPACE_ADJ);
    				break;
    		case IKE_SSPI:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_KERB_PEER_ID, (LPTSTR)(MMsas.PeerId.pBlob));
					break;
    		default:
    				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SPACE_ADJ);
					break;
		}

		//Sec Methods
		switch(MMsas.SelectedMMOffer.EncryptionAlgorithm.uAlgoIdentifier)
		{
			case CONF_ALGO_NONE:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NONE_ALGO);
					break;
			case CONF_ALGO_DES:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DES_ALGO);
					break;
			case CONF_ALGO_3_DES:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NO_SA_FOUND_MSGDES_ALGO);
					break;
			default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO);
					break;
		}

		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SLASH);

		switch(MMsas.SelectedMMOffer.HashingAlgorithm.uAlgoIdentifier)
		{
			case AUTH_ALGO_NONE:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NONE_ALGO);
					break;
			case AUTH_ALGO_MD5:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_MD5_ALGO);
					break;
			case AUTH_ALGO_SHA1:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SHA1_ALGO);
					break;
			default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO);
					break;
		}

	  	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_DH_LIFETIME,MMsas.SelectedMMOffer.dwDHGroup, MMsas.SelectedMMOffer.Lifetime.uKeyExpirationTime);

		if(bResolveDNS)
		{
			PrintAddrStr(&(MMsas.Peer), addressHash, DYNAMIC_SHOW_MMSAS_DNS);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: PrintSACertInfo
//
//Date of Creation: 9-3-2001
//
//Parameters: 	IN IPSEC_MM_SA& MMsas
//
//Return: 		VOID
//
//Description:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
VOID
PrintSACertInfo(
	IN IPSEC_MM_SA& MMsas
	)
{
    CRYPT_DATA_BLOB pkcsMsg;
    HANDLE hCertStore = NULL;
    PCCERT_CONTEXT pPrevCertContext = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    _TCHAR pszSubjectName[MAX_STR_LEN] = {0};
    char szThumbPrint[MAX_STR_LEN] = {0};
    BOOL bPrintID = FALSE;
    BOOL bLastCert = FALSE;
    BOOL pCertPrinted = TRUE;


    pkcsMsg.pbData=MMsas.MyCertificateChain.pBlob;
    pkcsMsg.cbData=MMsas.MyCertificateChain.dwSize;

    hCertStore = CertOpenStore( CERT_STORE_PROV_PKCS7,
                                    MY_ENCODING_TYPE | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    CERT_STORE_READONLY_FLAG,
                                    &pkcsMsg);

    if ( NULL == hCertStore )
    {
        BAIL_OUT;
    }

    while(TRUE)
    {

        pCertContext = CertEnumCertificatesInStore(  hCertStore,
                                                     pPrevCertContext);
        if ( NULL == pCertContext )
        {
            bLastCert = TRUE;
        }

        if ( !pCertPrinted )
        {
            //print the certificate
            if ( !bPrintID )
            {
                PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ID_VALUE,(LPTSTR)(pszSubjectName));
                bPrintID = TRUE;
            }

            if ( !bLastCert )
            {
                PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ISSUE_CA, (LPTSTR) pszSubjectName );
            }
            else
            {
                PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_ROOTCA , (LPTSTR) pszSubjectName );
            }

            PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_THUMB_PRINT);
            PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_THUMBPRINT , szThumbPrint);

			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_HASH_OPEN_BRACKET     );
			switch(MMsas.SelectedMMOffer.HashingAlgorithm.uAlgoIdentifier)
			{
				case AUTH_ALGO_NONE:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_NONE_ALGO);
						break;
				case AUTH_ALGO_MD5:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_MD5_ALGO);
						break;
				case AUTH_ALGO_SHA1:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_SHA1_ALGO);
						break;
				default:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO);
						break;
			}
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_HASH_CLOSE_BRACKET);

            pCertPrinted = TRUE;
        }

        if ( bLastCert )
        {
            BAIL_OUT;
        }

        GetSubjectAndThumbprint(pCertContext, pszSubjectName, szThumbPrint);
        pPrevCertContext = pCertContext;
        pCertPrinted = FALSE;

    }

error:
    if ( hCertStore )
    {
        CertCloseStore(hCertStore, 0 );
    }
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function: GetNameAudit
//
//Date of Creation: 1-3-2002
//
//Parameters:
//
//					IN CRYPT_DATA_BLOB *NameBlob,
//					IN OUT LPTSTR Name,
//					IN DWORD NameBufferSize
//
//Return:	VOID
//
//Description: Translates encoded Name into Unicode string.
//			   Buffer already allocated.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
GetNameAudit(
	IN CRYPT_DATA_BLOB *NameBlob,
	IN OUT LPTSTR Name,
	IN DWORD NameBufferSize
	)
{
	DWORD dwCount=0;
	DWORD dwSize = 0;

	dwSize = CertNameToStr(
					MY_ENCODING_TYPE,     		// Encoding type
					NameBlob,            		// CRYPT_DATA_BLOB
					CERT_X500_NAME_STR, 		// Type
					Name,       				// Place to return string
					NameBufferSize);            // Size of string (chars)
	if(dwSize <= 1)
	{
		dwCount = _tcslen(_TEXT(""))+1;
		_tcsncpy(Name, _TEXT(""), dwCount);
	}

    return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	CertGetSHAHash
//
//	Date of Creation: 	1-3-2002
//
//	Parameters		:
//
//						IN PCCERT_CONTEXT pCertContext,
//						IN OUT BYTE* OutHash
//
//	Return			:	DWORD
//
//	Description		: 	Gets certificate context property
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
CertGetSHAHash(
	IN PCCERT_CONTEXT pCertContext,
	IN OUT BYTE* OutHash
	)
{
    DWORD HashSize = SHA_LENGTH - 1;//one less for null termination
    DWORD dwReturn = ERROR_SUCCESS;

    if (!CertGetCertificateContextProperty(pCertContext,
                                           CERT_SHA1_HASH_PROP_ID,
                                           (VOID*)OutHash,
                                           &HashSize))
    {
        dwReturn = GetLastError();
    }

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: print_vpi
//
//	Date of Creation: 1-3-2002
//
//	Parameters		:
//						IN unsigned char *vpi,
//						IN int vpi_len,
//						IN OUT char *msg
//
//	Return			:	VOID
//
//	Description		: 	Prepare string for Cookie
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
VOID
print_vpi(
	IN unsigned char *vpi,
	IN int vpi_len,
	IN OUT char *msg
	)
{
    int i;
    char *p = msg;

    if ((vpi != NULL) && (p != NULL))
    {
		for (i=0; i<vpi_len; i++)
		{
			p += _snprintf(p,1,"%x",vpi[i]);
		}

    	*p = 0;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	GetSubjectAndThumbprint
//
//	Date of Creation: 	1-3-2002
//
//	Parameters		:
//						IN PCCERT_CONTEXT pCertContext,
//						IN LPTSTR pszSubjectName,
//						IN LPSTR pszThumbPrint
//
//	Return			:	VOID
//
//	Description		: 	Drills CA and prints thumbprint and Issuing CAs.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
GetSubjectAndThumbprint(
	IN PCCERT_CONTEXT pCertContext,
	IN LPTSTR pszSubjectName,
	IN LPSTR pszThumbPrint
	)
{
    DWORD dwReturn = ERROR_SUCCESS;
    CRYPT_DATA_BLOB NameBlob;
    BYTE CertHash[SHA_LENGTH] = {0};

    NameBlob = pCertContext->pCertInfo->Subject;

    dwReturn = GetNameAudit(&NameBlob,pszSubjectName,MAX_STR_LEN);

    if(dwReturn == ERROR_SUCCESS)
    {
    	dwReturn = CertGetSHAHash(pCertContext,CertHash);
	}

	if(dwReturn == ERROR_SUCCESS)
	{
    	print_vpi(CertHash, SHA_LENGTH, pszThumbPrint);
    }
 }

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	ShowQMSas
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN IPAddr source,
//						IN IPAddr destination,
//						IN DWORD dwProtocol
//						IN NshHashTable& addressHash
//						IN BOOL bResolveDNS
//
//	Return			: 	DWORD
//
//	Description		: 	This function prepares data for QMsas
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowQMSas(
	IN ADDR Source,
	IN ADDR Destination,
	IN DWORD dwProtocol,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	)
{
	DWORD dwReturn = ERROR_SUCCESS; 	// success by default
	DWORD i=0, j=0;
	DWORD dwResumeHandle = 0;          	// handle for continuation calls
	DWORD dwCount =2;                 	// counting objects here min 2 required
	PIPSEC_QM_SA pIPSecQMSA = NULL;     // for QM SA calls
	DWORD dwReserved =0;              	// reserved container
	DWORD dwVersion = 0;
	BOOL bFound = FALSE;
	BOOL bHeader = FALSE;
	BOOL bContinue = TRUE;

	// make the call(s)
	for (i = 0; ;i+=dwCount)
	{
		dwReturn = EnumQMSAs(g_szDynamicMachine, dwVersion , NULL, 0, 0, &pIPSecQMSA, &dwCount, &dwReserved, &dwResumeHandle, NULL);
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			if (i == 0)
			{
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_QMSAS_3);
				bHeader = TRUE;											//To Block other error message
			}
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
		for (j = 0; j < dwCount; j++)
		{
			bFound = FALSE;
			bContinue = TRUE;
			//Source is a SPL_SERVER
			if((Source.AddrType != IP_ADDR_UNIQUE) && bContinue)
			{
				if(pIPSecQMSA[j].IpsecQMFilter.SrcAddr.AddrType == Source.AddrType)
				{
					bFound = TRUE;
				}
				else
				{
					bFound = FALSE;
					bContinue= FALSE;
				}
			}
			//Destination is a SPL_SERVER
			if((Destination.AddrType != IP_ADDR_UNIQUE)&& bContinue)
			{
				if(pIPSecQMSA[j].IpsecQMFilter.DesAddr.AddrType == Destination.AddrType)
				{
					bFound = TRUE;
				}
				else
				{
					bFound = FALSE;
					bContinue= FALSE;
				}
			}
			//Source Addr specie
			if((Source.uIpAddr != 0xFFFFFFFF)&& bContinue)
			{
				if(pIPSecQMSA[j].IpsecQMFilter.SrcAddr.uIpAddr == Source.uIpAddr)
				{
					bFound = TRUE;
				}
				else
				{
					bFound = FALSE;
					bContinue= FALSE;
				}
			}
			// Check for me/any
			// 0x55555555 is an invalid mask. In parent function mask is initialized with this value.
			// If user gives the input then this will be overwritten.
			if((Source.uSubNetMask != 0x55555555)&& bContinue)
			{
				if(pIPSecQMSA[j].IpsecQMFilter.SrcAddr.uSubNetMask == Source.uSubNetMask)
				{
					bFound = TRUE;
				}
				else
				{
					bFound = FALSE;
					bContinue= FALSE;
				}
			}
			//Dst Addr
			if((Destination.uIpAddr != 0xFFFFFFFF)&& bContinue)
			{
				if(pIPSecQMSA[j].IpsecQMFilter.DesAddr.uIpAddr == Destination.uIpAddr)
				{
					bFound = TRUE;
				}
				else
				{
					bFound = FALSE;
					bContinue= FALSE;
				}
			}
			//
			// Check for me/any
			// 0x55555555 is an invalid mask. In parent function mask is initialized with this value.
			// If user gives the input then this will be overwritten.
			//
			if((Destination.uSubNetMask != 0x55555555)&& bContinue)
			{
				if(pIPSecQMSA[j].IpsecQMFilter.DesAddr.uSubNetMask == Destination.uSubNetMask)
				{
					bFound = TRUE;
				}
				else
				{
					bFound = FALSE;
					bContinue= FALSE;
				}
			}
			//Protocol specified
			if((dwProtocol != 0xFFFFFFFF)&& bContinue)
			{
				if(pIPSecQMSA[j].IpsecQMFilter.Protocol.dwProtocol == dwProtocol)
				{
					bFound = TRUE;
				}
				else
				{
					bFound = FALSE;
					bContinue= FALSE;
				}
			}
			//
			// AllQmsas
			//
			if((Source.uIpAddr == 0xFFFFFFFF ) && (Destination.uIpAddr == 0xFFFFFFFF) &&
				(Source.AddrType == IP_ADDR_UNIQUE) && (Destination.AddrType == IP_ADDR_UNIQUE) &&
				(dwProtocol == 0xFFFFFFFF))
			{
				bFound = TRUE;
			}

			if(bFound)
			{
				if(!bHeader)
				{
					//
					// Display main mode SAs
					//
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_HEADING);
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_UNDERLINE);
					bHeader = TRUE;
				}
				PrintQMSAFilter(pIPSecQMSA[j], addressHash, bResolveDNS);
			}
		}

		if(dwReserved == 0)
		{
			//
			// This API requirement
			//
			BAIL_OUT;
		}

		SPDApiBufferFree(pIPSecQMSA);
		pIPSecQMSA=NULL;
	}

error:
	//error path clean up
	if(pIPSecQMSA)
	{
		SPDApiBufferFree(pIPSecQMSA);
	}
	if(bHeader == FALSE)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHOW_QMSAS_4);
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	PrintQMSas
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN IPSEC_MM_SA QMOffer
//
//	Return			:	VOID
//
//	Description		: 	This function displays quickmode offer details for security associations.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintQMSas(
	IN IPSEC_QM_OFFER QMOffer
	)
{
	DWORD i = 0;

	if(QMOffer.dwNumAlgos >0)
	{
		for (i = 0; i < QMOffer.dwNumAlgos; i++)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);

			//print Authentication algorithms
			if(QMOffer.Algos[i].Operation == AUTHENTICATION)
			{
				switch(QMOffer.Algos[i].uAlgoIdentifier)
				{
				case 1:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_MD5_NONE_NONE_ALGO, QMOffer.Algos[i].uAlgoKeyLen, QMOffer.Algos[i].uAlgoRounds);
					break;
				case 2:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_SHA1_NONE_NONE_ALGO, QMOffer.Algos[i].uAlgoKeyLen, QMOffer.Algos[i].uAlgoRounds);
					break;
				case 0:
				default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_NONE_NONE_NONE_ALGO);
					break;
				}
			}
			else if(QMOffer.Algos[i].Operation == ENCRYPTION)
			{
				//print Hash algorithms
				switch(QMOffer.Algos[i].uAlgoIdentifier)
				{
				case 1:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_NONE_DES_ALGO, QMOffer.Algos[i].uAlgoKeyLen, QMOffer.Algos[i].uAlgoRounds);
					break;
				case 2:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_NONE_UNKNOWN_ALGO);
					break;
				case 3:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_NONE_3DES_ALGO, QMOffer.Algos[i].uAlgoKeyLen, QMOffer.Algos[i].uAlgoRounds);
					break;
				case 0:
				default:
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_NONE_NONE_ALGO);
					break;
				}

				if (QMOffer.Algos[i].uSecAlgoIdentifier != HMAC_AUTH_ALGO_NONE)
					switch(QMOffer.Algos[i].uSecAlgoIdentifier)
					{
					case 1:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_MD5_ALGO);
						break;
					case 2:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_SHA1_ALGO);
						break;
					case 0:
					default:
						PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_NONE_ALGO);
						break;
					}
				else
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_NONE_SPACE_ALGO);
			}
			else
			{
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMP_SAS_NONE_NONE_NONE_ALGO);
			}

			PrintMessageFromModule(g_hModule, QMPFSDHGroup(QMOffer.dwPFSGroup));
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	PrintQMSAFilter
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN IPSEC_QM_SA QMsa
//						IN NshHashTable& addressHash
//						IN BOOL bResolveDNS
//
//	Return			: 	DWORD
//
//	Description		: 	This function displays quickmode filter details for Security associations.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
PrintQMSAFilter(
	IN IPSEC_QM_SA QMsa,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	)
{
	DWORD dwReturn = 0;
	DWORD dwVersion = 0;
	PIPSEC_QM_POLICY pIPSecQMP = NULL;

	//Print Tunnel or Transport type
	switch(QMsa.IpsecQMFilter.QMFilterType)
	{
		case QM_TRANSPORT_FILTER:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TRANSPORT_FILTER_HEADING);
			break;
		case QM_TUNNEL_FILTER:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_FILTER_HEADING);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_UNKNOWN);
			break;
	}

	//print qmpolicy name
	dwReturn = GetQMPolicyByID(g_szDynamicMachine, dwVersion, QMsa.gQMPolicyID, 0, &pIPSecQMP, NULL);
	if(dwReturn == ERROR_SUCCESS)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_POL_NAME_HEADING, pIPSecQMP[0].pszPolicyName);
	}

	//Print source and destination point.
	if (QMsa.IpsecQMFilter.QMFilterType == QM_TUNNEL_FILTER)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_SRC);
		PrintAddr(QMsa.IpsecQMFilter.MyTunnelEndpt, addressHash, bResolveDNS);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_TUNNEL_DST);
		PrintAddr(QMsa.IpsecQMFilter.PeerTunnelEndpt, addressHash, bResolveDNS);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_ADDR_HEADING);
	PrintAddr(QMsa.IpsecQMFilter.SrcAddr, addressHash, bResolveDNS);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DST_ADDR_HEADING);
	PrintAddr(QMsa.IpsecQMFilter.DesAddr, addressHash, bResolveDNS);

	//Print protocol
	switch(QMsa.IpsecQMFilter.Protocol.dwProtocol)
	{
		case PROT_ID_ICMP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_ICMP);
			break;
		case PROT_ID_TCP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_TCP);
			break;
		case PROT_ID_UDP:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_UDP);
			break;
		case PROT_ID_RAW:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_RAW);
			break;
		case PROT_ID_ANY:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_ANY);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PROTO_HEADING, QMsa.IpsecQMFilter.Protocol.dwProtocol);
			break;
	}

	//print source and destination port
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_SRC_PORT, QMsa.IpsecQMFilter.SrcPort.wPort);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DST_PORT, QMsa.IpsecQMFilter.DesPort.wPort);

	//print Inbound and outbound filteractions
	switch(QMsa.IpsecQMFilter.dwFlags)
	{
		case FILTER_DIRECTION_INBOUND:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DIRECTION_INBOUND);
			break;
		case FILTER_DIRECTION_OUTBOUND:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DIRECTION_OUTBOUND);
			break;
		default:
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DIRECTION_ERR);
			break;
	}

	//print encapsulation details
	if (QMsa.EncapInfo.SAEncapType != SA_UDP_ENCAP_TYPE_NONE)
	{
		if(QMsa.EncapInfo.SAEncapType == SA_UDP_ENCAP_TYPE_IKE)
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_ENCAP_IKE);
		}
		else
		{
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_ENCAP_OTHER);
		}
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_SRC_UDP_PORT, QMsa.EncapInfo.UdpEncapContext.wSrcEncapPort);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_DST_UDP_PORT, QMsa.EncapInfo.UdpEncapContext.wDesEncapPort);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_PEER_ADDR);
		PrintAddr(QMsa.EncapInfo.PeerPrivateAddr, addressHash, bResolveDNS);
	}
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_OFFER);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_COLUMN_HEADING);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_QMSAS_COLUMN_UNDERLINE);
	PrintQMSas(QMsa.SelectedQMOffer);

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	ShowRegKeys
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		:	VOID
//
//	Return			:	DWORD
//
//	Description		: 	This function displays ipsec configuration keys.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ShowRegKeys(
	VOID
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwKeyDataSize = sizeof(DWORD);
	DWORD dwKeyDataType = REG_DWORD;
	DWORD dwKeyData = 0;
	IKE_CONFIG IKEConfig;
	HKEY hRegistryKey = NULL;
	LPTSTR lpBootMode;
	PIPSEC_EXEMPT_ENTRY pAllEntries = NULL;

	ZeroMemory( &IKEConfig, sizeof(IKE_CONFIG) );

	dwReturn = RegOpenKeyEx(g_hGlobalRegistryKey, REGKEY_GLOBAL, 0, KEY_QUERY_VALUE, &hRegistryKey);

	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	dwReturn = GetConfigurationVariables(g_szDynamicMachine, &IKEConfig);

	if(dwReturn != ERROR_SUCCESS)
	{
		//Print default values
		IKEConfig.dwEnableLogging = IKE_LOG_DEFAULT;
		IKEConfig.dwStrongCRLCheck = STRONG_CRL_DEFAULT;
		dwReturn = ERROR_SUCCESS;

	}
	//print registry key headings

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_HEADING);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_HEADING_UNDERLINE);

	dwKeyData = IPSEC_DIAG_DEFAULT;
	dwReturn = RegQueryValueEx(hRegistryKey, ENABLE_DIAG, 0, &dwKeyDataType, (BYTE*)&dwKeyData, &dwKeyDataSize);
	if ((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_FILE_NOT_FOUND))
	{
	    BAIL_OUT;
    }	    
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_DIAG, dwKeyData);

	//Print GetConfig values
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IKE_LOG, IKEConfig.dwEnableLogging);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_STRONG_CRL, IKEConfig.dwStrongCRLCheck);

	dwKeyData = 0;
	dwKeyData = ENABLE_LOGINT_DEFAULT;
	dwReturn = RegQueryValueEx(hRegistryKey, ENABLE_LOGINT, 0, &dwKeyDataType, (BYTE*)&dwKeyData, &dwKeyDataSize);
	if ((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_FILE_NOT_FOUND))
	{
	    BAIL_OUT;
    }	    
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_LOG, dwKeyData);

	dwKeyData = 0;
	dwKeyData = ENABLE_EXEMPT_DEFAULT;
	dwReturn = RegQueryValueEx(hRegistryKey, ENABLE_EXEMPT, 0, &dwKeyDataType, (BYTE*)&dwKeyData, &dwKeyDataSize);
	if ((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_FILE_NOT_FOUND))
	{
	    BAIL_OUT;
    }	    
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_EXEMPT, dwKeyData);

	dwKeyData = BOOTMODE_DEFAULT;
	dwReturn = RegQueryValueEx(hRegistryKey, BOOTMODEKEY, 0, &dwKeyDataType, (BYTE*)&dwKeyData, &dwKeyDataSize);
	if ((dwReturn != ERROR_SUCCESS) && (dwReturn != ERROR_FILE_NOT_FOUND))
	{
		BAIL_OUT;
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE);
	switch (dwKeyData)
	{
	case VALUE_STATEFUL:
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_STATEFUL);
		break;
	case VALUE_BLOCK:
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_BLOCK);
		break;
	case VALUE_PERMIT:
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_PERMIT);
		break;
	default:
		dwReturn = ERROR_INVALID_DATA;
		break;
	}
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPTIONS_HEADER_1);

	dwKeyDataSize = 0;
	dwReturn = RegQueryValueEx(hRegistryKey, BOOTEXEMPTKEY, 0, 0, NULL, &dwKeyDataSize);
	if (dwReturn == ERROR_FILE_NOT_FOUND)
	{
		dwReturn = ERROR_SUCCESS;
	}
	else if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	if (dwKeyDataSize == 0)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPTIONS_NO_EXEMPTIONS);
	}
	else if ((dwKeyDataSize % sizeof(IPSEC_EXEMPT_ENTRY)) != 0)
	{
		dwReturn = ERROR_INVALID_DATA;
		BAIL_OUT;
	}
	else
	{
		size_t uiNumEntries = dwKeyDataSize / sizeof(IPSEC_EXEMPT_ENTRY);
		pAllEntries = new IPSEC_EXEMPT_ENTRY[uiNumEntries];
		if (pAllEntries == NULL)
		{
			dwReturn = ERROR_NOT_ENOUGH_MEMORY;
			BAIL_OUT;
		}

		dwReturn = RegQueryValueEx(hRegistryKey, BOOTEXEMPTKEY, 0, 0, (BYTE*)pAllEntries, &dwKeyDataSize);
		if (dwReturn != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}

		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPTIONS_HEADER_2);
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPTIONS_HEADER_3);

		for (size_t i = 0; i < uiNumEntries; ++i)
		{
			PIPSEC_EXEMPT_ENTRY pEntry = pAllEntries + i;

			switch (pEntry->Protocol)
			{
			case PROT_ID_TCP:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_TCP);
				break;
			case PROT_ID_UDP:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_UDP);
				break;
			case PROT_ID_ICMP:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_ICMP);
				break;
			case PROT_ID_RAW:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_RAW);
				break;
			case PROT_ID_ANY:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_ANY);
				break;
			default:
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPT_INTEGER, (int)pEntry->Protocol);
				break;
			}

			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPT_PORT, (int)pEntry->SrcPort);
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPT_PORT, (int)pEntry->DestPort);

			switch (pEntry->Direction)
			{
			case (EXEMPT_DIRECTION_INBOUND):
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPT_DIRECTION_IN);
				break;
			case (EXEMPT_DIRECTION_OUTBOUND):
				PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_BOOTMODE_EXEMPT_DIRECTION_OUT);
				break;
			default:
				dwReturn = ERROR_INVALID_DATA;
				BAIL_OUT;
			}
			PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
		}
	}

error:
	if (pAllEntries)
	{
		delete [] pAllEntries;
	}
	if (hRegistryKey)
	{
	    RegCloseKey(hRegistryKey);
	}

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	PrintAddr
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN ADDR addr
//						IN NshHashTable& addressHash
//						IN BOOL bResolveDNS
//
//	Return			:	VOID
//
//	Description		: 	This function displays ip address in xxx.xxx.xxx.xxx format.
//
//  Date			Author		Comments
//
////////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintAddr(
	IN ADDR addr,
	IN NshHashTable& addressHash,
	IN BOOL bResolveDNS
	)
{
    struct in_addr inAddr;

    LPSTR pszAddr = NULL;
    LPTSTR pszWPAddr = NULL;

    pszWPAddr = new _TCHAR[STR_ADDRLEN];

    if(pszWPAddr == NULL)
    {
		PrintErrorMessage(WIN32_ERR, ERROR_OUTOFMEMORY, NULL);
		BAIL_OUT;
	}

    ZeroMemory(pszWPAddr, STR_ADDRLEN * sizeof(_TCHAR));

	if(addr.AddrType == IP_ADDR_WINS_SERVER)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_WINS);
	}
	else if(addr.AddrType == IP_ADDR_DHCP_SERVER)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DHCP);
	}
	else if(addr.AddrType == IP_ADDR_DNS_SERVER)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_DNS);
	}
	else if(addr.AddrType == IP_ADDR_DEFAULT_GATEWAY)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_GATEWAY);
	}
	else if (addr.AddrType == IP_ADDR_UNIQUE && addr.uIpAddr == IP_ADDRESS_ME && addr.uSubNetMask == IP_ADDRESS_MASK_NONE)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PMYADD);
	}
	else if (addr.AddrType == IP_ADDR_SUBNET && addr.uIpAddr == SUBNET_ADDRESS_ANY && addr.uSubNetMask == SUBNET_MASK_ANY)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PANYADD);
	}
    else
    {
		inAddr.s_addr = addr.uIpAddr;
		pszAddr = inet_ntoa(inAddr);
		if(pszAddr == NULL)
		{
			_tcsncpy(pszWPAddr, _TEXT("               "), _tcslen(_TEXT("               "))+1);//if inet_ntoa fails 16 spaces
		}
		else
		{
			_sntprintf(pszWPAddr, STR_ADDRLEN-1, _TEXT("%-16S"), pszAddr);
		}

		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PADD, pszWPAddr);
	}

	if (bResolveDNS)
	{
		PrintAddrStr(&addr, addressHash);
	}

	if (pszWPAddr)
	{
		delete [] pszWPAddr;
	}
error:
	return;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//Function			: 	PrintMask
//
//Date of Creation	: 	9-3-2001
//
//Parameters		: 	IN ADDR addr
//
//Return			:	VOID
//
//Description		: 	This function displays ip address in xxx.xxx.xxx.xxx format.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintMask(
	IN ADDR addr
	)
{
    struct in_addr inAddr;
    LPSTR pszAddr = NULL;
    LPTSTR pszWPAddr = NULL;

    pszWPAddr = new _TCHAR[STR_ADDRLEN];

    if(pszWPAddr == NULL)
    {
		PrintErrorMessage(WIN32_ERR, ERROR_OUTOFMEMORY, NULL);
		BAIL_OUT;
	}

    ZeroMemory(pszWPAddr, STR_ADDRLEN * sizeof(_TCHAR));

	inAddr.s_addr = addr.uSubNetMask;
	pszAddr = inet_ntoa(inAddr);

	if(pszAddr == NULL)
	{
		_tcsncpy(pszWPAddr, _TEXT("               "), _tcslen(_TEXT("               "))+1);//if inet_ntoa fails 15 spaces
	}
	else
	{
		_sntprintf(pszWPAddr, STR_ADDRLEN-1, _TEXT("%-15S"), pszAddr);
	}

	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PADD, pszWPAddr);
	if (pszWPAddr)
	{
		delete [] pszWPAddr;
	}
error:
	return;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	LongLongToString
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		:
//						IN DWORD dwHigh,
//						IN DWORD dwLow,
//						IN int iPrintCommas
//
//	Return			:	LPTSTR
//
//	Description:	This routine will make a pretty string to match an input long-long,
//				 	and return it. If iPrintCommas is set, it will put in commas.
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

LPSTR
LongLongToString(
	IN DWORD dwHigh,
	IN DWORD dwLow,
	IN int iPrintCommas
	)
{
	char cFourGig[]="4294967296";	// "four gigabytes"
	char cBuf[POTF_MAX_STRLEN]={0};
	char cRes[POTF_MAX_STRLEN]={0}, cFullRes[POTF_MAX_STRLEN]={0}, *cRet = NULL;
	DWORD dwPos= 0, dwPosRes =0, dwThreeCount =0;

	// First, multiply the high dword by decimal 2^32 to
	// get the right decimal value for it.
	_snprintf(cBuf,POTF_MAX_STRLEN, "%u",dwHigh);
	cBuf[POTF_MAX_STRLEN -1] = 0;
	AscMultUint(cRes,cBuf,cFourGig);

	// next, add in the low DWORD (fine as it is)
	// to the previous product
	_snprintf(cBuf,POTF_MAX_STRLEN, "%u",dwLow);
	cBuf[POTF_MAX_STRLEN -1] = 0;
	AscAddUint(cFullRes, cRes, cBuf);

	// Finally, copy the buffer with commas.

	dwPos = 0;
	dwPosRes = 0;
	dwThreeCount = strlen(cFullRes)%3;
	while(cFullRes[dwPosRes] != '\0')
	{
		cBuf[dwPos++] = cFullRes[dwPosRes++];

		dwThreeCount +=2; // Same as subtracting one for modulo math

		if ((!(dwThreeCount%3))&&(cFullRes[dwPosRes] != '\0')&&(iPrintCommas))
		{
			cBuf[dwPos++]=',';
		}

		if(dwPos == 254)
			break;
	}

	cBuf[dwPos] = '\0';

	cRet = (LPSTR)malloc(255);
	if(cRet)									//Allocation failure is checked in parent function
	{
		memset(cRet, 0, 255);
		strncpy(cRet, cBuf, 255);
		cRet[254] = 0;
	}
	return(cRet);
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	AscMultUint
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN LPSTR cProduct,
//						IN LPSTR cA,
//						IN LPSTR cB
//
//	Return			: 	DWORD (0 on success, else failure code.)
//
//	Description		:	This routine will add two arbitrarily long ascii strings. It makes several
//						assumptions about them.
//						1) the string is null terminated.
// 						2) The LSB is the last char of the string. "1000000" is a million
// 						3) There are no signs or decimal points.
// 						4) The cProduct buffer is large enough to store the result
// 						5) The product will require 254 bytes or less.
//
//Revision History	:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
AscMultUint(
	IN LPSTR cProduct,
	IN LPSTR cA,
	IN LPSTR cB
	)
{
	int iALen =0, iBLen =0;
	int i=0,j=0,k=0, iCarry=0;
	char cTmp[POTF_MAX_STRLEN]={0};

	// Verify parameters

	if ((cA == NULL) || (cB == NULL) || (cProduct == NULL))
	{
		return((DWORD)-1);
	}

	iALen = strlen(cA);
	iBLen = strlen(cB);

	// We will multiply the traditional longhand way: for each digit in
	// cA, we will multiply it against cB and add the incremental result
	// into our temporary product.

	// for each digit of the first multiplicand

	for (i=0; i < iALen; i++)
	{
		iCarry = 0;

		// for each digit of the second multiplicand

		for(j=0; j < iBLen; j++)
		{
			// calculate this digit's value

			k = ((int) cA[iALen-i-1]-'0') * ((int) cB[iBLen-j-1]-'0');
			k += iCarry;

			// Add it in to the appropriate place in the result

			if (cTmp[i+j] != '\0')
			{
				k += (int) cTmp[i+j] - '0';
			}
			cTmp[i+j] = '0' + (char)(k % 10);
			iCarry = k/10;
		}

		// Take care of the straggler carry. If the higher
		// digits happen to be '9999' then this can require
		// a loop.

		while (iCarry)
		{
			if (cTmp[i+j] != '\0')
			{
				iCarry += cTmp[i+j] - '0';
			}
			cTmp[i+j] = '0' + (char)(iCarry%10);
			iCarry /= 10;
			j++;
		}
	}

	// Now that we've got the entire number, reverse it and put it back in the dest.

	// Skip leading 0's.

	i = strlen(cTmp) - 1;

	while ((i > 0)&&(cTmp[i] == '0'))
	{
		i--;
	}

	// Copy the product.

	j = 0;
	while (i >= 0)
	{
		cProduct[j++] = cTmp[i--];
	}

	cProduct[j] = '\0';

	// We're done. Return 0 for success!

	return(0);
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	AscAddUint
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN LPSTR cSum,
//						IN LPSTR cA,
//						IN LPSTR cB
//
//	Return			: 	DWORD(0 on success, else failure code.)
//
//	Description		:	This routine will add two arbitrarily long ascii strings. It makes several
//						assumptions about them.
//
//						1) the string is null terminated.
//						2) The LSB is the last char of the string. "1000000" is a million
//						3) There are no signs or decimal points.
//						4) The cSum buffer is large enough to store the result
//						5) The sum will require 254 bytes or less.
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
AscAddUint(
	IN LPSTR cSum,
	IN	LPSTR cA,
	IN LPSTR cB
	)
{
	int iALen=0, iBLen=0, iBiggerLen=0;
	int i=0,j=0,k=0, iCarry=0;
	char cTmp[POTF_MAX_STRLEN]={0}, *cBigger=NULL;

	// Verify parameters
	if ((cA == NULL) || (cB == NULL) || (cSum == NULL))
	{
		return((DWORD)-1);
	}

	iALen = strlen(cA);
	iBLen = strlen(cB);
	iCarry = 0;

	// Loop through, adding the values. Our result string will be
	// backwards, we'll straighten it out when we copy it to the
	// cSum buffer.
	for (i=0; (i < iALen) && (i < iBLen); i++)
	{
		// Figure out the actual decimal value of the add.
		k = (int) (cA[iALen-i-1] + cB[iBLen-i-1] + iCarry);
		k -= 2 * '0';

		// Set the carry as appropriate
		iCarry = k/10;

		// Set the current digit's value.
		cTmp[i] = '0' + (char)(k%10);
	}

	// At this point, all digits present in both strings have been added.
	// In other words, "12345" + "678901", "12345" has been added to "78901"
	// The next step is to account for the high-order digits of the larger number.

	if (iALen > iBLen)
	{
		cBigger = cA;
		iBiggerLen = iALen;
	}
	else
	{
		cBigger = cB;
		iBiggerLen = iBLen;
	}

	while (i < iBiggerLen)
	{
		k = cBigger[iBiggerLen - i - 1] + iCarry - '0';

		// Set the carry as appropriate
		iCarry = k/10;

		// Set the current digit's value.
		cTmp[i] = '0' + (char)(k%10);
		i++;
	}

	// Finally, we might still have a set carry to put in the next
	// digit.

	if (iCarry)
	{
		cTmp[i++] = '0' + (char)iCarry;
	}

	// Now that we've got the entire number, reverse it and put it back in the dest.
	// Skip leading 0's.
	i = strlen(cTmp) - 1;

	while ((i > 0)&&(cTmp[i] == '0'))
	{
		i--;
	}

	// and copy the number.
	j = 0;
	while (i >= 0)
	{
		cSum[j++] = cTmp[i--];
	}

	cSum[j] = '\0';

	// We're done. Return 0 for success!
	return(0);
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	PrintAddrStr
//
//	Date of Creation: 	9-3-2001
//
//	Parameters		: 	IN PADDR ResolveAddress
//						IN NshHashTable& addressHash
//
//	Return			:	VOID
//
//	Description		: 	Resolves IP address number to char string.
//
//	Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

VOID
PrintAddrStr(
	IN PADDR pResolveAddress,
	IN NshHashTable& addressHash,
	IN UINT uiFormat
	)
{
	switch(pResolveAddress->AddrType)
	{
		case IP_ADDR_WINS_SERVER:
		case IP_ADDR_DHCP_SERVER:
		case IP_ADDR_DNS_SERVER:
		case IP_ADDR_DEFAULT_GATEWAY:
		case IP_ADDR_SUBNET:
					//no resolve required for them... They are self explanatory...
			break;
		default:
			ULONG uIpAddr = pResolveAddress->uIpAddr;
			const char* name = addressHash.Find(uIpAddr);
			if (name == 0)
			{
				HOSTENT* pHostEnt = gethostbyaddr((char *)&uIpAddr, 4, pResolveAddress->AddrType);
				if (pHostEnt)
				{
					name = pHostEnt->h_name;
				}
				else
				{
					name = " ";
				}
				addressHash.Insert(uIpAddr, name);
			}
			PrintMessageFromModule(g_hModule, uiFormat, name);
			break;
	}
}


UINT QMPFSDHGroup(DWORD dwPFSGroup)
{
	UINT PFSGroup;
	switch (dwPFSGroup)
	{
	case PFS_GROUP_MM:
		PFSGroup = DYNAMIC_SHOW_QMP_MM_DH_GROUP;
		break;
	case PFS_GROUP_1:
		PFSGroup = DYNAMIC_SHOW_QMP_DH_GROUP_LOW;
		break;
	case PFS_GROUP_2:
		PFSGroup = DYNAMIC_SHOW_QMP_DH_GROUP_MEDIUM;
		break;
	case PFS_GROUP_2048:
		PFSGroup = DYNAMIC_SHOW_QMP_DH_GROUP_HIGH;
		break;
	default:
		PFSGroup = DYNAMIC_SHOW_QMP_PFS_NONE;
		break;
	}
	return PFSGroup;
}


// NshHashTable implementation


NshHashTable::NshHashTable() throw ()
{
	for(size_t i = 0; i < NSHHASHTABLESIZE; ++i)
	{
		NsuListInitialize(&table[i]);;
	}
}


NshHashTable::~NshHashTable() throw ()
{
	Clear();
}


DWORD NshHashTable::Insert(UINT uiNewKey, const char* szNewData) throw ()
{
	size_t hash = Hash(uiNewKey);
	if (Find(uiNewKey, hash) != 0)
	{
		return ERROR_DUPLICATE_TAG;
	}

	HashEntry* entry = new HashEntry(&table[hash], uiNewKey, szNewData);
	if (entry == 0)
	{
		delete entry;
		return ERROR_NOT_ENOUGH_MEMORY;
	}

	return ERROR_SUCCESS;
}


void NshHashTable::Clear() throw ()
{
	for (size_t i = 0; i < NSHHASHTABLESIZE; ++i)
	{
		PNSU_LIST_ENTRY pListEntry = NsuListRemoveFront(&table[i]);
		while (pListEntry)
		{
			NsuListEntryRemove(pListEntry);
			const HashEntry* pEntry = HashEntry::Get(pListEntry);
			delete(pEntry);
			pListEntry = NsuListRemoveFront(&table[i]);
		}
	}
}


const char* NshHashTable::Find(UINT uiKey) const throw ()
{
	return Find(uiKey, Hash(uiKey));
}


const char* NshHashTable::Find(UINT uiKey, size_t hash) const throw ()
{
	const HashEntry* entry = FindEntry(uiKey, hash);
	return (entry == 0) ? NULL : entry->Data();
}


size_t NshHashTable::Hash(UINT uiKey) const throw ()
{
	return uiKey % NSHHASHTABLESIZE;
}


const NshHashTable::HashEntry* NshHashTable::FindEntry(
												UINT uiKey,
												size_t hash
												) const throw ()
{
	NSU_LIST_ITERATOR iterator;
	NsuListIteratorInitialize(&iterator, (PNSU_LIST)&table[hash], 0);
	while (!NsuListIteratorAtEnd(&iterator))
	{
		PNSU_LIST_ENTRY pListEntry = NsuListIteratorCurrent(&iterator);
		const HashEntry* pEntry = HashEntry::Get(pListEntry);
		if (pEntry->Key() == uiKey)
		{
			return pEntry;
		}
		NsuListIteratorNext(&iterator);
	}
	return 0;
}


NshHashTable::HashEntry::HashEntry(
		PNSU_LIST pList,
		UINT uiNewKey,
		const char* szNewData
		) throw ()
: listEntry(),
  key(uiNewKey)
{
	NsuListInsertFront(pList, &listEntry);
	char* szTempData;
	NsuStringDupA(&szTempData, 1024, szNewData);
	data = szTempData;
}


NshHashTable::HashEntry::~HashEntry() throw ()
{
	NsuFree(reinterpret_cast<void**>(const_cast<char**>(&data)));
}


const NshHashTable::HashEntry* NshHashTable::HashEntry::Get(PNSU_LIST_ENTRY pEntry) throw ()
{
	return NsuListEntryGetData(pEntry, HashEntry, HashEntry::listEntry);
}


UINT NshHashTable::HashEntry::Key() const throw ()
{
	return key;
}


const char* NshHashTable::HashEntry::Data() const throw ()
{
	return data;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\nshcertmgmt.cpp ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: Dynamic/Nshcertmgmt.cpp
//
// 	Purpose			: Smartdefaults implementation.
//
// 	Developers Name	: Bharat/Radhika
//
//	History			:
//
//  Date			Author		Comments
//  10-13-2001   	Bharat		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#ifndef UNICODE
#define UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <winipsec.h>
#include <ipsecshr.h>
#include "memory.h"
#include "nshcertmgmt.h"

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	fIsCertStoreEmpty
//
//	Date of Creation	: 	10-10-2001
//
//	Parameters			:	IN HCERTSTORE hCertStore
//	Return				:	BOOL
//
//	Description			: 	Check if certificate store is empty.
//
//	Revision History	:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////////////////////////
BOOL
fIsCertStoreEmpty(
	IN HCERTSTORE hCertStore
	)
{
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL fResult = FALSE;

    pCertContext = CertEnumCertificatesInStore(hCertStore, NULL);

    if(NULL == pCertContext)
    {
        fResult = TRUE;
    }
    else
    {
        CertFreeCertificateContext(pCertContext);
    }

    return fResult;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	ListCertsInStore
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		:	IN HCERTSTORE hCertStore,
//						OUT INT_IPSEC_MM_AUTH_INFO ** ppAuthInfo,
//						OUT PDWORD pdwNumCertificates
//	Return			:	DWORD
//
//	Description		: 	Lists Certificates InStore hCertStore and fills in ppAuth.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ListCertsInStore(
	IN HCERTSTORE hCertStore,
	OUT INT_IPSEC_MM_AUTH_INFO ** ppAuthInfo,
	OUT PDWORD pdwNumCertificates
	)
{
    PCCERT_CONTEXT    pPrevCertContext = NULL;
    PCCERT_CONTEXT    pCertContext = NULL;
    CERT_NAME_BLOB    NameBlob;
	PCERT_ENHKEY_USAGE pUsage = NULL;
    PCERT_NODE pCertificateList = NULL;
    PCERT_NODE pTemp = NULL;

    INT_IPSEC_MM_AUTH_INFO * pAuthInfo = NULL;
    INT_IPSEC_MM_AUTH_INFO * pCurrentAuth = NULL;

    LPWSTR pszSubjectName = NULL;

    DWORD i = 0;
    DWORD dwNumCertificates = 0;
    DWORD dwError = 0;
	DWORD Usage = 0;

	BOOL bValid = FALSE;

    while(TRUE)
    {
        pCertContext = CertEnumCertificatesInStore(hCertStore, pPrevCertContext);

        if (!pCertContext)
        {
            break;
        }

		pUsage = NULL;
		Usage = 0;
		bValid = FALSE;

		dwError = CertGetEnhancedKeyUsage(pCertContext, 0, NULL, &Usage);
		if(Usage)
		{
			pUsage = (PCERT_ENHKEY_USAGE)LocalAlloc(LPTR, Usage);
			if(!pUsage)
			{
				dwError = ERROR_OUTOFMEMORY;
				BAIL_ON_WIN32ERROR(dwError)
			}

			CertGetEnhancedKeyUsage(pCertContext, 0, pUsage, &Usage);

			for (Usage = 0; Usage < pUsage->cUsageIdentifier; Usage++)
			{
				if(!strcmp(pUsage->rgpszUsageIdentifier[Usage],szOID_PKIX_KP_SERVER_AUTH))
				{
					bValid = TRUE;
				}
				else if(!strcmp(pUsage->rgpszUsageIdentifier[Usage],szOID_PKIX_KP_CLIENT_AUTH))
				{
					bValid = TRUE;
				}
				else if(!strcmp(pUsage->rgpszUsageIdentifier[Usage],szOID_ANY_CERT_POLICY))
				{
					bValid = TRUE;
				}
			}

			if(pUsage)
			{
				LocalFree(pUsage);
				pUsage = NULL;
			}
		}
		else
		{
			dwError = ERROR_SUCCESS;
		}
		if(bValid)
		{
			NameBlob = pCertContext->pCertInfo->Issuer;

			dwError = GetCertificateName(&NameBlob,	&pszSubjectName);
			if (dwError)
			{
				if(NULL != pPrevCertContext)
				{
					CertFreeCertificateContext(pCertContext);
				}
				break;
			}

			if (!FindCertificateInList(pCertificateList, pszSubjectName))
			{
				//
				// Append this CA to the list of CAs
				//
				pCertificateList = AppendCertificateNode(pCertificateList, pszSubjectName);
				dwNumCertificates++;
			}
			else
			{
				FreeADsStr(pszSubjectName);
			}
		}
		pPrevCertContext = pCertContext;
    }

    pAuthInfo = (INT_IPSEC_MM_AUTH_INFO *)AllocADsMem( sizeof(INT_IPSEC_MM_AUTH_INFO)*dwNumCertificates );
    if (!pAuthInfo)
    {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32ERROR(dwError)
    }

    pTemp = pCertificateList;

    for (i = 0; i < dwNumCertificates; i++)
    {
        pCurrentAuth = pAuthInfo + i;

        dwError = CopyCertificateNode(pCurrentAuth, pTemp);
        BAIL_ON_WIN32ERROR(dwError)
        pTemp = pTemp->pNext;
    }

    if (pCertificateList)
    {
        FreeCertificateList(pCertificateList);
    }

    *ppAuthInfo = pAuthInfo;
    *pdwNumCertificates = dwNumCertificates;

    return(dwError);

error:
    if (pCertificateList)
    {
        FreeCertificateList(pCertificateList);
    }

    if(NULL != pAuthInfo)
    {
        FreeADsMem(pAuthInfo);
    }

    *ppAuthInfo = NULL;
    *pdwNumCertificates = 0;

    return(dwError);
}
///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CopyCertificateNode
//
//	Date of Creation	: 	10-10-2001
//
//	Parameters			:	OUT PINT_IPSEC_MM_AUTH_INFO pCurrentAuth,
//							IN PCERT_NODE pTemp
//	Return				: 	DWORD
//
//	Description			:  	This function copies certificate from node to authentication.
//
//	Revision History	:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
CopyCertificateNode(
	OUT PINT_IPSEC_MM_AUTH_INFO pCurrentAuth,
	IN PCERT_NODE pTemp
	)
{
	DWORD dwError = ERROR_SUCCESS;
    LPWSTR pszSubjectName = NULL;

    pCurrentAuth->AuthMethod = IKE_RSA_SIGNATURE;			//value is 3
    pszSubjectName = AllocADsStr(pTemp->pszSubjectName);

    if (!pszSubjectName)
    {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32ERROR(dwError)
    }
    pCurrentAuth->pAuthInfo = (LPBYTE) pszSubjectName;

    //
    // The AuthInfoSize is in number of characters -1 the leading character
    // see  oakley\isadb.c
    //
    pCurrentAuth->dwAuthInfoSize = wcslen(pTemp->pszSubjectName)*sizeof(WCHAR);

error:
    return dwError;
}
///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	AppendCertificateNode
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		:	OUT PCERT_NODE pCertificateList,
//						IN LPWSTR pszSubjectName
//	Return			:	PCERT_NODE
//
//	Description		: 	Add node and allocates memory.
//
//	Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
PCERT_NODE
AppendCertificateNode(
	OUT PCERT_NODE pCertificateList,
	IN LPWSTR pszSubjectName
	)
{
    PCERT_NODE pCertificateNode = NULL;

    pCertificateNode = (PCERT_NODE)AllocADsMem(sizeof(CERT_NODE));

    if (!pCertificateNode)
    {
		pCertificateNode = pCertificateList;
        BAILOUT;
    }
    pCertificateNode->pszSubjectName = pszSubjectName;

    pCertificateNode->pNext = pCertificateList;

error:
    return(pCertificateNode);
}
///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	FreeCertificateList
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		: 	IN PCERT_NODE pCertificateList
//	Return			: 	VOID
//
//	Description		: 	Frees node
//
//	Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
VOID
FreeCertificateList(
	IN PCERT_NODE pCertificateList
	)
{
    PCERT_NODE pTemp = NULL;

    pTemp = pCertificateList;

    while (pCertificateList)
    {
        pTemp = pCertificateList;

        pCertificateList = pCertificateList->pNext;

        if (pTemp)
        {
            FreeADsStr(pTemp->pszSubjectName);
            FreeADsMem(pTemp);
        }
    }
    return;
}
///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	GetCertificateName
//
//	Date of Creation	: 	10-10-2001
//
//	Parameters			:	IN CERT_NAME_BLOB * pCertNameBlob,
//							IN LPWSTR * ppszSubjectName
//	Return				:	DWORD
//
//	Description			: 	Gets certificate
//
//	Revision History	:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
GetCertificateName(
	IN CERT_NAME_BLOB * pCertNameBlob,
	IN LPWSTR * ppszSubjectName
	)
{
    DWORD dwSize = 0;
    DWORD dwError = 0;
    LPWSTR pszSubjectName = NULL;

    *ppszSubjectName = NULL;

    dwSize = CertNameToStrW(MY_ENCODING_TYPE_CERT, pCertNameBlob, CERT_X500_NAME_STR, NULL, dwSize );

    if (dwSize <= 1)
    {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32ERROR(dwError)
    }

    pszSubjectName = (LPWSTR)AllocADsMem((dwSize + 1)*sizeof(WCHAR));

    if (!pszSubjectName)
    {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32ERROR(dwError)
    }

    dwSize = CertNameToStrW(MY_ENCODING_TYPE_CERT, pCertNameBlob, CERT_X500_NAME_STR, pszSubjectName, dwSize );

    if(dwSize <= 1)
    {
        FreeADsMem(pszSubjectName);
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32ERROR(dwError)
    }

    *ppszSubjectName = pszSubjectName;

error:
    return(dwError);
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	FreeCertificatesList
//
//	Date of Creation	: 	10-10-2001
//
//	Parameters			:	IN INT_IPSEC_MM_AUTH_INFO * pAuthInfo,
//							IN DWORD dwNumCertificates
//	Return				: 	VOID
//
//	Description			: 	Frees list of certificates from pAuth
//
//	Revision History	:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
VOID
FreeCertificatesList(
	IN INT_IPSEC_MM_AUTH_INFO * pAuthInfo,
	IN DWORD dwNumCertificates
	)
{
    DWORD i = 0;
    INT_IPSEC_MM_AUTH_INFO * pThisAuthInfo = NULL;

    if (!pAuthInfo)
    {
        BAILOUT;
    }

    for (i = 0; i < dwNumCertificates; i++)
    {
        pThisAuthInfo = pAuthInfo + i;

        if (pThisAuthInfo->pAuthInfo)
        {
            FreeADsMem(pThisAuthInfo->pAuthInfo);
            pThisAuthInfo->pAuthInfo = NULL;
        }
    }
    FreeADsMem(pAuthInfo);

error:
    return;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function			:	FindCertificateInList
//
//	Date of Creation	: 	10-10-2001
//
//	Parameters			:	IN PCERT_NODE pCertificateList,
//							IN LPWSTR pszSubjectName
//	Return				: 	BOOL
//
//	Description			: 	Finds certificate in List
//
//	Revision History	:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL
FindCertificateInList(
	IN PCERT_NODE pCertificateList,
	IN LPWSTR pszSubjectName
	)
{
	BOOL bReturn = FALSE;

    while (pCertificateList) {

        if (!_wcsicmp(pCertificateList->pszSubjectName, pszSubjectName)) {

			bReturn = TRUE;
            BAILOUT;

        }

        pCertificateList = pCertificateList->pNext;

    }
error:
    return bReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	ListCertChainsInStore
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		:	IN 	HCERTSTORE 	hCertStore,
//						OUT INT_IPSEC_MM_AUTH_INFO 	** ppAuthInfo,
//						IN 	PDWORD pdwNumCertificates,
//						IN 	LPCSTR pszUsageIdentifier
//
//	Return			:	DWORD
//
//	Description		:	Lists certificate in store
//
//	Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ListCertChainsInStore(
	IN HCERTSTORE hCertStore,
	OUT INT_IPSEC_MM_AUTH_INFO ** ppAuthInfo,
	IN PDWORD pdwNumCertificates,
	IN LPCSTR pszUsageIdentifier
	)
{
    PCCERT_CHAIN_CONTEXT pPrevChain=NULL;
    PCCERT_CHAIN_CONTEXT pCertChain = NULL;
    DWORD dwError = 0;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindPara;
    CERT_NAME_BLOB *NameArray=NULL;
    DWORD ArraySize=0;
    PCERT_SIMPLE_CHAIN pSimpChain = NULL;
    PCERT_CHAIN_ELEMENT pRoot = NULL;
    DWORD dwRootIndex = 0;
    LPWSTR pszSubjectName = NULL;
    PCERT_NODE pCertificateList = NULL;
    PCERT_NODE pTemp = NULL;
    INT_IPSEC_MM_AUTH_INFO * pAuthInfo = NULL;
    INT_IPSEC_MM_AUTH_INFO * pCurrentAuth = NULL;
    DWORD i = 0;
    DWORD dwNumCertificates = 0;

	FindPara.pszUsageIdentifier = pszUsageIdentifier;
	FindPara.cbSize = sizeof(FindPara);
	FindPara.dwKeySpec = 0;
	FindPara.cIssuer = ArraySize;
	FindPara.rgIssuer = NameArray;
	FindPara.pfnFindCallback = NULL;
	FindPara.pvFindArg = NULL;

	while (TRUE)
	{

		pCertChain=CertFindChainInStore(hCertStore, X509_ASN_ENCODING,
						CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG |
						CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG |
						CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG |
						CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG,
						CERT_CHAIN_FIND_BY_ISSUER,
						&FindPara,
						pPrevChain
						);

	   	if (!pCertChain)
	   	{
			break;
		}

		pSimpChain=*(pCertChain->rgpChain);
		dwRootIndex=pSimpChain->cElement-1;
		pRoot=pSimpChain->rgpElement[dwRootIndex];

		dwError = GetCertificateName(
						&(pRoot->pCertContext->pCertInfo->Issuer),
						&pszSubjectName
						);
		BAIL_ON_WIN32ERROR(dwError)

		if (!FindCertificateInList(pCertificateList, pszSubjectName))
		{
			//
			// Append this CA to the list of CAs
			//
			pCertificateList = AppendCertificateNode( pCertificateList,	pszSubjectName );
			dwNumCertificates++;
		}
		else
		{
			//
			// This is a duplicate - certificate payloads will not accept dupes.
			//
			FreeADsStr(pszSubjectName);
		}
		pPrevChain = pCertChain;
	}

	if (!dwNumCertificates)
	{
		dwError = ERROR_NO_MORE_ITEMS;
		BAIL_ON_WIN32ERROR(dwError);
	}

	//
	// Allocate one more authinfo for pre-sharedkey.
	//
	pAuthInfo = (INT_IPSEC_MM_AUTH_INFO *)AllocADsMem(sizeof(INT_IPSEC_MM_AUTH_INFO) * (1 + dwNumCertificates));
	if (!pAuthInfo)
	{
		dwError = ERROR_OUTOFMEMORY;
		BAIL_ON_WIN32ERROR(dwError);
	}

	pTemp = pCertificateList;

	for (i = 0; i < dwNumCertificates; i++)
	{
		pCurrentAuth = pAuthInfo + i;

		dwError = CopyCertificateNode( pCurrentAuth, pTemp);
		BAIL_ON_WIN32ERROR(dwError);

		pTemp = pTemp->pNext;
	}

	*ppAuthInfo = pAuthInfo;
	*pdwNumCertificates = dwNumCertificates;

error:
    if (pCertificateList)
    {
        FreeCertificateList(pCertificateList);
    }

    if(dwError != 0)
    {
    	*ppAuthInfo = NULL;
    	*pdwNumCertificates = 0;
	}

    return(dwError);
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	CopyCertificate
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		:	IN PINT_IPSEC_MM_AUTH_INFO pCurrentAuth,
//						IN PINT_IPSEC_MM_AUTH_INFO pCurrentAuthFrom
//	Return			:	DWORD
//
//	Description		:	Copies certificate
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
CopyCertificate(
	IN PINT_IPSEC_MM_AUTH_INFO pCurrentAuth,
	IN PINT_IPSEC_MM_AUTH_INFO pCurrentAuthFrom
	)
{
	DWORD dwReturn = ERROR_SUCCESS;

    pCurrentAuth->AuthMethod = pCurrentAuthFrom->AuthMethod;

    dwReturn = EncodeCertificateName ((LPTSTR)pCurrentAuthFrom->pAuthInfo,
      									&pCurrentAuth->pAuthInfo,
      									&pCurrentAuth->dwAuthInfoSize);

    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	IsDomainMember
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		:	IN LPTSTR pszMachine
//
//	Return			:	BOOL
//
//	Description		: 	Checks for member of a domain(2k) or not of pszMachine.
//
//	Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL
IsDomainMember(
	IN LPTSTR pszMachine
	)
{
    BOOL bIsDomainMember = FALSE;

    do
	{
        NTSTATUS lStatus;
        LSA_HANDLE hLsa;
        LSA_OBJECT_ATTRIBUTES ObjectAttributes;
        LSA_UNICODE_STRING LsaString;

        // Initialize the object attributes to all zeroes.
        ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

	    if ((pszMachine == NULL) || !wcscmp(pszMachine, L"\0"))
	    {
	        LsaString.Buffer = NULL;
	        LsaString.Length = 0;
	        LsaString.MaximumLength = 0;
	    }
	    else
	    {
    		LsaString.Buffer = pszMachine;
    		LsaString.Length = (USHORT) (wcslen(pszMachine)* sizeof(WCHAR));
    		LsaString.MaximumLength = (USHORT) (wcslen(pszMachine) + 1) * sizeof(WCHAR);
		}

        // Attempt to open the policy.
        lStatus = LsaOpenPolicy( &LsaString, &ObjectAttributes,
            GENERIC_READ | POLICY_VIEW_LOCAL_INFORMATION, &hLsa );

        // Exit on error.
        if (lStatus)
        {
            break;
        }

        // Query domain information
        PPOLICY_PRIMARY_DOMAIN_INFO ppdiDomainInfo;
        lStatus = LsaQueryInformationPolicy( hLsa, PolicyPrimaryDomainInformation,
            (PVOID*)&ppdiDomainInfo );

        // Exit on error.
        if (lStatus)
        {
            break;
        }

        //
        // Check the Sid pointer, if it is null, the workstation is either a
        // stand-alone computer or a member of a workgroup.
        //
        if( ppdiDomainInfo->Sid )
        {
            bIsDomainMember = TRUE;
        }
		//
        // Clean up
        //
        if (NULL != ppdiDomainInfo)
            LsaFreeMemory( ppdiDomainInfo );

    } while (0);
    return bIsDomainMember;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	SmartDefaults
//
//	Date of Creation: 	10-10-2001
//
//	Parameters		:	IN PINT_IPSEC_MM_AUTH_INFO pAuthInfo,
//						IN LPTSTRT pszMachine,
//						IN DWORD * pdwNumberOfAuth,
//						IN BOOL bIsDomainPolicy
//
//	Return			:	DWORD
//
//	Description		:	Loads smart defaults of pszMachine in pAuthinfo.
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
SmartDefaults(
	IN PINT_IPSEC_MM_AUTH_INFO *ppAuthInfo,
	IN LPTSTR pszMachine,
	IN DWORD * pdwNumberOfAuth,
	IN BOOL bIsDomainPolicy
	)
{
	HCERTSTORE hCertStore = NULL;
	INT_IPSEC_MM_AUTH_INFO  * pAuthInfoIKE = NULL, * pAuthInfoOthers = NULL;
	PINT_IPSEC_MM_AUTH_INFO pAuthInfo = NULL;
	DWORD dwReturn = ERROR_SUCCESS, i=0;
	DWORD dwNumCertificatesIKE = 0, dwNumCertificatesOthers = 0;
	_TCHAR szMachine[MACHINE_NAME] = {0};

	if((pszMachine == NULL) || (!wcscmp(pszMachine, L"\0")))
	{
		wcscpy(szMachine, L"MY\0");
	}
	else
	{
		wcscpy(szMachine, pszMachine);
		wcscat(szMachine, L"\\MY\0");
	}

	if (bIsDomainPolicy || IsDomainMember(pszMachine))
	{
		hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0,
				CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE,
				szMachine);
		if(hCertStore)
		{
			//
			// First fill IKE intermediate
			//
			dwReturn = ListCertChainsInStore( hCertStore, &pAuthInfoIKE,
			&dwNumCertificatesIKE, szOID_IPSEC_KP_IKE_INTERMEDIATE );
			if(dwNumCertificatesIKE == 0)
			{
				dwReturn = ERROR_SUCCESS;
			}

			if(dwReturn == ERROR_SUCCESS)
			{
				dwReturn = ListCertsInStore( hCertStore, &pAuthInfoOthers, &dwNumCertificatesOthers);
			}
			if(dwNumCertificatesOthers == 0)
			{
				dwReturn = ERROR_SUCCESS;
			}
		}
		else
		{
			dwReturn = GetLastError();
			BAIL_ON_WIN32ERROR(dwReturn)
		}
	}

	*pdwNumberOfAuth = dwNumCertificatesIKE + dwNumCertificatesOthers + 1;
	pAuthInfo = new INT_IPSEC_MM_AUTH_INFO[(*pdwNumberOfAuth)];
	if(pAuthInfo == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_ON_WIN32ERROR(dwReturn)
	}
	ZeroMemory(pAuthInfo, sizeof(INT_IPSEC_MM_AUTH_INFO) * (*pdwNumberOfAuth));

	if(dwReturn == ERROR_SUCCESS)
	{
		for( i=0; i< dwNumCertificatesIKE; i++)
		{
			CopyCertificate( &pAuthInfo[i],	&pAuthInfoIKE[i]);
		}

		for( i=0; i< dwNumCertificatesOthers; i++)
		{
			CopyCertificate( &pAuthInfo[i+dwNumCertificatesIKE], &pAuthInfoOthers[i]);
		}

		pAuthInfo[(*pdwNumberOfAuth)-1].AuthMethod = IKE_SSPI;
		pAuthInfo[(*pdwNumberOfAuth)-1].dwAuthInfoSize = 0;
		pAuthInfo[(*pdwNumberOfAuth)-1].pAuthInfo = (LPBYTE)new _TCHAR[1];
		if(pAuthInfo[(*pdwNumberOfAuth)-1].pAuthInfo != NULL)
		{
			pAuthInfo[(*pdwNumberOfAuth)-1].pAuthInfo[0] = UNICODE_NULL;
		}
		else
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_ON_WIN32ERROR(dwReturn)
		}
	}

error:
	*ppAuthInfo =  pAuthInfo;

	if(pAuthInfoIKE)
		FreeADsMem(pAuthInfoIKE);
	if(pAuthInfoOthers)
		FreeADsMem(pAuthInfoOthers);

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\nshipsec.cpp ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: FrameWork/Nshipsec.cpp
//
// 	Purpose			: Netshell Frame Work for IPSec Implementation.
//
// 	Developers Name	: Bharat/Radhika
//
//	History			:
//
//  Date			Author		Comments
//  8-10-2001   	Bharat		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

//Object to cache the policy store handle
CNshPolStore g_NshPolStoreHandle;

//Object to cache the Policy,filterlist and negpol
CNshPolNegFilData g_NshPolNegFilData;

//Storage Location structure
STORAGELOCATION g_StorageLocation={ {0},{0},IPSEC_REGISTRY_PROVIDER};

HKEY g_hGlobalRegistryKey = HKEY_LOCAL_MACHINE;
HINSTANCE g_hModule = NULL;

PSTA_MM_AUTH_METHODS g_paRootca[MAX_ARGS] = {NULL};
_TCHAR g_wszLastErrorMessage[MAX_STR_LEN]  	= {0};

PIPSEC_QM_OFFER			g_pQmsec[IPSEC_MAX_QM_OFFERS] = {NULL};
PIPSEC_MM_OFFER			g_pMmsec[IPSEC_MAX_MM_OFFERS] = {NULL};

void *g_AllocPtr[MAX_ARGS]= {NULL};

_TCHAR g_szMachine[MAX_COMPUTERNAME_LENGTH + 1]			= {0};
_TCHAR *g_szDynamicMachine = NULL;

//
//These are the commands other than group...
//
CMD_ENTRY g_TopLevelStaticCommands[] =
{
    CREATE_CMD_ENTRY(STATIC_EXPORTPOLICY,		HandleStaticExportPolicy),
    CREATE_CMD_ENTRY(STATIC_IMPORTPOLICY,		HandleStaticImportPolicy),
    CREATE_CMD_ENTRY(STATIC_RESTOREDEFAULTS,	HandleStaticRestoreDefaults)
};
//
//These are the commands static add group...
//
CMD_ENTRY g_StaticAddCommands[] =
{
    CREATE_CMD_ENTRY(STATIC_ADD_FILTER,			HandleStaticAddFilter),
    CREATE_CMD_ENTRY(STATIC_ADD_FILTERLIST,		HandleStaticAddFilterList),
    CREATE_CMD_ENTRY(STATIC_ADD_FILTERACTIONS,	HandleStaticAddFilterActions),
    CREATE_CMD_ENTRY(STATIC_ADD_POLICY,			HandleStaticAddPolicy),
	CREATE_CMD_ENTRY(STATIC_ADD_RULE,			HandleStaticAddRule)
};
//
//These are the commands static set group...
//
CMD_ENTRY g_StaticSetCommands[] =
{
    CREATE_CMD_ENTRY(STATIC_SET_FILTERLIST,         HandleStaticSetFilterList),
    CREATE_CMD_ENTRY(STATIC_SET_FILTERACTIONS,      HandleStaticSetFilterActions),
    CREATE_CMD_ENTRY(STATIC_SET_POLICY,				HandleStaticSetPolicy),
	CREATE_CMD_ENTRY(STATIC_SET_RULE,               HandleStaticSetRule),
    CREATE_CMD_ENTRY(STATIC_SET_STORE	,           HandleStaticSetStore),
    CREATE_CMD_ENTRY(STATIC_SET_DEFAULTRULE,        HandleStaticSetDefaultRule),
	//CREATE_CMD_ENTRY(STATIC_SET_INTERACTIVE,        HandleStaticSetInteractive),
	// CREATE_CMD_ENTRY(STATIC_SET_BATCH,        		HandleStaticSetBatch)
};
//
//These are the commands static delete group...
//
CMD_ENTRY g_StaticDeleteCommands[] =
{
	CREATE_CMD_ENTRY(STATIC_DELETE_FILTER,              HandleStaticDeleteFilter),
	CREATE_CMD_ENTRY(STATIC_DELETE_FILTERLIST,          HandleStaticDeleteFilterList),
	CREATE_CMD_ENTRY(STATIC_DELETE_FILTERACTIONS,       HandleStaticDeleteFilterActions),
    CREATE_CMD_ENTRY(STATIC_DELETE_POLICY,              HandleStaticDeletePolicy),
	CREATE_CMD_ENTRY(STATIC_DELETE_RULE,                HandleStaticDeleteRule),
	CREATE_CMD_ENTRY(STATIC_DELETE_ALL,					HandleStaticDeleteAll)
};
//
//These are the commands static show group...
//
CMD_ENTRY g_StaticShowCommands[] =
{
	CREATE_CMD_ENTRY(STATIC_SHOW_FILTERLIST,          HandleStaticShowFilterList),
	CREATE_CMD_ENTRY(STATIC_SHOW_FILTERACTIONS,       HandleStaticShowFilterActions),
    CREATE_CMD_ENTRY(STATIC_SHOW_POLICY,              HandleStaticShowPolicy),
	CREATE_CMD_ENTRY(STATIC_SHOW_RULE,                HandleStaticShowRule),
    CREATE_CMD_ENTRY(STATIC_SHOW_ALL,                 HandleStaticShowAll),
    CREATE_CMD_ENTRY(STATIC_SHOW_STORE,               HandleStaticShowStore),
    CREATE_CMD_ENTRY(STATIC_SHOW_GPOASSIGNEDPOLICY,   HandleStaticShowGPOAssignedPolicy)
};

//
//Static Grouping commands...
//
CMD_GROUP_ENTRY g_StaticGroups[] =
{
	CREATE_CMD_GROUP_ENTRY(STATIC_GROUP_ADD,		g_StaticAddCommands),
    CREATE_CMD_GROUP_ENTRY(STATIC_GROUP_DELETE,		g_StaticDeleteCommands),
    CREATE_CMD_GROUP_ENTRY(STATIC_GROUP_SET,		g_StaticSetCommands),
    CREATE_CMD_GROUP_ENTRY(STATIC_GROUP_SHOW,		g_StaticShowCommands)
};
//
// Dynamic Add commands
//
CMD_ENTRY g_DynamicAddCommands[] =
{
	CREATE_CMD_ENTRY(DYNAMIC_ADD_QMPOLICY,		HandleDynamicAddQMPolicy),
	CREATE_CMD_ENTRY(DYNAMIC_ADD_MMPOLICY,		HandleDynamicAddMMPolicy),
	CREATE_CMD_ENTRY(DYNAMIC_ADD_RULE,			HandleDynamicAddRule)

};
//
// Dynamic Set commands
//
CMD_ENTRY g_DynamicSetCommands[] =
{
	CREATE_CMD_ENTRY(DYNAMIC_SET_QMPOLICY,		HandleDynamicSetQMPolicy),
	CREATE_CMD_ENTRY(DYNAMIC_SET_MMPOLICY,		HandleDynamicSetMMPolicy),
	CREATE_CMD_ENTRY(DYNAMIC_SET_CONFIG,		HandleDynamicSetConfig),
	CREATE_CMD_ENTRY(DYNAMIC_SET_RULE,			HandleDynamicSetRule)

};
//
// Dynamic Delete commands
//
CMD_ENTRY g_DynamicDeleteCommands[] =
{
	CREATE_CMD_ENTRY(DYNAMIC_DELETE_QMPOLICY,	HandleDynamicDeleteQMPolicy),
	CREATE_CMD_ENTRY(DYNAMIC_DELETE_MMPOLICY,	HandleDynamicDeleteMMPolicy),
	CREATE_CMD_ENTRY(DYNAMIC_DELETE_RULE,		HandleDynamicDeleteRule),
	CREATE_CMD_ENTRY(DYNAMIC_DELETE_ALL,		HandleDynamicDeleteAll)
};
//
// Dynamic Show commands
//
CMD_ENTRY g_DynamicShowCommands[] =
{
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_ALL,			HandleDynamicShowAll),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_MMPOLICY,		HandleDynamicShowMMPolicy),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_QMPOLICY,		HandleDynamicShowQMPolicy),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_MMFILTER,		HandleDynamicShowMMFilter),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_QMFILTER,		HandleDynamicShowQMFilter),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_STATS,		HandleDynamicShowStats),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_MMSAS,		HandleDynamicShowMMSas),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_QMSAS,		HandleDynamicShowQMSas),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_REGKEYS,		HandleDynamicShowRegKeys),
	CREATE_CMD_ENTRY(DYNAMIC_SHOW_RULE,			HandleDynamicShowRule)
};
//
//Dynamic Grouping commands...
//
CMD_GROUP_ENTRY g_DynamicGroups[] =
{
	CREATE_CMD_GROUP_ENTRY(DYNAMIC_GROUP_ADD,		g_DynamicAddCommands),
	CREATE_CMD_GROUP_ENTRY(DYNAMIC_GROUP_SET,       g_DynamicSetCommands),
	CREATE_CMD_GROUP_ENTRY(DYNAMIC_GROUP_DELETE,    g_DynamicDeleteCommands),
	CREATE_CMD_GROUP_ENTRY(DYNAMIC_GROUP_SHOW,      g_DynamicShowCommands)
};

DWORD 
IpsecConnectInternal(
    IN LPCWSTR  pwszMachine);

////////////////////////////////////////////////////////////////////////////////////////
//
//Function: GenericStopHelper
//
//Date of Creation: 10-8-2001
//
//Parameters: IN DWORD dwReserved
//
//Return: DWORD
//
//Description: This Function called by Netshell Frame work
//			 when Helper is stopped. This can be utilized for
//			 diagnostic purposes. To satisfy the frame work.
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI GenericStopHelper(IN DWORD dwReserved)
{
	return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	DllMain
//
//	Date of Creation: 	10-8-2001
//
//	Parameters		: 	IN HINSTANCE hinstDLL,  // handle to DLL module
//						IN DWORD fdwReason,     // reason for calling function
//						IN LPVOID lpvReserved   // reserved
//	Return			: 	BOOL
//
//	Description		: 	This is an optional method to entry into dll.
//						Here we can save the instance handle.
//
//	History			:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////////////

extern "C"
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,  	// handle to DLL module
    DWORD fdwReason,     	// reason for calling function
    PVOID pReserved )  		// reserved
{

    UNREFERENCED_PARAMETER(pReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
    {
		//save the HINSTANCE
		g_hModule = hinstDLL;
	}
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////
//
//Function: InitHelperDll
//
//Date of Creation: 10-8-2001
//
///Parameters: IN  DWORD   dwNetshVersion,
//			OUT PVOID	pReserved
//Return: DWORD
//
//Description: This Function called by Netshell Frame work
//			 at the start up. Registers the contexts.
//
//Revision History:
//
//  Date			Author		Comments
//
///////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI InitHelperDll(
					IN  DWORD   dwNetshVersion,
					OUT PVOID	pReserved
					)
{

	DWORD dwReturn = ERROR_SUCCESS;
    NS_HELPER_ATTRIBUTES MyAttributes;

    if(g_hModule == NULL)
    {
		_tprintf(_TEXT("\n nshipsec.dll handle not available, not registering the IPSec Helper.\n"));
		BAIL_OUT;
	}

	ZeroMemory(&MyAttributes, sizeof(MyAttributes));
	MyAttributes.dwVersion = IPSEC_HELPER_VERSION;

	MyAttributes.pfnStart  = StartHelpers;
	MyAttributes.pfnStop   = GenericStopHelper;
	//
	// Set the GUID of IPSec helper.
	//
	MyAttributes.guidHelper = g_IPSecGuid;
	//
	// Specify g_RootGuid as the parent helper to indicate
	// that any contexts registered by this helper will be top
	// level contexts.
	//
	dwReturn = RegisterHelper(&g_RootGuid,&MyAttributes);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
	//
	// Set the GUID for Static Sub context.
	//
	MyAttributes.guidHelper = g_StaticGuid;
	dwReturn = RegisterHelper(&g_IPSecGuid, &MyAttributes);

	if(dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
	//
	// Set the GUID of Dynamic Sub context...
	//
	MyAttributes.guidHelper = g_DynamicGuid;
	dwReturn = RegisterHelper(&g_IPSecGuid, &MyAttributes);

	IpsecConnectInternal(NULL);

error:

    return dwReturn;
}
///////////////////////////////////////////////////////////////////////////////////////
//
//Function: StartHelpers
//
//Date of Creation: 10-8-2001
//
//Parameters: 	IN CONST GUID * pguidParent,
//				IN DWORD        dwVersion
//Return: DWORD
//
//Description: This Function called by Netshell Frame work,
//			 	at the start up and as enters to every context.
//
//Revision History:
//
//  Date			Author		Comments
//
///////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI StartHelpers(
				IN CONST GUID * pguidParent,
				IN DWORD        dwVersion
				)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;
    NS_CONTEXT_ATTRIBUTES ContextAttributes;

    ZeroMemory(&ContextAttributes,sizeof(ContextAttributes));

    ContextAttributes.dwVersion = IPSEC_HELPER_VERSION;

    if (IsEqualGUID(*pguidParent, g_RootGuid))
    {
        ContextAttributes.dwFlags           = 0;
        ContextAttributes.dwVersion   		= 1;
        ContextAttributes.ulPriority        = DEFAULT_CONTEXT_PRIORITY;
        ContextAttributes.pwszContext       = TOKEN_IPSEC;
        ContextAttributes.guidHelper        = g_IPSecGuid;
        ContextAttributes.ulNumTopCmds      = 0;
        ContextAttributes.pTopCmds          = NULL;
        ContextAttributes.ulNumGroups       = 0;
        ContextAttributes.pCmdGroups        = NULL;
        ContextAttributes.pfnCommitFn       = NULL;
        ContextAttributes.pfnConnectFn      = NULL;
        ContextAttributes.pfnDumpFn         = NULL;
        ContextAttributes.pfnOsVersionCheck = CheckOsVersion;
        //
        //Registering IPSec Main Context...
        //
        dwReturn = RegisterContext(&ContextAttributes);
    }
    else if (IsEqualGUID(*pguidParent, g_IPSecGuid))
    {
		//
		//Registering SubContexts under IPSec Main Context...
		//
        ContextAttributes.dwFlags           = 0;
        ContextAttributes.dwVersion   		= 1;
        ContextAttributes.ulPriority        = DEFAULT_CONTEXT_PRIORITY;
        ContextAttributes.pwszContext       = TOKEN_STATIC;
        ContextAttributes.guidHelper        = g_StaticGuid;
        ContextAttributes.ulNumTopCmds      = sizeof(g_TopLevelStaticCommands)/sizeof(CMD_ENTRY);
        ContextAttributes.pTopCmds          = (CMD_ENTRY (*)[])g_TopLevelStaticCommands;
        ContextAttributes.ulNumGroups       = sizeof(g_StaticGroups)/sizeof(CMD_GROUP_ENTRY);
        ContextAttributes.pCmdGroups        = (CMD_GROUP_ENTRY (*)[])&g_StaticGroups;
        ContextAttributes.pfnCommitFn       = NULL;
        ContextAttributes.pfnConnectFn      = IpsecConnect;
        ContextAttributes.pfnOsVersionCheck = CheckOsVersion;
        ContextAttributes.pfnDumpFn         = NULL;
		//
		//Registering Static SubContext
		//...
        dwReturn = RegisterContext(&ContextAttributes);
        //even if static sub context not succeeds,
        //proceed to register the dynamic context

        ContextAttributes.dwFlags           = 0;
        ContextAttributes.dwVersion   		= 1;
		ContextAttributes.ulPriority        = DEFAULT_CONTEXT_PRIORITY;
		ContextAttributes.pwszContext       = TOKEN_DYNAMIC;
		ContextAttributes.guidHelper        = g_DynamicGuid;
		ContextAttributes.ulNumTopCmds      = sizeof(g_DynamicGroups)/sizeof(CMD_ENTRY);
		ContextAttributes.pTopCmds          = (CMD_ENTRY (*)[])g_DynamicGroups;
		ContextAttributes.ulNumGroups       = sizeof(g_DynamicGroups)/sizeof(CMD_GROUP_ENTRY);
		ContextAttributes.pCmdGroups        = (CMD_GROUP_ENTRY (*)[])&g_DynamicGroups;
		ContextAttributes.pfnCommitFn       = NULL;
		ContextAttributes.pfnConnectFn      = IpsecConnect;
        ContextAttributes.pfnOsVersionCheck = CheckOsVersion;
        ContextAttributes.pfnDumpFn         = NULL;
		//
        //Registering Dynamic Sub context...
        //
        dwReturn = RegisterContext(&ContextAttributes);
    }
    return dwReturn;
}

DWORD 
IpsecConnectInternal(
    IN LPCWSTR  pwszMachine)
{
    DWORD dwReturn, dwReturn2;

	if(pwszMachine)
	{
		_tcsncpy(g_szMachine, pwszMachine, MAX_COMPUTERNAME_LENGTH);
		g_szMachine[MAX_COMPUTERNAME_LENGTH] = '\0';
	}
	else
	{
		g_szMachine[0] = '\0';
	}
	g_szDynamicMachine = (_TCHAR*)g_szMachine;

    // Have the static and dynamic contexts connect to the specified 
    // machine.  Return an error if either attempt fails.
    //
	dwReturn = ConnectStaticMachine(g_szMachine, g_StorageLocation.dwLocation);
	dwReturn2 = ConnectDynamicMachine(g_szDynamicMachine);
	dwReturn = (dwReturn) ? dwReturn : dwReturn2;

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
//Function: IpsecConnect
//
//Date of Creation: October 4th 2001
//
//Parameters: IN  LPCWSTR  pwszMachine
//
//Return: DWORD
//
//Description: Displays Win32 Error message in locale language for
//				given Win 32Error Code.
//
//Revision History:
//
//  Date			Author		Comments
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
IpsecConnect( IN  LPCWSTR  pwszMachine )
{
	DWORD dwReturn = ERROR_SUCCESS, dwReturn2 = ERROR_SUCCESS;
	BOOL bSetMachine = FALSE;
	
	if((pwszMachine != NULL) && (g_szMachine[0] == '\0'))
	{
		bSetMachine = TRUE;
	}

	if((pwszMachine == NULL) && (g_szMachine[0] != '\0'))
	{
		bSetMachine = TRUE;
	}

	if((pwszMachine != NULL) && (g_szMachine[0] != '\0'))
	{
		if(_tcscmp(pwszMachine, g_szMachine) != 0)
		{
			bSetMachine = TRUE;
		}
	}

	if(bSetMachine)
	{
	    dwReturn = IpsecConnectInternal( pwszMachine );
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//Function: PrintErrorMessage()
//
//Date of Creation: October 4th 2001
//
//Parameters:
//			IN DWORD dwErrorType,
//			IN DWORD dwWin32ErrorCode,
//			IN DWORD dwIpsecErrorCode,
//			...
//
//
//Return: DWORD
//
//Description: Prints the IPSEC and WIN32 error messages.
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////

void PrintErrorMessage(IN DWORD dwErrorType,
					   IN DWORD dwWin32ErrorCode,
					   IN DWORD dwIpsecErrorCode,
					   ...)
{
	va_list arg_ptr;

	BOOL bFound			= FALSE;
	DWORD i,dwStatus	= 0;
	DWORD dwRcIndex		= 0xFFFF;
	LPVOID szWin32Msg	= NULL;
	DWORD dwMaxErrMsg	= sizeof(ERROR_RC)/sizeof(ERROR_TO_RC);

	for(i=0;i<dwMaxErrMsg;i++)
	{
		if (dwIpsecErrorCode == ERROR_RC[i].dwErrCode)
		{
			bFound		= TRUE;
			dwRcIndex	= ERROR_RC[i].dwRcCode;
			break;
		}

	}

	if(dwWin32ErrorCode == ERROR_OUTOFMEMORY)
	{
		PrintMessageFromModule(g_hModule,ERR_OUTOF_MEMORY);
		BAIL_OUT;
	}

	switch (dwErrorType)
 	{
		case WIN32_ERR	:

				dwStatus = FormatMessageW(
						FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
						NULL,
						dwWin32ErrorCode,
						0,						// Default country ID.
						(LPWSTR)&szWin32Msg,
						0,
						NULL);

				if (dwStatus)
				{
					PrintMessageFromModule(g_hModule,ERR_WIN32_FMT,dwWin32ErrorCode,szWin32Msg);
					UpdateGetLastError((LPWSTR)szWin32Msg);
				}
				else
				{
					UpdateGetLastError(_TEXT("ERR Win32\n"));
					PrintMessageFromModule(g_hModule,ERR_WIN32_INVALID_WIN32CODE,dwWin32ErrorCode);
				}

				break;
		case IPSEC_ERR	:
				if (!bFound)
				{
					PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
				}
				else
				{
					PrintMessageFromModule(g_hModule,ERR_IPSEC_FMT,dwIpsecErrorCode);
					va_start(arg_ptr,dwIpsecErrorCode);
					PrintErrorMessageFromModule(g_hModule,dwRcIndex,&arg_ptr);
					va_end(arg_ptr);
				}
				break;
		default			:
			break;
	}

	if(szWin32Msg != NULL)
	{
		LocalFree(szWin32Msg);
	}

error:
	return;
}

//////////////////////////////////////////////////////////////////////////////
//
//Function: DisplayErrorMessage()
//
//Date of Creation:October 4th 2001
//
//Parameters:
//		IN  LPCWSTR  pwszFormat,
//		IN  va_list *parglist
//
//
//Return: DWORD
//
//Description:Displays error message and updates the last error
//
//Revision History:
//
// 	Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
DisplayErrorMessage(
		IN  LPCWSTR  pwszFormat,
		IN  va_list *parglist
		)
{
    DWORD        dwMsgLen = 0;
    LPWSTR       pwszOutput = NULL;

    do
    {
        dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                                  pwszFormat,
                                  0,
                                  0L,
                                  (LPWSTR)&pwszOutput,
                                  0,
                                  parglist);

        if((dwMsgLen == 0) || (pwszOutput == NULL))
        {
         	BAIL_OUT;
        }
        PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_PADD, pwszOutput);
        UpdateGetLastError(pwszOutput);
    } while ( FALSE );

    if ( pwszOutput)
    {
		LocalFree( pwszOutput );
	}

error:
    return dwMsgLen;
}
//////////////////////////////////////////////////////////////////////////////
//
//Function: PrintErrorMessageFromModule()
//
//Date of Creation: October 4th 2001
//
//Parameters:
//    IN  HANDLE  hModule,
//    IN  DWORD   dwMsgId,
//    IN  va_list *parglist
//
//
//Return: DWORD
//
//Description: Prints the error message
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////
DWORD
PrintErrorMessageFromModule(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    IN  va_list *parglist
    )
{
    WCHAR rgwcInput[MAX_STR_LEN + 1] = {0};

    if ( !LoadStringW(g_hModule,
                      dwMsgId,
                      rgwcInput,
                      MAX_STR_LEN) )
    {
        return 0;
    }
    return DisplayErrorMessage(rgwcInput, parglist);
}
//////////////////////////////////////////////////////////////////////////////
//
//Function: UpdateGetLastError()
//
//Date of Creation: October 4th 2001
//
//Parameters:
//    IN  LPWSTR pwszOutput
//
//Return: VOID
//
//Description:	Updates the contents of the global string for GetLastErrorMessage
//              If the operation was success, empty string to be passed to the
// 				UpdateGetLastError function.
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////
VOID
UpdateGetLastError(LPWSTR pwszOutput)
{
	if (pwszOutput)
	{
		_tcsncpy(g_wszLastErrorMessage,pwszOutput,MAX_STR_LEN-1);
	}
	else
	{
		_tcsncpy(g_wszLastErrorMessage,_TEXT(""), _tcslen(_TEXT(""))+1);						// Operation Ok.
	}

}
//////////////////////////////////////////////////////////////////////////////
//
//Function: GetIpsecLastError()
//
//Date of Creation: October 4th 2001
//
//Parameters:
//    IN  VOID
//
//Return: LPWSTR
//
//Description:	Returns the error message for the last operation, If the last operation
//				was success returns NULL
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
GetIpsecLastError(VOID)
{
	LPTSTR wszLastErrorMessage = NULL;

	if(_tcscmp(g_wszLastErrorMessage, _TEXT("")) != 0)
	{
		wszLastErrorMessage = g_wszLastErrorMessage;
	}

	return (LPCWSTR)wszLastErrorMessage;
}
//////////////////////////////////////////////////////////////////////////////
//
//Function: CheckOsVersion
//
//Date of Creation: 10-8-2001
//
//Parameters: IN  UINT     CIMOSType,
//			IN  UINT     CIMOSProductSuite,
//			IN  LPCWSTR  CIMOSVersion,
//			IN  LPCWSTR  CIMOSBuildNumber,
//			IN  LPCWSTR  CIMServicePackMajorVersion,
//			IN  LPCWSTR  CIMServicePackMinorVersion,
//			IN  UINT     CIMProcessorArchitecture,
//			IN  DWORD    dwReserved
//Return: BOOL
//
//Description: 	This Function called by Netshell Frame work
//			 	for every command.  This can be utilized for
//			 	diagnostic purposes. To satisfy the frame work.
//
//Revision History:
//
//  Date			Author		Comments
//
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI CheckOsVersion(
					IN  UINT     CIMOSType,
					IN  UINT     CIMOSProductSuite,
					IN  LPCWSTR  CIMOSVersion,
					IN  LPCWSTR  CIMOSBuildNumber,
					IN  LPCWSTR  CIMServicePackMajorVersion,
					IN  LPCWSTR  CIMServicePackMinorVersion,
					IN  UINT     CIMProcessorArchitecture,
					IN  DWORD    dwReserved
					)
{
	DWORD dwStatus =0;
	DWORD dwBuildNumber=0;
	static BOOL bDisplayOnce = FALSE;

	dwBuildNumber = _ttol(CIMOSBuildNumber);

	if (dwStatus)
		if(dwBuildNumber < NSHIPSEC_BUILD_NUMBER)
		{
			if (!bDisplayOnce)
			{
				PrintMessageFromModule(g_hModule,NSHIPSEC_CHECK,NSHIPSEC_BUILD_NUMBER);
				bDisplayOnce = TRUE;
			}
			return FALSE;
		}
 	return TRUE;
}


VOID
CleanupAuthMethod(
	PSTA_AUTH_METHODS *ppAuthMethod,
	BOOL bIsArray
	)
{
	if (ppAuthMethod && *ppAuthMethod)
	{
		CleanupMMAuthMethod(&((*ppAuthMethod)->pAuthMethodInfo), bIsArray);
		delete *ppAuthMethod;
		*ppAuthMethod = NULL;
	}
}


VOID
CleanupMMAuthMethod(
	PSTA_MM_AUTH_METHODS *ppMMAuth,
	BOOL bIsArray
	)
{
	if (*ppMMAuth)
	{
		if (bIsArray)
		{
			delete [] *ppMMAuth;
		}
		else
		{
			if ((*ppMMAuth)->pAuthenticationInfo)
			{
				if ((*ppMMAuth)->pAuthenticationInfo->pAuthInfo)
				{
					delete (*ppMMAuth)->pAuthenticationInfo->pAuthInfo;
				}
				delete (*ppMMAuth)->pAuthenticationInfo;
			}
			delete *ppMMAuth;
		}
		*ppMMAuth = NULL;
	}
}

VOID
CleanupAuthData(
	PSTA_AUTH_METHODS *ppKerbAuth,
	PSTA_AUTH_METHODS *ppPskAuth,
	PSTA_MM_AUTH_METHODS *ppRootcaMMAuth
	)
{
	CleanupAuthMethod(ppKerbAuth);
	CleanupAuthMethod(ppPskAuth);

	if (ppRootcaMMAuth)
	{
		CleanupMMAuthMethod(ppRootcaMMAuth, TRUE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\nshipsec.h ===
////////////////////////////////////////////////////////////////////////
//
// 	Module			: FrameWork/Nshipsec.h
//
// 	Purpose			: Netshell Frame Work for IPSec Implementation.
//
// 	Developers Name	: Bharat/Radhika
//
//	History			:
//
//  Date			Author		Comments
//  8-10-2001   	Radhika		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#ifndef _NSHIPSEC_H_
#define _NSHIPSEC_H_

#define UNICODE

#define BAIL_OUT
#include "Nsu.h"
#undef BAIL_OUT

#include <winuser.h>
#include <math.h>
#include <tchar.h>
#include <netsh.h>
#include <stdio.h>
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <lm.h>
#include <assert.h>
#include <objbase.h>
#include <ipexport.h>
#include <wincrypt.h>
#include <dsgetdc.h>
#include <userenv.h>
#include <winldap.h>
#include <malloc.h>

extern "C" {
#include <rpc.h>
#include <winldap.h>
#include <time.h>
#include <winipsec.h>
#include <ipsec.h>
#include <oakdefs.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include <security.h>
#include "polstore2.h"
}
#include <ipsecshr.h>

#define MAXCOMPUTERNAMELEN	(1024)

typedef struct _STORAGELOCATION
{
   TCHAR      pszMachineName[MAXCOMPUTERNAMELEN];
   TCHAR      pszDomainName[MAXCOMPUTERNAMELEN];
   DWORD      dwLocation;
} STORAGELOCATION, *PSTORAGELOCATION;

//ipsec includes
#include "resource.h"
#include "nshpa.h"
#include "parser.h"
#include "parser_static.h"
#include "parser_dynamic.h"
#include "parser_util.h"
#include "staticshowutils.h"
#include "staticmisc.h"
#include "staticshow.h"
#include "staticshowlist.h"
#include "staticshowtable.h"
#include "staticset.h"
#include "staticadd.h"
#include "staticdelete.h"
#include "staticsetutils.h"
#include "dynamicdelete.h"
#include "dynamicshow.h"
#include "dynamicadd.h"
#include "nshcache.h"


#define NSHIPSEC_BUILD_NUMBER					(3588)

// Registry Keys
#define ENABLE_DIAG 							_TEXT("EnableDiagnostics")
#define ENABLE_LOGINT 							_TEXT("LogInterval")
#define ENABLE_EXEMPT 							_TEXT("NoDefaultExempt")
#define BOOTMODEKEY								_TEXT("OperationMode")
#define BOOTEXEMPTKEY							_TEXT("BootExemptList")

#define ERROR_NO_DISPLAY						(DWORD)(-1)

#define BAIL_OUT       				  			goto error

#define CERT_TEXT_SIZE   						(8192)

//global definitions...
#define IPSEC_HELPER_VERSION					(1)
#define POTF_MAX_STRLEN 						(256)
#define STR_ADDRLEN			 					(128)

//error masks
#define WIN32_AUTH_BEING_USED					(13012)

const TCHAR  DENIAL_TOKENS[]       				= _T("Nn");
const TCHAR  ACCEPTANCE_TOKENS[]       			= _T("Yy");

const GUID g_IPSecGuid 		=   {0xf7e0bc27, 0xba6e, 0x4145, {0xa1, 0x23, 0x01, 0x2f, 0x19, 0x22, 0xf3, 0xf1}};
const GUID g_StaticGuid     =   {0xf7e0bc28, 0xba6e, 0x4145, {0xa1, 0x23, 0x01, 0x2f, 0x19, 0x22, 0xf3, 0xf1}};
const GUID g_DynamicGuid	=   {0xf7e0bc29, 0xba6e, 0x4145, {0xa1, 0x23, 0x01, 0x2f, 0x19, 0x22, 0xf3, 0xf1}};
const GUID g_RootGuid       =   NETSH_ROOT_GUID;

//
// Function prototypes.Forward declarations
//

//
// Static Functions Prototypes
//
FN_HANDLE_CMD  HandleStaticAddPolicy;
FN_HANDLE_CMD  HandleStaticAddFilterList;
FN_HANDLE_CMD  HandleStaticAddFilter;
FN_HANDLE_CMD  HandleStaticAddFilterActions;
FN_HANDLE_CMD  HandleStaticAddRule;

FN_HANDLE_CMD  HandleStaticSetPolicy;
FN_HANDLE_CMD  HandleStaticSetFilterList;
FN_HANDLE_CMD  HandleStaticSetFilterActions;
FN_HANDLE_CMD  HandleStaticSetRule;
FN_HANDLE_CMD  HandleStaticSetStore;
FN_HANDLE_CMD  HandleStaticSetDefaultRule;
FN_HANDLE_CMD  HandleStaticSetInteractive;
FN_HANDLE_CMD  HandleStaticSetBatch;

FN_HANDLE_CMD  HandleStaticDeletePolicy;
FN_HANDLE_CMD  HandleStaticDeleteFilterList;
FN_HANDLE_CMD  HandleStaticDeleteFilter;
FN_HANDLE_CMD  HandleStaticDeleteFilterActions;
FN_HANDLE_CMD  HandleStaticDeleteRule;
FN_HANDLE_CMD  HandleStaticDeleteAll;

FN_HANDLE_CMD  HandleStaticShowPolicy;
FN_HANDLE_CMD  HandleStaticShowFilterList;
FN_HANDLE_CMD  HandleStaticShowFilterActions;
FN_HANDLE_CMD  HandleStaticShowRule;
FN_HANDLE_CMD  HandleStaticShowAll;
FN_HANDLE_CMD  HandleStaticShowStore;
FN_HANDLE_CMD  HandleStaticShowGPOAssignedPolicy;

FN_HANDLE_CMD  HandleStaticExportPolicy;
FN_HANDLE_CMD  HandleStaticImportPolicy;
FN_HANDLE_CMD  HandleStaticRestoreDefaults;
//
//Dynamic Function Prototypes...
//
FN_HANDLE_CMD  	HandleDynamicAddQMPolicy;
FN_HANDLE_CMD  	HandleDynamicAddMMPolicy;
FN_HANDLE_CMD  	HandleDynamicAddRule;

FN_HANDLE_CMD  HandleDynamicSetQMPolicy;
FN_HANDLE_CMD  HandleDynamicSetMMPolicy;
FN_HANDLE_CMD  HandleDynamicSetConfig;
FN_HANDLE_CMD  HandleDynamicSetRule;

FN_HANDLE_CMD  HandleDynamicDeleteQMPolicy;
FN_HANDLE_CMD  HandleDynamicDeleteMMPolicy;
FN_HANDLE_CMD  HandleDynamicDeleteRule;
FN_HANDLE_CMD  HandleDynamicDeleteAll;

FN_HANDLE_CMD  HandleDynamicShowMMPolicy;
FN_HANDLE_CMD  HandleDynamicShowQMPolicy;
FN_HANDLE_CMD  HandleDynamicShowMMFilter;
FN_HANDLE_CMD  HandleDynamicShowQMFilter;
FN_HANDLE_CMD  HandleDynamicShowStats;
FN_HANDLE_CMD  HandleDynamicShowMMSas;
FN_HANDLE_CMD  HandleDynamicShowQMSas;
FN_HANDLE_CMD  HandleDynamicShowRegKeys;
FN_HANDLE_CMD  HandleDynamicShowRule;
FN_HANDLE_CMD  HandleDynamicShowAll;


//
// Error Code Ids
//
#define ERRCODE_INVALID_NUM_ARGS								1000
#define ERRCODE_INVALID_ARGS									1001

#define ERRCODE_NO_PREKEY										1002
#define ERRCODE_AUTH_INVALID			    					1003
#define ERRCODE_ENCODE_FAILED									1004
#define ERRCODE_MULTIPLE_KERBPRE		    					1005

#define ERRCODE_INVALID_INDEX									1007
#define ERRCODE_INVALID_ARG										1008
#define ERRCODE_DNSLOOKUP_FAILED								1009
#define ERRCODE_INVALID_ADDR									1010
#define ERRCODE_INVALID_TAG										1011
#define ERRCODE_TAG_ALREADY_PRESENT								1012
#define ERRCODE_GPONAME_ARG_NEEDED								1013
#define ERRCODE_NAME_GUID_NEEDED								1014
#define ERRCODE_TAG_NEEDED										1015
#define ERRCODE_ARG_INVALID										1016
#define ERRCODE_PREFIX_INVALID									1017
#define ERRCODE_MASK_INVALID									1018
#define ERRCODE_NULL_STRING										1019
#define ERRCODE_SECLIFE_INVALID									1020
#define ERRCODE_KBLIFE_INVALID									1021
#define ERRCODE_P2REKEY_INVALID									1022
#define ERRCODE_HASH_INVALID									1023
#define ERRCODE_ESP_INCOMPLETE									1024
#define ERRCODE_DUPALG_INVALID									1025
#define ERRCODE_NONE_INVALID									1026
#define ERRCODE_IPSECPROT_INVALID								1027
#define ERRCODE_MAX_OFFERS										1028
#define ERRCODE_AHESP_INVALID									1029
#define ERRCODE_KS_INVALID										1030
#define ERRCODE_INVALID_P1GROUP									1031
#define ERRCODE_P1GROUP_MISSING									1032
#define ERRCODE_MMOFFER_INVALID									1033
#define ERRCODE_FILETYPE_INVALID								1034
#define ERRCODE_ADDR_ALL_INVALID								1035
#define ERRCODE_PORT_INVALID									1036
#define ERRCODE_MAXARGS_CROSSED									1037
#define ERRCODE_QMOFFER_INVALID									1038
#define ERRCODE_INVALID_TUNNEL									1039
#define ERRCODE_PROTO_INVALID									1040
#define ERRCODE_INVALID_MASK									1041
#define ERRCODE_INVALID_MACHINE									1042
#define ERRCODE_TOO_MANY_EXEMPTS								1043

//
// Error codes for static commands
//
#define	ERRCODE_ADD_STATIC_POLICY_MISSING_POL_NAME  			5001
#define	ERRCODE_ADD_STATIC_POLICY_POLL_INTERVAL_MSG             5002
#define	ERRCODE_ADD_STATIC_POLICY_QMPERMM_MSG                   5003
#define	ERRCODE_ADD_STATIC_POLICY_LIFETIME_LIMIT_MSG           	5004

#define	ERRCODE_ADD_STATIC_CRNEWPOL_1                       	5005
#define	ERRCODE_ADD_STATIC_CRNEWPOL_2                       	5006
#define	ERRCODE_ADD_STATIC_CRNEWPOL_4                       	5007
#define	ERRCODE_ADD_STATIC_CRNEWPOL_5                       	5008

//Add Filterlist
#define	ERRCODE_ADD_STATIC_FILTERLIST_1        					5009
#define	ERRCODE_ADD_STATIC_FILTERLIST_2                     	5010
#define	ERRCODE_ADD_STATIC_FILTERLIST_3 						5011
#define	ERRCODE_ADD_STATIC_FILTERLIST_5							5012

//Add Filter
#define	ERRCODE_ADD_STATIC_FILTER_2                         	5013

//Add FilterAction
#define	ERRCODE_ADD_STATIC_FILTERACTION_1       				5014
#define	ERRCODE_ADD_STATIC_FILTERACTION_2                   	5015
#define	ERRCODE_ADD_STATIC_FILTERACTION_4   					5016

//Add Rule
#define	ERRCODE_ADD_STATIC_RULE_1  								5017
#define	ERRCODE_ADD_STATIC_RULE_2                  				5018
#define	ERRCODE_ADD_STATIC_RULE_3                  				5019
#define	ERRCODE_ADD_STATIC_RULE_4                  				5020
#define	ERRCODE_ADD_STATIC_RULE_5                  				5021
#define	ERRCODE_ADD_STATIC_RULE_6                  				5022
#define	ERRCODE_ADD_STATIC_RULE_7 								5023
#define	ERRCODE_ADD_STATIC_RULE_CREATING_INFO					5024
#define	ERRCODE_ADD_STATIC_RULE_10								5025
#define	ERRCODE_ADD_STATIC_RULE_11								5026

#define	ERRCODE_ADD_STATIC_FILTER_1                         	5027
#define	ERRCODE_ADD_STATIC_FILTER_4								5028

//Set Policy
#define	ERRCODE_SET_STATIC_POLICY_3           					5029
#define	ERRCODE_SET_STATIC_POLICY_4                         	5030
#define	ERRCODE_SET_STATIC_POLICY_5                         	5031
#define	ERRCODE_SET_STATIC_POLICY_INVALID_CERTMAP_MSG           5032
#define	ERRCODE_SET_STATIC_POLICY_CERTMAP_YES_STR               5033

//set filterlist
#define	ERRCODE_SET_STATIC_FILTERLIST_1                     	5034
#define	ERRCODE_SET_STATIC_FILTERLIST_3                     	5035

//set filter action
#define	ERRCODE_SET_STATIC_FILTERACTION_1                   	5036
#define	ERRCODE_SET_STATIC_FILTERACTION_3                   	5037

//set rule
#define	ERRCODE_SET_STATIC_RULE_1                           	5038
#define	ERRCODE_SET_STATIC_RULE_2                           	5039

//set def rule
#define	ERRCODE_SET_STATIC_DEFRULE_2    						5040

#define	ERRCODE_MISC_STATIC_IMPORTPOLICY_1                    	5041
#define	ERRCODE_MISC_STATIC_IMPORTPOLICY_3                    	5042
#define	ERRCODE_MISC_STATIC_IMPORTPOLICY_4                    	5043

//export policy
#define	ERRCODE_MISC_STATIC_EXPORTPOLICY_2       				5044

#define ERRCODE_MISC_STATIC_RESDEFRULE_2                    	5045

#define ERRCODE_DEL_STATIC_POLICY_3                            	5046
#define ERRCODE_SHW_STATIC_POLICY_2                            	5047

//delete filterlist
#define ERRCODE_DEL_STATIC_FILTERLIST_2                        	5048

//delete filter
#define ERRCODE_SHW_STATIC_TAB_PRTALLFL_3                       5049
#define ERRCODE_DEL_STATIC_FILTER_1                             5050
#define ERRCODE_DEL_STATIC_FILTER_2                             5051

//delete filter action
#define ERRCODE_DEL_STATIC_FILTERACTION_2                      	5052
#define ERRCODE_SHW_STATIC_TAB_PRTALLFA_FA_COUNT_LIST           5053

//delete rule
#define ERRCODE_DEL_STATIC_RULE_3                            	5054
#define ERRCODE_DEL_STATIC_RULE_4                           	5055
#define ERRCODE_DEL_STATIC_RULE_5                            	5056
#define ERRCODE_DEL_STATIC_RULE_10                           	5057
#define ERRCODE_SHW_STATIC_RULE_3                            	5058
#define ERRCODE_SHW_STATIC_RULE_4                            	5059

#define ERRCODE_SHW_STATIC_LIST_POLICY_COUNT                    5060
#define ERRCODE_SHW_STATIC_TAB_POLICY_3                         5061
#define ERRCODE_SHW_STATIC_TAB_POLICY_4                         5062
#define ERRCODE_SHW_STATIC_TAB_POLICY_5                         5063

//show filterl
#define ERRCODE_SHW_STATIC_TAB_FILTERLIST_3                     5064
#define ERRCODE_SHW_STATIC_TAB_RULE_3                           5065

//show assigned gpo policy
#define ERRCODE_SHW_STATIC_TAB_ASSIGNPOL_2                      5066

#define ERRCODE_SHW_STATIC_TAB_PRTALLFL_2                       5067
#define ERRCODE_SHW_STATIC_TAB_PRTALLFA_6                       5068
#define	ERRCODE_ADD_STATIC_FILTERACTION_3                   	5069

#define	ERRCODE_ADD_STATIC_RULE_UPDATING_INFO					5070

#define	ERRCODE_NO_POLICY			        					5072
#define ERRCODE_FAILED_POLSTORE_OPEN							5073
#define	ERRCODE_NO_FILTER_ACTION	        					5074
#define	ERRCODE_NO_FILTER_LIST		        					5075
#define	ERRCODE_INVALID_POLICY_NAME	        					5076
#define	ERRCODE_SET_STATIC_RULE_3	        					5077
#define	ERRCODE_SET_STATIC_RULE_NEW_RULE_QUERY	        		5078
#define	ERRCODE_SET_STATIC_RULE_5	        					5079
#define	ERRCODE_ADD_STATIC_RULE_SUCCESS_MSG 					5080
#define	ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE3				5081
#define	ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE4				5082
#define	ERRCODE_SET_STATIC_POLICY_CERT_MAP_NO_STR               5083
#define	ERRCODE_ADD_STATIC_FILTER_3                         	5084

#define	ERRCODE_ADD_STATIC_FILTER_6                         	5085
#define	ERRCODE_ADD_STATIC_FILTER_7                         	5086
#define	ERRCODE_ADD_STATIC_FILTER_8                         	5087
#define	ERRCODE_ADD_STATIC_FILTER_9                         	5088
#define	ERRCODE_ADD_STATIC_FILTER_10                        	5089
#define	ERRCODE_ADD_STATIC_FILTER_11                        	5090
#define	ERRCODE_ADD_STATIC_FILTER_12                        	5091

#define	ERRCODE_SET_STATIC_POL_NEWNAME	                      	5092
#define	ERRCODE_SET_STATIC_RULE_NEWNAME	                      	5093
#define	ERRCODE_SET_STATIC_FL_NEWNAME	                      	5094
#define	ERRCODE_SET_STATIC_FA_NEWNAME	                      	5095
#define	ERRCODE_ADD_STATIC_RULE_INVALID_TUNNEL	                5096
#define ERRCODE_MISC_STATIC_RESDEFRULE_3                    	5097
#define ERRCODE_SET_STATIC_SHOW_RULE_TYPE                       5098
#define ERRCODE_DEL_STATIC_FILTERLIST_ALL_FL_DEL_QUERY          5099
#define ERRCODE_DEL_STATIC_FILTERACTION_ALL_FA_DEL_QUERY        5100
#define ERRCODE_ADD_RULE_INVALID_TUNNEL                      	5101

#define ERRCODE_STATIC_INTERNAL_ERROR							5102
#define ERRCODE_SHW_STATIC_RULE_RULE_ID_GUID                    5103
#define ERRCODE_UPDATE_DEF_NEGPOL                               5104
#define ERRCODE_SET_POL_READ_ONLY_OBJECT						5105
#define	ERRCODE_ADD_SET_RULE_READ_ONLY_OBJECT					5106
#define	ERRCODE_SET_FA_READ_ONLY_OBJECT							5107
#define	ERRCODE_SET_FL_READ_ONLY_OBJECT							5108
#define	ERRCODE_DEL_POL_READ_ONLY_OBJECT						5109
#define	ERRCODE_DEL_RULE_READ_ONLY_OBJECT						5110
#define	ERRCODE_DEL_FA_READ_ONLY_OBJECT							5111
#define ERRCODE_DEL_FL_READ_ONLY_OBJECT							5112
#define ERRCODE_SET_STATIC_POLICY_MISSING_GPO_NAME_STR          5113
#define ERRCODE_MISC_STATIC_SETSTORE_DOMAIN_NA           		5114
#define ERRCODE_MISC_STATIC_SETSTORE_NOT_DOMAIN_MEMBER			5115
#define ERRCODE_SET_STATIC_POLICY_GPO_SPECIFIED_ON_NODOMAIN_POLICY 5116

#define	ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE5				5117


//
// Dynamic error codes
//

// add rule
#define	ERRCODE_ADD_RULE_NO_POILCY	        					6001
#define	ERRCODE_ADD_RULE_WARNING_3	        					6002
#define	ERRCODE_ADD_RULE_WARNING_4	        					6003
#define	ERRCODE_PARSER_ADDRTYPE									6004
#define	ERRCODE_PARSER_TUNNELADDRTYPE                         	6005

// delete rule
#define	ERRCODE_DELETE_RULE_NO_MMFILTER	        				6011
#define	ERRCODE_DELETE_RULE_NO_TRANSPORT	        			6012
#define	ERRCODE_DELETE_RULE_NO_TUNNEL	        				6013
#define	ERRCODE_DEL_NO_MMPOLICY									6014
#define	ERRCODE_DEL_NO_QMPOLICY									6015

//add mainmode policy
#define	ERRCODE_ADD_MMP_MMPOLICY_EXISTS   						6021

//add quick mode policy
#define	ERRCODE_ADD_QMP_QMPOLICY_EXISTS   						6031

//add qmfilter
#define	ERRCODE_ADD_QMF_NO_QMPOLICY								6041

//add mmfil
#define	ERRCODE_ADD_MMF_NO_MMPOLICY								6051

//set mmfil
#define	ERRCODE_SET_MMF_NO_MMPOLICY								6061

//set Transport/Tunnel
#define	ERRCODE_SET_QMF_NO_QMPOLICY								6071

//delete rule mmf
#define	ERRCODE_DELETE_RULE_MMF_1								6081
#define	ERRCODE_DELETE_RULE_MMF_2								6082
#define	ERRCODE_DELETE_RULE_MMF_3								6083
#define	ERRCODE_DELETE_RULE_MMF_4								6084

//delete rule qmf
#define	ERRCODE_DELETE_RULE_QMF_1								6091
#define	ERRCODE_DELETE_RULE_QMF_2								6092
#define	ERRCODE_DELETE_RULE_QMF_3								6093
#define	ERRCODE_DELETE_RULE_QMF_4								6094
#define	ERRCODE_DELETE_AUTH_BEING_USED							6095
#define	ERRCODE_DELETE_MMF_OBJ_NOTDEL							6096
#define	ERRCODE_DELETE_TRANSPORT_OBJ_NOTDEL						6097
#define	ERRCODE_DELETE_TUNNEL_OBJ_NOTDEL						6098


#define	ERRCODE_SET_CONFIG_1									6121
#define	ERRCODE_SET_CONFIG_2									6122
#define	ERRCODE_SET_CONFIG_3									6123
#define	ERRCODE_SET_CONFIG_4									6124
#define	ERRCODE_SET_CONFIG_5									6125
#define ERRCODE_SET_CONFIG_6									6200

//show cmds
#define	ERRCODE_SHOW_MMP_5										6126
#define	ERRCODE_SHOW_MMP_6										6127
#define	ERRCODE_SHOW_QMP_5										6128
#define	ERRCODE_SHOW_QMP_6										6129
#define	ERRCODE_SHOW_MMF_6										6130
#define	ERRCODE_SHOW_MMF_7										6131
#define	ERRCODE_SHOW_MMF_8										6132
#define	ERRCODE_SHOW_QMF_6										6133
#define	ERRCODE_SHOW_QMF_7										6134
#define	ERRCODE_SHOW_QMF_8										6135
#define	ERRCODE_SHOW_QMF_17										6136
#define	ERRCODE_SHOW_MMSAS_3									6137
#define	ERRCODE_SHOW_QMSAS_3									6138
#define	ERRCODE_SHOW_MMSAS_6									6139
#define	ERRCODE_SHOW_QMSAS_4									6140
#define	ERRCODE_SHOW_REG_16		    							6141

//
// Error ID vs Error RC Index
//
const ERROR_TO_RC ERROR_RC[] =
{
	{ ERRCODE_INVALID_NUM_ARGS,							(ERR_INVALID_NUM_ARGS)		},
	{ ERRCODE_INVALID_ARGS,								(ERR_INVALID_ARGS)			},
	{ ERRCODE_INVALID_INDEX,							(ERR_INVALID_INDEX)			},

	{ ERRCODE_INVALID_ARG,								(ERR_INVALID_ARG)			},
	{ ERRCODE_DNSLOOKUP_FAILED,							(ERR_DNSLOOKUP_FAILED)		},
	{ ERRCODE_INVALID_ADDR,								(ERR_INVALID_ADDR)			},
	{ ERRCODE_INVALID_TAG,								(ERR_INVALID_TAG)			},
	{ ERRCODE_GPONAME_ARG_NEEDED,						(ERR_GPONAME_ARG_NEEDED)	},
	{ ERRCODE_NAME_GUID_NEEDED,							(ERR_NAME_GUID_NEEDED)		},
	{ ERRCODE_TAG_ALREADY_PRESENT,						(ERR_TAG_ALREADY_PRESENT)	},
	{ ERRCODE_TAG_NEEDED,								(ERR_TAG_NEEDED)			},
	{ ERRCODE_ARG_INVALID,								(ERR_ARG_INVALID)			},
	{ ERRCODE_PREFIX_INVALID,							(ERR_PREFIX_INVALID)		},
	{ ERRCODE_MASK_INVALID,								(ERR_MASK_INVALID)			},
	{ ERRCODE_NULL_STRING,								(ERR_NULL_STRING)			},
	{ ERRCODE_SECLIFE_INVALID,							(ERR_SECLIFE_INVALID)		},
	{ ERRCODE_KBLIFE_INVALID,							(ERR_KBLIFE_INVALID)		},
	{ ERRCODE_P2REKEY_INVALID,							(ERR_P2REKEY_INVALID)		},
	{ ERRCODE_HASH_INVALID,								(ERR_HASH_INVALID)			},
	{ ERRCODE_ESP_INCOMPLETE,							(ERR_ESP_INCOMPLETE)		},
	{ ERRCODE_DUPALG_INVALID,							(ERR_DUPALG_INVALID)		},
	{ ERRCODE_NONE_INVALID,								(ERR_NONE_INVALID)			},
	{ ERRCODE_IPSECPROT_INVALID,						(ERR_IPSECPROT_INVALID)		},
	{ ERRCODE_MAX_OFFERS,								(ERR_MAX_OFFERS)			},
	{ ERRCODE_AHESP_INVALID,							(ERR_AHESP_INVALID)			},
	{ ERRCODE_KS_INVALID,								(ERR_KS_INVALID)			},
	{ ERRCODE_INVALID_P1GROUP,							(ERR_INVALID_P1GROUP)		},
	{ ERRCODE_P1GROUP_MISSING,							(ERR_P1GROUP_MISSING)		},
	{ ERRCODE_MMOFFER_INVALID,							(ERR_MMOFFER_INVALID)		},
	{ ERRCODE_FILETYPE_INVALID,							(ERR_FILETYPE_INVALID)		},
	{ ERRCODE_ADDR_ALL_INVALID,							(ERR_ADDR_ALL_INVALID)		},
	{ ERRCODE_NO_PREKEY,								(ERR_NO_PREKEY)				},
	{ ERRCODE_AUTH_INVALID,								(ERR_AUTH_INVALID)			},
	{ ERRCODE_ENCODE_FAILED,							(ERR_ENCODE_FAILED)			},
	{ ERRCODE_MULTIPLE_KERBPRE,							(ERR_MULTIPLE_KERBPRE)		},
	{ ERRCODE_PORT_INVALID,								(ERR_PORT_INVALID)			},
	{ ERRCODE_MAXARGS_CROSSED,							(ERR_MAXARGS_CROSSED)		},
	{ ERRCODE_QMOFFER_INVALID,							(ERR_QMOFFER_INVALID)		},
	{ ERRCODE_INVALID_TUNNEL,							(ERR_INVALID_TUNNEL)		},
	{ ERRCODE_PROTO_INVALID,							(ERR_PROTO_INVALID)			},
	{ ERRCODE_INVALID_MASK,								(ERR_INVALID_MASK)			},
	{ ERRCODE_INVALID_MACHINE,							(ERR_INVALID_MACHINE)		},

	//static mode error table starts here

	{ ERRCODE_ADD_STATIC_POLICY_MISSING_POL_NAME,		(ERR_ADD_STATIC_POLICY_MISSING_POL_NAME)		},
	{ ERRCODE_ADD_STATIC_POLICY_POLL_INTERVAL_MSG,		(ERR_ADD_STATIC_POLICY_POLL_INTERVAL_MSG)		},
	{ ERRCODE_ADD_STATIC_POLICY_QMPERMM_MSG,			(ERR_ADD_STATIC_POLICY_QMPERMM_MSG)				},
	{ ERRCODE_ADD_STATIC_POLICY_LIFETIME_LIMIT_MSG,		(ERR_ADD_STATIC_POLICY_LIFETIME_LIMIT_MSG)		},

	{ ERRCODE_ADD_STATIC_CRNEWPOL_1,					(ERR_ADD_STATIC_CRNEWPOL_POL_EXISTS)			},
	{ ERRCODE_ADD_STATIC_CRNEWPOL_2,					(ERR_ADD_STATIC_CRNEWPOL_DEF_RULE_ERR)			},
	{ ERRCODE_ADD_STATIC_CRNEWPOL_4,					(ERR_ADD_STATIC_CRNEWPOL_ERROR)					},
	{ ERRCODE_ADD_STATIC_CRNEWPOL_5,					(ERR_ADD_STATIC_CRNEWPOL_FAIL_DEF_AUTH)			},


	//Add Filterlist
	{ ERRCODE_ADD_STATIC_FILTERLIST_1,					(ERR_ADD_STATIC_FILTERLIST_MISSING_FL_NAME)		},
	{ ERRCODE_ADD_STATIC_FILTERLIST_2,					(ERR_ADD_STATIC_FILTERLIST_FL_ALREADY_EXISTS)	},
	{ ERRCODE_ADD_STATIC_FILTERLIST_3,					(ERR_ADD_STATIC_FILTERLIST_ERROR_NEW_FL)		},
	{ ERRCODE_ADD_STATIC_FILTERLIST_5,					(ERR_ADD_STATIC_FILTERLIST_INVALID_GUID)		},

	//Add Filter
	{ ERRCODE_ADD_STATIC_FILTER_2,						(ERR_ADD_STATIC_FILTER_ERROR_NEW_FILTER)		},

	//Add FilterAction
	{ ERRCODE_ADD_STATIC_FILTERACTION_1,				(ERR_ADD_STATIC_FILTERACTION_FA_EXISTS)			},
	{ ERRCODE_ADD_STATIC_FILTERACTION_2,				(ERR_ADD_STATIC_FILTERACTION_ERROR_NEW_FA)		},
	{ ERRCODE_ADD_STATIC_FILTERACTION_4,				(ERR_ADD_STATIC_FILTERACTION_MIMIMUM_QMSEC)		},

	//Add Rule
	{ ERRCODE_ADD_STATIC_RULE_1,						(ERR_ADD_STATIC_RULE_MISSING_RULE_NAME)					},
	{ ERRCODE_ADD_STATIC_RULE_2,						(ERR_ADD_STATIC_RULE_MISSIGN_FA_NAME)					},
	{ ERRCODE_ADD_STATIC_RULE_3,						(ERR_ADD_STATIC_RULE_POL_NOT_AVAILABLE)					},
	{ ERRCODE_ADD_STATIC_RULE_4,						(ERR_ADD_STATIC_RULE_RULE_ALREADY_EXISTS)				},
	{ ERRCODE_ADD_STATIC_RULE_5,						(ERR_ADD_STATIC_RULE_FA_NOT_EXISTS)						},
	{ ERRCODE_ADD_STATIC_RULE_6,						(ERR_ADD_STATIC_RULE_NO_FILTERS_IN_FL)					},
	{ ERRCODE_ADD_STATIC_RULE_7,						(ERR_ADD_STATIC_RULE_ERROR_NEW_RULE)					},
	{ ERRCODE_ADD_STATIC_RULE_SUCCESS_MSG,				(ERR_ADD_STATIC_RULE_MISSING_RULE_NAME_OR_ID)			},
	{ ERRCODE_ADD_STATIC_RULE_CREATING_INFO,			(ERR_ADD_STATIC_RULE_POL_GUID_NOT_EXISTS)				},
	{ ERRCODE_ADD_STATIC_RULE_10,						(ERR_ADD_STATIC_RULE_FA_GUID_NOT_EXISTS)				},
	{ ERRCODE_ADD_STATIC_RULE_11,						(ERR_ADD_STATIC_RULE_DEF_AUTH_LOAD_FAILED)				},
	{ ERRCODE_ADD_STATIC_RULE_UPDATING_INFO,			(ERR_ADD_STATIC_RULE_CERT_DECODING_FAIL)				},
	{ ERRCODE_ADD_STATIC_RULE_INVALID_TUNNEL,			(ERR_ADD_STATIC_RULE_POL_NOT_EXIST_IN_DOMAIN)			},
	{ ERRCODE_ADD_RULE_INVALID_TUNNEL,      			(ERR_ADD_RULE_INVALID_TUNNEL)							},
	{ ERRCODE_ADD_STATIC_FILTER_1,						(ERR_ADD_STATIC_FILTER_FL_NOT_EXISTS)					},
	{ ERRCODE_ADD_STATIC_FILTER_3,						(ERR_ADD_STATIC_FILTER_SERVER_NOT_ALLOWED_BOTH_SIDES)	},
	{ ERRCODE_ADD_STATIC_FILTER_4,						(ERR_ADD_STATIC_FILTER_FL_GUID_NOT_EXISTS)				},
	{ ERRCODE_ADD_STATIC_FILTER_6,						(ERR_ADD_STATIC_FILTER_INVALID_SRCIP)					},
	{ ERRCODE_ADD_STATIC_FILTER_7,						(ERR_ADD_STATIC_FILTER_INVALID_SRCIPMASK)				},
	{ ERRCODE_ADD_STATIC_FILTER_8,						(ERR_ADD_STATIC_FILTER_ADDRESS_CONFLICT)				},
	{ ERRCODE_ADD_STATIC_FILTER_9,						(ERR_ADD_STATIC_FILTER_INVALID_SERVER_TYPE)				},
	{ ERRCODE_ADD_STATIC_FILTER_10,						(ERR_ADD_STATIC_FILTER_SERVER_TYPE_NEEDED)				},
	{ ERRCODE_ADD_STATIC_FILTER_11,						(ERR_ADD_STATIC_FILTER_INVALID_DSTIP)					},
	{ ERRCODE_ADD_STATIC_FILTER_12,						(ERR_ADD_STATIC_FILTER_INVALID_DSTIPMASK)				},

	//Set Policy
	{ ERRCODE_SET_STATIC_POLICY_3,						(ERR_SET_STATIC_POLICY_NO_DS)					},
	{ ERRCODE_SET_STATIC_POLICY_4,						(ERR_SET_STATIC_POLICY_NO_GPO_NAME)				},
	{ ERRCODE_SET_STATIC_POLICY_5,						(ERR_SET_STATIC_POLICY_ERR_GPO_ASSIGN)			},
	{ ERRCODE_SET_STATIC_POLICY_INVALID_CERTMAP_MSG,	(ERR_SET_STATIC_POLICY_INVALID_CERTMAP_MSG)		},
	{ ERRCODE_SET_STATIC_POLICY_CERTMAP_YES_STR,		(ERR_SET_STATIC_POLICY_CERTMAP_YES_STR)			},
	{ ERRCODE_SET_STATIC_POLICY_CERT_MAP_NO_STR,		(ERR_SET_STATIC_POLICY_CERT_MAP_NO_STR)			},

	//set filterlist
	{ ERRCODE_SET_STATIC_FILTERLIST_1,					(ERR_SET_STATIC_FILTERLIST_ERR_UPDATE_FL_NAME)	},
	{ ERRCODE_SET_STATIC_FILTERLIST_3,					(ERR_SET_STATIC_FILTERLIST_ERR_UPDATE_FL_GUID)	},

	//set filter action
	{ ERRCODE_ADD_STATIC_FILTERACTION_3,				(ERR_ADD_STATIC_FILTERACTION_INVALID_OPTIONS)	},
	{ ERRCODE_SET_STATIC_FILTERACTION_1,				(ERR_SET_STATIC_FA_ERR_NAME_UPDATE)				},
	{ ERRCODE_SET_STATIC_FILTERACTION_3,				(ERR_SET_STATIC_FA_ERR_GUID_UPDATE)				},

	//set rule
	{ ERRCODE_SET_STATIC_RULE_1,						(ERR_SET_STATIC_RULE_INVALID_NAME)				},
	{ ERRCODE_SET_STATIC_RULE_2,						(ERR_SET_STATIC_RULE_ERROR_UPDATE)				},
	{ ERRCODE_SET_STATIC_RULE_3,						(ERR_SET_STATIC_RULE_DEF_DEL_NOT_ALLOWED)		},
	{ ERRCODE_SET_STATIC_RULE_NEW_RULE_QUERY,			(ERR_SET_STATIC_RULE_NEW_RULE_QUERY)			},
	{ ERRCODE_SET_STATIC_RULE_5,						(ERR_SET_STATIC_RULE_INVALID_ID)				},

	//set def rule
	{ ERRCODE_SET_STATIC_DEFRULE_2,						(ERR_SET_STATIC_DEFRULE_ERROR_UPDATE)			},

	{ ERRCODE_MISC_STATIC_IMPORTPOLICY_1,				(ERR_MISC_STATIC_IMPORTPOLICY_NO_FILE_NAME)		},
	{ ERRCODE_MISC_STATIC_IMPORTPOLICY_3,				(ERR_MISC_STATIC_IMPORTPOLICY_INVALID_FILE)		},
	{ ERRCODE_MISC_STATIC_IMPORTPOLICY_4,				(ERR_MISC_STATIC_IMPORTPOLICY_ERROR)			},

		//export policy
	{ ERRCODE_MISC_STATIC_EXPORTPOLICY_2,				(ERR_MISC_STATIC_EXPORTPOLICY_ERROR)			},
	{ ERRCODE_MISC_STATIC_RESDEFRULE_2,					(ERR_MISC_STATIC_RESDEFRULE_ERROR)				},
	{ ERRCODE_MISC_STATIC_RESDEFRULE_3,					(ERR_MISC_STATIC_RESDEFRULE_CMD_NA)				},

	//Set Store
	{ ERRCODE_MISC_STATIC_SETSTORE_DOMAIN_NA, 			(ERR_MISC_STATIC_SETSTORE_DOMAIN_NA) 			},
	{ ERRCODE_MISC_STATIC_SETSTORE_NOT_DOMAIN_MEMBER,	(ERR_MISC_STATIC_SETSTORE_NOT_DOMAIN_MEMBER) 	},
	{ ERRCODE_DEL_STATIC_POLICY_3,						(ERR_DEL_STATIC_POLICY_ERROR)					},
	{ ERRCODE_SHW_STATIC_POLICY_2,						(ERR_SHW_STATIC_POLICY_NAME_NOT_EXISTS)			},

	//delete filterlist
	{ ERRCODE_DEL_STATIC_FILTERLIST_2,					(ERR_DEL_STATIC_FILTERLIST_DEL_NOT_ALLOWED)		},

	//delete filter
	{ ERRCODE_SHW_STATIC_TAB_PRTALLFL_3,				(ERR_SHW_STATIC_TAB_PRTALLFL_NAME_NOT_EXISTS)	},
	{ ERRCODE_DEL_STATIC_FILTER_1,						(ERR_DEL_STATIC_FILTER_NOT_AVAILABLE)			},

	{ ERRCODE_DEL_STATIC_FILTER_2,						(ERR_DEL_STATIC_FILTER_ERROR)					},

	//delete filter action
	{ ERRCODE_DEL_STATIC_FILTERACTION_2,				(ERR_DEL_STATIC_FA_DEL_NOT_ALLOWED)				},
	{ ERRCODE_SHW_STATIC_TAB_PRTALLFA_FA_COUNT_LIST,	(ERR_SHW_STATIC_TAB_PRTALLFA_FA_COUNT_LIST)		},

	//delete rule
	{ ERRCODE_SHW_STATIC_RULE_4,						(ERR_SHW_STATIC_RULE_MISSING_POL_NAME)			},
	{ ERRCODE_SHW_STATIC_RULE_RULE_ID_GUID,				(ERR_SHW_STATIC_RULE_RULE_ID_GUID)				},
	{ ERRCODE_DEL_STATIC_RULE_3,						(ERR_DEL_STATIC_RULE_ERR_DEL_RULE_NAME)			},
	{ ERRCODE_DEL_STATIC_RULE_4,						(ERR_DEL_STATIC_RULE_ERR_DEL_RULE_ID)			},
	{ ERRCODE_DEL_STATIC_RULE_5,						(ERR_DEL_STATIC_RULE_DEF_DEL_NOT_ALLOWED)		},
	{ ERRCODE_SHW_STATIC_RULE_3,						(ERR_SHW_STATIC_RULE_NO_RULE_WITH_ID)			},
	{ ERRCODE_DEL_STATIC_RULE_10,						(ERR_DEL_STATIC_RULE_NO_RULE_WITH_NAME)			},

	{ ERRCODE_SHW_STATIC_LIST_POLICY_COUNT,				(ERR_SHW_STATIC_LIST_POLICY_COUNT)				},
	{ ERRCODE_SHW_STATIC_TAB_POLICY_3,					(ERR_SHW_STATIC_TAB_POLICY_ERR_NEGPOL)			},
	{ ERRCODE_SHW_STATIC_TAB_POLICY_4,					(ERR_SHW_STATIC_TAB_POLICY_ERR_FILTER)			},
	{ ERRCODE_SHW_STATIC_TAB_POLICY_5,					(ERR_SHW_STATIC_TAB_POLICY_ERR_ISAKMP)			},

	//show filterl
	{ ERRCODE_SHW_STATIC_TAB_FILTERLIST_3,				(ERR_SHW_STATIC_TAB_FL_NO_RULE_NAME_STR)		},
	{ ERRCODE_SHW_STATIC_TAB_RULE_3,					(ERR_SHW_STATIC_TAB_RULE_NO_RULE_ID)			},

	//show assigned gpo policy
	{ ERRCODE_SHW_STATIC_TAB_ASSIGNPOL_2,				(ERR_SHW_STATIC_TAB_ASSIGNPOL_NO_ACTIVE_POL)	},
	{ ERRCODE_STATIC_INTERNAL_ERROR,	    			(ERR_STATIC_INTERNAL_ERROR)	        			},

	{ ERRCODE_SHW_STATIC_TAB_PRTALLFL_2,				(ERR_SHW_STATIC_TAB_PRTALLFL_NO_FL)				},
	{ ERRCODE_SHW_STATIC_TAB_PRTALLFA_6,				(ERR_SHW_STATIC_TAB_PRTALLFA_NO_FA)				},
	{ ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE3,		(ERR_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE3)		},
	{ ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE4,		(ERR_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE4)		},
	{ ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE5,		(ERR_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE5)		},

	{ ERRCODE_SET_STATIC_POL_NEWNAME,	  				(ERR_SET_STATIC_POL_NEWNAME)					},
	{ ERRCODE_SET_STATIC_RULE_NEWNAME,	  				(ERR_SET_STATIC_RULE_NEWNAME)					},
	{ ERRCODE_SET_STATIC_FL_NEWNAME,	  				(ERR_SET_STATIC_FL_NEWNAME)						},
	{ ERRCODE_SET_STATIC_FA_NEWNAME,	  				(ERR_SET_STATIC_FA_NEWNAME)						},

	{ ERRCODE_NO_POLICY,	        					(ERR_NO_POLICY)									},
	{ ERRCODE_FAILED_POLSTORE_OPEN,						(ERR_FAILED_POLSTORE_OPEN)						},
	{ ERRCODE_NO_FILTER_ACTION,	        				(ERR_NO_FILTER_ACTION)							},
	{ ERRCODE_NO_FILTER_LIST,		        			(ERR_NO_FILTER_LIST)							},
	{ ERRCODE_INVALID_POLICY_NAME,        				(ERR_INVALID_POLICY_NAME)						},
	{ ERRCODE_SET_STATIC_SHOW_RULE_TYPE,    			(ERR_SET_STATIC_SHOW_RULE_TYPE)					},
	{ ERRCODE_DEL_STATIC_FILTERLIST_ALL_FL_DEL_QUERY,   (ERR_DEL_STATIC_FILTERLIST_ERROR)				},
	{ ERRCODE_DEL_STATIC_FILTERACTION_ALL_FA_DEL_QUERY, (ERR_DEL_STATIC_FA_ERROR)						},
	{ ERRCODE_UPDATE_DEF_NEGPOL,            			(ERR_UPDATE_DEF_NEGPOL)             			},
	{ ERRCODE_SET_POL_READ_ONLY_OBJECT,					(ERR_SET_POL_READ_ONLY_OBJECT)					},
	{ ERRCODE_ADD_SET_RULE_READ_ONLY_OBJECT,			(ERR_ADD_SET_RULE_READ_ONLY_OBJECT)				},
	{ ERRCODE_SET_FA_READ_ONLY_OBJECT,					(ERR_SET_FA_READ_ONLY_OBJECT)					},
	{ ERRCODE_SET_FL_READ_ONLY_OBJECT,					(ERR_SET_FL_READ_ONLY_OBJECT)					},
	{ ERRCODE_DEL_POL_READ_ONLY_OBJECT,					(ERR_DEL_POL_READ_ONLY_OBJECT)					},
	{ ERRCODE_DEL_RULE_READ_ONLY_OBJECT,				(ERR_DEL_RULE_READ_ONLY_OBJECT)					},
	{ ERRCODE_DEL_FA_READ_ONLY_OBJECT,					(ERR_DEL_FA_READ_ONLY_OBJECT)					},
	{ ERRCODE_DEL_FL_READ_ONLY_OBJECT,					(ERR_DEL_FL_READ_ONLY_OBJECT)					},
	{ ERRCODE_SET_STATIC_POLICY_MISSING_GPO_NAME_STR,	(SET_STATIC_POLICY_MISSING_GPO_NAME_STR)		},
    { ERRCODE_SET_STATIC_POLICY_GPO_SPECIFIED_ON_NODOMAIN_POLICY, (SET_STATIC_POLICY_GPO_NOT_OK_STR)    },


   	//Dynamic error table starts here
	{ ERRCODE_ADD_RULE_NO_POILCY,        				(ERR_DYN_ACTION_IN_OUT_NEGOTIATE )				},
	{ ERRCODE_ADD_RULE_WARNING_3,        				(ERR_DYN_QMP_NEEDED)							},
	{ ERRCODE_ADD_RULE_WARNING_4,        				(ERR_DYN_INVALID_MIRROR)						},
	{ ERRCODE_PARSER_ADDRTYPE,							(ERROR_PARSER_ADDRTYPE)							},
	{ ERRCODE_PARSER_TUNNELADDRTYPE,					(ERROR_PARSER_TUNNELADDRTYPE)					},

	{ ERRCODE_DELETE_RULE_NO_MMFILTER,					(ERR_DYN_MMF_DOES_NOT_EXIST)					},
	{ ERRCODE_DELETE_RULE_NO_TRANSPORT,					(ERR_DYN_TRANSPORT_DOES_NOT_EXIST)				},
	{ ERRCODE_DELETE_RULE_NO_TUNNEL,					(ERR_DYN_TUNNEL_DOES_NOT_EXIST)					},

	{ ERRCODE_ADD_MMP_MMPOLICY_EXISTS,					(ERR_DYN_MMP_EXISTS)							},
	{ ERRCODE_ADD_QMP_QMPOLICY_EXISTS,					(ERR_DYN_QMP_EXISTS)							},
	{ ERRCODE_ADD_QMF_NO_QMPOLICY,						(ERR_DYN_QMP_DOES_NOT_EXIST)					},
	{ ERRCODE_ADD_MMF_NO_MMPOLICY,						(ERR_DYN_MMP_DOES_NOT_EXIST)					},
	{ ERRCODE_SET_MMF_NO_MMPOLICY,						(ERR_DYN_RULE_MMP_DOES_NOT_EXIST)				},
	{ ERRCODE_SET_QMF_NO_QMPOLICY,						(ERR_DYN_RULE_QMP_DOES_NOT_EXIST)				},
	{ ERRCODE_DEL_NO_MMPOLICY,							(ERROR_DEL_NO_MMP)								},
	{ ERRCODE_DEL_NO_QMPOLICY,							(ERROR_DEL_NO_QMP)								},

	//delete rule mmf
	{ ERRCODE_DELETE_RULE_MMF_1,						(ERR_DYN_DEL_MMF_DOES_NOT_EXIST)				},
	{ ERRCODE_DELETE_RULE_MMF_2,						(ERR_DYN_DEL_MMF_MMP_DOES_NOT_EXIST)			},
	{ ERRCODE_DELETE_RULE_MMF_3,						(ERR_DYN_DEL_MMP_DOES_NOT_EXIST)				},
	{ ERRCODE_DELETE_RULE_MMF_4,						(ERR_DYN_DEL_SPECIFIED_MMF_DOES_NOT_EXIST)		},

	//delete rule qmf
	{ ERRCODE_DELETE_RULE_QMF_1,						(ERR_DYN_DEL_MMF_DOES_NOT_EXIST)				},
	{ ERRCODE_DELETE_RULE_QMF_2,						(ERR_DYN_DEL_MMF_MMP_DOES_NOT_EXIST)			},
	{ ERRCODE_DELETE_RULE_QMF_3,						(ERR_DYN_DEL_MMP_DOES_NOT_EXIST)				},
	{ ERRCODE_DELETE_RULE_QMF_4,						(ERR_DYN_DEL_SPECIFIED_MMF_DOES_NOT_EXIST)		},
	{ ERRCODE_DELETE_AUTH_BEING_USED,					(ERR_DYN_DEL_AUTH_BEING_USED)					},


	{ ERRCODE_DELETE_MMF_OBJ_NOTDEL,					(ERR_DYN_DEL_MMF_OBJ_NOTDEL)					},
	{ ERRCODE_DELETE_TRANSPORT_OBJ_NOTDEL,				(ERR_DYN_DEL_TRANSPORT_OBJ_NOTDEL)				},
	{ ERRCODE_DELETE_TUNNEL_OBJ_NOTDEL,					(ERR_DYN_DEL_TUNNEL_OBJ_NOTDEL)					},

	//set config
	{ ERRCODE_SET_CONFIG_1,								(DYNAMIC_SHOW_REG_DIAG_ERR_MSG)					},
	{ ERRCODE_SET_CONFIG_2,								(DYNAMIC_SHOW_REG_IKE_LOG_ERR_MSG)				},
	{ ERRCODE_SET_CONFIG_3,								(DYNAMIC_SHOW_REG_STRONG_CRL_ERR_MSG)			},
	{ ERRCODE_SET_CONFIG_4,								(DYNAMIC_SHOW_REG_IPSEC_LOG_ERR_MSG)			},
	{ ERRCODE_SET_CONFIG_5,								(DYNAMIC_SHOW_REG_IPSEC_EXEMPT_ERR_MSG)			},
	{ ERRCODE_TOO_MANY_EXEMPTS,							(DYNAMIC_SET_REG_TOO_MANY_EXEMPTIONS)			},

	//show cmds
	{ ERRCODE_SHOW_MMP_5,								(DYNAMIC_SHOW_SPECIFIED_MMP_NOT_FOUND_MSG)		},
	{ ERRCODE_SHOW_MMP_6,								(DYNAMIC_SHOW_NO_MMP_ERROR_MSG)					},
	{ ERRCODE_SHOW_QMP_5,								(DYNAMIC_SHOW_SPECIFIED_QMP_NOT_FOUND_MSG)		},
	{ ERRCODE_SHOW_QMP_6,								(DYNAMIC_SHOW_NO_QMP_ERROR_MSG)					},
	{ ERRCODE_SHOW_MMF_6,								(DYNAMIC_SHOW_MMF_GENERIC_NOT_FOUND_MSG)		},
	{ ERRCODE_SHOW_MMF_7,								(DYNAMIC_SHOW_MMF_SPECIFIC_NOT_FOUND_MSG)		},
	{ ERRCODE_SHOW_MMF_8,								(DYNAMIC_SHOW_MMF_SPECIFIED_NOT_FOUND_MSG)		},
	{ ERRCODE_SHOW_QMF_6,								(DYNAMIC_SHOW_QMF_GENERIC_NOT_FOUND_MSG)		},
	{ ERRCODE_SHOW_QMF_7,								(DYNAMIC_SHOW_QMF_SPECIFIC_NOT_FOUND_MSG)		},
	{ ERRCODE_SHOW_QMF_8,								(DYNAMIC_SHOW_QMF_SPECIFIED_NOT_FOUND_MSG)		},
	{ ERRCODE_SHOW_QMF_17,								(DYNAMIC_SHOW_NO_RULES_ERROR_MSG)				},
	{ ERRCODE_SHOW_MMSAS_3, 							(DYNAMIC_SHOW_MMSAS_NO_SA_FOUND_MSG)			},
	{ ERRCODE_SHOW_QMSAS_3, 							(DYNAMIC_SHOW_QMSAS_NO_SA_FOUND_MSG)			},
	{ ERRCODE_SHOW_MMSAS_6, 							(DYNAMIC_SHOW_MMSAS_NOT_FOUND_MSG)				},
	{ ERRCODE_SHOW_QMSAS_4, 							(DYNAMIC_SHOW_QMSAS_NOT_FOUND_MSG)				},
	{ ERRCODE_SHOW_REG_16, 								(DYNAMIC_SHOW_REG_PARAM_NOT_SET_MSG)			}
};

//
// externs
//
extern DWORD
SmartDefaults(
	IN PINT_IPSEC_MM_AUTH_INFO * ppAuthInfo,
	IN LPTSTR pszMachine,
	IN DWORD * pdwNumberOfAuth,
	IN BOOL bIsDomainPolicy
	);
//
// Netsh framework function prototypes...
//
extern "C"
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    PVOID pReserved );

DWORD WINAPI
InitHelperDll(
	IN      DWORD           dwNetshVersion,
	OUT     PVOID	        pReserved
    );

DWORD WINAPI
StartHelpers(
    IN      CONST GUID *    pguidParent,
    IN      DWORD           dwVersion
    );

DWORD WINAPI
IpsecConnect(
		IN  LPCWSTR  pwszMachine
		);

VOID
PrintErrorMessage(
	IN	DWORD			dwErrorType,
  	IN	DWORD			dwWin32ErrorCode,
	IN	DWORD			dwIpsecErrorCode,
	...
	);

DWORD
DisplayErrorMessage(
    IN  LPCWSTR  pwszFormat,
    IN  va_list *parglist
	);

VOID
AddSplAddr(
	IN OUT ADDR& Addr,
	IN DWORD dwSplServer
	);

DWORD
PrintErrorMessageFromModule(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    IN  va_list *parglist
	);

VOID
UpdateGetLastError(
		LPWSTR pwszOutput
	);

LPCWSTR
GetIpsecLastError(
	VOID
	);

BOOL WINAPI
CheckOsVersion(
	IN  UINT     CIMOSType,
	IN  UINT     CIMOSProductSuite,
	IN  LPCWSTR  CIMOSVersion,
	IN  LPCWSTR  CIMOSBuildNumber,
	IN  LPCWSTR  CIMServicePackMajorVersion,
	IN  LPCWSTR  CIMServicePackMinorVersion,
	IN  UINT     CIMProcessorArchitecture,
	IN  DWORD    dwReserved
	);

VOID
CleanupAuthMethod(
	PSTA_AUTH_METHODS *ppAuthMethod,
	BOOL bIsArray = FALSE
	);

VOID
CleanupMMAuthMethod(
	PSTA_MM_AUTH_METHODS *ppMMAuth,
	BOOL bIsArray
	);

VOID
CleanupAuthData(
	PSTA_AUTH_METHODS *ppKerbAuth,
	PSTA_AUTH_METHODS *ppPskAuth,
	PSTA_MM_AUTH_METHODS *ppRootcaAuth
	);

#endif //_NSHIPSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\parser.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Module			: parser.cpp
//
// Purpose			: Netsh Ipsec Context Parser
//
// Developers Name	: N.Surendra Sai / Vunnam Kondal Rao
//
// History			:
//
// Date	    	Author    	Comments
// 1 Aug 2001   NSS/VKR
//
//////////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"
#include "parser_util.h"

extern HINSTANCE g_hModule;
extern PVOID  g_AllocPtr[MAX_ARGS];
extern PSTA_MM_AUTH_METHODS g_paRootca[MAX_ARGS];
extern PIPSEC_QM_OFFER	g_pQmsec[IPSEC_MAX_QM_OFFERS];
extern PIPSEC_MM_OFFER	g_pMmsec[IPSEC_MAX_MM_OFFERS];

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	Parser()
//
//	Date of Creation	:	21st Aug 2001
//
//	Parameters			:	IN      LPCWSTR         pwszMachine,
//							IN      LPWSTR          *ppwcArguments,
//							IN      DWORD           dwCurrentIndex,
//							IN      DWORD           dwArgCount,
//  						IN OUT  PARSER_PKT      *pParser
//
//	Return				:	ERROR_SUCCESS
//							ERROR_SHOW_USAGE
//							RETURN_NO_ERROR
//							ERROR_INVALID_ARG
//	Description			:	This is called by any Sub-Context of IPSec whenever
//							there is a Parsing requirement
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
Parser(
	IN      LPCWSTR         pwszMachine,
	IN      LPWSTR          *ppwcArguments,
	IN      DWORD           dwCurrentIndex,
	IN      DWORD           dwArgCount,
    IN OUT  PPARSER_PKT     pParser
)
{
	const TOKEN_VALUE vtokGroupCmd[] =		// Valid Groups Considered by the Parser
	{										// For determining group context
		{ GROUP_STATIC_STR,  GROUP_STATIC 	},
		{ GROUP_DYNAMIC_STR, GROUP_DYNAMIC	}
	};
	const TOKEN_VALUE vtokPriCmd[] =		// Valid Groups Considered by the Parser
	{										// For determining primary context
	 	{ PRI_ADD_STR,				PRI_ADD 			},
	 	{ PRI_SET_STR,				PRI_SET				},
	 	{ PRI_DELETE_STR,			PRI_DELETE			},
	 	{ PRI_SHOW_STR,				PRI_SHOW			},
	 	{ PRI_EXPORTPOLICY_STR,		PRI_EXPORTPOLICY	},
	 	{ PRI_IMPORTPOLICY_STR,		PRI_IMPORTPOLICY	},
	 	{ PRI_RESTOREDEFAULTS_STR,	PRI_RESTOREDEFAULTS }
	};
	const TOKEN_VALUE vtokSecCmd[] =		// Valid Groups Considered by the Parser
	{										// For determining secondary context
		{ SEC_POLICY_STR,			SEC_POLICY 			},
		{ SEC_FILTER_STR,			SEC_FILTER			},
		{ SEC_FILTERLIST_STR,		SEC_FILTERLIST		},
		{ SEC_FILTERACTION_STR,		SEC_FILTERACTION	},
		{ SEC_RULE_STR,				SEC_RULE			},
		{ SEC_ALL_STR,				SEC_ALL				},
		{ SEC_STORE_STR,			SEC_STORE			},
		{ SEC_DEFAULTRULE_STR,		SEC_DEFAULTRULE		},
		{ SEC_ASSIGNEDPOLICY_STR,	SEC_ASSIGNEDPOLICY	},
		{ SEC_INTERACTIVE_STR,		SEC_INTERACTIVE		},
		{ SEC_MMPOLICY_STR,			SEC_MMPOLICY		},
		{ SEC_QMPOLICY_STR,			SEC_QMPOLICY		},
		{ SEC_STATS_STR,			SEC_STATS			},
		{ SEC_MMSAS_STR,			SEC_MMSAS			},
		{ SEC_QMSAS_STR,			SEC_QMSAS			},
		{ SEC_MMFILTER_STR,			SEC_MMFILTER		},
		{ SEC_QMFILTER_STR,			SEC_QMFILTER		},
		{ SEC_CONFIG_STR,			SEC_CONFIG			},
		{ SEC_BATCH_STR,			SEC_BATCH			}
	};

	const DWORD GROUP_MAX = SIZEOF_TOKEN_VALUE(vtokGroupCmd);
  	const DWORD PRI_MAX	  = SIZEOF_TOKEN_VALUE(vtokPriCmd);
	const DWORD SEC_MAX	  = SIZEOF_TOKEN_VALUE(vtokSecCmd);

	_TCHAR szListTok[MAX_STR_LEN]	= {0};			// wide string
	LPTSTR *ppwcTok 				= NULL;			// pointer to array of pointers to wstr
 	LPTSTR ppwcFirstTok[MAX_ARGS]	= {0};			// pointer to array of pointers to wstr

	DWORD dwCount	= pParser->MaxCmd;				// Num of Args after removing List Tokens

	DWORD dwCommand 				= 0;			// command determines the context
	DWORD dwNumRootca			= 0;
	DWORD dwMaxArgs 				= 0;			// for loop index
	DWORD dwPreProcessCurrentIndex	= 0;			// Current Index for Preprocess Command after RemoveList
	DWORD dwPreProcessArgCount		= 0;			// Num of args input to Preprocess Command after RemoveList

	DWORD dwTagType[MAX_ARGS]		= {0};			// Return array of Preprocess Command
	DWORD dwReturn 					= ERROR_SUCCESS;		// Default Return Value implies Error Message
	DWORD dwGroupCmd,dwPriCmd,dwSecCmd;				// Context

	PTAG_TYPE    pValidCmds 	= NULL;				// pointer to array of TAG_TYPE commands
	PTOKEN_VALUE pValidTokens	= NULL;				// pointer to array of TOKEN_VALUE tokens

	BOOL bOption				= ADD_CMD;			// default is  add only.
	BOOL bPreProcessCommand		= FALSE;				// default use PreProcessCommand
	BOOL bIsRootcaRule = FALSE;

	UpdateGetLastError(NULL);						// Error Success

	InitializeGlobalPointers();

	for(dwMaxArgs=0;dwMaxArgs<MAX_ARGS;dwMaxArgs++)	// allocate storage for list commands
	{
		g_paRootca[dwMaxArgs] = NULL;
	}

	ZeroMemory(szListTok, MAX_STR_LEN*sizeof(_TCHAR));

	pValidCmds   = (PTAG_TYPE)pParser->ValidCmd;			// Input Valid Command Table
	pValidTokens = (PTOKEN_VALUE)pParser->ValidTok;			// Input Valid Non-List Commands Table

	for(dwMaxArgs = 0;dwMaxArgs <(pParser->MaxCmd);dwMaxArgs++)	// Packet Init
	{
		(pParser->Cmd)[dwMaxArgs].dwCmdToken = dwMaxArgs+1;		// Enum Starts at 1
		(pParser->Cmd)[dwMaxArgs].pArg       = NULL;			// All ptrs
		(pParser->Cmd)[dwMaxArgs].dwStatus 	 = INVALID_TOKEN;	// Status set
	}
	dwGroupCmd = dwPriCmd = dwSecCmd = 0;		// Initialize the context variables
	switch (dwCurrentIndex)						// CurrentIndex determines Context
	{
		case SEC_CMD	:
			MatchEnumTag(g_hModule,ppwcArguments[2],SEC_MAX,  vtokSecCmd,&dwSecCmd);
			// Fall Through
		case PRI_CMD	:
			// if present
			MatchEnumTag(g_hModule,ppwcArguments[1],PRI_MAX,  vtokPriCmd,&dwPriCmd);
			// Fall Through
		case GROUP_CMD 	:
			// Should be present
			MatchEnumTag(g_hModule,ppwcArguments[0],GROUP_MAX,vtokGroupCmd,&dwGroupCmd);
			break;
		default	:
			// Should Never Come Here
			break;
	}

	dwCommand = INDEX(dwGroupCmd,dwPriCmd,dwSecCmd);	// Macro to Compute Index
	switch(dwCommand)
	{													// Based on the context
		case DYNAMIC_SET_RULE			:
		case DYNAMIC_ADD_RULE			:
		case STATIC_ADD_RULE			:				// Load the List Commands
		case STATIC_SET_RULE			:
		case STATIC_SET_DEFAULTRULE		:				// Load the List Commands
			bIsRootcaRule = TRUE;
			bPreProcessCommand = TRUE;
			break;
		case STATIC_SET_POLICY			:
			dwReturn = ParseStaticSetPolicy((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_SET_FILTERACTION	:
			dwReturn = ParseStaticSetFilterAction((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_SET_FILTERLIST		:
			dwReturn = ParseStaticSetFilterList((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_SHOW_POLICY			:
			dwReturn = ParseStaticShowPolicy((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_SHOW_FILTERLIST		:
			dwReturn = ParseStaticShowFilterList((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_SHOW_FILTERACTION	:
			dwReturn = ParseStaticShowFilterAction((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_SHOW_RULE			:
			dwReturn = ParseStaticShowRule((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_SHOW_ASSIGNEDPOLICY	:
			dwReturn = ParseStaticShowAssignedPolicy((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_SET_STORE			:
			dwReturn = ParseStaticSetStore((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_DELETE_FILTERLIST	:
		case STATIC_DELETE_FILTERACTION :
		case STATIC_DELETE_POLICY		:
			dwReturn = ParseStaticDelPolFlistFaction((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case STATIC_DELETE_RULE			:
			dwReturn = ParseStaticDelRule((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case DYNAMIC_SHOW_MMPOLICY		:
		case DYNAMIC_SHOW_FILTERACTION	:
			dwReturn = ParseDynamicShowPolFaction((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case DYNAMIC_SHOW_QMFILTER		:
			dwReturn = ParseDynamicShowQMFilter((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case DYNAMIC_SHOW_MMFILTER		:
			dwReturn = ParseDynamicShowMMFilter((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case DYNAMIC_DELETE_FILTERACTION:
		case DYNAMIC_DELETE_MMPOLICY	:
			dwReturn = ParseDynamicDelPolFaction((LPTSTR * )ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case DYNAMIC_SHOW_QMSAS			:
			dwReturn = ParseDynamicShowQMSAS((LPTSTR *)ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		case DYNAMIC_SHOW_RULE			:
			dwReturn = ParseDynamicShowRule((LPTSTR *)ppwcArguments,pParser,dwCurrentIndex,dwArgCount);
			break;
		default							:
			bPreProcessCommand = TRUE;
			break;
	}
	if ( bPreProcessCommand == FALSE )						// It was done every thing for all 'or' commands..
	{														// So back to called context
		BAIL_OUT;
	}
	if (bIsRootcaRule)
	{
		dwReturn = RemoveRootcaAuthMethods(ppwcArguments,dwArgCount,dwCurrentIndex,pParser,NULL,g_paRootca,ppwcFirstTok,&dwNumRootca,MAX_STR_LEN, &dwCount);
		if(dwReturn != ERROR_SUCCESS)
		{
			dwReturn = RETURN_NO_ERROR;
			BAIL_OUT;
		}
	}
	else
	{	// Normalize the ppcwTok to 0 Base 'for sake of consistency
		dwCount = RemoveList(ppwcArguments,dwArgCount,dwCurrentIndex,pParser,_TEXT(""),NULL,szListTok,ppwcFirstTok,MAX_STR_LEN);
	}
	ppwcTok = (LPTSTR [MAX_ARGS])ppwcFirstTok;

	if(dwCommand == STATIC_SET_RULE)
	{
		dwReturn = ParseStaticSetRule(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
	}
	else
	{
		// Initialize the output array of PreProcess Command
		for(dwMaxArgs = 0;dwMaxArgs < MAX_ARGS;dwMaxArgs++)
		{
			dwTagType[dwMaxArgs] = 0;
		}

		dwPreProcessCurrentIndex = 0;		// Current Index for Preprocess Command after RemoveList
		dwPreProcessArgCount     = dwCount;	// Num of args input to Preprocess Command after RemoveList

		if(dwCount > MAX_ARGS)				// pParser->MaxCmd
											// Check For Max Args in the Non-List Commands
		{
			dwPreProcessArgCount = MAX_ARGS;						// pParser->MaxCmd;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MAXARGS_CROSSED);	// Should Never Come Here
		}															// If More Truncate...
		else
		{
			dwPreProcessArgCount = dwCount;
		}

		dwReturn = PreprocessCommand(
			g_hModule,                  // This argument is not used; should be 0.
			ppwcTok,             		// Argv style array (netsh passed us this.)
			dwPreProcessCurrentIndex,   // Means ppwcArguments[dwCurrentIndex] is the first argument of interest.
										// PpwcArguments[0] is going to be the context,
										// PpwcArguments[1] is the first command
										// So ppwcARguments[2] is the first argument of interest.
			dwPreProcessArgCount,       // Total count of all the args in ppwcArguments.
			(PTAG_TYPE)pParser->ValidCmd,
			pParser->MaxCmd,			// Number of entries in the ValidCommands array.
			1,                          // Minimum number of arguments needed to be a valid command.
			MAX_ARGS,                   // Maximum number of arguments allowed to be a valid command.
			dwTagType);                 // Array of DWORD's used to indicate which command in ValidCommands.
										// The token in the command line referred to.
		if (dwReturn != ERROR_SUCCESS)
		{
			UpdateGetLastError(ERRMSG_GETLASTERROR);
			BAIL_OUT;
		}
		switch(dwCommand)
		{

			case STATIC_IMPORTPOLICY		:
				dwReturn = ParseStaticImportPolicy(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_EXPORTPOLICY		:
				dwReturn = ParseStaticExportPolicy(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_SET_INTERACTIVE		:			// Interactive & Batch have the same args..
			case STATIC_SET_BATCH			:
				dwReturn = ParseStaticSetInteractive(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_ADD_POLICY			:
				dwReturn = ParseStaticAddPolicy(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_SET_RULE			:
				// handled above
				break;
			case STATIC_ADD_RULE			:
				dwReturn = ParseStaticAddRule(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_ADD_FILTERLIST		:
				dwReturn = ParseStaticAddFilterList(ppwcTok,szListTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_ADD_FILTERACTION	:
				dwReturn = ParseStaticAddFilterAction(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_SET_DEFAULTRULE		:
				dwReturn = ParseStaticSetDefaultRule(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_ADD_FILTER			:
				dwReturn = ParseStaticAddFilter(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_DELETE_FILTER		:
				dwReturn = ParseStaticDelFilter(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_RESTOREDEFAULTS		:
				dwReturn = ParseStaticRestoreDefaults(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case DYNAMIC_SET_MMPOLICY		:		// Set means no need to fill default MMSec methods
				bOption	 = SET_CMD;
			case DYNAMIC_ADD_MMPOLICY		:
				dwReturn = ParseDynamicAddSetMMPolicy(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType,bOption);
				break;
			case DYNAMIC_SET_FILTERACTION	:		// Set means no need to fill default QMSec methods
				bOption	 = SET_CMD;
			case DYNAMIC_ADD_FILTERACTION	:
				dwReturn = ParseDynamicAddSetQMPolicy(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType,bOption);
				break;
			case DYNAMIC_SET_CONFIG			:
				dwReturn = ParseDynamicSetConfig(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case DYNAMIC_SHOW_STATS			:
				dwReturn = ParseDynamicShowStats(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case DYNAMIC_SHOW_ALL			:
				dwReturn = ParseDynamicShowAll(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_SHOW_ALL			:
				dwReturn = ParseStaticAll(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case DYNAMIC_ADD_RULE			:
				dwReturn = ParseDynamicAddRule(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case DYNAMIC_SET_RULE			:
				dwReturn = ParseDynamicSetRule(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case DYNAMIC_DELETE_RULE		:
				dwReturn = ParseDynamicDelRule(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case DYNAMIC_SHOW_MMSAS			:
				dwReturn = ParseDynamicShowMMSAS(ppwcTok,pParser,dwCurrentIndex,dwCount,dwTagType);
				break;
			case STATIC_DELETE_ALL			:
				break;
			default 						:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}

	if (bIsRootcaRule)
	{
		pParser->Cmd[pParser->MaxTok].dwCmdToken = CMD_TOKEN_ROOTCA;
		pParser->Cmd[pParser->MaxTok].dwStatus   = dwNumRootca;
		pParser->Cmd[pParser->MaxTok].pArg       = (void *)g_paRootca;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CleanUp()
//
//	Date of Creation	:	12 Aug 2001
//
//	Parameters			:	NONE
//
//	Return				:	NONE
//
//	Description			:	Free's the all Globally allocated memory.
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

VOID
CleanUp(VOID)
{
	DWORD dwCount;
	DWORD dwMaxArgs;

	for(dwCount=0;dwCount<MAX_ARGS;dwCount++)
	{
		if (g_AllocPtr[dwCount])
		{
	 		free(g_AllocPtr[dwCount]);
	 		g_AllocPtr[dwCount] = NULL;
		}
	}

	if (g_paRootca)
	{
		for(dwMaxArgs=0;dwMaxArgs<MAX_ARGS;dwMaxArgs++)
		{
			CleanupMMAuthMethod(&(g_paRootca[dwMaxArgs]), FALSE);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	RemoveList()
//
//	Date of Creation	:	10th Aug 2001
//
//	Parameters			:	IN      ppwcArguments,	// Input stream
//							IN      dwArgCount,		// Input arg count
//							IN      dwCurrentIndex,	// Input current arg index
//  						IN      pParser,		// contains the MaxTok
//  						IN 		pwcListCmd,		// Compare ListCmd with this string
//  						OUT		pwcListArgs,	// string containing the list args
//  						OUT 	ppwcTok			// i/p stream stripped of list cmds
//							IN		dwInputAllocLen	// Max alloc len of pwcListArgs
//
//	Return				:	DWORD		(No.of Non list commands)
//
//	Description			:	This Function called by parser function.
//							It will separate the List and Non-List commands
//
//	History				:
//
// 	Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
RemoveList(
	IN      LPTSTR          *ppwcArguments,	// Input stream
	IN      DWORD           dwArgCount,		// Input arg count
	IN      DWORD			dwCurrentIndex,	// Input current arg index
    IN      PPARSER_PKT     pParser,		// contains the MaxTok
    IN 		LPTSTR 			pwcListCmd,		// Compare ListCmd with this string
	IN      LPTSTR          szAnotherList, 	// Another ListCmd also present ...
    OUT		LPTSTR 			pwcListArgs,	// string containing the list args		// Memory need to be pre allocated
    OUT 	LPTSTR 			*ppwcTok,		// i/p stream stripped of list cmds		// No Memory has been allocated...
    																				// Only pointer copy operation
    IN		DWORD			dwInputAllocLen	// Max alloc len of pwcListArgs
	)
{
	DWORD dwLoopCount,dwNum = 0,dwCount = 0;	// Count of the number of tokens input to PP

	BOOL bWithinList = FALSE;					// track if within list command
	BOOL bFoundList  = FALSE;					// track if list command found in stream
	BOOL bFoundAnotherList = FALSE;
	BOOL bEqualPresent = FALSE;
	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

 	for(dwLoopCount = dwCurrentIndex;dwLoopCount < dwArgCount;dwLoopCount++)
	{
		if (_tcslen(ppwcArguments[dwLoopCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwLoopCount],MAX_STR_LEN-1);
			// szTemp contains the cmd=arg
		}
		else
		{
			continue;
		}

		// szCmd = cmd, szTok = arg
		bEqualPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);

		if (bWithinList)
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szTemp,pParser->MaxTok,pParser->ValidTok,&dwNum);

			if (szAnotherList)
			{
				bFoundAnotherList = MatchToken(szTemp,szAnotherList) && bEqualPresent;
			}

			if ( dwNum || bFoundAnotherList )					// Normal command
			{
				bWithinList = 0;
				ppwcTok[dwCount] = ppwcArguments[dwLoopCount];	// Pointer Cpy, Unallocated Mem
				dwCount++;
				continue;
			}
			else
			{	// Searching for list inside list
				bFoundList = MatchToken(szCmd,pwcListCmd) && bEqualPresent;
				if (bFoundList)
				{
					bWithinList = 1;
					_tcsncat(pwcListArgs,szTok,dwInputAllocLen-_tcslen(pwcListArgs)-1);	 				// Pre Allocated Mem
					_tcsncat(pwcListArgs,TEXT(" "),dwInputAllocLen-_tcslen(pwcListArgs)-1);
					continue;
				}
				_tcsncat(pwcListArgs,szTemp,dwInputAllocLen-_tcslen(pwcListArgs)-1);						// List token
				_tcsncat(pwcListArgs,TEXT(" "),dwInputAllocLen-_tcslen(pwcListArgs)-1);					// Pre Allocated Mem
				continue;
			}
		}
		bFoundList = MatchToken(szCmd,pwcListCmd) && bEqualPresent;
		if (bFoundList)
		{
			bWithinList = 1;
			_tcsncat(pwcListArgs,szTok,dwInputAllocLen-_tcslen(pwcListArgs)-1);							// Pre Allocated Mem
			_tcsncat(pwcListArgs,TEXT(" "),dwInputAllocLen-_tcslen(pwcListArgs)-1);						// space delimited tokens
			continue;
		}
		ppwcTok[dwCount] = ppwcArguments[dwLoopCount];			// Pointer Copy operation only
		dwCount++;
	}
	return dwCount;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadParserOutput()
//
//	Date of Creation	:	16th Aug 2001
//
//	Parameters			:	OUT 	PPARSER_PKT pParser,
//							IN 		DWORD 		dwCount,
//							OUT 	PDWORD 	    pdwUsed,
//							IN 		LPTSTR 		str,
//							IN 		DWORD  		dwTagType,
//							IN  	DWORD       dwConversionType
//
//	Return				:	ERROR_SUCESS
//							RETURN_NO_ERROR
//
//	Description			:	Validates the argument and fill's  with relevant info
//							in the Parser_Pkt Structure.
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadParserOutput(
		OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCount,
		OUT 	PDWORD 	    pdwUsed,
		IN 		LPTSTR 		szArg,
		IN 		DWORD  		dwTagType,
		IN  	DWORD       dwConversionType
		)
{
	DWORD dwReturn = ERROR_SUCCESS;

	BOOL bTunnel   = FALSE;
	LPTSTR szIpsec = NULL;

	pParser->Cmd[dwCount].dwCmdToken = dwTagType;
	pParser->Cmd[dwCount].dwStatus = INVALID_TOKEN;

	switch(dwConversionType)
	{
		case TYPE_STRING	:
			//
			// Loads the normal string.
			//
			dwReturn = LoadParserString(szArg,pParser,dwTagType,pdwUsed,dwCount,FALSE,NULL);
			break;

		case TYPE_BOOL		:
			//
			// Validates the yes(y) or no(n)
			//
			dwReturn = LoadBoolWithOption(szArg,pParser,dwTagType,pdwUsed,dwCount,FALSE,NULL);
			break;

		case TYPE_DWORD		:
			//
			// Loads DWORD
			//
			dwReturn = LoadDword(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_ALL		:
			//
			// First check for the boolean (yes/y/No/n)
			//
			dwReturn = LoadBoolWithOption(szArg,pParser,dwTagType,pdwUsed,dwCount,TRUE,ALL_STR);
			break;

		case TYPE_VERBOSE	:
			//
			// Check for arg 'normal' or 'verbose'
			//
			dwReturn = LoadLevel(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_CONNTYPE 	:
			//
			// Validates the connection types (all/lan/dialup)
			//
			dwReturn = LoadConnectionType(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_PROTOCOL	:
			//
			// Protocol (TCP/UDP...) validation done here
			//
			dwReturn = LoadProtocol(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_PFSGROUP 	:
			//
			// Validate and Load PFSGroup(grpmm/grp1/grp2/grp3/nopfs)
			//
			dwReturn = LoadPFSGroup(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_BOUND 	:
			//
			// Check for valid arg(permit/block/negotiate)
			//
			dwReturn = LoadQMAction(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_FORMAT	:
			//
			// Validate user show o/p format. (list/table)
			//
			dwReturn = LoadFormat(szArg,pParser,dwTagType,pdwUsed,dwCount);
 			break;

		case TYPE_MODE		:
			//
			// Validate the filtermodes..(Transport/Tunnel)
			//
			dwReturn = LoadFilterMode(szArg,pParser,dwTagType,pdwUsed,dwCount);
 			break;

		case TYPE_RELEASE	:
			//
			// Check for the release of OS type(win2k/.net)
			//
			dwReturn = LoadOSType(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_PROPERTY	:
			//
			//Registry key name
			//
			dwReturn = LoadProperty(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_PORT		:
			//
			//Port valid form 0 to 65535
			//
			dwReturn = LoadPort(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_FILTER	:
			//
			// Validate filter (Generic/specific)
			//
			dwReturn = LoadFilterType(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_STATS	:
			//
			//Ipsec or Ike
			//
			dwReturn = LoadStats(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

 		case TYPE_TUNNEL 	:
 			//
 			// Validate and convert the string into Tunnel IP
 			//
				bTunnel	 = TRUE;
		case TYPE_IP 		:
			//
			// Validate and convert the string into IP, DNS name resolves to first IP only
			//
			dwReturn = LoadIPAddrTunnel(szArg,pParser,dwTagType,pdwUsed,dwCount,bTunnel);
			break;

		case TYPE_MASK 		:
			//
			// Converts the user i/p Mask (also allows prefix )
			//
			dwReturn = LoadIPMask(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_QM_OFFER	:
			//
			// Validate Quick Mode offers here
			//
			dwReturn = LoadQMOffers(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_MM_OFFER	:
			//
			//Loads MMOffer
			//
			dwReturn = LoadMMOffers(szArg,pParser,dwTagType,pdwUsed,dwCount);
			break;

		case TYPE_DNSIP		:
			//
			//Accepts DNS name, validates IP
			//
			dwReturn = LoadDNSIPAddr(szArg,pParser,dwTagType,pdwUsed,dwCount);
	 		break;

        case TYPE_LOCATION  :
			//
			// Accepts enumeration: [local | persistent | domain]
			//
			dwReturn = LoadLocationType(szArg,pParser,dwTagType,pdwUsed,dwCount);
	 		break;

	 	case TYPE_EXPORT	:
	 		//
	 		// Checks the file name extension,if not available appends .ipsec
	 		//
			szIpsec = _tcsstr(szArg,EXPORT_IPSEC);
			if(szIpsec == NULL)
			{
				dwReturn = LoadParserString(szArg,pParser,dwTagType,pdwUsed,dwCount,TRUE,EXPORT_IPSEC);
			}
			else
			{
				dwReturn = LoadParserString(szArg,pParser,dwTagType,pdwUsed,dwCount,FALSE,NULL);
			}
			break;
		case TYPE_KERBAUTH:
			dwReturn = LoadKerbAuthInfo(szArg, pParser, dwTagType, pdwUsed, dwCount);
			break;
		case TYPE_PSKAUTH:
			dwReturn = LoadPskAuthInfo(szArg, pParser, dwTagType, pdwUsed, dwCount);
			break;
		case TYPE_ROOTCA:
			// do nothing... this is handled a different way
			break;
		default				:
			break;
	}
	if ( dwReturn == ERRCODE_ARG_INVALID )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ARG_INVALID,szArg,pParser->ValidTok[dwTagType].pwszToken);
		dwReturn	= RETURN_NO_ERROR;
	}
	else if( dwReturn == ERROR_OUTOFMEMORY )
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturn = RETURN_NO_ERROR;
	}
	else if( dwReturn == ERROR_OUT_OF_STRUCTURES )
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUT_OF_STRUCTURES,NULL);
		dwReturn = RETURN_NO_ERROR;
	}
	else if(( dwReturn != ERROR_SUCCESS ) && ( dwReturn != RETURN_NO_ERROR))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_ARG,pParser->ValidTok[dwTagType].pwszToken);
		dwReturn = RETURN_NO_ERROR;
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	SplitCmdTok()
//
//	Date of Creation	:	8th Aug 2001
//
//	Parameters			:	IN		LPTSTR szStr
//							OUT		LPTSTR szCmd
//							OUT		LPTSTR szTok
//							IN 		DWORD   dwCmdLen
//							IN		DWORD   dwTokLen
//
//	Return				:	BOOL
//
//	Description			:	This splitter  assumes
// 							1. inputs are of the type cmd = tok
// 							2. cmd & tok are allocated ptrs
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

BOOL
SplitCmdTok(
	LPTSTR szStr,
	LPTSTR szCmd,
	LPTSTR szTok,
	DWORD  dwCmdLen,
	DWORD  dwTokLen
	)
{
	LPTSTR found = NULL;
	BOOL bTest 	 = FALSE;

	found = _tcschr(szStr,_TEXT('='));		// detect =
	if ( found != NULL)						// if = found strip =
	{
		*(found) = _TEXT('\0');				// replace = with null
		_tcsncpy(szCmd,szStr,dwCmdLen);		// First part is cmd
		_tcsncpy(szTok,found+1,dwTokLen);	// Second part if tok
	}
	else
	{
		_tcsncpy(szTok,szStr,dwTokLen);
		_tcsncpy(szCmd,szStr,dwCmdLen);
	}
	if (found)
	{
		bTest = TRUE;
	}
	return bTest;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	ValidateBool()
//
//	Date of Creation	:	20th Aug 2001
//
//	Parameters			:	IN	LPTSTR ppwcTok
//
//	Return				:	BOOL
//
//	Description			:	Validates the user input (Yes/y/no/n)
//
//	History				:
//
// 	Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ValidateBool(LPTSTR szStr)
{
	DWORD dwReturn = ERROR_SUCCESS;

	if ((_tcsicmp(szStr,YES_STR) == 0) || (_tcsicmp(szStr,Y_STR) == 0))
	{
		dwReturn = ARG_YES;
	}
	else if ((_tcsicmp(szStr,NO_STR) == 0) ||(_tcsicmp(szStr,N_STR) == 0))
	{
		dwReturn = ARG_NO;
	}

	return dwReturn;

}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	IsDnsName()
//
//	Date of Creation	:	30th Aug 2001
//
//	Parameters			:	IN	szText 		// string to check for DNS name
//
//	Return				:	DWORD
//
//	Description			:	If there is an alpha character in the string,
//			   				then we consider it as a DNS name.
//
//	History				:
//
// 	Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
IsDnsName(LPTSTR szStr)
{
	BOOL bTest = FALSE;
	if ( szStr )
	{
		for (DWORD dwCount = 0; dwCount < _tcslen(szStr); ++dwCount)
	    {
			if ( _istalpha(szStr[dwCount]) )
			{
				bTest = TRUE;
			}
		}
	}
	return bTest;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CheckIFType()
//
//	Date of Creation	:	30th Aug 3001
//
//	Parameters			:	IN	szText			// String to be compared
//
//	Return				:	DWORD
//							INTERFACE_TYPE_ALL
//							INTERFACE_TYPE_LAN
//							INTERFACE_TYPE_DIALUP
//	Description			:	Validates the User Input for connection types
//							(ALL/LAN/DIALUP)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
CheckIFType ( LPTSTR SzText)
{
	DWORD dwReturn = PARSE_ERROR;

	if( _tcsicmp(SzText,IF_TYPE_ALL) == 0 )
	{
		dwReturn = INTERFACE_TYPE_ALL;				// Interface Type 'all'
	}
	else if( _tcsicmp(SzText,IF_TYPE_LAN) == 0 )
	{
		dwReturn = INTERFACE_TYPE_LAN;				// Interface Type 'lan'
	}
	else if( _tcsicmp(SzText,IF_TYPE_DIALUP) == 0)
	{
		dwReturn = INTERFACE_TYPE_DIALUP;			// Interface Type 'dialup'
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CheckLocationType()
//
//	Date of Creation	:	30th Aug 3001
//
//	Parameters			:	IN	szText			// String to be compared
//
//	Return				:	the polstore provider id
//							
//	Description			:	Validates the User Input for connection types
//							(local,persistent,domain)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
CheckLocationType ( LPTSTR SzText)
{
	DWORD dwReturn = PARSE_ERROR;

	if( _tcsicmp(SzText,LOC_TYPE_PERSISTENT) == 0 )
	{
		dwReturn = IPSEC_PERSISTENT_PROVIDER;				
	}
	else if( _tcsicmp(SzText,LOC_TYPE_LOCAL) == 0 )
	{
		dwReturn = IPSEC_REGISTRY_PROVIDER;				
	}
	else if( _tcsicmp(SzText,LOC_TYPE_DOMAIN) == 0)
	{
		dwReturn = IPSEC_DIRECTORY_PROVIDER;			
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CheckPFSGroup()
//
//	Date of Creation	:	10th Sept 2001
//
//	Parameters			:	IN	szText				// String to be compared
//
//	Return				:	DWORD
//							PFSGROUP_TYPE_P1		// 1
//							PFSGROUP_TYPE_P2		// 2
//							PFSGROUP_TYPE_MM		// 3
//
//	Description			:  	Validates the user input for PFS Groups
//							(grp1/grp2/grp3/grpmm/nopfs)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
CheckPFSGroup ( LPTSTR SzText)
{
	DWORD dwReturn = PARSE_ERROR;

	if( _tcsicmp(SzText,PFS_TYPE_P1) == 0 )
	{
		dwReturn = PFSGROUP_TYPE_P1;
	}
	else if( _tcsicmp(SzText,PFS_TYPE_P2) == 0 )
	{
		dwReturn = PFSGROUP_TYPE_P2;
	}
	else if( _tcsicmp(SzText,PFS_TYPE_P3) == 0)
	{
		dwReturn = PFSGROUP_TYPE_2048;				// PFS Group is GRP3
	}
	else if( _tcsicmp(SzText,PFS_TYPE_MM) == 0)
	{
		dwReturn = PFSGROUP_TYPE_MM;
	}
	else if(_tcsicmp(SzText,PFS_TYPE_NOPFS) == 0)
	{
		dwReturn = PFSGROUP_TYPE_NOPFS;
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	GetIpAddress()
//
//	Date of Creation	:	10th Sept 2001
//
//	Parameters			:	IN		ppwcArg		// String to be converted
//							OUT		pipAddress	// Target to be filled
//
//	Return				:	ERROR_SUCCESS
//							IP_DECODE_ERROR
//							IP_MASK_ERROR
//
//	Description			:  	Gets the ip address from the string.
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
GetIpAddress(
	IN  LPTSTR ppwcArg,
	OUT IPAddr	 *pipAddress
	)
{
    CHAR  pszIpAddr[24+1] = {0}; // ADDR_LENGTH =24
	DWORD dwStatus = 0;
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD i = 0;
	LPTSTR pszTmpPtr = NULL;

    // Make sure all characters are legal
    if (ppwcArg[ _tcsspn(ppwcArg, VALID_HEXIP) ])
    {
        dwReturn = IP_DECODE_ERROR;
        BAIL_OUT;
    }
    // make sure there are 3 and only "." (periods)
	for (i=0,pszTmpPtr=ppwcArg; ;i++)
	{
		pszTmpPtr = _tcschr(pszTmpPtr, _TEXT('.'));
		if(pszTmpPtr)
		{
			pszTmpPtr++;
		}
		else
			break;
	}
	if(i!=3)			// Invalid IPAddress is specified
	{
		dwReturn = IP_DECODE_ERROR;
        BAIL_OUT;
	}

	dwStatus = WideCharToMultiByte(CP_THREAD_ACP,0,ppwcArg,-1,pszIpAddr,24,NULL,NULL);
	if (!dwStatus)
	{
		dwReturn = IP_DECODE_ERROR;
        BAIL_OUT;
	}

    pszIpAddr[24] = '\0';

    *pipAddress = (DWORD)inet_addr(pszIpAddr);

error:
   	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	TokenToIPAddr()
//
//	Date of Creation	:	20th Sept 2001
//
//	Parameters			:	IN 		szText		// String to be converted
//							IN OUT	Address		// Target to be filled
//
//	Return				:	T2P_OK					on Success
//							T2P_NULL_STRING			on Error
//							T2P_INVALID_ADDR
//							T2P_DNSLOOKUP_FAILED
//
//	Description			:	Converts the user input string to Valid IPAddress.
//
//	History				:
//
// 	Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
TokenToIPAddr(
	IN		LPTSTR  szText,
	IN OUT	IPAddr  *pAddress,
	IN		BOOL	bTunnel,
	IN		BOOL bMask
	)
{
	DWORD  dwReturn = T2P_OK;
   	DWORD  dwAddr , dwCount;
	LPTSTR pszTmpPtr =NULL;
	int iReturn=ERROR_SUCCESS;
	char szDNSName[MAX_STR_LEN] = {0};
	struct addrinfo *pAddrInfo = NULL,*pNext=NULL;
	DWORD dwBufferSize = MAX_STR_LEN;

   	if (szText != NULL)
   	{
		if (!_tcscmp(szText,POTF_ME_TUNNEL))
		{
			*pAddress = 0;
		}
	     	else if(bTunnel)
		{
		  	dwAddr = GetIpAddress(szText,pAddress);
	       	if( (dwAddr == IP_DECODE_ERROR) || (dwAddr == IP_MASK_ERROR) )
	       	{
		 	dwReturn = T2P_INVALID_ADDR;
		}

		ADDR addr;
		addr.uIpAddr = ntohl(*pAddress);
		if (!IsValidTunnelEndpointAddress(&addr))
		{
			dwReturn = T2P_INVALID_ADDR;
		}
	}
	else if(bMask)
	{
		dwAddr = GetIpAddress(szText,pAddress);
		if(dwAddr == IP_DECODE_ERROR)
		{
			dwReturn = T2P_INVALID_ADDR;
		}
	}
	else
     	{
		if (IsDnsName(szText))
	 	{
			for ( dwCount=0,pszTmpPtr=szText; ;dwCount++)
			{
				pszTmpPtr = _tcschr(pszTmpPtr, _TEXT('x'));
				if(pszTmpPtr)
				{
					pszTmpPtr++;
				}
				else
				{
					break;
				}
			}
			if (dwCount==4)		// Old .... ip addressing format..
			{
				dwAddr = GetIpAddress(szText,pAddress);
				if (dwAddr == IP_DECODE_ERROR)
				{
					dwReturn = T2P_INVALID_ADDR;
				}
				else if (dwAddr == IP_MASK_ERROR)
				{
					dwReturn = T2P_INVALID_MASKADDR;
				}
			}
			else				// DNS name is specified
			{
				iReturn = WideCharToMultiByte(CP_THREAD_ACP, 0, szText, -1,
							  szDNSName,dwBufferSize,NULL,NULL);

				if(iReturn == 0)
				{
					//conversion failed due to some error. dont proceed . dive out of the function
					dwReturn = T2P_INVALID_ADDR;
					BAIL_OUT;
				}

				iReturn = getaddrinfo((const char*)szDNSName,NULL,NULL,&pAddrInfo);

				if (iReturn == ERROR_SUCCESS)
				{
					pNext = pAddrInfo;
					for(DWORD i=0;i< 1;i++)
					{
						memcpy(pAddress,(ULONG *) &(((sockaddr_in *)(pNext->ai_addr))->sin_addr.S_un.S_addr), sizeof(ULONG));
						pNext=pNext->ai_next;
					}
					// free pAddrInfo after usage
					if (pAddrInfo)
					{
						freeaddrinfo(pAddrInfo);
					}
				}
				else
				{
					dwReturn = T2P_DNSLOOKUP_FAILED;
				}
			}
		}
  		else  												// good old dotted notation
  		{
		  	dwAddr = GetIpAddress(szText,pAddress);
	       	if (dwAddr == IP_DECODE_ERROR)
	       	{
			 	dwReturn = T2P_INVALID_ADDR;
			}
			else if (dwAddr == IP_MASK_ERROR)
			{
				dwReturn = T2P_INVALID_MASKADDR;
			}
			}
		}
	}
	else
	{
		dwReturn = T2P_NULL_STRING;
	}
error:
   	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	TokenToProperty()
//
//	Date of Creation	:	28th Sept 2001
//
//	Parameters			:	IN 		szText
//
//	Return				:	DWORD
//	Description			:	Validates the arguments for logging
//							(ipsecdiagnostics/ikelogging/strongcrlcheck
//							/ipsecloginterval/ipsecexempt)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
DWORD
TokenToProperty( LPTSTR SzText)
{
	DWORD dwReturn = PARSE_ERROR;

	if( _tcsicmp(SzText,PROPERTY_TYPE_ENABLEDIGNO) == 0)
	{
		dwReturn = PROPERTY_ENABLEDIGNO;
	}
	else if( _tcsicmp(SzText,PROPERTY_TYPE_IKELOG) == 0)
	{
		dwReturn = PROPERTY_IKELOG;
	}
	else if( _tcsicmp(SzText,PROPERTY_TYPE_CRLCHK) == 0)
	{
		dwReturn = PROPERTY_CRLCHK;						// It is Strongcrlchk
	}
	else if( _tcsicmp(SzText,PROPERTY_TYPE_LOGINTER) == 0)
	{
		dwReturn = PROPERTY_LOGINTER;
	}
	else if( _tcsicmp(SzText,PROPERTY_TYPE_EXEMPT) == 0)
	{
		dwReturn = PROPERTY_EXEMPT;
	}
	else if( _tcsicmp(SzText,PROPERTY_TYPE_BOOTMODE) == 0)
	{
		dwReturn = PROPERTY_BOOTMODE;
	}
	else if( _tcsicmp(SzText,PROPERTY_TYPE_BOOTEXEMP) == 0)
	{
		dwReturn = PROPERTY_BOOTEXEMP;
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CheckProtoType()
//
//	Date of Creation	:	20th Sept 2001
//
//	Parameters			:	IN 		szText
//
//	Return				:	DWORD
//
//	Description			:	Validates the Argument for the token Protocol.
//							(ANY|ICMP|TCP|UDP|RAW)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
DWORD
CheckProtoType(
	LPWSTR SzText,
	PDWORD pdwProto
	)
{
	DWORD dwReturn = PARSE_ERROR;
	DWORD dwProto = 0;
	if( _tcsicmp(SzText,IF_TYPE_ANY) == 0)			// Do protocol type validation here
	{
		dwProto = PROT_ID_ANY;
		dwReturn = ERROR_SUCCESS;
	}
	else if( _tcsicmp(SzText,IF_TYPE_ICMP) == 0)
	{
		dwProto = PROT_ID_ICMP;
		dwReturn = ERROR_SUCCESS;
	}
	else if( _tcsicmp(SzText,IF_TYPE_TCP) == 0)
	{
		dwProto = PROT_ID_TCP;
		dwReturn = ERROR_SUCCESS;
	}
	else if( _tcsicmp(SzText,IF_TYPE_UDP) == 0)
	{
		dwProto = PROT_ID_UDP;
		dwReturn = ERROR_SUCCESS;
	}
	else if( _tcsicmp(SzText,IF_TYPE_RAW) == 0)
	{
		dwProto = PROT_ID_RAW;
		dwReturn = ERROR_SUCCESS;
	}
	else
	{
		dwReturn = ConvertStringToDword(SzText, &dwProto);
	}

	if ((dwReturn == ERROR_SUCCESS) && (dwProto < 256))
	{
		*pdwProto = dwProto;
	}
	else
	{
		dwReturn = PARSE_ERROR;
	}

	return dwReturn;
}
//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	MatchEnumTagToTagIndex()
//
//	Date of Creation	:	26th Sept 2001
//
//	Parameters			:	IN 		szText
//							IN  	*pParser
//
//	Return				: 	DWORD	( TagIndex)
//
//	Description			:	Based on Tag, Returns TagIndex (string to dword)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
DWORD
MatchEnumTagToTagIndex(
		IN      LPWSTR     szToken,		// Input Token
		IN  	PPARSER_PKT pParser
	)

{
	DWORD dwNum = 0;
	DWORD dwIndex = PARSE_ERROR;
	DWORD dwCount;

 	MatchEnumTag(g_hModule,szToken,pParser->MaxTok,pParser->ValidTok,&dwNum);

	if (dwNum)
	{	// Convert the output of MatchEnumTag into the TagIndex
		for (dwCount =0;dwCount < pParser->MaxTok;dwCount++)
		{
			if (dwNum == pParser->ValidTok[dwCount].dwValue)
			{
				dwIndex = dwCount;
				break;
			}
		}
	}
	return dwIndex;
}
//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CheckBound()
//
//	Date of Creation	:	04th Sept 2001
//
//	Parameters			:	IN 		szText			// String to be compared
//
//	Return				: 	DWORD
//							BOUND_TYPE_PERMIT		// 1
//							BOUND_TYPE_BLOCK		// 2
//							BOUND_TYPE_NEGOTIATE	// 3
//	Description			:	Validates the argument for the token action
//							(permit|block|negotiate)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
DWORD
CheckBound ( LPTSTR SzText)
{
	DWORD dwReturn = PARSE_ERROR;

	if( _tcsicmp(SzText,QMSEC_PERMIT_STR) 	== 0 )
	{
		dwReturn = TOKEN_QMSEC_PERMIT;
	}
	else if( _tcsicmp(SzText,QMSEC_BLOCK_STR) == 0 )
	{
		dwReturn = TOKEN_QMSEC_BLOCK;
	}
	else if( _tcsicmp(SzText,QMSEC_NEGOTIATE_STR) == 0)
	{
		dwReturn = TOKEN_QMSEC_NEGOTIATE;
	}

	return dwReturn;
}
//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	IsWithinLimit()
//
//	Date of Creation	:	29th Sept 2001
//
//	Parameters			:	IN DWORD	data
//							IN DWORD	min
//							IN DWORD	max
//
//	Return				: 	DWORD
//							return 1 if success
//							return 0 if fail
//
//	Description			:	Checks for limits
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
BOOL
IsWithinLimit(
	DWORD dwData,
	DWORD dwMin,
	DWORD dwMax
	)
{
	return ( (dwData >= dwMin ) && ( dwData <= dwMax ) ) ? TRUE : FALSE ;
}


//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	TokenToDNSIPAddr()
//
//	Date of Creation	:	29th Sept 2001
//
//	Parameters			:	IN 		szText		// String to be converted
//							IN OUT	Address		// Target to be filled
//
//	Return				:	DWORD
//
//	Description			:	Validates i/p String and resolves to valid IPAddress(s)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
DWORD
TokenToDNSIPAddr(
	IN 		LPTSTR 		szText,
	IN OUT 	PDNSIPADDR  pDNSAddress,
	IN OUT 	PDWORD 		*ppdwUsed
	)
{
	DWORD  dwReturn = T2P_OK;
  	DWORD  dwCount,dwStatus,i=0,n;
	IPAddr address;

	int iReturn=ERROR_SUCCESS;
	char szDNSName[MAX_STR_LEN] = {0};
	struct addrinfo *pAddrInfo = NULL,*pNext=NULL;
	DWORD dwBufferSize = MAX_STR_LEN;

   	if (szText == NULL)
   	{
		dwReturn = T2P_NULL_STRING;
		BAIL_OUT;
	}
	if (IsDnsName(szText))									// 	Any Alpha ==> DNS name provided not (0x)
	{
		dwCount = CheckCharForOccurances(szText,_TEXT('x'));
		if (dwCount==4)
		{
			i = CheckCharForOccurances(szText,_TEXT('.'));
			if (i!=3)
			{
				dwReturn = T2P_INVALID_ADDR;
				BAIL_OUT;
			}

			dwStatus = WideCharToMultiByte(CP_THREAD_ACP,0,szText,-1,szDNSName,dwBufferSize,NULL,NULL);
			if (!dwStatus)
			{
				dwReturn = T2P_INVALID_ADDR;
				BAIL_OUT;
			}
			address = (ULONG)inet_addr(szDNSName);

			if(address == INADDR_NONE)
			{
				dwReturn = T2P_INVALID_ADDR;
				BAIL_OUT;
			}

			pDNSAddress->pszDomainName  = NULL;			// Old IPAddrs notation so dns name fill with zero
			pDNSAddress->puIpAddr 		= NULL;
			pDNSAddress->puIpAddr = (ULONG *) malloc(sizeof(ULONG));

			if(pDNSAddress->puIpAddr == NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}

			if (**ppdwUsed > MAX_ARGS_LIMIT)
			{
				free(pDNSAddress->puIpAddr);
				dwReturn = ERROR_OUT_OF_STRUCTURES;
				BAIL_OUT;
			}
			g_AllocPtr[**ppdwUsed] = pDNSAddress->puIpAddr ;
			(**ppdwUsed)++;
			memcpy(&(pDNSAddress->puIpAddr[0]),(ULONG *)&address, sizeof(ULONG));
			pDNSAddress->dwNumIpAddresses = 1; // only one IP sent
		}
		else
		{
			iReturn = WideCharToMultiByte(CP_THREAD_ACP, 0, szText, -1,
						  szDNSName,dwBufferSize,NULL,NULL);

			if(iReturn == 0)
			{
				//conversion failed due to some error. don't proceed, dive out of the function
				dwReturn = T2P_INVALID_ADDR;
				BAIL_OUT;
			}

			iReturn = getaddrinfo((const char*)szDNSName,NULL,NULL,&pAddrInfo);

			if (iReturn == ERROR_SUCCESS)
			{
				pDNSAddress->pszDomainName = NULL;
				pDNSAddress->pszDomainName = (TCHAR *)calloc(1,(_tcslen(szText) + 1)*sizeof(TCHAR));
				if(pDNSAddress->pszDomainName == NULL)
				{
					dwReturn = ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}
				_tcsncpy(pDNSAddress->pszDomainName,szText,_tcslen(szText));

				if (**ppdwUsed > MAX_ARGS_LIMIT)
				{
					free(pDNSAddress->pszDomainName);
					dwReturn = ERROR_OUT_OF_STRUCTURES;
					BAIL_OUT;
				}
				g_AllocPtr[**ppdwUsed] = pDNSAddress->pszDomainName;
				(**ppdwUsed)++;

				pNext = pAddrInfo;
				for(n=1;pNext = pNext->ai_next;	n++);		// First count no. of IP's resolved..

				pDNSAddress->dwNumIpAddresses 	= n;		// n starts from zero
				pDNSAddress->puIpAddr 			= NULL;
				pDNSAddress->puIpAddr = (ULONG *) malloc(sizeof(ULONG)* pDNSAddress->dwNumIpAddresses);
				if(pDNSAddress->puIpAddr == NULL)
				{
					dwReturn = ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}

				if (**ppdwUsed > MAX_ARGS_LIMIT)
				{
					free(pDNSAddress->puIpAddr);
					dwReturn = ERROR_OUT_OF_STRUCTURES;
					BAIL_OUT;
				}
				g_AllocPtr[**ppdwUsed] = pDNSAddress->puIpAddr ;
				(**ppdwUsed)++;

				pNext = pAddrInfo;
				for(DWORD j=0;j< n;j++)
				{
					memcpy(&(pDNSAddress->puIpAddr[j]),(ULONG *) &(((sockaddr_in *)(pNext->ai_addr))->sin_addr.S_un.S_addr), sizeof(ULONG));
					pNext=pNext->ai_next;
				}
				// free pAddrInfo after usage
				if (pAddrInfo)
				{
					freeaddrinfo(pAddrInfo);
				}
			}
			else
			{
				dwReturn = T2P_DNSLOOKUP_FAILED;
				pDNSAddress->pszDomainName = NULL;
			}
		}
	}
	else		// OLD .... notation
	{
		i = CheckCharForOccurances(szText,_TEXT('.'));
		if (i!=3)
		{
			dwReturn = T2P_INVALID_ADDR;
			BAIL_OUT;
		}

		iReturn = WideCharToMultiByte(CP_THREAD_ACP,0,szText,-1,szDNSName,dwBufferSize,NULL,NULL);
		if(iReturn == 0)
		{
			dwReturn = T2P_INVALID_ADDR;
			BAIL_OUT;
		}

		address = (ULONG)inet_addr(szDNSName);

		pDNSAddress->pszDomainName = NULL;
		pDNSAddress->puIpAddr = NULL;
		pDNSAddress->puIpAddr = (ULONG *) malloc(sizeof(ULONG));
		if(pDNSAddress->puIpAddr == NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

		if (**ppdwUsed > MAX_ARGS_LIMIT)
		{
			free(pDNSAddress->puIpAddr);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}
		g_AllocPtr[**ppdwUsed] = pDNSAddress->puIpAddr ;
		(**ppdwUsed)++;
		memcpy(&(pDNSAddress->puIpAddr[0]),(ULONG *)&address, sizeof(ULONG));
		pDNSAddress->dwNumIpAddresses = 1; 					// only one IP sent
	}
error:
   	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	RemoveRootcaAuthMethods()
//
//	Date of Creation	:	22nd Aug 2001
//
//	Parameters			:	IN      LPWSTR          *ppwcArguments,	// Input stream
//							IN      DWORD           dwArgCount,		// Input arg count
//							IN      DWORD			dwCurrentIndex,	// Input current arg index
//  						IN      PPARSER_PKT     pParser,		// contains the MaxTok
//							IN      LPTSTR          szAnotherList,	// Another ListCmd also present ...
//  						OUT		PSTA_MM_AUTH_METHODS 			*paRootcaAuthMethods,	// o/p array of auth methods
//  						OUT 	LPTSTR 			*ppwcTok,		// i/p stream stripped of list cmds
//							OUT		PDWORD			pdwNumRootcaAuthMethods		// Number of the list Tokens
//							IN		DWORD			dwInputAllocLen // The max allocation for ppwcListArgs
//
//	Return				:	DWORD
//
//	Description			:	Separates the list and non list commands..
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
RemoveRootcaAuthMethods
(
	IN	LPTSTR		*ppwcArguments,	// Input stream
	IN	DWORD		dwArgCount,		// Input arg count
	IN	DWORD		dwCurrentIndex,	// Input current arg index
	IN	PPARSER_PKT	pParser,		// contains the MaxTok
	IN	LPTSTR		szAnotherList,	// Another ListCmd also present ...
	OUT	PSTA_MM_AUTH_METHODS *paRootcaAuthMethods,	// o/p stream containing the list args		// Needs Pre Allocated Mem
	OUT	LPTSTR		*ppwcTok,		// i/p stream stripped of list cmds			// No Mem allocation needed...
																					// only pointer copy
	OUT	PDWORD		pdwNumRootcaAuthMethods,	// Number of the List Tokens
	IN	DWORD		dwInputAllocLen,
	OUT PDWORD		pdwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwLoopCount	= 0;
	DWORD dwCount = 0;
	DWORD dwRootcaCount = 0;
	DWORD dwNum = 0;

	_TCHAR szCmd[MAX_STR_LEN]  		= {0};
	_TCHAR szTok[MAX_STR_LEN]  		= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};
	BOOL bEqualPresent;
	BOOL bFoundRootca;

	for(dwLoopCount = dwCurrentIndex;dwLoopCount < dwArgCount;dwLoopCount++)
	{
		bFoundRootca = FALSE;
		if (_tcslen(ppwcArguments[dwLoopCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwLoopCount],MAX_STR_LEN-1);
			// szTemp contains the cmd=arg

			bEqualPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
			if (bEqualPresent)
			{
				dwNum = 0;
				MatchEnumTag(g_hModule,szTemp,pParser->MaxTok,pParser->ValidTok,&dwNum);
				if (!dwNum && (_tcsnicmp(szCmd, POTF_OAKAUTH_CERT, _tcslen(POTF_OAKAUTH_CERT)-1) == 0))
				{
					PSTA_MM_AUTH_METHODS pRootcaInfo = NULL;
					bFoundRootca = TRUE;
					if (ProcessEscapedCharacters(szTok) != ERROR_SUCCESS)
					{
						dwReturn = ERROR_INVALID_PARAMETER;
						BAIL_OUT;
					}
					dwReturn = GenerateRootcaAuthInfo(&pRootcaInfo, szTok);
					if (dwReturn != ERROR_SUCCESS)
					{
						BAIL_OUT;
					}
					pRootcaInfo->dwSequence = dwCount;
					paRootcaAuthMethods[dwRootcaCount++] = pRootcaInfo;
				}
			}
		}

		if (!bFoundRootca)
		{
			ppwcTok[dwCount++] = ppwcArguments[dwLoopCount];
		}
	}
	*pdwNumRootcaAuthMethods = dwRootcaCount;
error:
	*pdwCount = dwCount;
	return dwReturn;
}


//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	TokenToType()
//
//	Date of Creation	:	20th Aug 2001
//
//	Parameters			:	IN 		szText
//
//	Return				:	DWORD
//
//	Description			:	Validates the argument for filtertype (generic/specific)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
TokenToType( LPTSTR pszText)
{
	DWORD dwReturn = PARSE_ERROR;

	if( _tcsicmp(pszText,FILTER_TYPE_GENERIC_STR) == 0)
	{
		dwReturn = FILTER_GENERIC;
	}
	else if( _tcsicmp(pszText,FILTER_TYPE_SPECIFIC_STR) == 0)
	{
		dwReturn = FILTER_SPECIFIC;
	}

	return dwReturn;
}
//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	TokenToStats()
//
//	Date of Creation	:	29th Aug 2001
//
//	Parameters			:	IN 		szText
//
//	Return				:	DWORD
//
//	Description			:	Validates the argument to the token statistics. (all/ike/ipsec)
//
//	History				:
//
//	Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
TokenToStats( LPTSTR pszText)
{
	DWORD dwReturn = PARSE_ERROR;

	if( _tcsicmp(pszText,STATS_ALL_STR) == 0)
	{
		dwReturn = STATS_ALL;
	}
	else if( _tcsicmp(pszText,STATS_IKE_STR)	== 0)
	{
		dwReturn = STATS_IKE;
	}
	else if( _tcsicmp(pszText,STATS_IPSEC_STR) == 0)
	{
		dwReturn = STATS_IPSEC;
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	PrintQMOfferError()
//
//	Date of Creation	:	20th dec 2001
//
//	Parameters			:	IN		dwStatus
//							IN		pPArser
//							IN 		dwTagType			// String to be compared
//
//	Return				:	NONE
//
//	Description			:	Prints the QMOffer error messages
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
VOID
PrintQMOfferError(
	IN DWORD dwStatus,
	IN PPARSER_PKT pParser,
	IN DWORD dwTagType
	)
{
	switch(dwStatus)							// Print the specified QMOffer error messages.
	{
		case T2P_NULL_STRING			:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NULL_STRING);
			break;
		case T2P_P2_SECLIFE_INVALID		:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SECLIFE_INVALID,P2_Sec_LIFE_MIN,P2_Sec_LIFE_MAX);
			break;
		case T2P_P2_KBLIFE_INVALID		:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_KBLIFE_INVALID,P2_Kb_LIFE_MIN,P2_Kb_LIFE_MAX);
			break;
		case T2P_INVALID_P2REKEY_UNIT	:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_P2REKEY_INVALID);
			break;
		case T2P_INVALID_HASH_ALG		:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_HASH_INVALID);
			break;
		case T2P_INCOMPLETE_ESPALGS		:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ESP_INCOMPLETE);
			break;
		case T2P_GENERAL_PARSE_ERROR	:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_QMOFFER_INVALID);
			break;
		case T2P_DUP_ALGS				:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DUPALG_INVALID,pParser->ValidTok[dwTagType].pwszToken);
			break;
		case T2P_NONE_NONE				:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NONE_INVALID);
			break;
		case T2P_INVALID_IPSECPROT		:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_IPSECPROT_INVALID);
			break;
		case T2P_P2_KS_INVALID			:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_KS_INVALID);
			break;
		case T2P_AHESP_INVALID			:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_AHESP_INVALID);
			break;
		default							:
			break;
	}
}
//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	ValidateSplServer()
//
//	Date of Creation	:	2nd Jan 2002
//
//	Parameters			:	IN 		szText			// String to be compared
//
//	Return				:	DWORD
//  						SERVER_WINS
//  						SERVER_DHCP
//  						SERVER_DNS
//  						SERVER_GATEWAY
//  						IP_ME
//  						IP_ANY
//
//	Description			:	Checks for the Spl server types
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
DWORD
ValidateSplServer(IN LPTSTR pszText)
{
	DWORD dwReturn = NOT_SPLSERVER;

	if(_tcsicmp(pszText,SERVER_WINS_STR)==0)
	{										// Allow spl servers here
		dwReturn  = SERVER_WINS;
	}
	else if(_tcsicmp(pszText,SERVER_DHCP_STR)==0)
	{
		dwReturn  = SERVER_DHCP;
	}
	else if(_tcsicmp(pszText,SERVER_DNS_STR)==0)
	{
		dwReturn  = SERVER_DNS;
	}
	else if(_tcsicmp(pszText,SERVER_GATEWAY_STR)==0)
	{
		dwReturn  = SERVER_GATEWAY;
	}
	else if(_tcsicmp(pszText,IP_ME_STR)==0)		// Take care about 'me' and 'any' tokens here
	{
		dwReturn  = IP_ME;
	}
	else if(_tcsicmp(pszText,IP_ANY_STR)==0)
	{
		dwReturn  = IP_ANY;
	}
	return dwReturn;
}
//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	PrintIPError()
//
//	Date of Creation	:	20th dec 2001
//
//	Parameters			:	IN		dwStatus
//							IN 		szText			// String to be compared
//
//	Return				:	NONE
//
//	Description			:	Prints the IP validation errors
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
VOID
PrintIPError(IN DWORD dwStatus, IN LPTSTR  pszText)
{
	switch(dwStatus)				// Print error message for IPAddress
	{
		case	T2P_DNSLOOKUP_FAILED	:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DNSLOOKUP_FAILED,pszText);
			break;
		case	T2P_INVALID_MASKADDR	:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_MASK,pszText);
			break;
		case	T2P_INVALID_ADDR		:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_ADDR,pszText);
			break;
		case	T2P_NULL_STRING			:
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_ARG);
			break;
		case	ERROR_OUTOFMEMORY		:
			PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
			break;
		case	ERROR_OUT_OF_STRUCTURES		:
			PrintErrorMessage(WIN32_ERR,ERROR_OUT_OF_STRUCTURES,NULL);
			break;
		default							:
			PrintErrorMessage(WIN32_ERR,dwStatus,NULL);
			break;
	}
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	InitializeGlobalPointers()
//
//	Date of Creation	:	9th Jan 2002
//
//	Parameters			:
//
//	Return				:	NONE
//
//	Description			:	Initialize Global pointers to NULL
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////
VOID
InitializeGlobalPointers(
	VOID
	)
{
	DWORD dwMaxArgs = 0;

	for(dwMaxArgs=0;dwMaxArgs<IPSEC_MAX_QM_OFFERS;dwMaxArgs++)
	{
		g_pQmsec[dwMaxArgs] = NULL;			// Initialize all global pointers to NULL
	}
	for(dwMaxArgs=0;dwMaxArgs<IPSEC_MAX_MM_OFFERS;dwMaxArgs++)
	{
		g_pMmsec[dwMaxArgs] = NULL;
	}

	for(dwMaxArgs=0;dwMaxArgs<MAX_ARGS;dwMaxArgs++)
	{
		g_AllocPtr[dwMaxArgs]    = NULL;
		g_paRootca[dwMaxArgs] = NULL;
	}
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadParserString()
//
//	Date of Creation	:	8th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//							IN 	BOOL 		bAppend,
//							IN 	LPTSTR 		szAppend
//
//	Return				:	ERROR_SUCESS
//							RETURN_NO_ERROR
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the strings, If specified appends the given string
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////


DWORD
LoadParserString(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount,
	IN 	BOOL 		bAppend,
	IN 	LPTSTR 		pszAppend
	)
{
	LPTSTR pszArg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwInputLen = 0;

	if(_tcsicmp(pszInput,_TEXT("")) == 0)
	{
		dwReturn = ERROR_SHOW_USAGE;
	}
	else
	{
		if(!bAppend)					// Just called for load string. do it
		{
			dwInputLen = _tcslen(pszInput);
			pszArg = (LPTSTR)calloc(dwInputLen+1 ,sizeof(_TCHAR));
			if(pszArg == NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			if (*pdwUsed > MAX_ARGS_LIMIT)
			{
				free(pszArg);
				dwReturn = ERROR_OUT_OF_STRUCTURES;
				BAIL_OUT;
			}

			g_AllocPtr[(*pdwUsed)++] = pszArg;
			_tcsncpy((LPTSTR)pszArg,pszInput,dwInputLen);
		}
		else						// Here load the string and also do some appending operation
		{
			if(_tcsicmp(pszAppend,_TEXT("")) == 0)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_ARG,pParser->ValidTok[dwTagType].pwszToken);
				dwReturn = RETURN_NO_ERROR;
			}
			else
			{
				dwInputLen = _tcslen(pszInput)+_tcslen(pszAppend);
				pszArg = (LPTSTR)calloc(dwInputLen+1,sizeof(_TCHAR));
				if(pszArg == NULL)
				{
					dwReturn = ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}

				if (*pdwUsed > MAX_ARGS_LIMIT)
				{
					free(pszArg);
					dwReturn = ERROR_OUT_OF_STRUCTURES;
					BAIL_OUT;
				}

				g_AllocPtr[(*pdwUsed)++] = pszArg;
				_tcsncpy((LPTSTR)pszArg,pszInput,dwInputLen);
				_tcsncat((LPTSTR)pszArg,pszAppend,dwInputLen-_tcslen(pszArg));
			}
		}
		pParser->Cmd[dwCount].pArg = (PVOID)pszArg;
		pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadDword()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERROR_INVALID_OPTION_VALUE
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the input string and converts into DWORD
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadDword(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD  dwReturn = ERROR_SUCCESS;
	DWORD  dwStatus = 0;
	PDWORD pdwArg	= NULL;

	pdwArg = (PDWORD)malloc(sizeof(DWORD));
	if(pdwArg == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else				// Convert string to into DWORD and load it.
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwArg);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwArg;
		dwStatus = _stscanf(pszInput,_TEXT("%u"),pdwArg);
		if (dwStatus)
		{
			pParser->Cmd[dwCount].pArg = pdwArg;
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;
		}
		else
		{
			dwReturn = ERROR_INVALID_OPTION_VALUE;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadBoolWithOption()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERROR_INVALID_OPTION_VALUE
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates Yes/No, And all checks for Keyword 'all'
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadBoolWithOption(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount,
	IN	BOOL 		bOption,
	IN	LPTSTR 		pszCheckKeyWord
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	BOOL  *pbArg = NULL;

	pbArg = (BOOL *)malloc(sizeof(BOOL));

	if(pbArg == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{// Just check for a boolean (Yes/No)

		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pbArg);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}
		g_AllocPtr[(*pdwUsed)++] = pbArg;
		dwStatus = ValidateBool(pszInput);
		if(dwStatus == ARG_NO)
		{
			*pbArg = FALSE;
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;
		}
		else if(dwStatus == ARG_YES)
		{
			*pbArg = TRUE;
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;
		}
		else
		{
			if(!bOption)
			{
				dwReturn = ERROR_SHOW_USAGE;
				BAIL_OUT;
			}
		}
		if(bOption)		// Not only boolean and also check for keywords like 'all'
		{
			if(_tcsicmp(pszCheckKeyWord,_TEXT("")) != 0)
			{
				if(_tcsicmp(pszCheckKeyWord,ALL_STR) == 0)		// Check for 'all' key word
				{												// If it is all then fill yes
						*pbArg = TRUE;
						pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;
				}
				else
				{
					dwReturn = ERROR_SHOW_USAGE;
				}
			}
			else
			{

			}
		}
		pParser->Cmd[dwCount].pArg = (PVOID)pbArg;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadLevel()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount
//
//	Return				:	ERROR_SUCESS
//							ERROR_INVALID_OPTION_VALUE
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument for token level
//							(verbose/normal)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadLevel(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	PBOOL pbLevel = NULL;

	pbLevel = (BOOL *)malloc(sizeof(BOOL));
	if(pbLevel == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		// Validate and load level=verbose/normal
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pbLevel);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pbLevel;
		if (MatchToken(pszInput,ARG_TOKEN_STR_VERBOSE) )
		{
			*pbLevel = TRUE;
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;
		}
		else if (MatchToken(pszInput,ARG_TOKEN_STR_NORMAL))
		{
			*pbLevel = FALSE;
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;
		}
		else
		{
			dwReturn = ERROR_SHOW_USAGE;
		}
		pParser->Cmd[dwCount].pArg = (PVOID)pbLevel;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadConnectionType()
//
//	Date of Creation	:	08th Aug 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument for token 'connection type'
//							(lan/dialup/all)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadConnectionType(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD	 	pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwConnType = NULL;

	pdwConnType = (PDWORD)malloc(sizeof(DWORD));

	if(pdwConnType == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwConnType);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwConnType;
		dwStatus = CheckIFType (pszInput);		// Check for connection type (all/lan/dialup)
		if (dwStatus == PARSE_ERROR)
		{
			dwReturn = ERRCODE_ARG_INVALID;
		}
		else
		{
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN ;
			*pdwConnType = dwStatus;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwConnType;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadLocationType()
//
//	Date of Creation	:	08th Aug 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument for token 'location type'
//							(boot/local/domain)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadLocationType(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD	 	pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwLocType = NULL;

	pdwLocType = (PDWORD)malloc(sizeof(DWORD));

	if(pdwLocType == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwLocType);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwLocType;
		dwStatus = CheckLocationType (pszInput);
		if (dwStatus == PARSE_ERROR)
		{
			dwReturn = ERRCODE_ARG_INVALID;
		}
		else
		{
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN ;
			*pdwLocType = dwStatus;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwLocType;
		}
	}
error:
	return dwReturn;
}



//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadProtocol()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument for protocol
//							(TCP/UDP...)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadProtocol(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwProto = NULL;

	pdwProto = (PDWORD)malloc(sizeof(DWORD));

	if(pdwProto == NULL )
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwProto);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwProto;
		DWORD dwProto = 0;
		dwStatus = CheckProtoType (pszInput, &dwProto);	// Check for all valid protocols
		if (dwStatus == PARSE_ERROR)
		{
			dwReturn	= ERRCODE_ARG_INVALID;
		}
		else
		{
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN ;
			*pdwProto = dwProto;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwProto;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadPFSGroup()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument for pfs group
//							(grp1/grp2/grp3/grpmm/nopfs)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadPFSGroup(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwPFSGroup = NULL;

	pdwPFSGroup = (PDWORD)malloc(sizeof(DWORD));

	if(pdwPFSGroup == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwPFSGroup);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwPFSGroup;
		dwStatus = CheckPFSGroup(pszInput);
		if (dwStatus == PARSE_ERROR)
		{
			dwReturn	= ERRCODE_ARG_INVALID;
		}
		else								// It is not valid PFSGroup
		{
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN ;
			*pdwPFSGroup = dwStatus;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwPFSGroup;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadQMAction()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERROR_INVALID_OPTION_VALUE
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the action types.
//							(Permit/Block/Negotiate)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadQMAction(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwAction = NULL;

	pdwAction = (PDWORD )malloc(sizeof(DWORD));
	if(pdwAction == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwAction);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwAction;
		dwStatus = CheckBound(pszInput);
		if (dwStatus == PARSE_ERROR)
		{
			dwReturn	= ERRCODE_ARG_INVALID;		// permit/block/negotiate
		}
		else
		{
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN ;
			*pdwAction = dwStatus;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwAction;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadFormat()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument for format. (List/Table)
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadFormat(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	PBOOL pbFormat = NULL;

	pbFormat = (PBOOL)malloc(sizeof(BOOL));
	if(pbFormat == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pbFormat);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pbFormat;
		if( _tcsicmp(pszInput,TYPE_STR_LIST) == 0 )
		{
			*pbFormat = FALSE;
			pParser->Cmd[dwCount].pArg = (PVOID)pbFormat;
			pParser->Cmd[dwCount].dwStatus  = VALID_TOKEN;
		}
		else if( _tcsicmp(pszInput,TYPE_STR_TABLE) == 0 )
		{
			*pbFormat = TRUE;
			pParser->Cmd[dwCount].pArg = (PVOID)pbFormat;
			pParser->Cmd[dwCount].dwStatus  = VALID_TOKEN;
		}
		else					// It is not a valid arg for format
		{
			dwReturn	= ERRCODE_ARG_INVALID;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadFilterMode()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument and fill's  with relevant info
//							in the Parser_Pkt Struct.
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadFilterMode(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	PDWORD pdwFilterMode = NULL;
	pdwFilterMode = (PDWORD)malloc(sizeof(DWORD));

	if(pdwFilterMode == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwFilterMode);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwFilterMode;
		if( _tcsicmp(pszInput,TYPE_STR_TRANSPORT) == 0 )	// Is it Transport filter
		{
			*pdwFilterMode = TYPE_TRANSPORT_FILTER;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwFilterMode;
			pParser->Cmd[dwCount].dwStatus  = VALID_TOKEN;
		}
		else if	( _tcsicmp(pszInput,TYPE_STR_TUNNEL) == 0 )	// Is it Tunnel filter
		{
			*pdwFilterMode = TYPE_TUNNEL_FILTER;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwFilterMode;
			pParser->Cmd[dwCount].dwStatus  = VALID_TOKEN;
		}
		else
		{
			dwReturn	= ERRCODE_ARG_INVALID;
		}
	}
error:
	return dwReturn;
}


//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadOSType()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument.(.net/win2k)
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadOSType(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn   = ERROR_SUCCESS;
	PDWORD pdwOSType = NULL;
	pdwOSType = (PDWORD)malloc(sizeof(DWORD));

	if(pdwOSType == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwOSType);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwOSType;

		if((_tcsicmp(pszInput,RELEASE_WIN2K_STR) == 0))			// Is OS is WIN2K
		{
			*pdwOSType = TOKEN_RELEASE_WIN2K;
			pParser->Cmd[dwCount].dwStatus   = VALID_TOKEN;
			pParser->Cmd[dwCount].pArg       = pdwOSType;
		}
		else if((_tcsicmp(pszInput,RELEASE_DOTNET_STR) == 0))	// Is OS is .NET
		{
			*pdwOSType = TOKEN_RELEASE_DOTNET;
			pParser->Cmd[dwCount].dwStatus   = VALID_TOKEN;
			pParser->Cmd[dwCount].pArg       = pdwOSType;
		}
		else
		{
			pParser->Cmd[dwCount].pArg       = NULL;
			dwReturn	= ERRCODE_ARG_INVALID;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadProperty()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument property.
//							(ipsecdiagnostics/ikelogging/strongcrlcheck
//							/ipsecloginterval/ipsecexempt)
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadProperty(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwProperty = NULL;

	pdwProperty = (PDWORD)malloc(sizeof(DWORD));

	if(pdwProperty == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwProperty);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwProperty;
		dwStatus = TokenToProperty(pszInput);
		if (dwStatus == PARSE_ERROR)
		{
			dwReturn	= ERRCODE_ARG_INVALID;
		}
		else
		{
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN ;
			*pdwProperty = dwStatus;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwProperty;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadPort()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERROR_INVALID_OPTION_VALUE
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the port (Should be less than 64535).
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadPort(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwPort = NULL;

	pdwPort = (PDWORD)malloc(sizeof(DWORD));
	if(pdwPort == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwPort);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwPort;
		dwStatus = _stscanf(pszInput,_TEXT("%u"),pdwPort);
		if (dwStatus)		// Port should be less than 64535
		{
			if((*pdwPort) < MAX_PORT)
			{
				pParser->Cmd[dwCount].pArg = (PVOID)pdwPort;
				pParser->Cmd[dwCount].dwStatus =  VALID_TOKEN ;
			}
			else
			{
				dwReturn = RETURN_NO_ERROR;
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_PORT_INVALID,MAX_PORT);
			}
		}
		else
		{
			dwReturn = ERROR_INVALID_OPTION_VALUE;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadFilterType()
//
//	Date of Creation	:	08th JAn 2002
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument for filtertype.
//							(Generic/Specific)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadFilterType(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwFilterType = NULL;

	pdwFilterType = (PDWORD)malloc(sizeof(DWORD));

	if(pdwFilterType == NULL )
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwFilterType);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwFilterType;
		dwStatus = TokenToType(pszInput);
		if (dwStatus == PARSE_ERROR)
		{
			dwReturn	= ERRCODE_ARG_INVALID;
		}
		else
		{
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN ;
			*pdwFilterType = dwStatus;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwFilterType;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadStats()
//
//	Date of Creation	:	16th Aug 2001
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERRCODE_ARG_INVALID
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument ike/ipsec/all
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadStats(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDWORD pdwStats = NULL;

	pdwStats = (PDWORD)malloc(sizeof(DWORD));

	if(pdwStats == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pdwStats);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pdwStats;
		dwStatus = TokenToStats(pszInput);
		if (dwStatus == PARSE_ERROR)
		{
			dwReturn	= ERRCODE_ARG_INVALID;
		}
		else
		{
			pParser->Cmd[dwCount].dwStatus = VALID_TOKEN ;
			*pdwStats = dwStatus;
			pParser->Cmd[dwCount].pArg = (PVOID)pdwStats;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadIPAddrTunnel()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount
//
//	Return				:	ERROR_SUCESS
//							ERROR_OUTOFMEMORY
//                          RETURN_NO_ERROR
//
//	Description			:	IPAddress validation done here. DNS Resolves to first IP only
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadIPAddrTunnel(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount,
	IN 	BOOL 		bTunnel
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	IPAddr * pIPAddr = NULL;
	IPAddr	Address;
	BOOL bMask = FALSE;				// DNS name resolves to first IP only

	pIPAddr = (IPAddr *)malloc(sizeof(IPAddr));
	if(pIPAddr == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pIPAddr);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pIPAddr;
		dwStatus = ValidateSplServer(pszInput);
		if (dwStatus == NOT_SPLSERVER)
		{
			dwStatus = TokenToIPAddr(pszInput,&Address,bTunnel,bMask);
			if( dwStatus == T2P_OK )
			{
				*pIPAddr = Address;
				pParser->Cmd[dwCount].pArg = (PVOID)pIPAddr;
				pParser->Cmd[dwCount].dwStatus  = NOT_SPLSERVER;
			}
			else
			{
				if(bTunnel)
				{
					switch(dwStatus)
					{
						case	T2P_INVALID_ADDR		:
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TUNNEL,pszInput);
							break;
						case	T2P_NULL_STRING			:
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_ARG);
							break;
						default							:
							break;
					}
				}
				else
				{
					PrintIPError(dwStatus,pszInput);
				}
				dwReturn	= RETURN_NO_ERROR;
			}
		}
		else
		{
			pParser->Cmd[dwCount].pArg = NULL;
			pParser->Cmd[dwCount].dwStatus  = dwStatus;
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadIPMask()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		szInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							RETURN_NO_ERROR
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the IPMask. Also allows prefix format.
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadIPMask(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	DWORD dwPrefix = 0;
	IPAddr * pIPAddr = NULL;
	IPAddr	Address;
	BOOL bMask = TRUE;
	BOOL bTunnel = FALSE;
	LPTSTR szPrefix = NULL;

	pIPAddr = (IPAddr *)malloc(sizeof(IPAddr));
	if(pIPAddr == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pIPAddr);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pIPAddr;

		szPrefix = _tcschr(pszInput,_TEXT('.'));
		if(szPrefix != NULL)
		{
			dwStatus = TokenToIPAddr(pszInput,&Address,bTunnel,bMask);
			if( (dwStatus == T2P_OK ) || (dwStatus == T2P_INVALID_MASKADDR ) )
			{
				*pIPAddr = Address;
				pParser->Cmd[dwCount].pArg = (PVOID)pIPAddr;
				pParser->Cmd[dwCount].dwStatus  = VALID_TOKEN;
			}
			else
			{
				PrintIPError(dwStatus,pszInput);
				dwReturn	= RETURN_NO_ERROR;
			}
		}
		else				// It is Prefix
		{
			dwPrefix = 0;
			dwStatus = _stscanf(pszInput,_TEXT("%u"),&dwPrefix);
			if(dwStatus)
			{
				if( (dwPrefix > 0 ) && ( dwPrefix <33 ) )		// Construct MASK using prefix
				{
					 Address = (IPAddr)( (ULONG)(pow( 2.0 ,(double)dwPrefix ) - 1) << (32-dwPrefix));
					 *pIPAddr = htonl(Address);
					pParser->Cmd[dwCount].pArg = (PVOID)pIPAddr;
					pParser->Cmd[dwCount].dwStatus  = VALID_TOKEN;
				}
				else
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_PREFIX_INVALID);
					dwReturn	= RETURN_NO_ERROR;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MASK_INVALID,pszInput);
				dwReturn	= RETURN_NO_ERROR;
			}
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadQMOffers()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount
//
//	Return				:	ERROR_SUCESS
//                          RETURN_NO_ERROR
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates the argument for QMSecmethods
//							(No.of offers are ' ' delimited)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadQMOffers(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	DWORD dwNum = 0;
	DWORD i=0;
	PIPSEC_QM_OFFER pIPSecQMOffer = NULL;
	LPTSTR Token = NULL;

	if (_tcscmp(pszInput,_TEXT("")) != 0)	//  First Validate I/P
	{
		for(i=0;i<IPSEC_MAX_QM_OFFERS;i++)
		{
			g_pQmsec[i] = NULL;
		};

		Token = _tcstok(pszInput,OFFER_SEPARATOR);	// Offers are ' ' delimited process them separately

		while( ( Token != NULL ) && (dwNum < IPSEC_MAX_QM_OFFERS) )
		{
			pIPSecQMOffer = (IPSEC_QM_OFFER *)calloc(1,sizeof(IPSEC_QM_OFFER));
			if(pIPSecQMOffer == NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}

			LoadQMOfferDefaults(*pIPSecQMOffer);

			dwStatus = ListToOffer(Token,*pIPSecQMOffer);
			if(dwStatus == T2P_OK)
			{
				if (*pdwUsed > MAX_ARGS_LIMIT)
				{
					free(pIPSecQMOffer);
					dwReturn = ERROR_OUT_OF_STRUCTURES;
					BAIL_OUT;
				}

				g_AllocPtr[*pdwUsed] = g_pQmsec[dwNum] = pIPSecQMOffer;
				dwNum++;
				(*pdwUsed)++;
				dwReturn = ERROR_SUCCESS;
			}
			else
			{
				if (pIPSecQMOffer)
				{
					free(pIPSecQMOffer);
					pIPSecQMOffer = NULL;
				}
				PrintQMOfferError(dwStatus,pParser,dwTagType);
				dwReturn = RETURN_NO_ERROR;
				BAIL_OUT;
			}
			Token = _tcstok(NULL,OFFER_SEPARATOR);	// Separate offers
		}
		if(dwNum > IPSEC_MAX_QM_OFFERS)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MAX_OFFERS,IPSEC_MAX_QM_OFFERS);
			dwReturn = RETURN_NO_ERROR;

			pParser->Cmd[dwCount].pArg       = NULL;
			pParser->Cmd[dwCount].dwStatus   = 0;
		}
		else if((dwNum > 0) && (dwNum <= IPSEC_MAX_QM_OFFERS))
		{
			pParser->Cmd[dwCount].pArg       = (PVOID)g_pQmsec;
			pParser->Cmd[dwCount].dwStatus   = dwNum;
		}
	}
	else
	{
		dwReturn = ERROR_SHOW_USAGE;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadMMOffers()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount
//
//	Return				:	ERROR_SUCESS
//							ERROR_OUTOFMEMORY
//                          RETURN_NO_ERROR
//
//	Description			:	Validates the argument for MMSecMethods.
//							(No .of Offers are ' ' delimited)
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadMMOffers(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	DWORD dwNum = 0;
	DWORD i=0;
	PIPSEC_MM_OFFER pIPSecMMOffer = NULL;
	LPTSTR Token = NULL;

	if (_tcsicmp(pszInput,_TEXT("\0")) != 0)
	{
		Token = _tcstok(pszInput,OFFER_SEPARATOR); 	// Offers are ' ' delimited process them separately

		for(i=0;i<IPSEC_MAX_MM_OFFERS;i++)
		{
			g_pMmsec[i]=NULL;
		};

		while( ( Token != NULL  ) && (dwNum < IPSEC_MAX_MM_OFFERS) )
		{
			pIPSecMMOffer = (IPSEC_MM_OFFER *)calloc(1,sizeof(IPSEC_MM_OFFER));
			if(pIPSecMMOffer == NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}

			LoadSecMethodDefaults(*pIPSecMMOffer) ;

			dwStatus = ListToSecMethod(Token,*pIPSecMMOffer);
			if(dwStatus == T2P_OK)
			{
				if (*pdwUsed > MAX_ARGS_LIMIT)
				{
					free(pIPSecMMOffer);
					dwReturn = ERROR_OUT_OF_STRUCTURES;
					BAIL_OUT;
				}

				g_AllocPtr[*pdwUsed] = g_pMmsec[dwNum] = pIPSecMMOffer;
				(*pdwUsed)++;
				dwNum++;
				dwReturn = ERROR_SUCCESS;
			}
			else
			{
				switch(dwStatus)
				{
					case T2P_INVALID_P1GROUP		:
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_P1GROUP);
						break;
					case T2P_NULL_STRING			:
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NULL_STRING);
						break;
					case T2P_GENERAL_PARSE_ERROR	:
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MMOFFER_INVALID);
						break;
					case T2P_DUP_ALGS				:
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DUPALG_INVALID,pParser->ValidTok[dwTagType].pwszToken);
						break;
					case T2P_P1GROUP_MISSING		:
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_P1GROUP_MISSING);
						break;
					default 						:
						break;
				}
				if (pIPSecMMOffer)
				{
					free(pIPSecMMOffer);
					pIPSecMMOffer = NULL;
				}
				dwReturn = RETURN_NO_ERROR;
				BAIL_OUT;
			}
			Token = _tcstok(NULL,OFFER_SEPARATOR);		// Separate offers..
		}
		if(dwNum > IPSEC_MAX_MM_OFFERS)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MAX_OFFERS,IPSEC_MAX_MM_OFFERS);
			dwReturn = RETURN_NO_ERROR;
			BAIL_OUT;
		}
		if (dwNum)
		{
			pParser->Cmd[dwCount].pArg       = (PVOID)g_pMmsec;
			pParser->Cmd[dwCount].dwStatus   = dwNum;
		}
		else
		{
			pParser->Cmd[dwCount].pArg       = NULL;
			pParser->Cmd[dwCount].dwStatus   = 0;
		}
	}
	else
	{
		dwReturn = ERROR_SHOW_USAGE;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadDNSIPAddr()
//
//	Date of Creation	:	08th JAn 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERROR_OUTOFMEMORY
//                          RETURN_NO_ERROR
//
//	Description			:	Validates the IPAddress. DNS name resolves to all IP's
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadDNSIPAddr(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PDNSIPADDR pDNSIPAddr = NULL;

	pDNSIPAddr = (DNSIPADDR *)calloc(1,sizeof(DNSIPADDR));

	if(pDNSIPAddr == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
	}
	else
	{
		if (*pdwUsed > MAX_ARGS_LIMIT)
		{
			free(pDNSIPAddr);
			dwReturn = ERROR_OUT_OF_STRUCTURES;
			BAIL_OUT;
		}

		g_AllocPtr[(*pdwUsed)++] = pDNSIPAddr;
		dwStatus = ValidateSplServer(pszInput);	// allow spl servers..
		if (dwStatus == NOT_SPLSERVER)
		{
			dwStatus = TokenToDNSIPAddr(pszInput,pDNSIPAddr,&pdwUsed);
			if( dwStatus == T2P_OK )
			{
				pParser->Cmd[dwCount].pArg = (PVOID)pDNSIPAddr;
				pParser->Cmd[dwCount].dwStatus  = VALID_TOKEN;
			}
			else
			{
				PrintIPError(dwStatus,pszInput);
				dwReturn	= RETURN_NO_ERROR;
			}
		}
		else
		{
			pParser->Cmd[dwCount].pArg = NULL;
			pParser->Cmd[dwCount].dwStatus  = dwStatus;
		}
	}
error:
	return dwReturn;
}


//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	CheckCharForOccurances()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN LPTSTR szInput,
//							IN _TCHAR chData
//
//	Return				:	DWORD
//
//	Description			:
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
CheckCharForOccurances(
	IN 	LPTSTR 		pszInput,
	IN	_TCHAR		chData
	)
{
	DWORD dwCount = 0;
	LPTSTR pszTmpPtr = NULL;

	for ( dwCount=0,pszTmpPtr=pszInput; ;dwCount++)
	{
		pszTmpPtr = _tcschr(pszTmpPtr, chData);
		if(pszTmpPtr)
		{
			pszTmpPtr++;
		}
		else
		{
			break;
		}
	}
	return 	dwCount;
}


DWORD
ConvertStringToDword(
	 IN LPTSTR szInput,
	 OUT PDWORD pdwValue
	 )
{
	DWORD dwReturn = ERROR_INVALID_OPTION_VALUE;
	size_t i = 0;
	DWORD dwValue = 0;
	// our largest allowable value is 2147483647
	while ((dwValue < 2147483647) && (szInput[i] >= '0') && (szInput[i] <= '9'))
	{
		dwValue = dwValue * 10 + (szInput[i] - '0');
		++i;
	}
	if (szInput[i] == '\0')
	{
		dwReturn = ERROR_SUCCESS;
		*pdwValue = dwValue;
	}
	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\parser.h ===
//////////////////////////////////////////////////////////////////////////////
//	Module			:	parser.h
//
// 	Purpose			:	Parse the strings and gives concerned o/p to the
//		    		 	related context for IPSec Implementation.
//
//	Developers Name	:	N.Surendra Sai / Vunnam Kondal Rao
//
//	History			:
//
//	Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _PARSER_H_
#define _PARSER_H_

#include "nshipsec.h"

//
// All Limits
//
const DWORD POTF_DEFAULT_P2REKEY_TIME  	= 0;
const DWORD POTF_DEFAULT_P2REKEY_BYTES	= 0;
const DWORD POTF_DEF_P1SOFT_TIME  		= 480*60;   		// seconds
const DWORD POTF_DEFAULT_P1REKEY_TIME  	= 480*60;
const DWORD POTF_DEFAULT_P1REKEY_QMS   	= 0;
const time_t P2STORE_DEFAULT_POLLINT 	= 60 * 180;

#define MAX_MM_AUTH_INFO				40

#define P1_Min_LIFE_MIN					1				// in minutes
#define P1_Min_LIFE_MAX					71582788		// in minutes

#define P1_Kb_LIFE_MIN					20480			// in KB
#define P1_Kb_LIFE_MAX					2147438647		// in KB


#define P2_Sec_LIFE_MIN					300				// 300 in seconds
#define P2_Sec_LIFE_MAX					2147438647		// 172800 in seconds

#define P2_Kb_LIFE_MIN					20480			// 20480 in KB
#define P2_Kb_LIFE_MAX					2147438647		// in KB

#define POLLING_Min_MIN					0				// in min
#define POLLING_Min_MAX					43200			// in min

#define QMPERMM_MIN						0				// no. of sessions
#define QMPERMM_MAX						2147483647		// no. of sessions

#define MAX_PORT						65536

#define MAX_EXEMPTION_ENTRIES			1024

#define RETURN_NO_ERROR					9999
#define PARSE_ERROR						0xFFFFFFFF

#define TYPE_STRING 					0
#define TYPE_BOOL						1
#define TYPE_DWORD  					2
#define TYPE_ALL    					3
#define TYPE_IP 						4
#define TYPE_CONNTYPE					5
#define TYPE_PROTOCOL					6
#define TYPE_PFSGROUP					7
#define TYPE_VERBOSE					8
#define TYPE_BOUND						9
#define TYPE_TUNNEL						10
#define TYPE_ACTION						11
#define TYPE_RELEASE					12
#define TYPE_PROPERTY					13
#define TYPE_MASK						14
#define TYPE_QM_OFFER					15
#define TYPE_MM_OFFER					16
#define TYPE_FORMAT						17
#define TYPE_MODE						18
#define TYPE_DNSIP						19
#define TYPE_EXPORT						20
#define TYPE_PORT						21
#define TYPE_FILTER						22
#define TYPE_STATS						23
#define TYPE_ENLOGGING					24
#define TYPE_USERINPUT					25
#define TYPE_LOCATION                   26
#define TYPE_KERBAUTH                   27
#define TYPE_PSKAUTH                    28
#define TYPE_ROOTCA                     29

#define ARG_YES 						1
#define ARG_NO							2

#define GROUP_CMD						1
#define PRI_CMD							2
#define SEC_CMD							3

#define PFSGROUP_TYPE_NOPFS				0
#define PFSGROUP_TYPE_P1				1
#define PFSGROUP_TYPE_P2				2
#define PFSGROUP_TYPE_2048				3
#define PFSGROUP_TYPE_MM				4

#define STR_MAX							1024

#define ADD_CMD 						0
#define SET_CMD 						1
#define MAX_ARGS 						100
#define MAX_ARGS_LIMIT					(MAX_ARGS-2)	// Used in dwUsed++ checking
#define MAX_STR_LEN						STR_MAX

#define IF_TYPE_ANY						_TEXT("ANY")
#define IF_TYPE_ICMP					_TEXT("ICMP")
#define IF_TYPE_TCP						_TEXT("TCP")
#define IF_TYPE_UDP						_TEXT("UDP")
#define IF_TYPE_RAW						_TEXT("RAW")

#define PROPERTY_TYPE_ENABLEDIGNO		_TEXT("ipsecdiagnostics")
#define PROPERTY_TYPE_IKELOG			_TEXT("ikelogging")
#define PROPERTY_TYPE_CRLCHK			_TEXT("strongcrlcheck")
#define PROPERTY_TYPE_LOGINTER			_TEXT("ipsecloginterval")
#define PROPERTY_TYPE_EXEMPT			_TEXT("ipsecexempt")
#define PROPERTY_TYPE_BOOTMODE			_TEXT("bootmode")
#define PROPERTY_TYPE_BOOTEXEMP			_TEXT("bootexemptions")

#define VALUE_TYPE_STATEFUL				_TEXT("stateful")
#define VALUE_TYPE_BLOCK				_TEXT("block")
#define VALUE_TYPE_PERMIT				_TEXT("permit")

#define TOKEN_STR_INBOUND				_TEXT("inbound")
#define TOKEN_STR_OUTBOUND				_TEXT("outbound")
#define TOKEN_STR_NONE					_TEXT("none")

#define ARG_TOKEN_STR_VERBOSE			_TEXT("VERBOSE")
#define ARG_TOKEN_STR_NORMAL			_TEXT("NORMAL")

#define TYPE_STR_LIST					_TEXT("LIST")
#define TYPE_STR_TABLE					_TEXT("TABLE")

#define TYPE_STR_TUNNEL					_TEXT("TUNNEL")
#define TYPE_STR_TRANSPORT				_TEXT("TRANSPORT")

#define PFS_TYPE_NOPFS					_TEXT("NOPFS")
#define PFS_TYPE_P1						_TEXT("GRP1")
#define PFS_TYPE_P2						_TEXT("GRP2")
#define PFS_TYPE_P3						_TEXT("GRP3")
#define PFS_TYPE_MM 					_TEXT("GRPMM")

#define IF_TYPE_ALL						_TEXT("ALL")
#define IF_TYPE_LAN						_TEXT("LAN")
#define IF_TYPE_DIALUP 					_TEXT("DIALUP")
#define IF_TYPE_MAX 					_TEXT("MAX")

#define LOC_TYPE_PERSISTENT				_TEXT("PERSISTENT")
#define LOC_TYPE_LOCAL					_TEXT("LOCAL")
#define LOC_TYPE_DOMAIN 				_TEXT("DOMAIN")

#define EXPORT_IPSEC					_TEXT(".ipsec")
#define TOKEN_LOCAL						_TEXT("local")

#define DEFAULT_STR						_TEXT("default")
//
// Token names starts here
//
#define CMD_TOKEN_STR_NAME				_TEXT("name")
#define CMD_TOKEN_STR_DESCR 			_TEXT("description")
#define CMD_TOKEN_STR_MMPFS				_TEXT("mmpfs")
#define CMD_TOKEN_STR_DEFAULTRULE		_TEXT("defaultrule")
#define CMD_TOKEN_STR_PI				_TEXT("pollinginterval")
#define CMD_TOKEN_STR_ASSIGN 			_TEXT("assign")
#define CMD_TOKEN_STR_FILTERLIST		_TEXT("filterlist")
#define CMD_TOKEN_STR_NEWNAME			_TEXT("newname")
#define CMD_TOKEN_STR_MMSECMETHODS		_TEXT("mmsecmethods")
#define CMD_TOKEN_STR_SRCADDR			_TEXT("srcaddr/srcdns")
#define CMD_TOKEN_STR_DSTADDR			_TEXT("dstaddr/dstdns")
#define CMD_TOKEN_STR_PROTO				_TEXT("protocol")
#define CMD_TOKEN_STR_QMSECMETHODS		_TEXT("qmsecmethods")
#define CMD_TOKEN_STR_QMPFS				_TEXT("qmpfs")
#define CMD_TOKEN_STR_INPASS			_TEXT("inpass")
#define CMD_TOKEN_STR_SOFT				_TEXT("soft")
#define CMD_TOKEN_STR_POLICY			_TEXT("policy")
#define CMD_TOKEN_STR_TUNNEL			_TEXT("tunnelIP/tunnelDNS")
#define CMD_TOKEN_STR_CONNTYPE			_TEXT("conntype")
#define CMD_TOKEN_STR_ACTIVATE			_TEXT("activate")
#define CMD_TOKEN_STR_KERB      		_TEXT("kerberos")
#define CMD_TOKEN_STR_PSK       		_TEXT("psk")
#define CMD_TOKEN_STR_ROOTCA    		_TEXT("rootca")
#define CMD_TOKEN_STR_MACHINE			_TEXT("machine")
#define CMD_TOKEN_STR_LOCATION          _TEXT("location")
#define CMD_TOKEN_STR_DS				_TEXT("domain")
#define CMD_TOKEN_STR_FILE				_TEXT("file")
#define CMD_TOKEN_STR_RULE				_TEXT("rule")
#define CMD_TOKEN_STR_VERBOSE			_TEXT("level")
#define CMD_TOKEN_STR_ID				_TEXT("id")
#define CMD_TOKEN_STR_FILTERACTION		_TEXT("filteraction")
#define	CMD_TOKEN_STR_QMPERMM			_TEXT("qmpermm")
#define	CMD_TOKEN_STR_ALL				_TEXT("all")
#define CMD_TOKEN_STR_SRCMASK			_TEXT("srcmask")
#define CMD_TOKEN_STR_DSTMASK			_TEXT("dstmask")
#define CMD_TOKEN_STR_MIRROR			_TEXT("mirrored")
#define CMD_TOKEN_STR_SRCPORT			_TEXT("srcport")
#define CMD_TOKEN_STR_DSTPORT			_TEXT("dstport")
#define CMD_TOKEN_STR_ACTIVATEDEFRULE	_TEXT("activatedefaultrule")
#define CMD_TOKEN_STR_GPONAME			_TEXT("gponame")
#define CMD_TOKEN_STR_DEFRESPONSE		_TEXT("defaultresponse")
#define CMD_TOKEN_STR_SOFTSAEXPTIME		_TEXT("softsaexpirationtime")
#define CMD_TOKEN_STR_OUTBOUND			_TEXT("actionoutbound")
#define CMD_TOKEN_STR_INBOUND			_TEXT("actioninbound")
#define CMD_TOKEN_STR_MMFILTER			_TEXT("mmfilter")
#define CMD_TOKEN_STR_LOGLEVEL			_TEXT("loglevel")
#define CMD_TOKEN_STR_EXEMPT			_TEXT("exempt")
#define CMD_TOKEN_STR_INTERVAL			_TEXT("interval")
#define CMD_TOKEN_STR_LOG				_TEXT("log")
#define CMD_TOKEN_STR_LOCAL				_TEXT("local")
#define CMD_TOKEN_STR_CRL				_TEXT("crl")
#define CMD_TOKEN_STR_MODE 				_TEXT("mode")
#define CMD_TOKEN_STR_PFSGROUP			_TEXT("pfsgroup")
#define CMD_TOKEN_STR_TUNNELDST			_TEXT("tunneldstaddress")
#define CMD_TOKEN_STR_NEGOTIATION		_TEXT("qmsecmethods")
#define CMD_TOKEN_STR_VALUE				_TEXT("value")
#define CMD_TOKEN_STR_MMPOLICY			_TEXT("mmpolicy")
#define CMD_TOKEN_STR_QMPOLICY			_TEXT("qmpolicy")
#define CMD_TOKEN_STR_FORMAT			_TEXT("format")
#define CMD_TOKEN_STR_TYPE				_TEXT("type")
#define CMD_TOKEN_STR_MMLIFETIME		_TEXT("mmlifetime")
#define CMD_TOKEN_STR_GUID				_TEXT("guid")
#define CMD_TOKEN_STR_ACTION			_TEXT("action")
#define CMD_TOKEN_STR_RELEASE			_TEXT("release")
#define CMD_TOKEN_STR_PROPERTY			_TEXT("property")
#define CMD_TOKEN_STR_RESDNS			_TEXT("resolvedns")
#define CMD_TOKEN_STR_WIDE				_TEXT("wide")
#define CMD_TOKEN_STR_CERTTOMAP			_TEXT("certmapping")
#define CMD_TOKEN_STR_FAILMMIFEXISTS    _TEXT("forcemmfilter")
#define CMD_TOKEN_STR_ENABLE			_TEXT("enable")
#define CMD_TOKEN_STR_USERINPUT			_TEXT("userinput")
#define TOKEN_FIELD_DELIMITER			_TEXT(":")
#define TOKEN_TUPLE_DELIMITER			_TEXT(" \t")

#define CMD_TOKEN_NAME				1
#define CMD_TOKEN_DESCR 			2
#define CMD_TOKEN_MMPFS				3
#define CMD_TOKEN_RESDNS			4
#define CMD_TOKEN_WIDE				5
#define CMD_TOKEN_PI				6
#define	CMD_TOKEN_QMPERMM			7
#define CMD_TOKEN_ASSIGN 			8
#define CMD_TOKEN_FILTERLIST 		9
#define CMD_TOKEN_MMSECMETHODS		10
#define CMD_TOKEN_SRCADDR			11
#define CMD_TOKEN_DSTADDR			12
#define CMD_TOKEN_PROTO				13
#define CMD_TOKEN_QMSECMETHODS		14
#define CMD_TOKEN_QMPFS				15
#define CMD_TOKEN_INPASS			16
#define CMD_TOKEN_SOFT				17
#define CMD_TOKEN_POLICY			18
#define CMD_TOKEN_TUNNEL			19
#define CMD_TOKEN_CONNTYPE			20
#define CMD_TOKEN_ACTIVATE			21
#define CMD_TOKEN_AUTHMETHODS		22
#define CMD_TOKEN_LOCATION			23
#define CMD_TOKEN_DS				24
#define CMD_TOKEN_FILE				25
#define CMD_TOKEN_RULE				26
#define CMD_TOKEN_VERBOSE			27
#define CMD_TOKEN_ID				28
#define CMD_TOKEN_FILTERACTION		29
#define CMD_TOKEN_NEWNAME			30
#define	CMD_TOKEN_ALL				31
#define CMD_TOKEN_SRCMASK			32
#define CMD_TOKEN_DSTMASK			33
#define CMD_TOKEN_MIRROR			34
#define CMD_TOKEN_SRCPORT			35
#define CMD_TOKEN_DSTPORT			36
#define CMD_TOKEN_KBLIFETIME 		37
#define CMD_TOKEN_ACTIVATEDEFRULE	38
#define CMD_TOKEN_GPONAME			39
#define CMD_TOKEN_DEFRESPONSE		40
#define CMD_TOKEN_SOFTSAEXPTIME		41
#define CMD_TOKEN_INBOUND 			42
#define CMD_TOKEN_OUTBOUND			43
#define CMD_TOKEN_MMFILTER			44
#define CMD_TOKEN_LOGLEVEL			45
#define CMD_TOKEN_EXEMPT			46
#define CMD_TOKEN_INTERVAL			47
#define CMD_TOKEN_LOG				48
#define CMD_TOKEN_LOCAL				49
#define CMD_TOKEN_CRL				50
#define CMD_TOKEN_MODE				51
#define CMD_TOKEN_PFSGROUP			52
#define CMD_TOKEN_TUNNELDST			54
#define CMD_TOKEN_NEGOTIATION		55
#define CMD_TOKEN_VALUE				56
#define CMD_TOKEN_MMPOLICY			57
#define CMD_TOKEN_QMPOLICY			58
#define CMD_TOKEN_FORMAT			59
#define CMD_TOKEN_TYPE				60
#define CMD_TOKEN_MMLIFETIME		61
#define CMD_TOKEN_GUID				62
#define CMD_TOKEN_ACTION			63
#define CMD_TOKEN_RELEASE			64
#define CMD_TOKEN_PROPERTY			65
#define CMD_TOKEN_CERTTOMAP			66
#define CMD_TOKEN_FAILMMIFEXISTS    67
#define CMD_TOKEN_ENABLE			68
#define CMD_TOKEN_USERINPUT			69
#define CMD_TOKEN_KERB              70
#define CMD_TOKEN_PSK               71
#define CMD_TOKEN_ROOTCA            72

#define SIZEOF_TOKEN_VALUE(_x) 		( sizeof(_x) / sizeof(TOKEN_VALUE) )
#define SIZEOF_TAG_TYPE(_x)    		( sizeof(_x) / sizeof(TAG_TYPE)    )
#define SIZEOF_TAG_NEEDED(_x)  		( sizeof(_x) / sizeof(TAG_NEEDED)  )

#define CONTEXT_NULL				0
#define CONTEXT_IPSEC				1

#define VALID_TOKEN					0xFFFFFFFF
#define INVALID_TOKEN				0

#define GROUP_NULL					0
#define GROUP_STATIC 				1
#define GROUP_DYNAMIC 				2

#define PRI_NULL					0
#define PRI_ADD						1
#define PRI_SET						2
#define PRI_DELETE					3
#define PRI_SHOW					4
#define PRI_EXPORTPOLICY			5
#define PRI_IMPORTPOLICY			6
#define PRI_RESTOREDEFAULTS			7
#define PRI_CHECKINTEGRITY			8

#define SEC_NULL					0
#define SEC_POLICY					1
#define SEC_FILTER					2
#define SEC_FILTERLIST				3
#define SEC_FILTERACTION			4
#define SEC_RULE					5
#define SEC_ALL						6
#define SEC_STORE					7
#define SEC_DEFAULTRULE				8
#define SEC_ASSIGNEDPOLICY			9
#define SEC_INTERACTIVE				10
#define SEC_MMPOLICY				11
#define SEC_MMFILTER				12
#define SEC_QMPOLICY				13
#define SEC_QMFILTER				14
#define SEC_STATS					15
#define SEC_MMSAS					16
#define SEC_QMSAS					17
#define SEC_CONFIG					18
#define SEC_BATCH					19
#define SEC_EXTENDLOG				20

#define CON_IPSEC_STR				_TEXT("ipsec")

#define GROUP_STATIC_STR			_TEXT("static")
#define GROUP_DYNAMIC_STR			_TEXT("dynamic")

#define PRI_ADD_STR					_TEXT("add")
#define PRI_SET_STR					_TEXT("set")
#define PRI_DELETE_STR				_TEXT("delete")
#define PRI_SHOW_STR				_TEXT("show")
#define PRI_EXPORTPOLICY_STR		_TEXT("exportpolicy")
#define PRI_IMPORTPOLICY_STR		_TEXT("importpolicy")
#define PRI_RESTOREDEFAULTS_STR		_TEXT("restorepolicyexamples")


#define SEC_POLICY_STR				_TEXT("policy")
#define SEC_ASSIGNEDPOLICY_STR		_TEXT("gpoassignedpolicy")
#define SEC_FILTERLIST_STR			_TEXT("filterlist")
#define SEC_FILTER_STR				_TEXT("filter")
#define SEC_FILTERACTION_STR		_TEXT("filteraction")
#define SEC_RULE_STR				_TEXT("rule")
#define SEC_ALL_STR					_TEXT("all")
#define SEC_STORE_STR				_TEXT("store")
#define SEC_DEFAULTRULE_STR			_TEXT("defaultrule")
#define SEC_INTERACTIVE_STR			_TEXT("interactive")
#define SEC_BATCH_STR				_TEXT("batch")

#define SEC_MMPOLICY_STR			_TEXT("mmpolicy")
#define SEC_MMFILTER_STR			_TEXT("mmfilter")
#define SEC_QMFILTER_STR			_TEXT("qmfilter")
#define SEC_QMPOLICY_STR			_TEXT("qmpolicy")
#define SEC_STATS_STR				_TEXT("stats")
#define SEC_MMSAS_STR				_TEXT("mmsas")
#define SEC_QMSAS_STR				_TEXT("qmsas")

#define SEC_CONFIG_STR				_TEXT("config")

#define	DEFAULT_MMSECMETHODS		_TEXT("3DES-SHA1-2 3DES-MD5-2 3DES-SHA1-3")
#define DEFAULT_AUTHMETHODS			_TEXT("")
#define DEFAULT_QMSECMETHODS		_TEXT("ESP[3DES,SHA1] ESP[3DES,MD5]")

#define C_BASE						10000	// Context Base
#define G_BASE						1000	// Group Base
#define P_BASE						100		// Primary Command Base
#define S_BASE						1		// Secondary Command Base

#define INDEX(_g,_p,_s)				(C_BASE+_g*G_BASE+_p*P_BASE+_s*S_BASE)

#define STATIC_EXPORTPOLICY			INDEX(GROUP_STATIC,PRI_EXPORTPOLICY,SEC_NULL)
#define STATIC_IMPORTPOLICY			INDEX(GROUP_STATIC,PRI_IMPORTPOLICY,SEC_NULL)
#define STATIC_RESTOREDEFAULTS		INDEX(GROUP_STATIC,PRI_RESTOREDEFAULTS,SEC_NULL)

#define STATIC_ADD_POLICY			INDEX(GROUP_STATIC,PRI_ADD,SEC_POLICY)
#define STATIC_ADD_FILTER			INDEX(GROUP_STATIC,PRI_ADD,SEC_FILTER)
#define STATIC_ADD_FILTERLIST		INDEX(GROUP_STATIC,PRI_ADD,SEC_FILTERLIST)
#define STATIC_ADD_FILTERACTION		INDEX(GROUP_STATIC,PRI_ADD,SEC_FILTERACTION)
#define STATIC_ADD_RULE				INDEX(GROUP_STATIC,PRI_ADD,SEC_RULE)

#define STATIC_SET_POLICY			INDEX(GROUP_STATIC,PRI_SET,SEC_POLICY)
#define STATIC_SET_FILTERLIST		INDEX(GROUP_STATIC,PRI_SET,SEC_FILTERLIST)
#define STATIC_SET_FILTERACTION		INDEX(GROUP_STATIC,PRI_SET,SEC_FILTERACTION)
#define STATIC_SET_RULE				INDEX(GROUP_STATIC,PRI_SET,SEC_RULE)
#define STATIC_SET_DEFAULTRULE		INDEX(GROUP_STATIC,PRI_SET,SEC_DEFAULTRULE)
#define STATIC_SET_STORE			INDEX(GROUP_STATIC,PRI_SET,SEC_STORE)
#define STATIC_SET_INTERACTIVE		INDEX(GROUP_STATIC,PRI_SET,SEC_INTERACTIVE)
#define STATIC_SET_BATCH			INDEX(GROUP_STATIC,PRI_SET,SEC_BATCH)

#define STATIC_DELETE_POLICY		INDEX(GROUP_STATIC,PRI_DELETE,SEC_POLICY)
#define STATIC_DELETE_FILTER		INDEX(GROUP_STATIC,PRI_DELETE,SEC_FILTER)
#define STATIC_DELETE_FILTERLIST	INDEX(GROUP_STATIC,PRI_DELETE,SEC_FILTERLIST)
#define STATIC_DELETE_FILTERACTION	INDEX(GROUP_STATIC,PRI_DELETE,SEC_FILTERACTION)
#define STATIC_DELETE_RULE			INDEX(GROUP_STATIC,PRI_DELETE,SEC_RULE)
#define STATIC_DELETE_ALL			INDEX(GROUP_STATIC,PRI_DELETE,SEC_ALL)

#define STATIC_SHOW_POLICY			INDEX(GROUP_STATIC,PRI_SHOW,SEC_POLICY)
#define STATIC_SHOW_FILTERLIST		INDEX(GROUP_STATIC,PRI_SHOW,SEC_FILTERLIST)
#define STATIC_SHOW_FILTERACTION	INDEX(GROUP_STATIC,PRI_SHOW,SEC_FILTERACTION)
#define STATIC_SHOW_RULE			INDEX(GROUP_STATIC,PRI_SHOW,SEC_RULE)
#define STATIC_SHOW_DEFAULTRULE		INDEX(GROUP_STATIC,PRI_SHOW,SEC_DEFAULTRULE)
#define STATIC_SHOW_STORE			INDEX(GROUP_STATIC,PRI_SHOW,SEC_STORE)
#define STATIC_SHOW_ALL				INDEX(GROUP_STATIC,PRI_SHOW,SEC_ALL)
#define STATIC_SHOW_ASSIGNEDPOLICY	INDEX(GROUP_STATIC,PRI_SHOW,SEC_ASSIGNEDPOLICY)

#define DYNAMIC_ADD_MMPOLICY		INDEX(GROUP_DYNAMIC,PRI_ADD,SEC_MMPOLICY)
#define DYNAMIC_ADD_FILTERACTION	INDEX(GROUP_DYNAMIC,PRI_ADD,SEC_QMPOLICY)
#define DYNAMIC_ADD_RULE			INDEX(GROUP_DYNAMIC,PRI_ADD,SEC_RULE)

#define DYNAMIC_SET_MMPOLICY		INDEX(GROUP_DYNAMIC,PRI_SET,SEC_MMPOLICY)
#define DYNAMIC_SET_FILTERACTION	INDEX(GROUP_DYNAMIC,PRI_SET,SEC_QMPOLICY)
#define DYNAMIC_SET_RULE			INDEX(GROUP_DYNAMIC,PRI_SET,SEC_RULE)
#define DYNAMIC_SET_CONFIG			INDEX(GROUP_DYNAMIC,PRI_SET,SEC_CONFIG)

#define DYNAMIC_SHOW_MMPOLICY		INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_MMPOLICY)
#define DYNAMIC_SHOW_MMFILTER		INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_MMFILTER)
#define DYNAMIC_SHOW_FILTERACTION	INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_QMPOLICY)
#define DYNAMIC_SHOW_QMFILTER		INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_QMFILTER)
#define DYNAMIC_SHOW_STATS			INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_STATS)
#define DYNAMIC_SHOW_MMSAS			INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_MMSAS)
#define DYNAMIC_SHOW_QMSAS			INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_QMSAS)
#define DYNAMIC_SHOW_ALL			INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_ALL)
#define DYNAMIC_SHOW_AUTHMETHODS	INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_AUTHMETHODS)
#define DYNAMIC_SHOW_RULE			INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_RULE)
#define DYNAMIC_SHOW_CONFIG			INDEX(GROUP_DYNAMIC,PRI_SHOW,SEC_CONFIG)

#define DYNAMIC_DELETE_MMPOLICY		INDEX(GROUP_DYNAMIC,PRI_DELETE,SEC_MMPOLICY)
#define DYNAMIC_DELETE_FILTERACTION	INDEX(GROUP_DYNAMIC,PRI_DELETE,SEC_QMPOLICY)
#define DYNAMIC_DELETE_RULE			INDEX(GROUP_DYNAMIC,PRI_DELETE,SEC_RULE)
#define DYNAMIC_DELETE_ALL			INDEX(GROUP_DYNAMIC,PRI_DELETE,SEC_ALL)


#define IPAddr  										unsigned long

#define DEFAULT_CERTMAP_OPTION 							FALSE
#define CERTMAP_STR										_TEXT("certmap")

#define QMSEC_PERMIT_STR								_TEXT("PERMIT")
#define QMSEC_BLOCK_STR									_TEXT("BLOCK")
#define QMSEC_NEGOTIATE_STR		 						_TEXT("NEGOTIATE")

#define FILTER_TYPE_GENERIC_STR					 		_TEXT("GENERIC")
#define FILTER_TYPE_SPECIFIC_STR						_TEXT("SPECIFIC")

#define RELEASE_DOTNET_STR				 				_TEXT("win2003")
#define RELEASE_WIN2K_STR								_TEXT("WIN2K")

#define STATS_ALL_STR					 				_TEXT("ALL")
#define STATS_IKE_STR				 					_TEXT("IKE")
#define STATS_IPSEC_STR									_TEXT("IPSEC")

#define SERVER_WINS_STR									_TEXT("WINS")
#define SERVER_DHCP_STR				 					_TEXT("DHCP")
#define SERVER_DNS_STR				 					_TEXT("DNS")
#define SERVER_GATEWAY_STR			 					_TEXT("GATEWAY")
#define IP_ME_STR										_TEXT("ME")
#define IP_ANY_STR										_TEXT("ANY")

#define YES_STR											_TEXT("yes")
#define NO_STR 											_TEXT("no")
#define Y_STR											_TEXT("y")
#define N_STR 											_TEXT("n")
#define ALL_STR											_TEXT("all")

#define ERRMSG_NAMEALL									_TEXT("Name or ALL")
#define ERRMSG_NAMEGUID									_TEXT("Name or Guid")
#define ERRMSG_NAMERULEALL								_TEXT("Name or Rule or ALL")
#define ERRMSG_NAMEIDALL								_TEXT("Name or Id or ALL")
#define ERRMSG_NAMEID									_TEXT("Name or ID")
#define ERRMSG_NAME										_TEXT("Name")
#define ERRMSG_ALLSRCDSTADDR							_TEXT("All or Srcaddr or Dstaddr")
#define ERRMSG_GETLASTERROR								_TEXT("Parser PreprocessCommand() error\n")

#define TOKEN_QMSEC_PERMIT								1
#define TOKEN_QMSEC_BLOCK								2
#define TOKEN_QMSEC_NEGOTIATE							3

#define TOKEN_RELEASE_DOTNET							1
#define TOKEN_RELEASE_WIN2K								2

#define FILTER_GENERIC									1
#define FILTER_SPECIFIC									2

#define TYPE_TRANSPORT_FILTER							1
#define TYPE_TUNNEL_FILTER								2

#define STATS_ALL										1
#define STATS_IKE										2
#define STATS_IPSEC										3

#define USERINPUT_YES									1
#define USERINPUT_NO									2
#define USERINPUT_DEFAULT								3

#define SERVER_WINS										1
#define SERVER_DHCP										2
#define SERVER_DNS										3
#define SERVER_GATEWAY									4
#define IP_ME											5
#define IP_ANY											6
#define NOT_SPLSERVER									VALID_TOKEN

#define POTF_P1_TOKEN       							_TEXT('-')
#define POTF_NEGPOL_CLOSE								_TEXT(']')
#define POTF_REKEY_TOKEN 								_TEXT('/')
#define POTF_NEGPOL_DES									_TEXT("DES")
#define POTF_NEGPOL_3DES								_TEXT("3DES")
#define POTF_NEGPOL_SHA1								_TEXT("SHA1")
#define POTF_NEGPOL_MD5									_TEXT("MD5")
#define POTF_NEGPOL_NONE								_TEXT("NONE")
#define POTF_NEGPOL_ESP									_TEXT("ESP")
#define POTF_NEGPOL_AH									_TEXT("AH")
#define POTF_P1_DES										_TEXT("DES")
#define POTF_P1_3DES									_TEXT("3DES")
#define POTF_P1_SHA1									_TEXT("SHA1")
#define POTF_P1_MD5										_TEXT("MD5")
#define POTF_ME_TUNNEL									_TEXT("0")
#define POTF_PT_TOKEN									_TEXT(':')
#define POTF_MASK_TOKEN									_TEXT('/')
#define POTF_OAKAUTH_PRESHARE							_TEXT("psk=")
#define POTF_OAKAUTH_CERT								_TEXT("rootca=")
#define POTF_OAKAUTH_KERBEROS							_TEXT("kerberos")
#define POTF_NEGPOL_OPEN								_TEXT('[')
#define POTF_NEGPOL_AND									_TEXT('+')
#define POTF_NEGPOL_PFS									_TEXT('P')
#define POTF_ESPTRANS_TOKEN								_TEXT(',')
#define POTF_OAKAUTH_TOKEN								_TEXT('=')
#define POTF_OAKLEY_GROUP1								DH_GROUP_1
#define POTF_OAKLEY_GROUP2								DH_GROUP_2
#define POTF_OAKLEY_GROUP2048							DH_GROUP_2048
#define OFFER_SEPARATOR									_TEXT(" \t")	// ForQMSEC/MMSEC
#define VALID_HEXIP										_TEXT("0123456789.xXaAbBcCdDeEfF")
//
// Define the  error codes
//
#define T2P_OK											((DWORD)0x0BBB0001L)
#define T2P_PASSTHRU_NOT_CLOSED							((DWORD)0xCBBB0002L)
#define T2P_DROP_NOT_CLOSED								((DWORD)0xCBBB0003L)
#define T2P_AHESP_INVALID								((DWORD)0xCBBB0004L)
#define T2P_ENCODE_FAILED								((DWORD)0xCBBB0005L)
#define T2P_NULL_STRING									((DWORD)0xCBBB0006L)
#define T2P_DNSLOOKUP_FAILED							((DWORD)0xCBBB0007L)
#define T2P_INVALID_ADDR								((DWORD)0xCBBB0008L)
#define T2P_GENERAL_PARSE_ERROR							((DWORD)0xCBBB0009L)
#define T2P_INVALID_P2REKEY_UNIT						((DWORD)0xCBBB000AL)
#define T2P_INVALID_HASH_ALG							((DWORD)0xCBBB000BL)
#define T2P_DUP_ALGS									((DWORD)0xCBBB000CL)
#define T2P_NONE_NONE									((DWORD)0xCBBB000EL)
#define T2P_INCOMPLETE_ESPALGS							((DWORD)0xCBBB000FL)
#define T2P_INVALID_IPSECPROT							((DWORD)0xCBBB0010L)
#define T2P_NO_PRESHARED_KEY							((DWORD)0xCBBB0011L)
#define T2P_INVALID_AUTH_METHOD							((DWORD)0xCBBB0012L)
#define T2P_INVALID_P1GROUP								((DWORD)0xCBBB0013L)
#define T2P_P1GROUP_MISSING								((DWORD)0xCBBB0014L)
#define T2P_INVALID_P1REKEY_UNIT						((DWORD)0xCBBB0015L)
#define T2P_P2REKEY_TOO_LOW								((DWORD)0xCBBB0016L)
#define T2P_P2_SECLIFE_INVALID							((DWORD)0xCBBB0017L)
#define T2P_P2_KBLIFE_INVALID							((DWORD)0xCBBB0018L)
#define T2P_P2_KS_INVALID								((DWORD)0xCBBB0019L)
#define T2P_INVALID_MASKADDR							((DWORD)0xCBBB001AL)
#define IP_MASK_ERROR									((DWORD)0xCBBB0020L)
#define IP_DECODE_ERROR									((DWORD)0xCBBB0021L)
#define T2P_SUCCESS(Status)   							((int)Status == T2P_OK)

#define NOT_FOUND_TAG									0
#define FOUND_NON_LIST_TAG								1
#define FOUND_LIST_TAG									2
//
// ERROR #define from the Parser Context
//
#define WIN32_ERR										0	// Error Types
#define IPSEC_ERR										1	// Error Types

//
// Protocol IDs
//
const DWORD PROT_ID_ANY				= 0;
const DWORD PROT_ID_ICMP			= 1;
const DWORD PROT_ID_TCP				= 6;
const DWORD PROT_ID_EGP				= 8;
const DWORD PROT_ID_UDP				= 17;
const DWORD PROT_ID_HMP				= 20;
const DWORD PROT_ID_XNS_IDP			= 22;
const DWORD PROT_ID_RDP				= 27;
const DWORD PROT_ID_RVD				= 66;
const DWORD PROT_ID_RAW				= 255;

const PROPERTY_ENABLEDIGNO			= 1;
const PROPERTY_IKELOG				= 2;
const PROPERTY_CRLCHK				= 3;
const PROPERTY_LOGINTER				= 4;
const PROPERTY_EXEMPT				= 5;
const PROPERTY_BOOTMODE				= 6;
const PROPERTY_BOOTEXEMP			= 7;

const VALUE_STATEFUL				= 3;
const VALUE_BLOCK					= 1;
const VALUE_PERMIT					= 0;

#define BOOTMODE_DEFAULT	VALUE_PERMIT

#define EXEMPT_ENTRY_TYPE_DEFAULT 0x00000001;
#define EXEMPT_ENTRY_SIZE_DEFAULT 0x00000010;

typedef struct _ERROR_TO_RC
{
    DWORD	dwErrCode;			// Ipsec Error Code
    DWORD   dwRcCode;			// Corresponding Error String ID in .RC
} ERROR_TO_RC;

typedef struct _CMD_PKT
{
	DWORD   dwCmdToken;			// ID of Info String
	VOID    *pArg;   			// Arg Pointer
	DWORD	dwStatus;			// For Non-List Commands Status Return Code ( 0 == Ok , N = ERR Code)
								// For List Commands Status Return Code ( 0 == Err, N= Num of List Args)
} CMD_PKT, *PCMD_PKT;

typedef struct _DNSIPADDR
{
	LPTSTR		pszDomainName;
	DWORD		dwNumIpAddresses;
	PULONG		puIpAddr;
}DNSIPADDR, *PDNSIPADDR;

typedef struct _TAG_NEEDED
{
	LPCWSTR		lpwstrTagName;	// Name of the needed TAG
	DWORD		dwTagFlag;		// TAG_NEEDED
								// TAG_GROUP1 ... TAG_GROUP#n
} TAG_NEEDED, *PTAG_NEEDED;

typedef struct _PARSER_PKT
{
	const TAG_TYPE	*ValidCmd;
	const TOKEN_VALUE	*ValidTok;
	const TOKEN_VALUE *ValidList;
	TAG_NEEDED  *TagNeeded;
	CMD_PKT	    Cmd[MAX_ARGS];
	DWORD		MaxTok;
	DWORD		MaxCmd;
	DWORD		MaxList;
	DWORD		MaxTag;
}PARSER_PKT,*PPARSER_PKT;

//
// local structures defined to support cert mapping, since parser gives
// the same (SPD) structure for both static and dynamic contexts
//
typedef struct _STA_MM_AUTH_METHODS
{
	DWORD dwSequence;
	BOOL bCertMappingSpecified;
	BOOL bCertMapping;
	BOOL bCRPExclude;
	PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo;  	// SPD Auth structure
} STA_MM_AUTH_METHODS, * PSTA_MM_AUTH_METHODS;

typedef struct _STA_AUTH_METHODS
{
	GUID gMMAuthID;
	DWORD dwFlags;
	DWORD dwNumAuthInfos;  							//count of auth methods
	PSTA_MM_AUTH_METHODS pAuthMethodInfo;
} STA_AUTH_METHODS, * PSTA_AUTH_METHODS;


DWORD
Parser(
	IN      LPCWSTR         pwszMachine,
	IN      LPTSTR          *ppwcArguments,
	IN      DWORD           dwCurrentIndex,
	IN      DWORD           dwArgCount,
    IN OUT  PARSER_PKT      *pParser
	);

DWORD
LoadParserOutput(
	OUT 	PARSER_PKT		*pParser,
	IN 		DWORD 			dwCount,
	OUT 	DWORD 			*dwUsed,
	IN 		LPTSTR 			str,
	IN 		DWORD  			dwTagType,
	IN  	DWORD			dwConversionType
	);

DWORD
RemoveList(
	IN	LPWSTR          *ppwcArguments,
	IN	DWORD           dwArgCount,
	IN	DWORD			dwCurrentIndex,
    IN  PARSER_PKT      *pParser,
    IN	LPTSTR 			pwcListCmd,
	IN	LPTSTR			szAnotherList, // Another ListCmd also present ...
    OUT	LPTSTR 			pwcListArgs,
    OUT	LPTSTR 			*pptok,
    IN  DWORD 			dwInputAllocLen
	);

DWORD
RemoveRootcaAuthMethods(
	IN	LPTSTR          *ppwcArguments,	// Input stream
	IN	DWORD           dwArgCount,		// Input arg count
	IN	DWORD			dwCurrentIndex,	// Input current arg index
    IN	PARSER_PKT      *pParser,		// contains the MaxTok
	IN	LPTSTR          szAnotherList, 	// Another ListCmd also present ...
    OUT	PSTA_MM_AUTH_METHODS	 		*paRootcaAuthMethods,	// o/p stream containing the list args
    OUT LPTSTR 			*ppwcTok,		// i/p stream stripped of list cmds
	OUT	DWORD			*pdwNumRootcaAuthMethods,
	IN  DWORD  			dwInputAllocLen,
	OUT PDWORD	pdwCount
	);

DWORD
MatchEnumTagToTagIndex(
	IN  LPTSTR			szToken,		// Input Token
	IN  PARSER_PKT		*pParser
	);

DWORD
CheckNeededTags(
	IN  LPTSTR          *ppwcArguments,	// Input stream
	IN  DWORD           dwArgCount,		// Input arg count
	IN  DWORD			dwCurrentIndex,	// Input current arg index
    IN	PARSER_PKT      *pParser		// contains the MaxTok
	);

DWORD
GetIpAddress(
	IN  LPTSTR			ppwcArg,
	OUT DNSIPADDR		*pipAddress
	);

BOOL
SplitCmdTok(
	IN		LPTSTR		szStr,
	OUT		LPTSTR		szCmd,
	OUT		LPTSTR		szTok,
	IN		DWORD  		dwCmdLen,
	IN		DWORD  		dwTokLen
	);

DWORD
TokenToIPAddr(
	IN		LPTSTR		szText,
	IN OUT	IPAddr		*pAddress,
	IN		BOOL		bTunnel,
	IN		BOOL		bMask
	);

DWORD
CheckIFType(
	IN		LPTSTR		SzText
	);

DWORD
CheckLocationType(
	IN		LPTSTR		SzText
	);

DWORD
CheckProtoType(
	IN		LPTSTR		SzText,
	OUT		PDWORD		dwValue
	);

DWORD
isdnsname(
	IN		LPTSTR		szStr
	);

DWORD
ValidateBool(
	IN		LPTSTR		ppcTok
	);

DWORD
CheckPFSGroup(
	IN		LPTSTR		str
	);

DWORD
CheckBound(
	IN		LPTSTR		SzText
	);

BOOL
IsWithinLimit(
	IN		DWORD		data,
	IN		DWORD		Min,
	IN		DWORD		Max
	);

DWORD
TokenToDNSIPAddr(
	IN		LPTSTR		szText,
	IN		DNSIPADDR	*Address,
	IN OUT	PDWORD		*pdwUsed
	);

VOID
InitializeGlobalPointers(
	VOID
	);

DWORD
TokenToProperty(
	IN		LPTSTR		SzText
	);

DWORD
TokenToType(
	IN LPTSTR SzText
	);

DWORD
TokenToStats(
	IN	LPTSTR SzText
	);

VOID
CleanUp(
	VOID
	);

VOID
DisplayAllocPtr(
	VOID
	);

VOID
PrintQMOfferError(
	IN DWORD 		dwStatus,
	IN PPARSER_PKT 	pParser,
	IN DWORD 		dwTagType
	);

DWORD
ValidateSplServer(
	IN LPTSTR szText
	);

VOID
PrintIPError(
	IN DWORD dwStatus,
	IN LPTSTR  szText
	);

DWORD
LoadLevel(
	IN 	LPTSTR 		szInput,
	OUT PARSER_PKT 	*pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadConnectionType(
	IN 	LPTSTR 		szInput,
	OUT PARSER_PKT 	*pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadLocationType(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD	 	pdwUsed,
	IN 	DWORD 		dwCount
	);
	
DWORD
LoadProtocol(
	IN 	LPTSTR 		szInput,
	OUT PARSER_PKT  *pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadPFSGroup(
	IN 	LPTSTR 		szInput,
	OUT PARSER_PKT  *pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadQMAction(
	IN 	LPTSTR 		szInput,
	OUT PARSER_PKT  *pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadFormat(
	IN 	LPTSTR 		szInput,
	OUT PARSER_PKT  *pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadFilterMode(
	IN 	LPTSTR 		szInput,
	OUT PARSER_PKT  *pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadOSType(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadProperty(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadPort(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadFilterType(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadStats(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadFilterType(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadUserInput(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadIPAddrTunnel(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount,
	IN 	BOOL 		bTunnel
	);

DWORD
LoadIPMask(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadQMOffers(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadMMOffers(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadDNSIPAddr(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadParserString(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN  DWORD 		dwTagType,
	IN  PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount,
	IN  BOOL 		bAppend,
	IN  LPTSTR 		szAppend
	);

DWORD
LoadDword(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadBoolWithOption(
	IN 	LPTSTR 		szInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount,
	IN 	BOOL 		bOption,
	IN	LPTSTR 		szCheckKeyWord
	);

DWORD
LoadKerbAuthInfo(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
LoadPskAuthInfo(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	);

DWORD
CheckCharForOccurances(
	IN 	LPTSTR 		szInput,
	IN	_TCHAR		chData
	);

DWORD
ConvertStringToDword(
	 IN LPTSTR szInput,
	 OUT PDWORD dwValue
	 );

#endif //_PARSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\nshpa.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// 	Header			: nshpa.cpp
//
// 	Purpose			: Policy agent related services.
//
// 	Developers Name	: Bharat/Radhika
//
//	History			:
//
//  Date			Author		Comments
//  9-8-2001   		Bharat		Initial Version. V1.0
//
/////////////////////////////////////////////////////////////////////////////////////////


#include "nshipsec.h"

/////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	PAIsRunning
//
//	Date of Creation: 	10-8-2001
//
//	Parameters		: 	OUT DWORD &dwError,
//						IN LPTSTR szServ
//
//	Return			: 	BOOL
//
//	Description		: 	PAIsRunning function finds out whether policy agent is started
//						on a specified machine or not.
//	Revision History:
//
// 	Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////////////////////

BOOL
PAIsRunning(
	OUT DWORD &dwError,
	IN LPTSTR szServ
	)
{
    BOOL bReturn = TRUE;		//	default is success..
	dwError = ERROR_SUCCESS;
	SC_HANDLE schMan = NULL;
	SC_HANDLE schPA = NULL;
	SERVICE_STATUS ServStat;

	//
	//initialization...
	//
	memset(&ServStat, 0, sizeof(SERVICE_STATUS));

	schMan = OpenSCManager(szServ, NULL, SC_MANAGER_ALL_ACCESS);
	if (schMan == NULL)
	{
		// if service open failed...
		dwError = GetLastError();
		bReturn = FALSE;
	}
	else
   	{
		//open policyagent service...
		schPA = OpenService(schMan,
							szPolAgent,
						  	SERVICE_QUERY_STATUS |
						  	SERVICE_START | SERVICE_STOP);
		if (schPA == NULL)
		{
			//if policyagent open fails...
			dwError = GetLastError();
			bReturn = FALSE;
		}
		else if (QueryServiceStatus(schPA, &ServStat))
		{
			// check the status finally...
			if (ServStat.dwCurrentState != SERVICE_RUNNING)
			{
				bReturn = FALSE;
			}
			CloseServiceHandle(schPA);
		}
		CloseServiceHandle(schMan);
   }
   return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\nshpa.h ===
////////////////////////////////////////////////////////////////////////
//
// 	Header			: nshpa.h
//
// 	Purpose			: Policy agent related services.
//
// 	Developers Name	: Bharat/Radhika
//
//	History			:
//
//  Date			Author		Comments
//  9-8-2001   	Bharat		Initial Version. V1.0
//
////////////////////////////////////////////////////////////////////////

#ifndef _NSHPA_H_
#define _NSHPA_H_


// const defs
const _TCHAR    szPolAgent[] = _TEXT("policyagent");

//
//Chacks for policyagent runnning or not.
//
BOOL
PAIsRunning(
	OUT DWORD &dwReturn,
	IN LPTSTR szServ = NULL
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\parser_dynamic.h ===
//////////////////////////////////////////////////////////////////////////////
// Module			:	parser_dynamic.h
//
// Purpose			:	All parser dynamic mode functions header file
//
// Developers Name	:	N.Surendra Sai / Vunnam Kondal Rao
//
// History			:
//
// Date	    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _PARSER_DYNAMIC_H_
#define _PARSER_DYNAMIC_H_

#include "nshipsec.h"

DWORD
ParseDynamicAddSetMMPolicy(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT 	*pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS],
		IN		BOOL 		bOption
		);
DWORD
ParseDynamicAddSetQMPolicy(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT 	*pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS],
		IN		BOOL		bOption
		);

DWORD
ParseDynamicShowPolFaction(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PARSER_PKT  *pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs
		);

DWORD
ParseDynamicShowQMFilter(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PARSER_PKT  *pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs
		);

DWORD
ParseDynamicShowMMSAS(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT 	*pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		);
DWORD
ParseDynamicShowQMSAS(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PARSER_PKT  *pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs
		);

DWORD
ParseDynamicDelPolFaction(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PARSER_PKT  *pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs
		);
DWORD
ParseDynamicDelQMFilter(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PARSER_PKT  *pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs
		);

DWORD
ParseDynamicDelMMFilter(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PARSER_PKT  *pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs
		);

DWORD
ParseDynamicSetConfig(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT 	*pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		);

DWORD
ParseDynamicDelRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT 	*pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		);

DWORD
ParseDynamicSetRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT 	*pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		);

DWORD
ParseDynamicAddRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT 	*pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		);

DWORD
ParseDynamicShowMMFilter(
		IN      LPWSTR     *ppwcArguments,
		IN OUT 	PARSER_PKT *pParser,
		IN 		DWORD dwCurrentIndex,
		IN 		DWORD dwMaxArgs
		);

DWORD
ParseDynamicShowRule(
		IN      LPWSTR     *ppwcArguments,
		IN OUT 	PARSER_PKT *pParser,
		IN 		DWORD dwCurrentIndex,
		IN 		DWORD dwMaxArgs
		);

DWORD
ParseDynamicShowStats(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT 	*pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		);

DWORD ParseDynamicShowAll(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT	pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs,
		IN 		DWORD		dwTagType[MAX_ARGS]
		);

#endif //_PARSER_DYNAMIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\parser_dynamic.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Module			:	parser_dynamic.cpp
//
// Purpose			: 	All parser dynamic mode functions
//
// Developers Name	:	N.Surendra Sai / Vunnam Kondal Rao
//
// History			:
//
// Date	    	Author    	Comments
// 27 Aug 2001
//
//////////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern  HINSTANCE g_hModule;

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicAddSetMMPolicy()
//
// Date of Creation	:	3rd oct 2001
//
// Parameters		:	IN 		LPTSTR		lppwszTok[MAX_ARGS],
//						IN 		_TCHAR 		szListTok[MAX_STR_LEN],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD		dwCurrentIndex,
//						IN 		DWORD		dwMaxArgs,
//						IN 		DWORD		dwTagType[MAX_ARGS],
//						IN		BOOL		flag
//
//
// Return			:	DWORD
//
// Description		:	This Function called by parser function.
//						It will separate the List and Non-List commands
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseDynamicAddSetMMPolicy(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS],
		IN		BOOL 		bOption
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0;
	DWORD dwIndex  = 0;
 	LPTSTR	szListTok		= NULL;
 	BOOL	bMMSECSpecified	= FALSE;

	szListTok = (LPTSTR)calloc(MAX_STR_LEN,sizeof(_TCHAR));
	if(szListTok == NULL)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturn = RETURN_NO_ERROR;
		BAIL_OUT;
	}
	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)	// If one token invalid dive out from the function
		{
			case CMD_TOKEN_NAME				:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_DEFRESPONSE		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			case CMD_TOKEN_SOFTSAEXPTIME	:
			case CMD_TOKEN_MMLIFETIME		:
			case CMD_TOKEN_QMPERMM			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_DWORD);
				break;
			case CMD_TOKEN_MMSECMETHODS		:
				bMMSECSpecified = TRUE;
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_MM_OFFER);
				break;
			default							:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}
	if( dwReturn == ERROR_SUCCESS )
	{
		if ( (!bMMSECSpecified) && (bOption == ADD_CMD) )		// if its an Add Cmd and no MMSec methods are specified,
																// ...then add defaults
		{
			_tcsncpy(szListTok,DEFAULT_MMSECMETHODS,MAX_STR_LEN-1);
			dwIndex = MatchEnumTagToTagIndex(CMD_TOKEN_STR_MMSECMETHODS,pParser);
			if(dwIndex == PARSE_ERROR)
			{
				dwReturn = ERROR_SHOW_USAGE;
				BAIL_OUT;
			}
			dwReturn = LoadParserOutput(pParser,dwMaxArgs,&dwUsed,szListTok,dwIndex,TYPE_MM_OFFER);
		}
	}
	free(szListTok);
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
// Function			:	ParseStaticAddSetQMPolicy()
//
// Date of Creation	:	5th oct 2001
//
// Parameters		:	IN 		lppwszTok[MAX_ARGS],
//						IN 		szListTok[MAX_STR_LEN],
//						IN OUT 	pParser,
//						IN 		dwCurrentIndex,
//						IN 		dwMaxArgs,
//						IN 		dwTagType[MAX_ARGS]
//
// Return			: 	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicQMPolicy
//						(Add/Set)
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseDynamicAddSetQMPolicy(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS],
		IN		BOOL		bOption
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0;
	DWORD dwIndex  = 0;
	LPTSTR szListTok				= NULL;
	BOOL   bNegotiationSpecified	= FALSE;

	szListTok = (LPTSTR)calloc(MAX_STR_LEN,sizeof(_TCHAR));
	if(szListTok == NULL)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturn = RETURN_NO_ERROR;
		BAIL_OUT;
	}
	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		// If one token invalid dive out from the function
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_NAME			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_DEFRESPONSE	:
			case CMD_TOKEN_SOFT			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			case CMD_TOKEN_PFSGROUP		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PFSGROUP);
				break;
			case CMD_TOKEN_NEGOTIATION	:
				bNegotiationSpecified = TRUE;
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_QM_OFFER);
				break;
			default						:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}
	if( dwReturn == ERROR_SUCCESS )
	{
		if ( !bNegotiationSpecified && (bOption == ADD_CMD))
		{
			// If its an Add cmd and no QMSec methods are specified, then add defaults
			_tcsncpy(szListTok,DEFAULT_QMSECMETHODS,MAX_STR_LEN-1);

			dwIndex = MatchEnumTagToTagIndex(CMD_TOKEN_STR_NEGOTIATION,pParser);
			if(dwIndex == PARSE_ERROR)
			{
				dwReturn = ERROR_SHOW_USAGE;
				BAIL_OUT;
			}
			dwReturn = LoadParserOutput(pParser,dwMaxArgs,&dwUsed,szListTok,dwIndex,TYPE_QM_OFFER);
		}
	}
	free(szListTok);
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicDelPolicy()
//
// Date of Creation	:	1st oct 2001
//
// Parameters		:	IN      LPWSTR     	*ppwcArguments,	// Input stream
//						IN OUT 	PPARSER_PKT	pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicDelelte
//						(QMPolicy/MMPolicy)
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ParseDynamicDelPolFaction(
		IN      LPWSTR     *ppwcArguments,	// Input stream
		IN OUT 	PARSER_PKT *pParser,
		IN 		DWORD dwCurrentIndex,
		IN 		DWORD dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex = 0,dwUsed = 0;
	DWORD dwReturn  = ERROR_SUCCESS;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ALL   		= 0;
	const DWORD INDEX_NAME 		= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ALL  		= 1;	// Commands as in the ValidToken Structure
	 									// with the 'untagged' arg

	if ( (dwMaxArgs - dwCurrentIndex) >= 2 )			// Max 1 Args Allowed
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMEALL);
		dwReturn = RETURN_NO_ERROR;
		BAIL_OUT;
	}

	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)		// Initialize
	{
		bArg[dwCount] = FALSE;
	}

	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);		// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)								// Parameter With Tag Found
		{
			dwNum = 0;									// Before sending to MatchEnumTag it is needed
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)									// Convert the output of MatchEnumTag into the TagIndex
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					 default				:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL  :
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
							dwReturn = RETURN_NO_ERROR;
						}
					}
					break;
				 default 	:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else
	{
		if (dwReturn == ERROR_SUCCESS)
		{
			if (!bArg[ARG_NAME] )
			{
				dwReturn = RETURN_NO_ERROR;
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMEALL);
			}
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Function			:	ParseDynamicSetConfig()
//
// Date of Creation	:	12th oct 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT	pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicSetConfig
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ParseDynamicSetConfig(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0/*,dwNum = 0*/;

 	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_PROPERTY		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PROPERTY);
				break;
			case CMD_TOKEN_VALUE	 	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			default						:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicAddRule()
//
// Date of Creation	:	10th oct 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN 		LPTSTR 		ppwcListTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS],
//						IN      DWORD		dwListArgs
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicAddRule
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ParseDynamicAddRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_QMPOLICY			:
			case CMD_TOKEN_MMPOLICY			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_OUTBOUND			:
			case CMD_TOKEN_INBOUND 			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOUND);
				break;
			case CMD_TOKEN_MIRROR			:
			case CMD_TOKEN_FAILMMIFEXISTS   :
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			case CMD_TOKEN_SRCMASK			:
		 	case CMD_TOKEN_DSTMASK			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_MASK);
				break;
			case CMD_TOKEN_SRCADDR			:
			case CMD_TOKEN_DSTADDR			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_IP);
				break;
 			case CMD_TOKEN_SRCPORT			:
			case CMD_TOKEN_DSTPORT			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PORT);
				break;
			case CMD_TOKEN_TUNNELDST		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_IP);
				break;
			case CMD_TOKEN_PROTO 			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PROTOCOL);
 				break;
			case CMD_TOKEN_CONNTYPE 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_CONNTYPE);
				break;
	            case CMD_TOKEN_KERB             :
	                dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_KERBAUTH);
	                break;
	            case CMD_TOKEN_PSK              :
	                dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PSKAUTH);
	                break;
			default							:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function				:	ParseDynamicSetRule()
//
// Date of Creation		:	15th oct 2001
//
// Parameters			:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//							IN 		LPTSTR 		ppwcListTok[MAX_ARGS],
//							IN OUT 	PPARSER_PKT pParser,
//							IN 		DWORD 		dwCurrentIndex,
//							IN 		DWORD 		dwMaxArgs,
//							IN 		DWORD 		dwTagType[MAX_ARGS],
//							IN      DWORD		dwListArgs
//
// Return				:	DWORD
//
// Description			:	Validates the arguments to the  contexts DynamicSetRule
//
// History				:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ParseDynamicSetRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_QMPOLICY			:
			case CMD_TOKEN_MMPOLICY			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_OUTBOUND			:
			case CMD_TOKEN_INBOUND 			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOUND);
				break;
			case CMD_TOKEN_MIRROR			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			case CMD_TOKEN_SRCADDR			:
			case CMD_TOKEN_DSTADDR			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_IP);
				break;
			case CMD_TOKEN_SRCMASK			:
			case CMD_TOKEN_DSTMASK			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_MASK);
				break;
 			case CMD_TOKEN_SRCPORT			:
			case CMD_TOKEN_DSTPORT			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PORT);
				break;
			case CMD_TOKEN_TUNNELDST		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_IP);
				break;
			case CMD_TOKEN_PROTO 			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PROTOCOL);
 				break;
			case CMD_TOKEN_CONNTYPE 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_CONNTYPE);
				break;
	            case CMD_TOKEN_KERB             :
	                dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_KERBAUTH);
	                break;
	            case CMD_TOKEN_PSK              :
	                dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PSKAUTH);
	                break;
			default							:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicDelRule()
//
// Date of Creation	:	12th oct 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS],
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicDelRule
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ParseDynamicDelRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn  == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_MIRROR			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			case CMD_TOKEN_SRCADDR			:
			case CMD_TOKEN_DSTADDR			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_IP);
				break;
			case CMD_TOKEN_SRCMASK			:
			case CMD_TOKEN_DSTMASK			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_MASK);
				break;

 			case CMD_TOKEN_SRCPORT			:
			case CMD_TOKEN_DSTPORT			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PORT);
				break;
			case CMD_TOKEN_TUNNELDST		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_IP);
				break;
			case CMD_TOKEN_PROTO 			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PROTOCOL);
 				break;
			case CMD_TOKEN_CONNTYPE 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_CONNTYPE);
				break;
			default							:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicShowPolicy()
//
// Date of Creation	:	29th aug 2001
//
// Parameters		:	IN      LPWSTR      *ppwcArguments,	// Input stream
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicShowPolicy
//						(MMPolicy/QMPolicy)
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseDynamicShowPolFaction(
		IN      LPWSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex = 0,dwReturn  = ERROR_SUCCESS,dwUsed 	= 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ALL   		= 0;

	const DWORD INDEX_NAME 		= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ALL  		= 1;	// Commands as in the ValidToken Structure

	if ( (dwMaxArgs - dwCurrentIndex) >= 2)
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}
	for(dwCount = 0; dwCount < MAX_ARGS;dwCount++)		// Initialize
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);		// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)								// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)									// Convert the output of MatchEnumTag into the TagIndex
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL	:
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
					}
					break;
				default 		:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
		dwReturn = RETURN_NO_ERROR;
	}
	else if( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME] ) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMEALL);
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicShowQMSAS()
//
// Date of Creation	:	19th aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicShowQMSAS
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD ParseDynamicShowQMSAS(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount, dwNum,dwTagIndex = 0,dwIndex = 0,dwReturn  = ERROR_SUCCESS,dwUsed	= 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_ALL 		= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_SRC			= 1;
	const DWORD ARG_DST			= 2;
	const DWORD ARG_PROTO		= 3;
	const DWORD ARG_FORMAT		= 4;
	const DWORD ARG_RESOLVEDNS	= 5;

	const DWORD INDEX_ALL 			= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_SRC  			= 1;
	const DWORD INDEX_DST  			= 2;	// Commands as in the ValidToken Structure
	const DWORD INDEX_PROTO			= 3;	// Commands as in the ValidToken Structure
	const DWORD INDEX_FORMAT		= 4;	// with the 'untagged' arg
	const DWORD INDEX_RESOLVEDNS	= 5;

	if ( (dwMaxArgs - dwCurrentIndex) >= 6 )			// Max 5 Args Allowed
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}
	for(dwCount=0;dwCount < MAX_ARGS;dwCount++)			// Initialize
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);		// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)								// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)									// Convert the output of MatchEnumTag into the TagIndex
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_ALL		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCADDR	:
						if (!bArg[ARG_SRC])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_IP);
							bArg[ARG_SRC] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTADDR	:
						if (!bArg[ARG_DST])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_IP);
							bArg[ARG_DST] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_PROTO	:
						if( !bArg[ARG_PROTO] )
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_PROTOCOL);
							bArg[ARG_PROTO] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_FORMAT	:
						if (!bArg[ARG_FORMAT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_FORMAT);
							bArg[ARG_FORMAT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_RESDNS	:
						if (!bArg[ARG_RESOLVEDNS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_RESOLVEDNS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 default				:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		} else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL		:
					if (!bArg[ARG_SRC] && !bArg[ARG_ALL] && !bArg[ARG_DST] && !bArg[ARG_PROTO])
					{
						if (_tcsicmp(szTok,ALL_STR) == 0)
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_SRC,TYPE_IP);
							bArg[ARG_SRC] = TRUE;
						}
					}else if (bArg[ARG_SRC] && !bArg[ARG_ALL] && !bArg[ARG_DST] )
					{
						if (_tcsicmp(szTok,ALL_STR) == 0)
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);

						}
						else
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_DST,TYPE_IP);
							bArg[ARG_DST] = TRUE;
						}
					}else if (bArg[ARG_SRC] && !bArg[ARG_ALL] && bArg[ARG_DST] && !bArg[ARG_PROTO])
					{
						if (_tcsicmp(szTok,ALL_STR) == 0)
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADDR_ALL_INVALID,pParser->ValidTok[dwIndex].pwszToken);
						}
						else
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_PROTO,TYPE_PROTOCOL);
							bArg[ARG_PROTO] = TRUE;
						}
					}else if (bArg[ARG_SRC] && !bArg[ARG_ALL] && bArg[ARG_DST] && bArg[ARG_PROTO] && !bArg[ARG_FORMAT])
					{
						if (_tcsicmp(szTok,ALL_STR) == 0)
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADDR_ALL_INVALID,pParser->ValidTok[dwIndex].pwszToken);
						}
						else
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_FORMAT,TYPE_FORMAT);
							bArg[ARG_FORMAT] = TRUE;
						}
					}
					else
					{
						if (_tcsicmp(szTok,ALL_STR) == 0)
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else if(bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_FORMAT,TYPE_FORMAT);
							bArg[ARG_FORMAT] = TRUE;
						}
						else
						{
							dwReturn = ERROR_SHOW_USAGE;
						}
					}
					break;
				case ARG_SRC			:
					if (!bArg[ARG_SRC] && !bArg[ARG_ALL])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_SRC,TYPE_IP);
						bArg[ARG_SRC] = TRUE;
					}
					else if(bArg[ARG_ALL])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_FORMAT,TYPE_FORMAT);
						bArg[ARG_FORMAT] = TRUE;
					}
					else
					{
						dwReturn = RETURN_NO_ERROR;
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADDR_ALL_INVALID,pParser->ValidTok[dwIndex].pwszToken);
					}
					break;
				case ARG_DST			:
					if (!bArg[ARG_DST] && !bArg[ARG_ALL])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_DST,TYPE_IP);
						bArg[ARG_DST] = TRUE;
					}
					else
					{
						dwReturn = RETURN_NO_ERROR;
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADDR_ALL_INVALID,pParser->ValidTok[dwIndex].pwszToken);
					}
					break;
				case ARG_PROTO			:
					if ( (!bArg[ARG_PROTO] && !bArg[ARG_ALL]) && (bArg[ARG_SRC] || bArg[ARG_DST]) )
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_PROTO,TYPE_PROTOCOL);
						bArg[ARG_PROTO] = TRUE;
					}
					else
					{
						dwReturn = RETURN_NO_ERROR;
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADDR_ALL_INVALID,pParser->ValidTok[dwIndex].pwszToken);
					}
					break;
				case ARG_FORMAT			:
					if (!bArg[ARG_FORMAT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_FORMAT,TYPE_FORMAT);
						bArg[ARG_FORMAT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_RESOLVEDNS		:
					if (!bArg[ARG_RESOLVEDNS])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_RESOLVEDNS,TYPE_BOOL);
						bArg[ARG_RESOLVEDNS] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default 				:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
		dwReturn = RETURN_NO_ERROR;
	}

error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicShowMMFilter()
//
// Date of Creation	:	19th Aug 2001
//
// Parameters		:	IN      LPWSTR     *ppwcArguments,	// Input stream
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicShowMMFilter
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ParseDynamicShowMMFilter(
		IN      LPWSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum	= 0,dwTagIndex = 0,dwIndex = 0;
	DWORD dwReturn  = ERROR_SUCCESS,dwUsed = 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;		// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ALL   		= 0;
	const DWORD ARG_FILTERTYPE	= 1;
	const DWORD ARG_SRCADDR		= 2;
	const DWORD ARG_DSTADDR		= 3;
	const DWORD ARG_SRCMASK		= 4;
	const DWORD ARG_DSTMASK		= 5;
	const DWORD ARG_RESOLVEDNS	= 6;

	const DWORD INDEX_NAME 			= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ALL  			= 1;	// Commands as in the ValidToken Structure
	const DWORD INDEX_FILTERTYPE	= 2;
	const DWORD INDEX_SRCADDR		= 3;
	const DWORD INDEX_DSTADDR		= 4;
	const DWORD INDEX_SRCMASK		= 5;
	const DWORD INDEX_DSTMASK		= 6;
	const DWORD INDEX_RESOLVEDNS	= 7;

	if ( (dwMaxArgs - dwCurrentIndex) >= 8 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount=0;dwCount < MAX_ARGS;dwCount++)
	{
		bArg[dwCount] = FALSE;
	}

	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);		// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)								// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)									// Convert the output of MatchEnumTag into the TagIndex
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
						break;
					case CMD_TOKEN_TYPE	:
						if (!bArg[ARG_FILTERTYPE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_FILTER);
							bArg[ARG_FILTERTYPE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCADDR	:
						if (!bArg[ARG_SRCADDR])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_IP);
							bArg[ARG_SRCADDR] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTADDR	:
						if (!bArg[ARG_DSTADDR])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_IP);
							bArg[ARG_DSTADDR] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCMASK	:
						if (!bArg[ARG_SRCMASK])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MASK);
							bArg[ARG_SRCMASK] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTMASK	:
						if (!bArg[ARG_SRCMASK])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MASK);
							bArg[ARG_DSTMASK] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_RESDNS	:
						if (!bArg[ARG_RESOLVEDNS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_RESOLVEDNS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else			// Parameter Without a Tag Found
		{				// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL	:
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
					}
					break;
				case ARG_FILTERTYPE		:
					if (!bArg[ARG_FILTERTYPE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_FILTERTYPE,TYPE_FILTER);
						bArg[ARG_FILTERTYPE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SRCADDR		:
					if (!bArg[ARG_SRCADDR])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_SRCADDR,TYPE_IP);
						bArg[ARG_SRCADDR] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DSTADDR		:
					if (!bArg[ARG_DSTADDR])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_DSTADDR,TYPE_IP);
						bArg[ARG_DSTADDR] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SRCMASK		:
					if (!bArg[ARG_SRCMASK])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_SRCMASK,TYPE_MASK);
						bArg[ARG_SRCMASK] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DSTMASK		:
					if (!bArg[ARG_DSTMASK])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_DSTMASK,TYPE_MASK);
						bArg[ARG_DSTMASK] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_RESOLVEDNS		:
					if (!bArg[ARG_RESOLVEDNS])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_RESOLVEDNS,TYPE_BOOL);
						bArg[ARG_RESOLVEDNS] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default 			:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME] ) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMEALL);
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicShowQMFilter()
//
// Date of Creation	:	29th Aug 2001
//
// Parameters		:	IN      LPWSTR      *ppwcArguments,	// Input stream
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  contexts DynamicShowQMFilter
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ParseDynamicShowQMFilter(
		IN      LPWSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum	= 0,dwTagIndex = 0,dwIndex = 0;
	DWORD dwReturn  = ERROR_SUCCESS,dwUsed = 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;		// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ALL   		= 0;
	const DWORD ARG_FILTERTYPE	= 1;
	const DWORD ARG_SRCADDR		= 2;
	const DWORD ARG_DSTADDR		= 3;
	const DWORD ARG_SRCMASK		= 4;
	const DWORD ARG_DSTMASK		= 5;
	const DWORD ARG_PROTO		= 6;
	const DWORD ARG_SRCPORT		= 7;
	const DWORD ARG_DSTPORT		= 8;
	const DWORD ARG_ACTINBOUND	= 9;
	const DWORD ARG_ACTOUTBOUND	= 10;
	const DWORD ARG_RESOLVEDNS	= 11;

	const DWORD INDEX_NAME 			= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ALL  			= 1;	// Commands as in the ValidToken Structure
	const DWORD INDEX_FILTERTYPE	= 2;
	const DWORD INDEX_SRCADDR		= 3;
	const DWORD INDEX_DSTADDR		= 4;
	const DWORD INDEX_SRCMASK		= 5;
	const DWORD INDEX_DSTMASK		= 6;
	const DWORD INDEX_PROTO			= 7;
	const DWORD INDEX_SRCPORT		= 8;
	const DWORD INDEX_DSTPORT		= 9;
	const DWORD INDEX_ACTINBOUND	= 10;
	const DWORD INDEX_ACTOUTBOUND	= 11;
	const DWORD INDEX_RESOLVEDNS	= 12;

	if ( (dwMaxArgs - dwCurrentIndex) >= 13 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount =0;dwCount < MAX_ARGS;dwCount++)
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)									// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)										// Convert the output of MatchEnumTag into the TagIndex
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
						break;
					case CMD_TOKEN_TYPE	:
						if (!bArg[ARG_FILTERTYPE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_FILTER);
							bArg[ARG_FILTERTYPE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCADDR	:
						if (!bArg[ARG_SRCADDR])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_IP);
							bArg[ARG_SRCADDR] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTADDR	:
						if (!bArg[ARG_DSTADDR])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_IP);
							bArg[ARG_DSTADDR] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCMASK	:
						if (!bArg[ARG_SRCMASK])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MASK);
							bArg[ARG_SRCMASK] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTMASK	:
						if (!bArg[ARG_SRCMASK])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MASK);
							bArg[ARG_DSTMASK] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_PROTO	:
						if (!bArg[ARG_PROTO])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_PROTOCOL);
							bArg[ARG_PROTO] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCPORT	:
						if (!bArg[ARG_SRCPORT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_PORT);
							bArg[ARG_SRCPORT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTPORT	:
						if (!bArg[ARG_DSTPORT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_PORT);
							bArg[ARG_DSTPORT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_INBOUND	:
						if (!bArg[ARG_ACTINBOUND])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOUND);
							bArg[ARG_ACTINBOUND] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_OUTBOUND	:
						if (!bArg[ARG_ACTOUTBOUND])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOUND);
							bArg[ARG_ACTOUTBOUND] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;

					case CMD_TOKEN_RESDNS	:
						if (!bArg[ARG_RESOLVEDNS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_RESOLVEDNS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else			// Parameter Without a Tag Found
		{				// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL	:
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = RETURN_NO_ERROR;
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
						}
					}
					break;
				case ARG_FILTERTYPE		:
					if (!bArg[ARG_FILTERTYPE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_FILTERTYPE,TYPE_FILTER);
						bArg[ARG_FILTERTYPE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SRCADDR		:
					if (!bArg[ARG_SRCADDR])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_SRCADDR,TYPE_IP);
						bArg[ARG_SRCADDR] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DSTADDR		:
					if (!bArg[ARG_DSTADDR])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_DSTADDR,TYPE_IP);
						bArg[ARG_DSTADDR] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SRCMASK		:
					if (!bArg[ARG_SRCMASK])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_SRCMASK,TYPE_MASK);
						bArg[ARG_SRCMASK] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DSTMASK		:
					if (!bArg[ARG_DSTMASK])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_DSTMASK,TYPE_MASK);
						bArg[ARG_DSTMASK] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_PROTO		:
					if (!bArg[ARG_PROTO])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_PROTO,TYPE_PROTOCOL);
						bArg[ARG_PROTO] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SRCPORT		:
					if (!bArg[ARG_SRCPORT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_SRCPORT,TYPE_PORT);
						bArg[ARG_SRCPORT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DSTPORT		:
					if (!bArg[ARG_DSTPORT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_DSTPORT,TYPE_PORT);
						bArg[ARG_DSTPORT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ACTINBOUND		:
					if (!bArg[ARG_ACTINBOUND])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ACTINBOUND,TYPE_BOUND);
						bArg[ARG_ACTINBOUND] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ACTOUTBOUND	:
					if (!bArg[ARG_ACTOUTBOUND])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ACTOUTBOUND,TYPE_BOUND);
						bArg[ARG_ACTOUTBOUND] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_RESOLVEDNS		:
					if (!bArg[ARG_RESOLVEDNS])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_RESOLVEDNS,TYPE_BOOL);
						bArg[ARG_RESOLVEDNS] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default 			:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if ( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME]) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMEALL);
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicShowRule()
//
// Date of Creation	:	29th aug 2001
//
// Parameters		:	IN      LPWSTR      *ppwcArguments,	// Input stream
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  context DynamicShowRule
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ParseDynamicShowRule(
		IN      LPWSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum	= 0,dwTagIndex = 0,dwIndex = 0;
	DWORD dwReturn  = ERROR_SUCCESS,dwUsed = 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_FILTERTYPE	= 0;
	const DWORD ARG_SRCADDR		= 1;
	const DWORD ARG_DSTADDR		= 2;
	const DWORD ARG_SRCMASK		= 3;
	const DWORD ARG_DSTMASK		= 4;
	const DWORD ARG_PROTO		= 5;
	const DWORD ARG_SRCPORT		= 6;
	const DWORD ARG_DSTPORT		= 7;
	const DWORD ARG_ACTINBOUND	= 8;
	const DWORD ARG_ACTOUTBOUND	= 9;
	const DWORD ARG_RESOLVEDNS	= 10;

	const DWORD INDEX_FILTERTYPE	= 0;
	const DWORD INDEX_SRCADDR		= 1;
	const DWORD INDEX_DSTADDR		= 2;
	const DWORD INDEX_SRCMASK		= 3;
	const DWORD INDEX_DSTMASK		= 4;
	const DWORD INDEX_PROTO			= 5;
	const DWORD INDEX_SRCPORT		= 6;
	const DWORD INDEX_DSTPORT		= 7;
	const DWORD INDEX_ACTINBOUND	= 8;
	const DWORD INDEX_ACTOUTBOUND	= 9;
	const DWORD INDEX_RESOLVEDNS	= 10;


	if ( (dwMaxArgs - dwCurrentIndex) >= 12 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)
	{
		bArg[dwCount] = FALSE;
	}

	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);		// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)								// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)									// Convert the output of MatchEnumTag into the TagIndex
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_TYPE	:
						if (!bArg[ARG_FILTERTYPE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MODE);
							bArg[ARG_FILTERTYPE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCADDR	:
						if (!bArg[ARG_SRCADDR])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_IP);
							bArg[ARG_SRCADDR] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTADDR	:
						if (!bArg[ARG_DSTADDR])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_IP);
							bArg[ARG_DSTADDR] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCMASK	:
						if (!bArg[ARG_SRCMASK])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MASK);
							bArg[ARG_SRCMASK] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTMASK	:
						if (!bArg[ARG_SRCMASK])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MASK);
							bArg[ARG_DSTMASK] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_PROTO	:
						if (!bArg[ARG_PROTO])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_PROTOCOL);
							bArg[ARG_PROTO] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SRCPORT	:
						if (!bArg[ARG_SRCPORT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_PORT);
							bArg[ARG_SRCPORT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DSTPORT	:
						if (!bArg[ARG_DSTPORT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_PORT);
							bArg[ARG_DSTPORT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_INBOUND	:
						if (!bArg[ARG_ACTINBOUND])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOUND);
							bArg[ARG_ACTINBOUND] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_OUTBOUND	:
						if (!bArg[ARG_ACTOUTBOUND])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOUND);
							bArg[ARG_ACTOUTBOUND] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;

					case CMD_TOKEN_RESDNS	:
						if (!bArg[ARG_RESOLVEDNS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_RESOLVEDNS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else			// Parameter Without a Tag Found
		{				// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_FILTERTYPE		:
					if (!bArg[ARG_FILTERTYPE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_FILTERTYPE,TYPE_MODE);
						bArg[ARG_FILTERTYPE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SRCADDR		:
					if (!bArg[ARG_SRCADDR])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_SRCADDR,TYPE_IP);
						bArg[ARG_SRCADDR] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DSTADDR		:
					if (!bArg[ARG_DSTADDR])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_DSTADDR,TYPE_IP);
						bArg[ARG_DSTADDR] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SRCMASK		:
					if (!bArg[ARG_SRCMASK])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_SRCMASK,TYPE_MASK);
						bArg[ARG_SRCMASK] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DSTMASK		:
					if (!bArg[ARG_DSTMASK])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_DSTMASK,TYPE_MASK);
						bArg[ARG_DSTMASK] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_PROTO		:
					if (!bArg[ARG_PROTO])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_PROTO,TYPE_PROTOCOL);
						bArg[ARG_PROTO] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SRCPORT		:
					if (!bArg[ARG_SRCPORT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_SRCPORT,TYPE_PORT);
						bArg[ARG_SRCPORT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DSTPORT		:
					if (!bArg[ARG_DSTPORT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_DSTPORT,TYPE_PORT);
						bArg[ARG_DSTPORT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ACTINBOUND		:
					if (!bArg[ARG_ACTINBOUND])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ACTINBOUND,TYPE_BOUND);
						bArg[ARG_ACTINBOUND] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ACTOUTBOUND	:
					if (!bArg[ARG_ACTOUTBOUND])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ACTOUTBOUND,TYPE_BOUND);
						bArg[ARG_ACTOUTBOUND] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_RESOLVEDNS		:
					if (!bArg[ARG_RESOLVEDNS])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_RESOLVEDNS,TYPE_BOOL);
						bArg[ARG_RESOLVEDNS] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default 			:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Function			:	ParseDynamicShowStats()
//
// Date of Creation	:	29th aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  context DynamicShowStats
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD
ParseDynamicShowStats(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0;

 	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_TYPE		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STATS);
				break;
			default					:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicShowMMSAS()
//
// Date of Creation	:	29th aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	Validates the arguments to the  context DynamicShowMMSAS
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD
ParseDynamicShowMMSAS(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0/*,dwNum = 0*/;

 	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_ALL			:
				break;
			case CMD_TOKEN_SRCADDR	:
			case CMD_TOKEN_DSTADDR	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_IP);
				break;
			case CMD_TOKEN_FORMAT	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_FORMAT);
				break;
			case CMD_TOKEN_RESDNS	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			default					:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseDynamicShowAll()
//
// Date of Creation	:	31st Jan 2002
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the ParseDynamicShowAll context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD ParseDynamicShowAll(
	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
	IN OUT 	PPARSER_PKT	pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	)
{
	DWORD dwReturn	= ERROR_SUCCESS,dwCount,dwUsed=0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_RESDNS 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			default						:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\parser_static.h ===
//////////////////////////////////////////////////////////////////////////////
// Module			:	parser_static.h
//
// Purpose			:	All Parser Header for Static Mode Commands
//
// Developers Name	:	N.Surendra Sai / Vunnam Kondal Rao
//
// History			:
//
// Date	    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _PARSER_STATIC_H_
#define _PARSER_STATIC_H_

#include "nshipsec.h"

DWORD
ParseStaticAddPolicy(
	IN		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticSetPolicy(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticDelPolFlistFaction(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticAddFilterList(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN 		_TCHAR		szListTok[MAX_STR_LEN],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticSetFilterList(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticDelFilterList(
	IN      LPTSTR		ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticAddFilter(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticDelFilter(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticRestoreDefaults(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticAddFilterAction(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticSetFilterAction(
	IN      LPTSTR      *ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticDelFilterAction(
	IN      LPTSTR		ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticAddRule(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticDelRule(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticSetDefaultRule(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
 	IN OUT 	PARSER_PKT 	*pParser,
	IN 		DWORD 		dwCurrentIndex,
	IN 		DWORD 		dwMaxArgs,
	IN 		DWORD 		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticSetStore(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticExportPolicy(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticImportPolicy(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticSetInteractive(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticShowFilterList(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticShowFilterActions(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticShowRule(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN		DWORD		dwMaxArgs
	);

DWORD
ParseStaticShowPolicy(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticShowAssignedPolicy(
	IN      LPTSTR		*ppwcArguments,
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs
	);

DWORD
ParseStaticAll(
	IN 		LPTSTR		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD		dwCurrentIndex,
	IN 		DWORD		dwMaxArgs,
	IN 		DWORD		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticSetRule(
	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
	IN OUT 	PARSER_PKT  *pParser,
	IN 		DWORD 		dwCurrentIndex,
	IN 		DWORD 		dwMaxArgs,
	IN 		DWORD 		dwTagType[MAX_ARGS]
	);

DWORD
ParseStaticShowFilterAction(
		IN      LPTSTR     *ppwcArguments,
		IN OUT 	PARSER_PKT *pParser,
		IN 		DWORD dwCurrentIndex,
		IN 		DWORD dwMaxArgs
		);

#endif //_PARSER_STATIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\parser_util.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Module			:	parser_util.h
//
// Purpose			: 	Header file for all utility functions used by the parser
//
// Developers Name	:	N.Surendra Sai / Vunnam Kondal Rao
//
// History			:
//
// Date	    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _PARSER_UTIL_H_
#define _PARSER_UTIL_H_

#include "nshipsec.h"
#include "staticset.h"

#define IKE_SSPI_NULL		0xFFFFFFFF
//
// String to Structure Converter Functions
//
DWORD
ListToSecMethod(
	IN		LPTSTR			szText,
	IN OUT 	IPSEC_MM_OFFER 	&SecMethod
	);

DWORD
ListToCertAuths(
	IN	LPTSTR					szText,
	OUT INT_IPSEC_MM_AUTH_INFO 	&AuthInfo,
	IN	PDWORD 					pdwAuthType
	);

DWORD
ListToOffer(
	IN		LPTSTR			szText,
	IN OUT 	IPSEC_QM_OFFER 	&Offer
	);

DWORD
TextToAlgoInfo(
	IN	LPTSTR			szText,
	OUT IPSEC_QM_ALGO 	&algoInfo
	);

DWORD
EncodeCertificateName (
	IN 	LPTSTR pszSubjectName,
	OUT LPBYTE *EncodedName,
	OUT PDWORD pEncodedNameLength
	);

VOID
LoadSecMethodDefaults(
	IN OUT IPSEC_MM_OFFER &SecMethod
	);

VOID
LoadQMOfferDefaults(
	IPSEC_QM_OFFER &offer
	);

DWORD
CheckForCertParamsAndRemove(
	IN OUT	LPTSTR 	szText,
	OUT 	PBOOL 	pbCertMapSpecified,
	OUT 	PBOOL   	pbCertMap,
	OUT		PBOOL	pbCRPExclude
	);

DWORD
GenerateKerbAuthInfo(
    OUT STA_MM_AUTH_METHODS** ppInfo
    );

DWORD
GeneratePskAuthInfo(
    OUT STA_MM_AUTH_METHODS** ppInfo,
    IN LPTSTR lpKey
    );

DWORD
GenerateRootcaAuthInfo(
    OUT STA_MM_AUTH_METHODS** ppInfo,
    IN LPTSTR lpKey
    );

DWORD
FillAuthMethodInfo(
    IN PARSER_PKT* pParser,
    OUT PRULEDATA pRuleData);

DWORD
ProcessEscapedCharacters(wchar_t* lptString);

DWORD
AddAllAuthMethods(
	PRULEDATA pRuleData,
	PSTA_AUTH_METHODS pKerbAuth,
	PSTA_AUTH_METHODS pPskAuth,
	PSTA_MM_AUTH_METHODS *ppRootcaMMAuth,
	BOOL bAddDefaults
	);

#endif //_PARSER_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\resource.h ===
/////////////////////////////////////////////////////////////////////////
//	Header			: 	Resource.h
//
//	Purpose			: 	Identifiers for string table and Netsh framework.
//
//	Developers Name	: 	Bharat/Radhika
//
//	History			:
//
//	Date    	Author    	Comments
//	10-8-2001	Bharat		Initial Version. SCM Base line 1.0
//
/////////////////////////////////////////////////////////////////////////

//
// Common defs
//

#define HLP_IPSEC_BASE                   					(10000)

#define HLP_STATIC_BASE            		 					(1000)
#define HLP_DYNAMIC_BASE           		 					(2000)
#define SHW_STATIC_BASE										(3000)
#define SHW_DYANMIC_BASE									(9000)
#define HLP_ERROR_BASE           		 					(12000)

#define ERROR_BASE_DYNAMIC									(1000)

#define HLP_TOPLEVEL_BASE            	 					(100)
#define HLP_ADD_BASE            		 					(200)
#define HLP_SET_BASE            		 					(300)
#define HLP_DELETE_BASE         		 					(400)
#define HLP_SHOW_BASE           		 					(500)

//
// These are context names.
//
#define TOKEN_IPSEC                     					_TEXT("ipsec")
#define TOKEN_STATIC                						_TEXT("static")
#define TOKEN_DYNAMIC		          						_TEXT("dynamic")

//
// These are group names.
//
#define TOKEN_GROUP_ADD    									_TEXT("add")
#define TOKEN_GROUP_SET    									_TEXT("set")
#define TOKEN_GROUP_DELETE    								_TEXT("delete")
#define TOKEN_GROUP_SHOW    		    					_TEXT("show")

//
// These are command names.
//
#define TOKEN_POLICY                						_TEXT("policy")
#define TOKEN_QMPOLICY										_TEXT("qmpolicy")
#define TOKEN_MMPOLICY										_TEXT("mmpolicy")
#define TOKEN_MMFILTER										_TEXT("mmfilter")
#define TOKEN_QMFILTER										_TEXT("qmfilter")
#define TOKEN_STATS											_TEXT("stats")
#define TOKEN_MMSAS											_TEXT("mmsas")
#define TOKEN_QMSAS											_TEXT("qmsas")
#define TOKEN_REGKEYS										_TEXT("config")
#define TOKEN_CONFIG										_TEXT("config")

#define TOKEN_FILTERLIST            						_TEXT("filterlist")
#define TOKEN_FILTER	            						_TEXT("filter")
#define TOKEN_FILTERACTIONS         						_TEXT("filteraction")
#define TOKEN_RULE                      					_TEXT("rule")
#define TOKEN_STORE                     					_TEXT("store")
#define TOKEN_ALL                       					_TEXT("all")
#define TOKEN_DEFAULTRULE									_TEXT("defaultrule")
#define TOKEN_EXPORTPOLICY            						_TEXT("exportpolicy")
#define TOKEN_IMPORTPOLICY              					_TEXT("importpolicy")
#define TOKEN_RESTOREDEFAULTS								_TEXT("restorepolicyexamples")
#define TOKEN_ENBDIAG										_TEXT("enablediagnostics")
#define TOKEN_NODEFEXEM										_TEXT("nodefaultexempt")
#define TOKEN_LOGINT										_TEXT("loginterval")
#define TOKEN_STRGCRLC										_TEXT("strongcrlcheck")
#define TOKEN_GPOASSIGNEDPOLICY								_TEXT("gpoassignedpolicy")
#define TOKEN_INTERACTIVE									_TEXT("interactive")
#define TOKEN_ENABLELOGINT									_TEXT("enablelogging")
#define TOKEN_BATCH											_TEXT("batch")

//
// Static Top Level
//
#define CMD_STATIC_EXPORTPOLICY                				TOKEN_EXPORTPOLICY
#define CMD_STATIC_IMPORTPOLICY                				TOKEN_IMPORTPOLICY
#define CMD_STATIC_RESTOREDEFAULTS             				TOKEN_RESTOREDEFAULTS

#define HLP_STATIC_EXPORTPOLICY                				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_TOPLEVEL_BASE + 10
#define HLP_STATIC_IMPORTPOLICY                				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_TOPLEVEL_BASE + 11
#define HLP_STATIC_RESTOREDEFAULTS             				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_TOPLEVEL_BASE + 12

#define HLP_STATIC_EXPORTPOLICY_EX              			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_TOPLEVEL_BASE + 50
#define HLP_STATIC_IMPORTPOLICY_EX              			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_TOPLEVEL_BASE + 51
#define HLP_STATIC_RESTOREDEFAULTS_EX          				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_TOPLEVEL_BASE + 52

//
// Static Add Group
//
#define CMD_STATIC_GROUP_ADD    							TOKEN_GROUP_ADD
#define HLP_STATIC_GROUP_ADD  								HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 0

#define CMD_STATIC_ADD_POLICY           					TOKEN_POLICY
#define CMD_STATIC_ADD_FILTERLIST               			TOKEN_FILTERLIST
#define CMD_STATIC_ADD_FILTER	                			TOKEN_FILTER
#define CMD_STATIC_ADD_FILTERACTIONS            			TOKEN_FILTERACTIONS
#define CMD_STATIC_ADD_RULE             	    			TOKEN_RULE

#define HLP_STATIC_ADD_POLICY           					HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 10
#define HLP_STATIC_ADD_FILTERLIST               			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 11
#define HLP_STATIC_ADD_FILTERACTIONS            			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 12
#define HLP_STATIC_ADD_RULE             	    			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 13
#define HLP_STATIC_ADD_FILTER	                			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 14

#define HLP_STATIC_ADD_POLICY_EX          					HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 50
#define HLP_STATIC_ADD_FILTERLIST_EX       	    			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 51
#define HLP_STATIC_ADD_FILTERACTIONS_EX    	    			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 52
#define HLP_STATIC_ADD_RULE_EX             					HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 53
#define HLP_STATIC_ADD_FILTER_EX	       	    			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_ADD_BASE + 54

//
// Static Set Group
//
#define CMD_STATIC_GROUP_SET    							TOKEN_GROUP_SET
#define HLP_STATIC_GROUP_SET  								HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 0

#define CMD_STATIC_SET_POLICY                				TOKEN_POLICY
#define CMD_STATIC_SET_FILTERLIST               			TOKEN_FILTERLIST
#define CMD_STATIC_SET_FILTERACTIONS            			TOKEN_FILTERACTIONS
#define CMD_STATIC_SET_RULE                  				TOKEN_RULE
#define CMD_STATIC_SET_STORE               	    			TOKEN_STORE
#define CMD_STATIC_SET_DEFAULTRULE              			TOKEN_DEFAULTRULE
#define CMD_STATIC_SET_INTERACTIVE							TOKEN_INTERACTIVE
#define CMD_STATIC_SET_BATCH								TOKEN_BATCH


#define HLP_STATIC_SET_POLICY                				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 10
#define HLP_STATIC_SET_FILTERLIST               			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 11
#define HLP_STATIC_SET_FILTERACTIONS            			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 12
#define HLP_STATIC_SET_RULE                  				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 13
#define HLP_STATIC_SET_STORE               	    			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 14
#define HLP_STATIC_SET_DEFAULTRULE              			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 15
#define HLP_STATIC_SET_INTERACTIVE							HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 16
#define HLP_STATIC_SET_BATCH								HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 17


#define HLP_STATIC_SET_POLICY_EX                			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 50
#define HLP_STATIC_SET_FILTERLIST_EX            			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 51
#define HLP_STATIC_SET_FILTERACTIONS_EX         			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 52
#define HLP_STATIC_SET_RULE_EX                  			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 53
#define HLP_STATIC_SET_STORE_EX                				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 54
#define HLP_STATIC_SET_DEFAULTRULE_EX           			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 55
#define HLP_STATIC_SET_INTERACTIVE_EX						HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 56
#define HLP_STATIC_SET_BATCH_EX								HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SET_BASE + 57

//
// Static Delete Group
//
#define CMD_STATIC_GROUP_DELETE    							TOKEN_GROUP_DELETE
#define HLP_STATIC_GROUP_DELETE  							HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 0

#define CMD_STATIC_DELETE_POLICY                			TOKEN_POLICY
#define CMD_STATIC_DELETE_FILTERLIST            			TOKEN_FILTERLIST
#define CMD_STATIC_DELETE_FILTER	            			TOKEN_FILTER
#define CMD_STATIC_DELETE_FILTERACTIONS         			TOKEN_FILTERACTIONS
#define CMD_STATIC_DELETE_RULE                  			TOKEN_RULE
#define CMD_STATIC_DELETE_ALL	                			TOKEN_ALL


#define HLP_STATIC_DELETE_POLICY                			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 10
#define HLP_STATIC_DELETE_FILTERLIST            			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 11
#define HLP_STATIC_DELETE_FILTERACTIONS         			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 12
#define HLP_STATIC_DELETE_RULE                  			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 13
#define HLP_STATIC_DELETE_FILTER		        			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 14
#define HLP_STATIC_DELETE_ALL			        			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 15

#define HLP_STATIC_DELETE_POLICY_EX             			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 50
#define HLP_STATIC_DELETE_FILTERLIST_EX         			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 51
#define HLP_STATIC_DELETE_FILTERACTIONS_EX      			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 52
#define HLP_STATIC_DELETE_RULE_EX               			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 53
#define HLP_STATIC_DELETE_FILTER_EX		        			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 54
#define HLP_STATIC_DELETE_ALL_EX		        			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_DELETE_BASE + 55

//
// Static Show Group
//
#define CMD_STATIC_GROUP_SHOW   							TOKEN_GROUP_SHOW
#define HLP_STATIC_GROUP_SHOW  								HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 0

#define CMD_STATIC_SHOW_POLICY                  			TOKEN_POLICY
#define CMD_STATIC_SHOW_FILTERLIST              			TOKEN_FILTERLIST
#define CMD_STATIC_SHOW_FILTERACTIONS           			TOKEN_FILTERACTIONS
#define CMD_STATIC_SHOW_RULE                    			TOKEN_RULE
#define CMD_STATIC_SHOW_ALL                    				TOKEN_ALL
#define CMD_STATIC_SHOW_STORE                  				TOKEN_STORE
#define CMD_STATIC_SHOW_GPOASSIGNEDPOLICY      				TOKEN_GPOASSIGNEDPOLICY

#define HLP_STATIC_SHOW_POLICY                  			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 10
#define HLP_STATIC_SHOW_FILTERLIST              			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 11
#define HLP_STATIC_SHOW_FILTERACTIONS           			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 12
#define HLP_STATIC_SHOW_RULE                    			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 13
#define HLP_STATIC_SHOW_ALL                     			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 15
#define HLP_STATIC_SHOW_GPOASSIGNEDPOLICY       			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 16
#define HLP_STATIC_SHOW_STORE                     			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 17

#define HLP_STATIC_SHOW_POLICY_EX               			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 50
#define HLP_STATIC_SHOW_FILTERLIST_EX           			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 51
#define HLP_STATIC_SHOW_FILTERACTIONS_EX        			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 52
#define HLP_STATIC_SHOW_RULE_EX                 			HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 53
#define HLP_STATIC_SHOW_ALL_EX                				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 55
#define HLP_STATIC_SHOW_GPOASSIGNEDPOLICY_EX   				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 56
#define HLP_STATIC_SHOW_STORE_EX               				HLP_IPSEC_BASE + HLP_STATIC_BASE + HLP_SHOW_BASE + 57

//
// Dynamic Add Group
//
#define CMD_DYNAMIC_GROUP_ADD   							TOKEN_GROUP_ADD
#define HLP_DYNAMIC_GROUP_ADD	  							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 0

#define CMD_DYNAMIC_ADD_POLICY                  			TOKEN_POLICY
#define CMD_DYNAMIC_ADD_QMPOLICY                			TOKEN_QMPOLICY
#define CMD_DYNAMIC_ADD_MMPOLICY							TOKEN_MMPOLICY
#define CMD_DYNAMIC_ADD_QMFILTER							TOKEN_QMFILTER
#define CMD_DYNAMIC_ADD_MMFILTER							TOKEN_MMFILTER
#define CMD_DYNAMIC_ADD_RULE								TOKEN_RULE

#define HLP_DYNAMIC_ADD_QMPOLICY                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 10
#define HLP_DYNAMIC_ADD_MMPOLICY                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 11
#define HLP_DYNAMIC_ADD_QMFILTER                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 12
#define HLP_DYNAMIC_ADD_MMFILTER                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 13
#define HLP_DYNAMIC_ADD_POLICY                  			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 14
#define HLP_DYNAMIC_ADD_RULE	                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 15

#define HLP_DYNAMIC_ADD_QMPOLICY_EX             			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 50
#define HLP_DYNAMIC_ADD_MMPOLICY_EX             			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 51
#define HLP_DYNAMIC_ADD_QMFILTER_EX             			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 52
#define HLP_DYNAMIC_ADD_MMFILTER_EX             			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 53
#define HLP_DYNAMIC_ADD_POLICY_EX               			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 54
#define HLP_DYNAMIC_ADD_RULE_EX               				HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_ADD_BASE + 55

//
// Dynamic Set Group
//
#define CMD_DYNAMIC_GROUP_SET   							TOKEN_GROUP_SET
#define HLP_DYNAMIC_GROUP_SET	  							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 0

#define CMD_DYNAMIC_SET_QMPOLICY                			TOKEN_QMPOLICY
#define CMD_DYNAMIC_SET_MMPOLICY                			TOKEN_MMPOLICY
#define CMD_DYNAMIC_SET_QMFILTER                			TOKEN_QMFILTER
#define CMD_DYNAMIC_SET_MMFILTER                			TOKEN_MMFILTER
#define CMD_DYNAMIC_SET_ENBDIAG								TOKEN_ENBDIAG
#define CMD_DYNAMIC_SET_NODEFEXEM							TOKEN_NODEFEXEM
#define CMD_DYNAMIC_SET_LOGINT								TOKEN_LOGINT
#define CMD_DYNAMIC_SET_ENABLELOGINT						TOKEN_ENABLELOGINT
#define CMD_DYNAMIC_SET_STRGCRLC							TOKEN_STRGCRLC
#define CMD_DYNAMIC_SET_CONFIG								TOKEN_CONFIG
#define CMD_DYNAMIC_SET_RULE								TOKEN_RULE

#define HLP_DYNAMIC_SET_QMPOLICY                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 10
#define HLP_DYNAMIC_SET_MMPOLICY                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 11
#define HLP_DYNAMIC_SET_QMFILTER                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 12
#define HLP_DYNAMIC_SET_MMFILTER                			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 13
#define HLP_DYNAMIC_SET_ENBDIAG								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 14
#define HLP_DYNAMIC_SET_NODEFEXEM							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 15
#define HLP_DYNAMIC_SET_LOGINT								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 16
#define HLP_DYNAMIC_SET_STRGCRLC							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 17
#define HLP_DYNAMIC_SET_ENABLELOGINT						HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 18
#define HLP_DYNAMIC_SET_CONFIG								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 19
#define HLP_DYNAMIC_SET_RULE								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 20

#define HLP_DYNAMIC_SET_QMPOLICY_EX            				HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 50
#define HLP_DYNAMIC_SET_MMPOLICY_EX            				HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 51
#define HLP_DYNAMIC_SET_QMFILTER_EX            				HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 52
#define HLP_DYNAMIC_SET_MMFILTER_EX            				HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 53
#define HLP_DYNAMIC_SET_ENBDIAG_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 54
#define HLP_DYNAMIC_SET_NODEFEXEM_EX						HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 55
#define HLP_DYNAMIC_SET_LOGINT_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 56
#define HLP_DYNAMIC_SET_STRGCRLC_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 57
#define HLP_DYNAMIC_SET_ENABLELOGINT_EX						HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 58
#define HLP_DYNAMIC_SET_CONFIG_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 59
#define HLP_DYNAMIC_SET_RULE_EX								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SET_BASE + 60

//
// Dynamic Delete Group
//
#define CMD_DYNAMIC_GROUP_DELETE   							TOKEN_GROUP_DELETE
#define HLP_DYNAMIC_GROUP_DELETE  							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 0

#define CMD_DYNAMIC_DELETE_QMPOLICY             			TOKEN_QMPOLICY
#define CMD_DYNAMIC_DELETE_MMPOLICY             			TOKEN_MMPOLICY
#define CMD_DYNAMIC_DELETE_QMFILTER             			TOKEN_QMFILTER
#define CMD_DYNAMIC_DELETE_MMFILTER             			TOKEN_MMFILTER
#define CMD_DYNAMIC_DELETE_RULE		            			TOKEN_RULE
#define CMD_DYNAMIC_DELETE_ALL                  			TOKEN_ALL

#define HLP_DYNAMIC_DELETE_QMPOLICY             			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 10
#define HLP_DYNAMIC_DELETE_MMPOLICY             			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 11
#define HLP_DYNAMIC_DELETE_QMFILTER             			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 12
#define HLP_DYNAMIC_DELETE_MMFILTER             			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 13
#define HLP_DYNAMIC_DELETE_RULE          					HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 14
#define HLP_DYNAMIC_DELETE_ALL          					HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 15

#define HLP_DYNAMIC_DELETE_QMPOLICY_EX          			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 50
#define HLP_DYNAMIC_DELETE_MMPOLICY_EX          			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 51
#define HLP_DYNAMIC_DELETE_QMFILTER_EX          			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 52
#define HLP_DYNAMIC_DELETE_MMFILTER_EX          			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 53
#define HLP_DYNAMIC_DELETE_RULE_EX          				HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 54
#define HLP_DYNAMIC_DELETE_ALL_EX		        			HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_DELETE_BASE + 55

//
// Dynamic Show Group
//
#define CMD_DYNAMIC_GROUP_SHOW   							TOKEN_GROUP_SHOW
#define HLP_DYNAMIC_GROUP_SHOW  							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 0

#define CMD_DYNAMIC_SHOW_ALL                    			TOKEN_ALL
#define CMD_DYNAMIC_SHOW_MMPOLICY							TOKEN_MMPOLICY
#define CMD_DYNAMIC_SHOW_QMPOLICY							TOKEN_QMPOLICY
#define CMD_DYNAMIC_SHOW_MMFILTER							TOKEN_MMFILTER
#define CMD_DYNAMIC_SHOW_QMFILTER							TOKEN_QMFILTER
#define CMD_DYNAMIC_SHOW_STATS								TOKEN_STATS
#define CMD_DYNAMIC_SHOW_MMSAS								TOKEN_MMSAS
#define CMD_DYNAMIC_SHOW_QMSAS								TOKEN_QMSAS
#define CMD_DYNAMIC_SHOW_REGKEYS							TOKEN_REGKEYS
#define CMD_DYNAMIC_SHOW_RULE								TOKEN_RULE

#define HLP_DYNAMIC_SHOW_ALL                				HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 10
#define HLP_DYNAMIC_SHOW_MMPOLICY							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 11
#define HLP_DYNAMIC_SHOW_QMPOLICY							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 12
#define HLP_DYNAMIC_SHOW_MMFILTER							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 13
#define HLP_DYNAMIC_SHOW_QMFILTER							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 14
#define HLP_DYNAMIC_SHOW_STATS								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 15
#define HLP_DYNAMIC_SHOW_MMSAS								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 16
#define HLP_DYNAMIC_SHOW_QMSAS								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 17
#define HLP_DYNAMIC_SHOW_REGKEYS							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 18
#define HLP_DYNAMIC_SHOW_RULE								HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 19

#define HLP_DYNAMIC_SHOW_ALL_EX                				HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 50
#define HLP_DYNAMIC_SHOW_MMPOLICY_EX						HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 51
#define HLP_DYNAMIC_SHOW_QMPOLICY_EX						HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 52
#define HLP_DYNAMIC_SHOW_MMFILTER_EX						HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 53
#define HLP_DYNAMIC_SHOW_QMFILTER_EX						HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 54
#define HLP_DYNAMIC_SHOW_STATS_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 55
#define HLP_DYNAMIC_SHOW_MMSAS_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 56
#define HLP_DYNAMIC_SHOW_QMSAS_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 57
#define HLP_DYNAMIC_SHOW_REGKEYS_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 58
#define HLP_DYNAMIC_SHOW_RULE_EX							HLP_IPSEC_BASE + HLP_DYNAMIC_BASE + HLP_SHOW_BASE + 59

#define DYNAMIC_SHOW_POLANDOFFERS							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 1
#define	DYNAMIC_SHOW_POLNAME								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 2
#define	DYNAMIC_SHOW_OFFERS									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 3
#define	DYNAMIC_SHOW_PMYADD									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 4
#define	DYNAMIC_SHOW_PANYADD								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 5
#define	DYNAMIC_SHOW_PADD									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 6
#define DYNAMIC_SHOW_NEWLINE								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 7
#define DYNAMIC_SHOW_ICMP									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 8
#define DYNAMIC_SHOW_TCP									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 9
#define DYNAMIC_SHOW_UDP									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 10
#define DYNAMIC_SHOW_RAW									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 11
#define	DYNAMIC_SHOW_ANY									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 12
#define DYNAMIC_SHOW_SOFTSA									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 18
#define DYNAMIC_SHOW_WINS									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 19
#define DYNAMIC_SHOW_DHCP									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 20
#define DYNAMIC_SHOW_DNS									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 21
#define DYNAMIC_SHOW_GATEWAY								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 22
#define DYNAMIC_SHOW_ADDR_STR								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 23
#define NSHIPSEC_DLL										HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 24
#define NSHIPSEC_CHECK										HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 25

#define	DYNAMIC_SHOW_MMP_1									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 100
#define	DYNAMIC_SHOW_MMP_2									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 101
#define	DYNAMIC_SHOW_NO_MMP_ERROR_MSG						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 102
#define	DYNAMIC_SHOW_MMP_4									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 103
#define	DYNAMIC_SHOW_SPECIFIED_MMP_NOT_FOUND_MSG			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 104
#define	DYNAMIC_SHOW_MMP_PP_1								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 105
#define	DYNAMIC_SHOW_MMP_COLUMN_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 106
#define	DYNAMIC_SHOW_MMP_COLUMN_HEADING_UNDERLINE			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 107

#define	DYNAMIC_SHOW_MMP_ESP_NONE_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 120
#define	DYNAMIC_SHOW_MMP_ESP_DES_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 121
#define	DYNAMIC_SHOW_MMP_ESP_UNKNOWN_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 122
#define	DYNAMIC_SHOW_MMP_ESP_3DES_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 123
#define	DYNAMIC_SHOW_MMP_PMMOFFER_8							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 124
#define	DYNAMIC_SHOW_MMP_AH_NONE_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 125
#define	DYNAMIC_SHOW_MMP_AH_MD5_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 126
#define	DYNAMIC_SHOW_MMP_AH_SHA1_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 127
#define	DYNAMIC_SHOW_MMP_PMMOFFER_9							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 128
#define	DYNAMIC_SHOW_MMP_DH_LIFE_QMLIMIT					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 129
#define	DYNAMIC_SHOW_MMP_DH_LIFE_QMLIMIT_MMPFS				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 130

#define	DYNAMIC_SHOW_QMP_1									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 151
#define	DYNAMIC_SHOW_QMP_2									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 152
#define	DYNAMIC_SHOW_NO_QMP_ERROR_MSG						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 153
#define	DYNAMIC_SHOW_QMP_4									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 154
#define	DYNAMIC_SHOW_SPECIFIED_QMP_NOT_FOUND_MSG			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 155
#define	DYNAMIC_SHOW_QMP_NEGOTIATION_NAME					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 156

#define	DYNAMIC_SHOW_QMP_PFA_1								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 157
#define	DYNAMIC_SHOW_QMP_COLUMN_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 158
#define	DYNAMIC_SHOW_QMP_COLUMN_HEADING_UNDERLINE			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 159

#define	DYNAMIC_SHOW_QMP_AH_MD5_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 165
#define	DYNAMIC_SHOW_QMP_AH_SHA1_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 166
#define	DYNAMIC_SHOW_QMP_AH_NONE_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 167
#define	DYNAMIC_SHOW_QMP_ESP_DES_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 168
#define	DYNAMIC_SHOW_QMP_ESP_ERR_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 169
#define	DYNAMIC_SHOW_QMP_ESP_3DES_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 170
#define	DYNAMIC_SHOW_QMP_ESP_NONE_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 171
#define	DYNAMIC_SHOW_QMP_MD5_ALGO							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 172
#define	DYNAMIC_SHOW_QMP_SHA1_ALGO							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 173
#define	DYNAMIC_SHOW_QMP_NONE_ALGO							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 174
#define	DYNAMIC_SHOW_QMP_AH_MD5_ALGO1						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 175
#define	DYNAMIC_SHOW_QMP_DH_GROUP_LOW						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 176
#define	DYNAMIC_SHOW_QMP_PFS_NONE							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 177
#define	DYNAMIC_SHOW_QMP_LIFETIME							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 178
#define	DYNAMIC_SHOW_QMP_MM_DH_GROUP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 179
#define	DYNAMIC_SHOW_QMP_DH_GROUP_HIGH						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 180
#define DYNAMIC_SHOW_QMP_AH_ERR_SPACE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 181
#define DYNAMIC_SHOW_QMP_ERR_SPACE							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 182
#define DYNAMIC_SHOW_QMP_ERROR_ALGO							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 183
#define DYNAMIC_SHOW_QMP_AH_MD5								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 184
#define DYNAMIC_SHOW_QMP_AH_SHA1							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 185
#define DYNAMIC_SHOW_QMP_AH_NONE							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 186
#define DYNAMIC_SHOW_QMP_AH_ERR								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 187
#define DYNAMIC_SHOW_QMP_MD5								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 188
#define DYNAMIC_SHOW_QMP_SHA1								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 189
#define DYNAMIC_SHOW_QMP_NONE								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 190
#define DYNAMIC_SHOW_QMP_ERR								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 191
#define DYNAMIC_SHOW_QMP_PLUS								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 192
#define DYNAMIC_SHOW_QMP_DH_GROUP_MEDIUM					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 193

#define	DYNAMIC_SHOW_MMF_1									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 195
#define	DYNAMIC_SHOW_MMF_2									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 196
#define	DYNAMIC_SHOW_MMF_3									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 197
#define	DYNAMIC_SHOW_MMF_NAME								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 198
#define	DYNAMIC_SHOW_MMF_5									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 199
#define	DYNAMIC_SHOW_MMF_GENERIC_NOT_FOUND_MSG				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 200
#define	DYNAMIC_SHOW_MMF_SPECIFIC_NOT_FOUND_MSG				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 201
#define	DYNAMIC_SHOW_MMF_SPECIFIED_NOT_FOUND_MSG			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 202
#define	DYNAMIC_SHOW_MMF_SUB_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 203
#define	DYNAMIC_SHOW_MMF_GENERIC_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 204
#define	DYNAMIC_SHOW_MMF_UNDERLINE							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 205
#define	DYNAMIC_SHOW_MMF_SPECIFIC_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 206
#define	DYNAMIC_SHOW_MMF_OUTBOUND_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 207
#define	DYNAMIC_SHOW_MMF_INBOUND_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 208
#define	DYNAMIC_SHOW_MMF_FILTER_WEIGHT						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 209
#define	DYNAMIC_SHOW_MMF_NO_OF_GENERIC_FILTERS				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 210
#define	DYNAMIC_SHOW_MMF_NO_OF_SPECIFIC_OUTBOUND			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 211
#define	DYNAMIC_SHOW_MMF_NO_OF_SPECIFIC_INBOUND				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 212

#define	DYNAMIC_SHOW_MMF_PMMF_1								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 215
#define	DYNAMIC_SHOW_MMF_PMMF_2								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 216
#define	DYNAMIC_SHOW_MMF_PMMF_3								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 217
#define	DYNAMIC_SHOW_MMF_PMMF_4								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 218
#define	DYNAMIC_SHOW_MMF_CONN_ALL							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 219
#define	DYNAMIC_SHOW_MMF_CONN_LAN							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 220
#define	DYNAMIC_SHOW_MMF_CONN_DIALUP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 221
#define	DYNAMIC_SHOW_MMF_CONN_UNKNOWN						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 222
#define	DYNAMIC_SHOW_MMF_PMMF_9								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 223
#define	DYNAMIC_SHOW_MMF_PMMF_10							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 224
#define	DYNAMIC_SHOW_MMF_PMMF_11							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 225
#define	DYNAMIC_SHOW_MMF_PMMF_12							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 226
#define	DYNAMIC_SHOW_MMF_PMMF_13							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 227
#define	DYNAMIC_SHOW_MMF_PMMF_14							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 228
#define	DYNAMIC_SHOW_MMF_UNKNOWN_CERT						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 229
#define	DYNAMIC_SHOW_MMF_PMMF_16							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 230
#define	DYNAMIC_SHOW_MMF_PMMF_17							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 231
#define	DYNAMIC_SHOW_MMF_PMMF_18							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 232
#define	DYNAMIC_SHOW_MMF_PMMF_19							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 233
#define	DYNAMIC_SHOW_MMF_PMMF_20							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 234
#define	DYNAMIC_SHOW_MMF_PMMF_21							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 235
#define	DYNAMIC_SHOW_MMF_CONN_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 236
#define	DYNAMIC_SHOW_MMF_AUTH_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 237
#define	DYNAMIC_SHOW_MMF_PRE_KEY_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 238
#define	DYNAMIC_SHOW_MMF_KERB								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 240
#define	DYNAMIC_SHOW_MMF_SEC_METHOD_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 241
#define	DYNAMIC_SHOW_MMF_OFFER_CNT							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 242
#define	DYNAMIC_SHOW_MMF_DEFAULT_OFFER						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 243
#define	DYNAMIC_SHOW_MMF_OFFER_NONE_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 244
#define	DYNAMIC_SHOW_MMF_OFFER_DES_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 245
#define	DYNAMIC_SHOW_MMF_OFFER_UNKNOWN_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 246
#define	DYNAMIC_SHOW_MMF_OFFER_3DES_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 247
#define	DYNAMIC_SHOW_MMF_OFFER_AH_NONE_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 248
#define	DYNAMIC_SHOW_MMF_OFFER_MD5_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 249
#define	DYNAMIC_SHOW_MMF_OFFER_SHA1_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 250
#define	DYNAMIC_SHOW_MMF_DH_QMLIMIT							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 251
#define	DYNAMIC_SHOW_MMF_NEWLINE_TAB						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 252

#define	DYNAMIC_SHOW_QMF_1									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 260
#define	DYNAMIC_SHOW_QMF_2									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 261
#define	DYNAMIC_SHOW_QMF_3									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 262
#define	DYNAMIC_SHOW_QMF_4									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 263
#define	DYNAMIC_SHOW_QMF_5									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 264
#define	DYNAMIC_SHOW_QMF_GENERIC_NOT_FOUND_MSG				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 265
#define	DYNAMIC_SHOW_QMF_SPECIFIC_NOT_FOUND_MSG				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 266
#define	DYNAMIC_SHOW_QMF_SPECIFIED_NOT_FOUND_MSG			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 267
#define	DYNAMIC_SHOW_TRANSPORT_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 268
#define	DYNAMIC_SHOW_TRANSPORT_RULE_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 269
#define	DYNAMIC_SHOW_TUNNEL_RULE_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 270
#define	DYNAMIC_SHOW_MMFILTER_NAME							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 271
#define	DYNAMIC_SHOW_QMF_NAME								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 272
#define	DYNAMIC_SHOW_MMP_NAME								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 273
#define	DYNAMIC_SHOW_NO_OF_TRANSPORT_FILTERS				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 274
#define	DYNAMIC_SHOW_NO_OF_TUNNEL_FILTERS					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 275
#define	DYNAMIC_SHOW_TUNNEL_HEADING							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 276
#define	DYNAMIC_SHOW_QMF_16									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 277
#define	DYNAMIC_SHOW_NO_RULES_ERROR_MSG						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 278

#define	DYNAMIC_SHOW_INBOUND_PASSTHRU						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 280
#define	DYNAMIC_SHOW_INBOUND_NEGOTIATE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 281
#define	DYNAMIC_SHOW_INBOUND_BLOCK							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 282
#define	DYNAMIC_SHOW_INBOUND_UNKNOWN						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 283
#define	DYNAMIC_SHOW_OUTBOUND_PASSTHRU						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 284
#define	DYNAMIC_SHOW_OUTBOUND_NEGOTIATE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 285
#define	DYNAMIC_SHOW_OUTBOUND_BLOCK							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 286
#define	DYNAMIC_SHOW_OUTBOUND_UNKNOWN						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 287
#define	DYNAMIC_SHOW_QMF_PQMF_9								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 288
#define	DYNAMIC_SHOW_INBOUND_PASSTHRU0						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 289
#define	DYNAMIC_SHOW_INBOUND_PASSTHRU1						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 290
#define	DYNAMIC_SHOW_INBOUND_PASSTHRU2						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 291
#define	DYNAMIC_SHOW_DEFAULT_PROTOCOL						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 292
#define	DYNAMIC_SHOW_TUNNEL_SRC								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 293
#define	DYNAMIC_SHOW_TUNNEL_DST								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 294
#define	DYNAMIC_SHOW_SRC_DST_PORT							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 295
#define	DYNAMIC_SHOW_MIRR_YES								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 296
#define	DYNAMIC_SHOW_MIRR_NO								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 297
#define	DYNAMIC_SHOW_QMP_NAME								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 298
#define	DYNAMIC_SHOW_PROTO_HEADING							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 299


#define	DYNAMIC_SHOW_STATS_HEADING							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 300
#define	DYNAMIC_SHOW_STATS_IKE_HEADING_UNDERLINE			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 301
#define	DYNAMIC_SHOW_STATS_NOT_FOUND_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 302
#define	DYNAMIC_SHOW_STATS_MAIN_MODE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 303
#define	DYNAMIC_SHOW_STATS_QUICK_MODE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 304
#define	DYNAMIC_SHOW_STATS_SOFT_SA							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 305
#define	DYNAMIC_SHOW_STATS_AUTH_FAIL						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 306
#define	DYNAMIC_SHOW_STATS_ACTIVE_ACQUIRE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 307
#define	DYNAMIC_SHOW_STATS_ACTIVE_RECEIVE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 308
#define	DYNAMIC_SHOW_STATS_ACQUIRE_FAIL						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 309
#define	DYNAMIC_SHOW_STATS_RECEIVE_FAIL						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 310
#define	DYNAMIC_SHOW_STATS_SEND_FAIL						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 311
#define	DYNAMIC_SHOW_STATS_ACQ_HEAP_SIZE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 312
#define	DYNAMIC_SHOW_STATS_RECEIVE_HEAP_SIZE				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 313
#define	DYNAMIC_SHOW_STATS_NEG_FAIL							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 314
#define	DYNAMIC_SHOW_STATS_INVALID_COOKIE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 315
#define	DYNAMIC_SHOW_STATS_TOTAL_ACQUIRE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 316
#define	DYNAMIC_SHOW_STATS_TOT_GET_SPI						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 317
#define	DYNAMIC_SHOW_STATS_TOT_KEY_ADD						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 318
#define	DYNAMIC_SHOW_STATS_TOT_KEY_UPDATE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 319
#define	DYNAMIC_SHOW_STATS_GET_SPI_FAIL						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 320
#define	DYNAMIC_SHOW_STATS_KEY_ADD_FAIL						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 321
#define	DYNAMIC_SHOW_STATS_KEY_UPDATE_FAIL					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 322
#define	DYNAMIC_SHOW_STATS_DB_LIST							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 323
#define	DYNAMIC_SHOW_STATS_CONN_LIST_SIZE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 324
#define	DYNAMIC_SHOW_STATS_INVLD_PKTS						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 325
#define	DYNAMIC_SHOW_STATS_IPSEC_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 326
#define	DYNAMIC_SHOW_STATS_IPSEC_HEADING_UNDERLINE			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 327
#define	DYNAMIC_SHOW_STATS_IPSEC_NOT_FOUND					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 328
#define	DYNAMIC_SHOW_STATS_ACTIVE_ASSOC						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 329
#define	DYNAMIC_SHOW_STATS_OFFLOAD_SAS						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 330
#define	DYNAMIC_SHOW_STATS_PEND_KEY							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 331
#define	DYNAMIC_SHOW_STATS_KEY_ADDS							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 332
#define	DYNAMIC_SHOW_STATS_KEY_DELETES						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 333
#define	DYNAMIC_SHOW_STATS_REKEYS							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 334
#define	DYNAMIC_SHOW_STATS_ACT_TUNNEL						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 335
#define	DYNAMIC_SHOW_STATS_BAD_SPI							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 336
#define	DYNAMIC_SHOW_STATS_NOT_DECRYPT						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 337
#define	DYNAMIC_SHOW_STATS_NOT_AUTH							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 338
#define	DYNAMIC_SHOW_STATS_REPLAY							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 339
#define	DYNAMIC_SHOW_STATS_CONF_BYTES_SENT					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 340
#define	DYNAMIC_SHOW_STATS_CONF_BYTES_RECV					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 341
#define	DYNAMIC_SHOW_STATS_AUTH_BYTES_SENT					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 342
#define	DYNAMIC_SHOW_STATS_AUTH_BYTE_RECV					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 343
#define	DYNAMIC_SHOW_STATS_TRANSPORT_BYTES_SENT				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 344
#define	DYNAMIC_SHOW_STATS_TRANSPORT_BYTES_RCVD				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 345
#define	DYNAMIC_SHOW_STATS_OFFLOAD_BYTES_SENT				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 346
#define	DYNAMIC_SHOW_STATS_OFFLOAD_BYTES_RECV				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 347
#define	DYNAMIC_SHOW_STATS_BYTES_SENT_TUNNEL				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 348
#define	DYNAMIC_SHOW_STATS_BYTES_RECV_TUNNEL				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 349


#define	DYNAMIC_SHOW_MMSAS_COOKIE_PAIR						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 350
#define	DYNAMIC_SHOW_MMSAS_COOKIE							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 351
#define	DYNAMIC_SHOW_MMSAS_SEC_METHOD_HEADING				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 352
#define	DYNAMIC_SHOW_MMSAS_NONE_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 353
#define	DYNAMIC_SHOW_MMSAS_DES_ALGO							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 354
#define	DYNAMIC_SHOW_MMSAS_NO_SA_FOUND_MSGDES_ALGO			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 355
#define	DYNAMIC_SHOW_MMSAS_UNKNOWN_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 356
#define	DYNAMIC_SHOW_MMSAS_MD5_ALGO							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 357
#define	DYNAMIC_SHOW_MMSAS_SHA1_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 358
#define	DYNAMIC_SHOW_MMSAS_DH_LIFETIME						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 359
#define	DYNAMIC_SHOW_MMSAS_AUTH_MODE_HEADING				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 360
#define	DYNAMIC_SHOW_MMSAS_PRE_KEY							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 361
#define	DYNAMIC_SHOW_MMSAS_DSS_SIGN							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 362
#define	DYNAMIC_SHOW_MMSAS_RSA_SIGN							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 363
#define	DYNAMIC_SHOW_MMSAS_RSA_ENCRYPT						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 364
#define	DYNAMIC_SHOW_MMSAS_KERBEROS							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 365
#define	DYNAMIC_SHOW_MMSAS_SRC_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 366
#define	DYNAMIC_SHOW_MMSAS_PORT								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 367
#define	DYNAMIC_SHOW_MMSAS_ID_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 368
#define	DYNAMIC_SHOW_MMSAS_ID_VALUE							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 369
#define	DYNAMIC_SHOW_MMSAS_DST_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 370
#define	DYNAMIC_SHOW_MMSAS_DST_SEC_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 371
#define	DYNAMIC_SHOW_MMSAS_DATE_TIME_HEADING				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 372
#define	DYNAMIC_SHOW_MMSAS_UNDERLINE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 373
#define	DYNAMIC_SHOW_MMSAS_KERB_ID							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 374
#define	DYNAMIC_SHOW_MMSAS_DNS								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 375
#define	DYNAMIC_SHOW_MMSAS_KERB_PEER_ID						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 376
#define	DYNAMIC_SHOW_MMSAS_ISSUE_CA							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 377
#define	DYNAMIC_SHOW_MMSAS_THUMB_PRINT						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 378
#define	DYNAMIC_SHOW_MMSAS_THUMB_VALUE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 379
#define	DYNAMIC_SHOW_MMSAS_COLON							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 380
#define	DYNAMIC_SHOW_MMSAS_SLASH							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 381
#define	DYNAMIC_SHOW_MMSAS_SPACE_ADJ 						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 382
#define	DYNAMIC_SHOW_MMSAS_ROOTCA 							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 383
#define	DYNAMIC_SHOW_MMSAS_THUMBPRINT 						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 384
#define	DYNAMIC_SHOW_MMSAS_HASH_OPEN_BRACKET     			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 385
#define	DYNAMIC_SHOW_MMSAS_HASH_CLOSE_BRACKET				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 386
#define	DYNAMIC_SHOW_MMSAS_FILTER_ROOTCA 							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 387

#define	DYNAMIC_SHOW_MMSAS_1								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 395
#define	DYNAMIC_SHOW_MMSAS_2								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 396
#define	DYNAMIC_SHOW_MMSAS_NO_SA_FOUND_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 397
#define	DYNAMIC_SHOW_MMSAS_IKE_SA_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 398
#define	DYNAMIC_SHOW_MMSAS_5								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 399
#define	DYNAMIC_SHOW_MMSAS_NOT_FOUND_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 400

#define	DYNAMIC_SHOW_QMSAS_HEADING							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 401
#define	DYNAMIC_SHOW_QMSAS_UNDERLINE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 402
#define	DYNAMIC_SHOW_QMSAS_NO_SA_FOUND_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 403
#define	DYNAMIC_SHOW_QMSAS_NOT_FOUND_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 404

#define	DYNAMIC_SHOW_TRANSPORT_FILTER_HEADING				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 410
#define	DYNAMIC_SHOW_TUNNEL_FILTER_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 411
#define	DYNAMIC_SHOW_UNKNOWN								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 412
#define	DYNAMIC_SHOW_POL_NAME_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 413
#define	DYNAMIC_SHOW_SRC_ADDR_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 414
#define	DYNAMIC_SHOW_DST_ADDR_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 415
#define	DYNAMIC_SHOW_PROTOCOL_HEADING						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 416
#define	DYNAMIC_SHOW_SRC_PORT								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 417
#define	DYNAMIC_SHOW_DST_PORT								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 418
#define	DYNAMIC_SHOW_DIRECTION_INBOUND						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 419
#define	DYNAMIC_SHOW_DIRECTION_OUTBOUND						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 420
#define	DYNAMIC_SHOW_DIRECTION_ERR							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 421
#define	DYNAMIC_SHOW_OFFER									HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 422
#define	DYNAMIC_SHOW_PROTO_ICMP								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 423
#define	DYNAMIC_SHOW_PROTO_TCP								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 424
#define	DYNAMIC_SHOW_PROTO_UDP								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 425
#define	DYNAMIC_SHOW_PROTO_RAW								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 426
#define	DYNAMIC_SHOW_QMSAS_COLUMN_HEADING					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 427
#define	DYNAMIC_SHOW_QMSAS_COLUMN_UNDERLINE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 428
#define DYNAMIC_SHOW_QMSAS_ENCAP_IKE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 429
#define	DYNAMIC_SHOW_QMSAS_ENCAP_OTHER						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 430
#define	DYNAMIC_SHOW_QMSAS_SRC_UDP_PORT						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 431
#define	DYNAMIC_SHOW_QMSAS_DST_UDP_PORT						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 432
#define	DYNAMIC_SHOW_QMSAS_PEER_ADDR						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 433
#define	DYNAMIC_SHOW_PROTO_ANY								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 434
#define	DYNAMIC_SHOW_QMSAS_LEFTBRACKET						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 440
#define	DYNAMIC_SHOW_QMSAS_RIGHTBRACKET						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 441

#define	DYNAMIC_SHOW_QMSAS_PQMSAS_1							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 442
#define	DYNAMIC_SHOW_QMSAS_PQMSAS_2							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 443

#define DYNAMIC_SHOW_REG_HEADING							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 446
#define DYNAMIC_SHOW_REG_HEADING_UNDERLINE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 447
#define DYNAMIC_SHOW_REG_IPSEC_DIAG  						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 448
#define DYNAMIC_SHOW_REG_IKE_LOG  							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 449
#define DYNAMIC_SHOW_REG_STRONG_CRL  						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 450
#define DYNAMIC_SHOW_REG_IPSEC_LOG  						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 451
#define DYNAMIC_SHOW_REG_NLBS  								HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 452
#define DYNAMIC_SHOW_REG_FLAGS  							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 453
#define DYNAMIC_SHOW_REG_IPSEC_EXEMPT  						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 454
#define DYNAMIC_SHOW_REG_DH_GROUP 							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 455
#define DYNAMIC_SHOW_REG_DIAG_ERR_MSG						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 456
#define DYNAMIC_SHOW_REG_IKE_LOG_ERR_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 457
#define DYNAMIC_SHOW_REG_STRONG_CRL_ERR_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 458
#define DYNAMIC_SHOW_REG_IPSEC_LOG_ERR_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 459
#define DYNAMIC_SHOW_REG_IPSEC_EXEMPT_ERR_MSG				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 460
#define DYNAMIC_SHOW_REG_PARAM_NOT_SET_MSG					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 461

#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 462
#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_STATEFUL			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 463
#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_BLOCK				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 464
#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_PERMIT				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 465

#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_UDP					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 466
#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_TCP					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 467
#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_ICMP				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 468
#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_RAW					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 469
#define DYNAMIC_SHOW_REG_IPSEC_BOOTMODE_ANY					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 470

#define DYNAMIC_SHOW_BOOTMODE_EXEMPT_INTEGER				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 471
#define DYNAMIC_SHOW_BOOTMODE_EXEMPT_PORT					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 472
#define DYNAMIC_SHOW_BOOTMODE_EXEMPT_DIRECTION_IN			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 473
#define DYNAMIC_SHOW_BOOTMODE_EXEMPT_DIRECTION_OUT			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 474
#define DYNAMIC_SHOW_BOOTMODE_EXEMPTIONS_NO_EXEMPTIONS		HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 476
#define DYNAMIC_SHOW_BOOTMODE_EXEMPTIONS_HEADER_1			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 477
#define DYNAMIC_SHOW_BOOTMODE_EXEMPTIONS_HEADER_2			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 478
#define DYNAMIC_SHOW_BOOTMODE_EXEMPTIONS_HEADER_3			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 479
#define DYNAMIC_SET_REG_TOO_MANY_EXEMPTIONS					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 480

#define DYNAMIC_SHOW_QMP_SAS_MD5_NONE_NONE_ALGO				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 800
#define DYNAMIC_SHOW_QMP_SAS_SHA1_NONE_NONE_ALGO			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 801
#define DYNAMIC_SHOW_QMP_SAS_NONE_NONE_NONE_ALGO			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 802
#define DYNAMIC_SHOW_QMP_SAS_NONE_DES_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 803
#define DYNAMIC_SHOW_QMP_SAS_NONE_UNKNOWN_ALGO				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 804
#define DYNAMIC_SHOW_QMP_SAS_NONE_3DES_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 805
#define DYNAMIC_SHOW_QMP_SAS_NONE_NONE_ALGO					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 806
#define DYNAMIC_SHOW_QMP_SAS_MD5_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 807
#define DYNAMIC_SHOW_QMP_SAS_SHA1_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 808
#define DYNAMIC_SHOW_QMP_SAS_NONE_ALGO						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 809
#define DYNAMIC_SHOW_QMP_SAS_NONE_SPACE_ALGO				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 810
#define DYNAMIC_SHOW_MMF_CERT_MAP_DISPLAY					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 811
#define DYNAMIC_SHOW_MMF_CERT_CRP_DISPLAY					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 812
#define DYNAMIC_SHOW_MMF_YES_DISPLAY						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 813
#define DYNAMIC_SHOW_MMF_NO_DISPLAY							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 814

//
// General ID's
//
#define ERR_WIN32_FMT                           			HLP_IPSEC_BASE + HLP_ERROR_BASE + 1
#define ERR_IPSEC_FMT                           			HLP_IPSEC_BASE + HLP_ERROR_BASE + 2
#define ERR_WIN32_SPACE										HLP_IPSEC_BASE + HLP_ERROR_BASE + 3
#define ERR_WIN32_INVALID_WIN32CODE        					HLP_IPSEC_BASE + HLP_ERROR_BASE + 4
//
// Parser Error ID's
//
#define ERR_INVALID_NUM_ARGS              					HLP_IPSEC_BASE + HLP_ERROR_BASE + 10
#define ERR_INVALID_ARGS              						HLP_IPSEC_BASE + HLP_ERROR_BASE + 11
#define	ERR_NO_POLICY			        					HLP_IPSEC_BASE + HLP_ERROR_BASE + 12
#define ERR_FAILED_POLSTORE_OPEN							HLP_IPSEC_BASE + HLP_ERROR_BASE + 13
#define	ERR_NO_FILTER_ACTION	        					HLP_IPSEC_BASE + HLP_ERROR_BASE + 14
#define	ERR_NO_FILTER_LIST		        					HLP_IPSEC_BASE + HLP_ERROR_BASE + 15
#define	ERR_INVALID_POLICY_NAME	        					HLP_IPSEC_BASE + HLP_ERROR_BASE + 16

#define ERR_INVALID_INDEX				      				HLP_IPSEC_BASE + HLP_ERROR_BASE + 17
#define ERR_INVALID_ARG					      				HLP_IPSEC_BASE + HLP_ERROR_BASE + 18
#define ERR_INVALID_ADDR				      				HLP_IPSEC_BASE + HLP_ERROR_BASE + 19
#define ERR_DNSLOOKUP_FAILED			      				HLP_IPSEC_BASE + HLP_ERROR_BASE + 20
#define ERR_INVALID_TAG					      				HLP_IPSEC_BASE + HLP_ERROR_BASE + 21
#define ERR_TAG_ALREADY_PRESENT								HLP_IPSEC_BASE + HLP_ERROR_BASE + 22
#define ERR_GPONAME_ARG_NEEDED								HLP_IPSEC_BASE + HLP_ERROR_BASE + 23
#define ERR_NAME_GUID_NEEDED								HLP_IPSEC_BASE + HLP_ERROR_BASE + 24
#define ERR_TAG_NEEDED										HLP_IPSEC_BASE + HLP_ERROR_BASE + 25
#define ERR_ARG_INVALID										HLP_IPSEC_BASE + HLP_ERROR_BASE + 26
#define ERR_PREFIX_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 27
#define ERR_MASK_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 28

#define	ERR_NULL_STRING										HLP_IPSEC_BASE + HLP_ERROR_BASE + 29
#define	ERR_SECLIFE_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 30
#define	ERR_KBLIFE_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 31
#define	ERR_P2REKEY_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 32
#define	ERR_HASH_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 33
#define	ERR_ESP_INCOMPLETE									HLP_IPSEC_BASE + HLP_ERROR_BASE + 34
#define	ERR_DUPALG_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 35
#define	ERR_NONE_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 36
#define	ERR_IPSECPROT_INVALID								HLP_IPSEC_BASE + HLP_ERROR_BASE + 37
#define ERR_MAX_OFFERS										HLP_IPSEC_BASE + HLP_ERROR_BASE + 38
#define ERR_AHESP_INVALID 									HLP_IPSEC_BASE + HLP_ERROR_BASE + 39
#define ERR_KS_INVALID										HLP_IPSEC_BASE + HLP_ERROR_BASE + 40
#define ERR_INVALID_P1GROUP									HLP_IPSEC_BASE + HLP_ERROR_BASE + 41
#define ERR_P1GROUP_MISSING									HLP_IPSEC_BASE + HLP_ERROR_BASE + 42
#define ERR_MMOFFER_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 43
#define ERR_FILETYPE_INVALID								HLP_IPSEC_BASE + HLP_ERROR_BASE + 44
#define ERR_ADDR_ALL_INVALID								HLP_IPSEC_BASE + HLP_ERROR_BASE + 45
#define	ERR_NO_PREKEY										HLP_IPSEC_BASE + HLP_ERROR_BASE + 46
#define	ERR_AUTH_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 47
#define	ERR_ENCODE_FAILED									HLP_IPSEC_BASE + HLP_ERROR_BASE + 48
#define ERR_MULTIPLE_KERBPRE								HLP_IPSEC_BASE + HLP_ERROR_BASE + 49
#define ERR_PORT_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 50
#define ERR_MAXARGS_CROSSED									HLP_IPSEC_BASE + HLP_ERROR_BASE + 51
#define ERR_QMOFFER_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 52
#define ERR_INVALID_TUNNEL									HLP_IPSEC_BASE + HLP_ERROR_BASE + 53
#define ERR_PROTO_INVALID									HLP_IPSEC_BASE + HLP_ERROR_BASE + 54
#define ERR_INVALID_MASK									HLP_IPSEC_BASE + HLP_ERROR_BASE + 55
#define ERR_INVALID_MACHINE									HLP_IPSEC_BASE + HLP_ERROR_BASE + 56

//
#define ERR_OUTOF_MEMORY									HLP_IPSEC_BASE + HLP_ERROR_BASE + 57

//
// Static Show Table
//
#define SHW_STATIC_TAB_BASE									SHW_STATIC_BASE + 3000

#define SHW_STATIC_TAB_POLICY_COUNT							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1
#define SHW_STATIC_LIST_POLICY_COUNT						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2
#define SHW_STATIC_TAB_POLICY_STORE_RM_NAME					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 3
#define SHW_STATIC_TAB_POLICY_STORE_LM_NAME					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 4
#define SHW_STATIC_TAB_POLICY_STORE_RM_NAMEP				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 5
#define SHW_STATIC_TAB_POLICY_STORE_LM_NAMEP				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 6
#define SHW_STATIC_TAB_POLICY_STORE_RD_NAME					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 7
#define SHW_STATIC_TAB_POLICY_STORE_LD_NAME					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 8
#define SHW_STATIC_TAB_POLICY_STORE_LM						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 10
#define SHW_STATIC_TAB_POLICY_STORE_LD						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 11
#define SHW_STATIC_TAB_POLICY_STORE_LP						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 12
#define SHW_STATIC_TAB_POLICY_CERT_MAP_YES					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 13
#define SHW_STATIC_TAB_POLICY_CERT_MAP_NO					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 14

#define SHW_STATIC_TAB_FILTERLIST_POL_NAME_STR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 100
#define SHW_STATIC_TAB_FILTERLIST_RULE_NAME_STR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 101
#define SHW_STATIC_TAB_FILTERLIST_4							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 103

#define SHW_STATIC_TAB_FILTERACTION_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 201
#define SHW_STATIC_TAB_FILTERACTION_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 202
#define SHW_STATIC_TAB_FILTERACTION_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 203

#define SHW_STATIC_TAB_RULE_NO_POL_NAME						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 303
#define SHW_STATIC_TAB_RULE_ID_GUID							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 304

#define SHW_STATIC_TAB_RULE_FORMAT23S						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 306

#define SHW_STATIC_TAB_DEFRULE_5							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 404

#define SHW_STATIC_TAB_ALL_1								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 500
#define SHW_STATIC_TAB_ALL_2								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 501

#define SHW_STATIC_TAB_PRTPOLICY_POL_NAME_STR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 602
#define SHW_STATIC_TAB_PRTPOLICY_POL_DESC_STR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 603
#define SHW_STATIC_TAB_PRTPOLICY_POL_DESC_NONE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 604
#define SHW_STATIC_TAB_PRTPOLICY_ASSIGNED_YES				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 605
#define SHW_STATIC_TAB_PRTPOLICY_ASSIGNED_NO				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 606
#define SHW_STATIC_TAB_PRTPOLICY_MMPFS_YES					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 607
#define SHW_STATIC_TAB_PRTPOLICY_MMPFS_NO					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 608
#define SHW_STATIC_TAB_PRTPOLICY_POLL_MIN					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 609
#define SHW_STATIC_TAB_PRTPOLICY_RULE_COUNT					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 610
#define SHW_STATIC_TAB_PRTPOLICY_RULE_TITLE					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 611
#define SHW_STATIC_TAB_PRTPOLICY_RULE_UNDERLINE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 612
#define SHW_STATIC_TAB_PRTPOLICY_ASSIGNED_AD				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 613
#define SHW_STATIC_TAB_PRTPOLICY_NONVERB_TITLE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 614
#define SHW_STATIC_TAB_PRTPOLICY_FORMAT32S					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 615
#define SHW_STATIC_TAB_PRTPOLICY_AD_POL_OVERRIDES			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 616
#define SHW_STATIC_TAB_PRTPOLICY_YES_STR					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 617
#define SHW_STATIC_TAB_PRTPOLICY_NO_STR						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 618
#define SHW_STATIC_TAB_PRTPOLICY_NONVERB_UNDERLINE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 619
#define SHW_STATIC_TAB_PRTPOLICY_DOMAIN_NONVERB_TITLE		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 620
#define SHW_STATIC_TAB_PRTPOLICY_DOMAIN_NONVERB_UNDERLINE	HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 621

#define SHW_STATIC_TAB_PRTRULE_RULE_NAME_STR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 700
#define SHW_STATIC_TAB_PRTRULE_RULE_NAME_NONE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 701
#define SHW_STATIC_TAB_PRTRULE_AUTH_TITLE					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 703

#define SHW_STATIC_TAB_PRTRULE_TRANS_NONVERB_TITLE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 705
#define SHW_STATIC_TAB_PRTRULE_TRANS_NONVERB_UNDERLINE		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 706
#define SHW_STATIC_TAB_PRTRULE_TUNNEL_NONE					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 707
#define SHW_STATIC_TAB_PRTRULE_TUNNEL_IP					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 708
#define SHW_STATIC_TAB_PRTRULE_CONN_TYPE_ALL				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 709
#define SHW_STATIC_TAB_PRTRULE_CONN_TYPE_LAN				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 710
#define SHW_STATIC_TAB_PRTRULE_CONN_TYPE_DIALUP				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 711
#define SHW_STATIC_TAB_PRTRULE_CONN_TYPE_UNKNOWN			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 712
#define SHW_STATIC_TAB_PRTRULE_FILTERLIST_TITLE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 713
#define SHW_STATIC_TAB_PRTRULE_FILTERLIST_UNDERLINE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 714

#define SHW_STATIC_TAB_PRTRULE_FILTERACTION_TITLE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 716
#define SHW_STATIC_TAB_PRTRULE_FILTERACTION_UNDERLINE		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 717
#define SHW_STATIC_TAB_PRTRULE_ACTIVATED_YES				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 718
#define SHW_STATIC_TAB_PRTRULE_ACTIVATED_NO					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 719
#define SHW_STATIC_TAB_PRTRULE_RULE_NAME_NONE_STR			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 720
#define SHW_STATIC_TAB_PRTRULE_YES_STR						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 721
#define SHW_STATIC_TAB_PRTRULE_NO_STR						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 722

#define SHW_STATIC_TAB_PRTRULE_NONE_STR						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 724

#define SHW_STATIC_TAB_PRTRULE_KERB							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 728
#define SHW_STATIC_TAB_PRTRULE_CERT							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 729
#define SHW_STATIC_TAB_PRTRULE_PRE							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 730

#define SHW_STATIC_TAB_PRTRULE_TR_RULE_COUNT				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 734
#define SHW_STATIC_TAB_PRTRULE_TN_RULE_COUNT				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 735

#define SHW_STATIC_TAB_PRTRULE_TUN_NONVERB_TITLE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 737
#define SHW_STATIC_TAB_PRTRULE_TUN_NONVERB_UNDERLINE		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 738

#define SHW_STATIC_TAB_PRTNEGPOL_FA_NAME_STR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 800
#define SHW_STATIC_TAB_PRTNEGPOL_FA_NAME_NONE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 801
#define SHW_STATIC_TAB_PRTNEGPOL_ACTION_PERMIT				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 802
#define SHW_STATIC_TAB_PRTNEGPOL_ACTION_BLOCK				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 803
#define SHW_STATIC_TAB_PRTNEGPOL_ACTION_NEGOTIATE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 804
#define SHW_STATIC_TAB_PRTNEGPOL_INPASS_YES					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 805
#define SHW_STATIC_TAB_PRTNEGPOL_INPASS_NO					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 806
#define SHW_STATIC_TAB_PRTNEGPOL_SOFT_YES					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 807
#define SHW_STATIC_TAB_PRTNEGPOL_SOFT_NO					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 808

#define SHW_STATIC_TAB_PRTNEGPOL_SEC_MTHD_TITLE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 810

#define SHW_STATIC_TAB_PRTNEGPOL_ALGO_TITLE					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 812
#define SHW_STATIC_TAB_PRTNEGPOL_ALGO_UNDERLINE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 813
#define SHW_STATIC_TAB_PRTNEGPOL_QMPFS_YES					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 814
#define SHW_STATIC_TAB_PRTNEGPOL_QMPFS_NO					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 815
#define SHW_STATIC_TAB_PRTNEGPOL_NONVERB_TITLE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 816
#define SHW_STATIC_TAB_PRTNEGPOL_NONVERB_UNDERLINE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 817
#define SHW_STATIC_TAB_PRTNEGPOL_FORMAT38S					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 818
#define SHW_STATIC_TAB_PRTNEGPOL_NONE_STR					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 819
#define SHW_STATIC_TAB_PRTNEGPOL_PERMIT_STR					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 820
#define SHW_STATIC_TAB_PRTNEGPOL_BLOCK_STR					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 821
#define SHW_STATIC_TAB_PRTNEGPOL_NEGOTIATE_STR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 822
#define SHW_STATIC_TAB_PRTNEGPOL_ACTION_NONE_STR			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 823
#define SHW_STATIC_TAB_PRTNEGPOL_FORMAT23SNEWLINE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 824
#define SHW_STATIC_TAB_PRTNEGPOL_FORMAT23STAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 825

#define SHW_STATIC_TAB_PRTALGO_MD5							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1000
#define SHW_STATIC_TAB_PRTALGO_SHA1							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1001
#define SHW_STATIC_TAB_PRTALGO_NONE							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1002
#define SHW_STATIC_TAB_PRTALGO_NONE_NONE					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1003
#define SHW_STATIC_TAB_PRTALGO_5							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1004
#define SHW_STATIC_TAB_PRTALGO_6							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1005
#define SHW_STATIC_TAB_PRTALGO_7							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1006
#define SHW_STATIC_TAB_PRTALGO_MD5_COMMA					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1007
#define SHW_STATIC_TAB_PRTALGO_SHA1_COMMA					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1008
#define SHW_STATIC_TAB_PRTALGO_NONE_COMMA					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1009
#define SHW_STATIC_TAB_PRTALGO_DES_TAB						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1010
#define SHW_STATIC_TAB_PRTALGO_3DES_TAB						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1011
#define SHW_STATIC_TAB_PRTALGO_NONE_TAB						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1012


#define SHW_STATIC_TAB_PRTLIFE_FORMAT						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1100

#define SHW_STATIC_TAB_PRTAUTH_KERB							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1200
#define SHW_STATIC_TAB_PRTAUTH_ROOTCA_FORMAT				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1201
#define SHW_STATIC_TAB_PRTAUTH_PRE_FORMAT					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1202
#define SHW_STATIC_TAB_PRTAUTH_NONE_AUTH_STR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1203

#define SHW_STATIC_TAB_PRTFILTERDATA_FL_NAME_STR			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1300
#define SHW_STATIC_TAB_PRTFILTERDATA_FL_NAME_NONE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1301
#define SHW_STATIC_TAB_PRTFILTERDATA_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1302

#define SHW_STATIC_TAB_PRTFILTERDATA_FILTERS_TITLE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1304

#define SHW_STATIC_TAB_PRTFILTERDATA_NONVERB_TITLE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1306
#define SHW_STATIC_TAB_PRTFILTERDATA_NONVERB_UNDERLINE		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1307
#define SHW_STATIC_TAB_PRTFILTERDATA_FL_GUID_STR			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1308
#define SHW_STATIC_TAB_PRTFILTERDATA_FL_LASTMOD_STR	 		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1309
#define SHW_STATIC_TAB_PRTFILTERDATA_FILTER_COUNT			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1310

#define SHW_STATIC_TAB_PRTFSPEC_FORMAT45S					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1501

#define SHW_STATIC_TAB_PRTFSPEC_NONE_STR					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1505
#define SHW_STATIC_TAB_PRTFSPEC_FORMATS						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1506

#define SHW_STATIC_TAB_PRTFSPEC_FORMAT5D					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1508
#define SHW_STATIC_TAB_PRTFSPEC_10							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1509
#define SHW_STATIC_TAB_PRTFSPEC_NONE_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1510

#define SHW_STATIC_TAB_PRTFSPEC_YES_STR_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1512
#define SHW_STATIC_TAB_PRTFSPEC_NO_STR_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1513
#define SHW_STATIC_TAB_PRTFSPEC_FILTER_TITLE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1514
#define SHW_STATIC_TAB_PRTFSPEC_FILTER_UNDERLINE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1515

#define SHW_STATIC_TAB_PRTFILTER_MY_IP_ADDR					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1600
#define SHW_STATIC_TAB_PRTFILTER_ANY_IP_ADDR				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1601
#define SHW_STATIC_TAB_PRTFILTER_3							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1602
#define SHW_STATIC_TAB_PRTFILTER_4							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1603
#define SHW_STATIC_TAB_PRTFILTER_5							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1604
#define SHW_STATIC_TAB_PRTFILTER_6							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1605
#define SHW_STATIC_TAB_PRTFILTER_7							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1606
#define SHW_STATIC_TAB_PRTFILTER_8							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1607
#define SHW_STATIC_TAB_PRTFILTER_IP_FORMAT_TAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1608
#define SHW_STATIC_TAB_PRTFILTER_ANY_STR_TAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1609
#define SHW_STATIC_TAB_PRTFILTER_IP_FORMAT_NEWLINE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1610
#define SHW_STATIC_TAB_PRTFILTER_ANY_STR_NEWLINE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1611
#define SHW_STATIC_TAB_PRTFILTER_DNS_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1612
#define SHW_STATIC_TAB_PRTFILTER_WINS_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1613
#define SHW_STATIC_TAB_PRTFILTER_DHCP_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1614
#define SHW_STATIC_TAB_PRTFILTER_DEFGATE_TAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1615

#define SHW_STATIC_TAB_PRTPROTOCOL_ICMP_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1700
#define SHW_STATIC_TAB_PRTPROTOCOL_TCP_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1701
#define SHW_STATIC_TAB_PRTPROTOCOL_UDP_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1703
#define SHW_STATIC_TAB_PRTPROTOCOL_RAW_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1708
#define SHW_STATIC_TAB_PRTPROTOCOL_ANY_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1709
#define SHW_STATIC_TAB_PRTPROTOCOL_OTHER_TAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1710

#define SHW_STATIC_TAB_PRTISAKMP_MMSEC_TITLE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1802
#define SHW_STATIC_TAB_PRTISAKMP_MM_LIFE_FORMAT				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1803
#define SHW_STATIC_TAB_PRTISAKMP_MMSEC_MTD_TILE				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1804
#define SHW_STATIC_TAB_PRTISAKMP_MMSEC_MTD_UNDERLINE		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1805

#define SHW_STATIC_TAB_PRTISAKMPSEC_DES_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1900
#define SHW_STATIC_TAB_PRTISAKMPSEC_3DES_TAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1901
#define SHW_STATIC_TAB_PRTISAKMPSEC_SHA1_TAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1902
#define SHW_STATIC_TAB_PRTISAKMPSEC_MD5_TAB					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1903
#define SHW_STATIC_TAB_PRTISAKMPSEC_DH_LOW					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1904
#define SHW_STATIC_TAB_PRTISAKMPSEC_DH_MEDIUM				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1905
#define SHW_STATIC_TAB_PRTISAKMPSEC_DH_2048					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1906

#define SHW_STATIC_TAB_PRTSAFA_STAND_ALONE_FA_TITLE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2000
#define SHW_STATIC_TAB_PRTSAFA_STAND_ALONE_FA_UNDERLINE		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2001

#define SHW_STATIC_TAB_PRTSAFA_STAND_ALONE_FA_COUNT			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2004

#define SHW_STATIC_TAB_PRTSAFL_STAND_ALONE_FL_TITLE			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2100
#define SHW_STATIC_TAB_PRTSAFL_STAND_ALONE_FL_UNDERLINE		HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2101
#define SHW_STATIC_TAB_PRTSAFL_3							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2102
#define SHW_STATIC_TAB_PRTSAFL_4							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2103
#define SHW_STATIC_TAB_PRTSAFL_STAND_ALONE_FL_COUNT			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2104

#define SHW_STATIC_TAB_PRTALLFL_FL_COUNT_TAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2200
#define SHW_STATIC_TAB_PRTALLFL_FL_COUNT_LIST				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2204

#define SHW_STATIC_TAB_PRTALLFL_4							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2203

#define SHW_STATIC_TAB_PRTALLFA_FA_COUNT_TAB				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2300
#define SHW_STATIC_TAB_PRTALLFA_FA_COUNT_LIST				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2304

#define SHW_STATIC_TAB_ASSIGNPOL_5							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2354

//
// Static Misc
#define MISC_STATIC_RESDEFRULE_3 							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2402
#define MISC_STATIC_EXPORTPOLICY_1							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2441

#define DEL_STATIC_POLICY_ACTIVE_POL_DEL_QUERY 				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2500
#define DEL_STATIC_POLICY_FA_FL_DEL_QUERY 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2503
#define DEL_STATIC_POLICY_5 								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2504
#define DEL_STATIC_POLICY_6 								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2505

#define DEL_STATIC_FILTERLIST_ALL_FL_DEL_QUERY 				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2602
#define DEL_STATIC_FILTERLIST_Y_N_STR 						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2603

#define DEL_STATIC_FILTERACTION_ALL_FA_DEL_QUERY 			HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2652
#define DEL_STATIC_FILTERACTION_Y_N_STR 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2653

#define DEL_STATIC_RULE_FL_FA_DEL_QUERY 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2706

#define DEL_STATIC_ALL_POL_DEL_QUERY 						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2750
#define DEL_STATIC_ALL_Y_N_STR 								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2751
#define DEL_STATIC_ALL_3 									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2752
#define DEL_STATIC_ALL_4 									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2753

#define DEL_STATIC_SHWRUSED_TITLE 							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2780
#define DEL_STATIC_SHWRUSED_UNDERLINE 						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2781
#define DEL_STATIC_SHWRUSED_RULE_NAME_STR 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2782
#define DEL_STATIC_SHWRUSED_RULE_NAME_NONE 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2783

#define ADD_STATIC_POLICY_LIFETIME_STR 						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2794
#define ADD_STATIC_POLICY_6 								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2795

#define ADD_STATIC_CRNEWPOL_SUCCESS_MSG 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2802
#define ADD_STATIC_CRNEWPOL_CREATING_INFO 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2805
#define ADD_STATIC_CRNEWPOL_UPDATING_INFO 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2806

#define ADD_STATIC_FILTERACTION_LIFE_TIME_STR 				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2834

#define ADD_STATIC_FILTER_SRCSERVER_WARNING					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2840
#define ADD_STATIC_FILTER_DSTSERVER_WARNING					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2841

#define ADD_STATIC_RULE_SUCCESS_MSG 						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2848
#define ADD_STATIC_RULE_CREATING_INFO 						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2849
#define ADD_STATIC_RULE_12									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2852
#define ADD_STATIC_RULE_13									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2853
#define ADD_STATIC_RULE_14									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2854
#define ADD_STATIC_RULE_UPDATING_INFO						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2855
#define ADD_STATIC_RULE_INVALID_TUNNEL						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2856

#define SET_STATIC_POLICY_NEW_POL_QUERY 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2861

#define SET_STATIC_POLICY_INVALID_CERTMAP_MSG 				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2868
#define SET_STATIC_POLICY_CERTMAP_YES_STR 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2869
#define SET_STATIC_POLICY_CERTMAP_NO_STR 					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2870
#define SET_STATIC_POLICY_MISSING_GPO_NAME_STR 				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2871
#define SET_STATIC_POLICY_GPO_NOT_OK_STR                    HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2872

#define SET_STATIC_RULE_NEW_RULE_QUERY 						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2893
#define SET_STATIC_RULE_5 									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2894
#define SET_STATIC_RULE_6 									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2895
#define SET_STATIC_RULE_7 									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2896
#define SET_STATIC_RULE_8 									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2897
#define SET_STATIC_RULE_9 									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2898
#define SET_STATIC_RULE_10									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2899
#define SET_STATIC_RULE_11									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2900
#define SET_STATIC_RULE_12									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2901
#define SET_STATIC_RULE_13									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2902
#define SET_STATIC_RULE_14									HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2903

#define SET_STATIC_DEFRULE_3 								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2912
#define SET_STATIC_DEFRULE_4 								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2913
#define SET_STATIC_DEFRULE_5 								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2914
#define SET_STATIC_DEFRULE_6 								HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2915

//
// Static Show List
//
#define SHW_STATIC_POLICY_COUNT								HLP_IPSEC_BASE + SHW_STATIC_BASE + 1

#define SHW_STATIC_POLICY_STORE_RM_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2
#define SHW_STATIC_POLICY_STORE_LM_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 3
#define SHW_STATIC_POLICY_STORE_RM_NAME_STRP				HLP_IPSEC_BASE + SHW_STATIC_BASE + 4
#define SHW_STATIC_POLICY_STORE_LM_NAME_STRP				HLP_IPSEC_BASE + SHW_STATIC_BASE + 5
#define SHW_STATIC_POLICY_STORE_LD_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 6
#define SHW_STATIC_POLICY_STORE_RD_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 7
#define SHW_STATIC_POLICY_STORE_LM_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 8
#define SHW_STATIC_POLICY_STORE_LM_STRP						HLP_IPSEC_BASE + SHW_STATIC_BASE + 10
#define SHW_STATIC_POLICY_STORE_LD_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 11
#define SHW_STATIC_POLICY_RM_STR							HLP_IPSEC_BASE + SHW_STATIC_BASE + 12
#define SHW_STATIC_POLICY_LM_STR							HLP_IPSEC_BASE + SHW_STATIC_BASE + 13
#define SHW_STATIC_POLICY_RD_STR							HLP_IPSEC_BASE + SHW_STATIC_BASE + 14
#define SHW_STATIC_POLICY_LD_STR							HLP_IPSEC_BASE + SHW_STATIC_BASE + 15
#define SHW_STATIC_POLICY_LM								HLP_IPSEC_BASE + SHW_STATIC_BASE + 16
#define SHW_STATIC_POLICY_LD								HLP_IPSEC_BASE + SHW_STATIC_BASE + 17

#define SHW_STATIC_FILTERLIST_POL_NAME						HLP_IPSEC_BASE + SHW_STATIC_BASE + 100
#define SHW_STATIC_FILTERLIST_4								HLP_IPSEC_BASE + SHW_STATIC_BASE + 103

#define SHW_STATIC_FILTERACTION_2							HLP_IPSEC_BASE + SHW_STATIC_BASE + 201
#define SHW_STATIC_FILTERACTION_3							HLP_IPSEC_BASE + SHW_STATIC_BASE + 202
#define SHW_STATIC_FILTERACTION_4							HLP_IPSEC_BASE + SHW_STATIC_BASE + 203

#define SHW_STATIC_RULE_RULE_ID_GUID						HLP_IPSEC_BASE + SHW_STATIC_BASE + 304
#define SHW_STATIC_RULE_FL_NAME_STR							HLP_IPSEC_BASE + SHW_STATIC_BASE + 305
#define SHW_STATIC_RULE_FL_NAME_NONE						HLP_IPSEC_BASE + SHW_STATIC_BASE + 306

#define SHW_STATIC_ALL_1									HLP_IPSEC_BASE + SHW_STATIC_BASE + 500
#define SHW_STATIC_ALL_2									HLP_IPSEC_BASE + SHW_STATIC_BASE + 501

#define SHW_STATIC_PRTPOLICY_POL_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 602
#define SHW_STATIC_PRTPOLICY_POL_DESC_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 603
#define SHW_STATIC_PRTPOLICY_POL_DESC_NONE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 604
#define SHW_STATIC_PRTPOLICY_ASSIGNED_YES_STR				HLP_IPSEC_BASE + SHW_STATIC_BASE + 605
#define SHW_STATIC_PRTPOLICY_ASSIGNED_NO_STR				HLP_IPSEC_BASE + SHW_STATIC_BASE + 606
#define SHW_STATIC_PRTPOLICY_MMPFS_YES_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 607
#define SHW_STATIC_PRTPOLICY_MMPFS_NO_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 608
#define SHW_STATIC_PRTPOLICY_POLL_INTERVAL					HLP_IPSEC_BASE + SHW_STATIC_BASE + 609
#define SHW_STATIC_PRTPOLICY_RULE_COUNT						HLP_IPSEC_BASE + SHW_STATIC_BASE + 610
#define SHW_STATIC_PRTPOLICY_RULE_DETAILS_TITLE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 611
#define SHW_STATIC_PRTPOLICY_RULE_DETAILS_UNDERLINE			HLP_IPSEC_BASE + SHW_STATIC_BASE + 612
#define SHW_STATIC_PRTPOLICY_ASSIGNED_AD					HLP_IPSEC_BASE + SHW_STATIC_BASE + 615

#define SHW_STATIC_PRTRULE_RULE_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 700
#define SHW_STATIC_PRTRULE_RULE_NAME_NONE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 701
#define SHW_STATIC_PRTRULE_AUTH_TITLE						HLP_IPSEC_BASE + SHW_STATIC_BASE + 705

#define SHW_STATIC_PRTRULE_TUNNEL_IP						HLP_IPSEC_BASE + SHW_STATIC_BASE + 708
#define SHW_STATIC_PRTRULE_CONN_ALL_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 709
#define SHW_STATIC_PRTRULE_CONN_LAN_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 710
#define SHW_STATIC_PRTRULE_CONN_DIALUP_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 711
#define SHW_STATIC_PRTRULE_CONN_NONE_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 712
#define SHW_STATIC_PRTRULE_FL_DETAILS_TITLE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 713
#define SHW_STATIC_PRTRULE_FL_DETAILS_UNDERLINE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 714
#define SHW_STATIC_PRTRULE_NO_FL_FOR_DEF_RULE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 715
#define SHW_STATIC_PRTRULE_FA_DETAILS_TITLE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 716
#define SHW_STATIC_PRTRULE_FA_TITLE_UNDERLINE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 717
#define SHW_STATIC_PRTRULE_RULE_NAME_STR9					HLP_IPSEC_BASE + SHW_STATIC_BASE + 718
#define SHW_STATIC_PRTRULE_RULE_NAME_NONE0					HLP_IPSEC_BASE + SHW_STATIC_BASE + 719
#define SHW_STATIC_PRTRULE_TRANS_COUNT						HLP_IPSEC_BASE + SHW_STATIC_BASE + 734
#define SHW_STATIC_PRTRULE_TUNNEL_COUNT						HLP_IPSEC_BASE + SHW_STATIC_BASE + 735
#define SHW_STATIC_PRTRULE_ACTIVATED_YES_STR				HLP_IPSEC_BASE + SHW_STATIC_BASE + 736
#define SHW_STATIC_PRTRULE_ACTIVATED_NO_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 737

#define SHW_STATIC_PRTNEGPOL_FA_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 800
#define SHW_STATIC_PRTNEGPOL_FA_NAME_NONE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 801
#define SHW_STATIC_PRTNEGPOL_ACTION_PERMIT					HLP_IPSEC_BASE + SHW_STATIC_BASE + 802
#define SHW_STATIC_PRTNEGPOL_ACTION_BLOCK					HLP_IPSEC_BASE + SHW_STATIC_BASE + 803
#define SHW_STATIC_PRTNEGPOL_ACTION_NEGOTIATE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 804
#define SHW_STATIC_PRTNEGPOL_SOFT_YES_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 805
#define SHW_STATIC_PRTNEGPOL_SOFT_NO_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 806
#define SHW_STATIC_PRTNEGPOL_INPASS_YES_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 807
#define SHW_STATIC_PRTNEGPOL_INPASS_NO_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 808
#define SHW_STATIC_PRTNEGPOL_SEC_MTD_COUNT					HLP_IPSEC_BASE + SHW_STATIC_BASE + 809

#define SHW_STATIC_PRTNEGPOL_ALGO_TITLE_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 812
#define SHW_STATIC_PRTNEGPOL_ALGO_TITLE_UNDERLINE			HLP_IPSEC_BASE + SHW_STATIC_BASE + 813

#define SHW_STATIC_PRTNEGPOL_QMPFS_YES_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 815
#define SHW_STATIC_PRTNEGPOL_QMPFS_NO_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 816

#define SHW_STATIC_PRTAUTH_KERBEROS							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1200
#define SHW_STATIC_PRTAUTH_ROORCA_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1201
#define SHW_STATIC_PRTAUTH_PRE_STR							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1202
#define SHW_STATIC_PRTAUTH_NONE_STR							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1203

#define SHW_STATIC_PRTFILTERDATA_FL_NAME_STR				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1300
#define SHW_STATIC_PRTFILTERDATA_FL_NAME_NONE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1301
#define SHW_STATIC_PRTFILTERDATA_FILTERS_COUNT				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1302

#define SHW_STATIC_PRTFILTERDATA_FILTERS_TITLE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1304
#define SHW_STATIC_PRTFILTERDATA_FILTERS_TITLE_UNDERLINE	HLP_IPSEC_BASE + SHW_STATIC_BASE + 1305
#define SHW_STATIC_PRTFILTERDATA_7							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1306
#define SHW_STATIC_PRTFILTERDATA_8							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1307
#define SHW_STATIC_PRTFILTERDATA_FL_GUID					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1308
#define SHW_STATIC_PRTFILTERDATA_FL_LASTMODIFIED	 		HLP_IPSEC_BASE + SHW_STATIC_BASE + 1309
#define SHW_STATIC_PRTFILTERDATA_FL_NAME_STR1				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1310

#define SHW_STATIC_PRTFSPEC_SRCDNS_ME						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1500
#define SHW_STATIC_PRTFSPEC_SRCDNS_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1501
#define SHW_STATIC_PRTFSPEC_SRCDNS_ANY						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1502
#define SHW_STATIC_PRTFSPEC_SRCDNS_SPECIFIC_IP				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1503
#define SHW_STATIC_PRTFSPEC_SRCDNS_SPECIFIC_SUBNET			HLP_IPSEC_BASE + SHW_STATIC_BASE + 1504
#define SHW_STATIC_PRTFSPEC_SRCDNS_NONE_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1505
#define SHW_STATIC_PRTFSPEC_DSTDNS_ME						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1506
#define SHW_STATIC_PRTFSPEC_DSTDNS_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1507
#define SHW_STATIC_PRTFSPEC_DSTDNS_ANY						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1508
#define SHW_STATIC_PRTFSPEC_DSTDNS_SPECIFIC_IP				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1509
#define SHW_STATIC_PRTFSPEC_DSTDNS_SPECIFIC_SUBNET			HLP_IPSEC_BASE + SHW_STATIC_BASE + 1510
#define SHW_STATIC_PRTFSPEC_DSTDNS_NONE_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1511
#define SHW_STATIC_PRTFSPEC_MIR_YES_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1512
#define SHW_STATIC_PRTFSPEC_MIR_NO_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1513
#define SHW_STATIC_PRTFSPEC_SRCDNS_RESOLVE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1514
#define SHW_STATIC_PRTFSPEC_DST_DNS_RESOLVE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1515
#define SHW_STATIC_PRTFSPEC_SRCDNS_DNSSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1516
#define SHW_STATIC_PRTFSPEC_SRCDNS_WINSSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1517
#define SHW_STATIC_PRTFSPEC_SRCDNS_DHCPSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1518
#define SHW_STATIC_PRTFSPEC_SRCDNS_DEFGATEWAY				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1519
#define SHW_STATIC_PRTFSPEC_DSTDNS_DNSSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1520
#define SHW_STATIC_PRTFSPEC_DSTDNS_WINSSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1521
#define SHW_STATIC_PRTFSPEC_DSTDNS_DHCPSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1522
#define SHW_STATIC_PRTFSPEC_DSTDNS_DEFGATEWAY				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1523
#define SHW_STATIC_PRTFSPEC_SRCDNS_STR5						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1524
#define SHW_STATIC_PRTFSPEC_SRCDNS_STR6						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1525

#define SHW_STATIC_PRTFSPEC_FORMAT15S						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1526
#define SHW_STATIC_PRTFSPEC_FORMAT_NO_NEWLINE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1527
#define SHW_STATIC_PRTFSPEC_FORMAT_NEWLINE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1528

#define SHW_STATIC_PRTFSPEC_NEWLINE							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1529
#define SHW_STATIC_PRTFSPEC_COMMA							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1530
#define SHW_STATIC_PRTFSPEC_EXTENSION						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1531
#define SHW_STATIC_PRTFSPEC_SPACE_COMMA						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1532

#define SHW_STATIC_PRTFILTER_SRCIP_ME						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1600
#define SHW_STATIC_PRTFILTER_SRCIP_ANY						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1601
#define SHW_STATIC_PRTFILTER_SRCIP_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1602
#define SHW_STATIC_PRTFILTER_SRCIP_MASK						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1603
#define SHW_STATIC_PRTFILTER_DSTIP_ME						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1604
#define SHW_STATIC_PRTFILTER_DSTIP_ANY						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1605
#define SHW_STATIC_PRTFILTER_DSTIP_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1606
#define SHW_STATIC_PRTFILTER_DSTIP_MASK						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1607
#define SHW_STATIC_PRTFILTER_SRCPORT_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1608
#define SHW_STATIC_PRTFILTER_SRCPORT_ANY					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1609
#define SHW_STATIC_PRTFILTER_DSTPORT_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1610
#define SHW_STATIC_PRTFILTER_DSTPORT_ANY					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1611
#define SHW_STATIC_PRTFILTER_RESOLVES						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1615
#define SHW_STATIC_PRTFILTER_DNS_FAILED						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1616
#define SHW_STATIC_PRTFILTER_SRCIP_DNSSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1617
#define SHW_STATIC_PRTFILTER_SRCIP_WINSSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1618
#define SHW_STATIC_PRTFILTER_SRCIP_DHCPSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1619
#define SHW_STATIC_PRTFILTER_SRCIP_DEFGATEWAY				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1620
#define SHW_STATIC_PRTFILTER_DSTIP_DNSSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1621
#define SHW_STATIC_PRTFILTER_DSTIP_WINSSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1622
#define SHW_STATIC_PRTFILTER_DSTIP_DHCPSERVER				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1623
#define SHW_STATIC_PRTFILTER_DSTIP_DEFGATEWAY				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1624

#define SHW_STATIC_PRTPROTOCOL_ICMP							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1700
#define SHW_STATIC_PRTPROTOCOL_TCP							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1701
#define SHW_STATIC_PRTPROTOCOL_UDP							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1703
#define SHW_STATIC_PRTPROTOCOL_RAW							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1708
#define SHW_STATIC_PRTPROTOCOL_ANY							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1709
#define SHW_STATIC_PRTPROTOCOL_OTHER						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1710

#define SHW_STATIC_PRTISAKMP_MMSEC_ORDER_TITLE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1802
#define SHW_STATIC_PRTISAKMP_MMLIFETIME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1803
#define SHW_STATIC_PRTISAKMP_ALGO_TITLE_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1804
#define SHW_STATIC_PRTISAKMP_ALGO_TITLE_UNDERLINE			HLP_IPSEC_BASE + SHW_STATIC_BASE + 1805

#define SHW_STATIC_PRTISAKMPSEC_DES_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1900
#define SHW_STATIC_PRTISAKMPSEC_3DES_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1901
#define SHW_STATIC_PRTISAKMPSEC_SHA1_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1902
#define SHW_STATIC_PRTISAKMPSEC_MD5_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1903
#define SHW_STATIC_PRTISAKMPSEC_DH_LOW_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1904
#define SHW_STATIC_PRTISAKMPSEC_DH_MED_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1905
#define SHW_STATIC_PRTISAKMPSEC_DH_2048_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1906

#define SHW_STATIC_ASSIGNEDGPO_SRCMACHINE					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2001
#define SHW_STATIC_ASSIGNEDGPO_SRCDOMAIN					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2002
#define SHW_STATIC_ASSIGNEDGPO_DC_NAME						HLP_IPSEC_BASE + SHW_STATIC_BASE + 2003
#define SHW_STATIC_ASSIGNEDGPO_GPO_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2004
#define SHW_STATIC_ASSIGNEDGPO_LOCAL_POL_NAME_STR			HLP_IPSEC_BASE + SHW_STATIC_BASE + 2005
#define SHW_STATIC_ASSIGNEDGPO_AD_POL_NAME_STR				HLP_IPSEC_BASE + SHW_STATIC_BASE + 2006
#define SHW_STATIC_ASSIGNEDGPO_GPO_DN_NAME					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2007
#define SHW_STATIC_ASSIGNEDGPO_GPO_OU_LINK					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2008
#define SHW_STATIC_ASSIGNEDGPO_AD_POL_DN_NAME				HLP_IPSEC_BASE + SHW_STATIC_BASE + 2009
#define SHW_STATIC_ASSIGNEDGPO_LOC_OPOL_ACTIVE_AD			HLP_IPSEC_BASE + SHW_STATIC_BASE + 2010
#define SHW_STATIC_ASSIGNEDGPO_LOC_POL_ACTIVE_STR			HLP_IPSEC_BASE + SHW_STATIC_BASE + 2011

#define SHW_STATIC_ASSIGNEDGPO_SRCMACHINE4					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2014
#define SHW_STATIC_ASSIGNEDGPO_SRCMACHINE5					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2015
#define SHW_STATIC_ASSIGNEDGPO_LOC_POL_NAME_NONE			HLP_IPSEC_BASE + SHW_STATIC_BASE + 2016
#define SHW_STATIC_ASSIGNEDGPO_AD_POL_NAME_NONE				HLP_IPSEC_BASE + SHW_STATIC_BASE + 2017
#define SHW_STATIC_ASSIGNEDGPO_POL_NAME_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2018
#define SHW_STATIC_ASSIGNEDGPO_POL_DN_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2019
#define SHW_STATIC_ASSIGNEDGPO_POL_ACTIVE_STR				HLP_IPSEC_BASE + SHW_STATIC_BASE + 2020

#define SHW_AUTH_EXCLUDE_CA_NAME_YES_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2021
#define SHW_AUTH_EXCLUDE_CA_NAME_NO_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 2022
#define SHW_AUTH_CERTMAP_ENABLED_YES_STR					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2023
#define SHW_AUTH_CERTMAP_ENABLED_NO_STR						HLP_IPSEC_BASE + SHW_STATIC_BASE + 2024


//
// Static Errors
//
#define	ERR_ADD_STATIC_POLICY_MISSING_POL_NAME  			HLP_IPSEC_BASE + HLP_ERROR_BASE + 100
#define	ERR_ADD_STATIC_POLICY_POLL_INTERVAL_MSG             HLP_IPSEC_BASE + HLP_ERROR_BASE + 101
#define	ERR_ADD_STATIC_POLICY_QMPERMM_MSG                 	HLP_IPSEC_BASE + HLP_ERROR_BASE + 102
#define	ERR_ADD_STATIC_POLICY_LIFETIME_LIMIT_MSG            HLP_IPSEC_BASE + HLP_ERROR_BASE + 103

#define	ERR_ADD_STATIC_CRNEWPOL_POL_EXISTS               	HLP_IPSEC_BASE + HLP_ERROR_BASE + 111
#define	ERR_ADD_STATIC_CRNEWPOL_DEF_RULE_ERR               	HLP_IPSEC_BASE + HLP_ERROR_BASE + 112
#define	ERR_ADD_STATIC_CRNEWPOL_ERROR               		HLP_IPSEC_BASE + HLP_ERROR_BASE + 113
#define	ERR_ADD_STATIC_CRNEWPOL_FAIL_DEF_AUTH               HLP_IPSEC_BASE + HLP_ERROR_BASE + 114
//
//Add Filterlist
//
#define	ERR_ADD_STATIC_FILTERLIST_MISSING_FL_NAME        	HLP_IPSEC_BASE + HLP_ERROR_BASE + 121
#define	ERR_ADD_STATIC_FILTERLIST_FL_ALREADY_EXISTS         HLP_IPSEC_BASE + HLP_ERROR_BASE + 122
#define	ERR_ADD_STATIC_FILTERLIST_ERROR_NEW_FL 				HLP_IPSEC_BASE + HLP_ERROR_BASE + 123
#define	ERR_ADD_STATIC_FILTERLIST_INVALID_GUID				HLP_IPSEC_BASE + HLP_ERROR_BASE + 124
//
//Add Filter
//
#define	ERR_ADD_STATIC_FILTER_ERROR_NEW_FILTER              HLP_IPSEC_BASE + HLP_ERROR_BASE + 131
//
//Add FilterAction
#define	ERR_ADD_STATIC_FILTERACTION_FA_EXISTS       		HLP_IPSEC_BASE + HLP_ERROR_BASE + 141
#define	ERR_ADD_STATIC_FILTERACTION_ERROR_NEW_FA           	HLP_IPSEC_BASE + HLP_ERROR_BASE + 142
#define	ERR_ADD_STATIC_FILTERACTION_INVALID_OPTIONS         HLP_IPSEC_BASE + HLP_ERROR_BASE + 143
#define	ERR_ADD_STATIC_FILTERACTION_MIMIMUM_QMSEC   		HLP_IPSEC_BASE + HLP_ERROR_BASE + 144
//
//Add Rule
//
#define	ERR_ADD_STATIC_RULE_MISSING_RULE_NAME  				HLP_IPSEC_BASE + HLP_ERROR_BASE + 151
#define	ERR_ADD_STATIC_RULE_MISSIGN_FA_NAME                 HLP_IPSEC_BASE + HLP_ERROR_BASE + 152
#define	ERR_ADD_STATIC_RULE_POL_NOT_AVAILABLE               HLP_IPSEC_BASE + HLP_ERROR_BASE + 153
#define	ERR_ADD_STATIC_RULE_RULE_ALREADY_EXISTS             HLP_IPSEC_BASE + HLP_ERROR_BASE + 154
#define	ERR_ADD_STATIC_RULE_FA_NOT_EXISTS                  	HLP_IPSEC_BASE + HLP_ERROR_BASE + 155
#define	ERR_ADD_STATIC_RULE_NO_FILTERS_IN_FL                HLP_IPSEC_BASE + HLP_ERROR_BASE + 156
#define	ERR_ADD_STATIC_RULE_ERROR_NEW_RULE 					HLP_IPSEC_BASE + HLP_ERROR_BASE + 157
#define	ERR_ADD_STATIC_RULE_MISSING_RULE_NAME_OR_ID 		HLP_IPSEC_BASE + HLP_ERROR_BASE + 158
#define	ERR_ADD_STATIC_RULE_POL_GUID_NOT_EXISTS				HLP_IPSEC_BASE + HLP_ERROR_BASE + 159
#define	ERR_ADD_STATIC_RULE_FA_GUID_NOT_EXISTS				HLP_IPSEC_BASE + HLP_ERROR_BASE + 160
#define	ERR_ADD_STATIC_RULE_DEF_AUTH_LOAD_FAILED			HLP_IPSEC_BASE + HLP_ERROR_BASE + 161
#define	ERR_ADD_STATIC_RULE_CERT_DECODING_FAIL				HLP_IPSEC_BASE + HLP_ERROR_BASE + 165
#define	ERR_ADD_STATIC_RULE_POL_NOT_EXIST_IN_DOMAIN			HLP_IPSEC_BASE + HLP_ERROR_BASE + 166
#define ERR_ADD_RULE_INVALID_TUNNEL             			HLP_IPSEC_BASE + HLP_ERROR_BASE + 167
#define	ERR_ADD_STATIC_FILTER_FL_NOT_EXISTS                 HLP_IPSEC_BASE + HLP_ERROR_BASE + 168
#define	ERR_ADD_STATIC_FILTER_SERVER_NOT_ALLOWED_BOTH_SIDES HLP_IPSEC_BASE + HLP_ERROR_BASE + 169
#define	ERR_ADD_STATIC_FILTER_FL_GUID_NOT_EXISTS			HLP_IPSEC_BASE + HLP_ERROR_BASE + 170
//
//Set Policy
//
#define	ERR_SET_STATIC_POLICY_NO_DS           				HLP_IPSEC_BASE + HLP_ERROR_BASE + 171
#define	ERR_SET_STATIC_POLICY_NO_GPO_NAME                 	HLP_IPSEC_BASE + HLP_ERROR_BASE + 172
#define	ERR_SET_STATIC_POLICY_ERR_GPO_ASSIGN                HLP_IPSEC_BASE + HLP_ERROR_BASE + 173
#define	ERR_SET_STATIC_POLICY_INVALID_CERTMAP_MSG           HLP_IPSEC_BASE + HLP_ERROR_BASE + 174
#define	ERR_SET_STATIC_POLICY_CERTMAP_YES_STR               HLP_IPSEC_BASE + HLP_ERROR_BASE + 175
#define	ERR_SET_STATIC_POLICY_CERT_MAP_NO_STR               HLP_IPSEC_BASE + HLP_ERROR_BASE + 176
//
//set filterlist
//
#define	ERR_SET_STATIC_FILTERLIST_ERR_UPDATE_FL_NAME        HLP_IPSEC_BASE + HLP_ERROR_BASE + 181
#define	ERR_SET_STATIC_FILTERLIST_ERR_UPDATE_FL_GUID        HLP_IPSEC_BASE + HLP_ERROR_BASE + 182
//
//set filter action
//
#define	ERR_SET_STATIC_FA_ERR_NAME_UPDATE           		HLP_IPSEC_BASE + HLP_ERROR_BASE + 191
#define	ERR_SET_STATIC_FA_ERR_GUID_UPDATE           		HLP_IPSEC_BASE + HLP_ERROR_BASE + 192
//
//set rule
//
#define	ERR_SET_STATIC_RULE_INVALID_NAME                   	HLP_IPSEC_BASE + HLP_ERROR_BASE + 201
#define	ERR_SET_STATIC_RULE_ERROR_UPDATE                   	HLP_IPSEC_BASE + HLP_ERROR_BASE + 202
#define	ERR_SET_STATIC_RULE_DEF_DEL_NOT_ALLOWED             HLP_IPSEC_BASE + HLP_ERROR_BASE + 203
#define	ERR_SET_STATIC_RULE_NEW_RULE_QUERY                  HLP_IPSEC_BASE + HLP_ERROR_BASE + 204
#define	ERR_SET_STATIC_RULE_INVALID_ID                   	HLP_IPSEC_BASE + HLP_ERROR_BASE + 205
//
//set def rule
//
#define	ERR_SET_STATIC_DEFRULE_ERROR_UPDATE    				HLP_IPSEC_BASE + HLP_ERROR_BASE + 211

#define	ERR_MISC_STATIC_IMPORTPOLICY_NO_FILE_NAME          	HLP_IPSEC_BASE + HLP_ERROR_BASE + 221
#define	ERR_MISC_STATIC_IMPORTPOLICY_INVALID_FILE          	HLP_IPSEC_BASE + HLP_ERROR_BASE + 222
#define	ERR_MISC_STATIC_IMPORTPOLICY_ERROR          		HLP_IPSEC_BASE + HLP_ERROR_BASE + 223
//
//export policy
//
#define	ERR_MISC_STATIC_EXPORTPOLICY_ERROR       			HLP_IPSEC_BASE + HLP_ERROR_BASE + 231

#define ERR_MISC_STATIC_RESDEFRULE_ERROR            		HLP_IPSEC_BASE + HLP_ERROR_BASE + 235
#define ERR_MISC_STATIC_RESDEFRULE_CMD_NA           		HLP_IPSEC_BASE + HLP_ERROR_BASE + 236

#define ERR_MISC_STATIC_SETSTORE_DOMAIN_NA           		HLP_IPSEC_BASE + HLP_ERROR_BASE + 237
#define ERR_MISC_STATIC_SETSTORE_NOT_DOMAIN_MEMBER			HLP_IPSEC_BASE + HLP_ERROR_BASE + 238

#define ERR_DEL_STATIC_POLICY_ERROR                 		HLP_IPSEC_BASE + HLP_ERROR_BASE + 241
#define ERR_SHW_STATIC_POLICY_NAME_NOT_EXISTS       		HLP_IPSEC_BASE + HLP_ERROR_BASE + 242
//
//delete filterlist
//
#define ERR_DEL_STATIC_FILTERLIST_DEL_NOT_ALLOWED           HLP_IPSEC_BASE + HLP_ERROR_BASE + 251
#define ERR_DEL_STATIC_FILTERLIST_ERROR             		HLP_IPSEC_BASE + HLP_ERROR_BASE + 252
//
//delete filter
//
#define ERR_SHW_STATIC_TAB_PRTALLFL_NAME_NOT_EXISTS         HLP_IPSEC_BASE + HLP_ERROR_BASE + 255
#define ERR_DEL_STATIC_FILTER_NOT_AVAILABLE                 HLP_IPSEC_BASE + HLP_ERROR_BASE + 256
#define ERR_DEL_STATIC_FILTER_ERROR                 		HLP_IPSEC_BASE + HLP_ERROR_BASE + 261
//
//delete filter action
//
#define ERR_DEL_STATIC_FA_DEL_NOT_ALLOWED           		HLP_IPSEC_BASE + HLP_ERROR_BASE + 265
#define ERR_DEL_STATIC_FA_ERROR           					HLP_IPSEC_BASE + HLP_ERROR_BASE + 266
#define ERR_SHW_STATIC_TAB_PRTALLFA_FA_COUNT_LIST           HLP_IPSEC_BASE + HLP_ERROR_BASE + 267
//
//delete rule
//
#define ERR_DEL_STATIC_RULE_ERR_DEL_RULE_NAME               HLP_IPSEC_BASE + HLP_ERROR_BASE + 271
#define ERR_DEL_STATIC_RULE_ERR_DEL_RULE_ID                 HLP_IPSEC_BASE + HLP_ERROR_BASE + 272
#define ERR_DEL_STATIC_RULE_DEF_DEL_NOT_ALLOWED             HLP_IPSEC_BASE + HLP_ERROR_BASE + 273
#define ERR_DEL_STATIC_RULE_NO_RULE_WITH_NAME               HLP_IPSEC_BASE + HLP_ERROR_BASE + 274

#define ERR_SHW_STATIC_RULE_NO_RULE_WITH_ID                 HLP_IPSEC_BASE + HLP_ERROR_BASE + 275
#define ERR_SHW_STATIC_RULE_MISSING_POL_NAME                HLP_IPSEC_BASE + HLP_ERROR_BASE + 276

#define ERR_SHW_STATIC_LIST_POLICY_COUNT             		HLP_IPSEC_BASE + HLP_ERROR_BASE + 280
#define ERR_SHW_STATIC_TAB_POLICY_ERR_NEGPOL             	HLP_IPSEC_BASE + HLP_ERROR_BASE + 281
#define ERR_SHW_STATIC_TAB_POLICY_ERR_FILTER             	HLP_IPSEC_BASE + HLP_ERROR_BASE + 282
#define ERR_SHW_STATIC_TAB_POLICY_ERR_ISAKMP             	HLP_IPSEC_BASE + HLP_ERROR_BASE + 283
//
//show filterl
//
#define ERR_SHW_STATIC_TAB_FL_NO_RULE_NAME_STR       		HLP_IPSEC_BASE + HLP_ERROR_BASE + 285
#define ERR_SHW_STATIC_TAB_RULE_NO_RULE_ID               	HLP_IPSEC_BASE + HLP_ERROR_BASE + 286
//
//show assigned gpo policy
//
#define ERR_SHW_STATIC_TAB_ASSIGNPOL_NO_ACTIVE_POL          HLP_IPSEC_BASE + HLP_ERROR_BASE + 290

#define ERR_SHW_STATIC_TAB_PRTALLFL_NO_FL           		HLP_IPSEC_BASE + HLP_ERROR_BASE + 295
#define ERR_SHW_STATIC_TAB_PRTALLFA_NO_FA           		HLP_IPSEC_BASE + HLP_ERROR_BASE + 296
#define ERR_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE3				HLP_IPSEC_BASE + HLP_ERROR_BASE + 297
#define ERR_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE4				HLP_IPSEC_BASE + HLP_ERROR_BASE + 298

#define	ERR_ADD_STATIC_FILTER_INVALID_SRCIP					HLP_IPSEC_BASE + HLP_ERROR_BASE + 299
#define	ERR_ADD_STATIC_FILTER_INVALID_SRCIPMASK				HLP_IPSEC_BASE + HLP_ERROR_BASE + 300
#define	ERR_ADD_STATIC_FILTER_ADDRESS_CONFLICT				HLP_IPSEC_BASE + HLP_ERROR_BASE + 301
#define	ERR_ADD_STATIC_FILTER_INVALID_SERVER_TYPE			HLP_IPSEC_BASE + HLP_ERROR_BASE + 302
#define	ERR_ADD_STATIC_FILTER_SERVER_TYPE_NEEDED			HLP_IPSEC_BASE + HLP_ERROR_BASE + 303
#define	ERR_ADD_STATIC_FILTER_INVALID_DSTIP					HLP_IPSEC_BASE + HLP_ERROR_BASE + 304
#define	ERR_ADD_STATIC_FILTER_INVALID_DSTIPMASK				HLP_IPSEC_BASE + HLP_ERROR_BASE + 305

#define	ERR_SET_STATIC_POL_NEWNAME							HLP_IPSEC_BASE + HLP_ERROR_BASE + 306
#define	ERR_SET_STATIC_RULE_NEWNAME							HLP_IPSEC_BASE + HLP_ERROR_BASE + 307
#define	ERR_SET_STATIC_FL_NEWNAME							HLP_IPSEC_BASE + HLP_ERROR_BASE + 308
#define	ERR_SET_STATIC_FA_NEWNAME							HLP_IPSEC_BASE + HLP_ERROR_BASE + 309
#define	ERR_SET_STATIC_SHOW_RULE_TYPE						HLP_IPSEC_BASE + HLP_ERROR_BASE + 310
//
// Errors
//
#define	ERR_STATIC_INTERNAL_ERROR							HLP_IPSEC_BASE + HLP_ERROR_BASE + 311
#define	ERR_SHW_STATIC_RULE_RULE_ID_GUID					HLP_IPSEC_BASE + HLP_ERROR_BASE + 312
#define	ERR_UPDATE_DEF_NEGPOL								HLP_IPSEC_BASE + HLP_ERROR_BASE + 313
#define	ERR_SET_POL_READ_ONLY_OBJECT						HLP_IPSEC_BASE + HLP_ERROR_BASE + 314
#define	ERR_ADD_SET_RULE_READ_ONLY_OBJECT					HLP_IPSEC_BASE + HLP_ERROR_BASE + 315
#define	ERR_SET_FA_READ_ONLY_OBJECT							HLP_IPSEC_BASE + HLP_ERROR_BASE + 316
#define	ERR_SET_FL_READ_ONLY_OBJECT							HLP_IPSEC_BASE + HLP_ERROR_BASE + 317
#define	ERR_DEL_POL_READ_ONLY_OBJECT						HLP_IPSEC_BASE + HLP_ERROR_BASE + 318
#define	ERR_DEL_RULE_READ_ONLY_OBJECT						HLP_IPSEC_BASE + HLP_ERROR_BASE + 319
#define	ERR_DEL_FA_READ_ONLY_OBJECT							HLP_IPSEC_BASE + HLP_ERROR_BASE + 320
#define	ERR_DEL_FL_READ_ONLY_OBJECT							HLP_IPSEC_BASE + HLP_ERROR_BASE + 321

#define ERR_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE5				HLP_IPSEC_BASE + HLP_ERROR_BASE + 322

//
// Dynamic Errors
//
#define ERR_DYN_ACTION_IN_OUT_NEGOTIATE 					HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 1
#define ERR_DYN_INVALID_PORT								HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 2
#define ERR_DYN_QMP_DOES_NOT_EXIST							HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 3
#define ERR_DYN_MMP_DOES_NOT_EXIST							HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 4
#define ERR_DYN_QMP_NEEDED									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 5
#define ERR_DYN_INVALID_MIRROR								HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 6

#define ERR_DYN_MMF_DOES_NOT_EXIST							HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 11
#define ERR_DYN_TRANSPORT_DOES_NOT_EXIST					HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 12
#define ERR_DYN_TUNNEL_DOES_NOT_EXIST						HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 13

#define ERROR_DEL_NO_MMP									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 14
#define ERROR_DEL_NO_QMP									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 15

#define ERR_DYN_MMP_EXISTS									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 21

#define ERR_DYN_QMP_EXISTS									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 31

#define ERR_DYN_RULE_MMP_DOES_NOT_EXIST						HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 41

#define ERR_DYN_RULE_QMP_DOES_NOT_EXIST						HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 51

#define ERR_DYN_DEL_MMF_DOES_NOT_EXIST						HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 61
#define ERR_DYN_DEL_MMF_MMP_DOES_NOT_EXIST					HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 62
#define ERR_DYN_DEL_MMP_DOES_NOT_EXIST						HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 63
#define ERR_DYN_DEL_SPECIFIED_MMF_DOES_NOT_EXIST			HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 64

#define ERR_DYN_DEL_QMF_DOES_NOT_EXIST						HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 71
#define ERR_DYN_DEL_QMF_QMP_DOES_NOT_EXIST					HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 72
#define ERR_DYN_DEL_QMP_DOES_NOT_EXIST						HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 73
#define ERR_DYN_DEL_SPECIFIED_QMF_DOES_NOT_EXIST			HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 74
#define ERR_DYN_DEL_AUTH_BEING_USED							HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 75
#define ERR_DYN_DEL_MMF_OBJ_NOTDEL							HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 76
#define ERR_DYN_DEL_TRANSPORT_OBJ_NOTDEL					HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 77
#define ERR_DYN_DEL_TUNNEL_OBJ_NOTDEL						HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 78


#define ERROR_PA_NOT_RUN									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 81
#define ERROR_PA_SUCCESS									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 82

#define ERROR_PARSER_STATS									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 90
#define ERROR_PARSER_ADDR									HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 91
#define ERROR_PARSER_ADDRTYPE								HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 92
#define ERROR_PARSER_TUNNELADDRTYPE							HLP_IPSEC_BASE + HLP_ERROR_BASE + ERROR_BASE_DYNAMIC + 93
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\parser_util.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Module			:	parser_util.cpp
//
// Purpose			: 	All utility functions used by the parser
//
// Developers Name	:	N.Surendra Sai / Vunnam Kondal Rao
//
// History			:
//
// Date	    	Author    	Comments
//
// 27 Aug 2001
//
//////////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern  HINSTANCE g_hModule;
extern  void *g_AllocPtr[MAX_ARGS];
extern STORAGELOCATION g_StorageLocation;

extern DWORD	ValidateBool(IN		LPTSTR		ppcTok);

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ListToSecMethod()
//
// Date of Creation	:	12 Sept 2001
//
// Parameters		:  	IN 		LPTSTR 			szText  	// string to convert
//    					IN OUT  IPSEC_MM_OFFER 	SecMethod 	// target struct to be filled.
//
// Return			:	DWORD
//				 		T2P_OK
// 				    	T2P_NULL_STRING
//    					T2P_GENERAL_PARSE_ERROR
//    					T2P_DUP_ALGS
//	   					T2P_INVALID_P1GROUP
//	   					T2P_P1GROUP_MISSING
//
// Description		:	converts string to Phase 1 offer
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ListToSecMethod(
		IN 		LPTSTR 			szText,
		IN OUT 	IPSEC_MM_OFFER 	&SecMethod
		)
{
	DWORD  dwReturn = T2P_OK;
	_TCHAR szTmp[MAX_STR_LEN] = {0};
	LPTSTR pString1 = NULL;
	LPTSTR pString2 = NULL;
	BOOL bEncryption	 = FALSE;
	BOOL bAuthentication = FALSE;

	if (szText == NULL)
	{
		dwReturn = T2P_NULL_STRING;
		BAIL_OUT;
	}

	if (_tcslen(szText) < MAX_STR_LEN)
	{
		_tcsncpy(szTmp, szText,MAX_STR_LEN-1);
	}
	else
	{
		dwReturn = T2P_GENERAL_PARSE_ERROR;
		BAIL_OUT;
	}

	pString1 = _tcschr(szTmp, POTF_P1_TOKEN);
	pString2 = _tcsrchr(szTmp, POTF_P1_TOKEN);

	if ((pString1 != NULL) && (pString2 != NULL) && (pString1 != pString2))
	{
		*pString1 = '\0';
		*pString2 = '\0';
		++pString1;
		++pString2;

		// we allow the hash and encryption to be specified in either
		// the first or second field
		if (_tcsicmp(szTmp, POTF_P1_DES) == 0)
		{
			bEncryption = true;
			SecMethod.EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_DES;
			SecMethod.EncryptionAlgorithm.uAlgoKeyLen = SecMethod.EncryptionAlgorithm.uAlgoRounds = 0;
		}
		else if (_tcsicmp(szTmp, POTF_P1_3DES) == 0)
		{
			bEncryption = true;
			SecMethod.EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
			SecMethod.EncryptionAlgorithm.uAlgoKeyLen = SecMethod.EncryptionAlgorithm.uAlgoRounds = 0;
		}
		else if (_tcsicmp(szTmp, POTF_P1_MD5) == 0)
		{
			bAuthentication = true;
			SecMethod.HashingAlgorithm.uAlgoIdentifier = HMAC_AUTH_ALGO_MD5;
			SecMethod.HashingAlgorithm.uAlgoKeyLen = SecMethod.HashingAlgorithm.uAlgoRounds = 0;
		}
		else if ( (_tcsicmp(szTmp, POTF_P1_SHA1) == 0) )
		{
			bAuthentication = true;
			SecMethod.HashingAlgorithm.uAlgoIdentifier = HMAC_AUTH_ALGO_SHA1;
			SecMethod.HashingAlgorithm.uAlgoKeyLen = SecMethod.HashingAlgorithm.uAlgoRounds = 0;
		}
		else
		{
			// parse error
			dwReturn = T2P_GENERAL_PARSE_ERROR;
		}

		if (_tcsicmp(pString1, POTF_P1_DES) == 0 && !bEncryption)
		{
			bEncryption = true;
			SecMethod.EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_DES;
			SecMethod.EncryptionAlgorithm.uAlgoKeyLen = SecMethod.EncryptionAlgorithm.uAlgoRounds = 0;
		}
		else if (_tcsicmp(pString1, POTF_P1_3DES) == 0 && !bEncryption)
		{
			bEncryption = true;
			SecMethod.EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
			SecMethod.EncryptionAlgorithm.uAlgoKeyLen = SecMethod.EncryptionAlgorithm.uAlgoRounds = 0;
		}
		else if (_tcsicmp(pString1, POTF_P1_MD5) == 0 && !bAuthentication)
		{
			bAuthentication = true;
			SecMethod.HashingAlgorithm.uAlgoIdentifier = HMAC_AUTH_ALGO_MD5;
			SecMethod.HashingAlgorithm.uAlgoKeyLen = SecMethod.HashingAlgorithm.uAlgoRounds = 0;
		}
		else if ((_tcsicmp(pString1, POTF_P1_SHA1) == 0) && !bAuthentication)
		{
			bAuthentication = true;
			SecMethod.HashingAlgorithm.uAlgoIdentifier = HMAC_AUTH_ALGO_SHA1;
			SecMethod.HashingAlgorithm.uAlgoKeyLen = SecMethod.HashingAlgorithm.uAlgoRounds = 0;
		}
		else
		{
			// parse error
			dwReturn = T2P_GENERAL_PARSE_ERROR;
		}

		// now for the group
		if (isdigit(pString2[0]))
		{
			switch (pString2[0])
			{
				case '1'	:
				SecMethod.dwDHGroup = POTF_OAKLEY_GROUP1;
				break;
				case '2'	:
				SecMethod.dwDHGroup = POTF_OAKLEY_GROUP2;
				break;
				case '3'	:
				SecMethod.dwDHGroup = POTF_OAKLEY_GROUP2048;
				break;
				default	:
				dwReturn = T2P_INVALID_P1GROUP;
				break;
			}
		}
		else
		{
			dwReturn = T2P_P1GROUP_MISSING;
		}
	}
	else
	{
		dwReturn = T2P_GENERAL_PARSE_ERROR;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	StringToRootcaAuth()
//
// Date of Creation	:	13th Aug 2001
//
// Parameters		:	IN 		szText			// String to be converted
//						IN OUT	AuthInfo		// Target struct to be filled
//
// Return			:	DWORD
//						T2P_OK
//						T2P_NO_PRESHARED_KEY
//						T2P_INVALID_AUTH_METHOD
//						T2P_ENCODE_FAILED
//						T2P_NULL_STRING
//
// Description		:	This Function takes user input authentication string, validates
//						and puts into Main mode auth info structure
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
StringToRootcaAuth(
		IN		LPTSTR 					szText,
		IN OUT 	INT_IPSEC_MM_AUTH_INFO 	&AuthInfo
		)
{
	DWORD  dwStatus = ERROR_SUCCESS,dwReturn = T2P_OK;
	LPTSTR szTemp = NULL;
	DWORD  dwTextLen = 0;
	DWORD  dwInfoLen = 0;
	LPBYTE pbInfo = NULL;

	if (szText == NULL)
	{
		dwReturn = T2P_NULL_STRING;
		BAIL_OUT;
	}

	AuthInfo.pAuthInfo		= NULL;
	AuthInfo.dwAuthInfoSize = 0;

	dwTextLen = _tcslen(szText);

	dwInfoLen = _tcslen(szText);
	szTemp  = (LPTSTR) calloc(dwInfoLen+1,sizeof(_TCHAR));
	if(szTemp == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	AuthInfo.AuthMethod = IKE_RSA_SIGNATURE;
	_tcsncpy(szTemp, szText, dwInfoLen);
	AuthInfo.dwAuthInfoSize = _tcslen(szTemp)+1;

	pbInfo = (LPBYTE) new _TCHAR[AuthInfo.dwAuthInfoSize];
	if(pbInfo == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memcpy(pbInfo, szTemp, sizeof(TCHAR)*AuthInfo.dwAuthInfoSize);
	AuthInfo.dwAuthInfoSize *= sizeof(WCHAR);
	AuthInfo.pAuthInfo = pbInfo;

	LPBYTE asnCert = NULL;

	dwStatus = EncodeCertificateName((LPTSTR) AuthInfo.pAuthInfo,&asnCert,&AuthInfo.dwAuthInfoSize);

	delete [] AuthInfo.pAuthInfo;
	AuthInfo.pAuthInfo = NULL;

	if(dwStatus == ERROR_SUCCESS )
	{
		AuthInfo.pAuthInfo = asnCert;
		dwReturn = T2P_OK;
	}
	else
	{
		if(dwStatus == ERROR_OUTOFMEMORY)		// Either there was a error out of memory
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		AuthInfo.pAuthInfo = NULL;
		AuthInfo.dwAuthInfoSize = 0;
		dwReturn = T2P_ENCODE_FAILED;			// ... else the encode failed.
	}

error:
	if (szTemp)
	{
		free(szTemp);
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ListToOffer()
//
// Date of Creation	:	13th Aug 2001
//
// Parameters		:	IN 		LPTSTR			szText	// string to convert
//						IN OUT  IPSEC_QM_OFFER  &Offer	// target struct to be filled.
//
// Return			:	DWORD
//						T2P_OK
//						T2P_NULL_STRING
//						T2P_P2_SECLIFE_INVALID
//						T2P_P2_KBLIFE_INVALID
//						T2P_INVALID_P2REKEY_UNIT
//						T2P_INVALID_HASH_ALG
//						T2P_GENERAL_PARSE_ERROR
//						T2P_DUP_ALGS
//						T2P_NONE_NONE
//						T2P_INCOMPLETE_ESPALGS
//						T2P_INVALID_IPSECPROT
//						T2P_P2_KBLIFE_INVALID
//						T2P_AHESP_INVALID
//
// Description		:	Converts string to Phase 2 offer (quick mode)
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ListToOffer(
		IN 		LPTSTR 			szText,
		IN OUT	IPSEC_QM_OFFER 	&Offer
		)
{
	DWORD  dwReturn = T2P_OK,dwStatus = 0;

	_TCHAR szTmp[MAX_STR_LEN] = {0};
	LPTSTR pAnd = NULL,pOptions = NULL,pString = NULL;

	BOOL bLifeSpecified = FALSE;
	BOOL bDataSpecified = FALSE;

	if (szText == NULL)
	{
		dwReturn = T2P_NULL_STRING;
		BAIL_OUT;
	}

	Offer.dwNumAlgos = 0;
	Offer.dwPFSGroup = 0;
	if (_tcslen(szText) < MAX_STR_LEN)
	{
		_tcsncpy(szTmp, szText,MAX_STR_LEN-1);
	}
	else
	{
		dwReturn = T2P_GENERAL_PARSE_ERROR;
		BAIL_OUT;
	}

	pOptions = _tcsrchr(szTmp, POTF_NEGPOL_CLOSE);

	if ((pOptions != NULL) && *(pOptions + 1) != '\0' && *(pOptions + 1) == POTF_PT_TOKEN && *(pOptions + 2) != '\0')
	{
		 ++pOptions; // we have crossed ']'
		 *pOptions = '\0';						// We have zero'd *pOption
		 ++pOptions; // we have crossed ':'

		pString = _tcschr(pOptions, POTF_REKEY_TOKEN);
		if (pString != NULL)
		{
		   *pString = '\0';
		   ++pString;

		   switch (pString[_tcslen(pString) - 1])		// First parse Last one ie out of 200K/300S ->300S
		   {
				case 'k'	:
				case 'K'	:
					bDataSpecified = TRUE;
					pString[_tcslen(pString) - 1] = '\0';
					dwStatus = _stscanf(pString,_TEXT("%u"),&Offer.Lifetime.uKeyExpirationKBytes);
					if (dwStatus != 1)
					{
						dwReturn = T2P_P2_KBLIFE_INVALID;
					}
					else
					{
						if (!IsWithinLimit(Offer.Lifetime.uKeyExpirationKBytes,P2_Kb_LIFE_MIN,P2_Kb_LIFE_MAX) )
						{
							dwReturn = T2P_P2_KBLIFE_INVALID;
						}
					}
					break;
				case 's'	:
				case 'S'	:
					bLifeSpecified = TRUE;
					pString[_tcslen(pString) - 1] = '\0';
					dwStatus = _stscanf(pString,_TEXT("%u"),&Offer.Lifetime.uKeyExpirationTime);
					if (dwStatus != 1)
					{
						dwReturn = T2P_P2_SECLIFE_INVALID;
					}
					else if (!IsWithinLimit(Offer.Lifetime.uKeyExpirationTime,P2_Sec_LIFE_MIN,P2_Sec_LIFE_MAX) )
					{
						dwReturn = T2P_P2_SECLIFE_INVALID;
					}
					break;
				default		:
					dwReturn = T2P_P2_KS_INVALID;
					break;
			}
		}
		if(dwReturn == T2P_OK)
		{
			switch (pOptions[_tcslen(pOptions) - 1])
			{
				case 'k'	:
				case 'K'	:
					if(!bDataSpecified )
					{
						pOptions[_tcslen(pOptions) - 1] = '\0';
						dwStatus = _stscanf(pOptions,_TEXT("%u"),&Offer.Lifetime.uKeyExpirationKBytes);
						if (dwStatus != 1)
						{
							dwReturn = T2P_P2_KBLIFE_INVALID;
						}
						else if (!IsWithinLimit(Offer.Lifetime.uKeyExpirationKBytes,P2_Kb_LIFE_MIN,P2_Kb_LIFE_MAX) )
						{
							dwReturn = T2P_P2_KBLIFE_INVALID;
						}
					}
					else
					{
						dwReturn = T2P_P2_KS_INVALID;
					}
					break;
				case 's'	:
				case 'S'	:
					if(!bLifeSpecified )
					{
						pOptions[_tcslen(pOptions) - 1] = '\0';
						dwStatus = _stscanf(pOptions,_TEXT("%u"),&Offer.Lifetime.uKeyExpirationTime);
						if (dwStatus != 1)
						{
							dwReturn = T2P_P2REKEY_TOO_LOW;
						}
						else if (!IsWithinLimit(Offer.Lifetime.uKeyExpirationTime,P2_Sec_LIFE_MIN,P2_Sec_LIFE_MAX) )
						{
							dwReturn = T2P_P2_SECLIFE_INVALID;
						}
					}
					else
					{
						dwReturn = T2P_P2_KS_INVALID;
					}
					break;
				default		:
					dwReturn = T2P_INVALID_P2REKEY_UNIT;
					break;
			}
		}
	}
	if(dwReturn==T2P_OK)
	{
		pAnd = _tcschr(szTmp, POTF_NEGPOL_AND);

		if ( pAnd != NULL )
		{
			//
			// we have an AND proposal
			//
			*pAnd = '\0';
			++pAnd;

			dwReturn = TextToAlgoInfo(szTmp, Offer.Algos[Offer.dwNumAlgos]);
			++Offer.dwNumAlgos;
			if ( T2P_SUCCESS(dwReturn) )
			{
				dwReturn = TextToAlgoInfo(pAnd, Offer.Algos[Offer.dwNumAlgos]);
				if( (Offer.Algos[Offer.dwNumAlgos].Operation) == (Offer.Algos[Offer.dwNumAlgos-1].Operation) )
				{
					dwReturn = T2P_AHESP_INVALID;
				}
				++Offer.dwNumAlgos;
			}
		}
		else
		{
			dwReturn = TextToAlgoInfo(szTmp, Offer.Algos[Offer.dwNumAlgos]);
			++Offer.dwNumAlgos;
		}
	}
error:
   return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	TextToAlgoInfo()
//
// Date of Creation	:	26th Aug 2001
//
// Parameters		:	IN 		LPTSTR    		szText 		// string to convert
//    					IN OUT 	IPSEC_QM_ALGO	&algoInfo 	// target struct to be filled.
//
// Return			:	DWORD
//						T2P_OK
//						T2P_INVALID_HASH_ALG
//						T2P_GENERAL_PARSE_ERROR
//						T2P_DUP_ALGS
//						T2P_NONE_NONE
//						T2P_INCOMPLETE_ESPALGS
//						T2P_INVALID_IPSECPROT
//						T2P_NULL_STRING
//
// Description		:	Converts string to IPSEC_QM_ALGO,parses AH[alg] or ESP[hashalg,confalg]
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
TextToAlgoInfo(
		IN	LPTSTR szText,
		OUT IPSEC_QM_ALGO & algoInfo
		)
{
	DWORD dwReturn = T2P_OK;
	_TCHAR szTmp[MAX_STR_LEN] = {0};

	LPTSTR pOpen = NULL,pClose = NULL,pString = NULL;
	BOOL bEncryption  = FALSE;		// these are used for processing Auth+Encryption
	BOOL bAuthentication= FALSE;	// defaults to NONE+NONE

	if (szText == NULL)
	{
		dwReturn  = T2P_NULL_STRING;
		BAIL_OUT;
	}

	if (_tcslen(szText) < MAX_STR_LEN)
	{
		_tcsncpy(szTmp, szText,MAX_STR_LEN-1);
	}
	else
	{
		dwReturn = T2P_GENERAL_PARSE_ERROR;
		BAIL_OUT;
	}

	algoInfo.uAlgoKeyLen = algoInfo.uAlgoRounds = 0;
	pOpen = _tcschr(szTmp, POTF_NEGPOL_OPEN);
	pClose = _tcsrchr(szTmp, POTF_NEGPOL_CLOSE);

	if ((pOpen != NULL) && (pClose != NULL) && (*(pClose + 1) == '\0')) // defense
	{
		*pOpen = '\0';
		*pClose = '\0';
		++pOpen;

		if (_tcsicmp(szTmp, POTF_NEGPOL_AH) == 0)
		{
			algoInfo.Operation = AUTHENTICATION;

			if (_tcsicmp(pOpen, POTF_NEGPOL_MD5) == 0)
			{
				algoInfo.uAlgoIdentifier = AUTH_ALGO_MD5;
			}
			else if (_tcsicmp(pOpen, POTF_NEGPOL_SHA1) == 0)
			{
				algoInfo.uAlgoIdentifier = AUTH_ALGO_SHA1;
			}
			else
			{
				dwReturn = T2P_INVALID_HASH_ALG;
			}
		}
		else if (_tcsicmp(szTmp, POTF_NEGPOL_ESP) == 0)
		{
			algoInfo.Operation = ENCRYPTION;
			pString = _tcschr(pOpen, POTF_ESPTRANS_TOKEN);

			if (pString != NULL)
			{
				*pString = '\0';
				++pString;

				// we allow the hash and encryption to be specified in either
				// the first or second field
				if (_tcsicmp(pOpen, POTF_NEGPOL_DES) == 0)
		        {
					bEncryption = true;
					algoInfo.uAlgoIdentifier = CONF_ALGO_DES;
		        }
				else if (_tcsicmp(pOpen, POTF_NEGPOL_3DES) == 0)
				{
					bEncryption = true;
					algoInfo.uAlgoIdentifier = CONF_ALGO_3_DES;
				}
				else if (_tcsicmp(pOpen, POTF_NEGPOL_MD5) == 0)
				{
					bAuthentication = true;
					algoInfo.uSecAlgoIdentifier = HMAC_AUTH_ALGO_MD5;
				}
				else if (_tcsicmp(pOpen, POTF_NEGPOL_SHA1) == 0)
				{
					bAuthentication = true;
					algoInfo.uSecAlgoIdentifier = HMAC_AUTH_ALGO_SHA1;
				}
				else if (_tcsicmp(pOpen, POTF_NEGPOL_NONE) != 0)
				{
					//
					// parse error
					//
					dwReturn = T2P_GENERAL_PARSE_ERROR;
					BAIL_OUT;
				}

				// now the second one
				if (_tcsicmp(pString, POTF_NEGPOL_DES) == 0 && !bEncryption)
				{
					bEncryption = true;
					algoInfo.uAlgoIdentifier = CONF_ALGO_DES;
				}
				else if (_tcsicmp(pString, POTF_NEGPOL_3DES) == 0 && !bEncryption)
				{
					bEncryption = true;
					algoInfo.uAlgoIdentifier = CONF_ALGO_3_DES;
				}
				else if (_tcsicmp(pString, POTF_NEGPOL_MD5) == 0 && !bAuthentication)
				{
					bAuthentication = true;
					algoInfo.uSecAlgoIdentifier = HMAC_AUTH_ALGO_MD5;
				}
				else if ((_tcsicmp(pString, POTF_NEGPOL_SHA1) == 0) && !bAuthentication)
				{
					bAuthentication = true;
					algoInfo.uSecAlgoIdentifier = HMAC_AUTH_ALGO_SHA1;
				}
				else if (_tcsicmp(pString, POTF_NEGPOL_NONE) != 0)
				{
					//
					// parse error
					//
					dwReturn = T2P_GENERAL_PARSE_ERROR;
				}
				// now, fill in the NONE policies or detect NONE, NONE
				if (!bAuthentication && !bEncryption)
				{
					dwReturn = T2P_NONE_NONE;
				}
				else if (!bAuthentication)
				{
					algoInfo.uSecAlgoIdentifier = HMAC_AUTH_ALGO_NONE;
				}
				else if (!bEncryption)
				{
					algoInfo.uAlgoIdentifier = CONF_ALGO_NONE;
				}
			}
			else // error
			{
				dwReturn = T2P_INCOMPLETE_ESPALGS;
			}
		}
		else
		{
			dwReturn = T2P_INVALID_IPSECPROT;
		}
	}
	else  // error
   	{
		dwReturn = T2P_GENERAL_PARSE_ERROR;
   	}
error:
   return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	LoadQMOfferDefaults()
//
// Date of Creation	:	12th Aug 2001
//
// Parameters		:  	IN OUT 	Offer 	// target struct to be filled.
//
// Description		:	Fills the Default values for Quick mode offer structure
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

VOID
LoadQMOfferDefaults(
		IN OUT IPSEC_QM_OFFER & Offer
		)
{
	Offer.Lifetime.uKeyExpirationTime	= POTF_DEFAULT_P2REKEY_TIME;
    Offer.Lifetime.uKeyExpirationKBytes	= POTF_DEFAULT_P2REKEY_BYTES;
	Offer.dwFlags						= 0;
	Offer.bPFSRequired					= FALSE;
	Offer.dwPFSGroup					= 0;
	Offer.dwNumAlgos					= 2;
	Offer.dwReserved					= 0;

	Offer.Algos[0].Operation			= ENCRYPTION;
	Offer.Algos[0].uAlgoIdentifier		= 0;
    Offer.Algos[0].uSecAlgoIdentifier	= (HMAC_AUTH_ALGO_ENUM)0;
    Offer.Algos[0].uAlgoKeyLen			= 0;
    Offer.Algos[0].uSecAlgoKeyLen		= 0;
    Offer.Algos[0].uAlgoRounds			= 0;
	Offer.Algos[0].uSecAlgoRounds		= 0;
    Offer.Algos[0].MySpi				= 0;
	Offer.Algos[0].PeerSpi				= 0;

	Offer.Algos[1].Operation			= (IPSEC_OPERATION)0;
	Offer.Algos[1].uAlgoIdentifier		= 0;
    Offer.Algos[1].uSecAlgoIdentifier	= (HMAC_AUTH_ALGO_ENUM)0;
    Offer.Algos[1].uAlgoKeyLen			= 0;
    Offer.Algos[1].uSecAlgoKeyLen		= 0;
    Offer.Algos[1].uAlgoRounds			= 0;
	Offer.Algos[1].uSecAlgoRounds		= 0;
    Offer.Algos[1].MySpi				= 0;
	Offer.Algos[1].PeerSpi				= 0;

}

//////////////////////////////////////////////////////////////////////////////
//
//	Function		: 	LoadSecMethodDefaults()
//
//	Date of Creation:	7th Aug 2001
//
//	Parameters		:	IN OUT SecMethod		// Struct which is filled with default values
//
//	Return			: 	VOID
//
//	Description		: 	It Fills default values for IPSEC_MM_OFFER
//
//	Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

VOID
LoadSecMethodDefaults(
		IN OUT IPSEC_MM_OFFER &SecMethod
		)
{
	SecMethod.Lifetime.uKeyExpirationTime 			= POTF_DEFAULT_P1REKEY_TIME;
	SecMethod.Lifetime.uKeyExpirationKBytes 		= 0;
	SecMethod.dwFlags								= 0;
	SecMethod.dwQuickModeLimit						= POTF_DEFAULT_P1REKEY_QMS;
	SecMethod.dwDHGroup								= 0;
	SecMethod.EncryptionAlgorithm.uAlgoIdentifier 	= 0;
	SecMethod.EncryptionAlgorithm.uAlgoKeyLen 		= 0;
	SecMethod.EncryptionAlgorithm.uAlgoRounds 		= 0;
	SecMethod.HashingAlgorithm.uAlgoIdentifier 		= 0;
	SecMethod.HashingAlgorithm.uAlgoKeyLen 			= 0;
	SecMethod.HashingAlgorithm.uAlgoRounds 			= 0;
}


//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadKerbAuthInfo()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERROR_INVALID_OPTION_VALUE
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates Yes/No
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadKerbAuthInfo(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 	pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PSTA_MM_AUTH_METHODS pMMInfo = NULL;
	PSTA_AUTH_METHODS pInfo = NULL;

	if (*pdwUsed > MAX_ARGS_LIMIT)
	{
		dwReturn = ERROR_OUT_OF_STRUCTURES;
		BAIL_OUT;
	}

	pInfo = new STA_AUTH_METHODS;
	if (!pInfo)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	dwStatus = ValidateBool(pszInput);

	if (dwStatus != ARG_YES)
	{
		if (dwStatus == ARG_NO)
		{
			// valid parameter, but we don't enter any auth info
			dwStatus = ERROR_SUCCESS;
		}
		else
		{
			dwStatus = ERRCODE_INVALID_ARG;
		}

		// if we get here, we didn't have a yes param value for kerberos, so don't
		// generate the auth info structure
		BAIL_OUT;
	}

	// Generate the auth info
	//
	dwReturn = GenerateKerbAuthInfo(&pMMInfo);
	if (dwReturn != NO_ERROR)
	{
		BAIL_OUT;
	}

	pInfo->pAuthMethodInfo = pMMInfo;
	pInfo->dwNumAuthInfos = 1;
	pInfo->pAuthMethodInfo->dwSequence = dwCount;

	// Update the parser
	//
	pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;         // one auth info struct
	pParser->Cmd[dwCount].pArg = pInfo;
	pParser->Cmd[dwCount].dwCmdToken = dwTagType;
	pInfo = NULL;

error:
	if (pInfo)
	{
		delete pInfo;
	}

	return dwReturn;
}


//////////////////////////////////////////////////////////////////////////////
//
//	Function			:	LoadPskAuthInfo()
//
//	Date of Creation	:	08th Jan 2002
//
//	Parameters			:	IN 	LPTSTR 		pszInput,
//							OUT PPARSER_PKT pParser,
//							IN 	DWORD 		dwTagType,
//							IN 	PDWORD 		pdwUsed,
//							IN 	DWORD 		dwCount,
//
//	Return				:	ERROR_SUCESS
//							ERROR_INVALID_OPTION_VALUE
//							ERROR_OUTOFMEMORY
//
//	Description			:	Validates string
//
//
//	History				:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
LoadPskAuthInfo(
	IN 	LPTSTR 		pszInput,
	OUT PPARSER_PKT pParser,
	IN 	DWORD 		dwTagType,
	IN 	PDWORD 		pdwUsed,
	IN 	DWORD 		dwCount
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwStatus = 0;
	PSTA_MM_AUTH_METHODS pMMInfo = NULL;
	PSTA_AUTH_METHODS pInfo = NULL;

	if (*pdwUsed > MAX_ARGS_LIMIT)
	{
		dwReturn = ERROR_OUT_OF_STRUCTURES;
		BAIL_OUT;
	}

	pInfo = new STA_AUTH_METHODS;
	if (!pInfo)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	// verify there really is a string there
	//
	if (pszInput[0] == _TEXT('\0'))
	{
	    dwReturn = ERRCODE_INVALID_ARG;
	    BAIL_OUT;
	}

	// Generate the auth info
	//
	dwReturn = GeneratePskAuthInfo(&pMMInfo, pszInput);
	if (dwReturn != NO_ERROR)
	{
		BAIL_OUT;
	}

	pInfo->pAuthMethodInfo = pMMInfo;
	pInfo->dwNumAuthInfos = 1;
	pInfo->pAuthMethodInfo->dwSequence = dwCount;

	// Update the parser
	//
	pParser->Cmd[dwCount].dwStatus = VALID_TOKEN;         // one auth info struct
	pParser->Cmd[dwCount].pArg = pInfo;
	pParser->Cmd[dwCount].dwCmdToken = dwTagType;
	pInfo = NULL;

error:
	if (pInfo)
	{
		delete pInfo;
	}

	return dwReturn;
}


//////////////////////////////////////////////////////////////////////////////
//
// Function			:	EncodeCertificateName()
//
// Date of Creation	:	21st Aug 2001
//
// Parameters		:	LPTSTR pszSubjectName,
//						BYTE **EncodedName,
//						PDWORD pEncodedNameLength
//
// Return			:	DWORD
//
// Description		:	This function encodes the certificate name  based on the user input.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
EncodeCertificateName (
		LPTSTR pszSubjectName,
		BYTE **EncodedName,
		PDWORD pdwEncodedNameLength
		)
{
    *pdwEncodedNameLength=0; DWORD dwReturn = ERROR_SUCCESS;

	if (!CertStrToName(	X509_ASN_ENCODING,
						pszSubjectName,
						CERT_X500_NAME_STR,
						NULL,
						NULL,
						pdwEncodedNameLength,
						NULL))
	{
		dwReturn = ERROR_INVALID_PARAMETER;
	}

	if(dwReturn == ERROR_SUCCESS)
	{
		(*EncodedName)= new BYTE[*pdwEncodedNameLength];
    	if(*EncodedName)
		{

    		if (!CertStrToName(	X509_ASN_ENCODING,
								pszSubjectName,
								CERT_X500_NAME_STR,
								NULL,
								(*EncodedName),
								pdwEncodedNameLength,
								NULL))
			{
    		    delete (*EncodedName);
    		    (*EncodedName) = 0;
    		    dwReturn = ERROR_INVALID_PARAMETER;
    		}
		}
		else
		{
			dwReturn = ERROR_OUTOFMEMORY;
		}
	}
    return dwReturn;
}


DWORD
GenerateKerbAuthInfo(
    OUT STA_MM_AUTH_METHODS** ppInfo
    )
{
	DWORD dwReturn = NO_ERROR;
	STA_MM_AUTH_METHODS* pInfo = new STA_MM_AUTH_METHODS;
	if (pInfo == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		BAIL_OUT;
	}
	ZeroMemory(pInfo, sizeof(STA_MM_AUTH_METHODS));

	pInfo->pAuthenticationInfo = new INT_IPSEC_MM_AUTH_INFO;
	if (pInfo->pAuthenticationInfo == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		BAIL_OUT;
	}
	ZeroMemory(pInfo->pAuthenticationInfo, sizeof(INT_IPSEC_MM_AUTH_INFO));

	// Indicate kerberos
	//
	pInfo->pAuthenticationInfo->AuthMethod = IKE_SSPI;

	*ppInfo = pInfo;

error:

	if (dwReturn != NO_ERROR)
	{
		if (pInfo)
		{
			if (pInfo->pAuthenticationInfo)
			{
				delete pInfo->pAuthenticationInfo;
			}
			delete pInfo;
		}
	}

	return dwReturn;
	}


DWORD
GeneratePskAuthInfo(
    OUT STA_MM_AUTH_METHODS** ppInfo,
    IN LPTSTR lpKey
    )
{
	DWORD dwReturn = NO_ERROR;
	size_t uiKeyLen = 0;
	STA_MM_AUTH_METHODS* pInfo = NULL;
	LPTSTR lpLocalKey;

	// Allocate the info struct
	//
	pInfo = new STA_MM_AUTH_METHODS;
	if (pInfo == NULL)
	{
	    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
	    BAIL_OUT;
	}
	ZeroMemory(pInfo, sizeof(STA_MM_AUTH_METHODS));
	pInfo->pAuthenticationInfo = new INT_IPSEC_MM_AUTH_INFO;
	if (pInfo->pAuthenticationInfo == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		BAIL_OUT;
	}
	ZeroMemory(pInfo->pAuthenticationInfo, sizeof(INT_IPSEC_MM_AUTH_INFO));

	dwReturn = NsuStringLen(lpKey, &uiKeyLen);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	lpLocalKey = new TCHAR[uiKeyLen];
	_tcsncpy(lpLocalKey, lpKey, uiKeyLen);

	// Indicate psk
	//
	pInfo->pAuthenticationInfo->AuthMethod= IKE_PRESHARED_KEY;
	pInfo->pAuthenticationInfo->pAuthInfo = (LPBYTE)lpLocalKey;
	pInfo->pAuthenticationInfo->dwAuthInfoSize = uiKeyLen * sizeof(WCHAR);

	*ppInfo = pInfo;

error:

	if (dwReturn != NO_ERROR)
	{
		if (pInfo)
		{
			if (pInfo->pAuthenticationInfo)
			{
				delete pInfo->pAuthenticationInfo;
			}
			delete pInfo;
		}
	}

	return dwReturn;
}


DWORD
GenerateRootcaAuthInfo(
    OUT STA_MM_AUTH_METHODS** ppInfo,
    IN LPTSTR lpRootcaInfo
    )
{
	DWORD dwReturn = NO_ERROR;
	DWORD dwStatus = NO_ERROR;
	size_t uiCertInfoLen = 0;
	BOOL bCertMapSpecified = FALSE;
	BOOL bCertMapping = FALSE;
	BOOL bCRPExclude = FALSE;
	STA_MM_AUTH_METHODS* pInfo = NULL;
	PINT_IPSEC_MM_AUTH_INFO  pMMAuthInfo = NULL;

	// Allocate the info struct
	//
	pInfo = new STA_MM_AUTH_METHODS;
	if (pInfo == NULL)
	{
	    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
	    BAIL_OUT;
	}
	ZeroMemory(pInfo, sizeof(STA_MM_AUTH_METHODS));

	if (_tcsicmp(lpRootcaInfo,_TEXT("\0")) != 0)
	{
		pMMAuthInfo = new INT_IPSEC_MM_AUTH_INFO;
		if(pMMAuthInfo == NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

		CheckForCertParamsAndRemove(lpRootcaInfo, &bCertMapSpecified, &bCertMapping, &bCRPExclude);

		dwStatus = StringToRootcaAuth(lpRootcaInfo,*(pMMAuthInfo));

		pInfo->bCertMappingSpecified 	= bCertMapSpecified;
		pInfo->bCertMapping			= bCertMapping;
		pInfo->bCRPExclude			= bCRPExclude;
		pInfo->pAuthenticationInfo		= pMMAuthInfo;
		pMMAuthInfo = NULL;

		if((dwStatus != T2P_OK) || (dwReturn != ERROR_SUCCESS) )
		{
			switch(dwStatus)
			{
			case ERROR_OUTOFMEMORY			:
				PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
				dwReturn = RETURN_NO_ERROR;
				break;
			default						:
				break;
			}
			PrintErrorMessage(IPSEC_ERR, 0, ERRCODE_ENCODE_FAILED);
			dwReturn  = RETURN_NO_ERROR;
			BAIL_OUT;
		}
	}

	*ppInfo = pInfo;
	pInfo = NULL;

error:

	if (pInfo)
	{
		if (pInfo->pAuthenticationInfo)
		{
			delete pInfo->pAuthenticationInfo;
		}
		delete pInfo;
	}
	if (pMMAuthInfo)
	{
		delete pMMAuthInfo;
	}

	return dwReturn;
}


//////////////////////////////////////////////////////////////////////////////
//
// Function			:	CheckForCertParamsAndRemove()
//
// Date of Creation	:	28th Jan 2002
//
// Parameters		:	IN 		szText					// Input String
//						OUT	    BOOL CertMapSpecified	// Certificate contains CertMap Option
//						OUT	    BOOL CertMap			// User Specified CertMap Option
//						OUT		BOOL CRPExclude		// User specified CRP option
//
// Return			:	DWORD
//						T2P_INVALID_AUTH_METHOD
//						T2P_NULL_STRING
//
// Description		:	This Function takes user input authentication cert string, validates
//						cert map and puts into Main mode auth info structure
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
MatchKeywordAndFillValues(
	const TCHAR * lptString,
	const TCHAR * lptKeyword,
	size_t uiKeyLen,
	PBOOL pbSpecified,
	PBOOL pbValue
	)
{
	const TCHAR TOKEN_YES [] = _TEXT("yes");
	const TCHAR TOKEN_NO [] = _TEXT("no");
	
	if ((_tcsnicmp(lptString, lptKeyword, uiKeyLen) == 0) && (lptString[uiKeyLen] == _TEXT(':')))
	{
		if (*pbSpecified)
		{
			return ERROR_TOKEN_ALREADY_IN_USE;
		}
		*pbSpecified = TRUE;
		if (_tcsnicmp((LPTSTR)(&lptString[uiKeyLen+1]), TOKEN_YES, sizeof(TOKEN_YES)/sizeof(TCHAR) - 1) == 0)
		{
			*pbValue = TRUE;
		}
		else if (_tcsnicmp((LPTSTR)(&lptString[uiKeyLen+1]), TOKEN_NO, sizeof(TOKEN_NO)/sizeof(TCHAR) - 1) == 0)
		{
			*pbValue = FALSE;
		}
		else
		{
			return ERROR_INVALID_PARAMETER;
		}
	}
	else
	{
		return ERROR_INVALID_DATA;
	}
	return ERROR_SUCCESS;
}


DWORD
CheckForCertParamsAndRemove(
		IN OUT		LPTSTR 	szText,
		OUT 		PBOOL 	pbCertMapSpecified,
		OUT 		PBOOL	pbCertMap,
		OUT			PBOOL	pbCRPExclude
		)
{
	DWORD dwReturn = ERROR_SUCCESS;

	*pbCertMapSpecified = FALSE;
	BOOL bCRPExcludeSpecified = FALSE;
	BOOL bIsMatch = TRUE;

	const TCHAR TOKEN_CERTMAP [] = _TEXT("certmap");
	const TCHAR TOKEN_CRP_EXCLUDE [] = _TEXT("excludecaname");

	// find end of string
	size_t uiStrLen = 0;
	dwReturn = NsuStringLen(szText, &uiStrLen);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
	LPTSTR szTextTemp = szText + uiStrLen - 1;

	while (bIsMatch && (!bCRPExcludeSpecified || !(*pbCertMapSpecified)))
	{
		// work back to last whitespace before last non-whitespace
		while ((*szTextTemp == _TEXT(' ')) || (*szTextTemp == _TEXT('\t')))
		{
			*szTextTemp = _TEXT('\0');
			--szTextTemp;
		}
		// we can't go past the start of the string, and in fact it is invalid if the cert string starts with a parameter,
		// so parse accordingly
		while ((szTextTemp > szText) && (*szTextTemp != _TEXT(' ')) && (*szTextTemp != _TEXT('\t')))
		{
			--szTextTemp;
		}
		if (szTextTemp == szText)
		{
			// we are at the start of the whole string, so there is no appropriate parameter portion or
			// the certmap is invalid... just return we didn't find anything and let cert parsing figure it out
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
		++szTextTemp;

		dwReturn = MatchKeywordAndFillValues(
			szTextTemp,
			TOKEN_CERTMAP,
			sizeof(TOKEN_CERTMAP)/sizeof(TCHAR) - 1,
			pbCertMapSpecified,
			pbCertMap
			);
		switch(dwReturn)
		{
		case ERROR_SUCCESS:
			break;

		case ERROR_INVALID_DATA:
			dwReturn = MatchKeywordAndFillValues(
				szTextTemp,
				TOKEN_CRP_EXCLUDE,
				sizeof(TOKEN_CRP_EXCLUDE)/sizeof(TCHAR) - 1,
				&bCRPExcludeSpecified,
				pbCRPExclude
				);
			switch (dwReturn)
			{
			case ERROR_INVALID_DATA:
				// we didn't match either parameter, so we're done
				bIsMatch = FALSE;
				dwReturn = ERROR_SUCCESS;
				break;

			case ERROR_SUCCESS:
				break;

			case ERROR_TOKEN_ALREADY_IN_USE:
			case ERROR_INVALID_PARAMETER:
			default:
				BAIL_OUT;
				break;
			}
			break;

		case ERROR_TOKEN_ALREADY_IN_USE:
		case ERROR_INVALID_PARAMETER:
		default:
			BAIL_OUT;
			break;
		}

		// chop the certmap portion if it existed... we already know we are not altering anything _before_
		// the start of the passed string because of the while loops above
		if (bIsMatch)
		{
			--szTextTemp;
			while ((szTextTemp > szText) && ((*szTextTemp == _TEXT(' ')) || (*szTextTemp == _TEXT('\t'))))
			{
				--szTextTemp;
			}
			++szTextTemp;
			*szTextTemp = _TEXT('\0');
		}
	}

error:
   return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////
//
// ProcessEscapedCharacters
//
// every occurrence of \' in the string is shortened to "
//
// Notes:
//    * this transformation occurs in place and the new string is properly
//      null-terminated
//    * it is not up to this routine to determine if number of quotes match,
//      only to properly place interpreted escaped characters where they
//      originally existed in the input string
//
// Return values:
//      ERR_INVALID_ARG
//      ERROR_SUCCESS
//
///////////////////////////////////////////////////////////////////////////////

DWORD ProcessEscapedCharacters(LPTSTR lptString)
{
	DWORD dwReturn = ERROR_SUCCESS;
	_TCHAR* src = lptString;
	_TCHAR* dst = lptString;

	while (*src != _TEXT('\0'))
	{
		switch(*src)
		{
		case _TEXT('\\'):
		// take proper action based on escaped character found
			++src;
			switch(*src)
			{
			case _TEXT('\''):
				*dst = _TEXT('\"');
				break;
			default:
				dwReturn = ERR_INVALID_ARG;
				BAIL_OUT;
				break;
			}
			break;
		default:
			// copy directly, keep processing
			*dst = *src;
			break;
		}
	++dst;
	++src;
	}

error:
	// null-terminate the string as-is, even if processing failed
	*dst = _TEXT('\0');

	return dwReturn;
}


VOID
AddAuthMethod(
	PRULEDATA pRuleData,
	PSTA_MM_AUTH_METHODS pMMAuth,
	size_t *pIndex
	)
{
	if (pMMAuth)
	{
		//Certificate to account mapping issue is taken care here
		if(pMMAuth->bCertMappingSpecified)
		{
			if((g_StorageLocation.dwLocation==IPSEC_REGISTRY_PROVIDER && IsDomainMember(g_StorageLocation.pszMachineName))||(g_StorageLocation.dwLocation==IPSEC_DIRECTORY_PROVIDER))
			{
				if(pMMAuth->bCertMapping)
				{
					pMMAuth->pAuthenticationInfo->dwAuthFlags|= IPSEC_MM_CERT_AUTH_ENABLE_ACCOUNT_MAP;
				}
				else
				{
					pMMAuth->pAuthenticationInfo->dwAuthFlags &= ~IPSEC_MM_CERT_AUTH_ENABLE_ACCOUNT_MAP;
				}
			}
			else
			{
				if(pMMAuth->bCertMapping)
				{
					PrintMessageFromModule(g_hModule,SET_STATIC_POLICY_INVALID_CERTMAP_MSG);
				}
			}
		}
		else
		{
			pMMAuth->pAuthenticationInfo->dwAuthFlags &= ~IPSEC_MM_CERT_AUTH_ENABLE_ACCOUNT_MAP;

		}
		if(pMMAuth->bCRPExclude)
		{
			pMMAuth->pAuthenticationInfo->dwAuthFlags |= IPSEC_MM_CERT_AUTH_DISABLE_CERT_REQUEST;
		}
		else
		{
			pMMAuth->pAuthenticationInfo->dwAuthFlags &= ~IPSEC_MM_CERT_AUTH_DISABLE_CERT_REQUEST;
		}

		pRuleData->AuthInfos.pAuthMethodInfo[*pIndex].pAuthenticationInfo = pMMAuth->pAuthenticationInfo;
		pMMAuth->pAuthenticationInfo = NULL;
		++(*pIndex);
	}
}


VOID
AddAuthMethod(
	PRULEDATA pRuleData,
	PSTA_AUTH_METHODS pAuthMethods,
	size_t *pIndex
	)
{
	if (pAuthMethods)
	{
		AddAuthMethod(pRuleData, pAuthMethods->pAuthMethodInfo, pIndex);
	}
}


DWORD
AddAllAuthMethods(
	PRULEDATA pRuleData,
	PSTA_AUTH_METHODS pKerbAuth,
	PSTA_AUTH_METHODS pPskAuth,
	PSTA_MM_AUTH_METHODS *ppRootcaMMAuth,
	BOOL bAddDefaults
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	PSTA_AUTH_METHODS paSingletons[2];
	size_t uiNumSingletons = 0;
	size_t uiNumRootca = 0;
	size_t uiNumAuthMethods = pRuleData->AuthInfos.dwNumAuthInfos;
	size_t uiRootIndex = 0;
	size_t uiSingletonIndex = 0;
	size_t uiNumAuths = 0;

	if (pRuleData->bAuthMethodSpecified)
	{
		pRuleData->dwAuthInfos = uiNumAuthMethods;
		pRuleData->AuthInfos.pAuthMethodInfo = new STA_MM_AUTH_METHODS[uiNumAuthMethods];
		if(pRuleData->AuthInfos.pAuthMethodInfo == NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

		paSingletons[0] = pKerbAuth;
		paSingletons[1] = pPskAuth;
		// swap if pKerbAuth doesn't exist, or if both exist and sequence is out of order
		if (!pKerbAuth || (pPskAuth && (pKerbAuth->pAuthMethodInfo->dwSequence > pPskAuth->pAuthMethodInfo->dwSequence)))
		{
			paSingletons[0] = pPskAuth;
			paSingletons[1] = pKerbAuth;
		}

		uiNumSingletons = (pKerbAuth ? 1 : 0);
		uiNumSingletons += (pPskAuth ? 1 : 0);
		uiNumRootca = uiNumAuthMethods - uiNumSingletons;

		while (uiSingletonIndex< uiNumSingletons)
		{
			while ((uiRootIndex < uiNumRootca) && (ppRootcaMMAuth[uiRootIndex]->dwSequence <= paSingletons[uiSingletonIndex]->pAuthMethodInfo->dwSequence))
			{
				AddAuthMethod(pRuleData, ppRootcaMMAuth[uiRootIndex], &uiNumAuths);
				++uiRootIndex;
			}
			AddAuthMethod(pRuleData, paSingletons[uiSingletonIndex], &uiNumAuths);
			++uiSingletonIndex;
		}
		while (uiRootIndex < uiNumRootca)
		{
			AddAuthMethod(pRuleData, ppRootcaMMAuth[uiRootIndex], &uiNumAuths);
			++uiRootIndex;
		}
	}
	else if (bAddDefaults)
	{
		DWORD dwLocation=IPSEC_REGISTRY_PROVIDER;
		LPTSTR pszMachineName=NULL;

		dwReturn = CopyStorageInfo(&pszMachineName,dwLocation);
		BAIL_ON_WIN32_ERROR(dwReturn);

		PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;

		if(dwLocation==IPSEC_REGISTRY_PROVIDER)
		{
			dwReturn=SmartDefaults(&pAuthenticationInfo, pszMachineName, &(pRuleData->dwAuthInfos), FALSE);
		}
		else
		{
			dwReturn=SmartDefaults(&pAuthenticationInfo, NULL, &(pRuleData->dwAuthInfos), TRUE);
		}

		if(dwReturn==ERROR_SUCCESS)
		{
			//this conversion is required to get the additional certmap info
			//for details , refer the following function
			dwReturn = ConvertMMAuthToStaticLocal(pAuthenticationInfo, pRuleData->dwAuthInfos, pRuleData->AuthInfos);
			pRuleData->AuthInfos.dwNumAuthInfos = pRuleData->dwAuthInfos;
		}

		if(pszMachineName)
		{
			delete [] pszMachineName;
		}
	}

error:
	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\parser_static.cpp ===
//////////////////////////////////////////////////////////////////////////////
// Module			:	parser_static.cpp
//
// Purpose			:	All Parser Implementation of Static Mode Commands
//
// Developers Name	:	N.Surendra Sai / Vunnam Kondal Rao
//
// History			:
//
// Date	    	Author    	Comments
//
//
//////////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern  HINSTANCE g_hModule;

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticAddPolicy()
//
// Date of Creation	:	24th oct 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN 		_TCHAR 		szListTok[MAX_STR_LEN],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS],
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the context StaticAddPolicy.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    		Author    		Comments
//
// 10/12/2001 	Kondal Rao 	Cert to account mapping function was added
//
//////////////////////////////////////////////////////////////////////////////
DWORD
ParseStaticAddPolicy(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed 	= 0;

	for(dwCount = 0; (dwCount < dwMaxArgs ) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_NAME				:
			case CMD_TOKEN_DESCR			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_MMPFS			:
			case CMD_TOKEN_ACTIVATEDEFRULE	:
			case CMD_TOKEN_ASSIGN			:
			case CMD_TOKEN_CERTTOMAP		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			case CMD_TOKEN_MMLIFETIME		:
			case CMD_TOKEN_PI				:
			case CMD_TOKEN_QMPERMM			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_DWORD);
				break;
			case CMD_TOKEN_MMSECMETHODS		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_MM_OFFER);
				break;
			default							:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
 	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticSetPolicy()
//
// Date of Creation	:	8th Aug 2001
//
// Parameters		:	IN      LPWSTR     *ppwcArguments,	// Input stream
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD dwCurrentIndex,
//						IN 		DWORD dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the context StaticSetPolicy.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticSetPolicy(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex = 0,dwUsed = 0;
	DWORD dwReturn  = ERROR_SUCCESS;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;		// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_GUID 		= 0;
	const DWORD ARG_NEWNAME 	= 1;
	const DWORD ARG_DESC	 	= 2;
	const DWORD ARG_MMPFS 		= 3;
	const DWORD ARG_QMPERMM 	= 4;
	const DWORD ARG_MMLIFE	 	= 5;
	const DWORD ARG_ACTDEFRULE	= 6;
	const DWORD ARG_POLL	 	= 7;
	const DWORD ARG_ASSIGN	 	= 8;
	const DWORD ARG_GPONAME		= 9;
	const DWORD ARG_CERTTOMAP	= 10;
	const DWORD ARG_MMSEC	 	= 11;

	const DWORD INDEX_NAME    	= 0;
	const DWORD INDEX_GUID 		= 1;
	const DWORD INDEX_NEWNAME 	= 2;
	const DWORD INDEX_DESC	 	= 3;
	const DWORD INDEX_MMPFS 	= 4;
	const DWORD INDEX_QMPERMM 	= 5;
	const DWORD INDEX_MMLIFE	= 6;
	const DWORD INDEX_ACTDEFRULE= 7;
	const DWORD INDEX_POLL	 	= 8;
	const DWORD INDEX_ASSIGN	= 9;
	const DWORD INDEX_GPONAME	= 10;
	const DWORD INDEX_CERTTOMAP	= 11;
	const DWORD INDEX_MMSEC	 	= 12;

	DBG_UNREFERENCED_LOCAL_VARIABLE(INDEX_GUID);

	if ( (dwMaxArgs - dwCurrentIndex) >= 13 )			// Max 12 Args
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}
	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)		// Initialize
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);		// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for = Parameter With Tag Found
		if (bTagPresent)
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
								dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
								bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_GUID		:
						if (!bArg[ARG_GUID])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_GUID] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEGUID);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_NEWNAME	:
						if (!bArg[ARG_NEWNAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NEWNAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DESCR	:
						if (!bArg[ARG_DESC])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_DESC] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_MMPFS	:
						if (!bArg[ARG_MMPFS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_MMPFS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_QMPERMM	:
						if (!bArg[ARG_QMPERMM])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_DWORD);
							bArg[ARG_QMPERMM] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_MMLIFETIME :
						if (!bArg[ARG_MMLIFE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_DWORD);
							bArg[ARG_MMLIFE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_ACTIVATEDEFRULE:
						if (!bArg[ARG_ACTDEFRULE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_ACTDEFRULE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_PI		:
						if (!bArg[ARG_POLL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_DWORD);
							bArg[ARG_POLL] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_ASSIGN	:
						if (!bArg[ARG_ASSIGN])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_ASSIGN] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_GPONAME	:
						if (!bArg[ARG_GPONAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_GPONAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_CERTTOMAP	:
						if (!bArg[ARG_CERTTOMAP])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_CERTTOMAP] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_MMSECMETHODS	:
						if (!bArg[ARG_MMSEC])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MM_OFFER);
							bArg[ARG_MMSEC] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_NAME			:
					if (!bArg[ARG_NAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
						bArg[ARG_NAME] = TRUE;
					}
					else
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEGUID);
						dwReturn = RETURN_NO_ERROR;
					}
					break;
				case ARG_NEWNAME		:
					if (!bArg[ARG_NEWNAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NEWNAME,TYPE_STRING);
						bArg[ARG_NEWNAME] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DESC			:
					if (!bArg[ARG_DESC])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_DESC,TYPE_STRING);
						bArg[ARG_DESC] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_MMPFS			:
					if (!bArg[ARG_MMPFS])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_MMPFS,TYPE_BOOL);
						bArg[ARG_MMPFS] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_QMPERMM		:
					if (!bArg[ARG_QMPERMM])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_QMPERMM,TYPE_DWORD);
						bArg[ARG_QMPERMM] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_MMLIFE			:
					if (!bArg[ARG_MMLIFE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_MMLIFE,TYPE_DWORD);
						bArg[ARG_MMLIFE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ACTDEFRULE		:
					if (!bArg[ARG_ACTDEFRULE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_ACTDEFRULE,TYPE_BOOL);
						bArg[ARG_ACTDEFRULE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_POLL			:
					if (!bArg[ARG_POLL])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_POLL,TYPE_DWORD);
						bArg[ARG_POLL] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ASSIGN			:
					if (!bArg[ARG_ASSIGN])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_ASSIGN,TYPE_BOOL);
						bArg[ARG_ASSIGN] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_GPONAME		:
					if (!bArg[ARG_GPONAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_GPONAME,TYPE_STRING);
						bArg[ARG_GPONAME] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_CERTTOMAP		:
					if (!bArg[ARG_CERTTOMAP])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_CERTTOMAP,TYPE_BOOL);
						bArg[ARG_CERTTOMAP] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_MMSEC			:
					if (!bArg[ARG_MMSEC])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_MMSEC,TYPE_MM_OFFER);
						bArg[ARG_MMSEC] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default					:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if (dwReturn == ERROR_SUCCESS)
	{
		if (!bArg[ARG_NAME] )
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NAME_GUID_NEEDED);
		}
		if (bArg[ARG_GPONAME] && !bArg[ARG_ASSIGN] )
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_GPONAME_ARG_NEEDED);
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticDelPolFlistFaction()
//
// Date of Creation	:	8th Aug 2001
//
// Parameters		:	IN      LPWSTR      *ppwcArguments,	// Input stream
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the context ParseStaticDelPolFlistFaction.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticDelPolFlistFaction(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex = 0,dwUsed = 0;
	DWORD dwReturn  = ERROR_SUCCESS;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;		// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ALL   		= 0;

	const DWORD INDEX_NAME 		= 0;		// When no tag is present the index reflects the
	const DWORD INDEX_ALL  		= 1;		// Commands as in the ValidToken Structure

	if ( (dwMaxArgs - dwCurrentIndex) >= 2 )		// Max 1 Args Allowed
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount =0;dwCount < MAX_ARGS;dwCount++)	// Initialize
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);	// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)							  // Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default				:
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_INDEX);
						dwReturn = ERROR_SHOW_USAGE;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		} else // Parameter Without a Tag Found
		{
			for(dwTagIndex=0;dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE);dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL	:
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
					}
					break;
				 default 	:
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_INDEX);
					dwReturn = ERROR_SHOW_USAGE;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
		dwReturn = RETURN_NO_ERROR;
	}
	else if( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME]) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,pParser->ValidTok[dwIndex].pwszToken);
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticAddFilterList()
//
// Date of Creation	:	24th Aug 2001
//
// Parameters		:	IN 		lppwszTok[MAX_ARGS],
//						IN 		szListTok[MAX_STR_LEN],
//						IN OUT 	pParser,
//						IN 		dwCurrentIndex,
//						IN 		dwMaxArgs,
//						IN 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticAddFilterList context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticAddFilterList(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN 		_TCHAR 		szListTok[MAX_STR_LEN],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS,dwCount,dwUsed = 0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_NAME			:
			case CMD_TOKEN_DESCR		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			default						:
				dwReturn = ERROR_CMD_NOT_FOUND;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticSetFilterList()
//
// Date of Creation	:	24th Aug 2001
//
// Parameters		:	IN      LPTSTR     *ppwcArguments,	// Input stream
//						IN OUT 	PARSER_PKT *pParser,
//						IN 		DWORD dwCurrentIndex,
//						IN 		DWORD dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticSetFilterList context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticSetFilterList(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex 	 = 0,dwUsed = 0;
	DWORD dwReturn  = ERROR_SUCCESS;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};
	const DWORD ARG_NAME    	= 0;		// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_GUID 		= 0;
	const DWORD ARG_NEWNAME 	= 1;
	const DWORD ARG_DESC	 	= 2;

	const DWORD INDEX_NAME    	= 0;
	const DWORD INDEX_GUID 		= 1;
	const DWORD INDEX_NEWNAME 	= 2;
	const DWORD INDEX_DESC	 	= 3;

	DBG_UNREFERENCED_LOCAL_VARIABLE(INDEX_GUID);

	if ( (dwMaxArgs - dwCurrentIndex) >= 4 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount =0;dwCount < MAX_ARGS;dwCount++)
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)									// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)										// Convert the output of MatchEnumTag into the TagIndex
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
								dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
								bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEGUID);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_GUID		:
						if (!bArg[ARG_GUID])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_GUID] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEGUID);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_NEWNAME	:
						if (!bArg[ARG_NEWNAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NEWNAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DESCR	:
						if (!bArg[ARG_DESC])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_DESC] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default 				:
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_INDEX);
						dwReturn = ERROR_SHOW_USAGE;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_NAME			:
					if (!bArg[ARG_NAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
						bArg[ARG_NAME] = TRUE;
					}
					else
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEGUID);
						dwReturn = RETURN_NO_ERROR;
					}
					break;
				case ARG_NEWNAME		:
					if (!bArg[ARG_NEWNAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NEWNAME,TYPE_STRING);
						bArg[ARG_NEWNAME] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DESC			:
					if (!bArg[ARG_DESC])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_DESC,TYPE_STRING);
						bArg[ARG_DESC] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default 				:
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_INDEX);
					dwReturn = ERROR_SHOW_USAGE;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME]) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,pParser->ValidTok[INDEX_NAME].pwszToken);
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticAddFilter()
//
// Date of Creation	:	22nd Aug 2001
//
// Parameters		:	IN 		LPTSTR		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticAddFilter context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticAddFilter(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn	= ERROR_SUCCESS ;
	DWORD dwCount,dwUsed   = 0;

	for(dwCount = 0;( dwCount < dwMaxArgs ) && ( dwReturn == ERROR_SUCCESS );dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_DESCR		:
			case CMD_TOKEN_FILTERLIST	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_SRCMASK		:
		 	case CMD_TOKEN_DSTMASK		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_MASK);
				break;
		 	case CMD_TOKEN_SRCADDR		:
			case CMD_TOKEN_DSTADDR		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_DNSIP);
				break;
 			case CMD_TOKEN_SRCPORT		:
			case CMD_TOKEN_DSTPORT		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PORT);
				break;
			case CMD_TOKEN_PROTO 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PROTOCOL);
 				break;
			case CMD_TOKEN_MIRROR 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			default						:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticDelFilter()
//
// Date of Creation	:	22nd Aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticDelFilter context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticDelFilter(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn	= ERROR_SUCCESS;
	DWORD dwCount, dwUsed   = 0;

	for(dwCount = 0;( dwCount < dwMaxArgs ) && ( dwReturn == ERROR_SUCCESS );dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_FILTERLIST	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_SRCMASK		:
		 	case CMD_TOKEN_DSTMASK		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_MASK);
				break;
			case CMD_TOKEN_SRCADDR		:
			case CMD_TOKEN_DSTADDR		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_DNSIP);
				break;
 			case CMD_TOKEN_SRCPORT		:
			case CMD_TOKEN_DSTPORT		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PORT);
				break;
			case CMD_TOKEN_PROTO 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PROTOCOL);
				 break;
			case CMD_TOKEN_MIRROR 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			default						:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticAddFilterAction()
//
// Date of Creation	:	25th Aug 2001
//
// Parameters		:	IN 		lppwszTok[MAX_ARGS],
//						IN 		szListTok[MAX_STR_LEN],
//						IN OUT 	pParser,
//						IN 		dwCurrentIndex,
//						IN 		dwMaxArgs,
//						IN 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticAddFilterAction context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticAddFilterAction(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwCount  ,dwUsed 	= 0;

	BOOL  bQMSECSpecified = FALSE;

	for(dwCount = 0;( dwCount < dwMaxArgs ) && ( dwReturn == ERROR_SUCCESS );dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_NAME			:
			case CMD_TOKEN_DESCR		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_QMPFS 		:
			case CMD_TOKEN_INPASS		:
			case CMD_TOKEN_SOFT			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			case CMD_TOKEN_ACTION		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOUND);
				break;
			case CMD_TOKEN_QMSECMETHODS :
				bQMSECSpecified = TRUE;
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_QM_OFFER);
				break;
			default						:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticSetFilterAction()
//
// Date of Creation	:	25th Aug 2001
//
// Parameters		:	IN      LPTSTR      *ppwcArguments,	// Input stream
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticSetFilterAction context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticSetFilterAction(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex = 0,dwUsed = 0;
	DWORD dwReturn  = ERROR_SUCCESS;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;					// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_GUID 		= 0;
	const DWORD ARG_NEWNAME 	= 1;
	const DWORD ARG_DESC	 	= 2;
	const DWORD ARG_QMPFS 		= 3;
	const DWORD ARG_INPASS	 	= 4;
	const DWORD ARG_SOFT	 	= 5;
	const DWORD ARG_ACTION		= 6;
	const DWORD ARG_QMSEC	 	= 7;

	const DWORD INDEX_NAME    	= 0;
	const DWORD INDEX_GUID 		= 1;
	const DWORD INDEX_NEWNAME 	= 2;
	const DWORD INDEX_DESC	 	= 3;
	const DWORD INDEX_QMPFS 	= 4;
	const DWORD INDEX_INPASS 	= 5;
	const DWORD INDEX_SOFT		= 6;
	const DWORD INDEX_ACTION	= 7;
	const DWORD INDEX_QMSEC	 	= 8;

	DBG_UNREFERENCED_LOCAL_VARIABLE(INDEX_GUID);

	if ( (dwMaxArgs - dwCurrentIndex) >= 9 )			// Max Args
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}
	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)		// Initialize
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;( dwCount < dwMaxArgs ) && ( dwReturn == ERROR_SUCCESS );dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);		// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)								// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
								dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
								bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEGUID);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_GUID		:
						if (!bArg[ARG_GUID])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_GUID] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEGUID);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_NEWNAME	:
						if (!bArg[ARG_NEWNAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NEWNAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DESCR	:
						if (!bArg[ARG_DESC])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_DESC] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_QMPFS	:
						if (!bArg[ARG_QMPFS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_QMPFS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_INPASS	:
						if (!bArg[ARG_INPASS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_INPASS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_SOFT		 :
						if (!bArg[ARG_SOFT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_SOFT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_ACTION	:
						if (!bArg[ARG_ACTION])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOUND);
							bArg[ARG_ACTION] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_QMSECMETHODS	:
						if (!bArg[ARG_QMSEC])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_QM_OFFER);
							bArg[ARG_QMSEC] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		} else			// Parameter Without a Tag Found
		{				// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{

				case ARG_NAME			:
					if (!bArg[ARG_NAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
						bArg[ARG_NAME] = TRUE;
					}
					else
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEGUID);
						dwReturn = RETURN_NO_ERROR;
					}
					break;
				case ARG_NEWNAME		:
					if (!bArg[ARG_NEWNAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NEWNAME,TYPE_STRING);
						bArg[ARG_NEWNAME] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DESC			:
					if (!bArg[ARG_DESC])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_DESC,TYPE_STRING);
						bArg[ARG_DESC] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_QMPFS			:
					if (!bArg[ARG_QMPFS])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_QMPFS,TYPE_BOOL);
						bArg[ARG_QMPFS] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_INPASS			:
					if (!bArg[ARG_INPASS])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_INPASS,TYPE_BOOL);
						bArg[ARG_INPASS] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_SOFT			:
					if (!bArg[ARG_SOFT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_SOFT,TYPE_BOOL);
						bArg[ARG_SOFT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ACTION			:
					if (!bArg[ARG_ACTION])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_ACTION,TYPE_BOUND);
						bArg[ARG_ACTION] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_QMSEC			:
					if (!bArg[ARG_QMSEC])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_QMSEC,TYPE_QM_OFFER);
						bArg[ARG_QMSEC] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default					:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if (dwReturn == ERROR_SUCCESS)
	{
		if (!bArg[ARG_NAME] )
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,pParser->ValidTok[INDEX_NAME].pwszToken);
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticAddRule()
//
// Date of Creation	:	25th Aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN 		_TCHAR 		szListTok[MAX_STR_LEN],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticAddRule context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticAddRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD dwCount,dwUsed  = 0;

	for(dwCount = 0;(dwCount < dwMaxArgs ) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_NAME			:
			case CMD_TOKEN_POLICY 		:
			case CMD_TOKEN_DESCR		:
  	              case CMD_TOKEN_FILTERLIST 	:
 			case CMD_TOKEN_FILTERACTION	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_TUNNEL 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_IP);
 				break;
			case CMD_TOKEN_CONNTYPE 	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_CONNTYPE);
				break;
			case CMD_TOKEN_ACTIVATE 	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
	            case CMD_TOKEN_KERB             :
	                dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_KERBAUTH);
	                break;
	            case CMD_TOKEN_PSK              :
	                dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PSKAUTH);
	                break;
			default						:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticDelRule()
//
// Date of Creation	:	7th Aug 2001
//
// Parameters		:	IN      LPTSTR     	*ppwcArguments,
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticDelRule context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticDelRule(
		IN      LPTSTR     *ppwcArguments,
		IN OUT 	PARSER_PKT *pParser,
		IN 		DWORD dwCurrentIndex,
		IN 		DWORD dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex = 0,dwReturn  = ERROR_SUCCESS,dwUsed 	= 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ID 			= 0;
	const DWORD ARG_ALL			= 0;
	const DWORD ARG_POLICY 		= 1;

	const DWORD INDEX_NAME		= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ID 		= 1;	// Commands as in the ValidToken Structure
	const DWORD INDEX_ALL		= 2;	// This define is used to indicate the ARG correspondence
	const DWORD INDEX_POLICY	= 3;	// with the 'untagged' arg

	DBG_UNREFERENCED_LOCAL_VARIABLE(INDEX_ID);

	if ( (dwMaxArgs - dwCurrentIndex) != 2 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}
	for(dwCount =0;dwCount < MAX_ARGS;dwCount++)			// Initialize
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs ) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)									// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_POLICY	:
						if (!bArg[ARG_POLICY])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_POLICY] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEIDALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_ID		:
						if (!bArg[ARG_ID])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_DWORD);
							bArg[ARG_ID] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEIDALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEIDALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_POLICY	:
					if (!bArg[ARG_POLICY])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_POLICY,TYPE_STRING);
						bArg[ARG_POLICY] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ALL  	:
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEIDALL);
							dwReturn = RETURN_NO_ERROR;
						}
					}
					break;
				default 		:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if (dwReturn == ERROR_SUCCESS)
	{
		if (!bArg[ARG_POLICY] )
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,pParser->ValidTok[INDEX_POLICY].pwszToken);
		}
		if (!bArg[ARG_NAME] )
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMEIDALL);
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticSetDefaultRule()
//
// Date of Creation	:	7th Aug 2001
//
// Parameters		:	IN		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN 		LPTSTR 		ppwcListTok[MAX_ARGS],
//				 		IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS],
//						IN      DWORD		dwListArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticSetDefaultRule context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticSetDefaultRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
 		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn	= ERROR_SUCCESS,dwCount	= 0,dwUsed 	= 0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_POLICY			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			case CMD_TOKEN_QMPFS			:
			case CMD_TOKEN_ACTIVATE			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			case CMD_TOKEN_QMSECMETHODS		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_QM_OFFER);
				break;
	            case CMD_TOKEN_KERB             :
	                dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_KERBAUTH);
	                break;
	            case CMD_TOKEN_PSK              :
	                dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_PSKAUTH);
	                break;
			default							:
				dwReturn = ERROR_INVALID_SYNTAX;
				break;
		}
	}

	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticSetStore()
//
// Date of Creation	:	7th Aug 2001
//
// Parameters		:	IN 		ppwcArguments
//						IN OUT	pParser
//						IN 		dwCurrentIndex,
//						IN 		dwMaxArgs,
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticSetStore context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticSetStore(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwIndex 	 = 0,dwReturn  = ERROR_SUCCESS,dwUsed 	= 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_MACHINE    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_MLOCAL 		= 0;
	const DWORD ARG_DS   		= 1;
	const DWORD ARG_DSLOCAL		= 1;

											// When no tag is present the index reflects
	const DWORD INDEX_MLOCAL	= 0;    	// the command slot
											// Commands as in the ValidToken Structure
	const DWORD INDEX_DSLOCAL	= 1;		// This define is used to indicate the ARG correspondence

	if ( (dwMaxArgs - dwCurrentIndex) > 2 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}
	for(dwCount =0;dwCount < MAX_ARGS;dwCount++)		// Initialize
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);		// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)								// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)									// Convert the output of MatchEnumTag into the TagIndex
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_LOCATION	:
						if(!bArg[ARG_MACHINE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_LOCATION);
							bArg[ARG_MACHINE] = TRUE;
						}
						else
						{
							dwReturn  = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DS		:
						if(!bArg[ARG_DS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_DS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 											// Parameter Without a Tag Found
		{
		    // Find the first free position in which to place the untagged 
		    // argument
		    //
		    if (!bArg[ARG_MACHINE])
		    {
				dwReturn = LoadParserOutput(
				                pParser,
				                dwCount-dwCurrentIndex,
				                &dwUsed,
				                szTok,
				                INDEX_MLOCAL,
				                TYPE_LOCATION);
				bArg[ARG_MACHINE] = TRUE;
		    }
		    else if (!bArg[ARG_DS])
		    {
				dwReturn = LoadParserOutput(
				                pParser,
				                dwCount-dwCurrentIndex,
				                &dwUsed,
				                szTok,
				                INDEX_DSLOCAL,
				                TYPE_STRING);
				bArg[ARG_DS] = TRUE;
		    }
		    else
		    {
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
		    }
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticExportPolicy()
//
// Date of Creation	:	7th Aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD		dwCurrentIndex,
//						IN 		DWORD		dwMaxArgs,
//						IN 		DWORD		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticExportPolicy context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticExportPolicy(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs,
		IN 		DWORD		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn	= ERROR_SUCCESS ,dwCount  ,dwUsed   = 0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_FILE		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_EXPORT);
				break;
			default					:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
 	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticImportPolicy()
//
// Date of Creation	:	7th Aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD		dwCurrentIndex,
//						IN 		DWORD		dwMaxArgs,
//						IN 		DWORD		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticImportPolicy context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticImportPolicy(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PARSER_PKT  *pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs,
		IN 		DWORD		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn	= ERROR_SUCCESS ,dwCount  ,dwUsed   = 0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_FILE	:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_STRING);
				break;
			default				:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
 	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticSetInteractive()
//
// Date of Creation	:	24th Aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD		dwCurrentIndex,
//						IN 		DWORD		dwMaxArgs,
//						IN 		DWORD		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticSetInteractive context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticSetInteractive(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs,
		IN 		DWORD		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn = ERROR_SUCCESS ,dwCount,dwUsed = 0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_MODE			:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			default				:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
 	return dwReturn;
}
//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticShowFilterList()
//
// Date of Creation	:	24th Aug 2001
//
// Parameters		:	IN      LPWSTR      *ppwcArguments,
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticShowFilteList context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticShowFilterList(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex 	 = 0,dwUsed	= 0;
	DWORD dwReturn  = ERROR_SUCCESS;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ALL   		= 0;
	const DWORD ARG_RULE 		= 0;
	const DWORD ARG_VERBOSE 	= 1;
	const DWORD ARG_FORMAT	 	= 2;
	const DWORD ARG_DNS			= 3;
	const DWORD ARG_WIDE		= 4;

	const DWORD INDEX_NAME 		= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ALL  		= 1;	// Commands as in the ValidToken Structure
	const DWORD INDEX_RULE		= 2;	// This define is used to indicate the ARG correspondence
	const DWORD INDEX_VERBOSE 	= 3;	// with the 'untagged' arg
	const DWORD INDEX_FORMAT	= 4;
	const DWORD INDEX_DNS		= 5;
	const DWORD INDEX_WIDE		= 6;

	DBG_UNREFERENCED_LOCAL_VARIABLE(INDEX_RULE);

	if ( (dwMaxArgs - dwCurrentIndex) >= 6 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)			// Initialize
	{
		bArg[dwCount] = FALSE;
	}

	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)									// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_RULE 	:
						if (!bArg[ARG_RULE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_RULE] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_VERBOSE	:
						if (!bArg[ARG_VERBOSE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_VERBOSE);
							bArg[ARG_VERBOSE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_FORMAT	:
						if (!bArg[ARG_FORMAT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_FORMAT);
							bArg[ARG_FORMAT] = TRUE;
						}else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_RESDNS	:
						if (!bArg[ARG_DNS])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_DNS] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_WIDE	:
						if (!bArg[ARG_WIDE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_WIDE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL		  :
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
					}
					break;
				case ARG_VERBOSE 		:
					if (!bArg[ARG_VERBOSE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_VERBOSE,TYPE_VERBOSE);
						bArg[ARG_VERBOSE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_FORMAT 		:
					if (!bArg[ARG_FORMAT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_FORMAT,TYPE_FORMAT);
						bArg[ARG_FORMAT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				 case ARG_DNS			:
					if (!bArg[ARG_DNS])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_DNS,TYPE_BOOL);
						bArg[ARG_DNS] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				 case ARG_WIDE			:
					if (!bArg[ARG_WIDE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_WIDE,TYPE_BOOL);
						bArg[ARG_WIDE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default 				:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME]) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMERULEALL);
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticShowRule()
//
// Date of Creation	:	24th Aug 2001
//
// Parameters		:	IN      LPWSTR      *ppwcArguments,
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticShowRule context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticShowRule(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex 	 = 0,dwReturn  = ERROR_SUCCESS,dwUsed 	= 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];
	BOOL bDefaultRule = FALSE;

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
 	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ID   		= 0;
	const DWORD ARG_ALL   		= 0;
	const DWORD ARG_DEFAULT		= 0;
	const DWORD ARG_POLICY 		= 1;
	const DWORD ARG_MODE 		= 2;
	const DWORD ARG_VERBOSE 	= 3;
	const DWORD ARG_FORMAT	 	= 4;
	const DWORD ARG_WIDE		= 5;

	const DWORD INDEX_NAME 		= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ID 		= 1;
	const DWORD INDEX_ALL  		= 2;	// Commands as in the ValidToken Structure
	const DWORD INDEX_DEFAULT	= 3;
	const DWORD INDEX_POLICY	= 4;	// This define is used to indicate the ARG correspondence
	const DWORD INDEX_MODE	 	= 5;
	const DWORD INDEX_VERBOSE 	= 6;	// with the 'untagged' arg
	const DWORD INDEX_FORMAT 	= 7;
	const DWORD INDEX_WIDE	 	= 8;

	DBG_UNREFERENCED_LOCAL_VARIABLE(INDEX_ID);
	if ( (dwMaxArgs - dwCurrentIndex) >= 7 )	// Max Arg allowed in this context
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)			// Initialize
	{
		bArg[dwCount] = FALSE;
	}

	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)									// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_ID		:
						if (!bArg[ARG_ID])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_DWORD);
							bArg[ARG_ID] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_DEFRESPONSE	:
							dwReturn = ERROR_SHOW_USAGE;
						break;
					case CMD_TOKEN_POLICY 	:
						if (!bArg[ARG_POLICY])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_POLICY] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_TYPE	:
						if (!bArg[ARG_MODE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_MODE);
							bArg[ARG_MODE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_VERBOSE	:
						if (!bArg[ARG_VERBOSE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_VERBOSE);
							bArg[ARG_VERBOSE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_FORMAT	:
						if (!bArg[ARG_FORMAT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_FORMAT);
							bArg[ARG_FORMAT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_WIDE	:
						if (!bArg[ARG_WIDE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_WIDE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 			// Parameter Without a Tag Found
		{				// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL	:
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else if (_tcsicmp(szTok,DEFAULT_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,YES_STR,INDEX_DEFAULT,TYPE_ALL);
						bArg[ARG_DEFAULT] = TRUE;
						bDefaultRule  = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
					}
					break;
				case ARG_POLICY		:
					if (!bArg[ARG_POLICY])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_POLICY,TYPE_STRING);
						bArg[ARG_POLICY] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_MODE		:
					if (!bArg[ARG_MODE] )
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_MODE,TYPE_MODE);
						bArg[ARG_MODE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_VERBOSE	:
					if (!bArg[ARG_VERBOSE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_VERBOSE,TYPE_VERBOSE);
						bArg[ARG_VERBOSE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_FORMAT		:
					if (!bArg[ARG_FORMAT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_FORMAT,TYPE_FORMAT);
						bArg[ARG_FORMAT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_WIDE		:
					if (!bArg[ARG_WIDE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_WIDE,TYPE_BOOL);
						bArg[ARG_WIDE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default				:
					dwReturn = ERROR_SHOW_USAGE;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if (dwReturn == ERROR_SUCCESS)
	{
		if ( (!bArg[ARG_ALL]) && (bArg[ARG_MODE]))
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,pParser->ValidTok[INDEX_ALL].pwszToken);
		}
		else if (!bArg[ARG_NAME] )
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMEIDALL);
		}
		if (!bArg[ARG_POLICY] )
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,pParser->ValidTok[INDEX_POLICY].pwszToken);
		}

		if ( (bArg[ARG_MODE]) && bDefaultRule)
		{
			dwReturn = RETURN_NO_ERROR;
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,pParser->ValidTok[INDEX_ALL].pwszToken);
		}
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticShowPolicy()
//
// Date of Creation	:	25th Aug 2001
//
// Parameters		:	IN      LPWSTR      *ppwcArguments,
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticShowPolicy context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticShowPolicy(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex = 0,dwReturn  = ERROR_SUCCESS,dwUsed = 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ALL   		= 0;
	const DWORD ARG_VERBOSE 	= 1;
	const DWORD ARG_FORMAT	 	= 2;
	const DWORD ARG_WIDE	 	= 3;

	const DWORD INDEX_NAME 		= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ALL  		= 1;	// Commands as in the ValidToken Structure
	const DWORD INDEX_VERBOSE 	= 2;	// This define is used to indicate the ARG correspondence
	const DWORD INDEX_FORMAT	= 3;	// with the 'untagged' arg
	const DWORD INDEX_WIDE		= 4;

	if ( (dwMaxArgs - dwCurrentIndex) >= 5 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount = 0; dwCount < MAX_ARGS;dwCount++)			// Initialize
	{
		bArg[dwCount] = FALSE;
	}
	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn  == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)									// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					 case CMD_TOKEN_VERBOSE	:
						if (!bArg[ARG_VERBOSE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_VERBOSE);
							bArg[ARG_VERBOSE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_FORMAT	:
						if (!bArg[ARG_FORMAT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_FORMAT);
							bArg[ARG_FORMAT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_WIDE	:
						if (!bArg[ARG_WIDE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_WIDE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 default				:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 			// Parameter Without a Tag Found
		{				// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL		:
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEALL);
							dwReturn = RETURN_NO_ERROR;
						}
					}
					break;
				case ARG_VERBOSE	:
					if (!bArg[ARG_VERBOSE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_VERBOSE,TYPE_VERBOSE);
						bArg[ARG_VERBOSE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_FORMAT		:
					if (!bArg[ARG_FORMAT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_FORMAT,TYPE_FORMAT);
						bArg[ARG_FORMAT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				 case ARG_WIDE		:
					if (!bArg[ARG_WIDE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_WIDE,TYPE_BOOL);
						bArg[ARG_WIDE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default 		:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME]) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMEALL);
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseShowAll()
//
// Date of Creation	:	24th Aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the ParseShowAll context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD ParseStaticAll(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT	pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs,
		IN 		DWORD		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn	= ERROR_SUCCESS,dwCount,dwUsed=0;

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_FORMAT 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_FORMAT);
				break;
			case CMD_TOKEN_WIDE 		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_BOOL);
				break;
			default						:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticShowAssignedPolicy()
//
// Date of Creation	:	29th Aug 2001
//
// Parameters		:	IN      LPTSTR      *ppwcArguments,
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticShowAssignedPolicy context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD ParseStaticShowAssignedPolicy(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex 	 = 0,dwReturn  = ERROR_SUCCESS,dwUsed 	= 0;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_VERBOSE 	= 1;

	const DWORD INDEX_NAME		= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_VERBOSE 	= 1;	// This define is used to indicate the ARG correspondence

	if ( (dwMaxArgs - dwCurrentIndex) >= 3)
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)			// Initialize
	{
		bArg[dwCount] = FALSE;
	}

	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)									// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_VERBOSE	:
						if (!bArg[ARG_VERBOSE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_VERBOSE);
							bArg[ARG_VERBOSE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default				:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else			// Parameter Without a Tag Found
		{				// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_NAME		:
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAME);
							dwReturn = RETURN_NO_ERROR;
						}
					}
					break;
				case ARG_VERBOSE :
					if (!bArg[ARG_VERBOSE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_VERBOSE,TYPE_VERBOSE);
						bArg[ARG_VERBOSE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default				:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticRestoreDefaults()
//
// Date of Creation	:	7th Aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT	pParser,
//						IN 		DWORD		dwCurrentIndex,
//						IN 		DWORD		dwMaxArgs,
//						IN 		DWORD		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticRestoreDefaults context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticRestoreDefaults(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD		dwCurrentIndex,
		IN 		DWORD		dwMaxArgs,
		IN 		DWORD		dwTagType[MAX_ARGS]
		)
{
	DWORD dwReturn	= ERROR_SUCCESS ;
	DWORD dwCount,dwUsed   = 0;

	for(dwCount = 0;( dwCount < dwMaxArgs ) && ( dwReturn == ERROR_SUCCESS );dwCount++)
	{
		switch(pParser->ValidTok[dwTagType[dwCount]].dwValue)
		{
			case CMD_TOKEN_RELEASE		:
				dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,lppwszTok[dwCount],dwTagType[dwCount],TYPE_RELEASE);
				break;
			default						:
				dwReturn = ERROR_SHOW_USAGE;
				break;
		}
	}
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticSetRule()
//
// Date of Creation	:	7th Aug 2001
//
// Parameters		:	IN 		LPTSTR 		lppwszTok[MAX_ARGS],
//						IN 		LPTSTR 		ppwcListTok[MAX_ARGS],
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs,
//						IN 		DWORD 		dwListArgs,
//						IN 		DWORD 		dwTagType[MAX_ARGS]
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticSetRule context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD ParseStaticSetRule(
		IN 		LPTSTR 		lppwszTok[MAX_ARGS],
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs,
		IN 		DWORD 		dwTagType[MAX_ARGS]
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex = 0,dwUsed = 0;
	DWORD dwReturn  = ERROR_SUCCESS;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;		// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ID	 		= 0;
	const DWORD ARG_POLICY		= 1;
	const DWORD ARG_NEWNAME 	= 2;
	const DWORD ARG_DESC	 	= 3;
	const DWORD ARG_FLIST	 	= 4;
	const DWORD ARG_FACTION		= 5;
	const DWORD ARG_TUNNEL 		= 6;
	const DWORD ARG_CONNTYPE	= 7;
	const DWORD ARG_ACTIVATE 	= 8;
	const DWORD ARG_KERBAUTH = 9;
	const DWORD ARG_PSKAUTH = 10;

	const DWORD INDEX_NAME    	= 0;
	const DWORD INDEX_ID 		= 1;
	const DWORD INDEX_POLICY 	= 2;
	const DWORD INDEX_NEWNAME 	= 3;
	const DWORD INDEX_DESC		= 4;
	const DWORD INDEX_FLIST 	= 5;
	const DWORD INDEX_FACTION 	= 6;
	const DWORD INDEX_TUNNEL	= 7;
	const DWORD INDEX_CONNTYPE	= 8;
	const DWORD INDEX_ACTIVATE 	= 9;
	const DWORD INDEX_KERBAUTH = 10;
	const DWORD INDEX_PSKAUTH = 11;

	DBG_UNREFERENCED_LOCAL_VARIABLE(INDEX_ID);
	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)		// Initialize
	{
		bArg[dwCount] = FALSE;
	}

	for(dwCount = 0;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(lppwszTok[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,lppwszTok[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)								// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{
				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
								dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_STRING);
								bArg[ARG_NAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_ID		:
						if (!bArg[ARG_ID])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_DWORD);
							bArg[ARG_ID] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEID);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_POLICY	:
						if (!bArg[ARG_POLICY])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_POLICY] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_NEWNAME	:
						if (!bArg[ARG_NEWNAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NEWNAME] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_DESCR	:
						if (!bArg[ARG_DESC])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_DESC] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;

					case CMD_TOKEN_FILTERLIST	:
						if (!bArg[ARG_FLIST])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_FLIST] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_FILTERACTION	:
						if (!bArg[ARG_FACTION])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_FACTION] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_TUNNEL :
						if (!bArg[ARG_TUNNEL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_TUNNEL);
							bArg[ARG_TUNNEL] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_CONNTYPE:
						if (!bArg[ARG_CONNTYPE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_CONNTYPE);
							bArg[ARG_CONNTYPE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_ACTIVATE	:
						if (!bArg[ARG_ACTIVATE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_ACTIVATE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_KERB             :
						if (!bArg[ARG_KERBAUTH])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_KERBAUTH);
							bArg[ARG_KERBAUTH] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					case CMD_TOKEN_PSK              :
						if (!bArg[ARG_PSKAUTH])
						{
							dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,dwIndex,TYPE_PSKAUTH);
							bArg[ARG_PSKAUTH] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_NAME			:
					if (!bArg[ARG_NAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
						bArg[ARG_NAME] = TRUE;
					}
					else
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMEID);
						dwReturn = RETURN_NO_ERROR;
					}
					break;
				case ARG_POLICY		:
					if (!bArg[ARG_POLICY])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_POLICY,TYPE_STRING);
						bArg[ARG_POLICY] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_NEWNAME	:
					if (!bArg[ARG_NEWNAME])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_NEWNAME,TYPE_STRING);
						bArg[ARG_NEWNAME] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_DESC	:
					if (!bArg[ARG_DESC])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_DESC,TYPE_STRING);
						bArg[ARG_DESC] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_FLIST		:
					if (!bArg[ARG_FLIST])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_FLIST,TYPE_STRING);
						bArg[ARG_FLIST] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_FACTION	:
					if (!bArg[ARG_FACTION])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_FACTION,TYPE_STRING);
						bArg[ARG_FACTION] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_TUNNEL			:
					if (!bArg[ARG_TUNNEL])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_TUNNEL,TYPE_TUNNEL);
						bArg[ARG_TUNNEL] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_ACTIVATE		:
					if (!bArg[ARG_ACTIVATE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_ACTIVATE,TYPE_BOOL);
						bArg[ARG_ACTIVATE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_CONNTYPE		:
					if (!bArg[ARG_CONNTYPE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_CONNTYPE,TYPE_CONNTYPE);
						bArg[ARG_CONNTYPE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_KERBAUTH:
					if (!bArg[ARG_KERBAUTH])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_KERBAUTH,TYPE_KERBAUTH);
						bArg[ARG_KERBAUTH] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_PSKAUTH:
					if (!bArg[ARG_PSKAUTH])
					{
						dwReturn = LoadParserOutput(pParser,dwCount,&dwUsed,szTok,INDEX_PSKAUTH,TYPE_PSKAUTH);
						bArg[ARG_PSKAUTH] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default					:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME]) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NAME_GUID_NEEDED);
	}

error:
	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function			:	ParseStaticShowFilterAction()
//
// Date of Creation	:	24th Aug 2001
//
// Parameters		:	IN      LPWSTR      *ppwcArguments,
//						IN OUT 	PPARSER_PKT pParser,
//						IN 		DWORD 		dwCurrentIndex,
//						IN 		DWORD 		dwMaxArgs
//
// Return			:	DWORD
//
// Description		:	It will check the valid Arguments for the StaticShowFilterAction context.
//						It loads all valid argument into pParser structure with status for each argument.
//
// History			:
//
// Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////

DWORD
ParseStaticShowFilterAction(
		IN      LPTSTR      *ppwcArguments,
		IN OUT 	PPARSER_PKT pParser,
		IN 		DWORD 		dwCurrentIndex,
		IN 		DWORD 		dwMaxArgs
		)
{
 	DWORD dwCount,dwNum,dwTagIndex = 0,dwIndex 	 = 0,dwUsed	= 0;
	DWORD dwReturn  = ERROR_SUCCESS;

	BOOL bTagPresent= FALSE;
 	BOOL bArg[MAX_ARGS];

 	_TCHAR szCmd[MAX_STR_LEN]  	= {0};
 	_TCHAR szTok[MAX_STR_LEN]  	= {0};
	_TCHAR szTemp[MAX_STR_LEN] 	= {0};

	const DWORD ARG_NAME    	= 0;	// Arg Array Index ( Same Index indicates OR'd commands)
	const DWORD ARG_ALL   		= 0;
	const DWORD ARG_RULE 		= 0;
	const DWORD ARG_VERBOSE 	= 1;
	const DWORD ARG_FORMAT	 	= 2;
	const DWORD ARG_WIDE		= 3;

	const DWORD INDEX_NAME 		= 0;	// When no tag is present the index reflects the
	const DWORD INDEX_ALL  		= 1;	// Commands as in the ValidToken Structure
	const DWORD INDEX_RULE		= 2;	// This define is used to indicate the ARG correspondence
	const DWORD INDEX_VERBOSE 	= 3;	// with the 'untagged' arg
	const DWORD INDEX_FORMAT	= 4;
	const DWORD INDEX_WIDE		= 5;

	DBG_UNREFERENCED_LOCAL_VARIABLE(INDEX_RULE);
	if ( (dwMaxArgs - dwCurrentIndex) >= 5 )
	{
		dwReturn = ERROR_INVALID_SYNTAX;
		BAIL_OUT;
	}

	for(dwCount = 0;dwCount < MAX_ARGS;dwCount++)			// Initialize
	{
		bArg[dwCount] = FALSE;
	}

	for(dwCount = dwCurrentIndex;(dwCount < dwMaxArgs) && (dwReturn == ERROR_SUCCESS);dwCount++)
	{
		if (_tcslen(ppwcArguments[dwCount]) < MAX_STR_LEN)
		{
			_tcsncpy(szTemp,ppwcArguments[dwCount],MAX_STR_LEN-1);			// temp contains arg
		}
		else
		{
			continue;
		}
		bTagPresent = SplitCmdTok(szTemp,szCmd,szTok,MAX_STR_LEN-1,MAX_STR_LEN-1);
		// Check for =
		if (bTagPresent)									// Parameter With Tag Found
		{
			dwNum = 0;
			MatchEnumTag(g_hModule,szCmd,pParser->MaxTok,pParser->ValidTok,&dwNum);
			if (dwNum)
			{

				dwIndex = MatchEnumTagToTagIndex(szCmd,pParser);
				if(dwIndex == PARSE_ERROR)
				{
					dwReturn = ERROR_SHOW_USAGE;
					BAIL_OUT;
				}
				switch(pParser->ValidTok[dwIndex].dwValue)
				{
					case CMD_TOKEN_NAME		:
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_ALL 		:
						if (!bArg[ARG_ALL])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_ALL);
							bArg[ARG_ALL] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_RULE 	:
						if (!bArg[ARG_RULE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_STRING);
							bArg[ARG_RULE] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
						break;
					case CMD_TOKEN_VERBOSE	:
						if (!bArg[ARG_VERBOSE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_VERBOSE);
							bArg[ARG_VERBOSE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_FORMAT	:
						if (!bArg[ARG_FORMAT])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_FORMAT);
							bArg[ARG_FORMAT] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					 case CMD_TOKEN_WIDE	:
						if (!bArg[ARG_WIDE])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,dwIndex,TYPE_BOOL);
							bArg[ARG_WIDE] = TRUE;
						}
						else
						{
							dwReturn = ERR_TAG_ALREADY_PRESENT;
						}
						break;
					default					:
						dwReturn = ERROR_INVALID_SYNTAX;
						break;
				}
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_TAG,szCmd);
				dwReturn = RETURN_NO_ERROR;
			}
		}
		else 	// Parameter Without a Tag Found
		{		// Find the first free slot to position the untagged arg
			for(dwTagIndex=0;
				dwTagIndex<pParser->MaxTok && (bArg[dwTagIndex] == TRUE) ;
				dwTagIndex++);
			switch (dwTagIndex)
			{
				case ARG_ALL		  :
					if (_tcsicmp(szTok,ALL_STR) == 0)
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_ALL,TYPE_ALL);
						bArg[ARG_ALL] = TRUE;
					}
					else
					{
						if (!bArg[ARG_NAME])
						{
							dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_NAME,TYPE_STRING);
							bArg[ARG_NAME] = TRUE;
						}
						else
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,ERRMSG_NAMERULEALL);
							dwReturn = RETURN_NO_ERROR;
						}
					}
					break;
				case ARG_VERBOSE 		:
					if (!bArg[ARG_VERBOSE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_VERBOSE,TYPE_VERBOSE);
						bArg[ARG_VERBOSE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				case ARG_FORMAT 		:
					if (!bArg[ARG_FORMAT])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,ppwcArguments[dwCount],INDEX_FORMAT,TYPE_FORMAT);
						bArg[ARG_FORMAT] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				 case ARG_WIDE			:
					if (!bArg[ARG_WIDE])
					{
						dwReturn = LoadParserOutput(pParser,dwCount-dwCurrentIndex,&dwUsed,szTok,INDEX_WIDE,TYPE_BOOL);
						bArg[ARG_WIDE] = TRUE;
					}
					else
					{
						dwReturn = ERR_TAG_ALREADY_PRESENT;
					}
					break;
				default 				:
					dwReturn = ERROR_INVALID_SYNTAX;
					break;
			}
		}
	}
	if(dwReturn == ERR_TAG_ALREADY_PRESENT)
	{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_ALREADY_PRESENT,pParser->ValidTok[dwIndex].pwszToken);
			dwReturn = RETURN_NO_ERROR;
	}
	else if( (dwReturn == ERROR_SUCCESS) && (!bArg[ARG_NAME]) )
	{
		dwReturn = RETURN_NO_ERROR;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_TAG_NEEDED,ERRMSG_NAMERULEALL);
	}
error:
	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticadd.cpp ===
////////////////////////////////////////////////////////////
//	Module			:	Static/Staticadd.cpp
//
// 	Purpose			: 	Static Add Implementation.
//
// 	Developers Name	:	Surya
//
// 	History			:
//
//  Date    	Author    	Comments
//
////////////////////////////////////////////////////////////
#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern CNshPolStore g_NshPolStoreHandle;
extern STORAGELOCATION g_StorageLocation;
extern CNshPolNegFilData g_NshPolNegFilData;

////////////////////////////////////////////////////////////
//
//Function: HandleStaticAddPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Add Policy"
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticAddPolicy(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	LPTSTR pszMachineName=NULL;
	DWORD dwReturn=ERROR_SUCCESS;
	DWORD   dwReturnCode   = ERROR_SHOW_USAGE;
	PPOLICYDATA pPolicyData=NULL;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticAddPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_PRESENT,	  	FALSE	},
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_MMPFS, 			NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_QMPERMM,		NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_MMLIFETIME,		NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_ACTIVATEDEFRULE,NS_REQ_ZERO,	  	FALSE 	},
		{ CMD_TOKEN_STR_PI,				NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_ASSIGN,			NS_REQ_ZERO,	  	FALSE	},
		{ CMD_TOKEN_STR_MMSECMETHODS,	NS_REQ_ZERO,	  	FALSE	}
	};
	const TOKEN_VALUE vtokStaticAddPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 				},
		{ CMD_TOKEN_STR_DESCR,			CMD_TOKEN_DESCR 			},
		{ CMD_TOKEN_STR_MMPFS, 			CMD_TOKEN_MMPFS				},
		{ CMD_TOKEN_STR_QMPERMM,		CMD_TOKEN_QMPERMM			},
		{ CMD_TOKEN_STR_MMLIFETIME, 	CMD_TOKEN_MMLIFETIME		},
		{ CMD_TOKEN_STR_ACTIVATEDEFRULE,CMD_TOKEN_ACTIVATEDEFRULE 	},
		{ CMD_TOKEN_STR_PI,				CMD_TOKEN_PI 				},
		{ CMD_TOKEN_STR_ASSIGN,			CMD_TOKEN_ASSIGN			},
		{ CMD_TOKEN_STR_MMSECMETHODS,	CMD_TOKEN_MMSECMETHODS		}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwReturnCode = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticAddPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticAddPolicy);

	parser.ValidCmd   = vcmdStaticAddPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticAddPolicy);

	dwReturnCode = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturnCode != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwReturnCode == RETURN_NO_ERROR)
		{
			dwReturnCode = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	//Get the User specified info into local structure

	dwReturn = FillAddPolicyInfo(&pPolicyData,parser,vtokStaticAddPolicy);

	if(dwReturn==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if (!pPolicyData->pszPolicyName || (pPolicyData->pszPolicyName[0] == TEXT('\0')) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_MISSING_POL_NAME);
		dwReturnCode=ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	// check the limits of variables

	if(pPolicyData->bPollIntervalSpecified && !IsWithinLimit(pPolicyData->dwPollInterval/60,POLLING_Min_MIN,POLLING_Min_MAX))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_POLL_INTERVAL_MSG,POLLING_Min_MIN,POLLING_Min_MAX);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}
	if(pPolicyData->bQMLimitSpecified && !IsWithinLimit(pPolicyData->dwQMLimit,QMPERMM_MIN,QMPERMM_MAX))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_QMPERMM_MSG,QMPERMM_MIN,QMPERMM_MAX);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}
	if(pPolicyData->bLifeTimeInsecondsSpecified && !IsWithinLimit(pPolicyData->LifeTimeInSeconds/60,P1_Min_LIFE_MIN,P1_Min_LIFE_MAX))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_LIFETIME_LIMIT_MSG,P1_Min_LIFE_MIN,P1_Min_LIFE_MAX);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}
	if(pPolicyData)
	{
		dwReturnCode = CreateNewPolicy(pPolicyData);
		if(dwReturnCode == ERROR_OUTOFMEMORY)
		{
			PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		}
		else if (dwReturnCode == ERROR_INVALID_PARAMETER)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_STATIC_INTERNAL_ERROR);
		}

		dwReturnCode=ERROR_SUCCESS;
	}

error:
	//clean up

	CleanUpLocalPolicyDataStructure(pPolicyData);

	if (pszMachineName)
	{
		delete [] pszMachineName;
	}

	return dwReturnCode;
}

/////////////////////////////////////////////////////////////
//
//Function: CreateNewPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PPOLICYDATA pPolicyData
//
//Return: DWORD
//
//Description:
//	Creates new policy data structure and calls the API
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
CreateNewPolicy(
	IN PPOLICYDATA pPolicyData
	)
{

	HANDLE hPolicyStorage = NULL;
	LPTSTR pszMachineName=NULL;
	DWORD   dwReturnCode   = ERROR_SUCCESS;
	PIPSEC_POLICY_DATA pPolicy=NULL,pActive=NULL;
	RPC_STATUS     RpcStat =RPC_S_OK;
	BOOL bExists=FALSE;

	// if no offer , fill defaults

	if(pPolicyData->dwOfferCount==0)
	{
		dwReturnCode = LoadIkeDefaults(pPolicyData,&(pPolicyData->pIpSecMMOffer));
		BAIL_ON_WIN32_ERROR(dwReturnCode);
	}

	if(pPolicyData->bPFSSpecified && pPolicyData->bPFS)
	{
		pPolicyData->dwQMLimit=MMPFS_QM_LIMIT;
	}

	if(!pPolicyData->bLifeTimeInsecondsSpecified)
	{
		pPolicyData->LifeTimeInSeconds= P2STORE_DEFAULT_LIFETIME;
	}

	if(!pPolicyData->bPollIntervalSpecified)
	{
		pPolicyData->dwPollInterval=P2STORE_DEFAULT_POLLINT;
	}

	if (pPolicyData->dwOfferCount != 0)
	{
		for(DWORD i=0;i<pPolicyData->dwOfferCount;i++)
		{
			pPolicyData->pIpSecMMOffer[i].Lifetime.uKeyExpirationTime=pPolicyData->LifeTimeInSeconds;
			pPolicyData->pIpSecMMOffer[i].dwQuickModeLimit=pPolicyData->dwQMLimit;
		}
	}

	if(pPolicyData->pszGPOName)
	{
	    if (g_StorageLocation.dwLocation != IPSEC_DIRECTORY_PROVIDER)
	    {
    		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_GPO_SPECIFIED_ON_NODOMAIN_POLICY);
    		dwReturnCode= ERROR_SHOW_USAGE;
    		BAIL_OUT;
	    }
	}
	
	// this wrapper function is for cache
	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwReturnCode = ERROR_SUCCESS;
		BAIL_OUT;
	}

	//check whether the policy exists in cache

	if(g_NshPolStoreHandle.GetBatchmodeStatus() && g_NshPolNegFilData.CheckPolicyInCacheByName(pPolicyData->pszPolicyName))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_CRNEWPOL_1,pPolicyData->pszPolicyName);
		dwReturnCode=ERROR_INVALID_DATA;
		bExists=TRUE;
	}
	else if (CheckPolicyExistance(hPolicyStorage,pPolicyData->pszPolicyName))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_CRNEWPOL_1,pPolicyData->pszPolicyName);
		dwReturnCode=ERROR_INVALID_DATA;
		bExists=TRUE;
	}

	if(!bExists) // if policy not exists, process further
	{
		pPolicy = (PIPSEC_POLICY_DATA) IPSecAllocPolMem(sizeof(IPSEC_POLICY_DATA));
		if (pPolicy == NULL)
		{
			dwReturnCode=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

		pPolicy->pszIpsecName = IPSecAllocPolStr(pPolicyData->pszPolicyName);

		if (pPolicy->pszIpsecName == NULL)
		{
			dwReturnCode=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

		if (pPolicyData->pszDescription)
		{
			pPolicy->pszDescription = IPSecAllocPolStr(pPolicyData->pszDescription);
			if (pPolicy->pszDescription == NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
		}
		else
		{
			pPolicy->pszDescription = NULL;
		}
		pPolicy->dwPollingInterval =  pPolicyData->dwPollInterval;
		RpcStat = UuidCreate(&(pPolicy->PolicyIdentifier));
		if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
		{
			dwReturnCode=ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}

		pPolicy->pIpsecISAKMPData = NULL;
		pPolicy->ppIpsecNFAData = NULL;
		pPolicy->dwNumNFACount = 0;
		pPolicy->dwWhenChanged = 0;

		RpcStat = UuidCreate(&(pPolicy->ISAKMPIdentifier));
		if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
		{
			dwReturnCode=ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}

		//deal with ISAKMP details

		pPolicy->pIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) IPSecAllocPolMem(sizeof(IPSEC_ISAKMP_DATA));
		if(pPolicy->pIpsecISAKMPData==NULL)
		{
			dwReturnCode=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		memset(pPolicy->pIpsecISAKMPData,0,sizeof(IPSEC_ISAKMP_DATA));
		pPolicy->pIpsecISAKMPData->ISAKMPIdentifier = pPolicy->ISAKMPIdentifier;
		pPolicy->pIpsecISAKMPData->dwWhenChanged = 0;

		// sec methods details
		pPolicy->pIpsecISAKMPData->dwNumISAKMPSecurityMethods = pPolicyData->dwOfferCount;
		pPolicy->pIpsecISAKMPData->pSecurityMethods = (PCRYPTO_BUNDLE) IPSecAllocPolMem(sizeof(CRYPTO_BUNDLE)*pPolicyData->dwOfferCount);
		if(pPolicy->pIpsecISAKMPData->pSecurityMethods==NULL)
		{
			dwReturnCode=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		// fill the sec methods

		for (DWORD i = 0; i <  pPolicyData->dwOfferCount; i++)
		{
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].MajorVersion = 0;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].MinorVersion = 0;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].AuthenticationMethod = 0;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.AlgorithmIdentifier = 0;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.KeySize = 0;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.Rounds = 0;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].PfsIdentityRequired = pPolicyData->bPFS;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.AlgorithmIdentifier = pPolicyData->pIpSecMMOffer[i].EncryptionAlgorithm.uAlgoIdentifier;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.KeySize = pPolicyData->pIpSecMMOffer[i].EncryptionAlgorithm.uAlgoKeyLen;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.Rounds = pPolicyData->pIpSecMMOffer[i].EncryptionAlgorithm.uAlgoRounds;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.AlgorithmIdentifier = pPolicyData->pIpSecMMOffer[i].HashingAlgorithm.uAlgoIdentifier;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.KeySize = pPolicyData->pIpSecMMOffer[i].HashingAlgorithm.uAlgoKeyLen;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.Rounds = pPolicyData->pIpSecMMOffer[i].HashingAlgorithm.uAlgoRounds;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].OakleyGroup = pPolicyData->pIpSecMMOffer[i].dwDHGroup;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].QuickModeLimit = pPolicyData->pIpSecMMOffer[i].dwQuickModeLimit;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].Lifetime.KBytes = 0;
			pPolicy->pIpsecISAKMPData->pSecurityMethods[i].Lifetime.Seconds = pPolicyData->pIpSecMMOffer[i].Lifetime.uKeyExpirationTime;
		}

		// now for other details for  ISAKMPPolicy
		pPolicy->pIpsecISAKMPData->ISAKMPPolicy.PolicyId = pPolicy->ISAKMPIdentifier;
		pPolicy->pIpsecISAKMPData->ISAKMPPolicy.IdentityProtectionRequired = 0;
		pPolicy->pIpsecISAKMPData->ISAKMPPolicy.PfsIdentityRequired = pPolicy->pIpsecISAKMPData->pSecurityMethods[0].PfsIdentityRequired;

		//call the APIs

		dwReturnCode = IPSecCreateISAKMPData(hPolicyStorage, pPolicy->pIpsecISAKMPData);
		if (dwReturnCode == ERROR_SUCCESS)
		{
			//add default rule
			dwReturnCode=AddDefaultResponseRule(pPolicy,hPolicyStorage,pPolicyData->bActivateDefaultRule,pPolicyData->bActivateDefaultRuleSpecified);
			if (dwReturnCode != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_CRNEWPOL_2);
			}

			if ( dwReturnCode==ERROR_SUCCESS  && pPolicyData->bAssign && (g_StorageLocation.dwLocation!=IPSEC_DIRECTORY_PROVIDER))
			{
				dwReturnCode =  IPSecGetAssignedPolicyData(hPolicyStorage, &pActive);
				if ((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode ==ERROR_FILE_NOT_FOUND))
				{
					dwReturnCode = pActive ? IPSecUnassignPolicy(hPolicyStorage, pActive->PolicyIdentifier) : 0,
						IPSecAssignPolicy(hPolicyStorage, pPolicy->PolicyIdentifier);
				}

				if (pActive)
				{
					IPSecFreePolicyData(pActive);
				}
				dwReturnCode = ERROR_SUCCESS;
			}
			if(dwReturnCode != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_CRNEWPOL_4,pPolicy->pszIpsecName);
			}
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_CRNEWPOL_4,pPolicy->pszIpsecName);
		}

	}

    if (hPolicyStorage)
    {
		ClosePolicyStore(hPolicyStorage);
    }    	


	if(pPolicy)
	{
		FreePolicyData(pPolicy);
	}

	if(pszMachineName)
	{
		delete [] pszMachineName;
	}
error:
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		CleanUpPolicy(pPolicy);
	}
	return dwReturnCode;
}

////////////////////////////////////////////////////////////
//
//Function: FillAddPolicyInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PPOLICYDATA* ppFilter,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticAddPolicy
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
FillAddPolicyInfo(
	OUT PPOLICYDATA* ppPolicyData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticAddPolicy
	)
{
	DWORD dwCount=0,dwReturn=ERROR_SUCCESS, dwStrLength = 0;
	PPOLICYDATA pPolicyData=new POLICYDATA;

	if(pPolicyData == NULL)
	{
		dwReturn=ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	memset(pPolicyData,0,sizeof(POLICYDATA));

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticAddPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME				:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
					pPolicyData->pszPolicyName = new _TCHAR[dwStrLength+1];

					if(pPolicyData->pszPolicyName == NULL)
					{
						dwReturn=ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}

					_tcsncpy(pPolicyData->pszPolicyName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
				}
				break;
			case CMD_TOKEN_DESCR			:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
					pPolicyData->pszDescription = new _TCHAR[dwStrLength+1];

					if(pPolicyData->pszDescription == NULL)
					{
						dwReturn=ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}

					_tcsncpy(pPolicyData->pszDescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
				}
				break;
			case CMD_TOKEN_MMPFS			:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					pPolicyData->bPFSSpecified=TRUE;
					pPolicyData->bPFS = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_ACTIVATEDEFRULE	:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					pPolicyData->bActivateDefaultRule = *(BOOL *)parser.Cmd[dwCount].pArg;
					pPolicyData->bActivateDefaultRuleSpecified=TRUE;
				}
				break;
			case CMD_TOKEN_ASSIGN			:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					pPolicyData->bAssign = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_MMLIFETIME		:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					pPolicyData->LifeTimeInSeconds=	*(ULONG *)parser.Cmd[dwCount].pArg * 60;
					pPolicyData->bLifeTimeInsecondsSpecified=TRUE;
				}
				break;
			case CMD_TOKEN_QMPERMM			:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					pPolicyData->dwQMLimit=	*(DWORD *)parser.Cmd[dwCount].pArg;
					pPolicyData->bQMLimitSpecified=TRUE;
				}
				break;
			case CMD_TOKEN_PI				:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					pPolicyData->dwPollInterval=  *(DWORD *)parser.Cmd[dwCount].pArg * 60;
					pPolicyData->bPollIntervalSpecified=TRUE;
				}
				break;
			case CMD_TOKEN_CERTTOMAP	:
				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
				{
					pPolicyData->bCertToAccMappingSpecified = TRUE;
					pPolicyData->bCertToAccMapping = *(BOOL *)parser.Cmd[dwCount].pArg;
				}
				break;
			case CMD_TOKEN_MMSECMETHODS		:
				if (parser.Cmd[dwCount].dwStatus > 0)
				{
					pPolicyData->dwOfferCount=parser.Cmd[dwCount].dwStatus;
					pPolicyData->pIpSecMMOffer = new IPSEC_MM_OFFER[pPolicyData->dwOfferCount];

					if(pPolicyData->pIpSecMMOffer == NULL)
					{
						dwReturn=ERROR_OUTOFMEMORY;
						BAIL_OUT;
					}

					memset(pPolicyData->pIpSecMMOffer, 0, sizeof(IPSEC_MM_OFFER) * pPolicyData->dwOfferCount);

					for(DWORD j=0;j<(parser.Cmd[dwCount].dwStatus);j++)
					{
						if ( ((IPSEC_MM_OFFER **)parser.Cmd[dwCount].pArg)[j] )
						{
							memcpy( &(pPolicyData->pIpSecMMOffer[j]),((IPSEC_MM_OFFER **)parser.Cmd[dwCount].pArg)[j],sizeof(IPSEC_MM_OFFER));
						}
					}
				}
				break;
			default							:
				break;
		}
	}

error:
	*ppPolicyData=pPolicyData;
	CleanUp();
	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: HandleStaticAddFilterList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//    OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Add FilterList"
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticAddFilterList(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	LPTSTR pszFLName=NULL,pszFLDescription=NULL;
	DWORD   dwCount=0,dwRet = ERROR_SHOW_USAGE, dwStrLength = 0;
	HANDLE hPolicyStorage = NULL;
	BOOL bFilterExists=FALSE;
	DWORD        dwReturnCode   = ERROR_SHOW_USAGE;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticAddFilterList[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  FALSE	}
	};

	const TOKEN_VALUE vtokStaticAddFilterList[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 			},
		{ CMD_TOKEN_STR_DESCR,		CMD_TOKEN_DESCR 		}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwReturnCode = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}
	parser.ValidTok   = vtokStaticAddFilterList;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticAddFilterList);

	parser.ValidCmd   = vcmdStaticAddFilterList;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticAddFilterList);

	//call the parser to parse the user input

	dwReturnCode = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturnCode != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwReturnCode==RETURN_NO_ERROR)
		{
			dwReturnCode = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed input

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticAddFilterList[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME				:
						if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						{
							dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
							pszFLName = new _TCHAR[dwStrLength+1];
							if(pszFLName == NULL)
							{
								dwRet=ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							_tcsncpy(pszFLName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
						}
						break;
			case CMD_TOKEN_DESCR			:
						if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						{
							dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
							pszFLDescription = new _TCHAR[dwStrLength+1];

							if(pszFLDescription == NULL)
							{
								dwRet=ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							_tcsncpy(pszFLDescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
						}
						break;
			default							:
						break;
		}
	}
	CleanUp();

	//in no name , bail out

	if(!pszFLName)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_1);
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	//check if policy already exists

	if(g_NshPolStoreHandle.GetBatchmodeStatus() && g_NshPolNegFilData.CheckFilterListInCacheByName(pszFLName))
	{
		bFilterExists=TRUE;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_2,pszFLName);
	}
	else
	{
		bFilterExists = CheckFilterListExistance(hPolicyStorage,pszFLName);
		if(bFilterExists)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_2,pszFLName);
		}
	}

	if(!bFilterExists) //if not exists , proceed further
	{
		dwReturnCode=CreateNewFilterList(hPolicyStorage,pszFLName,pszFLDescription);

		if (dwReturnCode == ERROR_INVALID_PARAMETER)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_STATIC_INTERNAL_ERROR);
			dwReturnCode=ERROR_SUCCESS;
		}
		else if(dwReturnCode != ERROR_OUTOFMEMORY)
		{
			dwReturnCode=ERROR_SUCCESS;
		}
	}
	ClosePolicyStore(hPolicyStorage);

error:   //clean up routines

	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		dwReturnCode = ERROR_SUCCESS;
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
	}
	if (pszFLName)
	{
		delete [] pszFLName;
	}
	if (pszFLDescription)
	{
		delete [] pszFLDescription;
	}

	return dwReturnCode;
}

////////////////////////////////////////////////////////////
//
//Function: CreateNewFilterList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage,
//	IN LPTSTR pszFLName,
//	IN LPTSTR pszFLDescription
//
//Return: DWORD
//
//Description:
//	This function creates a new empty filter list
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
CreateNewFilterList(
	IN HANDLE hPolicyStorage,
	IN LPTSTR pszFLName,
	IN LPTSTR pszFLDescription
	)
{
	DWORD  dwReturnCode   = ERROR_SUCCESS;
	RPC_STATUS     RpcStat =RPC_S_OK;
	PIPSEC_FILTER_DATA pFilterData = (PIPSEC_FILTER_DATA) IPSecAllocPolMem(sizeof(IPSEC_FILTER_DATA));

	if(pFilterData==NULL)
	{
		dwReturnCode = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	RpcStat = UuidCreate(&(pFilterData->FilterIdentifier));
	if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturnCode=ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}

	pFilterData->dwNumFilterSpecs = 0;
	pFilterData->ppFilterSpecs = NULL;

	pFilterData->dwWhenChanged = 0;

	//fill the name and desc

	if(pszFLName)
	{
		pFilterData->pszIpsecName = IPSecAllocPolStr(pszFLName);

		if(pFilterData->pszIpsecName==NULL)
		{
			dwReturnCode = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}
	if(pszFLDescription)
	{
		pFilterData->pszDescription = IPSecAllocPolStr(pszFLDescription);

		if(pFilterData->pszDescription==NULL)
		{
			dwReturnCode = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}

	//call the API and report if any error

	if (pFilterData)
	{
		dwReturnCode = CreateFilterData(hPolicyStorage, pFilterData);
	}
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_3,pszFLName);
	}

	if (pFilterData)
	{
		FreeFilterData(pFilterData);
	}
error:
	return dwReturnCode;
}

////////////////////////////////////////////////////////////
//
//Function: HandleStaticAddFilter()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//    OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Add Filter"
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticAddFilter(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{

	DWORD dwReturnCode = ERROR_SUCCESS;
	PIPSEC_FILTER_DATA pFilterData=NULL;
	DWORD   LoopIndex=0;
	HANDLE hPolicyStorage = NULL;
	BOOL bFilterExists=FALSE,bFilterInFLExists=FALSE;
	RPC_STATUS     RpcStat =RPC_S_OK;
	PFILTERDATA pFilter=NULL;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticAddFilter[] =
	{
		{ CMD_TOKEN_STR_FILTERLIST,		NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_SRCADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_DSTADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_PROTO,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_MIRROR,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SRCMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SRCPORT,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTPORT,		NS_REQ_ZERO,	  FALSE }
	};

	const TOKEN_VALUE vtokStaticAddFilter[] =
	{

		{ CMD_TOKEN_STR_FILTERLIST,		CMD_TOKEN_FILTERLIST },
		{ CMD_TOKEN_STR_SRCADDR,		CMD_TOKEN_SRCADDR	 },
		{ CMD_TOKEN_STR_DSTADDR,		CMD_TOKEN_DSTADDR	 },
		{ CMD_TOKEN_STR_DESCR,			CMD_TOKEN_DESCR		 },
		{ CMD_TOKEN_STR_PROTO,			CMD_TOKEN_PROTO		 },
		{ CMD_TOKEN_STR_MIRROR,			CMD_TOKEN_MIRROR	 },
		{ CMD_TOKEN_STR_SRCMASK,		CMD_TOKEN_SRCMASK	 },
		{ CMD_TOKEN_STR_DSTMASK,		CMD_TOKEN_DSTMASK	 },
		{ CMD_TOKEN_STR_SRCPORT,		CMD_TOKEN_SRCPORT	 },
		{ CMD_TOKEN_STR_DSTPORT,		CMD_TOKEN_DSTPORT	 }
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwReturnCode = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticAddFilter;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticAddFilter);

	parser.ValidCmd   = vcmdStaticAddFilter;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticAddFilter);

	dwReturnCode = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturnCode != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwReturnCode==RETURN_NO_ERROR)
		{
			dwReturnCode = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	//get the parsed user input

	dwReturnCode = FillAddFilterInfo(&pFilter,parser,vtokStaticAddFilter);
	BAIL_ON_WIN32_ERROR(dwReturnCode);

	if(!pFilter->pszFLName)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_1);
		BAIL_OUT;
	}

	//validate the user specified filter details

	dwReturnCode =ValidateFilterSpec(pFilter);
	BAIL_ON_WIN32_ERROR(dwReturnCode);

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	//get the filterlist specified to which the filter is to be added

	if(g_NshPolStoreHandle.GetBatchmodeStatus())
	{
		bFilterExists=g_NshPolNegFilData.GetFilterListFromCacheByName(pFilter->pszFLName,&pFilterData);
	}
	if(!bFilterExists)
	{
		bFilterExists=GetFilterListFromStore(&pFilterData,pFilter->pszFLName,hPolicyStorage,bFilterInFLExists);
	}

	if(!bFilterExists)
	{
		// if not exists create the filterlist

		dwReturnCode=CreateNewFilterList(hPolicyStorage,pFilter->pszFLName,NULL);
		BAIL_ON_WIN32_ERROR(dwReturnCode);

		if(g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			bFilterExists=g_NshPolNegFilData.GetFilterListFromCacheByName(pFilter->pszFLName,&pFilterData);
		}
		if(!bFilterExists)
		{
			bFilterExists=GetFilterListFromStore(&pFilterData,pFilter->pszFLName,hPolicyStorage,bFilterInFLExists);
		}
	}

	if(!bFilterExists)
	{
		// if creation also failed, bail out
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_3,pFilter->pszFLName);
		dwReturnCode =  ERROR_SUCCESS;
		BAIL_OUT;
	}

	//check readonly flag

	if(pFilterData->dwFlags & POLSTORE_READONLY )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_FL_READ_ONLY_OBJECT,pFilterData->pszIpsecName);
		BAIL_OUT;
	}

	// this for loop is for multiple DNS resolved IPs

	for(DWORD i=0;i < pFilter->SourceAddr.dwNumIpAddresses;i++)
	{
		for(DWORD j=0;j < pFilter->DestnAddr.dwNumIpAddresses;j++)
		{
			RpcStat = UuidCreate(&(pFilter->FilterSpecGUID));
			if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
			{
				dwReturnCode=ERROR_INVALID_PARAMETER;
				BAIL_OUT;
			}
			pFilterData->dwNumFilterSpecs++;
			LoopIndex = pFilterData->dwNumFilterSpecs-1;
			// call realloc , to make room for another filter
			pFilterData->ppFilterSpecs = ReAllocFilterSpecMem(pFilterData->ppFilterSpecs,LoopIndex,LoopIndex+1);
			if(pFilterData->ppFilterSpecs==NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			pFilterData->ppFilterSpecs[LoopIndex] = (PIPSEC_FILTER_SPEC) IPSecAllocPolMem(sizeof(IPSEC_FILTER_SPEC));

			if(pFilterData->ppFilterSpecs[LoopIndex]==NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			memset(pFilterData->ppFilterSpecs[LoopIndex],0,sizeof(IPSEC_FILTER_SPEC));

			//src & dst DNS name

			if(pFilter->SourceAddr.pszDomainName)
			{
				pFilterData->ppFilterSpecs[LoopIndex]->pszSrcDNSName=IPSecAllocPolStr(pFilter->SourceAddr.pszDomainName);

				if(pFilterData->ppFilterSpecs[LoopIndex]->pszSrcDNSName==NULL)
				{
					dwReturnCode=ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}
			}
			else
			{
				pFilterData->ppFilterSpecs[LoopIndex]->pszSrcDNSName=0;
			}

			if(pFilter->DestnAddr.pszDomainName)
			{
				pFilterData->ppFilterSpecs[LoopIndex]->pszDestDNSName = IPSecAllocPolStr(pFilter->DestnAddr.pszDomainName);

				if(pFilterData->ppFilterSpecs[LoopIndex]->pszDestDNSName==NULL)
				{
					dwReturnCode=ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}
			}
			else
			{
				pFilterData->ppFilterSpecs[LoopIndex]->pszDestDNSName = 0;
			}
			//desc
			if(pFilter->pszDescription)
			{

				pFilterData->ppFilterSpecs[LoopIndex]->pszDescription = IPSecAllocPolStr(pFilter->pszDescription);

				if(pFilterData->ppFilterSpecs[LoopIndex]->pszDescription==NULL)
				{
					dwReturnCode=ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}
			}
			else
			{
				pFilterData->ppFilterSpecs[LoopIndex]->pszDescription = NULL;
			}
			
			if (((pFilter->dwProtocol != PROT_ID_TCP) && (pFilter->dwProtocol != PROT_ID_UDP)) &&
				((pFilter->SourPort != 0) || (pFilter->DestPort != 0)))
			{
				dwReturnCode = ERROR_INVALID_PARAMETER;
				BAIL_OUT;
			}

			//other details like mirrored, protocol etc
			pFilterData->ppFilterSpecs[LoopIndex]->dwMirrorFlag        = pFilter->bMirrored;
			pFilterData->ppFilterSpecs[LoopIndex]->FilterSpecGUID      = pFilter->FilterSpecGUID;
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.SrcAddr      = pFilter->SourceAddr.puIpAddr[i];
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.SrcMask      = pFilter->SourMask;
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.DestAddr     = pFilter->DestnAddr.puIpAddr[j];
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.DestMask     = pFilter->DestMask;
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.TunnelAddr   = 0;
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.Protocol     = pFilter->dwProtocol;
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.SrcPort      = pFilter->SourPort;
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.DestPort     = pFilter->DestPort;
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.TunnelFilter = FALSE;
			pFilterData->ppFilterSpecs[LoopIndex]->Filter.ExType       = pFilter->ExType;
		}
	}

	//once filling the parameters are over , call the respective API

	if (pFilterData)
	{
		// Wrapper API is called to update cache also if required

		dwReturnCode = SetFilterData(hPolicyStorage, pFilterData);
	}

	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_2);
	}
	if(pFilterData)
	{
		FreeFilterData(pFilterData);
	}

	ClosePolicyStore(hPolicyStorage);

error:  //cleanup and error printing

	if(dwReturnCode == ERROR_OUTOFMEMORY || dwReturnCode == ERROR_INVALID_PARAMETER)
	{
		if(dwReturnCode == ERROR_OUTOFMEMORY)
		{
			PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_INVALID_ARGS);
		}

		if(pFilterData)  // if allocation failed somewhere, free
		{
			if(pFilterData->ppFilterSpecs)
			{
				for (DWORD cnt=0; cnt< pFilterData->dwNumFilterSpecs;cnt++)
				{
					if(pFilterData->ppFilterSpecs[cnt])
					{
						IPSecFreePolMem(pFilterData->ppFilterSpecs[cnt]);
					}
				}
				IPSecFreePolMem(pFilterData->ppFilterSpecs);
			}
			IPSecFreePolMem(pFilterData);
			pFilterData = NULL;
		}
	}

	CleanUpLocalFilterDataStructure(pFilter);

   	if(dwReturnCode != ERROR_SHOW_USAGE)
   	{
   		dwReturnCode =  ERROR_SUCCESS;
	}
   	return dwReturnCode;
}

////////////////////////////////////////////////////////////
//
//Function: FillAddFilterInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PFILTERDATA* ppFilterData,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticAddFilter
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
FillAddFilterInfo(
	OUT PFILTERDATA* ppFilterData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticAddFilter
	)
{
	DWORD dwCount=0,dwReturn=ERROR_SUCCESS,dwStrLength = 0;
	PFILTERDATA pFilterData=new FILTERDATA;
	if(pFilterData==NULL)
	{
		dwReturn=ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memset(pFilterData,0,sizeof(FILTERDATA));

	pFilterData->bMirrored=TRUE;
	pFilterData->DestPort= pFilterData->SourPort=PORT_ANY;
	pFilterData->dwProtocol=PROTOCOL_ANY;
	pFilterData->TunnFiltExists=FALSE;
	pFilterData->SourMask = pFilterData->DestMask = MASK_ME;

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticAddFilter[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_FILTERLIST		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
								pFilterData->pszFLName = new _TCHAR[dwStrLength+1];

								if(pFilterData->pszFLName==NULL)
								{
									dwReturn=ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilterData->pszFLName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_DESCR			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
								pFilterData->pszDescription = new _TCHAR[dwStrLength+1];
								if(pFilterData->pszDescription==NULL)
								{
									dwReturn=ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilterData->pszDescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_MIRROR			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterData->bMirrored = *(BOOL *)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_PROTO			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterData->dwProtocol = *(DWORD *)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_SRCPORT			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterData->SourPort = *(WORD *)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_DSTPORT			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterData->DestPort = *(WORD *)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_SRCADDR 			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterData->bSrcAddrSpecified=TRUE;

								if(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName)
								{
									dwStrLength = _tcslen(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName);
									pFilterData->SourceAddr.pszDomainName = new _TCHAR[dwStrLength+1];
									if(pFilterData->SourceAddr.pszDomainName==NULL)
									{
										dwReturn=ERROR_OUTOFMEMORY;
										BAIL_OUT;
									}
									_tcsncpy(pFilterData->SourceAddr.pszDomainName,((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName,dwStrLength+1);
								}
								pFilterData->SourceAddr.dwNumIpAddresses = ((DNSIPADDR *)parser.Cmd[dwCount].pArg)->dwNumIpAddresses;
								pFilterData->SourceAddr.puIpAddr= new ULONG[pFilterData->SourceAddr.dwNumIpAddresses];
								if(pFilterData->SourceAddr.puIpAddr==NULL)
								{
									dwReturn=ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}

								for(DWORD n=0;n < pFilterData->SourceAddr.dwNumIpAddresses;n++)
								{
									memcpy( &(pFilterData->SourceAddr.puIpAddr[n]),&(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->puIpAddr[n]),sizeof(ULONG));
								}
							}
							else
							{
								//look for special server type

								if(parser.Cmd[dwCount].dwStatus == SERVER_DNS)
								{
									pFilterData->bSrcServerSpecified=TRUE;
									pFilterData->ExType=EXT_DNS_SERVER;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_WINS)
								{
									pFilterData->bSrcServerSpecified=TRUE;
									pFilterData->ExType=EXT_WINS_SERVER;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_DHCP)
								{
									pFilterData->bSrcServerSpecified=TRUE;
									pFilterData->ExType=EXT_DHCP_SERVER;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_GATEWAY)
								{
									pFilterData->bSrcServerSpecified=TRUE;
									pFilterData->ExType=EXT_DEFAULT_GATEWAY;
								}
								else if (parser.Cmd[dwCount].dwStatus == IP_ME)
								{
									pFilterData->bSrcMeSpecified=TRUE;
								}
								else if (parser.Cmd[dwCount].dwStatus == IP_ANY)
								{
									pFilterData->bSrcAnySpecified=TRUE;
								}
							}
							break;
			case CMD_TOKEN_SRCMASK 			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterData->bSrcMaskSpecified=TRUE;
								pFilterData->SourMask = *(DWORD *)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_DSTADDR 			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterData->bDstAddrSpecified=TRUE;

								if(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName)
								{
									dwStrLength = _tcslen(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName);
									pFilterData->DestnAddr.pszDomainName = new _TCHAR[dwStrLength+1];
									if(pFilterData->DestnAddr.pszDomainName == NULL)
									{
										dwReturn=ERROR_OUTOFMEMORY;
										BAIL_OUT;
									}
									_tcsncpy(pFilterData->DestnAddr.pszDomainName,((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName,dwStrLength+1);
								}
								pFilterData->DestnAddr.dwNumIpAddresses = ((DNSIPADDR *)parser.Cmd[dwCount].pArg)->dwNumIpAddresses;
								pFilterData->DestnAddr.puIpAddr= new ULONG[pFilterData->DestnAddr.dwNumIpAddresses];

								if(pFilterData->DestnAddr.puIpAddr == NULL)
								{
									dwReturn=ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}

								for(DWORD n=0;n < pFilterData->DestnAddr.dwNumIpAddresses;n++)
								{
									memcpy( &(pFilterData->DestnAddr.puIpAddr[n]),(&((DNSIPADDR *)parser.Cmd[dwCount].pArg)->puIpAddr[n]),sizeof(ULONG));
								}
							}
							else
							{
								//look for special server type

								if(parser.Cmd[dwCount].dwStatus == SERVER_DNS)
								{
									pFilterData->bDstServerSpecified=TRUE;
									pFilterData->ExType=EXT_DNS_SERVER | EXT_DEST;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_WINS)
								{
									pFilterData->bDstServerSpecified=TRUE;
									pFilterData->ExType=EXT_WINS_SERVER | EXT_DEST;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_DHCP)
								{
									pFilterData->bDstServerSpecified=TRUE;
									pFilterData->ExType=EXT_DHCP_SERVER | EXT_DEST;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_GATEWAY)
								{
									pFilterData->bDstServerSpecified=TRUE;
									pFilterData->ExType=EXT_DEFAULT_GATEWAY | EXT_DEST;
								}
								else if (parser.Cmd[dwCount].dwStatus == IP_ME)
								{
									pFilterData->bDstMeSpecified=TRUE;
								}
								else if (parser.Cmd[dwCount].dwStatus == IP_ANY)
								{
									pFilterData->bDstAnySpecified=TRUE;
								}
							}
							break;
			case CMD_TOKEN_DSTMASK 			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterData->bDstMaskSpecified=TRUE;
								pFilterData->DestMask = *(DWORD *)parser.Cmd[dwCount].pArg;
							}
							break;
			default							:
							break;
		}
	}

	//  take care of me and any here

	if(pFilterData->bSrcMeSpecified)
	{
		if (pFilterData->bDstMeSpecified)
		{
			dwReturn = ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}

		pFilterData->SourceAddr.dwNumIpAddresses = 1;
		pFilterData->SourceAddr.puIpAddr= new ULONG[pFilterData->SourceAddr.dwNumIpAddresses];
		if(pFilterData->SourceAddr.puIpAddr == NULL)
		{
			dwReturn=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		*(pFilterData->SourceAddr.puIpAddr)=ADDR_ME;
		pFilterData->SourMask = MASK_ME;
	}
	else
	{
		ADDR srcAddr, dstAddr;
		
		if(pFilterData->bSrcAnySpecified)
		{
			pFilterData->SourceAddr.dwNumIpAddresses = 1;
			pFilterData->SourceAddr.puIpAddr= new ULONG[pFilterData->SourceAddr.dwNumIpAddresses];
			if(pFilterData->SourceAddr.puIpAddr == NULL)
			{
				dwReturn=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			*(pFilterData->SourceAddr.puIpAddr)=ADDR_ME;
			pFilterData->SourMask = ADDR_ME;
		}

		if (pFilterData->bDstAddrSpecified)
		{
			dstAddr.uIpAddr = ntohl(*(pFilterData->DestnAddr.puIpAddr));
			if (pFilterData->bDstMaskSpecified)
			{
				dstAddr.uSubNetMask = ntohl(pFilterData->DestMask);
			}
			else
			{
				dstAddr.uSubNetMask = 0;
			}
			if (IsBroadcastAddress(&dstAddr) || IsMulticastAddress(&dstAddr))
			{
				dwReturn = ERROR_INVALID_PARAMETER;
				BAIL_OUT;
			}
		}

		if (pFilterData->bSrcAddrSpecified)
		{
			srcAddr.uIpAddr = ntohl(*(pFilterData->SourceAddr.puIpAddr));
			if (pFilterData->bSrcMaskSpecified)
			{
				srcAddr.uSubNetMask = ntohl(pFilterData->SourMask);
			}
			else
			{
				srcAddr.uSubNetMask = 0;
			}
			if (IsBroadcastAddress(&srcAddr) || IsMulticastAddress(&srcAddr))
			{
				dwReturn = ERROR_INVALID_PARAMETER;
				BAIL_OUT;
			}
		}

		if (pFilterData->bSrcAddrSpecified && pFilterData->bDstAddrSpecified)
		{
			// if <ip> - <same IP> reject
			if (!IsValidSubnet(&srcAddr) && !IsValidSubnet(&dstAddr) && (srcAddr.uIpAddr == dstAddr.uIpAddr))
			{
				dwReturn = ERROR_INVALID_PARAMETER;
				BAIL_OUT;
			}
		}
	}

	if (pFilterData->bMirrored)
	{
		if (pFilterData->bSrcAddrSpecified)
		{
			ADDR addr;
			addr.uIpAddr = ntohl(*(pFilterData->SourceAddr.puIpAddr));
			addr.uSubNetMask = 0;
			if (IsBroadcastAddress(&addr) || IsMulticastAddress(&addr))
			{
				dwReturn = ERROR_INVALID_PARAMETER;
				BAIL_OUT;
			}
		}
	}
	else
	{
		// reject if any<->any and not mirrored
		if (pFilterData->bSrcAnySpecified && pFilterData->bDstAnySpecified)
		{
			dwReturn = ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}

		if (pFilterData->SourceAddr.puIpAddr && pFilterData->DestnAddr.puIpAddr)
		{
			// reject subnetx-subnetx if not mirrored
			ADDR srcAddr;
			ADDR dstAddr;

			srcAddr.uIpAddr = ntohl(*(pFilterData->SourceAddr.puIpAddr));
			srcAddr.uSubNetMask = ntohl(pFilterData->SourMask);

			dstAddr.uIpAddr = ntohl(*(pFilterData->DestnAddr.puIpAddr));
			dstAddr.uSubNetMask = ntohl(pFilterData->DestMask);

			if (IsValidSubnet(&srcAddr) && IsValidSubnet(&dstAddr) && (srcAddr.uIpAddr == dstAddr.uIpAddr))
			{
				dwReturn = ERROR_INVALID_PARAMETER;
				BAIL_OUT;
			}
		}
	}

	if(pFilterData->bDstMeSpecified)
	{
		pFilterData->DestnAddr.dwNumIpAddresses = 1;
		pFilterData->DestnAddr.puIpAddr= new ULONG[pFilterData->DestnAddr.dwNumIpAddresses];
		if(pFilterData->DestnAddr.puIpAddr == NULL)
		{
			dwReturn=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		*(pFilterData->DestnAddr.puIpAddr)=ADDR_ME;
		pFilterData->DestMask = MASK_ME;
	}
	else
	{
		if(pFilterData->bDstAnySpecified)
		{
			pFilterData->DestnAddr.dwNumIpAddresses = 1;
			pFilterData->DestnAddr.puIpAddr= new ULONG[pFilterData->DestnAddr.dwNumIpAddresses];
			if(pFilterData->DestnAddr.puIpAddr == NULL)
			{
				dwReturn=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}

			*(pFilterData->DestnAddr.puIpAddr)=ADDR_ME;
			pFilterData->DestMask = ADDR_ME;
		}
	}

	//if DNS specified  mask is to be made to 255.255.255.255
	if (pFilterData->DestnAddr.pszDomainName)
	{
		pFilterData->DestMask = MASK_ME;
	}
	if (pFilterData->SourceAddr.pszDomainName)
	{
		pFilterData->SourMask = MASK_ME;
	}

	//if server type specified, ingore other irrelevent inputs

	if(pFilterData->bSrcServerSpecified || pFilterData->bDstServerSpecified)
	{
		if(!(pFilterData->bSrcServerSpecified && pFilterData->bDstServerSpecified))
		{
			if(pFilterData->bSrcServerSpecified)
			{
				if(
					!(pFilterData->bDstMeSpecified)
					&& ((pFilterData->DestnAddr.puIpAddr && pFilterData->DestnAddr.puIpAddr !=0 )
					||(pFilterData->DestMask != MASK_ME))
				  )
				{
					PrintMessageFromModule(g_hModule,ADD_STATIC_FILTER_SRCSERVER_WARNING);
				}
			}
			else
			{
				if(
					!(pFilterData->bSrcMeSpecified)
					&& ( (pFilterData->SourceAddr.puIpAddr && pFilterData->SourceAddr.puIpAddr !=0 )
					||(pFilterData->SourMask != MASK_ME))
				  )
				{
					PrintMessageFromModule(g_hModule,ADD_STATIC_FILTER_DSTSERVER_WARNING);
				}
			}
		}
		if(pFilterData->SourceAddr.pszDomainName)
		{
			delete [] pFilterData->SourceAddr.pszDomainName;
			pFilterData->SourceAddr.pszDomainName=NULL;
		}
		if(pFilterData->DestnAddr.pszDomainName)
		{
			delete [] pFilterData->DestnAddr.pszDomainName;
			pFilterData->DestnAddr.pszDomainName=NULL;
		}
		if(pFilterData->SourceAddr.puIpAddr)
		{
			delete [] pFilterData->SourceAddr.puIpAddr;
		}
		if(pFilterData->DestnAddr.puIpAddr)
		{
			delete [] pFilterData->DestnAddr.puIpAddr;
		}
		pFilterData->bSrcAddrSpecified=FALSE;
		pFilterData->bSrcMaskSpecified=FALSE;
		pFilterData->bDstAddrSpecified=FALSE;
		pFilterData->bDstMaskSpecified=FALSE;

		pFilterData->SourceAddr.dwNumIpAddresses = DEF_NUMBER_OF_ADDR;
		pFilterData->SourceAddr.puIpAddr= new ULONG[DEF_NUMBER_OF_ADDR];
		if(pFilterData->SourceAddr.puIpAddr == NULL)
		{
			dwReturn=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		memcpy( &(pFilterData->SourceAddr.puIpAddr[0]),&ADDR_ME ,sizeof(ULONG));

		pFilterData->DestnAddr.dwNumIpAddresses = DEF_NUMBER_OF_ADDR;
		pFilterData->DestnAddr.puIpAddr= new ULONG[DEF_NUMBER_OF_ADDR];
		if(pFilterData->DestnAddr.puIpAddr == NULL)
		{
			dwReturn=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		memcpy( &(pFilterData->DestnAddr.puIpAddr[0]),&ADDR_ME ,sizeof(ULONG));

		pFilterData->SourMask = MASK_ME;
		pFilterData->DestMask = MASK_ME;
	}
error:
	*ppFilterData=pFilterData;

	CleanUp();
	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: HandleStaticAddFilterActions()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Add FilterActions"
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticAddFilterActions(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	HANDLE hPolicyStorage = NULL;
	BOOL bNegPolExists=FALSE;
	PFILTERACTION pFilterAction= NULL;
	DWORD        dwReturnCode   = ERROR_SUCCESS;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticAddFilterAction[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_QMPFS,	 		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_INPASS,		 	NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SOFT,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_ACTION,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_QMSECMETHODS,	NS_REQ_ZERO,	  FALSE	}
	};

	const TOKEN_VALUE vtokStaticAddFilterAction[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 			},
		{ CMD_TOKEN_STR_DESCR,			CMD_TOKEN_DESCR 		},
		{ CMD_TOKEN_STR_QMPFS,	 		CMD_TOKEN_QMPFS			},
		{ CMD_TOKEN_STR_INPASS,			CMD_TOKEN_INPASS		},
		{ CMD_TOKEN_STR_SOFT,			CMD_TOKEN_SOFT			},
		{ CMD_TOKEN_STR_ACTION,			CMD_TOKEN_ACTION		},
		{ CMD_TOKEN_STR_QMSECMETHODS,	CMD_TOKEN_QMSECMETHODS	}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <=3)
	{
		dwReturnCode = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticAddFilterAction;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticAddFilterAction);

	parser.ValidCmd   = vcmdStaticAddFilterAction;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticAddFilterAction);

	//call parser

	dwReturnCode = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturnCode != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwReturnCode==RETURN_NO_ERROR)
		{
			dwReturnCode = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	//get the parsed user input

	dwReturnCode = FillAddFilterActionInfo(&pFilterAction,parser,vtokStaticAddFilterAction);
	if(dwReturnCode==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturnCode = ERROR_SUCCESS;
		BAIL_OUT;
	}
	// if no name, bail out

	if(!pFilterAction->pszFAName)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_2);
		BAIL_OUT;
	}

	if((pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)||(pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC))
	{
		pFilterAction->bQMPfs=0;
		pFilterAction->bSoft=0;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}
	// check for multiple filteractions with same name

	if(g_NshPolStoreHandle.GetBatchmodeStatus() && g_NshPolNegFilData.CheckNegPolInCacheByName(pFilterAction->pszFAName))
	{
		bNegPolExists=TRUE;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERACTION_1,pFilterAction->pszFAName);
		BAIL_OUT;
	}
	else
	{
		bNegPolExists = CheckFilterActionExistance(hPolicyStorage,pFilterAction->pszFAName);
		if(bNegPolExists)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERACTION_1,pFilterAction->pszFAName);
			BAIL_OUT;
		}
	}
	PIPSEC_NEGPOL_DATA pNegPolData=NULL;

	if(pFilterAction->dwNumSecMethodCount==0 && (!((pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)|| (pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC))))
	{
		dwReturnCode = LoadOfferDefaults(pFilterAction->pIpsecSecMethods,pFilterAction->dwNumSecMethodCount);

		if(dwReturnCode == ERROR_OUTOFMEMORY)
		{
			PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
			dwReturnCode=ERROR_SUCCESS;
			BAIL_OUT;
		}
	}

	// prepare the NEG_POL structure

	dwReturnCode = MakeNegotiationPolicy(&pNegPolData,pFilterAction);

	//call the API
	if(dwReturnCode==ERROR_SUCCESS)
	{
		if (pNegPolData)
		{
			dwReturnCode = CreateNegPolData(hPolicyStorage, pNegPolData);
		}
		if (dwReturnCode != ERROR_SUCCESS)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERACTION_2,pFilterAction->pszFAName);
			dwReturnCode = ERROR_SUCCESS;
		}

		if(pNegPolData)
		{
			FreeNegPolData(pNegPolData);
		}
	}
	else if(dwReturnCode==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturnCode=ERROR_SUCCESS;
	}
	else if(dwReturnCode==ERROR_INVALID_PARAMETER)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_STATIC_INTERNAL_ERROR);
		dwReturnCode=ERROR_SUCCESS;
	}

	ClosePolicyStore(hPolicyStorage);

error:
		// clean up the used structures

	CleanUpLocalFilterActionDataStructure(pFilterAction);

	return dwReturnCode;
}

////////////////////////////////////////////////////////////
//
//Function: FillAddFilterActionInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PFILTERACTION* ppFilterData,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticAddFilterAction
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
FillAddFilterActionInfo(
	OUT PFILTERACTION* ppFilterData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticAddFilterAction
	)
{
	DWORD dwCount=0,dwReturn =ERROR_SUCCESS,dwStrLength = 0;
	PFILTERACTION pFilterAction=new FILTERACTION;

	if(pFilterAction==NULL)
	{
		dwReturn =ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memset(pFilterAction,0,sizeof(FILTERACTION));

	pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticAddFilterAction[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_DESCR		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pFilterAction->pszFADescription = new _TCHAR[dwStrLength+1];
								if(pFilterAction->pszFADescription==NULL)
								{
									dwReturn =ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilterAction->pszFADescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
            case CMD_TOKEN_NAME			:
            				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pFilterAction->pszFAName = new _TCHAR[dwStrLength+1];
								if(pFilterAction->pszFAName==NULL)
								{
									dwReturn =ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilterAction->pszFAName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_INPASS		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								 if ( *(BOOL *)parser.Cmd[dwCount].pArg == TRUE)
								 {
									pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU;
								 }
							}
							break;
			case CMD_TOKEN_SOFT			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterAction->bSoft = *(BOOL *)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_QMPFS		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterAction->bQMPfs = *(BOOL *)parser.Cmd[dwCount].pArg;
							}
							break;
 			default						:
 							break;
		}
	}

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticAddFilterAction[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_ACTION			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								if (*(DWORD *)parser.Cmd[dwCount].pArg == TOKEN_QMSEC_PERMIT )
								{
									pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_NO_IPSEC;
								}
								else if (*(DWORD *)parser.Cmd[dwCount].pArg == TOKEN_QMSEC_BLOCK)
								{
									pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_BLOCK;
								}
							}
							break;
			default							:
							break;
		}
	}

	//if action is permit or block , sec methods  not required

	if (!(pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC || pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK))
	{
		for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
		{
			switch(vtokStaticAddFilterAction[parser.Cmd[dwCount].dwCmdToken].dwValue)
			{
				case CMD_TOKEN_QMSECMETHODS		:   //qmsec methods
							if (parser.Cmd[dwCount].dwStatus > 0)
							{
								pFilterAction->dwNumSecMethodCount=parser.Cmd[dwCount].dwStatus;
								pFilterAction->pIpsecSecMethods = new IPSEC_QM_OFFER[pFilterAction->dwNumSecMethodCount];
								if(pFilterAction->pIpsecSecMethods==NULL)
								{
									dwReturn =ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								memset(pFilterAction->pIpsecSecMethods, 0, sizeof(IPSEC_QM_OFFER) * pFilterAction->dwNumSecMethodCount);
								for(DWORD j=0;j<(parser.Cmd[dwCount].dwStatus);j++)
								{
									if ( ((IPSEC_QM_OFFER **)parser.Cmd[dwCount].pArg)[j] )
									{
										memcpy( &(pFilterAction->pIpsecSecMethods[j]),((IPSEC_QM_OFFER **)parser.Cmd[dwCount].pArg)[j],sizeof(IPSEC_QM_OFFER));
									}
								}
							}
							break;
				default							:
							break;
			}
		}
	}
error:
	*ppFilterData=pFilterAction;
	CleanUp();
	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: HandleStaticAddRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description
//	Implementation for the command "Add Rule"
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticAddRule(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	DWORD dwRet = ERROR_SHOW_USAGE;
	PRULEDATA pRuleData=NULL;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticAddRule[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_POLICY,			NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_FILTERLIST,		NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_FILTERACTION,	NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_TUNNEL,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_CONNTYPE,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_ACTIVATE,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_KERB,	        NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_PSK,	        NS_REQ_ZERO,	  FALSE	}
	};

	const TOKEN_VALUE vtokStaticAddRule[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 			},
		{ CMD_TOKEN_STR_POLICY,			CMD_TOKEN_POLICY		},
		{ CMD_TOKEN_STR_FILTERLIST,		CMD_TOKEN_FILTERLIST	},
		{ CMD_TOKEN_STR_FILTERACTION,	CMD_TOKEN_FILTERACTION	},
		{ CMD_TOKEN_STR_TUNNEL,			CMD_TOKEN_TUNNEL		},
		{ CMD_TOKEN_STR_CONNTYPE, 		CMD_TOKEN_CONNTYPE		},
		{ CMD_TOKEN_STR_ACTIVATE,		CMD_TOKEN_ACTIVATE	 	},
		{ CMD_TOKEN_STR_DESCR,			CMD_TOKEN_DESCR		 	},
		{ CMD_TOKEN_STR_KERB,	        CMD_TOKEN_KERB          },
		{ CMD_TOKEN_STR_PSK,	        CMD_TOKEN_PSK	        }
	};

	const TOKEN_VALUE vlistStaticAddRule[] =
	{
		{ CMD_TOKEN_STR_ROOTCA,	        CMD_TOKEN_ROOTCA	    },
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <=3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticAddRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticAddRule);

	parser.ValidCmd   = vcmdStaticAddRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticAddRule);

	parser.ValidList  = vlistStaticAddRule;
	parser.MaxList    = SIZEOF_TOKEN_VALUE(vlistStaticAddRule);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet == RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}
	// get parsed user input

	dwRet = FillAddRuleInfo(&pRuleData,parser,vtokStaticAddRule);

	if(dwRet==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if(pRuleData)
	{
		//if tunnel specified, validate it

		if (pRuleData->bTunnel)
		{
			if(!bIsValidIPAddress(htonl(pRuleData->TunnelIPAddress),TRUE,TRUE))
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_RULE_INVALID_TUNNEL);
				dwRet=ERROR_SUCCESS;
				BAIL_OUT;
			}
		}
		//create new rule
		CreateNewRule(pRuleData);
		dwRet=ERROR_SUCCESS;
	}

error:
	CleanUpLocalRuleDataStructure(pRuleData);

	return dwRet;
}

////////////////////////////////////////////////////////////
//
//Function: CreateNewRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PRULEDATA pRuleData
//
//Return: DWORD
//
//Description:
//	Creates a new rule based on the user input
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
CreateNewRule(
	IN PRULEDATA pRuleData
	)
{

	PIPSEC_POLICY_DATA pPolicyData  = NULL;
	PIPSEC_NEGPOL_DATA pNegPolData  = NULL;
	PIPSEC_FILTER_DATA pFilterData  = NULL;
	HANDLE hPolicyStorage = NULL;
	BOOL bPolicyExists=FALSE,bFAExists=FALSE,bFLExists=FALSE;
	BOOL bFilterExists=FALSE,bRuleExists=FALSE;
	DWORD  dwReturnCode = ERROR_SUCCESS;

	// check for all mandatory names

	if (!pRuleData->pszRuleName || (pRuleData->pszRuleName[0] == _TEXT('\0')) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_1);
		return ERROR_INVALID_DATA;
	}
	if (!pRuleData->pszPolicyName || (pRuleData->pszPolicyName[0] == _TEXT('\0')) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_MISSING_POL_NAME);
		return ERROR_INVALID_DATA;
	}
	if (!pRuleData->pszFLName || (pRuleData->pszFLName[0] == _TEXT('\0')) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_1);
		return ERROR_INVALID_DATA;
	}
	if (!pRuleData->pszFAName || (pRuleData->pszFAName[0] == _TEXT('\0')) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_2);
		return ERROR_INVALID_DATA;
	}

	if(!pRuleData->bConnectionTypeSpecified)
	{
		pRuleData->ConnectionType= INTERFACE_TYPE_ALL;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwReturnCode = ERROR_SUCCESS;
		BAIL_OUT;
	}
	//check for duplicate names in polstore

	if(g_NshPolStoreHandle.GetBatchmodeStatus())
	{
		bPolicyExists=g_NshPolNegFilData.GetPolicyFromCacheByName(pRuleData->pszPolicyName,&pPolicyData);
	}
	if(!bPolicyExists)
	{
		if(!(bPolicyExists=GetPolicyFromStore(&pPolicyData,pRuleData->pszPolicyName,hPolicyStorage)))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_3,pRuleData->pszPolicyName);
			dwReturnCode=ERROR_INVALID_DATA;
			BAIL_OUT;
		}
	}

	//check for readonly flag

	if(pPolicyData->dwFlags & POLSTORE_READONLY )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_POL_READ_ONLY_OBJECT,pPolicyData->pszIpsecName);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if (bPolicyExists && (bRuleExists=CheckForRuleExistance(pPolicyData,pRuleData->pszRuleName)))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_4,pRuleData->pszRuleName,pRuleData->pszPolicyName);
		dwReturnCode=ERROR_INVALID_DATA;
		BAIL_OUT;
	}

	//check for filterlist & filteractions, if not available bail out

	if(g_NshPolStoreHandle.GetBatchmodeStatus())
	{
		bFAExists=g_NshPolNegFilData.GetNegPolFromCacheByName(pRuleData->pszFAName,&pNegPolData);
	}
	if(!bFAExists)
	{
		if(!(bFAExists=GetNegPolFromStore(&pNegPolData,pRuleData->pszFAName,hPolicyStorage)))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_5,pRuleData->pszFAName);
			dwReturnCode=ERROR_INVALID_DATA;
			BAIL_OUT;
		}
	}
	if(g_NshPolStoreHandle.GetBatchmodeStatus())
	{
		bFLExists=g_NshPolNegFilData.GetFilterListFromCacheByName(pRuleData->pszFLName,&pFilterData);
	}

	if(!bFLExists)
	{
		if(!(bFLExists=GetFilterListFromStore(&pFilterData,pRuleData->pszFLName,hPolicyStorage,bFilterExists)))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_1,pRuleData->pszFLName);
			dwReturnCode=ERROR_INVALID_DATA;
			BAIL_OUT;
		}
	}
	else  // if no filters bail out
	{
		if(pFilterData->dwNumFilterSpecs > 0)
		{
			bFilterExists=TRUE;
		}
	}

	if( !bFilterExists && bFLExists)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_6,pRuleData->pszFLName);
		dwReturnCode=ERROR_INVALID_DATA;
		BAIL_OUT;
	}
	//if everything is in place , proceed

	if(bPolicyExists && bFAExists && bFLExists && bFilterExists)
	{
		dwReturnCode=AddRule(pPolicyData, pRuleData, pNegPolData, pFilterData,hPolicyStorage ) ;
		if(dwReturnCode!=ERROR_SUCCESS)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_7,pRuleData->pszRuleName);
		}
	}
	ClosePolicyStore(hPolicyStorage);
	if(pPolicyData)
	{
		FreePolicyData(pPolicyData);
	}
error:
	return dwReturnCode;
}

////////////////////////////////////////////////////////////
//
//Function: CheckRuleExistance( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN  PIPSEC_POLICY_DATA pPolicy,
//	IN  PRULEDATA pRuleData
//
//Return: BOOL
//
//Description:
//	This function checks whether the user specified rule already exists.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

BOOL
CheckForRuleExistance(
	IN  PIPSEC_POLICY_DATA pPolicy,
	IN  LPTSTR pszRuleName
	)
{
	BOOL bRuleExists=FALSE;

	//check whether the specified rule already exists

	for (DWORD n = 0; n <  pPolicy->dwNumNFACount ; n++)
	{
		if (pPolicy->ppIpsecNFAData[n]->pszIpsecName && pszRuleName &&(_tcscmp(pPolicy->ppIpsecNFAData[n]->pszIpsecName,pszRuleName)==0))
		{
			bRuleExists=TRUE;
			break;
		}
	}
	return bRuleExists;
}


////////////////////////////////////////////////////////////
//
//Function: FillAddRuleInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PRULEDATA* ppFilterData,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticAddRule,
//	IN const TOKEN_VALUE *vlistStaticAddRule
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
	FillAddRuleInfo(
	OUT PRULEDATA* ppRuleData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticAddRule
	)
{
	DWORD dwCount=0, dwReturn=ERROR_SUCCESS , dwStrLength = 0;
	PRULEDATA pRuleData=new RULEDATA;
	PSTA_AUTH_METHODS pKerbAuth = NULL;
	PSTA_AUTH_METHODS pPskAuth = NULL;
	PSTA_MM_AUTH_METHODS *ppRootcaMMAuth = NULL;

	if(pRuleData == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memset(pRuleData,0,sizeof(RULEDATA));

	// default is that new rule is active
	pRuleData->bActivate = TRUE;
	
	for(dwCount=0; dwCount<parser.MaxTok; dwCount++)
	{
		switch(vtokStaticAddRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszRuleName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszRuleName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszRuleName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_POLICY 		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszPolicyName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszPolicyName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszPolicyName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_DESCR 		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszRuleDescription = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszRuleDescription == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszRuleDescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_FILTERLIST 	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszFLName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszFLName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszFLName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_FILTERACTION	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszFAName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszFAName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszFAName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_TUNNEL 		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pRuleData->TunnelIPAddress = *(IPADDR *)parser.Cmd[dwCount].pArg;
								if(pRuleData->TunnelIPAddress)
								{
									pRuleData->bTunnel=TRUE;
								}
								else
								{
									pRuleData->bTunnel=FALSE;
								}

								ADDR addr;
								addr.uIpAddr = ntohl(pRuleData->TunnelIPAddress);
								addr.uSubNetMask = 0;
								if (!IsValidTunnelEndpointAddress(&addr))
								{
									dwReturn = ERROR_INVALID_PARAMETER;
									BAIL_OUT;
								}
							}
							else
							{
								// if special server specified, give a warning, and proceed with no tunnel
								switch(parser.Cmd[dwCount].dwStatus)
								{
									case SERVER_DNS 	:
									case SERVER_WINS	:
									case SERVER_DHCP 	:
									case SERVER_GATEWAY	:

									default				:PrintMessageFromModule(g_hModule,ADD_STATIC_RULE_INVALID_TUNNEL);
														 break;
								}
							}
							break;
			case CMD_TOKEN_CONNTYPE 	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pRuleData->ConnectionType = *(IF_TYPE *)parser.Cmd[dwCount].pArg;
								pRuleData->bConnectionTypeSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_ACTIVATE 	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pRuleData->bActivate = *(BOOL *)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_KERB             :
							if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pKerbAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_PSK			:
							if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pPskAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_ROOTCA		:
							// this case is special, handled below...
							break;
			default						:
							break;
		}
	}

	size_t uiRootcaIndex = parser.MaxTok;
	if (parser.Cmd[uiRootcaIndex].dwStatus > 0)
	{
		pRuleData->bAuthMethodSpecified = TRUE;
		pRuleData->AuthInfos.dwNumAuthInfos += parser.Cmd[uiRootcaIndex].dwStatus;
		ppRootcaMMAuth = (PSTA_MM_AUTH_METHODS *)(parser.Cmd[uiRootcaIndex].pArg);
	}

	dwReturn = AddAllAuthMethods(pRuleData, pKerbAuth, pPskAuth, ppRootcaMMAuth, TRUE);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

error:   // if default auth loading failed, clean up everything and make 'pRuleData' as NULL
	CleanupAuthData(&pKerbAuth, &pPskAuth, ppRootcaMMAuth);
	if(dwReturn==ERROR_SUCCESS && pRuleData->dwAuthInfos > 0)
	{
		*ppRuleData=pRuleData;
	}
	else
	{
		if(dwReturn != ERROR_OUTOFMEMORY)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_7,pRuleData->pszRuleName);
		}
		else
		{
			PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		}

		CleanUpLocalRuleDataStructure(pRuleData);
	}
	CleanUp();

	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: AddDefaultResponseRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN OUT PIPSEC_POLICY_DATA pPolicy,
//	IN HANDLE hPolicyStorage,
//	IN BOOL bActivateDefaultRule
//Return: DWORD
//
//Description:
//	This function adds the NFA structure to the policy for default response rule
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
AddDefaultResponseRule(
	IN OUT PIPSEC_POLICY_DATA pPolicy,
	IN HANDLE hPolicyStorage,
	IN BOOL bActivateDefaultRule,
	IN BOOL bActivateDefaultRuleSpecified
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	BOOL bCertConversionSuceeded=TRUE;

	PIPSEC_NFA_DATA pRule = MakeDefaultResponseRule(bActivateDefaultRule,bActivateDefaultRuleSpecified);
	// form policy data structures
	if(pRule ==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	// if cert specified, and decode/ancode failed, bail out
	if(!bCertConversionSuceeded)
	{
		dwReturn=ERROR_INVALID_DATA;
		BAIL_OUT;
	}

	pPolicy->dwNumNFACount=1;
	pPolicy->ppIpsecNFAData = (PIPSEC_NFA_DATA *) IPSecAllocPolMem(sizeof(PIPSEC_NFA_DATA));

	if(pPolicy->ppIpsecNFAData ==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	// call the APIs
	pPolicy->ppIpsecNFAData[pPolicy->dwNumNFACount-1] = pRule;

	pRule->pIpsecNegPolData->NegPolType = GUID_NEGOTIATION_TYPE_DEFAULT;

	//create default negpol
	dwReturn = IPSecCreateNegPolData(hPolicyStorage, pRule->pIpsecNegPolData);

	if (dwReturn == ERROR_SUCCESS)
	{
		dwReturn=CreatePolicyData(hPolicyStorage, pPolicy);

		if(dwReturn==ERROR_SUCCESS)
		{
			dwReturn =IPSecCreateNFAData(hPolicyStorage,pPolicy->PolicyIdentifier, pRule);
			if(dwReturn!=ERROR_SUCCESS)
			{
				IPSecDeleteISAKMPData(hPolicyStorage, pPolicy->ISAKMPIdentifier);
				IPSecDeleteNegPolData(hPolicyStorage, pRule->NegPolIdentifier);
				DeletePolicyData(hPolicyStorage, pPolicy);
			}
		}
		else
		{
			IPSecDeleteNegPolData(hPolicyStorage, pRule->NegPolIdentifier);
		}
	}

error:
	if(dwReturn == ERROR_OUTOFMEMORY)
	{
		dwReturn = ERROR_SUCCESS;
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
	}
	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: MakeDefaultResponseRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN BOOL bActivate,
//	IN BOOL bActivateSpecified
//
//Return: PIPSEC_NFA_DATA
//
//Description:
//	This function fills the NFA structure for default response rule
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

PIPSEC_NFA_DATA
MakeDefaultResponseRule (
	IN BOOL bActivate,
	IN BOOL bActivateSpecified
	)
{
	RPC_STATUS     RpcStat =RPC_S_OK , dwReturn = ERROR_SUCCESS;
	PIPSEC_NFA_DATA pRule = (PIPSEC_NFA_DATA) IPSecAllocPolMem(sizeof(IPSEC_NFA_DATA));

	if(pRule == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	memset(pRule,0,sizeof(IPSEC_NFA_DATA));

	//no name, desc, interface name or endpoint name dor default rule

	pRule->pszIpsecName = pRule->pszDescription = pRule->pszInterfaceName = pRule->pszEndPointName = NULL;
	RpcStat = UuidCreate(&(pRule->NFAIdentifier));
	if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn=ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}

	pRule->dwWhenChanged = 0;

	// filter list
	pRule->pIpsecFilterData = NULL;
	RpcStat = UuidCreateNil(&(pRule->FilterIdentifier));
	if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn=ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}

	pRule->pIpsecNegPolData = MakeDefaultResponseNegotiationPolicy ();

	if(pRule->pIpsecNegPolData == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pRule->NegPolIdentifier = pRule->pIpsecNegPolData->NegPolIdentifier;

	// tunnel address
	pRule->dwTunnelFlags = 0;

	// interface type
	pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_ALL;

	// active flag
	if(bActivateSpecified)
	{
		pRule->dwActiveFlag = bActivate;
	}
	else
	{
		pRule->dwActiveFlag = TRUE;
	}

	// auth methods = Kerberos for the time being
	pRule->dwAuthMethodCount = 1;
	pRule->ppAuthMethods = (PIPSEC_AUTH_METHOD *) IPSecAllocPolMem(pRule->dwAuthMethodCount * sizeof(PIPSEC_AUTH_METHOD));
	if(pRule->ppAuthMethods==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	pRule->ppAuthMethods[0] = (PIPSEC_AUTH_METHOD) IPSecAllocPolMem(sizeof(IPSEC_AUTH_METHOD));
	pRule->ppAuthMethods[0]->dwAuthType = IKE_SSPI;
	pRule->ppAuthMethods[0]->dwAuthLen = 0;
	pRule->ppAuthMethods[0]->pszAuthMethod = NULL;

error:
	if(dwReturn == ERROR_OUTOFMEMORY || dwReturn == ERROR_INVALID_PARAMETER)
	{
		if(pRule)
		{
			CleanUpAuthInfo(pRule);	//this function frees only auth info.
			IPSecFreePolMem(pRule);	//since the above fn is used in other fns also, this free is required to cleanup other rule memory
			pRule = NULL;
		}
	}
	return pRule;
}


////////////////////////////////////////////////////////////
//
//Function: MakeDefaultResponseNegotiationPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	VOID
//
//Return: PIPSEC_NEGPOL_DATA
//
//Description:
//	This function fills the NegPol structure for default response rule
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

PIPSEC_NEGPOL_DATA
MakeDefaultResponseNegotiationPolicy (
	VOID
	)
{
	RPC_STATUS RpcStat=RPC_S_OK;
	DWORD dwReturn = ERROR_SUCCESS;
	_TCHAR pFAName[MAXSTRLEN]={0};
	PIPSEC_NEGPOL_DATA pNegPol = (PIPSEC_NEGPOL_DATA) IPSecAllocPolMem(sizeof(IPSEC_NEGPOL_DATA));

	if(pNegPol == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	RpcStat = UuidCreate(&(pNegPol->NegPolIdentifier));
	if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn=ERROR_INVALID_PARAMETER;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_STATIC_INTERNAL_ERROR);
		BAIL_OUT;
	}

	pNegPol->NegPolAction = GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;
	pNegPol->NegPolType = GUID_NEGOTIATION_TYPE_DEFAULT;
	pNegPol->dwSecurityMethodCount = 6;

	// allocate sec.methods
	pNegPol->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *) IPSecAllocPolMem(pNegPol->dwSecurityMethodCount * sizeof(IPSEC_SECURITY_METHOD));
	if(pNegPol->pIpsecSecurityMethods==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	// method 0 - ESP[3DES, SHA1]
	pNegPol->pIpsecSecurityMethods[0].Lifetime.KeyExpirationBytes = 0;
	pNegPol->pIpsecSecurityMethods[0].Lifetime.KeyExpirationTime = 0;
	pNegPol->pIpsecSecurityMethods[0].Flags = 0;
	pNegPol->pIpsecSecurityMethods[0].PfsQMRequired = FALSE;
	pNegPol->pIpsecSecurityMethods[0].Count = 1;
	pNegPol->pIpsecSecurityMethods[0].Algos[0].algoIdentifier = CONF_ALGO_3_DES;
	pNegPol->pIpsecSecurityMethods[0].Algos[0].secondaryAlgoIdentifier = AUTH_ALGO_SHA1;
	pNegPol->pIpsecSecurityMethods[0].Algos[0].algoKeylen = 0;
	pNegPol->pIpsecSecurityMethods[0].Algos[0].algoRounds = 0;
	pNegPol->pIpsecSecurityMethods[0].Algos[0].operation = Encrypt;

	// method 1 - ESP[3DES, MD5]
	pNegPol->pIpsecSecurityMethods[1].Lifetime.KeyExpirationBytes = 0;
	pNegPol->pIpsecSecurityMethods[1].Lifetime.KeyExpirationTime = 0;
	pNegPol->pIpsecSecurityMethods[1].Flags = 0;
	pNegPol->pIpsecSecurityMethods[1].PfsQMRequired = FALSE;
	pNegPol->pIpsecSecurityMethods[1].Count = 1;
	pNegPol->pIpsecSecurityMethods[1].Algos[0].algoIdentifier = CONF_ALGO_3_DES;
	pNegPol->pIpsecSecurityMethods[1].Algos[0].secondaryAlgoIdentifier = AUTH_ALGO_MD5;
	pNegPol->pIpsecSecurityMethods[1].Algos[0].algoKeylen = 0;
	pNegPol->pIpsecSecurityMethods[1].Algos[0].algoRounds = 0;
	pNegPol->pIpsecSecurityMethods[1].Algos[0].operation = Encrypt;

	// method 2 - ESP[DES, SHA1]
	pNegPol->pIpsecSecurityMethods[2].Lifetime.KeyExpirationBytes = 0;
	pNegPol->pIpsecSecurityMethods[2].Lifetime.KeyExpirationTime = 0;
	pNegPol->pIpsecSecurityMethods[2].Flags = 0;
	pNegPol->pIpsecSecurityMethods[2].PfsQMRequired = FALSE;
	pNegPol->pIpsecSecurityMethods[2].Count = 1;
	pNegPol->pIpsecSecurityMethods[2].Algos[0].algoIdentifier = CONF_ALGO_DES;
	pNegPol->pIpsecSecurityMethods[2].Algos[0].secondaryAlgoIdentifier = AUTH_ALGO_SHA1;
	pNegPol->pIpsecSecurityMethods[2].Algos[0].algoKeylen = 0;
	pNegPol->pIpsecSecurityMethods[2].Algos[0].algoRounds = 0;
	pNegPol->pIpsecSecurityMethods[2].Algos[0].operation = Encrypt;

	// method 3 - ESP[DES, MD5]
	pNegPol->pIpsecSecurityMethods[3].Lifetime.KeyExpirationBytes = 0;
	pNegPol->pIpsecSecurityMethods[3].Lifetime.KeyExpirationTime = 0;
	pNegPol->pIpsecSecurityMethods[3].Flags = 0;
	pNegPol->pIpsecSecurityMethods[3].PfsQMRequired = FALSE;
	pNegPol->pIpsecSecurityMethods[3].Count = 1;
	pNegPol->pIpsecSecurityMethods[3].Algos[0].algoIdentifier = CONF_ALGO_DES;
	pNegPol->pIpsecSecurityMethods[3].Algos[0].secondaryAlgoIdentifier = AUTH_ALGO_MD5;
	pNegPol->pIpsecSecurityMethods[3].Algos[0].algoKeylen = 0;
	pNegPol->pIpsecSecurityMethods[3].Algos[0].algoRounds = 0;
	pNegPol->pIpsecSecurityMethods[3].Algos[0].operation = Encrypt;

	// method 4 - AH[SHA1]
	pNegPol->pIpsecSecurityMethods[4].Lifetime.KeyExpirationBytes = 0;
	pNegPol->pIpsecSecurityMethods[4].Lifetime.KeyExpirationTime = 0;
	pNegPol->pIpsecSecurityMethods[4].Flags = 0;
	pNegPol->pIpsecSecurityMethods[4].PfsQMRequired = FALSE;
	pNegPol->pIpsecSecurityMethods[4].Count = 1;
	pNegPol->pIpsecSecurityMethods[4].Algos[0].algoIdentifier = AUTH_ALGO_SHA1;
	pNegPol->pIpsecSecurityMethods[4].Algos[0].secondaryAlgoIdentifier = AUTH_ALGO_NONE;
	pNegPol->pIpsecSecurityMethods[4].Algos[0].algoKeylen = 0;
	pNegPol->pIpsecSecurityMethods[4].Algos[0].algoRounds = 0;
	pNegPol->pIpsecSecurityMethods[4].Algos[0].operation = Auth;

	// method 5 - AH[MD5]
	pNegPol->pIpsecSecurityMethods[5].Lifetime.KeyExpirationBytes = 0;
	pNegPol->pIpsecSecurityMethods[5].Lifetime.KeyExpirationTime = 0;
	pNegPol->pIpsecSecurityMethods[5].Flags = 0;
	pNegPol->pIpsecSecurityMethods[5].PfsQMRequired = FALSE;
	pNegPol->pIpsecSecurityMethods[5].Count = 1;
	pNegPol->pIpsecSecurityMethods[5].Algos[0].algoIdentifier = AUTH_ALGO_MD5;
	pNegPol->pIpsecSecurityMethods[5].Algos[0].secondaryAlgoIdentifier = AUTH_ALGO_NONE;
	pNegPol->pIpsecSecurityMethods[5].Algos[0].algoKeylen = 0;
	pNegPol->pIpsecSecurityMethods[5].Algos[0].algoRounds = 0;
	pNegPol->pIpsecSecurityMethods[5].Algos[0].operation = Auth;

	// not necessary to change to bounded printf

	_stprintf(pFAName, _TEXT(""));
	pNegPol->pszIpsecName = IPSecAllocPolStr(pFAName);
	if(pNegPol->pszIpsecName==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pNegPol->pszDescription = NULL;

error:
	if(dwReturn == ERROR_OUTOFMEMORY || dwReturn==ERROR_INVALID_PARAMETER)
	{
		if(pNegPol)
		{
			if(pNegPol->pIpsecSecurityMethods)
			{
				IPSecFreePolMem(pNegPol->pIpsecSecurityMethods);
			}
			IPSecFreePolMem(pNegPol);
			pNegPol = NULL;
		}
	}

	return pNegPol;
}

////////////////////////////////////////////////////////////
//
//Function: MakeNegotiationPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PIPSEC_NEGPOL_DATA *ppNegPol,
//	IN PFILTERACTION pFilterAction
//
//Return: DWORD
//
//Description:
//	This function fills the Negpol structure based of the user input
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
MakeNegotiationPolicy(
	OUT PIPSEC_NEGPOL_DATA *ppNegPol,
	IN PFILTERACTION pFilterAction
	)
{
	RPC_STATUS RpcStat=RPC_S_OK;
	DWORD i=0,dwReturn = ERROR_SUCCESS;
	PIPSEC_NEGPOL_DATA pNegPol = (PIPSEC_NEGPOL_DATA) IPSecAllocPolMem(sizeof(IPSEC_NEGPOL_DATA));

	if(pNegPol == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	memset(pNegPol,0,sizeof(IPSEC_NEGPOL_DATA));

	RpcStat = UuidCreate(&(pNegPol->NegPolIdentifier));
	if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn=ERROR_INVALID_PARAMETER;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_STATIC_INTERNAL_ERROR);
		BAIL_OUT;
	}
	// start with action=negotiate
	pNegPol->NegPolAction = GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;
	pNegPol->NegPolType = GUID_NEGOTIATION_TYPE_STANDARD;
	pNegPol->dwSecurityMethodCount = pFilterAction->dwNumSecMethodCount;

	//if soft , increment the count

	if(pFilterAction->bSoft)
	{
		pNegPol->dwSecurityMethodCount++;
	}

	if(pNegPol->dwSecurityMethodCount)
	{
		pNegPol->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *) IPSecAllocPolMem(pNegPol->dwSecurityMethodCount * sizeof(IPSEC_SECURITY_METHOD));
		if(pNegPol->pIpsecSecurityMethods==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}

	// handle sec.methods
	for (i = 0; i <  pFilterAction->dwNumSecMethodCount; i++)
	{
		DWORD j;
		pNegPol->pIpsecSecurityMethods[i].Lifetime.KeyExpirationBytes = pFilterAction->pIpsecSecMethods[i].Lifetime.uKeyExpirationKBytes;
		pNegPol->pIpsecSecurityMethods[i].Lifetime.KeyExpirationTime  = pFilterAction->pIpsecSecMethods[i].Lifetime.uKeyExpirationTime;
		pNegPol->pIpsecSecurityMethods[i].Flags = 0;
		pNegPol->pIpsecSecurityMethods[i].PfsQMRequired = pFilterAction->bQMPfs;
		pNegPol->pIpsecSecurityMethods[i].Count = pFilterAction->pIpsecSecMethods[i].dwNumAlgos;
		for (j = 0; j <  pNegPol->pIpsecSecurityMethods[i].Count && j < QM_MAX_ALGOS; j++)
		{
			pNegPol->pIpsecSecurityMethods[i].Algos[j].algoIdentifier = pFilterAction->pIpsecSecMethods[i].Algos[j].uAlgoIdentifier;
			pNegPol->pIpsecSecurityMethods[i].Algos[j].secondaryAlgoIdentifier = pFilterAction->pIpsecSecMethods[i].Algos[j].uSecAlgoIdentifier;
			pNegPol->pIpsecSecurityMethods[i].Algos[j].algoKeylen = pFilterAction->pIpsecSecMethods[i].Algos[j].uAlgoKeyLen;
			pNegPol->pIpsecSecurityMethods[i].Algos[j].algoRounds = pFilterAction->pIpsecSecMethods[i].Algos[j].uAlgoRounds;
			switch (pFilterAction->pIpsecSecMethods[i].Algos[j].Operation)
			{
				case AUTHENTICATION:
					pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = Auth;
					break;
				case ENCRYPTION:
					pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = Encrypt;
					break;
				default:
					pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = None;
			}
		}
	}

	// add soft
	if (pFilterAction->bSoft)
	{
		memset(&(pNegPol->pIpsecSecurityMethods[pNegPol->dwSecurityMethodCount - 1]), 0, sizeof(IPSEC_SECURITY_METHOD));
	}

	if(pFilterAction->pszFAName)
	{
		pNegPol->pszIpsecName = IPSecAllocPolStr(pFilterAction->pszFAName);
		if(pNegPol->pszIpsecName==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}

	if(pFilterAction->pszFADescription)
	{
		pNegPol->pszDescription = IPSecAllocPolStr(pFilterAction->pszFADescription);
		if(pNegPol->pszDescription==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}
// fill the relevent guid for action, got from the user
	pNegPol->NegPolAction=pFilterAction->NegPolAction;

error: //clean up

	if(dwReturn == ERROR_OUTOFMEMORY)
	{
		if(pNegPol)
		{
			if(pNegPol->pIpsecSecurityMethods)
			{
				IPSecFreePolMem(pNegPol->pIpsecSecurityMethods);
			}
			IPSecFreePolMem(pNegPol);
			pNegPol=NULL;
		}
	}
	*ppNegPol= pNegPol;

	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: GetNegPolFromStore()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PIPSEC_NEGPOL_DATA *ppNegPol,
//	IN LPTSTR pszFAName,
//	IN HANDLE hPolicyStorage
//
//Return: BOOL
//
//Description:
//	This function retrives the user specified NegPol data from the policy store
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

BOOL
GetNegPolFromStore(
	OUT PIPSEC_NEGPOL_DATA *ppNegPol,
	IN LPTSTR pszFAName,
	IN HANDLE hPolicyStorage
	)
{
	PIPSEC_NEGPOL_DATA *ppNegPolEnum  = NULL,pNegPolData=NULL;
	DWORD   dwNumNegPol=0 ;
	BOOL bNegPolExists=FALSE;
	DWORD dwReturnCode=ERROR_SUCCESS, i=0;

	//enum and get the filteraction from the store

	dwReturnCode = IPSecEnumNegPolData(hPolicyStorage, &ppNegPolEnum, &dwNumNegPol);
	if (dwReturnCode == ERROR_SUCCESS && dwNumNegPol> 0 && ppNegPolEnum != NULL)
	{
		for (i = 0; i <  dwNumNegPol; i++)
		{
			if ((ppNegPolEnum[i]->pszIpsecName!=NULL)&&( _tcscmp(ppNegPolEnum[i]->pszIpsecName, pszFAName) == 0))
			{
				bNegPolExists=TRUE;
				dwReturnCode = IPSecCopyNegPolData(ppNegPolEnum[i],&pNegPolData);
				break;
			}
		}
		if (dwNumNegPol > 0 && ppNegPolEnum != NULL)
		{
			IPSecFreeMulNegPolData(ppNegPolEnum, dwNumNegPol);
		}
	}
	if(pNegPolData)
	{
		*ppNegPol=pNegPolData;
	}
	return bNegPolExists;
}

////////////////////////////////////////////////////////////
//
//Function: GetFilterListFromStore()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PIPSEC_FILTER_DATA *ppFilter,
//	IN LPTSTR pszFLName,
//	IN HANDLE hPolicyStorage,
//	IN OUT BOOL &bFilterExists
//
//Return: BOOL
//
//Description:
//	This function retrives the user specified Filter list data from the policy store
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

BOOL
GetFilterListFromStore(
	OUT PIPSEC_FILTER_DATA *ppFilter,
	IN LPTSTR pszFLName,
	IN HANDLE hPolicyStorage,
	IN OUT BOOL &bFilterExists
	)
{
	PIPSEC_FILTER_DATA *ppFilterEnum  = NULL,pFilterData=NULL;
	DWORD   dwNumFilter=0 , i=0 ;
	BOOL bFilterListExists=FALSE;
	DWORD dwReturnCode=ERROR_SUCCESS;

	//enum and get the filterlist from the store

	dwReturnCode = IPSecEnumFilterData(hPolicyStorage, &ppFilterEnum, &dwNumFilter);
	if (dwReturnCode == ERROR_SUCCESS && dwNumFilter> 0 && ppFilterEnum != NULL)
	{
		for (i = 0; i <  dwNumFilter; i++)
		{
			if ((ppFilterEnum[i]->pszIpsecName!=NULL)&&( _tcscmp(ppFilterEnum[i]->pszIpsecName, pszFLName) == 0))
			{
				bFilterListExists=TRUE;
				dwReturnCode = IPSecCopyFilterData(ppFilterEnum[i],&pFilterData);
				if(ppFilterEnum[i]->dwNumFilterSpecs > 0)
				{
					bFilterExists=TRUE;
				}
				break;
			}
		}
		if (dwNumFilter > 0 && ppFilterEnum != NULL)
		{
			IPSecFreeMulFilterData(ppFilterEnum, dwNumFilter);
		}
	}
	if(pFilterData)
	{
		*ppFilter=pFilterData;
	}
	return bFilterListExists;
}

////////////////////////////////////////////////////////////
//
//Function: GetPolicyFromStore()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PIPSEC_POLICY_DATA *ppPolicy,
//	IN LPTSTR szPolicyName,
//	IN HANDLE hPolicyStorage
//
//Return: BOOL
//
//Description:
//	This function retrives the user specified Policy data from the policy store
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

BOOL
GetPolicyFromStore(
	OUT PIPSEC_POLICY_DATA *ppPolicy,
	IN LPTSTR szPolicyName,
	IN HANDLE hPolicyStorage
	)
{
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	BOOL bPolicyExists=FALSE;
	DWORD  dwNumPolicies = 0,i=0,j=0;
	DWORD dwReturnCode=ERROR_SUCCESS;
	RPC_STATUS     RpcStat =RPC_S_OK;

	//enum and get the policy from the store

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		BAIL_OUT;
	}

	for (i = 0; i <  dwNumPolicies; i++)
	{
		if (szPolicyName && _tcscmp(ppPolicyEnum[i]->pszIpsecName, szPolicyName) == 0)
		{
			bPolicyExists=TRUE;
			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);

			if (dwReturnCode == ERROR_SUCCESS)
			{
				dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
										  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));
			}
			if (dwReturnCode == ERROR_SUCCESS)
			{
				dwReturnCode = IPSecGetISAKMPData(hPolicyStorage, pPolicy->ISAKMPIdentifier, &(pPolicy->pIpsecISAKMPData));

				if(dwReturnCode==ERROR_SUCCESS )
				{
					for (j = 0; j <  pPolicy->dwNumNFACount; j++)
					{
						if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->NegPolIdentifier), &RpcStat))
						{
							IPSecGetNegPolData(hPolicyStorage,
										 pPolicy->ppIpsecNFAData[j]->NegPolIdentifier,
										 &(pPolicy->ppIpsecNFAData[j]->pIpsecNegPolData));
						}
					}
				}
			}
		}
	}

	// clean it up
	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}

	if(pPolicy)
	{
		*ppPolicy=pPolicy;
	}
error:
	return bPolicyExists;
}

////////////////////////////////////////////////////////////
//
//Function: MakeRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PRULEDATA pRuleData,
//	IN PIPSEC_NEGPOL_DATA pNegPolData,
//	IN PIPSEC_FILTER_DATA pFilterData,
//  IN OUT BOOL &bCertConversionSuceeded
//
//Return: PIPSEC_NFA_DATA
//
//Description:
//	This function forms the NFA data structure basedon the user input.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

PIPSEC_NFA_DATA
MakeRule(
	IN PRULEDATA pRuleData,
	IN PIPSEC_NEGPOL_DATA pNegPolData,
	IN PIPSEC_FILTER_DATA pFilterData,
	IN OUT BOOL &bCertConversionSuceeded
	)
{
	RPC_STATUS     RpcStat =RPC_S_OK;
	DWORD dwReturn = ERROR_SUCCESS;

	PIPSEC_NFA_DATA pRule = (PIPSEC_NFA_DATA) IPSecAllocPolMem(sizeof(IPSEC_NFA_DATA));
	if(pRule==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memset(pRule,0,sizeof(IPSEC_NFA_DATA));

	pRule->pszIpsecName = pRule->pszDescription = pRule->pszInterfaceName = pRule->pszEndPointName = NULL;

	//rule name

	if (pRuleData->pszRuleName)
	{
		pRule->pszIpsecName = IPSecAllocPolStr(pRuleData->pszRuleName);

		if(pRule->pszIpsecName==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}
	//rule desc

	if (pRuleData->pszRuleDescription)
	{
		pRule->pszDescription = IPSecAllocPolStr(pRuleData->pszRuleDescription);

		if(pRule->pszDescription==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}

	RpcStat = UuidCreate(&(pRule->NFAIdentifier));
	if (!(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY))
	{
		dwReturn=ERROR_INVALID_PARAMETER;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_STATIC_INTERNAL_ERROR);
		BAIL_OUT;
	}

	pRule->dwWhenChanged = 0;

	//filterlist

	pRule->pIpsecFilterData = NULL;
	pRule->FilterIdentifier = pFilterData->FilterIdentifier;

	//filteraction

	pRule->pIpsecNegPolData = NULL;
	pRule->NegPolIdentifier = pNegPolData->NegPolIdentifier;

	// tunnel address
	pRule->dwTunnelFlags = 0;
	pRule->dwTunnelIpAddr= 0;

	if (pRuleData->bTunnel)
	{
	   pRule->dwTunnelFlags = 1;
	   pRule->dwTunnelIpAddr = pRuleData->TunnelIPAddress;
	}

	// interface type
	if (pRuleData->ConnectionType == INTERFACE_TYPE_ALL)
	{
	   pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_ALL;
	}
	else if (pRuleData->ConnectionType == INTERFACE_TYPE_LAN)
	{
	   pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_LAN;
	}
	else if (pRuleData->ConnectionType == INTERFACE_TYPE_DIALUP)
	{
	   pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_DIALUP;
	}
	else
	{
	   pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_NONE;
	}

   	// active flag
	pRule->dwActiveFlag = pRuleData->bActivate;

	// auth methods
	pRule->dwAuthMethodCount = pRuleData->AuthInfos.dwNumAuthInfos;
	pRule->ppAuthMethods = (PIPSEC_AUTH_METHOD *) IPSecAllocPolMem(pRule->dwAuthMethodCount * sizeof(PIPSEC_AUTH_METHOD));

	if(pRule->ppAuthMethods==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	dwReturn = LoadAuthenticationInfos(pRuleData->AuthInfos, pRule,bCertConversionSuceeded);

 error:
 	if(dwReturn == ERROR_OUTOFMEMORY || dwReturn == ERROR_INVALID_PARAMETER)
 	{
		if(pRule)
		{
			CleanUpAuthInfo(pRule);	 //this function frees only auth info.
			IPSecFreePolMem(pRule);	 //since the above fn is used in other fns also, this free is required to cleanup other rule memory
			pRule = NULL;
		}
	}

 	return pRule;
}

////////////////////////////////////////////////////////////
//
//Function: DecodeCertificateName()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LPBYTE EncodedName,
//	IN DWORD EncodedNameLength,
//	IN OUT LPTSTR *ppszSubjectName
//
//Return: DWORD
//
//Description:
//	This function decodes the certificate name  based on the user input.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
DecodeCertificateName (
	IN LPBYTE EncodedName,
	IN DWORD EncodedNameLength,
	IN OUT LPTSTR *ppszSubjectName
	)
{
    DWORD DecodedNameLength=0, dwReturn=ERROR_SUCCESS;
	CERT_NAME_BLOB CertName;

	CertName.cbData = EncodedNameLength;
	CertName.pbData = EncodedName;

	//this API call is to get the size

	DecodedNameLength = CertNameToStr(
		X509_ASN_ENCODING,
		&CertName,
		CERT_X500_NAME_STR,
		NULL,
		NULL);

	if (!DecodedNameLength)
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}

	(*ppszSubjectName)= new _TCHAR[DecodedNameLength];

	if (*ppszSubjectName == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	//this API call is for conversion

	DecodedNameLength = CertNameToStr(
		X509_ASN_ENCODING,
		&CertName,
		CERT_X500_NAME_STR,
		*ppszSubjectName,
		DecodedNameLength);

	if (!DecodedNameLength)
	{
		delete (*ppszSubjectName);
		(*ppszSubjectName) = 0;
		dwReturn = ERROR_INVALID_PARAMETER;
	}

error:
    return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: AddRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN OUT PIPSEC_POLICY_DATA pPolicy,
//	IN PRULEDATA pRuleData,
//	IN PIPSEC_NEGPOL_DATA pNegPolData,
//	IN PIPSEC_FILTER_DATA pFilterData ,
//	IN HANDLE hPolicyStorage
//
//Return: DWORD
//
//Description:
//	This function adds the already formed NFA structure to the policy specified.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
AddRule(
	IN OUT PIPSEC_POLICY_DATA pPolicy,
	IN PRULEDATA pRuleData,
	IN PIPSEC_NEGPOL_DATA pNegPolData,
	IN PIPSEC_FILTER_DATA pFilterData ,
	IN HANDLE hPolicyStorage
	)
{
	DWORD dwReturnCode = ERROR_SUCCESS;
	BOOL bCertConversionSuceeded=TRUE;
	PIPSEC_NFA_DATA pRule = MakeRule(pRuleData, pNegPolData, pFilterData,bCertConversionSuceeded);

	if(pRule ==NULL)
	{
		dwReturnCode = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	if(!bCertConversionSuceeded)
	{
		dwReturnCode = ERROR_INVALID_DATA;
		BAIL_OUT;
	}

	// form rule data structures
	pPolicy->dwNumNFACount++;
	pPolicy->ppIpsecNFAData = (PIPSEC_NFA_DATA *) ReAllocRuleMem(pPolicy->ppIpsecNFAData
						  , (pPolicy->dwNumNFACount-1), pPolicy->dwNumNFACount);

	if(pPolicy->ppIpsecNFAData ==NULL)
	{
		dwReturnCode = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	pPolicy->ppIpsecNFAData[pPolicy->dwNumNFACount-1] = pRule;

	// Create Rule
	dwReturnCode=IPSecCreateNFAData(hPolicyStorage, pPolicy->PolicyIdentifier, pRule);

	if(dwReturnCode==ERROR_SUCCESS)
	{
		dwReturnCode=SetPolicyData(hPolicyStorage, pPolicy);
	}

error:
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturnCode = ERROR_SUCCESS;
	}

	return dwReturnCode;
}

////////////////////////////////////////////////////////////
//
//Function: LoadIkeDefaults()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN  PPOLICYDATA pPolicy,
//	OUT IPSEC_MM_OFFER **ppIpSecMMOffer
//
//Return: DWORD
//
//Description:
//	This function loads the IKE default values
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
LoadIkeDefaults(
	IN PPOLICYDATA pPolicy,
	OUT IPSEC_MM_OFFER **ppIpSecMMOffer
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	pPolicy->dwOfferCount = 3;
	IPSEC_MM_OFFER *pOffers = new IPSEC_MM_OFFER[pPolicy->dwOfferCount];
	if(pOffers == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	memset(pOffers, 0, sizeof(IPSEC_MM_OFFER) * (pPolicy->dwOfferCount));

	// init these
	for (DWORD i = 0; i < pPolicy->dwOfferCount; ++i)
	{
		pOffers[i].dwQuickModeLimit = pPolicy->dwQMLimit;
		pOffers[i].Lifetime.uKeyExpirationKBytes = 0;
		pOffers[i].Lifetime.uKeyExpirationTime = pPolicy->LifeTimeInSeconds;
	}
	// 3DES-SHA1-2
	pOffers[0].EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
	pOffers[0].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	pOffers[0].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;

	pOffers[0].HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_SHA1;
	pOffers[0].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;

	pOffers[0].dwDHGroup = POTF_OAKLEY_GROUP2;

	// 3DES-MD5-2

	pOffers[1].EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
	pOffers[1].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	pOffers[1].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;

	pOffers[1].HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_MD5;
	pOffers[1].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;

	pOffers[1].dwDHGroup = POTF_OAKLEY_GROUP2;

	// 3DES-SHA1-3

	pOffers[2].EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
	pOffers[2].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
	pOffers[2].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;

	pOffers[2].HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_SHA1;
	pOffers[2].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;

	pOffers[2].dwDHGroup = POTF_OAKLEY_GROUP2048;

	*ppIpSecMMOffer=pOffers;

error:
	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: LoadOfferDefaults()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PIPSEC_QM_OFFER & pOffers,
//	OUT DWORD & dwNumOffers
//
//Return: DWORD
//
//Description:
//	This function fills the Offers structure with default values
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
LoadOfferDefaults(
	OUT PIPSEC_QM_OFFER & pOffers,
	OUT DWORD & dwNumOffers
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	dwNumOffers = 2;
	DWORD i=0;

	pOffers = new IPSEC_QM_OFFER[dwNumOffers];
	if(pOffers == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memset(pOffers, 0, sizeof(IPSEC_QM_OFFER) * dwNumOffers);

	for (i = 0; i < dwNumOffers; ++i)
	{
		pOffers[i].Lifetime.uKeyExpirationKBytes  = POTF_DEFAULT_P2REKEY_BYTES;
		pOffers[i].Lifetime.uKeyExpirationTime   = POTF_DEFAULT_P2REKEY_TIME;
		pOffers[i].bPFSRequired = FALSE;
		pOffers[i].dwPFSGroup = 0;
		pOffers[i].dwFlags = 0;
		pOffers[i].dwNumAlgos = 1;
		pOffers[i].Algos[0].Operation = ENCRYPTION;
	}
	//esp[3des,sha1]

	pOffers[0].Algos[0].uAlgoIdentifier = CONF_ALGO_3_DES;
	pOffers[0].Algos[0].uSecAlgoIdentifier = HMAC_AUTH_ALGO_SHA1;

	//esp[3des,md5]
	pOffers[1].Algos[0].uAlgoIdentifier = CONF_ALGO_3_DES;
	pOffers[1].Algos[0].uSecAlgoIdentifier = HMAC_AUTH_ALGO_MD5;
error:
	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: CheckPolicyExistance()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage,
//	IN LPTSTR pszPolicyName
//
//Return: BOOL
//
//Description:
//	This function checks whether the specified policy exists in Policy store.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

BOOL
CheckPolicyExistance(
	IN HANDLE hPolicyStorage,
	IN LPTSTR pszPolicyName
	)
{
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL;
	BOOL bPolicyExists=FALSE;
	DWORD dwNumPolicies=0;
	DWORD dwReturnCode=ERROR_SUCCESS;

	// check whether the policy already exists in store

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);
	if (dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		for (DWORD i = 0; i <  dwNumPolicies; i++)
			if (_tcscmp(ppPolicyEnum[i]->pszIpsecName, pszPolicyName) == 0)
			{
				bPolicyExists=TRUE;
				break;
			}
			if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
			{
				IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
			}
	}
	return bPolicyExists;
}

////////////////////////////////////////////////////////////
//
//Function: ReAllocRuleMem()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_NFA_DATA *ppOldMem,
//	IN DWORD cbOld,
//	IN DWORD cbNew
//
//Return: PIPSEC_NFA_DATA*
//
//Description:
//	This function reallocates the memory for the NFA structure.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

PIPSEC_NFA_DATA*
ReAllocRuleMem(
	IN PIPSEC_NFA_DATA *ppOldMem,
	IN DWORD cbOld,
	IN DWORD cbNew
	)
{
	PIPSEC_NFA_DATA * ppNewMem=NULL;
	DWORD j=0;

	//reallocate the NFA mem

	ppNewMem= (PIPSEC_NFA_DATA *) IPSecAllocPolMem(cbNew * sizeof(PIPSEC_NFA_DATA));

	if (ppNewMem)
	{
		for(DWORD i=0;i<min(cbNew, cbOld);i++)
		{
			while(!ppOldMem[j])
				j++;
			ppNewMem[i]=ppOldMem[j];
			j++;
		}
		IPSecFreePolMem(ppOldMem);
	}

	return ppNewMem;
}

////////////////////////////////////////////////////////////
//
//Function: ReAllocFilterSpecMem()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_SPEC * ppOldMem,
//	IN DWORD cbOld,
//	IN DWORD cbNew
//
//Return: PIPSEC_FILTER_SPEC *
//
//Description:
//	This function reallocates the Filter Spec memory
//
//Revision History:
//
//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
////////////////////////////////////////////////////////////

PIPSEC_FILTER_SPEC *
ReAllocFilterSpecMem(
	IN PIPSEC_FILTER_SPEC * ppOldMem,
	IN DWORD cbOld,
	IN DWORD cbNew
	)
{
    PIPSEC_FILTER_SPEC * ppNewMem=NULL;
    DWORD j=0;

	ppNewMem= (PIPSEC_FILTER_SPEC *) IPSecAllocPolMem(cbNew * sizeof(PIPSEC_FILTER_SPEC));

	// reallocate the filterspec memory

	if(ppNewMem)
	{
		for(DWORD i=0;i<min(cbNew, cbOld);i++)
		{
			while(!ppOldMem[j])
				j++;
			ppNewMem[i]=ppOldMem[j];
			j++;
		}
		IPSecFreePolMem(ppOldMem);
	}
    return ppNewMem;
}


////////////////////////////////////////////////////////////
//
//Function: ValidateFilterSpec()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PPOLICYDATA pPolicyData
//
//Return: DWORD
//
//Description:
//	This function validates the Filter Spec details
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
ValidateFilterSpec(
	IN PFILTERDATA pFilterData
	)
{
	DWORD dwReturn=ERROR_SUCCESS;
	ADDR SrcAddr,DstAddr;

	SrcAddr.uIpAddr=htonl(pFilterData->SourceAddr.puIpAddr[0]);
	SrcAddr.uSubNetMask=htonl(pFilterData->SourMask);

	DstAddr.uIpAddr=htonl(pFilterData->DestnAddr.puIpAddr[0]);
	DstAddr.uSubNetMask=htonl(pFilterData->DestMask);

	if(!pFilterData->SourceAddr.pszDomainName)
	{
		// if only IP addr specified
		if(pFilterData->bSrcAddrSpecified && !pFilterData->bSrcMaskSpecified)
		{
			if(pFilterData->SourceAddr.puIpAddr[0]!=0)
			{
				if(!bIsValidIPAddress(htonl(pFilterData->SourceAddr.puIpAddr[0]),TRUE,TRUE))
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_6);
					dwReturn=ERROR_INVALID_DATA;
					BAIL_OUT;
				}
			}
		}
		else if(pFilterData->bSrcAddrSpecified && pFilterData->bSrcMaskSpecified)
		{
			// if both IP and mask specified
			if(!((pFilterData->SourceAddr.puIpAddr[0]==0) && ((pFilterData->SourMask==0)||(pFilterData->SourMask==MASK_ME))))
			{
				SrcAddr.AddrType= IP_ADDR_UNIQUE;
				if (!IsValidSubnettedAddress(&SrcAddr) && !IsValidSubnet(&SrcAddr))
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_7);
					dwReturn=ERROR_INVALID_DATA;
					BAIL_OUT;
				}
			}
		}
	}

	if(!pFilterData->DestnAddr.pszDomainName)
	{
		// if only IP addr specified
		if(pFilterData->bDstAddrSpecified && !pFilterData->bDstMaskSpecified)
		{
			if(pFilterData->DestnAddr.puIpAddr[0]!=0)
			{
				if(!bIsValidIPAddress(htonl(pFilterData->DestnAddr.puIpAddr[0]),TRUE,TRUE))
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_11);
					dwReturn=ERROR_INVALID_DATA;
					BAIL_OUT;
				}
			}
		}
		else if(pFilterData->bDstAddrSpecified && pFilterData->bDstMaskSpecified)
		{
			// if both IP and mask specified
			if(!((pFilterData->DestnAddr.puIpAddr[0]==0)&& ((pFilterData->DestMask==0)||(pFilterData->DestMask==MASK_ME))))
			{
				DstAddr.AddrType= IP_ADDR_UNIQUE;
				if(!IsValidSubnettedAddress(&DstAddr) && !IsValidSubnet(&DstAddr))
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_12);
					dwReturn=ERROR_INVALID_DATA;
					BAIL_OUT;
				}
			}
		}
	}

	if(!pFilterData->DestnAddr.pszDomainName && !pFilterData->SourceAddr.pszDomainName)
	{
		// check for address conflict
		if(!(pFilterData->bSrcServerSpecified || pFilterData->bDstServerSpecified))
		{
			SrcAddr.AddrType=IP_ADDR_SUBNET;
			DstAddr.AddrType=IP_ADDR_SUBNET;

			if(AddressesConflict(SrcAddr,DstAddr))
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_8);
				dwReturn=ERROR_INVALID_DATA;
				BAIL_OUT;
			}
		}
	}

	if(pFilterData->DestnAddr.pszDomainName && pFilterData->SourceAddr.pszDomainName)
	{
		// check for same src and dst DNS names
		if(_tcscmp(pFilterData->SourceAddr.pszDomainName,pFilterData->DestnAddr.pszDomainName)==0)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_8);
			dwReturn=ERROR_INVALID_DATA;
			BAIL_OUT;
		}
	}

	if(pFilterData->bSrcServerSpecified || pFilterData->bDstServerSpecified)
	{
		//validate special server
		if(!IsSpecialServ(ExTypeToAddrType(pFilterData->ExType)))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_9);
			dwReturn=ERROR_INVALID_DATA;
			BAIL_OUT;
		}
	}

	if(pFilterData->bSrcServerSpecified || pFilterData->bDstServerSpecified)
	{
		if(pFilterData->ExType==EXT_NORMAL)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_10);
			dwReturn=ERROR_INVALID_DATA;
			BAIL_OUT;
		}
	}

	if(pFilterData->bSrcServerSpecified && pFilterData->bDstServerSpecified)
	{
		// check if both sides servers specified
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_3);
		dwReturn=ERROR_INVALID_DATA;
	}

error:
	return dwReturn;
}


////////////////////////////////////////////////////////////
//
//Function: CheckFilterListExistance()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage,
//	IN LPTSTR pszFLName
//
//Return: BOOL
//
//Description:
//	This function checks whether the specified filterlist exists in Policy store.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

BOOL
CheckFilterListExistance(
	IN HANDLE hPolicyStorage,
	IN LPTSTR pszFLName
	)
{
	PIPSEC_FILTER_DATA *ppFilterEnum  = NULL;
	BOOL bFilterExists=FALSE;
	DWORD dwNumFilters=0;
	DWORD dwReturnCode=ERROR_SUCCESS;

	// check for duplicate Filterlist on same name

	dwReturnCode = IPSecEnumFilterData(hPolicyStorage, &ppFilterEnum, &dwNumFilters);
	if (dwReturnCode == ERROR_SUCCESS && dwNumFilters > 0 && ppFilterEnum != NULL)
	{
		DWORD i;
		for (i = 0; i <  dwNumFilters; i++)
		{
			if ( pszFLName && ppFilterEnum[i]->pszIpsecName && ( _tcscmp(ppFilterEnum[i]->pszIpsecName, pszFLName) == 0))
			{
				bFilterExists=TRUE;
				break;
			}
		}
		if(ppFilterEnum && dwNumFilters>0)
		{
			IPSecFreeMulFilterData(	ppFilterEnum,dwNumFilters);
		}
	}
	return bFilterExists;
}

////////////////////////////////////////////////////////////
//
//Function: CheckFilterActionExistance()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage,
//	IN LPTSTR pszFAName
//
//Return: BOOL
//
//Description:
//	This function checks whether the specified filteraction exists in Policy store.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

BOOL
CheckFilterActionExistance(
	IN HANDLE hPolicyStorage,
	IN LPTSTR pszFAName
	)
{
	PIPSEC_NEGPOL_DATA *ppNegPolEnum  = NULL;
	BOOL bNegPolExists=FALSE;
	DWORD dwNumNegPol=0;
	DWORD dwReturnCode=ERROR_SUCCESS;

	// check for duplicate Filteraction on same name

	dwReturnCode = IPSecEnumNegPolData(hPolicyStorage, &ppNegPolEnum, &dwNumNegPol);
	if (dwReturnCode == ERROR_SUCCESS && dwNumNegPol> 0 && ppNegPolEnum != NULL)
	{
		DWORD i;
		for (i = 0; i <  dwNumNegPol; i++)
		{
			if (ppNegPolEnum[i]->pszIpsecName && pszFAName && ( _tcscmp(ppNegPolEnum[i]->pszIpsecName, pszFAName) == 0))
			{
				bNegPolExists=TRUE;
				break;
			}
		}

		if (dwNumNegPol > 0 && ppNegPolEnum != NULL)
		{
			IPSecFreeMulNegPolData(	ppNegPolEnum,dwNumNegPol);
		}
	}
	return bNegPolExists;
}

////////////////////////////////////////////////////////////
//
//Function: LoadAuthenticationInfos()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN INT_MM_AUTH_METHODS AuthInfos,
//	IN OUT PIPSEC_NFA_DATA &pRule
//
//Return: DWORD
//
//Description:
//	This function loads the authentication details
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////


DWORD
LoadAuthenticationInfos(
	IN STA_AUTH_METHODS AuthInfos,
	IN OUT PIPSEC_NFA_DATA &pRule,
	IN OUT BOOL &bCertConversionSuceeded
	)
{
	DWORD 	dwReturn = ERROR_SUCCESS;
	BOOL bWarningPrinted = FALSE;

	for (DWORD i = 0; i <  pRule->dwAuthMethodCount; i++)
	{
		pRule->ppAuthMethods[i] = (PIPSEC_AUTH_METHOD) IPSecAllocPolMem(sizeof(IPSEC_AUTH_METHOD));
		if(pRule->ppAuthMethods[i]== NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		ZeroMemory(pRule->ppAuthMethods[i], sizeof(IPSEC_AUTH_METHOD));
		pRule->ppAuthMethods[i]->dwAuthType = AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->AuthMethod;
		if (pRule->ppAuthMethods[i]->dwAuthType == IKE_SSPI)   //kerb
		{
		   pRule->ppAuthMethods[i]->dwAuthLen = 0;
		   pRule->ppAuthMethods[i]->pszAuthMethod = NULL;
		   pRule->ppAuthMethods[i]->dwAltAuthLen = 0;
		   pRule->ppAuthMethods[i]->pAltAuthMethod = NULL;
		   pRule->ppAuthMethods[i]->dwAuthFlags  = 0;
		}
		else if (pRule->ppAuthMethods[i]->dwAuthType == IKE_RSA_SIGNATURE)   //cert
		{
			LPTSTR pTemp = NULL;
			pRule->ppAuthMethods[i]->dwAuthFlags  = AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->dwAuthFlags;
			pRule->ppAuthMethods[i]->dwAltAuthLen = AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->dwAuthInfoSize;
			pRule->ppAuthMethods[i]->pAltAuthMethod = (PBYTE) IPSecAllocPolMem(AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->dwAuthInfoSize);
			if(pRule->ppAuthMethods[i]->pAltAuthMethod==NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			memcpy(pRule->ppAuthMethods[i]->pAltAuthMethod, AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->pAuthInfo, AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->dwAuthInfoSize);
			dwReturn = DecodeCertificateName(pRule->ppAuthMethods[i]->pAltAuthMethod, pRule->ppAuthMethods[i]->dwAltAuthLen, &pTemp);

			if(dwReturn != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_UPDATING_INFO);
				bCertConversionSuceeded=FALSE;
			}
			pRule->ppAuthMethods[i]->pszAuthMethod = IPSecAllocPolStr(pTemp);
			if(pRule->ppAuthMethods[i]->pszAuthMethod == NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}

			pRule->ppAuthMethods[i]->dwAuthLen = wcslen(pRule->ppAuthMethods[i]->pszAuthMethod);
			delete [] pTemp;
		}
		else  if (pRule->ppAuthMethods[i]->dwAuthType == IKE_PRESHARED_KEY)   //preshared key
		{
			pRule->ppAuthMethods[i]->dwAuthLen = AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->dwAuthInfoSize / sizeof(WCHAR);
			pRule->ppAuthMethods[i]->pszAuthMethod = (LPWSTR) IPSecAllocPolMem(AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->dwAuthInfoSize + sizeof(WCHAR));
			if(pRule->ppAuthMethods[i]->pszAuthMethod==NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			memcpy(pRule->ppAuthMethods[i]->pszAuthMethod, AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->pAuthInfo, AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo->dwAuthInfoSize);
			pRule->ppAuthMethods[i]->pszAuthMethod[pRule->ppAuthMethods[i]->dwAuthLen] = 0;
			pRule->ppAuthMethods[i]->dwAltAuthLen = 0;
			pRule->ppAuthMethods[i]->pAltAuthMethod = NULL;
			pRule->ppAuthMethods[i]->dwAuthFlags  = 0;
		}
	}
error:
	return dwReturn;
}

////////////////////////////////////////////////////////////
//
//Function: ConvertMMAuthToStaticLocal()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo,
//	IN DWORD dwAuthInfos,
//	IN OUT STA_AUTH_METHODS &AuthInfos
//
//Return: DWORD
//
//Description:
//	This function converts the PINT_IPSEC_MM_AUTH_INFO structure to STA_AUTH_METHODS
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD
ConvertMMAuthToStaticLocal(
	IN PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo,
	IN DWORD dwAuthInfos,
	IN OUT STA_AUTH_METHODS &AuthInfos
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	DWORD i = 0 ;

	if(pAuthenticationInfo == NULL || dwAuthInfos == 0 )
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}

	AuthInfos.dwNumAuthInfos = dwAuthInfos;
	AuthInfos.pAuthMethodInfo = new STA_MM_AUTH_METHODS[AuthInfos.dwNumAuthInfos];
	if(AuthInfos.pAuthMethodInfo == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	for(i=0;i<AuthInfos.dwNumAuthInfos;i++)
	{
		memset(&(AuthInfos.pAuthMethodInfo[i]),0,sizeof(STA_MM_AUTH_METHODS));
		AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo = new INT_IPSEC_MM_AUTH_INFO;
		if(AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo == NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		memset(AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo ,0,sizeof(INT_IPSEC_MM_AUTH_INFO));
		memcpy( AuthInfos.pAuthMethodInfo[i].pAuthenticationInfo , &(pAuthenticationInfo[i]),sizeof(INT_IPSEC_MM_AUTH_INFO));
	}

error:
	return dwReturn;

}

DWORD
ConnectStaticMachine(
	IN  LPCWSTR  pwszMachine,
	IN  DWORD dwLocation
	)
{
    DWORD dwReturnCode;
    HANDLE hPolicyStorage;
    LPWSTR pszTarget = NULL;
    
	// Connect to the appropriate store
	//
	dwReturnCode = 
	    IPSecOpenPolicyStore(
            (LPWSTR)pwszMachine, 
            dwLocation, 
            NULL, 
            &hPolicyStorage);

	if (dwReturnCode == ERROR_SUCCESS) 
	{
	    if (dwLocation == IPSEC_DIRECTORY_PROVIDER)
	    {
	        pszTarget = g_StorageLocation.pszDomainName;
	    }
	    else
	    {
	        pszTarget = g_StorageLocation.pszMachineName;
	    }
	    
		if (pwszMachine)
		{
			_tcsncpy(pszTarget, pwszMachine,MAXCOMPUTERNAMELEN-1);
		}
		else
		{
			_tcsncpy(pszTarget, _TEXT(""), 2);
		}
		
        g_StorageLocation.dwLocation = dwLocation;
        
		g_NshPolStoreHandle.SetStorageHandle(hPolicyStorage);
    }

    return dwReturnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticadd.h ===
////////////////////////////////////////////////////////////
//Header: staticadd.h
//
// Purpose: 	Defining structures and prototypes for staticadd.cpp.
//
// Developers Name: surya
//
// Revision History:
//
//   Date    		Author    	Comments
//	21th Aug 2001	surya		Initial Version.
//
////////////////////////////////////////////////////////////

#ifndef _STATICADD_H_
#define _STATICADD_H_


const DWORD   MMPFS_QM_LIMIT 					= 1;
const time_t  P2STORE_DEFAULT_KBLIFE 			= 0;
const time_t  P2STORE_DEFAULT_LIFETIME 			= POTF_DEFAULT_P1REKEY_TIME;//60 * 480; by VKR to reflect the IPSECCMD defaults
const time_t  QM_DEFAULT_LIFETIMEINKILOBYTES 	= 0;
const time_t  QM_DEFAULT_LIFETIMEINSECONDS 		= 0;
const ULONG   POTF_OAKLEY_ALGOKEYLEN   			= 64;
const ULONG   POTF_OAKLEY_ALGOROUNDS   			= 8;
const DWORD   PROTOCOL_ANY   					= 0;
const WORD    PORT_ANY   						= 0;
const WORD    DEF_NUMBER_OF_ADDR				= 1;
const DWORD   ADDR_ME							= 0x00000000;
const DWORD   MASK_ME							= 0xFFFFFFFF;



typedef struct _FILTERDATA {
	LPTSTR pszFLName;
	LPTSTR pszDescription;
	GUID  FilterSpecGUID;
	DNSIPADDR SourceAddr;
	BOOL bSrcAddrSpecified;
	DWORD SourMask;
	BOOL bSrcMaskSpecified;
	DNSIPADDR DestnAddr;
	BOOL bDstAddrSpecified;
	DWORD DestMask;
	BOOL bDstMaskSpecified;
	DWORD TunnAddr;
	BOOL  TunnFiltExists;
	BOOL  bMirrored;
	DWORD dwProtocol;
	WORD SourPort;
	WORD DestPort;
	UCHAR ExType;
	BOOL bSrcServerSpecified;
	BOOL bDstServerSpecified;
	BOOL bSrcMeSpecified;
	BOOL bSrcAnySpecified;
	BOOL bDstMeSpecified;
	BOOL bDstAnySpecified;
}FILTERDATA, *PFILTERDATA;

extern BOOL
IsDomainMember(
	IN LPTSTR pszMachine
	);

//
//Add policy prototypes
//
DWORD
CreateNewPolicy(
	IN PPOLICYDATA pPolicyData
	);

DWORD
LoadIkeDefaults(
	IN OUT PPOLICYDATA pPolicy,
	OUT IPSEC_MM_OFFER **ppIpSecMMOffer
	);

DWORD
AddDefaultResponseRule(
	IN OUT PIPSEC_POLICY_DATA pPolicy,
	IN HANDLE hPolicyStorage,
	IN BOOL bActivateDefaultRule,
	IN BOOL bActivateDefaultRuleSpecified
	);

PIPSEC_NFA_DATA
MakeDefaultResponseRule (
	IN BOOL bActivate,
	IN BOOL bActivateSpecified
	);

PIPSEC_NEGPOL_DATA
MakeDefaultResponseNegotiationPolicy (
	VOID
	);

BOOL
CheckPolicyExistance(
	IN HANDLE hPolicyStorage,
	IN LPTSTR pszPolicyName
	);
//
//Add filter action proto types
//
DWORD
LoadOfferDefaults(
	OUT PIPSEC_QM_OFFER & pOffers,
	OUT DWORD & dwNumOffers
	);

DWORD
MakeNegotiationPolicy(
	OUT PIPSEC_NEGPOL_DATA *ppNegPol,
	IN PFILTERACTION pFilterAction
	);
//
//Add rule
//
DWORD
CreateNewRule(
	IN PRULEDATA pRuleData
	);

BOOL
GetPolicyFromStore(
	OUT PIPSEC_POLICY_DATA *ppPolicy,
	IN LPTSTR szPolicyName,
	IN HANDLE hPolicyStorage
	);

BOOL
GetFilterListFromStore(
	OUT PIPSEC_FILTER_DATA *ppFilter,
	IN LPTSTR pszFLName,
	IN HANDLE hPolicyStorage,
	IN OUT BOOL &bFilterExists
	);

BOOL
GetNegPolFromStore(
	OUT PIPSEC_NEGPOL_DATA *ppNegPol,
	IN LPTSTR pszFAName,
	IN HANDLE hPolicyStorage
	);

PIPSEC_NFA_DATA
MakeRule(
	IN PRULEDATA pRuleData,
	IN PIPSEC_NEGPOL_DATA pNegPolData,
	IN PIPSEC_FILTER_DATA pFilterData
	);

DWORD
AddRule(
	IN OUT PIPSEC_POLICY_DATA pPolicy,
	IN PRULEDATA pRuleData,
	IN PIPSEC_NEGPOL_DATA pNegPolData,
	IN PIPSEC_FILTER_DATA pFilterData ,
	IN HANDLE hPolicyStorage
	);

DWORD
LoadAuthenticationInfos(
	IN STA_AUTH_METHODS AuthInfos,
	IN OUT PIPSEC_NFA_DATA &pRule,
	IN OUT BOOL &bCertConversionSuceeded
	);

PIPSEC_NFA_DATA*
ReAllocRuleMem(
	IN PIPSEC_NFA_DATA *ppOldMem,
	IN DWORD cbOld,
	IN DWORD cbNew
	);

DWORD
DecodeCertificateName (
	IN LPBYTE EncodedName,
	IN DWORD EncodedNameLength,
	IN OUT LPTSTR *ppszSubjectName
	);
//
//Add Filter
//
PIPSEC_FILTER_SPEC *
ReAllocFilterSpecMem(
	IN PIPSEC_FILTER_SPEC * ppOldMem,
	IN DWORD cbOld,
	IN DWORD cbNew
	);

DWORD
FillAddPolicyInfo(
	OUT PPOLICYDATA* ppFilter,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticAddPolicy
	);

DWORD
FillAddFilterInfo(
	OUT PFILTERDATA* ppFilterData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticAddFilter
	);

DWORD
FillAddFilterActionInfo(
	OUT PFILTERACTION* ppFilterData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticAddFilterAction
	);

DWORD
FillAddRuleInfo(
	OUT PRULEDATA* ppRuleData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticAddRule
	);

//
//add filterlist
//
DWORD
CreateNewFilterList(
	IN HANDLE hPolicyStorage,
	IN LPTSTR pszFLName,
	IN LPTSTR pszFLDescription
	);

DWORD
ValidateFilterSpec(
	IN PFILTERDATA pFilterData
	);

BOOL
CheckForRuleExistance(
	IN  PIPSEC_POLICY_DATA pPolicy,
	IN  LPTSTR pszRuleName
	);

BOOL
CheckFilterListExistance(
	IN HANDLE hPolicyStorage,
	IN LPTSTR pszFLName
	);

BOOL
CheckFilterActionExistance(
	IN HANDLE hPolicyStorage,
	IN LPTSTR pszFAName
	);

DWORD
ConvertMMAuthToStaticLocal(
	IN PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo,
	IN DWORD dwAuthInfos,
	IN OUT STA_AUTH_METHODS &AuthInfos
	);

DWORD
ConnectStaticMachine(
	IN  LPCWSTR  pwszMachine,
	IN  DWORD dwLocation
	);

#endif //_STATICADD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticdelete.cpp ===
////////////////////////////////////////////////////////////
// Module: Static/Staticdelete.cpp
//
// Purpose: 	Static Module Implementation.
//
// Developers Name: surya
//
// History:
//
// Date    		Author    	Comments
// 10-8-2001	Bharat		Initial Version.
// 21-8-2001	Surya
////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern STORAGELOCATION g_StorageLocation;
extern CNshPolStore g_NshPolStoreHandle;
extern CNshPolNegFilData g_NshPolNegFilData;

////////////////////////////////////////////////////////////
//
//Function: HandleStaticDeletePolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Delete Policy"
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticDeletePolicy(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	BOOL bExists=FALSE;
	BOOL bAll=FALSE,bAssigned=FALSE,bCompleteDelete=FALSE;
	LPTSTR pszPolicyName=NULL;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	DWORD   dwNumPolicies = 0,dwRet = ERROR_SHOW_USAGE,dwCount=0,i=0;
	HANDLE hPolicyStorage=NULL;
	_TCHAR szUserInput[STRING_SIZE]={0};
	DWORD   dwReturnCode   = ERROR_SUCCESS,dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticDeletePolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_ALL,			NS_REQ_ZERO,	  FALSE	}
	};

	const TOKEN_VALUE vtokStaticDeletePolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 	},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 	}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticDeletePolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticDeletePolicy);

	parser.ValidCmd   = vcmdStaticDeletePolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticDeletePolicy);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	//get the user input

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticDeletePolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszPolicyName= new _TCHAR[dwStrLength+1];
						if(pszPolicyName == NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszPolicyName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_ALL :
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						bAll= *(BOOL *)parser.Cmd[dwCount].pArg;
					}
					break;
			default:
					break;
		}
	}

	CleanUp();

	bCompleteDelete = TRUE;
	dwReturnCode = OpenPolicyStore(&hPolicyStorage);

	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
		dwRet= ERROR_SUCCESS;
		BAIL_OUT;
	}

	//check for the required policy

	for (i = 0; i <  dwNumPolicies; i++)
	{
		if ( bAll || (pszPolicyName && (_tcscmp(ppPolicyEnum[i]->pszIpsecName, pszPolicyName) == 0)))
		{
			bExists=TRUE;
			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
			if (dwReturnCode != ERROR_SUCCESS)
			{
				dwRet = dwReturnCode;
				BAIL_OUT;
			}

			dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
							  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

			if (dwReturnCode == ERROR_SUCCESS)
			{
				dwReturnCode=IPSecGetISAKMPData(hPolicyStorage, pPolicy->ISAKMPIdentifier, &(pPolicy->pIpsecISAKMPData));
			}

			if((dwReturnCode == ERROR_SUCCESS)&& !bAssigned )
			{
				if(g_StorageLocation.dwLocation!=IPSEC_DIRECTORY_PROVIDER)
				{
					dwReturnCode=IsAssigned(pPolicy,hPolicyStorage,bAssigned);
				}
				if(((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode == ERROR_FILE_NOT_FOUND))&& bAssigned)
				{
					dwReturnCode=IPSecUnassignPolicy(hPolicyStorage, pPolicy->PolicyIdentifier);
				}
			}
			if (((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode == ERROR_FILE_NOT_FOUND)))
			{
				// if found, proceed deleting

				dwReturnCode = DeletePolicy(pPolicy,hPolicyStorage,bCompleteDelete);
				if (dwReturnCode != ERROR_SUCCESS)
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_POLICY_3,pPolicy->pszIpsecName);
				}
			}

		}
		if((!bAll && bExists)||(dwReturnCode != ERROR_SUCCESS))
			break;
	}

	//incase due to some thing deletion failed, tell it to the user

	if((!bExists)&& (!bAll) && (dwReturnCode == ERROR_SUCCESS))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_POLICY_2,pszPolicyName);
	}
	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
	dwRet= ERROR_SUCCESS;

	if (pPolicy)
	{
		IPSecFreePolicyData(pPolicy);
	}
	ClosePolicyStore(hPolicyStorage);

error:
	if (pszPolicyName)
	{
		delete [] pszPolicyName;
	}
    return dwRet;
}

////////////////////////////////////////////////////////////
//
//Function: HandleStaticDeleteFilterList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Delete FilterList"
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticDeleteFilterList(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )

{

	LPTSTR pszFListName=NULL;
	DWORD dwCount=0;
	PIPSEC_FILTER_DATA *ppFilterEnum  = NULL,pFilter=NULL;
	DWORD  dwNumFilters=0,cnt=0,dwRet = ERROR_SHOW_USAGE;
	HANDLE hPolicyStorage=NULL;
	_TCHAR szUserInput[STRING_SIZE]={0};
	BOOL bExists=FALSE,bAll=FALSE;
	DWORD dwReturnCode   = ERROR_SUCCESS,dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticDeleteFilterList[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_ALL,			NS_REQ_ZERO,	  FALSE	}
	};

	const TOKEN_VALUE vtokStaticDeleteFilterList[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 	},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 	}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticDeleteFilterList;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticDeleteFilterList);

	parser.ValidCmd   = vcmdStaticDeleteFilterList;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticDeleteFilterList);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet !=ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed user input

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticDeleteFilterList[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszFListName= new _TCHAR[dwStrLength+1];
						if(pszFListName == NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}

						_tcsncpy(pszFListName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_ALL :
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						bAll= *(BOOL *)parser.Cmd[dwCount].pArg;
					}
					break;
			default:
					break;
		}
	}

	CleanUp();

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);

	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecEnumFilterData(hPolicyStorage, &ppFilterEnum, &dwNumFilters);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumFilters > 0 && ppFilterEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_FILTER_LIST);
		dwRet = ERROR_SUCCESS;
		BAIL_OUT;
	}

	// try to look for the specified filter

	for(cnt=0; cnt < dwNumFilters;cnt++)
	{
		if ( bAll ||((ppFilterEnum[cnt]->pszIpsecName)&&(pszFListName)&&(_tcscmp(ppFilterEnum[cnt]->pszIpsecName,pszFListName)==0)))
		{
			dwReturnCode = IPSecCopyFilterData(ppFilterEnum[cnt], &pFilter);

			if ((dwReturnCode == ERROR_SUCCESS) && (pFilter != NULL))
			{
				bExists=TRUE;
				dwReturnCode = DeleteFilterList(pFilter,hPolicyStorage);

				if (dwReturnCode == ERROR_INVALID_DATA)
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTERLIST_2,pFilter->pszIpsecName);

					// if cannot delete, tell the user where it is used

					ShowWhereFLUsed(pFilter,hPolicyStorage);
				}
				else if (dwReturnCode != ERROR_SUCCESS)
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTERLIST_ALL_FL_DEL_QUERY,pFilter->pszIpsecName);
				}
			}
		}
		if((!bAll && bExists)||((dwReturnCode != ERROR_SUCCESS)&&(dwReturnCode != ERROR_INVALID_DATA)))
			break;

	}

	// throw the error messages to the user

	if ((!bExists)&&(pszFListName)&&(dwReturnCode == ERROR_SUCCESS))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_PRTALLFL_3,pszFListName);
	}

	if(ppFilterEnum && dwNumFilters>0)
	{
		IPSecFreeMulFilterData(	ppFilterEnum,dwNumFilters);
	}
	if(pFilter)
	{
		IPSecFreeFilterData(pFilter);
	}

	dwRet = ERROR_SUCCESS;
	ClosePolicyStore(hPolicyStorage);

error:
	if(pszFListName)
	{
		delete [] pszFListName;
	}

    return dwRet;
}

////////////////////////////////////////////////////////////
//
//Function: HandleStaticDeleteFilter()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Delete Filter"
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticDeleteFilter(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )

{
	DWORD dwNumFilters = 0,dwRet = ERROR_SHOW_USAGE,dwReturn=0,i=0;
	PIPSEC_FILTER_DATA *ppFilterEnum = NULL,pFilterData=NULL;
	HANDLE hPolicyStorage=NULL;
	BOOL bFilterExists=FALSE;
	PDELFILTERDATA pFilter=NULL;
	DWORD  dwReturnCode   = ERROR_SUCCESS;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticDeleteFilter[] =
	{
		{ CMD_TOKEN_STR_FILTERLIST,		NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_SRCADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_DSTADDR,		NS_REQ_PRESENT,	  FALSE },
		{ CMD_TOKEN_STR_PROTO,			NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SRCMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTMASK,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SRCPORT,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_DSTPORT,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_MIRROR,			NS_REQ_ZERO,	  FALSE }
	};

	const TOKEN_VALUE vtokStaticDeleteFilter[] =
	{
		{ CMD_TOKEN_STR_FILTERLIST,		CMD_TOKEN_FILTERLIST },
		{ CMD_TOKEN_STR_SRCADDR,		CMD_TOKEN_SRCADDR	 },
		{ CMD_TOKEN_STR_DSTADDR,		CMD_TOKEN_DSTADDR	 },
		{ CMD_TOKEN_STR_PROTO,			CMD_TOKEN_PROTO		 },
		{ CMD_TOKEN_STR_SRCMASK,		CMD_TOKEN_SRCMASK	 },
		{ CMD_TOKEN_STR_DSTMASK,		CMD_TOKEN_DSTMASK	 },
		{ CMD_TOKEN_STR_SRCPORT,		CMD_TOKEN_SRCPORT	 },
		{ CMD_TOKEN_STR_DSTPORT,		CMD_TOKEN_DSTPORT	 },
		{ CMD_TOKEN_STR_MIRROR,			CMD_TOKEN_MIRROR	 }
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticDeleteFilter;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticDeleteFilter);

	parser.ValidCmd   = vcmdStaticDeleteFilter;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticDeleteFilter);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet!=ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed user input

	dwRet = FillDelFilterInfo(&pFilter,parser,vtokStaticDeleteFilter);

	if(dwReturn==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if(pFilter->bSrcServerSpecified && pFilter->bDstServerSpecified)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_3);
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);

	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecEnumFilterData(hPolicyStorage, &ppFilterEnum, &dwNumFilters);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumFilters > 0 && ppFilterEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_FILTER_LIST);
		dwRet = ERROR_SUCCESS;
		BAIL_OUT;
	}
	// check for the specified filterlist

	for (i = 0; i <  dwNumFilters; i++)
	{
		if ((ppFilterEnum[i]->pszIpsecName)&& (pFilter->pszFLName) && ( _tcscmp(ppFilterEnum[i]->pszIpsecName, pFilter->pszFLName) == 0))
		{
			bFilterExists=TRUE;
			dwReturnCode = IPSecCopyFilterData(ppFilterEnum[i], &pFilterData);
		}
		if	(bFilterExists)
			break;
	}
	if(!bFilterExists)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_PRTALLFL_3,pFilter->pszFLName);
	}
	if(ppFilterEnum && dwNumFilters>0)
	{
		IPSecFreeMulFilterData(	ppFilterEnum,dwNumFilters);
	}

	// check for the specified filterspec in the found filterlist

	if ( bFilterExists && dwReturnCode == ERROR_SUCCESS)
	{
		if(pFilterData->dwFlags & POLSTORE_READONLY )
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_FL_READ_ONLY_OBJECT,pFilterData->pszIpsecName);
			BAIL_OUT;
		}
		if (!DeleteSpecifiedFilter(pFilterData,pFilter))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTER_1,pFilter->pszFLName);
		}
		else
		{
			dwReturnCode = IPSecSetFilterData(hPolicyStorage, pFilterData);
			if (dwReturnCode != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTER_2,pFilter->pszFLName);
			}
		}
	}
	ClosePolicyStore(hPolicyStorage);
	dwRet=ERROR_SUCCESS;
error:
	CleanUpLocalDelFilterDataStructure(pFilter);

	return dwRet;
}

//////////////////////////////////////////////////////////////////
//
//Function: DeleteSpecifiedFilter()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN OUT PIPSEC_FILTER_DATA pFilterData,
//	IN PDELFILTERDATA pDeleteFilter
//
//Return: BOOL
//
//Description:
//	This function deletes a specific filter out of the filterlist
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

BOOL
DeleteSpecifiedFilter(
	IN OUT PIPSEC_FILTER_DATA pFilterData,
	IN PDELFILTERDATA pDeleteFilter
	)
{
	DWORD i=0;
	BOOL bFilterDeleted=FALSE;
	BOOL bDeletedFilter=FALSE;
	DWORD dwOldNumFilters=pFilterData->dwNumFilterSpecs;

	while(dwOldNumFilters > i)
	{
		if(
			(
			 pDeleteFilter->SourceAddr.puIpAddr && (pFilterData->ppFilterSpecs[i]->Filter.SrcAddr == pDeleteFilter->SourceAddr.puIpAddr[0]) ||
		     (
			  pDeleteFilter->SourceAddr.pszDomainName && pFilterData->ppFilterSpecs[i]->pszSrcDNSName &&
		      (_tcscmp(pFilterData->ppFilterSpecs[i]->pszSrcDNSName,pDeleteFilter->SourceAddr.pszDomainName)==0)
		     )
		    )
		    &&
			(
			 pDeleteFilter->DestnAddr.puIpAddr && (pFilterData->ppFilterSpecs[i]->Filter.DestAddr == pDeleteFilter->DestnAddr.puIpAddr[0]) ||
			 (
			  pDeleteFilter->DestnAddr.pszDomainName && pFilterData->ppFilterSpecs[i]->pszDestDNSName &&
			  (_tcscmp(pFilterData->ppFilterSpecs[i]->pszDestDNSName,pDeleteFilter->DestnAddr.pszDomainName)==0)
			 )
			)
		   )
		{
			bFilterDeleted=TRUE;
			if (pDeleteFilter->bMirrorSpecified)  // if mirror specified
			{
				if(pFilterData->ppFilterSpecs[i]->dwMirrorFlag == (DWORD) (pDeleteFilter->bMirrored))
				{
					bFilterDeleted=TRUE;
				}
				else
				{
					bFilterDeleted=FALSE;
				}
			}
			if (bFilterDeleted && pDeleteFilter->bSrcMaskSpecified) // if srcmask specified
			{
				if(pFilterData->ppFilterSpecs[i]->Filter.SrcMask == pDeleteFilter->SourMask)
				{
					bFilterDeleted=TRUE;
				}
				else
				{
					bFilterDeleted=FALSE;
				}
			}
			if (bFilterDeleted && pDeleteFilter->bDstMaskSpecified) // if dstmask specified
			{
				if(pFilterData->ppFilterSpecs[i]->Filter.DestMask == pDeleteFilter->DestMask)
				{
					bFilterDeleted=TRUE;
				}
				else
				{
					bFilterDeleted=FALSE;
				}
			}
			if (bFilterDeleted && pDeleteFilter->bProtocolSpecified)
			{
				if(pFilterData->ppFilterSpecs[i]->Filter.Protocol == pDeleteFilter->dwProtocol)
				{
					bFilterDeleted=TRUE;
				}
				else
				{
					bFilterDeleted=FALSE;
				}
			}
			if (bFilterDeleted && pDeleteFilter->bSrcPortSpecified)
			{
				if(pFilterData->ppFilterSpecs[i]->Filter.SrcPort == pDeleteFilter->SourPort)
				{
					bFilterDeleted=TRUE;
				}
				else
				{
					bFilterDeleted=FALSE;
				}
			}
			if (bFilterDeleted && pDeleteFilter->bDstPortSpecified)
			{
				if(pFilterData->ppFilterSpecs[i]->Filter.DestPort == pDeleteFilter->DestPort)
				{
					bFilterDeleted=TRUE;
				}
				else
				{
					bFilterDeleted=FALSE;
				}
			}
			if (bFilterDeleted && (pDeleteFilter->bSrcServerSpecified || pDeleteFilter->bDstServerSpecified))
			{
				if(pFilterData->ppFilterSpecs[i]->Filter.ExType == pDeleteFilter->ExType)
				{
					bFilterDeleted=TRUE;
				}
				else
				{
					bFilterDeleted=FALSE;
				}
			}
		}
		if(bFilterDeleted)  // if found delete and realloc memory
		{
			IPSecFreeFilterSpec(pFilterData->ppFilterSpecs[i]);
			pFilterData->ppFilterSpecs[i]=NULL;
			pFilterData->dwNumFilterSpecs--;
			bDeletedFilter=TRUE;
			bFilterDeleted=FALSE;
		}
		i++;
	}
	if(bDeletedFilter)
	{
		pFilterData->ppFilterSpecs=ReAllocFilterSpecMem(pFilterData->ppFilterSpecs,dwOldNumFilters,pFilterData->dwNumFilterSpecs);
	}

	return bDeletedFilter;
}


//////////////////////////////////////////////////////////////////
//
//Function: HandleStaticDeleteFilterActions()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Delete FilterActions"
//
//Revision History:
//
//Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticDeleteFilterActions(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{

	LPTSTR pszFactName=NULL;
	DWORD dwCount=0;
	PIPSEC_NEGPOL_DATA *ppNegPolEnum  = NULL,pNegPol=NULL;
	DWORD   dwNumNegPolicies=0,cnt=0,dwRet = ERROR_SHOW_USAGE;
	HANDLE hPolicyStorage=NULL;
	_TCHAR szUserInput[STRING_SIZE]={0};
	BOOL bExists=FALSE,bAll=FALSE;
	DWORD  dwReturnCode   = ERROR_SUCCESS , dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticDeleteFilterActions[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokStaticDeleteFilterActions[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticDeleteFilterActions;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticDeleteFilterActions);

	parser.ValidCmd   = vcmdStaticDeleteFilterActions;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticDeleteFilterActions);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}
	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticDeleteFilterActions[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszFactName= new _TCHAR[dwStrLength+1];
						if(pszFactName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszFactName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_ALL :
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						bAll= *(BOOL *)parser.Cmd[dwCount].pArg;
					}
					break;
			default:
					break;
		}
	}
	CleanUp();

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}
	dwReturnCode = IPSecEnumNegPolData(hPolicyStorage, &ppNegPolEnum, &dwNumNegPolicies);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumNegPolicies > 0 && ppNegPolEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_FILTER_ACTION);
		dwRet = ERROR_SUCCESS;
		BAIL_OUT;
	}
	// check for the specified filteraction

	for(cnt=0; cnt < dwNumNegPolicies;cnt++)
	{
		if(IsEqualGUID(ppNegPolEnum[cnt]->NegPolType,GUID_NEGOTIATION_TYPE_DEFAULT) ||(!ppNegPolEnum[cnt]->pszIpsecName))
		{
			DeleteFilterAction(ppNegPolEnum[cnt],hPolicyStorage);
			continue;
		}

		if (bAll || (pszFactName &&(_tcscmp(ppNegPolEnum[cnt]->pszIpsecName,pszFactName)==0)))
		{
			dwReturnCode = IPSecCopyNegPolData(ppNegPolEnum[cnt], &pNegPol);
			if ((dwReturnCode == ERROR_SUCCESS) && pNegPol)
			{
				bExists=TRUE;
				dwReturnCode = DeleteFilterAction(pNegPol,hPolicyStorage);

				if (dwReturnCode == ERROR_INVALID_DATA)
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTERACTION_2,pNegPol->pszIpsecName);
					ShowWhereFAUsed(pNegPol,hPolicyStorage);
				}
				else if (dwReturnCode != ERROR_SUCCESS)
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTERACTION_ALL_FA_DEL_QUERY,pNegPol->pszIpsecName);
				}
			}
		}
		if((!bAll && bExists)||((dwReturnCode != ERROR_SUCCESS)&&(dwReturnCode != ERROR_INVALID_DATA)))
			break;
	}
	// throw the error messages to the user

	if ((!bAll)&&(!bExists)&&(dwReturnCode == ERROR_SUCCESS))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_PRTALLFA_FA_COUNT_LIST,pszFactName);
	}

	if (dwNumNegPolicies > 0 && ppNegPolEnum != NULL)
	{
		IPSecFreeMulNegPolData(ppNegPolEnum, dwNumNegPolicies);
	}

	if(pNegPol)
	{
		IPSecFreeNegPolData(pNegPol);
	}

	ClosePolicyStore(hPolicyStorage);
	dwRet=ERROR_SUCCESS;

error:
	if(pszFactName)
	{
		delete [] pszFactName;
	}

    return dwRet;
}

//////////////////////////////////////////////////////////////////
//
//Function: HandleStaticDeleteRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Delete Rule"
//
//Revision History:
//
//Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticDeleteRule(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	BOOL bAll=FALSE,bExists=FALSE,bRuleExists=FALSE,bAssigned=FALSE,bCompleteDelete=FALSE;
	LPTSTR pszPolicyName=NULL,pszRuleName=NULL;
	DWORD dwNumPolicies = 0,dwRuleId = 0;
	DWORD dwRet = ERROR_SHOW_USAGE,i=0,dwCount=0;
	PIPSEC_POLICY_DATA *ppPolicyEnum = NULL,pPolicy=NULL;
	HANDLE hPolicyStorage=NULL;
	RPC_STATUS RpcStat =RPC_S_OK;
	_TCHAR szUserInput[STRING_SIZE]={0};
	DWORD dwReturnCode   = ERROR_SUCCESS , dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticDeleteRule[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ID,			NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_POLICY,		NS_REQ_ZERO,	FALSE },
	};

	const TOKEN_VALUE vtokStaticDeleteRule[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ID,			CMD_TOKEN_ID 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		},
		{ CMD_TOKEN_STR_POLICY,		CMD_TOKEN_POLICY	}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticDeleteRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticDeleteRule);

	parser.ValidCmd   = vcmdStaticDeleteRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticDeleteRule);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed user input

	for(dwCount=0;dwCount < parser.MaxTok;dwCount++)
	{
		switch(vtokStaticDeleteRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME :
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszRuleName= new _TCHAR[dwStrLength+1];
						if(pszRuleName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszRuleName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_POLICY :
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszPolicyName= new _TCHAR[dwStrLength+1];
						if(pszPolicyName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszPolicyName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_ID :
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						dwRuleId=	*(DWORD *)parser.Cmd[dwCount].pArg;
					}
					break;
			case CMD_TOKEN_ALL :
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						bAll= *(BOOL *)parser.Cmd[dwCount].pArg;
					}
					break;
			default:
					break;
		}
	}

	CleanUp();

	// if no policy name, bail out
	if (!pszPolicyName)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_RULE_4);
		return dwRet;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
		dwRet = ERROR_SUCCESS;
		BAIL_OUT;
	}
	// get the required policy
	for (i = 0; i <  dwNumPolicies; i++)
	{
		if ((pszPolicyName!=NULL)&&( wcscmp(ppPolicyEnum[i]->pszIpsecName, pszPolicyName) == 0))
		{
			bExists=TRUE;

			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
			if (dwReturnCode != ERROR_SUCCESS)
			{
				dwRet = dwReturnCode;
				BAIL_OUT;
			}

			dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
										  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

			if (dwReturnCode == ERROR_SUCCESS)
			{
				DWORD j;
				for (j = 0; j <  pPolicy->dwNumNFACount && (dwReturnCode == ERROR_SUCCESS); j++)
				{
					if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->NegPolIdentifier), &RpcStat))
					{
						dwReturnCode=IPSecGetNegPolData(hPolicyStorage, pPolicy->ppIpsecNFAData[j]->NegPolIdentifier,&(pPolicy->ppIpsecNFAData[j]->pIpsecNegPolData));
					}
					if ((!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->FilterIdentifier), &RpcStat))&&(dwReturnCode == ERROR_SUCCESS))
					{
						dwReturnCode=IPSecGetFilterData(hPolicyStorage,	pPolicy->ppIpsecNFAData[j]->FilterIdentifier,&(pPolicy->ppIpsecNFAData[j]->pIpsecFilterData));
					}
				}
			}

			for (DWORD n = 0; n <  pPolicy->dwNumNFACount && (dwReturnCode == ERROR_SUCCESS); n++)

				if (bAll||((pPolicy->ppIpsecNFAData[n]->pszIpsecName)&& pszRuleName &&(_tcscmp(pPolicy->ppIpsecNFAData[n]->pszIpsecName,pszRuleName)==0))||((dwRuleId-1)==n))
				{
					bRuleExists=TRUE;
					if((dwReturnCode == ERROR_SUCCESS)&&(!bAssigned) && g_StorageLocation.dwLocation != IPSEC_DIRECTORY_PROVIDER)
					{
						dwReturnCode=IsAssigned(pPolicy,hPolicyStorage,bAssigned);
						if(( dwReturnCode == ERROR_SUCCESS || dwReturnCode == ERROR_FILE_NOT_FOUND )&&bAssigned)
						{
							dwReturnCode=IPSecUnassignPolicy(hPolicyStorage, pPolicy->PolicyIdentifier);
						}
					}

					// if user asked to delete default rule, throw error to the user

					if(pPolicy->ppIpsecNFAData[n]->pIpsecNegPolData->NegPolType!=GUID_NEGOTIATION_TYPE_DEFAULT)
					{
						if (((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode == ERROR_FILE_NOT_FOUND)))
						{
							dwReturnCode=DeleteRule(pPolicy,pPolicy->ppIpsecNFAData[n],hPolicyStorage,bCompleteDelete);

							if (dwReturnCode!=ERROR_SUCCESS)
							{
								if (bAll&&(pPolicy->ppIpsecNFAData[n]->pszIpsecName))
								{
									PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_RULE_3,pPolicy->ppIpsecNFAData[n]->pszIpsecName);
								}
								else if (!bAll && pszRuleName)
								{
									PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_RULE_3,pszRuleName);
								}
								else
								{
									PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_RULE_4,dwRuleId);
								}
								dwRet = ERROR_SUCCESS;
							}
						}
					}
					else
					{
						PrintMessageFromModule(g_hModule,ERR_DEL_STATIC_RULE_DEF_DEL_NOT_ALLOWED);
						dwRet = ERROR_SUCCESS;
					}
					if(!bAll && bExists)
						break;
				}

			if (bAssigned && g_StorageLocation.dwLocation != IPSEC_DIRECTORY_PROVIDER)
			{
				IPSecAssignPolicy(hPolicyStorage, pPolicy->PolicyIdentifier);
			}

			if((!bRuleExists)&& pszRuleName &&(dwReturnCode==ERROR_SUCCESS))
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_RULE_10,pszRuleName);
			}
			else if(!bRuleExists)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_RULE_3,dwRuleId);
			}
		}
		if(bExists)
			break;
	}

	if(!bExists )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_POLICY_2,pszPolicyName);
	}

	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}

	ClosePolicyStore(hPolicyStorage);
	dwRet=ERROR_SUCCESS;
	if (pPolicy)
	{
		IPSecFreePolicyData(pPolicy);
	}

error: // clean up
	if (pszPolicyName)
	{
		delete [] pszPolicyName;
	}
	if (pszRuleName)
	{
		delete [] pszRuleName;
	}
    return dwRet;
}

//////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticDeleteAll()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Delete All"
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticDeleteAll(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	BOOL bAssigned=FALSE,bCompleteDelete=TRUE;
	DWORD dwNumPolicies = 0,dwRet = ERROR_SUCCESS,i=0;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	HANDLE hPolicyStorage=NULL;
	_TCHAR szUserInput[STRING_SIZE]={0};
	DWORD   dwReturnCode   = ERROR_SUCCESS;

	UpdateGetLastError(NULL);		// Error Success

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	// enum all policies and delete one by one

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);
	if (dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		for (i = 0; i <  dwNumPolicies; i++)
		{
			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
			if (dwReturnCode != ERROR_SUCCESS)
			{
				dwRet = dwReturnCode;
				BAIL_OUT;
			}

			dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
										  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

			if (dwReturnCode == ERROR_SUCCESS)
			{
				dwReturnCode=IPSecGetISAKMPData(hPolicyStorage, pPolicy->ISAKMPIdentifier, &(pPolicy->pIpsecISAKMPData));
			}

			if((dwReturnCode == ERROR_SUCCESS)&&(!bAssigned))
			{
				if(g_StorageLocation.dwLocation!=IPSEC_DIRECTORY_PROVIDER)
				{
					dwReturnCode=IsAssigned(pPolicy,hPolicyStorage,bAssigned);
				}
				if(( dwReturnCode == ERROR_SUCCESS || dwReturnCode == ERROR_FILE_NOT_FOUND )&&bAssigned)
				{
					dwReturnCode=IPSecUnassignPolicy(hPolicyStorage, pPolicy->PolicyIdentifier);
				}
			}

			dwReturnCode = DeletePolicy(pPolicy,hPolicyStorage,bCompleteDelete);
			
			if (dwReturnCode != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_POLICY_3,pPolicy->pszIpsecName);
			}

			if (pPolicy)
			{
				IPSecFreePolicyData(pPolicy);
			}
		}
	}

	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
	// delete the left out filterlists and filter action(Standalone)
	dwReturnCode =DeleteStandAloneFL(hPolicyStorage);

	if( dwReturnCode==ERROR_SUCCESS || dwReturnCode==ERROR_INVALID_DATA)
	{
		dwReturnCode =DeleteStandAloneFA(hPolicyStorage);
	}

	dwRet= ERROR_SUCCESS;

	ClosePolicyStore(hPolicyStorage);

error:
	return dwRet;
}

///////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteStandAloneFL()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage
//
//Return: DWORD
//
//Description:
//	This function deletes all the stand alone filter lists
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

DWORD
DeleteStandAloneFL(
	IN HANDLE hPolicyStorage
	)
{
	DWORD dwReturnCode=ERROR_SUCCESS;
	PIPSEC_FILTER_DATA *ppFilterEnum  = NULL,pFilter=NULL;
	DWORD cnt=0,dwNumFilters=0;

	dwReturnCode = IPSecEnumFilterData(hPolicyStorage, &ppFilterEnum, &dwNumFilters);
	if (!(dwReturnCode == ERROR_SUCCESS && dwNumFilters > 0 && ppFilterEnum != NULL))
	{
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}
	// delete one  by one
	for(cnt=0; cnt < dwNumFilters;cnt++)
	{
		dwReturnCode = IPSecCopyFilterData(ppFilterEnum[cnt], &pFilter);
		if ((dwReturnCode == ERROR_SUCCESS) && (pFilter != NULL))
		{
			dwReturnCode = DeleteFilterList(pFilter,hPolicyStorage);
			if (dwReturnCode == ERROR_INVALID_DATA)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTERLIST_2,pFilter->pszIpsecName);
				// if cannot be deleted , show where it is used
				ShowWhereFLUsed(pFilter,hPolicyStorage);
			}
			else if (dwReturnCode != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTERLIST_ALL_FL_DEL_QUERY,pFilter->pszIpsecName);
			}
		}
	}
	if(ppFilterEnum && dwNumFilters>0)
	{
		IPSecFreeMulFilterData(	ppFilterEnum,dwNumFilters);
	}
	if(pFilter)
	{
		IPSecFreeFilterData(pFilter);
	}
error:
	return dwReturnCode;
}

///////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteStandAloneFA()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage
//
//Return: DWORD
//
//Description:
//	This function deletes all the stand alone filter actions
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

DWORD
DeleteStandAloneFA(
	IN HANDLE hPolicyStorage
	)
{
	DWORD dwReturnCode=ERROR_SUCCESS;
	PIPSEC_NEGPOL_DATA *ppNegPolEnum  = NULL,pNegPol=NULL;
	DWORD cnt=0,dwNumNegPolicies=0;

	dwReturnCode = IPSecEnumNegPolData(hPolicyStorage, &ppNegPolEnum, &dwNumNegPolicies);
	if (!(dwReturnCode == ERROR_SUCCESS && dwNumNegPolicies > 0 && ppNegPolEnum != NULL))
	{
		dwReturnCode = ERROR_SUCCESS;
		BAIL_OUT;
	}
	for(cnt=0; cnt < dwNumNegPolicies;cnt++)
	{
		// ignore the default filteraction
		if(IsEqualGUID(ppNegPolEnum[cnt]->NegPolType,GUID_NEGOTIATION_TYPE_DEFAULT)||(!ppNegPolEnum[cnt]->pszIpsecName))
		{
			DeleteFilterAction(ppNegPolEnum[cnt],hPolicyStorage);
			continue;
		}

		dwReturnCode = IPSecCopyNegPolData(ppNegPolEnum[cnt], &pNegPol);
		if ((dwReturnCode == ERROR_SUCCESS) && (pNegPol != NULL))
		{
			dwReturnCode = DeleteFilterAction(pNegPol,hPolicyStorage);
			if (dwReturnCode == ERROR_INVALID_DATA)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTERACTION_2,pNegPol->pszIpsecName);
				//if delete failed, show where it is used
				ShowWhereFAUsed(pNegPol,hPolicyStorage);
			}
			else if (dwReturnCode != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_DEL_STATIC_FILTERACTION_ALL_FA_DEL_QUERY,pNegPol->pszIpsecName);
			}
		}
	}
	if (dwNumNegPolicies > 0 && ppNegPolEnum != NULL)
	{
		IPSecFreeMulNegPolData(	ppNegPolEnum,dwNumNegPolicies);
	}
	if(pNegPol)
	{
		IPSecFreeNegPolData(pNegPol);
	}
error:
	return dwReturnCode;
}

///////////////////////////////////////////////////////////////////////////////
//
//Function: DeletePolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_POLICY_DATA pPolicy,
//	IN HANDLE hStore,
//	IN BOOL bCompleteDelete
//
//Return: DWORD
//
//Description:
//	Deletes a specific policy from the policy store
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

DWORD
DeletePolicy(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN HANDLE hStore,
	IN BOOL bCompleteDelete
	)
{
	DWORD   dwReturnCode  = ERROR_SUCCESS;
	DWORD i=0;
	RPC_STATUS RpcStat=RPC_S_OK;
	GUID guidISAKMP = pPolicy->ISAKMPIdentifier,guidNegPol,guidFilter;

	//check for read only flag

	if(pPolicy->dwFlags & POLSTORE_READONLY )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_POL_READ_ONLY_OBJECT,pPolicy->pszIpsecName);
		BAIL_OUT;
	}

	//delete sequentially the policy data structure

	for (i = 0; i <  pPolicy->dwNumNFACount && ((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode==ERROR_INVALID_DATA)); i++)
	{
		if(bCompleteDelete)
		{
			guidNegPol=pPolicy->ppIpsecNFAData[i]->NegPolIdentifier;
			guidFilter=pPolicy->ppIpsecNFAData[i]->FilterIdentifier;
		}
		dwReturnCode = IPSecDeleteNFAData(hStore, pPolicy->PolicyIdentifier, pPolicy->ppIpsecNFAData[i]);

		if(bCompleteDelete) // if the user asked, delete the filterlist and filteractions also
		{
			if ((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode==ERROR_INVALID_DATA))
			{
				if (!UuidIsNil(&guidFilter, &RpcStat))
				{
					dwReturnCode = DeleteFilterData(hStore, guidFilter);
				}
			}

			if ((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode==ERROR_INVALID_DATA))
			{
				if (!UuidIsNil(&guidNegPol, &RpcStat))
				{
					dwReturnCode = DeleteNegPolData(hStore, guidNegPol);
				}
			}
		}
	}
	if ((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode==ERROR_INVALID_DATA))
	{
		dwReturnCode = DeletePolicyData(hStore, pPolicy);
	}

	if (dwReturnCode == ERROR_SUCCESS)
	{
		dwReturnCode = IPSecDeleteISAKMPData(hStore, guidISAKMP);
	}
error:
	return dwReturnCode;
}

////////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_POLICY_DATA pPolicy,
//	IN PIPSEC_NFA_DATA pIpsecNFAData,
//	IN HANDLE hStore,
//	IN BOOL bCompleteDelete
//
//Return: DWORD
//
//Description:
//	Deletes a specific rule from the policy specified.
//	Note : It will deny to delete the Default response rule.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

DWORD
DeleteRule(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN PIPSEC_NFA_DATA pIpsecNFAData,
	IN HANDLE hStore,
	IN BOOL bCompleteDelete
	)

{
	DWORD   dwReturnCode  = ERROR_SUCCESS;
	RPC_STATUS RpcStat=RPC_S_OK;
	GUID guidNegPol,guidFilter;

	//check for readonly flag

	if(pPolicy->dwFlags & POLSTORE_READONLY )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_POL_READ_ONLY_OBJECT,pPolicy->pszIpsecName);
		BAIL_OUT;
	}

	// delete sequentially the NFA data structure

	if(bCompleteDelete)
	{
		guidNegPol=pIpsecNFAData->NegPolIdentifier;
		guidFilter=pIpsecNFAData->FilterIdentifier;
	}

	dwReturnCode = IPSecDeleteNFAData(hStore, pPolicy->PolicyIdentifier, pIpsecNFAData);

	if(bCompleteDelete) // if the user asked, delete the filterlist and filteractions also
	{
		if (dwReturnCode == ERROR_SUCCESS)
		{
			if (!UuidIsNil(&guidFilter, &RpcStat))
			{
				dwReturnCode = DeleteFilterData(hStore, guidFilter);
			}
		}
		if ((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode==ERROR_INVALID_DATA))
		{
			if (!UuidIsNil(&guidNegPol, &RpcStat))
			{
				dwReturnCode = DeleteNegPolData(hStore, guidNegPol);
			}
		}
	}

	if(g_NshPolStoreHandle.GetBatchmodeStatus())
	{
		g_NshPolNegFilData.DeletePolicyFromCache(pPolicy);
	}

	if (dwReturnCode==ERROR_INVALID_DATA)
	{
		dwReturnCode = ERROR_SUCCESS;
	}

error:
	return dwReturnCode;
}


///////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteFilterAction()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_NEGPOL_DATA pNegPolData,
//	IN HANDLE hStore
//
//Return: DWORD
//
//Description:
//	Deletes a specific Filter Action from the policy store
//	Note : It will object to delete the FA attached to some policy/Rule.
//	And it displays the policies/rules which are using it.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

DWORD
DeleteFilterAction(
	IN PIPSEC_NEGPOL_DATA pNegPolData,
	IN HANDLE hStore
	)
{
	DWORD   dwReturnCode  = ERROR_SUCCESS;
	RPC_STATUS RpcStat=RPC_S_OK;

	if (!UuidIsNil(&(pNegPolData->NegPolIdentifier), &RpcStat))
	{
		dwReturnCode = DeleteNegPolData(hStore, pNegPolData->NegPolIdentifier);
	}
	return dwReturnCode;
}

///////////////////////////////////////////////////////////////////////////////
//
//Function: DeleteFilterList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_DATA pFilterData,
//	IN HANDLE hStore
//
//Return: DWORD
//
//Description:
//	Deletes a specific Filter List from the policy store
//	Note : It will object to delete the FL attached to some policy/Rule.
//	And it displays the policies/rules which are using it.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

DWORD
DeleteFilterList(
	IN PIPSEC_FILTER_DATA pFilterData,
	IN HANDLE hStore
	)
{
	DWORD   dwReturnCode  = ERROR_SUCCESS;
	RPC_STATUS RpcStat=RPC_S_OK;

	if(pFilterData->dwFlags & POLSTORE_READONLY )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_FL_READ_ONLY_OBJECT,pFilterData->pszIpsecName);
		BAIL_OUT;
	}

	if (!UuidIsNil(&(pFilterData->FilterIdentifier), &RpcStat))
	{
		dwReturnCode = DeleteFilterData(hStore, pFilterData->FilterIdentifier);
	}
error:
	return dwReturnCode;
}

///////////////////////////////////////////////////////////////////////////////
//
//Function: ShowWhereFLUsed()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_DATA pIpsecFilterData,
//	IN HANDLE hPolicyStorage
//
//Return: DWORD
//
//Description:
//	This function displays the policies/rules which are using a specific Filter list.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

VOID
ShowWhereFLUsed(
	IN PIPSEC_FILTER_DATA pIpsecFilterData,
	IN HANDLE hPolicyStorage
	)
{
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	BOOL bPrinted=FALSE;
	DWORD dwNumPolicies = 0 , i=0;
	DWORD dwReturnCode = ERROR_SUCCESS;

	PrintMessageFromModule(g_hModule,DEL_STATIC_SHWRUSED_TITLE);
	PrintMessageFromModule(g_hModule,DEL_STATIC_SHWRUSED_UNDERLINE);

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		BAIL_OUT;
	}
	for (i = 0; i <  dwNumPolicies; i++)
	{
		bPrinted=FALSE;

		dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
		BAIL_ON_WIN32_ERROR(dwReturnCode);

		dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
									 , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

		for (DWORD n = 0; n <  pPolicy->dwNumNFACount && (dwReturnCode == ERROR_SUCCESS); n++)
		{
			//check where this filterlist is used

			if(IsEqualGUID(pPolicy->ppIpsecNFAData[n]->FilterIdentifier,pIpsecFilterData->FilterIdentifier))
			{
				if ((!bPrinted)&&(pPolicy->pszIpsecName))
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_FILTERLIST_POL_NAME,pPolicy->pszIpsecName);
					bPrinted=TRUE;
				}
				if (pPolicy->ppIpsecNFAData[n]->pszIpsecName)
				{
					PrintMessageFromModule(g_hModule,DEL_STATIC_SHWRUSED_RULE_NAME_STR,pPolicy->ppIpsecNFAData[n]->pszIpsecName );
				}
				else
				{
					PrintMessageFromModule(g_hModule,DEL_STATIC_SHWRUSED_RULE_NAME_NONE);
				}
			}
		}
		if (pPolicy)
		{
			IPSecFreePolicyData(pPolicy);
		}
	}
	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
error:
	return;
}

///////////////////////////////////////////////////////////////////////////////
//
//Function: ShowWhereFAUsed()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
//	IN HANDLE hPolicyStorage
//
//Return: DWORD
//
//Description:
//	This function displays the policies/rules which are using a specific Filter Action.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

VOID
ShowWhereFAUsed(
	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
	IN HANDLE hPolicyStorage
	)
{
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	BOOL bPrinted=FALSE;
	DWORD dwNumPolicies = 0 , i = 0;
	DWORD dwReturnCode = ERROR_SUCCESS;

	PrintMessageFromModule(g_hModule,DEL_STATIC_SHWRUSED_TITLE);
	PrintMessageFromModule(g_hModule,DEL_STATIC_SHWRUSED_UNDERLINE);

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);
	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		BAIL_OUT;
	}
	for (i = 0; i <  dwNumPolicies; i++)
	{
		bPrinted=FALSE;
		dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
		if (dwReturnCode != ERROR_SUCCESS)
		{
			BAIL_OUT;
		}
		dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
										, &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

		for (DWORD n = 0; n <  pPolicy->dwNumNFACount && (dwReturnCode == ERROR_SUCCESS); n++)
		{
			//check where this filteraction is used

			if(IsEqualGUID(pPolicy->ppIpsecNFAData[n]->NegPolIdentifier,pIpsecNegPolData->NegPolIdentifier))
			{
				if (!bPrinted)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_FILTERLIST_POL_NAME,pPolicy->pszIpsecName);
					bPrinted=TRUE;
				}
				if (pPolicy->ppIpsecNFAData[n]->pszIpsecName)
				{
					PrintMessageFromModule(g_hModule,DEL_STATIC_SHWRUSED_RULE_NAME_STR,pPolicy->ppIpsecNFAData[n]->pszIpsecName );
				}
				else
				{
					PrintMessageFromModule(g_hModule,DEL_STATIC_SHWRUSED_RULE_NAME_NONE);
				}
			}
		}

		if (pPolicy)
		{
			IPSecFreePolicyData(pPolicy);
		}
	}
	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
error :
	return;
}

///////////////////////////////////////////////////////////////////////////////
//
//Function: FillDelFilterInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PDELFILTERDATA* ppFilter,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticDeleteFilter
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////////

DWORD
FillDelFilterInfo(
	OUT PDELFILTERDATA* ppFilter,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticDeleteFilter
	)
{
	DWORD dwCount=0,dwReturn=ERROR_SUCCESS , dwStrLength = 0;
	PDELFILTERDATA pFilter=new DELFILTERDATA;
	if(pFilter==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memset(pFilter,0,sizeof(DELFILTERDATA));

	pFilter->bMirrored=TRUE;
	pFilter->SourMask = MASK_ME;
	pFilter->DestMask = MASK_ME;

	for(dwCount=0;dwCount < parser.MaxTok;dwCount++)
	{
		switch(vtokStaticDeleteFilter[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_FILTERLIST :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pFilter->pszFLName=new _TCHAR[dwStrLength+1];
								if(pFilter->pszFLName==NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilter->pszFLName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_SRCADDR 	  :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								if(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName)
								{
									dwStrLength = _tcslen(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName);

									pFilter->SourceAddr.pszDomainName = new _TCHAR[dwStrLength+1];
									if(pFilter->SourceAddr.pszDomainName==NULL)
									{
										dwReturn = ERROR_OUTOFMEMORY;
										BAIL_OUT;
									}
									_tcsncpy(pFilter->SourceAddr.pszDomainName,((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName,dwStrLength+1);
								}
								else
								{
									pFilter->SourceAddr.puIpAddr = new ULONG;
									if(pFilter->SourceAddr.puIpAddr==NULL)
									{
										dwReturn = ERROR_OUTOFMEMORY;
										BAIL_OUT;
									}
									memcpy( &(pFilter->SourceAddr.puIpAddr[0]),(&((DNSIPADDR *)parser.Cmd[dwCount].pArg)->puIpAddr[0]),sizeof(ULONG));
								}
							}
							else  // deal if special server specified
							{

								if(parser.Cmd[dwCount].dwStatus == SERVER_DNS)
								{
									pFilter->bSrcServerSpecified=TRUE;
									pFilter->ExType=EXT_DNS_SERVER;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_WINS)
								{
									pFilter->bSrcServerSpecified=TRUE;
									pFilter->ExType=EXT_WINS_SERVER;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_DHCP)
								{
									pFilter->bSrcServerSpecified=TRUE;
									pFilter->ExType=EXT_DHCP_SERVER;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_GATEWAY)
								{
									pFilter->bSrcServerSpecified=TRUE;
									pFilter->ExType=EXT_DEFAULT_GATEWAY;
								}
								else if (parser.Cmd[dwCount].dwStatus == IP_ME)
								{
									pFilter->bSrcMeSpecified=TRUE;
								}
								else if (parser.Cmd[dwCount].dwStatus == IP_ANY)
								{
									pFilter->bSrcAnySpecified=TRUE;
								}
							}
							break;
			case CMD_TOKEN_DSTADDR :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								if(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName)
								{
									dwStrLength = _tcslen(((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName);

									pFilter->DestnAddr.pszDomainName = new _TCHAR[dwStrLength+1];
									if(pFilter->DestnAddr.pszDomainName==NULL)
									{
										dwReturn = ERROR_OUTOFMEMORY;
										BAIL_OUT;
									}
									_tcsncpy(pFilter->DestnAddr.pszDomainName,((DNSIPADDR *)parser.Cmd[dwCount].pArg)->pszDomainName,dwStrLength+1);
								}
								else
								{
									pFilter->DestnAddr.puIpAddr = new ULONG;
									if(pFilter->DestnAddr.puIpAddr==NULL)
									{
										dwReturn = ERROR_OUTOFMEMORY;
										BAIL_OUT;
									}

									memcpy( &(pFilter->DestnAddr.puIpAddr[0]),(&((DNSIPADDR *)parser.Cmd[dwCount].pArg)->puIpAddr[0]),sizeof(ULONG));
								}
							}
							else // deal if special server specified
							{

								if(parser.Cmd[dwCount].dwStatus == SERVER_DNS)
								{
									pFilter->bDstServerSpecified=TRUE;
									pFilter->ExType=EXT_DNS_SERVER | EXT_DEST;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_WINS)
								{
									pFilter->bDstServerSpecified=TRUE;
									pFilter->ExType=EXT_WINS_SERVER | EXT_DEST;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_DHCP)
								{
									pFilter->bDstServerSpecified=TRUE;
									pFilter->ExType=EXT_DHCP_SERVER | EXT_DEST;
								}
								else if(parser.Cmd[dwCount].dwStatus == SERVER_GATEWAY)
								{
									pFilter->bDstServerSpecified=TRUE;
									pFilter->ExType=EXT_DEFAULT_GATEWAY | EXT_DEST;
								}
								else if (parser.Cmd[dwCount].dwStatus == IP_ME)
								{
									pFilter->bDstMeSpecified=TRUE;
								}
								else if (parser.Cmd[dwCount].dwStatus == IP_ANY)
								{
									pFilter->bDstAnySpecified=TRUE;
								}
							}
							break;
			case CMD_TOKEN_SRCMASK :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilter->SourMask=	*(DWORD *)parser.Cmd[dwCount].pArg;
								pFilter->bSrcMaskSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_DSTMASK :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilter->DestMask=	*(DWORD *)parser.Cmd[dwCount].pArg;
								pFilter->bDstMaskSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_MIRROR :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilter->bMirrored= *(BOOL *)parser.Cmd[dwCount].pArg;
								pFilter->bMirrorSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_PROTO :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilter->dwProtocol= *(DWORD *)parser.Cmd[dwCount].pArg;
								pFilter->bProtocolSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_SRCPORT :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilter->SourPort= *(WORD *)parser.Cmd[dwCount].pArg;
								pFilter->bSrcPortSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_DSTPORT :
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilter->DestPort= *(WORD *)parser.Cmd[dwCount].pArg;
								pFilter->bDstPortSpecified=TRUE;
							}
							break;
			default:
							break;
		}
	}

	// deal me and any cases

	if(pFilter->bSrcMeSpecified)
	{
		pFilter->SourceAddr.dwNumIpAddresses = 1;
		pFilter->SourceAddr.puIpAddr= new ULONG[pFilter->SourceAddr.dwNumIpAddresses];
		if(pFilter->SourceAddr.puIpAddr==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		*(pFilter->SourceAddr.puIpAddr)=ADDR_ME;
		pFilter->SourMask = MASK_ME;
		if (pFilter->bDstMeSpecified)
		{
			dwReturn = ERROR_INVALID_PARAMETER;
			BAIL_OUT;
		}
	}
	else if(pFilter->bSrcAnySpecified)
	{
		pFilter->SourceAddr.dwNumIpAddresses = 1;
		pFilter->SourceAddr.puIpAddr= new ULONG[pFilter->SourceAddr.dwNumIpAddresses];
		if(pFilter->SourceAddr.puIpAddr==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		*(pFilter->SourceAddr.puIpAddr)=ADDR_ME;
		pFilter->SourMask = ADDR_ME;
	}
	if(pFilter->bDstMeSpecified)
	{
		pFilter->DestnAddr.dwNumIpAddresses = 1;
		pFilter->DestnAddr.puIpAddr= new ULONG[pFilter->DestnAddr.dwNumIpAddresses];
		if(pFilter->DestnAddr.puIpAddr==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		*(pFilter->DestnAddr.puIpAddr)=ADDR_ME;
		pFilter->DestMask = MASK_ME;
	}
	else if(pFilter->bDstAnySpecified)
	{
		pFilter->DestnAddr.dwNumIpAddresses = 1;
		pFilter->DestnAddr.puIpAddr= new ULONG[pFilter->DestnAddr.dwNumIpAddresses];
		if(pFilter->DestnAddr.puIpAddr==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		*(pFilter->DestnAddr.puIpAddr)=ADDR_ME;
		pFilter->DestMask = ADDR_ME;
	}

	if (((pFilter->dwProtocol != PROT_ID_TCP) && (pFilter->dwProtocol != PROT_ID_UDP)) &&
	((pFilter->SourPort != 0) || (pFilter->DestPort != 0)))
	{
		dwReturn = ERROR_INVALID_PARAMETER;
		BAIL_OUT;
	}



	if(pFilter->bSrcServerSpecified || pFilter->bDstServerSpecified)
	{
		//deal the special server cases. ignore irrelevant input parameters

		if(pFilter->SourceAddr.pszDomainName)
		{
			delete [] pFilter->SourceAddr.pszDomainName;
			pFilter->SourceAddr.pszDomainName=NULL;
		}
		if(pFilter->DestnAddr.pszDomainName)
		{
			delete [] pFilter->DestnAddr.pszDomainName;
			pFilter->DestnAddr.pszDomainName=NULL;
		}
		if(pFilter->SourceAddr.puIpAddr)
		{
			delete [] pFilter->SourceAddr.puIpAddr;
		}
		if(pFilter->DestnAddr.puIpAddr)
		{
			delete [] pFilter->DestnAddr.puIpAddr;
		}

		pFilter->SourceAddr.dwNumIpAddresses = DEF_NUMBER_OF_ADDR;
		pFilter->SourceAddr.puIpAddr= new ULONG[DEF_NUMBER_OF_ADDR];
		if(pFilter->SourceAddr.puIpAddr==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		memcpy( &(pFilter->SourceAddr.puIpAddr[0]),&ADDR_ME ,sizeof(ULONG));

		pFilter->DestnAddr.dwNumIpAddresses = DEF_NUMBER_OF_ADDR;
		pFilter->DestnAddr.puIpAddr= new ULONG[DEF_NUMBER_OF_ADDR];
		if(pFilter->DestnAddr.puIpAddr==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
		memcpy( &(pFilter->DestnAddr.puIpAddr[0]),&ADDR_ME ,sizeof(ULONG));

		pFilter->SourMask = MASK_ME;
		pFilter->DestMask = MASK_ME;
	}
error:
	*ppFilter=pFilter;

	CleanUp();

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticdelete.h ===
////////////////////////////////////////////////////////////
//Header: staticdelete.h
//
// Purpose: 	Defining structures and prototypes for statidelete.cpp.
//
// Developers Name: surya
//
// History:
//
//   Date    		Author    	Comments
//	21th Aug 2001	surya		Initial Version.
//  <creation>  <author>
//
//   <modification> <author>  <comments, references to code sections,
//									in case of bug fixes>
//
////////////////////////////////////////////////////////////

#ifndef _STATICDELETE_H_
#define _STATICDELETE_H_


typedef struct _DELFILTERDATA {
	LPTSTR pszFLName;
	DNSIPADDR SourceAddr;
	DWORD SourMask;
	BOOL  bSrcMaskSpecified;
	DNSIPADDR DestnAddr;
	DWORD DestMask;
	BOOL  bDstMaskSpecified;
	BOOL  bMirrored;
	BOOL  bMirrorSpecified;
	DWORD dwProtocol;
	BOOL  bProtocolSpecified;
	UINT  SourPort;
	BOOL  bSrcPortSpecified;
	UINT  DestPort;
	BOOL  bDstPortSpecified;
	UCHAR ExType;
	BOOL bSrcServerSpecified;
	BOOL bDstServerSpecified;
	BOOL bSrcMeSpecified;
	BOOL bSrcAnySpecified;
	BOOL bDstMeSpecified;
	BOOL bDstAnySpecified;
}DELFILTERDATA, *PDELFILTERDATA;


DWORD
DeleteStandAloneFL(
	IN HANDLE hStorage
	);

DWORD
DeleteStandAloneFA(
	IN HANDLE hStorage
	);

DWORD
DeletePolicy(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN HANDLE hStore,
	IN BOOL bCompleteDelete
	);

DWORD
DeleteFilterAction(
	IN PIPSEC_NEGPOL_DATA pNegPolData,
	IN HANDLE hStore
	);

DWORD
DeleteFilterList(
	IN PIPSEC_FILTER_DATA pFilterData,
	IN HANDLE hStore
	);

BOOL
DeleteSpecifiedFilter(
	IN OUT PIPSEC_FILTER_DATA pFilterData,
	IN PDELFILTERDATA pDeleteFilter
	);

VOID
ShowWhereFAUsed(
	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
	IN HANDLE hPolicyStorage
	);

VOID
ShowWhereFLUsed(
	IN PIPSEC_FILTER_DATA pIpsecFilterData,
	IN HANDLE hPolicyStorage
	);

DWORD
DeleteRule(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN PIPSEC_NFA_DATA pIpsecNFAData,
	IN HANDLE hStore,
	IN BOOL bCompleteDelete
	);

DWORD
FillDelFilterInfo(
	OUT PDELFILTERDATA* ppFilter,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticDelFilter
	);

#endif //_STATICDELETE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticset.h ===
///////////////////////////////////////////////////////////////////////
//Header: staticset.h
//
// Purpose: 	Defining structures and prototypes for statiset.cpp.
//
// Developers Name: surya
//
// History:
//
//   Date    		Author    	Comments
//	21th Aug 2001	surya		Initial Version.
//
///////////////////////////////////////////////////////////////////////

#ifndef _STATICSET_H_
#define _STATICSET_H_

typedef struct _POLICYDATA {
	LPTSTR  pszGUIDStr;
	BOOL    bGUIDSpecified;
	GUID    PolicyGuid;
	LPTSTR  pszPolicyName;
	BOOL    bPolicyNameSpecified;
	LPTSTR  pszNewPolicyName;
	LPTSTR  pszDescription;
	LPTSTR  pszGPOName;
	BOOL    bPFS;
	BOOL    bPFSSpecified;
	ULONG   LifeTimeInSeconds;
	BOOL    bLifeTimeInsecondsSpecified;
	DWORD   dwQMLimit;
	BOOL 	bQMLimitSpecified;
	DWORD 	dwOfferCount;
	IPSEC_MM_OFFER *pIpSecMMOffer;
	DWORD 	dwAuthInfos;
	DWORD 	dwPollInterval;
	BOOL 	bPollIntervalSpecified;
	BOOL 	bAssign;
	BOOL 	bAssignSpecified;
	BOOL 	bActivateDefaultRule;
	BOOL 	bActivateDefaultRuleSpecified;
	BOOL    bGuidConversionOk;
	BOOL    bCertToAccMappingSpecified;
	BOOL    bCertToAccMapping;
}POLICYDATA,*PPOLICYDATA;

typedef struct _FILTERACTION {
	LPTSTR  pszGUIDStr;
	BOOL    bGUIDSpecified;
	GUID    FAGuid;
	LPTSTR 	pszFAName;
	LPTSTR 	pszNewFAName;
	LPTSTR 	pszFADescription;
	GUID 	NegPolAction;
	PIPSEC_QM_OFFER pIpsecSecMethods;
	DWORD 	dwNumSecMethodCount;
	BOOL 	bSecMethodsSpecified;
	BOOL 	bNegPolActionSpecified;
	BOOL 	bQMPfs;
	BOOL 	bQMPfsSpecified;
	BOOL 	bInpass;
	BOOL 	bInpassSpecified;
	BOOL 	bSoft;
	BOOL 	bSoftSpecified;
	BOOL 	bNegotiateSpecified;
	ULONG   LifeTimeInSeconds;
	ULONG   LifeTimeInkiloBytes;
	BOOL    bLifeTimeInsecondsSpecified;
	BOOL    bLifeTimeInkiloBytesSpecified;
	BOOL    bGuidConversionOk;
} FILTERACTION, *PFILTERACTION;

typedef struct _RULEDATA {
	LPTSTR 	pszRuleName;
	DWORD   dwRuleId;
	BOOL    bIDSpecified;
	BOOL    bGuidConversionOk;
	LPTSTR 	pszNewRuleName;
	LPTSTR 	pszRuleDescription;
	LPTSTR 	pszPolicyName;
	LPTSTR 	pszFLName;
	BOOL 	bFLSpecified;
	LPTSTR 	pszFAName;
	BOOL 	bFASpecified;
	BOOL 	bTunnel;
	BOOL 	bTunnelSpecified;
	IPADDR 	TunnelIPAddress;
	DWORD 	dwAuthInfos;
	STA_AUTH_METHODS AuthInfos;
	IF_TYPE ConnectionType;
	BOOL 	bConnectionTypeSpecified;
	BOOL 	bActivate;
	BOOL 	bActivateSpecified;
	BOOL    bAuthMethodSpecified;
}RULEDATA, *PRULEDATA;

typedef struct _DEFAULTRULE {
	LPTSTR  pszPolicyName;
	PIPSEC_QM_OFFER pIpsecSecMethods;
	DWORD dwNumSecMethodCount;
	DWORD dwAuthInfos;
	STA_AUTH_METHODS AuthInfos;
	BOOL bActivate;
	BOOL bActivateSpecified;
	BOOL bQMPfs;
	BOOL bQMPfsSpecified;
	ULONG   LifeTimeInSeconds;
	ULONG   LifeTimeInkiloBytes;
	BOOL    bLifeTimeInsecondsSpecified;
	BOOL    bLifeTimeInkiloBytesSpecified;
}DEFAULTRULE, *PDEFAULTRULE;

//
//friendly names for the default policies
//
const _TCHAR  GUID_CLIENT_RESPOND_ONLY[]       		= _TEXT("CLIENT_RESPOND");
const _TCHAR  GUID_SECURE_SERVER_REQUIRE_SECURITY[]	= _TEXT("SECURE_SERVER");
const _TCHAR  GUID_SERVER_REQUEST_SECURITY[]       	= _TEXT("SERVER_REQUEST");

//
//default policy GUIDs
//
const CLSID CLSID_Server 		=	{ 0x72385230, 0x70FA, 0x11D1,
   { 0x86, 0x4C, 0x14, 0xA3, 0x00, 0x00, 0x00, 0x00 } };

const CLSID CLSID_Client 		=	{ 0x72385236, 0x70FA, 0x11D1,
   { 0x86, 0x4C, 0x14, 0xA3, 0x00, 0x00, 0x00, 0x00 } };

const CLSID CLSID_SecureServer	=	{ 0x7238523C, 0x70FA, 0x11D1,
   { 0x86, 0x4C, 0x14, 0xA3, 0x00, 0x00, 0x00, 0x00 } };

//
// Prototypes
//
extern BOOL
IsDomainMember(
	IN LPTSTR pszMachine
	);

PIPSEC_NFA_DATA
GetRuleFromPolicy(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN PRULEDATA pRuleData
	);
DWORD
UpdateRule(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN PRULEDATA pRuleData,
	IN PIPSEC_NEGPOL_DATA pNegPolData,
	IN PIPSEC_FILTER_DATA pFilterData,
	IN HANDLE hPolicyStorage
	);
DWORD
UpdateDefaultResponseNegotiationPolicy (
	IN PDEFAULTRULE pRuleData,
	IN OUT PIPSEC_NFA_DATA pRule
	);

DWORD
UpdateDefaultResponseRule (
	IN PDEFAULTRULE pRuleData,
	IN OUT PIPSEC_NFA_DATA pRule,
	IN OUT BOOL &bCertConversionSuceeded
	);

DWORD
UpdateNegotiationPolicy(
	IN OUT PIPSEC_NEGPOL_DATA pNegPol,
	IN PFILTERACTION pFilterAction
	);

DWORD
FillSetPolicyInfo(
	OUT PPOLICYDATA* ppPolicyData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticSetPolicy
	);

DWORD
FillSetFilterActionInfo(
	OUT PFILTERACTION* ppFilterData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticSetFilterAction
	);

DWORD
FillSetRuleInfo(
	OUT PRULEDATA* ppRuleData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticSetRule
	);

DWORD
FillSetDefRuleInfo(
	OUT PDEFAULTRULE* ppRuleData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticSetDefaultRule
	);

BOOL
GetPolicyFromStoreBasedOnGuid(
	OUT PIPSEC_POLICY_DATA *ppPolicy,
	IN PPOLICYDATA pPolicyData,
	IN HANDLE hPolicyStorage
	);

#endif //_STATICSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticsetutils.cpp ===
//////////////////////////////////////////////////////////////////////
//Module: Static/StaticSetUtils.cpp

// Purpose: 	Static Set auxiliary functions Implementation.

// Developers Name: Surya

// History:

//   Date    	Author    	Comments
//	10-8-2001	Bharat		Initial Version. SCM Base line 1.0
//  <creation>  <author>

//   <modification> <author>  <comments, references to code sections,
//								in case of bug fixes>

//////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

//////////////////////////////////////////////////////////////////////
//Function: IsDSAvailable()

//Date of Creation: 21st Aug 2001

//Parameters:
//	OUT LPTSTR * pszPath

//Return: BOOL

//Description:
//	This function checks whether DS exists

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
//////////////////////////////////////////////////////////////////////
BOOL
IsDSAvailable(
	OUT LPTSTR * pszPath
	)
{
   HRESULT  hr       = S_OK;
   IADs *   pintIADs = NULL;
   VARIANT  var;
   BSTR bstrName = NULL;
   DWORD dwReturn = ERROR_SUCCESS , dwStrLenAlloc = 0,dwStrLenCpy = 0;
   BOOL bDSAvailable = FALSE ;

   hr = ADsGetObject(_TEXT("LDAP://rootDSE"), IID_IADs, (void **)&pintIADs);

   if ( SUCCEEDED(hr) )
   {
      if ( pszPath )
      {
		 dwReturn = AllocBSTRMem(_TEXT("defaultNamingContext"),bstrName);

		 if(dwReturn == ERROR_OUTOFMEMORY)
		 {
			 PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
			 BAIL_OUT;
		 }

		 pintIADs->Get(bstrName, &var);
		 SysFreeString(bstrName);

		 if ( SUCCEEDED(hr) )
		 {
			dwStrLenAlloc = wcslen(var.bstrVal) + wcslen(_TEXT("LDAP://"));
			*pszPath = (LPTSTR)
				 ::CoTaskMemAlloc(sizeof(OLECHAR) *
						(dwStrLenAlloc+1));
			if (*pszPath == NULL)
			{
				PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
				BAIL_OUT;
			}
			wcsncpy(*pszPath, _TEXT("LDAP://"),dwStrLenAlloc+1);
			dwStrLenCpy = wcslen(*pszPath);
			wcsncat(*pszPath, var.bstrVal,dwStrLenAlloc-dwStrLenCpy+1);
		 }
      }
      bDSAvailable = TRUE;
   }
   if ( pintIADs )
   {
      pintIADs->Release();
   }
error:
   return bDSAvailable;
}

//////////////////////////////////////////////////////////////////////
//
//  Function:  FindObject
//
//  Date of Creation: 21st Aug 2001
//
//
//  Pre-conditions:
//
//    Runs on a machine that is part of an NT5 domain
//
//  Parameters:
//
//    IN    szName      the friendly name to find
//    IN    cls         the class of the object
//    OUT   szPath      ADS path returned on success
//                      Or the ADS path to the domain on failure
//
//  Return :
//
//    E_FAIL if object not found
//    anything from GetGC
//    S_OK for success
//
//	Description:
//	    Finds particular object in the DS. The objects supported
//    right now are any in the objectClass enum type
//  Revision History:
//  <Version number, Change request number, Date of modification,
//						Author, Nature of change>

//////////////////////////////////////////////////////////////////////

HRESULT
FindObject(
	 IN    LPTSTR      szName,
	 IN    objectClass cls,
	 OUT   LPTSTR &  szPath
	)
{
   _TCHAR   szFilter[IDS_MAX_FILTLEN]     = {0};  // the search filter we'll use
   _TCHAR   szSearchBase[IDS_MAX_FILTLEN] = {0};  // the root to search from
   LPTSTR  pszAttr[]                 = {_TEXT("distinguishedName")};
   DWORD   dwAttrCount               = 1 , dwStrLen = 0;
   HRESULT hrStatus                  = S_OK;

   IDirectorySearch *  pintSearch = NULL;

   szPath = NULL;

   if ( !IsDSAvailable(&szPath) )
   {
      return E_IDS_NO_DS;
   }
   else if ( !szName )
   {
      return E_INVALIDARG;
   }
   // determine what we're looking for
   // and set up the filter
   _tcsncpy(szSearchBase, _TEXT("LDAP://"),IDS_MAX_FILTLEN-1);

   switch (cls)
   {
      case OBJCLS_OU:
         _tcsncpy(szFilter, _TEXT("(&(objectClass=organizationalUnit)(name="),IDS_MAX_FILTLEN-1);
         break;
      case OBJCLS_GPO:
         _tcsncpy(szFilter, _TEXT("(&(objectClass=groupPolicyContainer)(displayName="),IDS_MAX_FILTLEN-1);
         dwStrLen = _tcslen(szSearchBase);
         _tcsncat(szSearchBase, _TEXT("CN=Policies,CN=System,"),IDS_MAX_FILTLEN-dwStrLen-1);
         break;
      case OBJCLS_IPSEC_POLICY:
         _tcsncpy(szFilter, _TEXT("(&(objectClass=ipsecPolicy)(ipsecName="),IDS_MAX_FILTLEN-1);
         dwStrLen = _tcslen(szSearchBase);
         _tcsncat(szSearchBase, _TEXT("CN=IP Security,CN=System,"),IDS_MAX_FILTLEN-dwStrLen-1);
         break;
      case OBJCLS_CONTAINER:
         _tcsncpy(szFilter, _TEXT("(&(objectClass=container)(cn="),IDS_MAX_FILTLEN-1);
         break;
      case OBJCLS_COMPUTER:
         _tcsncpy(szFilter, _TEXT("(&(objectClass=computer)(cn="),IDS_MAX_FILTLEN-1);
         break;
      default:
         return CO_E_NOT_SUPPORTED;
   }

   dwStrLen = _tcslen(szFilter);
   _tcsncat(szFilter, szName,IDS_MAX_FILTLEN-dwStrLen-1);

   dwStrLen = _tcslen(szFilter);
   _tcsncat(szFilter, TEXT("))"),IDS_MAX_FILTLEN-dwStrLen-1);

   dwStrLen = _tcslen(szSearchBase);
   _tcsncat(szSearchBase, szPath + 7,IDS_MAX_FILTLEN-dwStrLen-1);  // get's past the LDAP://

   // the filter and search base are set up now
   // we need to get the IDirectorySearch interface
   // from the root of the domain
   hrStatus = ADsGetObject(szSearchBase, IID_IDirectorySearch,
                           (void **)&pintSearch);
   if ( SUCCEEDED(hrStatus) )
   {
      ADS_SEARCH_HANDLE hSearch = NULL;

      hrStatus = pintSearch->ExecuteSearch(szFilter, pszAttr,
                                           dwAttrCount, &hSearch);

      if ( SUCCEEDED(hrStatus) )
      {
         hrStatus = pintSearch->GetFirstRow(hSearch);
         // at this point, if we have a row, we have found the
         // object.
         if ( S_ADS_NOMORE_ROWS == hrStatus )
         {
            hrStatus = E_FAIL;
         }
         else if ( SUCCEEDED(hrStatus) )
         {
            ADS_SEARCH_COLUMN adsCol = {0};

            hrStatus = pintSearch->GetColumn(hSearch, pszAttr[0], &adsCol);

            if ( SUCCEEDED(hrStatus) &&
                 adsCol.pADsValues->dwType == ADSTYPE_DN_STRING )
            {

               if ( szPath )
                  CoTaskMemFree(szPath);

              	dwStrLen = _tcslen(adsCol.pADsValues->DNString) + _tcslen(TEXT("LDAP://"));
              	szPath = (LPTSTR)::CoTaskMemAlloc((dwStrLen +1) * sizeof(_TCHAR));
				if (szPath == NULL)
				{
					hrStatus=HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
					BAIL_OUT;
				}
               	memset(szPath ,0 ,(dwStrLen+1)*sizeof(TCHAR));
               	_tcsncpy(szPath, _TEXT("LDAP://"),dwStrLen+1);

               	_tcsncat(szPath, adsCol.pADsValues->DNString,dwStrLen- (_tcslen(szPath))+1);

            }
            else
            {
               hrStatus = E_IDS_NODNSTRING;
            }

            pintSearch->FreeColumn( &adsCol );
         }

         pintSearch->CloseSearchHandle(hSearch);
      }
   }
   if ( pintSearch )
   {
      pintSearch->Release();
   }
 error:
 	return hrStatus;
}

//////////////////////////////////////////////////////////////////////////////
//  Function:  AssignIPSecPolicyToGPO
//
//  Purpose:
//
//    Assigns (or unassigns) IPSec pol to GPO
//
//  Pre-conditions: None
//
//  Parameters:
//
//    IN    szPolicyName   ADsPath or name of ipsec pol
//    IN    szGPO          ADsPath or name of GPO
//	  IN   BOOL    bAssign
//
//  Returns:
//
//    ADSI errors
//    S_OK on success
//
//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>

//////////////////////////////////////////////////////////////////////////////

HRESULT
AssignIPSecPolicyToGPO(
		 IN   LPTSTR  szPolicyName,
		 IN   LPTSTR  szGPO,
		 IN   BOOL    bAssign
	  )
{
   HRESULT  hr = S_OK;
   LPTSTR   szIPSecPolPath = NULL,
            szGPOPath      = NULL;

   _TCHAR    szMachinePath[IDS_MAX_PATHLEN] = {0};

   IGroupPolicyObject * pintGPO = NULL;
   GUID guidClientExt = CLSID_IPSECClientEx;
   GUID guidSnapin = CLSID_Snapin;

   hr = CoInitialize(NULL);

   if (FAILED(hr))
   {
	   BAIL_OUT;
   }

   if ( !szGPO )
   {
      return E_INVALIDARG;
   }
   //
   // First, get the ipsec policy object
   // and get the GPO objects
   //
   if ( szPolicyName && !IsADsPath(szPolicyName) )
   {
      hr = FindObject(szPolicyName, OBJCLS_IPSEC_POLICY, szIPSecPolPath);
   }
   else
   {
      szIPSecPolPath = szPolicyName;
   }
   // now get the GPO
   if ( SUCCEEDED(hr) )
   {
      if ( !IsADsPath(szGPO) )
      {
         hr = FindObject(szGPO, OBJCLS_GPO, szGPOPath);
      }
      else
      {
         szGPOPath = szGPO;
      }

      hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL, CLSCTX_ALL,
                            IID_IGroupPolicyObject, (void **)&pintGPO);

      if ( SUCCEEDED(hr) )
      {
         //
         // we need to hand off the domain path name
         // FindObject returned it in szPath
         //
         hr = pintGPO->OpenDSGPO(szGPOPath, FALSE);
         if ( SUCCEEDED(hr) )
         {
            //
            // We want to get the path to the GPO's machine container
            //
            hr = pintGPO->GetDSPath(GPO_SECTION_MACHINE, szMachinePath,
                               IDS_MAX_PATHLEN);
         }
      }
   }
   if ( SUCCEEDED(hr) )
   {
      LPTSTR   szName         = NULL,
               szDescription  = NULL;

      if ( szIPSecPolPath )
      {
         if(bAssign)
         {
			 //
			 // Assignment
			 hr = GetIPSecPolicyInfo(szIPSecPolPath, szName, szDescription);
			 if ( SUCCEEDED(hr) )
			 {
				// if description is NULL, pass blank str to make ADSI happy
				//
				hr = AddPolicyInformationToGPO(szMachinePath,
											szName,
											(szDescription) ? szDescription : TEXT(" "),
											szIPSecPolPath);

				// Need to write the changes to the GPO
				if ( SUCCEEDED(hr) )
				{
				   hr = pintGPO->Save(TRUE, TRUE, &guidClientExt,
							   &guidSnapin);
				}
			 }
			 if ( szName )
				CoTaskMemFree(szName);
			 if ( szDescription )
				CoTaskMemFree(szDescription);
		}
		else
		{
			 // Unassignment
			 hr = DeletePolicyInformationFromGPO(szMachinePath);
			 // Need to write the changes to the GPO
			 if ( SUCCEEDED(hr) )
			 {
				pintGPO->Save(TRUE, FALSE, &guidClientExt,
							&guidSnapin);
			 }
      	}
      }
   }
   if ( pintGPO )
      pintGPO->Release();
error:
   return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:  GetIPSecPolicyInfo
//
//  Purpose:
//
//    Gets the name and description of an ipsec policy
//    given an ADs path to the policy
//
//  Pre-conditions:  None
//
//  Parameters:
//          IN szPath ADsPath to policy
//          OUT szName, szDescription
//          NOTE: caller MUST free with CoTaskMemFree
//
//  Returns:
//       anything from ADsGetObject
//       E_FAIL if Name not found
//
//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>

//////////////////////////////////////////////////////////////////////////////

HRESULT
GetIPSecPolicyInfo(
		 IN  LPTSTR   szPath,
		 OUT LPTSTR & szName,
		 OUT LPTSTR & szDescription
		 )
{
	HRESULT  hr          = S_OK;
	DWORD    dwNumAttr   = 2,
			dwNumRecvd  = 0,
			dwStrLen    = 0;

	LPTSTR               pszAttr[]            = {TEXT("ipsecName"), TEXT("description")};
	ADS_ATTR_INFO     *  pattrInfo            = NULL;
	IDirectoryObject  *  pintDirObj           = NULL;
	//
	// init these to NULL, if the attr's not found, they will stay NULL
	//
	szName = szDescription = NULL;

	hr = ADsGetObject(szPath, IID_IDirectoryObject, (void **)&pintDirObj);
	BAIL_ON_FAILURE(hr);

	hr = pintDirObj->GetObjectAttributes(pszAttr, dwNumAttr, &pattrInfo, &dwNumRecvd);
	BAIL_ON_FAILURE(hr);
	for ( DWORD i = 0; i < dwNumRecvd; ++i )
	{
		if ( !_tcscmp(pattrInfo[i].pszAttrName, TEXT("ipsecName")) )
		{
			dwStrLen = _tcslen(pattrInfo[i].pADsValues->DNString);
			szName = (LPTSTR)CoTaskMemAlloc((dwStrLen + 1)
										   * sizeof (_TCHAR));
			if (szName == NULL)
			{
				hr=HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
				BAIL_OUT;
			}
			_tcsncpy(szName, pattrInfo[i].pADsValues->DNString,dwStrLen + 1);
		}
		else if ( !_tcscmp(pattrInfo[i].pszAttrName, TEXT("description")) )
		{
			dwStrLen = _tcslen(pattrInfo[i].pADsValues->DNString);
			szDescription = (LPTSTR)CoTaskMemAlloc((dwStrLen + 1)
										   * sizeof (_TCHAR));
			if (szDescription == NULL)
			{
				hr=HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
				BAIL_OUT;
			}
			_tcsncpy(szDescription, pattrInfo[i].pADsValues->DNString,dwStrLen + 1);
		}
	}
	pintDirObj->Release();
	FreeADsMem(pattrInfo);
	//
	// if szName is NULL, it wasn't found and it is an error
	// description CAN be NULL
	//
	if ( !szName )
	{
	  hr = E_FAIL;
	}
error:
	return hr;
}

///////////////////////////////////////////////////////////////////////////
//Function: CreateDirectoryAndBindToObject()

//Date of Creation: 21st Aug 2001

//Parameters:
//	IDirectoryObject * pParentContainer,
//	LPWSTR pszCommonName,
//	LPWSTR pszObjectClass,
//    IDirectoryObject ** ppDirectoryObject

//Return: HRESULT

//Description:
//	This function created a AD object

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////////

HRESULT
CreateDirectoryAndBindToObject(
    IDirectoryObject * pParentContainer,
    LPWSTR pszCommonName,
    LPWSTR pszObjectClass,
    IDirectoryObject ** ppDirectoryObject
    )
{
    ADS_ATTR_INFO AttrInfo[2];
    ADSVALUE classValue;
    HRESULT hr = S_OK;
    IADsContainer * pADsContainer = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrObjectClass = NULL, bstrCommonName = NULL;
    DWORD dwReturn = ERROR_SUCCESS;
    //
    // Populate ADS_ATTR_INFO structure for new object
    //
    classValue.dwType = ADSTYPE_CASE_IGNORE_STRING;
    classValue.CaseIgnoreString = pszObjectClass;

    AttrInfo[0].pszAttrName = _TEXT("objectClass");
    AttrInfo[0].dwControlCode = ADS_ATTR_UPDATE;
    AttrInfo[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    AttrInfo[0].pADsValues = &classValue;
    AttrInfo[0].dwNumValues = 1;

    hr = pParentContainer->CreateDSObject(
                                pszCommonName,
                                AttrInfo,
                                1,
                                &pDispatch
                                );
    if ((FAILED(hr) && (hr == E_ADS_OBJECT_EXISTS)) ||
        (FAILED(hr) && (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)))){

        hr = pParentContainer->QueryInterface(
                                    IID_IADsContainer,
                                    (void **)&pADsContainer
                                    );
        BAIL_ON_FAILURE(hr);

	    dwReturn = AllocBSTRMem(pszObjectClass,bstrObjectClass);
	    hr = HRESULT_FROM_WIN32(dwReturn);
		BAIL_ON_WIN32_ERROR(dwReturn);

	    dwReturn = AllocBSTRMem(pszCommonName,bstrCommonName);
	    hr = HRESULT_FROM_WIN32(dwReturn);
		BAIL_ON_WIN32_ERROR(dwReturn);

		hr = pADsContainer->GetObject(
		                        bstrObjectClass,
		                        bstrCommonName,
		                        &pDispatch
                        		);

		SysFreeString(bstrObjectClass);
		SysFreeString(bstrCommonName);

        BAIL_ON_FAILURE(hr);
    }

    hr = pDispatch->QueryInterface(
                    IID_IDirectoryObject,
                    (void **)ppDirectoryObject
                    );

error:

    if (pADsContainer) {

        pADsContainer->Release();
    }

    if (pDispatch) {

        pDispatch->Release();
    }
    return(hr);
}
///////////////////////////////////////////////////////////////////////////

//Function: CreateChildPath()

//Date of Creation: 21st Aug 2001

//Parameters:
//	IN LPWSTR pszParentPath,
//	IN LPWSTR pszChildComponent,
//    OUT BSTR * ppszChildPath

//Return: HRESULT

//Description:
//	This function creates the required path in the AD

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////////

HRESULT
CreateChildPath(
    IN LPWSTR pszParentPath,
    IN LPWSTR pszChildComponent,
    OUT BSTR * ppszChildPath
    )
{
    HRESULT hr = S_OK;
    IADsPathname     *pPathname = NULL;
    BSTR bstrParentPath = NULL,bstrChildComponent=NULL;
    DWORD dwReturn = ERROR_SUCCESS;

    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_IADsPathname,
                (void**)&pPathname
                );

    if (FAILED(hr))
    {
		BAIL_OUT;
    }

    dwReturn = AllocBSTRMem(pszParentPath,bstrParentPath);
	hr = HRESULT_FROM_WIN32(dwReturn);
	BAIL_ON_WIN32_ERROR(dwReturn);

	hr = pPathname->Set(bstrParentPath, ADS_SETTYPE_FULL);
	SysFreeString(bstrParentPath);
    BAIL_ON_FAILURE(hr);

	dwReturn = AllocBSTRMem(pszChildComponent,bstrChildComponent);
	hr = HRESULT_FROM_WIN32(dwReturn);
	BAIL_ON_WIN32_ERROR(dwReturn);


	hr = pPathname->AddLeafElement(bstrChildComponent);
	SysFreeString(bstrChildComponent);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Retrieve(ADS_FORMAT_X500, ppszChildPath);
    BAIL_ON_FAILURE(hr);

error:
    if (pPathname) {
        pPathname->Release();
    }

    return(hr);
}

///////////////////////////////////////////////////////////////////////////

//Function: ConvertADsPathToDN()

//Date of Creation: 21st Aug 2001

//Parameters:
//	IN LPWSTR pszPathName,
//    OUT BSTR * ppszPolicyDN

//Return: HRESULT

//Description:
//	This function converts ADs path to DN path

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////////

HRESULT
ConvertADsPathToDN(
    IN LPWSTR pszPathName,
    OUT BSTR * ppszPolicyDN
    )
{
    HRESULT hr = S_OK;
    IADsPathname     *pPathname = NULL;
    BSTR bstrPathName =NULL;
    DWORD dwReturn = ERROR_SUCCESS;

    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_IADsPathname,
                (void**)&pPathname
                );

    if (FAILED(hr))
    {
		BAIL_OUT;
    }


	dwReturn = AllocBSTRMem(pszPathName,bstrPathName);
	hr = HRESULT_FROM_WIN32(dwReturn);
	BAIL_ON_WIN32_ERROR(dwReturn);


    hr = pPathname->Set(bstrPathName, ADS_SETTYPE_FULL);
	SysFreeString(bstrPathName);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Retrieve(ADS_FORMAT_X500_DN, ppszPolicyDN);
    BAIL_ON_FAILURE(hr);

error:

    if (pPathname) {
        pPathname->Release();
    }
    return(hr);
}
///////////////////////////////////////////////////////////////////////////

//Function: AddPolicyInformationToGPO()

//Date of Creation: 21st Aug 2001

//Parameters:
//	IN LPWSTR pszMachinePath,
//	IN LPWSTR pszName,
//	IN LPWSTR pszDescription,
//    IN LPWSTR pszPathName

//Return: HRESULT

//Description:
//	This function assigns the policy info to the specified GPO.

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////////

HRESULT
AddPolicyInformationToGPO(
    IN LPWSTR pszMachinePath,
    IN LPWSTR pszName,
    IN LPWSTR pszDescription,
    IN LPWSTR pszPathName
    )
{

    HRESULT hr = S_OK;
    IDirectoryObject * pMachineContainer = NULL;
    IDirectoryObject * pIpsecObject = NULL;
    IDirectoryObject * pWindowsContainer = NULL;
    IDirectoryObject * pMicrosoftContainer = NULL;

    BSTR pszMicrosoftPath = NULL;
    BSTR pszIpsecPath = NULL;
    BSTR pszWindowsPath = NULL;
    BSTR pszPolicyDN = NULL;

    ADS_ATTR_INFO AttrInfo[4];
    ADSVALUE PolicyPathValue;
    ADSVALUE PolicyNameValue;
    ADSVALUE PolicyDescriptionValue;


    memset((LPBYTE)AttrInfo, 0, sizeof(ADS_ATTR_INFO)*4);
    memset((LPBYTE)&PolicyPathValue, 0, sizeof(ADSVALUE));
    memset((LPBYTE)&PolicyNameValue, 0, sizeof(ADSVALUE));
    memset((LPBYTE)&PolicyDescriptionValue, 0, sizeof(ADSVALUE));

    DWORD dwNumModified = 0;

    hr = ADsGetObject(
                pszMachinePath,
                IID_IDirectoryObject,
                (void **)&pMachineContainer
                );
    BAIL_ON_FAILURE(hr);


    // Build the fully qualified ADsPath for my object


    hr = CreateChildPath(
                pszMachinePath,
                _TEXT("cn=Microsoft"),
                &pszMicrosoftPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszMicrosoftPath,
                _TEXT("cn=Windows"),
                &pszWindowsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszWindowsPath,
                _TEXT("cn=ipsec"),
                &pszIpsecPath
                );
    BAIL_ON_FAILURE(hr);


    hr = ADsGetObject(
            pszIpsecPath,
            IID_IDirectoryObject,
            (void **)&pIpsecObject
            );

    if (FAILED(hr)) {

        //
        // Bind to the Machine Container
        //
        hr = CreateDirectoryAndBindToObject(
                        pMachineContainer,
                        _TEXT("cn=Microsoft"),
                        _TEXT("container"),
                        &pMicrosoftContainer
                        );
        BAIL_ON_FAILURE(hr);

        hr = CreateDirectoryAndBindToObject(
                        pMicrosoftContainer,
                        _TEXT("cn=Windows"),
                        _TEXT("container"),
                        &pWindowsContainer
                        );
        BAIL_ON_FAILURE(hr);

        hr = CreateDirectoryAndBindToObject(
                        pWindowsContainer,
                        _TEXT("cn=IPSEC"),
                        _TEXT("ipsecPolicy"),
                        &pIpsecObject
                        );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Input pszPathName is an ADsPathName
    // We need to reduce it to a DN and store it
    // in the ipsecOwnersReference (a multi-valued DN attribute)
    //

    hr = ConvertADsPathToDN(
                pszPathName,
                &pszPolicyDN
                );
    BAIL_ON_FAILURE(hr);
    //
    // Populate ADS_ATTR_INFO structure for new object
    //
    PolicyPathValue.dwType = ADSTYPE_CASE_IGNORE_STRING;
    PolicyPathValue.CaseIgnoreString = pszPolicyDN;

    AttrInfo[0].pszAttrName = _TEXT("ipsecOwnersReference");
    AttrInfo[0].dwControlCode = ADS_ATTR_UPDATE;
    AttrInfo[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    AttrInfo[0].pADsValues = &PolicyPathValue;
    AttrInfo[0].dwNumValues = 1;
    //
    // Populate ADS_ATTR_INFO structure for new object
    //

    PolicyNameValue.dwType = ADSTYPE_CASE_IGNORE_STRING;
    PolicyNameValue.CaseIgnoreString = pszName;

    AttrInfo[1].pszAttrName = _TEXT("ipsecName");
    AttrInfo[1].dwControlCode = ADS_ATTR_UPDATE;
    AttrInfo[1].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    AttrInfo[1].pADsValues = &PolicyNameValue;
    AttrInfo[1].dwNumValues = 1;
    //
    // Populate ADS_ATTR_INFO structure for new object
    //
    PolicyDescriptionValue.dwType = ADSTYPE_CASE_IGNORE_STRING;
    PolicyDescriptionValue.CaseIgnoreString = pszDescription;

    AttrInfo[2].pszAttrName = _TEXT("description");
    AttrInfo[2].dwControlCode = ADS_ATTR_UPDATE;
    AttrInfo[2].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    AttrInfo[2].pADsValues = &PolicyDescriptionValue;
    AttrInfo[2].dwNumValues = 1;
    //
    // Now populate our object with our data.
    //

    hr = pIpsecObject->SetObjectAttributes(
                        AttrInfo,
                        3,
                        &dwNumModified
                        );
error:

    if (pIpsecObject) {
        pIpsecObject->Release();
    }

    if (pMicrosoftContainer) {
        pMicrosoftContainer->Release();
    }

    if (pWindowsContainer) {
        pWindowsContainer->Release();
    }

    if (pMachineContainer) {
        pMachineContainer->Release();
    }

    if (pszMicrosoftPath) {
        SysFreeString(pszMicrosoftPath);
    }

    if (pszPolicyDN) {
        SysFreeString(pszPolicyDN);
    }

    if (pszWindowsPath) {
        SysFreeString(pszWindowsPath);

    }

    if (pszIpsecPath) {
        SysFreeString(pszIpsecPath);
    }
    return(hr);
}
///////////////////////////////////////////////////////////////////////////

//Function: DeletePolicyInformationFromGPO()

//Date of Creation: 21st Aug 2001

//Parameters:
//	IN LPWSTR pszMachinePath,

//Return: HRESULT

//Description:
//	This function unassigns the policy info to the specified GPO.

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////////

HRESULT
DeletePolicyInformationFromGPO(
    IN LPWSTR pszMachinePath
    )
{
    HRESULT hr = S_OK;
    IDirectoryObject * pIpsecObject = NULL;
    IDirectoryObject * pWindowsContainer = NULL;

    BSTR pszMicrosoftPath = NULL;
    BSTR pszIpsecPath = NULL;
    BSTR pszWindowsPath = NULL;


    // Build the fully qualified ADsPath for my object


    hr = CreateChildPath(
                pszMachinePath,
                _TEXT("cn=Microsoft"),
                &pszMicrosoftPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszMicrosoftPath,
                _TEXT("cn=Windows"),
                &pszWindowsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszWindowsPath,
                _TEXT("cn=ipsec"),
                &pszIpsecPath
                );
    BAIL_ON_FAILURE(hr);


    hr = ADsGetObject(
            pszIpsecPath,
            IID_IDirectoryObject,
            (void **)&pIpsecObject
            );
    if (FAILED(hr)) {

        //
        // This means there is no object, need to
        // test that it is because the object does
        // not exist.
        //

        hr = S_OK;
        goto error;
    }

    if (SUCCEEDED(hr)) {

        pIpsecObject->Release();
        pIpsecObject = NULL;

        hr = ADsGetObject(
                pszWindowsPath,
                IID_IDirectoryObject,
                (void **)&pWindowsContainer
                );
        BAIL_ON_FAILURE(hr);

        hr = pWindowsContainer->DeleteDSObject(
                            _TEXT("cn=ipsec")
                            );

    }
error:

    if (pIpsecObject) {
        pIpsecObject->Release();
    }

    if (pWindowsContainer) {
        pWindowsContainer->Release();
    }

    if (pszMicrosoftPath) {
        SysFreeString(pszMicrosoftPath);
    }

    if (pszWindowsPath) {
        SysFreeString(pszWindowsPath);
    }

    if (pszIpsecPath) {
        SysFreeString(pszIpsecPath);
    }
    return(hr);
}

///////////////////////////////////////////////////////////////////////////

//Function: IsADsPath()

//Date of Creation: 21st Aug 2001

//Parameters:
//	IN LPTSTR szPath

//Return: BOOL

//Description:
//	This function checks whether the specified string is valid ADs path

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////////

BOOL
   IsADsPath(
	   IN LPTSTR szPath
	   )
{
   return !_tcsncmp(szPath, _TEXT("LDAP://"), 7);
}

///////////////////////////////////////////////////////////////////////

//Function: StripGUIDBraces()

//Date of Creation: 21st Aug 2001

//Parameters:
//	IN OUT LPTSTR & pszStr


//Return: VOID

//Description:
//	This function strips the end braces from the GUID string

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////


VOID
StripGUIDBraces(
	IN OUT LPTSTR & pszGUIDStr
	)
{
	LPTSTR pszLocalStr=NULL;
	if(!pszGUIDStr)
	{
		BAIL_OUT;
	}
	pszLocalStr = _tcschr(pszGUIDStr,CLOSE_GUID_BRACE);
	if(pszLocalStr)
		*pszLocalStr = _T('\0');

	pszLocalStr = _tcschr(pszGUIDStr,OPEN_GUID_BRACE);
	if(pszLocalStr)
	{
		pszLocalStr++;
		memmove(pszGUIDStr,(const void *)pszLocalStr,sizeof(TCHAR)*(_tcslen(pszLocalStr)+1));
	}
error:
	return;
}

///////////////////////////////////////////////////////////////////////

//Function: AllocBSTRMem()

//Date of Creation: 21st Aug 2001

//Parameters:
//	IN LPTSTR  pszStr,
//	IN OUT BSTR & pbsStr

//Return: DWORD

//Description:
//	This function strips the end braces from the GUID string

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////


DWORD
AllocBSTRMem(
	IN LPTSTR  pszStr,
	IN OUT BSTR & pbsStr
	)
{
	DWORD dwReturnCode=ERROR_SUCCESS;

	if(!pszStr)
	{
		dwReturnCode=ERROR_INVALID_DATA;
		BAIL_OUT;
	}
	pbsStr = SysAllocString(pszStr);

	if(!pbsStr)
	{
		if (*pszStr)
		{
			dwReturnCode=ERROR_OUTOFMEMORY;
		}
		else
		{
			dwReturnCode=ERROR_INVALID_DATA;
		}
	}
error:
	return dwReturnCode;
}

///////////////////////////////////////////////////////////////////////

//Function: CleanUpAuthInfo()

//Date of Creation: 21st Aug 2001

//Parameters:
//	PIPSEC_NFA_DATA &pRule

//Return: VOID

//Description:
//	This function cleans up the auth info memory of rule

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////

VOID
CleanUpAuthInfo(
	PIPSEC_NFA_DATA &pRule
	)
{
	DWORD i=0;

	if(pRule->ppAuthMethods)
	{
		for (i = 0; i <  pRule->dwAuthMethodCount; i++)
		{
			if(pRule->ppAuthMethods[i])
			{
				if(pRule->ppAuthMethods[i]->pAltAuthMethod!=NULL)
				{
					IPSecFreePolMem(pRule->ppAuthMethods[i]->pAltAuthMethod);
				}
				IPSecFreePolMem(pRule->ppAuthMethods[i]);
			}
		}
		IPSecFreePolMem(pRule->ppAuthMethods);
	}
}

///////////////////////////////////////////////////////////////////////

//Function: CleanUpPolicy()

//Date of Creation: 21st Aug 2001

//Parameters:
//	PIPSEC_POLICY_DATA &pPolicy

//Return: VOID

//Description:
//	This function cleans up the policy info

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////


VOID
CleanUpPolicy(
	PIPSEC_POLICY_DATA &pPolicy
	)
{
	if(pPolicy)
	{
		if(pPolicy->pIpsecISAKMPData)
		{
			if(pPolicy->pIpsecISAKMPData->pSecurityMethods)
			{
				IPSecFreePolMem(pPolicy->pIpsecISAKMPData->pSecurityMethods);
			}
			IPSecFreePolMem(pPolicy->pIpsecISAKMPData);
		}
		IPSecFreePolMem(pPolicy);
		pPolicy=NULL;
	}
}

///////////////////////////////////////////////////////////////////////

//Function: CleanUpLocalRuleDataStructure()

//Date of Creation: 21st Aug 2001

//Parameters:
//	PRULEDATA &pRuleData

//Return: VOID

//Description:
//	This function cleans up the local Rule Structure

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////


VOID
CleanUpLocalRuleDataStructure(
	PRULEDATA &pRuleData
	)
{
	DWORD j=0;

	if (pRuleData)
	{
		if (pRuleData->pszRuleName)
		{
			delete [] pRuleData->pszRuleName;
		}
		if (pRuleData->pszNewRuleName)
		{
			delete [] pRuleData->pszNewRuleName;
		}
		if (pRuleData->pszRuleDescription)
		{
			delete [] pRuleData->pszRuleDescription;
		}
		if (pRuleData->pszPolicyName)
		{
			delete [] pRuleData->pszPolicyName;
		}
		if (pRuleData->pszFLName)
		{
			delete [] pRuleData->pszFLName;
		}
		if (pRuleData->pszFAName)
		{
			delete [] pRuleData->pszFAName;
		}

		for (j=0;j<pRuleData->AuthInfos.dwNumAuthInfos;j++)
		{
			if (pRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo)
			{
				if (pRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo->AuthMethod == IKE_RSA_SIGNATURE &&
					pRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo->pAuthInfo
					)
				{
					delete [] pRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo->pAuthInfo;
				}
				delete pRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo;
			}
		}

		if (pRuleData->AuthInfos.pAuthMethodInfo)
		{
			delete [] pRuleData->AuthInfos.pAuthMethodInfo;
		}
		delete pRuleData;
		pRuleData = NULL;
	}
}

///////////////////////////////////////////////////////////////////////

//Function: CleanUpLocalPolicyDataStructure()

//Date of Creation: 21st Aug 2001

//Parameters:
//	PPOLICYDATA &pPolicyData

//Return: VOID

//Description:
//	This function cleans up the local policy Structure

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////

VOID
CleanUpLocalPolicyDataStructure(
	PPOLICYDATA &pPolicyData
	)
{
	if(pPolicyData)
	{
		if (pPolicyData->pszPolicyName)
		{
			delete [] pPolicyData->pszPolicyName;
		}
		if (pPolicyData->pszNewPolicyName)
		{
			delete [] pPolicyData->pszNewPolicyName;
		}
		if (pPolicyData->pszDescription)
		{
			delete [] pPolicyData->pszDescription;
		}
		if (pPolicyData->pszGPOName)
		{
			delete [] pPolicyData->pszGPOName;
		}
		if (pPolicyData->pIpSecMMOffer)
		{
			delete [] pPolicyData->pIpSecMMOffer;
		}
		delete pPolicyData;
		pPolicyData = NULL;
	}
}

///////////////////////////////////////////////////////////////////////

//Function: CleanUpLocalFilterActionDataStructure()

//Date of Creation: 21st Aug 2001

//Parameters:
//	PFILTERACTION &pFilterAction

//Return: VOID

//Description:
//	This function cleans up the local filteraction Structure

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////


VOID
CleanUpLocalFilterActionDataStructure(
	PFILTERACTION &pFilterAction
	)
{
	if(pFilterAction)
	{
		if(pFilterAction->pszFAName)
		{
			delete [] pFilterAction->pszFAName;
		}
		if(pFilterAction->pszNewFAName)
		{
			delete [] pFilterAction->pszNewFAName;
		}
		if(pFilterAction->pszFADescription)
		{
			delete [] pFilterAction->pszFADescription;
		}
		if(pFilterAction->pszGUIDStr)
		{
			delete [] pFilterAction->pszGUIDStr;
		}
		if(pFilterAction->pIpsecSecMethods)
		{
			delete [] pFilterAction->pIpsecSecMethods;
		}
		delete pFilterAction;
		pFilterAction=NULL;

	}
}


///////////////////////////////////////////////////////////////////////

//Function: CleanUpLocalFilterDataStructure()

//Date of Creation: 21st Aug 2001

//Parameters:
//	PFILTERDATA &pFilter

//Return: VOID

//Description:
//	This function cleans up the local filter Structure

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////

VOID
CleanUpLocalFilterDataStructure(
	PFILTERDATA &pFilter
	)
{
	if(pFilter)
	{
		if(pFilter->pszFLName)
		{
			delete [] pFilter->pszFLName;
		}
		if(pFilter->pszDescription)
		{
			delete [] pFilter->pszDescription;
		}
		if(pFilter->SourceAddr.pszDomainName)
		{
			delete [] pFilter->SourceAddr.pszDomainName;
		}
		if(pFilter->DestnAddr.pszDomainName)
		{
			delete [] pFilter->DestnAddr.pszDomainName;
		}
		if(pFilter->SourceAddr.puIpAddr)
		{
			delete [] pFilter->SourceAddr.puIpAddr;
		}
		if(pFilter->DestnAddr.puIpAddr)
		{
			delete [] pFilter->DestnAddr.puIpAddr;
		}
		delete pFilter;
		pFilter = NULL;
	}
}

///////////////////////////////////////////////////////////////////////

//Function: CleanUpLocalDelFilterDataStructure()

//Date of Creation: 21st Aug 2001

//Parameters:
//	PFILTERDATA &pFilter

//Return: VOID

//Description:
//	This function cleans up the local filter Structure

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////

VOID
CleanUpLocalDelFilterDataStructure(
	PDELFILTERDATA &pFilter
	)
{
	if(pFilter)
	{
		if(pFilter->pszFLName)
		{
			delete [] pFilter->pszFLName;
		}
		if(pFilter->SourceAddr.pszDomainName)
		{
			delete [] pFilter->SourceAddr.pszDomainName;
		}
		if(pFilter->DestnAddr.pszDomainName)
		{
			delete [] pFilter->DestnAddr.pszDomainName;
		}
		if(pFilter->SourceAddr.puIpAddr)
		{
			delete [] pFilter->SourceAddr.puIpAddr;
		}
		if(pFilter->DestnAddr.puIpAddr)
		{
			delete [] pFilter->DestnAddr.puIpAddr;
		}
		delete pFilter;
		pFilter = NULL;
	}
}

///////////////////////////////////////////////////////////////////////

//Function: CleanUpLocalDefRuleDataStructure()

//Date of Creation: 21st Aug 2001

//Parameters:
//	PDEFAULTRULE &pRuleData

//Return: VOID

//Description:
//	This function cleans up the local default rule Structure

//Revision History:

//<Version number, Change request number, Date of modification,
//						Author, Nature of change>
///////////////////////////////////////////////////////////////////////

VOID
CleanUpLocalDefRuleDataStructure(
	PDEFAULTRULE &pDefRuleData
	)
{

	if(pDefRuleData)
	{
		if(pDefRuleData->pszPolicyName) delete [] pDefRuleData->pszPolicyName;

		for(DWORD j=0;j<pDefRuleData->AuthInfos.dwNumAuthInfos;j++)
		{
			if(&(pDefRuleData->AuthInfos.pAuthMethodInfo[j]) &&
				pDefRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo)
			{
				if(pDefRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo->pAuthInfo)
				{
					delete pDefRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo->pAuthInfo;
					pDefRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo->pAuthInfo = NULL;
				}
				delete pDefRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo;
				pDefRuleData->AuthInfos.pAuthMethodInfo[j].pAuthenticationInfo = NULL;
			}
		}

		if(pDefRuleData->AuthInfos.pAuthMethodInfo)
		{
			delete [] pDefRuleData->AuthInfos.pAuthMethodInfo;
		}
		if(pDefRuleData->pIpsecSecMethods)
		{
			delete [] pDefRuleData->pIpsecSecMethods;
		}
		delete pDefRuleData;
		pDefRuleData = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticmisc.h ===
//////////////////////////////////////////////////////////////////
//Header: staticmisc.h

// Purpose: 	Defining structures and prototypes for staticmisc.cpp.

// Developers Name: surya

// History:

//   Date    		Author    	Comments
//	21th Aug 2001	surya		Header for misc commands in static mode
//  <creation>  <author>

//   <modification> <author>  <comments, references to code sections,
//									in case of bug fixes>

//////////////////////////////////////////////////////////////////


#ifndef _STATICMISC_H_
#define _STATICMISC_H_

const TCHAR  IPSEC_FILE_EXTENSION[]       		= _T(".ipsec");

DWORD
CopyStorageInfo(
	OUT LPTSTR *ppszMachineName,
	OUT DWORD &dwLocation
	);

#endif // _STATICMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticmisc.cpp ===
//////////////////////////////////////////////////////////////////
//Module: Static/Staticmisc.cpp
//
// Purpose: 	Static Module Implementation. This module implements
//			miscellaneous commands of Static mode.
//
// Developers Name: Surya
//
// Revision History:
//
//   Date    	Author    	Comments
//	10-8-2001	Bharat		Initial Version. SCM Base line 1.0
//	21-8-2001 	Surya       Implemented misc functions.
//
//////////////////////////////////////////////////////////////////

#include "nshipsec.h"

//
//External Variables declaration
//
extern HINSTANCE g_hModule;

extern STORAGELOCATION g_StorageLocation;
extern CNshPolStore g_NshPolStoreHandle;
extern CNshPolNegFilData g_NshPolNegFilData;

//////////////////////////////////////////////////////////////////
//
//Function: HandleStaticImportPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Import Policy "
//
// Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////

DWORD
HandleStaticImportPolicy(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	LPTSTR pszMachineName=NULL,pszFileName=NULL,pszEnhancedFileName=NULL;
	DWORD dwFileLocation=IPSEC_FILE_PROVIDER;
	DWORD dwRet = ERROR_SHOW_USAGE,dwCount=0;
	HANDLE hhPolicyStorage=NULL, hFileStore=NULL;
	DWORD dwReturnCode = ERROR_SUCCESS , dwStrLength = 0, dwLocation;

	const TAG_TYPE vcmdStaticImportPolicy[] =
	{
		{ CMD_TOKEN_STR_FILE,		NS_REQ_PRESENT,	  FALSE	}
	};
	const TOKEN_VALUE vtokStaticImportPolicy[] =
	{
		{ CMD_TOKEN_STR_FILE,		CMD_TOKEN_FILE 			}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 2)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticImportPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticImportPolicy);

	parser.ValidCmd   = vcmdStaticImportPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticImportPolicy);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed user input

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticImportPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_FILE	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN && parser.Cmd[dwCount].pArg)
					{
						dwStrLength = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg);

						pszFileName= new _TCHAR[dwStrLength+1];
						if(pszFileName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszFileName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			default				:
					break;
		}
	}
	CleanUp();

	// if no file name, bail out

	if(!pszFileName)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MISC_STATIC_IMPORTPOLICY_1);
		BAIL_OUT;
	}

	dwReturnCode = CopyStorageInfo(&pszMachineName,dwLocation);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	// open pol store in normal way

	dwReturnCode = OpenPolicyStore(&hhPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	// open pol store with file name

	dwReturnCode = IPSecOpenPolicyStore(pszMachineName, dwFileLocation, pszFileName, &hFileStore);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	// call the API

	dwReturnCode = IPSecImportPolicies(hFileStore , hhPolicyStorage );

	if (dwReturnCode != ERROR_SUCCESS)
	{
		if(hFileStore)
		{
			IPSecClosePolicyStore(hFileStore);
			hFileStore=NULL;
		}
		// if no .ipsec extension, append it and again try
		dwStrLength = _tcslen(pszFileName)+_tcslen(IPSEC_FILE_EXTENSION);
		pszEnhancedFileName=new _TCHAR[dwStrLength+1];
		if(pszEnhancedFileName==NULL)
		{
			PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
			dwRet=ERROR_SUCCESS;
			BAIL_OUT;
		}
		_tcsncpy(pszEnhancedFileName,pszFileName,_tcslen(pszFileName)+1);			//allocation and error checking done above
		_tcsncat(pszEnhancedFileName,IPSEC_FILE_EXTENSION,_tcslen(IPSEC_FILE_EXTENSION) + 1);							//allocation and error checking done above
		dwReturnCode = IPSecOpenPolicyStore(pszMachineName, dwFileLocation, pszEnhancedFileName, &hFileStore);
		if (dwReturnCode != ERROR_SUCCESS)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
			dwRet=ERROR_SUCCESS;
			BAIL_OUT;
		}
		dwReturnCode = IPSecImportPolicies(hFileStore , hhPolicyStorage );
		if (dwReturnCode == ERROR_FILE_NOT_FOUND || dwReturnCode ==  ERROR_PATH_NOT_FOUND)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MISC_STATIC_IMPORTPOLICY_3);
		}
		else if (dwReturnCode != ERROR_SUCCESS)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MISC_STATIC_IMPORTPOLICY_4);
		}

		if(pszEnhancedFileName)
		{
			delete []pszEnhancedFileName;
		}
	}
	if(hFileStore)
	{
		IPSecClosePolicyStore(hFileStore);
	}

	dwRet=ERROR_SUCCESS;

	if(hhPolicyStorage)
	{
			ClosePolicyStore(hhPolicyStorage);
	}
	if(pszFileName) delete []pszFileName;

error:
	if (pszMachineName) delete []pszMachineName;
	return dwRet;
}

//////////////////////////////////////////////////////////////////
//
//Function: HandleStaticExportPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Export Policy "
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////

DWORD
HandleStaticExportPolicy(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	LPTSTR pszMachineName=NULL,pszFileName=NULL;
	DWORD FileLocation=IPSEC_FILE_PROVIDER;
	DWORD dwRet = ERROR_SHOW_USAGE,dwCount=0;
	HANDLE hPolicyStorage=NULL, hFileStore=NULL;
	DWORD  dwReturnCode   = ERROR_SUCCESS, dwStrLength = 0, dwLocation;

	const TAG_TYPE vcmdStaticExportPolicy[] =
	{
		{ CMD_TOKEN_STR_FILE,		NS_REQ_PRESENT,	  FALSE	}
	};
	const TOKEN_VALUE vtokStaticExportPolicy[] =
	{
		{ CMD_TOKEN_STR_FILE,		CMD_TOKEN_FILE 			}
	};

	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 2)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticExportPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticExportPolicy);

	parser.ValidCmd   = vcmdStaticExportPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticExportPolicy);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed user input

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticExportPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_FILE	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						dwStrLength = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg);

						pszFileName= new _TCHAR[dwStrLength+1];
						if(pszFileName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszFileName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			default				:
					break;
		}
	}

	CleanUp();

	// if no filename bail out

	if(!pszFileName)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MISC_STATIC_IMPORTPOLICY_1);
		BAIL_OUT;
	}

	dwReturnCode = CopyStorageInfo(&pszMachineName,dwLocation);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	//open the polstore two times one time in normal way and another time with filename
	dwReturnCode = IPSecOpenPolicyStore(pszMachineName, FileLocation, pszFileName, &hFileStore);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecExportPolicies(hPolicyStorage , hFileStore );

	// if something failed, throw the error messages to the user

	if (dwReturnCode == ERROR_INVALID_NAME)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MISC_STATIC_IMPORTPOLICY_3);
	}
	else if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MISC_STATIC_EXPORTPOLICY_2);
	}
	dwRet=dwReturnCode;
	ClosePolicyStore(hPolicyStorage);
	IPSecClosePolicyStore(hFileStore);

	if(pszFileName) delete []pszFileName;

error:
	if (pszMachineName) delete []pszMachineName;
	return dwRet;
}

/////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticSetStore()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Set Store "
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticSetStore(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	DWORD dwRet = ERROR_SHOW_USAGE, dwCount = 0;
	LPTSTR pszDomainName=NULL;
	HANDLE hPolicyStorage=NULL;
	BOOL bLocationSpecified=FALSE, bDomainSpecified=FALSE;
	DWORD dwReturnCode = ERROR_SUCCESS ,dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	DWORD dwLocation;

	const TAG_TYPE vcmdStaticSetStore[] =
	{
		{ CMD_TOKEN_STR_LOCATION,		NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_DS,				NS_REQ_ZERO,	  FALSE	}
	};

	const TOKEN_VALUE vtokStaticSetStore[] =
	{
		{ CMD_TOKEN_STR_LOCATION,	CMD_TOKEN_LOCATION		},
		{ CMD_TOKEN_STR_DS,			CMD_TOKEN_DS			}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticSetStore;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticSetStore);

	parser.ValidCmd   = vcmdStaticSetStore;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticSetStore);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed user info,

	for(dwCount = 0;dwCount < parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetStore[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_LOCATION:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						if (parser.Cmd[dwCount].pArg )
						{
						    dwLocation = *((DWORD*)parser.Cmd[dwCount].pArg);
    						bLocationSpecified=TRUE;
                        }    						
					}
					break;
					
			case CMD_TOKEN_DS		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
					{
						dwLocation = IPSEC_DIRECTORY_PROVIDER;

						if(parser.Cmd[dwCount].pArg )
						{
							dwStrLength = _tcslen((LPTSTR)parser.Cmd[dwCount].pArg);

							pszDomainName= new _TCHAR[dwStrLength+1];
							if(pszDomainName==NULL)
							{
								PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
								dwRet=ERROR_SUCCESS;
								BAIL_OUT;
							}
							_tcsncpy(pszDomainName,(LPTSTR)parser.Cmd[dwCount].pArg,dwStrLength+1);
						}

						bLocationSpecified=TRUE;

					}
					break;
			default					:
					break;
		}
	}

	CleanUp();

	if(bLocationSpecified)
	{
	    switch (dwLocation)
	    {
	        case IPSEC_DIRECTORY_PROVIDER:
	            dwRet = ConnectStaticMachine(
	                        pszDomainName, 
	                        dwLocation);
                if (dwRet == ERROR_INVALID_PARAMETER || dwRet == ERROR_DS_SERVER_DOWN)
                {
                    if (pszDomainName)
                    {
                        PrintErrorMessage(
                            IPSEC_ERR,
                            0,
                            ERRCODE_MISC_STATIC_SETSTORE_DOMAIN_NA,
                            pszDomainName);
                    }
                    else
                    {
                        PrintErrorMessage(
                            IPSEC_ERR,
                            0,
                            ERRCODE_MISC_STATIC_SETSTORE_NOT_DOMAIN_MEMBER,
                            pszDomainName);
                    }
                }
                else if (dwRet != ERROR_SUCCESS)
                {
                    PrintErrorMessage(WIN32_ERR, dwRet, NULL);
                }
	            break;

            case IPSEC_REGISTRY_PROVIDER:
            case IPSEC_PERSISTENT_PROVIDER:
                dwRet = ConnectStaticMachine(
                            g_StorageLocation.pszMachineName,
                            dwLocation
                            );
                if (dwRet != ERROR_SUCCESS)
                {
                    PrintErrorMessage(WIN32_ERR, dwRet, NULL);
                }
                break;

            default:
                dwRet = ERRCODE_ARG_INVALID;
                BAIL_OUT;
                break;
	    }

	}

error:

	return dwRet;
}

/////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticRestoreDefaults()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Restore Defaults "
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticRestoreDefaults(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	DWORD dwRet = ERROR_SHOW_USAGE,dwCount=0;
	HANDLE hPolicyStorage=NULL;
	DWORD   dwReturnCode   = ERROR_SUCCESS;
	BOOL bWin2kSpecified=FALSE;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticRestoreDefaults[] =
	{
		{ CMD_TOKEN_STR_RELEASE,		NS_REQ_PRESENT,	  FALSE	}
	};
	const TOKEN_VALUE vtokStaticRestoreDefaults[] =
	{
		{ CMD_TOKEN_STR_RELEASE,		CMD_TOKEN_RELEASE		}
	};

	if((g_StorageLocation.dwLocation == IPSEC_DIRECTORY_PROVIDER) || (g_StorageLocation.dwLocation == IPSEC_PERSISTENT_PROVIDER))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MISC_STATIC_RESDEFRULE_3);
		dwRet =  ERROR_SUCCESS;
		BAIL_OUT;
	}

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 2)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticRestoreDefaults;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticRestoreDefaults);

	parser.ValidCmd   = vcmdStaticRestoreDefaults;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticRestoreDefaults);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticRestoreDefaults[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_RELEASE	:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						if (*(DWORD *)parser.Cmd[dwCount].pArg== TOKEN_RELEASE_WIN2K)
						{
							bWin2kSpecified=TRUE;
						}
					}
					break;
			default					:
					break;
		}
	}

	CleanUp();

	// get the store location info

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if(bWin2kSpecified)
	{
		dwReturnCode = IPSecRestoreDefaultPolicies(hPolicyStorage);
	}
	else
	{
		//.NET case. API call is to be changed when applicable
		dwReturnCode = IPSecRestoreDefaultPolicies(hPolicyStorage);
	}

	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_MISC_STATIC_RESDEFRULE_2);
	}

	ClosePolicyStore(hPolicyStorage);
	dwRet=ERROR_SUCCESS;

error:
	return dwRet;
}

///////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticSetBatch()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//  IN OUT  LPWSTR          *ppwcArguments,
//  IN      DWORD           dwCurrentIndex,
//  IN      DWORD           dwArgCount,
//  IN      DWORD           dwFlags,
//  IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticSetBatch(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
 	DWORD dwRet = ERROR_SHOW_USAGE;
	DWORD dwCount=0;
	BOOL bBatchMode=FALSE;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticSetBatch[] =
	{
		{ CMD_TOKEN_STR_MODE,	NS_REQ_PRESENT,	FALSE }
	};

	const TOKEN_VALUE vtokStaticSetBatch[] =
	{
		{ CMD_TOKEN_STR_MODE,	CMD_TOKEN_MODE	}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}
	parser.ValidTok   = vtokStaticSetBatch;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticSetBatch);

	parser.ValidCmd   = vcmdStaticSetBatch;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticSetBatch);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	//this flag enables the cache operation

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetBatch[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_MODE		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						bBatchMode = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			default					:
					break;
		}
	}
	if (g_NshPolStoreHandle.SetBatchmodeStatus(bBatchMode) == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
	}

	g_NshPolNegFilData.FlushAll();

	CleanUp();

error:
	return dwRet;
}

///////////////////////////////////////////////////////////////////////
//
//Function: CopyStorageInfo()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT LPTSTR *ppszMachineName,
//	OUT DWORD &dwLoc
//
//Return: DWORD
//
//Description:
//	This function copys the Global storage info to local variables.
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD
CopyStorageInfo(
	OUT LPTSTR *ppszMachineName,
	OUT DWORD &dwLocation
	)
{
	DWORD dwReturn = ERROR_SUCCESS ,dwStrLength =0;
	LPTSTR pszMachineName = NULL;
	LPTSTR pszTarget = NULL;

	dwLocation = g_StorageLocation.dwLocation;
    if (dwLocation == IPSEC_DIRECTORY_PROVIDER)
    {
        pszTarget = g_StorageLocation.pszDomainName;
    }
    else
    {
        pszTarget = g_StorageLocation.pszMachineName;
    }

	if(_tcscmp(pszTarget, _TEXT("")) !=0)
	{
		dwStrLength = _tcslen(pszTarget);

		pszMachineName= new _TCHAR[dwStrLength+1];
		if(pszMachineName)
		{
			_tcsncpy(pszMachineName,pszTarget,dwStrLength+1);
		}
		else
		{
			dwReturn = ERROR_OUTOFMEMORY;
		}
	}
	*ppszMachineName = pszMachineName;

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticset.cpp ===
///////////////////////////////////////////////////////////////////////
//	Module			: 	Static/StaticSet.cpp
//
//	Purpose			: 	Static Set Implementation.
//
//	Developers Name	: 	Surya
//
//	Revision History:
//
//	Date    	Author    	Comments
//	10-8-2001	Bharat		Initial Version. SCM Base line 1.0
//
///////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern CNshPolStore g_NshPolStoreHandle;
extern STORAGELOCATION g_StorageLocation;
extern CNshPolNegFilData g_NshPolNegFilData;

///////////////////////////////////////////////////////////////////////
//Function: HandleStaticSetPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Set Policy "
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticSetPolicy(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	DWORD dwReturnCode= ERROR_SUCCESS;
	DWORD dwStrLength = 0;
	PIPSEC_POLICY_DATA pPolicy=NULL,pActive=NULL;
	BOOL bExists=TRUE,bISAKMP=FALSE;
	BOOL bCreateNewPolicy=TRUE;
	HANDLE hPolicyStorage = NULL;
	PPOLICYDATA pPolicyData=NULL;
	_TCHAR szUserInput[STRING_SIZE]={0};
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticSetPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_GUID,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_NEWNAME,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_MMPFS, 			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_QMPERMM,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_MMLIFETIME, 	NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_ACTIVATEDEFRULE,NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_PI,				NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_ASSIGN,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_GPONAME,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_MMSECMETHODS,	NS_REQ_ZERO,	  FALSE	}
	};
	const TOKEN_VALUE vtokStaticSetPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 				},
		{ CMD_TOKEN_STR_GUID,			CMD_TOKEN_GUID 				},
		{ CMD_TOKEN_STR_NEWNAME,		CMD_TOKEN_NEWNAME			},
		{ CMD_TOKEN_STR_DESCR,			CMD_TOKEN_DESCR				},
		{ CMD_TOKEN_STR_MMPFS, 			CMD_TOKEN_MMPFS				},
		{ CMD_TOKEN_STR_QMPERMM,		CMD_TOKEN_QMPERMM			},
		{ CMD_TOKEN_STR_MMLIFETIME,		CMD_TOKEN_MMLIFETIME		},
		{ CMD_TOKEN_STR_ACTIVATEDEFRULE,CMD_TOKEN_ACTIVATEDEFRULE 	},
		{ CMD_TOKEN_STR_PI,				CMD_TOKEN_PI 				},
		{ CMD_TOKEN_STR_ASSIGN,			CMD_TOKEN_ASSIGN			},
		{ CMD_TOKEN_STR_GPONAME,		CMD_TOKEN_GPONAME			},
		{ CMD_TOKEN_STR_MMSECMETHODS,	CMD_TOKEN_MMSECMETHODS		}
	};

	if (dwArgCount <= 3)
	{
		dwReturnCode = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticSetPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticSetPolicy);

	parser.ValidCmd   = vcmdStaticSetPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticSetPolicy);

	dwReturnCode = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturnCode != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwReturnCode==RETURN_NO_ERROR)
		{
			dwReturnCode = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	//get the parsed user input

	dwReturnCode = FillSetPolicyInfo(&pPolicyData,parser,vtokStaticSetPolicy);

	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		BAIL_OUT;
	}

	// check whether user specified correct mandatory parameters

 	if (!pPolicyData->pszPolicyName && !pPolicyData->pszGUIDStr)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_MISSING_POL_NAME);
		BAIL_OUT;
	}
	if(pPolicyData->bGUIDSpecified && pPolicyData->pszGUIDStr && !pPolicyData->bGuidConversionOk)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_5);
		BAIL_OUT;
	}

	if(pPolicyData->bPollIntervalSpecified && !IsWithinLimit(pPolicyData->dwPollInterval/60,POLLING_Min_MIN,POLLING_Min_MAX))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_POLL_INTERVAL_MSG,POLLING_Min_MIN,POLLING_Min_MAX);
		BAIL_OUT;
	}
	if(pPolicyData->bQMLimitSpecified && !IsWithinLimit(pPolicyData->dwQMLimit,QMPERMM_MIN,QMPERMM_MAX))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_QMPERMM_MSG,QMPERMM_MIN,QMPERMM_MAX);
		BAIL_OUT;
	}
	if(pPolicyData->bLifeTimeInsecondsSpecified && !IsWithinLimit(pPolicyData->LifeTimeInSeconds/60,P1_Min_LIFE_MIN,P1_Min_LIFE_MAX))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_LIFETIME_LIMIT_MSG,P1_Min_LIFE_MIN,P1_Min_LIFE_MAX);
		BAIL_OUT;
	}

	if (pPolicyData->bAssignSpecified && g_StorageLocation.dwLocation == IPSEC_DIRECTORY_PROVIDER && !pPolicyData->pszGPOName)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_MISSING_GPO_NAME_STR);
		dwReturnCode= ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	if(pPolicyData->pszGPOName) // if GPO specified, any modification to policy, will occur in domain.  not in machine
	{
	    if (g_StorageLocation.dwLocation != IPSEC_DIRECTORY_PROVIDER)
	    {
    		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_GPO_SPECIFIED_ON_NODOMAIN_POLICY);
    		dwReturnCode= ERROR_SHOW_USAGE;
    		BAIL_OUT;
	    }
	}

	// if gpo specified, open the domain polstore
	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		 PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		 dwReturnCode=ERROR_SUCCESS;
		 BAIL_OUT;
	}

	//check in the user specified policy exists. else bail out

	if (pPolicyData->pszPolicyName && !GetPolicyFromStore(&pPolicy,pPolicyData->pszPolicyName,hPolicyStorage))
	{
		if(g_StorageLocation.dwLocation == IPSEC_DIRECTORY_PROVIDER)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_INVALID_TUNNEL,pPolicyData->pszPolicyName);
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_3,pPolicyData->pszPolicyName);
		}
		bExists=FALSE;
	}
	else if (pPolicyData->bGUIDSpecified && !GetPolicyFromStoreBasedOnGuid(&pPolicy,pPolicyData,hPolicyStorage))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_CREATING_INFO,pPolicyData->pszGUIDStr);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}
	if (bExists && pPolicyData->pszNewPolicyName && CheckPolicyExistance(hPolicyStorage,pPolicyData->pszNewPolicyName))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POL_NEWNAME,pPolicyData->pszNewPolicyName);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if(bExists)
	{
		// check if the policy is read only

		if(pPolicy->dwFlags & POLSTORE_READONLY )
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_POL_READ_ONLY_OBJECT,pPolicy->pszIpsecName);
			BAIL_OUT;
		}
		//check the existing parameters with the new user specified parameters

		if (pPolicyData->pszNewPolicyName)
		{
			if(pPolicy->pszIpsecName) IPSecFreePolStr(pPolicy->pszIpsecName);
			pPolicy->pszIpsecName = IPSecAllocPolStr(pPolicyData->pszNewPolicyName);
			if (pPolicy->pszIpsecName == NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
		}
		if(pPolicyData->pszGPOName)  // for GPO purpose get the new policy name;
		{
			if(pPolicyData->pszPolicyName) delete [] pPolicyData->pszPolicyName;

			dwStrLength = _tcslen(pPolicy->pszIpsecName);

			pPolicyData->pszPolicyName= new _TCHAR[dwStrLength+1];
			if(pPolicyData->pszPolicyName == NULL)
			{
				PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
				dwReturnCode=ERROR_SUCCESS;
				BAIL_OUT;
			}
			_tcsncpy(pPolicyData->pszPolicyName , pPolicy->pszIpsecName,dwStrLength+1);
		}

		if (pPolicyData->pszDescription)
		{
			if(pPolicy->pszDescription)
			{
				IPSecFreePolStr(pPolicy->pszDescription);
			}
			pPolicy->pszDescription = IPSecAllocPolStr(pPolicyData->pszDescription);
			if (pPolicy->pszDescription == NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
		}

		if(pPolicyData->bPollIntervalSpecified)
		{
			pPolicy->dwPollingInterval =  pPolicyData->dwPollInterval;
		}

		if (pPolicyData->dwOfferCount==0)
		{
			for(DWORD j=0;j<pPolicy->pIpsecISAKMPData->dwNumISAKMPSecurityMethods;j++)
			{
				if(pPolicyData->bPFSSpecified)
				{
					pPolicy->pIpsecISAKMPData->pSecurityMethods[j].PfsIdentityRequired = pPolicyData->bPFS;
					bISAKMP=TRUE;
				}
				if(pPolicyData->bLifeTimeInsecondsSpecified)
				{
					pPolicy->pIpsecISAKMPData->pSecurityMethods[j].Lifetime.Seconds=pPolicyData->LifeTimeInSeconds;
					bISAKMP=TRUE;
				}
				if(pPolicyData->bQMLimitSpecified)
				{
					pPolicy->pIpsecISAKMPData->pSecurityMethods[j].QuickModeLimit = pPolicyData->dwQMLimit;
					bISAKMP=TRUE;
				}
			}
			pPolicy->pIpsecISAKMPData->ISAKMPPolicy.PfsIdentityRequired = pPolicy->pIpsecISAKMPData->pSecurityMethods[0].PfsIdentityRequired;
		}
		else if (pPolicyData->dwOfferCount > 0)
		{
			bISAKMP=TRUE;

			if(!pPolicyData->bQMLimitSpecified)
			{
				pPolicyData->dwQMLimit = pPolicy->pIpsecISAKMPData->pSecurityMethods[0].QuickModeLimit;
			}
			if(!pPolicyData->bLifeTimeInsecondsSpecified)
			{
				pPolicyData->LifeTimeInSeconds = pPolicy->pIpsecISAKMPData->pSecurityMethods[0].Lifetime.Seconds ;
			}
			if(!pPolicyData->bPFSSpecified)
			{
				pPolicyData->bPFS=pPolicy->pIpsecISAKMPData->pSecurityMethods[0].PfsIdentityRequired;
			}
			if (!pPolicyData->bCertToAccMappingSpecified)
			{
				if((g_StorageLocation.dwLocation!=IPSEC_DIRECTORY_PROVIDER && IsDomainMember(g_StorageLocation.pszMachineName))  ||
				   (g_StorageLocation.dwLocation==IPSEC_DIRECTORY_PROVIDER))
				{
					if(pPolicy->pIpsecISAKMPData->dwFlags & IPSEC_MM_POLICY_ENABLE_CERT_MAPPING )
					{
						pPolicyData->bCertToAccMappingSpecified=TRUE;
						pPolicyData->bCertToAccMapping=TRUE;
					}
				}
			}
			if(pPolicy->pIpsecISAKMPData)
			{
				if(pPolicy->pIpsecISAKMPData->pSecurityMethods)
				{
					IPSecFreePolMem(pPolicy->pIpsecISAKMPData->pSecurityMethods);
				}
				IPSecFreePolMem(pPolicy->pIpsecISAKMPData);
			}

			pPolicy->pIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) IPSecAllocPolMem(sizeof(IPSEC_ISAKMP_DATA));
			if(pPolicy->pIpsecISAKMPData==NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			memset(pPolicy->pIpsecISAKMPData,0,sizeof(IPSEC_ISAKMP_DATA));
			pPolicy->pIpsecISAKMPData->ISAKMPIdentifier = pPolicy->ISAKMPIdentifier;
			pPolicy->pIpsecISAKMPData->dwWhenChanged = 0;

			// sec methods details

			pPolicy->pIpsecISAKMPData->dwNumISAKMPSecurityMethods = pPolicyData->dwOfferCount;
			pPolicy->pIpsecISAKMPData->pSecurityMethods = (PCRYPTO_BUNDLE) IPSecAllocPolMem(sizeof(CRYPTO_BUNDLE)*pPolicyData->dwOfferCount);
			if(pPolicy->pIpsecISAKMPData->pSecurityMethods==NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			for (DWORD i = 0; i <  pPolicyData->dwOfferCount; i++)
			{
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].MajorVersion = 0;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].MinorVersion = 0;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].AuthenticationMethod = 0;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.AlgorithmIdentifier = 0;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.KeySize = 0;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.Rounds = 0;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].PfsIdentityRequired = pPolicyData->bPFS;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.AlgorithmIdentifier = pPolicyData->pIpSecMMOffer[i].EncryptionAlgorithm.uAlgoIdentifier;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.KeySize = pPolicyData->pIpSecMMOffer[i].EncryptionAlgorithm.uAlgoKeyLen;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.Rounds = pPolicyData->pIpSecMMOffer[i].EncryptionAlgorithm.uAlgoRounds;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.AlgorithmIdentifier = pPolicyData->pIpSecMMOffer[i].HashingAlgorithm.uAlgoIdentifier;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.KeySize = pPolicyData->pIpSecMMOffer[i].HashingAlgorithm.uAlgoKeyLen;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.Rounds = pPolicyData->pIpSecMMOffer[i].HashingAlgorithm.uAlgoRounds;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].OakleyGroup = pPolicyData->pIpSecMMOffer[i].dwDHGroup;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].QuickModeLimit = pPolicyData->dwQMLimit;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].Lifetime.KBytes = 0;
				pPolicy->pIpsecISAKMPData->pSecurityMethods[i].Lifetime.Seconds = pPolicyData->LifeTimeInSeconds;
			}
			// now for other details for  ISAKMPPolicy
			pPolicy->pIpsecISAKMPData->ISAKMPPolicy.PolicyId = pPolicy->ISAKMPIdentifier;
			pPolicy->pIpsecISAKMPData->ISAKMPPolicy.IdentityProtectionRequired = 0;
			pPolicy->pIpsecISAKMPData->ISAKMPPolicy.PfsIdentityRequired = pPolicy->pIpsecISAKMPData->pSecurityMethods[0].PfsIdentityRequired;
		}

		if(bISAKMP)
		{
			dwReturnCode = IPSecSetISAKMPData(hPolicyStorage, pPolicy->pIpsecISAKMPData);
		}

		for(DWORD k=0;k<pPolicy->dwNumNFACount;k++)
		{

			if ((pPolicy->ppIpsecNFAData[k]->pIpsecNegPolData->NegPolType == GUID_NEGOTIATION_TYPE_DEFAULT)&&(pPolicyData->bActivateDefaultRuleSpecified))
			{
				pPolicy->ppIpsecNFAData[k]->dwActiveFlag = pPolicyData->bActivateDefaultRule;
				dwReturnCode = IPSecSetNFAData(hPolicyStorage, pPolicy->PolicyIdentifier, pPolicy->ppIpsecNFAData[k]);
			}
		}

		if(dwReturnCode==ERROR_SUCCESS)
		{
			dwReturnCode = IPSecSetPolicyData(hPolicyStorage, pPolicy);

			if(dwReturnCode==ERROR_SUCCESS && g_NshPolStoreHandle.GetBatchmodeStatus())
			{
				// if required update cache also
				g_NshPolNegFilData.DeletePolicyFromCache(pPolicy);
			}
		}

		if(dwReturnCode!=ERROR_SUCCESS && pPolicyData->bPolicyNameSpecified && pPolicyData->pszPolicyName)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_INVALID_CERTMAP_MSG,pPolicyData->pszPolicyName);
		}
		else if(dwReturnCode!=ERROR_SUCCESS && pPolicyData->pszGUIDStr)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_CERTMAP_YES_STR,pPolicyData->pszGUIDStr);
		}

		// assign/unassign the policy based on the user request

		if (pPolicyData->bAssignSpecified && dwReturnCode==ERROR_SUCCESS)
		{
			if (g_StorageLocation.dwLocation!=IPSEC_DIRECTORY_PROVIDER)
			{
				if(pPolicyData->bAssign)
				{
					dwReturnCode =  IPSecGetAssignedPolicyData(hPolicyStorage, &pActive);
					if ( dwReturnCode == ERROR_SUCCESS || dwReturnCode ==ERROR_FILE_NOT_FOUND)
					{
						dwReturnCode = pActive ? IPSecUnassignPolicy(hPolicyStorage, pActive->PolicyIdentifier) : 0,
									   IPSecAssignPolicy(hPolicyStorage, pPolicy->PolicyIdentifier);
					}
					if (pActive)
					{
						IPSecFreePolicyData(pActive);
					}
				}
				else
				{
					dwReturnCode =  IPSecGetAssignedPolicyData(hPolicyStorage, &pActive);
					if ( dwReturnCode == ERROR_SUCCESS && pActive)
					{
						if (IsEqualGUID(pActive->PolicyIdentifier ,pPolicy->PolicyIdentifier))
						{
							IPSecUnassignPolicy(hPolicyStorage, pActive->PolicyIdentifier);
						}
						if (pActive)
						{
							IPSecFreePolicyData(pActive);
						}
					}
				}
			}
			else if ( g_StorageLocation.dwLocation == IPSEC_DIRECTORY_PROVIDER && !pPolicyData->pszGPOName)
			{
				PrintMessageFromModule(g_hModule,SET_STATIC_POLICY_MISSING_GPO_NAME_STR);
			}
		}
		dwReturnCode=ERROR_SUCCESS;
	}

	if(!bExists && bCreateNewPolicy && pPolicyData->bPolicyNameSpecified && pPolicyData->pszPolicyName)
	{
		if(pPolicyData->pszNewPolicyName)
		{
			PrintMessageFromModule(g_hModule, ADD_STATIC_CRNEWPOL_UPDATING_INFO,pPolicyData->pszPolicyName,pPolicyData->pszNewPolicyName);
		}
		else
		{
			PrintMessageFromModule(g_hModule, ADD_STATIC_CRNEWPOL_CREATING_INFO,pPolicyData->pszPolicyName);
		}

		if (pPolicyData->pszNewPolicyName && CheckPolicyExistance(hPolicyStorage,pPolicyData->pszNewPolicyName))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POL_NEWNAME,pPolicyData->pszNewPolicyName);
			dwReturnCode=ERROR_SUCCESS;
			BAIL_OUT;
		}

		if(pPolicyData->pszPolicyName && pPolicyData->pszNewPolicyName)
		{
			if(pPolicyData->pszPolicyName)
			{
				delete [] pPolicyData->pszPolicyName;
			}
			dwStrLength = _tcslen(pPolicyData->pszNewPolicyName);
			pPolicyData->pszPolicyName = new TCHAR[dwStrLength+1];
			if(pPolicyData->pszPolicyName==NULL)
			{
				dwReturnCode=ERROR_SUCCESS;
				BAIL_OUT;
			}
			_tcsncpy(pPolicyData->pszPolicyName,pPolicyData->pszNewPolicyName,dwStrLength+1);
		}

		dwReturnCode=CreateNewPolicy(pPolicyData);
		if(dwReturnCode==ERROR_SUCCESS)
		{
			PrintMessageFromModule(g_hModule, ADD_STATIC_CRNEWPOL_SUCCESS_MSG);
			UpdateGetLastError(NULL);
			bExists=TRUE;
		}
		else if (dwReturnCode == ERROR_INVALID_PARAMETER)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_STATIC_INTERNAL_ERROR);
			dwReturnCode = ERROR_SUCCESS;
			BAIL_OUT;
		}
		else
		{
			dwReturnCode = ERROR_SUCCESS;
			BAIL_OUT;
		}
		// if in case of domain, if assign is specified with out GPO , flag a warning

		if ( pPolicyData->bAssignSpecified && g_StorageLocation.dwLocation == IPSEC_DIRECTORY_PROVIDER && !pPolicyData->pszGPOName)
		{
			PrintMessageFromModule(g_hModule,SET_STATIC_POLICY_MISSING_GPO_NAME_STR);
		}
	}
	if(pPolicy)
	{
		IPSecFreePolicyData(pPolicy);
	}

	// if GPO is specified, assign/unassign  the policy

	if(bExists && pPolicyData->pszGPOName && pPolicyData->bAssignSpecified && pPolicyData->pszPolicyName)
	{
		HRESULT hrReturnCode=AssignIPSecPolicyToGPO(pPolicyData->pszPolicyName,pPolicyData->pszGPOName,pPolicyData->bAssign);
		if(hrReturnCode==E_IDS_NO_DS)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_3);
		}
		else if((hrReturnCode==E_FAIL)||(hrReturnCode==E_UNEXPECTED) || (hrReturnCode==E_IDS_NODNSTRING))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_4,pPolicyData->pszGPOName);
		}
		else if(hrReturnCode != S_OK)
		{
			if(pPolicyData->bAssign)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_5,pPolicyData->pszGPOName);
			}
			else
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_POLICY_CERT_MAP_NO_STR,pPolicyData->pszGPOName);
			}
		}
		dwReturnCode=ERROR_SUCCESS;
	}

error:		//clean up
    if (hPolicyStorage)
    {
		ClosePolicyStore(hPolicyStorage);
    }    	

	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		dwReturnCode=ERROR_SUCCESS;
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);

		CleanUpPolicy(pPolicy);
	}

	CleanUpLocalPolicyDataStructure(pPolicyData	);

	return dwReturnCode;
}

///////////////////////////////////////////////////////////////////////
//
//Function: FillSetPolicyInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PPOLICYDATA* ppPolicyData,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticSetPolicy,
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD
FillSetPolicyInfo(
	OUT PPOLICYDATA* ppPolicyData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticSetPolicy
	)
{
	DWORD dwCount=0, dwReturn = ERROR_SUCCESS , dwStrLength = 0;
	RPC_STATUS RpcStat =RPC_S_OK;
	PPOLICYDATA pPolicyData=new POLICYDATA;

	if(pPolicyData == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memset(pPolicyData,0,sizeof(POLICYDATA));

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME				:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pPolicyData->pszPolicyName = new _TCHAR[dwStrLength+1];
								if(pPolicyData->pszPolicyName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pPolicyData->pszPolicyName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
								pPolicyData->bPolicyNameSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_NEWNAME			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pPolicyData->pszNewPolicyName = new _TCHAR[dwStrLength+1];
								if(pPolicyData->pszNewPolicyName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pPolicyData->pszNewPolicyName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_DESCR			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pPolicyData->pszDescription = new _TCHAR[dwStrLength+1];
								if(pPolicyData->pszDescription == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pPolicyData->pszDescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_GUID				:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pPolicyData->pszGUIDStr = new _TCHAR[dwStrLength+1];
								if(pPolicyData->pszGUIDStr == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pPolicyData->pszGUIDStr, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
								StripGUIDBraces(pPolicyData->pszGUIDStr);
								pPolicyData->bGUIDSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_GPONAME			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pPolicyData->pszGPOName = new _TCHAR[dwStrLength+1];
								if(pPolicyData->pszGPOName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pPolicyData->pszGPOName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_MMPFS			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pPolicyData->bPFS = *(BOOL *)parser.Cmd[dwCount].pArg;
								pPolicyData->bPFSSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_ACTIVATEDEFRULE	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pPolicyData->bActivateDefaultRule = *(BOOL *)parser.Cmd[dwCount].pArg;
								pPolicyData->bActivateDefaultRuleSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_ASSIGN			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pPolicyData->bAssign = *(BOOL *)parser.Cmd[dwCount].pArg;
								pPolicyData->bAssignSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_MMLIFETIME		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pPolicyData->LifeTimeInSeconds=	*(ULONG *)parser.Cmd[dwCount].pArg * 60;
								pPolicyData->bLifeTimeInsecondsSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_QMPERMM			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pPolicyData->dwQMLimit=	*(DWORD *)parser.Cmd[dwCount].pArg;
								pPolicyData->bQMLimitSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_PI				:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pPolicyData->dwPollInterval=  *(DWORD *)parser.Cmd[dwCount].pArg * 60;
								pPolicyData->bPollIntervalSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_CERTTOMAP			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pPolicyData->bCertToAccMappingSpecified = TRUE;
								pPolicyData->bCertToAccMapping = *(BOOL *)parser.Cmd[dwCount].pArg;
							}
							break;
			default							:
							break;
		}
	}

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_MMSECMETHODS		:
							if (parser.Cmd[dwCount].dwStatus != 0)
							{
								pPolicyData->dwOfferCount=parser.Cmd[dwCount].dwStatus;

								pPolicyData->pIpSecMMOffer = new IPSEC_MM_OFFER[pPolicyData->dwOfferCount];
								if(pPolicyData->pIpSecMMOffer == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								memset(pPolicyData->pIpSecMMOffer, 0, sizeof(IPSEC_MM_OFFER) * pPolicyData->dwOfferCount);

								for(DWORD j=0;j<(parser.Cmd[dwCount].dwStatus);j++)
								{
									if ( ((IPSEC_MM_OFFER **)parser.Cmd[dwCount].pArg)[j] )
										memcpy( &(pPolicyData->pIpSecMMOffer[j]),((IPSEC_MM_OFFER **)parser.Cmd[dwCount].pArg)[j],sizeof(IPSEC_MM_OFFER));
								}
							}
							break;
			default							:
							break;
		}
	}

	if(pPolicyData->bPFSSpecified && pPolicyData->bPFS )
	{
		pPolicyData->dwQMLimit=MMPFS_QM_LIMIT;
		pPolicyData->bQMLimitSpecified=TRUE;
	}

	if (pPolicyData->dwOfferCount != 0)
	{
		for(DWORD i=0;i<pPolicyData->dwOfferCount;i++)
		{
			if(pPolicyData->bLifeTimeInsecondsSpecified)
			{
				pPolicyData->pIpSecMMOffer[i].Lifetime.uKeyExpirationTime=pPolicyData->LifeTimeInSeconds;
			}
			if(pPolicyData->bQMLimitSpecified)
			{
				pPolicyData->pIpSecMMOffer[i].dwQuickModeLimit=pPolicyData->dwQMLimit;
			}
		}
	}

	//check for friendly name of the default policies

	if(pPolicyData->bGUIDSpecified )
	{
		if (_tcsicmp(pPolicyData->pszGUIDStr,GUID_SERVER_REQUEST_SECURITY)==0)
		{
			pPolicyData->PolicyGuid=CLSID_Server;
			pPolicyData->bGuidConversionOk= TRUE;
		}
		else if(_tcsicmp(pPolicyData->pszGUIDStr,GUID_CLIENT_RESPOND_ONLY)==0)
		{
			pPolicyData->PolicyGuid=CLSID_Client;
			pPolicyData->bGuidConversionOk= TRUE;
		}
		else if(_tcsicmp(pPolicyData->pszGUIDStr,GUID_SECURE_SERVER_REQUIRE_SECURITY)==0)
		{
			pPolicyData->PolicyGuid=CLSID_SecureServer;
			pPolicyData->bGuidConversionOk= TRUE;
		}
		else
		{
			RpcStat=UuidFromString(pPolicyData->pszGUIDStr, &(pPolicyData->PolicyGuid));
			if(RpcStat == RPC_S_OK)
			{
				pPolicyData->bGuidConversionOk= TRUE;
			}
		}
	}
error:
	*ppPolicyData=pPolicyData;

	CleanUp();

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticSetFilterList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Set FilterList "
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticSetFilterList(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	GUID FLGuid={0};
	PIPSEC_FILTER_DATA *ppFilterEnum  = NULL,pFilterData=NULL;
	HANDLE hPolicyStorage = NULL;
	BOOL bFilterExists=FALSE;
	RPC_STATUS RpcStat =RPC_S_OK;
	DWORD dwReturnCode = ERROR_SUCCESS,dwStrLength = 0;
	LPTSTR pszFLName=NULL,pszNewFLName=NULL,pszFLDescription=NULL;
	LPTSTR pszGUIDStr=NULL;
	BOOL bGUIDSpecified=FALSE;
	DWORD dwNumFilters = 0,dwCount=0;
	DWORD dwRet=ERROR_SHOW_USAGE,dwReturn=ERROR_SUCCESS;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticSetFilterList[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_GUID,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_NEWNAME,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  FALSE	}
	};

	const TOKEN_VALUE vtokStaticSetFilterList[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 			},
		{ CMD_TOKEN_STR_GUID,		CMD_TOKEN_GUID 			},
		{ CMD_TOKEN_STR_NEWNAME,	CMD_TOKEN_NEWNAME 		},
		{ CMD_TOKEN_STR_DESCR,		CMD_TOKEN_DESCR 		}
	};

	if (dwArgCount <= 3)
	{
		dwReturnCode = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}
	parser.ValidTok   = vtokStaticSetFilterList;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticSetFilterList);

	parser.ValidCmd   = vcmdStaticSetFilterList;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticSetFilterList);

	dwReturnCode = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwReturnCode != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwReturnCode == RETURN_NO_ERROR)
		{
			dwReturnCode = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetFilterList[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME				:
						if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						{
							dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
							pszFLName = new _TCHAR[dwStrLength+1];
							if(pszFLName==NULL)
							{
								dwReturn =ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							_tcsncpy(pszFLName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
						}
						break;
			case CMD_TOKEN_DESCR			:
						if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						{
							dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
							pszFLDescription = new _TCHAR[dwStrLength+1];
							if(pszFLDescription==NULL)
							{
								dwReturn =ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							_tcsncpy(pszFLDescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
						}
						break;
			case CMD_TOKEN_GUID				:
						if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						{
							dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
							pszGUIDStr = new _TCHAR[dwStrLength+1];
							if(pszGUIDStr==NULL)
							{
								dwReturn =ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							_tcsncpy(pszGUIDStr, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							StripGUIDBraces(pszGUIDStr);
							bGUIDSpecified=TRUE;
						}
						break;
			case CMD_TOKEN_NEWNAME			:
						if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						{
							dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);
							pszNewFLName = new _TCHAR[dwStrLength+1];
							if(pszNewFLName==NULL)
							{
								dwReturn =ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							_tcsncpy(pszNewFLName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
						}
						break;
			default							:
						break;
		}
	}
	// if guid specified, check for conversion, if failed bailout
	if(bGUIDSpecified)
	{
		RpcStat=UuidFromString(pszGUIDStr, &FLGuid);
		if(RpcStat != RPC_S_OK)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_5);
			BAIL_OUT;
		}
	}

	CleanUp();

	if(!pszFLName && !bGUIDSpecified)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_1);
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);

	if (dwReturnCode != ERROR_SUCCESS)
	{
	   PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
	   dwReturnCode=ERROR_SUCCESS;
	   BAIL_OUT;
	}

	//check for filterlist existence

	dwReturnCode = IPSecEnumFilterData(hPolicyStorage, &ppFilterEnum, &dwNumFilters);
	if (dwReturnCode == ERROR_SUCCESS && dwNumFilters > 0 && ppFilterEnum != NULL)
	{
		DWORD i;
		for (i = 0; i <  dwNumFilters; i++)
		{
			if (( pszFLName && ppFilterEnum[i]->pszIpsecName && ( _tcscmp(ppFilterEnum[i]->pszIpsecName, pszFLName) == 0))||(bGUIDSpecified && UuidCompare(&(ppFilterEnum[i]->FilterIdentifier), &FLGuid, &RpcStat) == 0 && RpcStat == RPC_S_OK))
			{
				bFilterExists=TRUE;
				dwReturnCode = IPSecCopyFilterData(ppFilterEnum[i], &pFilterData);
				break;
			}
		}
		if(ppFilterEnum && dwNumFilters>0)
		{
			IPSecFreeMulFilterData(	ppFilterEnum,dwNumFilters);
		}
	}
	if(!bFilterExists)
	{
		if(pszFLName)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_1,pszFLName);
		}
		else if(pszGUIDStr)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_4,pszGUIDStr);
		}
	}

	if(bFilterExists && pszNewFLName && CheckFilterListExistance(hPolicyStorage,pszNewFLName))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_FL_NEWNAME,pszNewFLName);
		dwReturnCode=ERROR_SUCCESS;
		ClosePolicyStore(hPolicyStorage);
		BAIL_OUT;
	}

	if(bFilterExists)
	{
		// check for readonly flag

		if(pFilterData->dwFlags & POLSTORE_READONLY )
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_FL_READ_ONLY_OBJECT,pFilterData->pszIpsecName);
			BAIL_OUT;
		}
		// update the parameters
		if(pszNewFLName)
		{
			IPSecFreePolStr(pFilterData->pszIpsecName);
			pFilterData->pszIpsecName = IPSecAllocPolStr(pszNewFLName);
			if (pFilterData->pszIpsecName == NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
		}
		if(pszFLDescription)
		{
			IPSecFreePolStr(pFilterData->pszDescription);
			pFilterData->pszDescription = IPSecAllocPolStr(pszFLDescription);
			if (pFilterData->pszDescription == NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
		}
		//call the set API
		if (pFilterData)
		{
			dwReturnCode = IPSecSetFilterData(hPolicyStorage, pFilterData);

			if(dwReturnCode==ERROR_SUCCESS && g_NshPolStoreHandle.GetBatchmodeStatus())
			{
				g_NshPolNegFilData.DeleteFilterListFromCache(pFilterData->FilterIdentifier);
			}
		}
		// if something failed , throw error messages to the user
		if (dwReturnCode != ERROR_SUCCESS)
		{
			if(pszFLName)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_FILTERLIST_1,pszFLName);
			}
			else if (pszGUIDStr)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_FILTERLIST_3,pszGUIDStr);
			}
		}

		if(pFilterData) FreeFilterData(pFilterData);
	}
	ClosePolicyStore(hPolicyStorage);

error:

	//clean up

	if(dwReturn == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
	}
	if(pszFLName) delete [] pszFLName;
	if(pszNewFLName) delete [] pszNewFLName;
	if(pszFLDescription) delete [] pszFLDescription;
	if(pszGUIDStr) delete [] pszGUIDStr;

	return dwReturnCode;
}


///////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticSetFilterActions()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Set FilterAction "
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticSetFilterActions(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	DWORD dwNumNegPol=0,dwRet=ERROR_SHOW_USAGE;
	PIPSEC_NEGPOL_DATA *ppNegPolEnum = NULL ,pNegPolData=NULL;
	HANDLE hPolicyStorage = NULL;
	BOOL bNegPolExists=FALSE;
	RPC_STATUS RpcStat =RPC_S_OK;
	PFILTERACTION pFilterAction=NULL;
	DWORD  dwReturnCode = ERROR_SUCCESS;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticSetFilterAction[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_GUID,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_NEWNAME,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_QMPFS,	 		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_INPASS,		 	NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_SOFT,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_ACTION,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_QMSECMETHODS,	NS_REQ_ZERO,	  FALSE	}
	};

	const TOKEN_VALUE vtokStaticSetFilterAction[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 			},
		{ CMD_TOKEN_STR_GUID,			CMD_TOKEN_GUID 			},
		{ CMD_TOKEN_STR_NEWNAME,		CMD_TOKEN_NEWNAME 		},
		{ CMD_TOKEN_STR_DESCR,			CMD_TOKEN_DESCR 		},
		{ CMD_TOKEN_STR_QMPFS,	 		CMD_TOKEN_QMPFS			},
		{ CMD_TOKEN_STR_INPASS,			CMD_TOKEN_INPASS		},
		{ CMD_TOKEN_STR_SOFT,			CMD_TOKEN_SOFT			},
		{ CMD_TOKEN_STR_ACTION,			CMD_TOKEN_ACTION		},
		{ CMD_TOKEN_STR_QMSECMETHODS,	CMD_TOKEN_QMSECMETHODS	}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <=3)
	{
		dwReturnCode = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticSetFilterAction;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticSetFilterAction);

	parser.ValidCmd   = vcmdStaticSetFilterAction;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticSetFilterAction);

	dwReturnCode = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwReturnCode != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwReturnCode==RETURN_NO_ERROR)
		{
			dwReturnCode = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed user input

	dwRet = FillSetFilterActionInfo(&pFilterAction,parser,vtokStaticSetFilterAction);

	if(dwRet==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		BAIL_OUT;
	}

	//check for mandatory parameters

	if(!pFilterAction->pszFAName && !pFilterAction->pszGUIDStr)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_2);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if(pFilterAction->bGUIDSpecified && pFilterAction->pszGUIDStr && !pFilterAction->bGuidConversionOk )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERLIST_5);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	//copy the store location info into local variables and then proceed

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		 PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		 dwReturnCode=ERROR_SUCCESS;
		 BAIL_OUT;
	}

	//check if filteraction exists, else bail out

	dwReturnCode = IPSecEnumNegPolData(hPolicyStorage, &ppNegPolEnum, &dwNumNegPol);
	if (dwReturnCode == ERROR_SUCCESS && dwNumNegPol> 0 && ppNegPolEnum != NULL)
	{
		DWORD i;
		for (i = 0; i <  dwNumNegPol; i++)
		{
			if (( ppNegPolEnum[i]->pszIpsecName && pFilterAction->pszFAName && ( _tcscmp(ppNegPolEnum[i]->pszIpsecName, pFilterAction->pszFAName) == 0))||(pFilterAction->bGUIDSpecified && UuidCompare(&(ppNegPolEnum[i]->NegPolIdentifier), &(pFilterAction->FAGuid), &RpcStat) == 0 && RpcStat == RPC_S_OK))
			{
				bNegPolExists=TRUE;
				dwReturnCode=IPSecCopyNegPolData(ppNegPolEnum[i],&pNegPolData);
			}
		}

		if (dwNumNegPol > 0 && ppNegPolEnum != NULL)
		{
			IPSecFreeMulNegPolData(	ppNegPolEnum,dwNumNegPol);
		}
	}

	if(!bNegPolExists )
	{
		if(pFilterAction->pszFAName)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_5,pFilterAction->pszFAName);
		}
		else if(pFilterAction->pszGUIDStr)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_10,pFilterAction->pszGUIDStr);
		}
	}

	if(bNegPolExists && pFilterAction->pszNewFAName && CheckFilterActionExistance(hPolicyStorage,pFilterAction->pszNewFAName))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_FA_NEWNAME,pFilterAction->pszNewFAName);
		if(pNegPolData)
		{
			IPSecFreeNegPolData(pNegPolData);
			pNegPolData = NULL;
		}
		ClosePolicyStore(hPolicyStorage);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if(bNegPolExists)
	{
		// if the user tries to update the default neg pol , throw error to the user
		if(pNegPolData->NegPolType == GUID_NEGOTIATION_TYPE_DEFAULT)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_UPDATE_DEF_NEGPOL);
			dwReturnCode=ERROR_SUCCESS;
			BAIL_OUT;
		}
		// check for read only flag
		if(pNegPolData->dwFlags & POLSTORE_READONLY )
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_FA_READ_ONLY_OBJECT,pNegPolData->pszIpsecName);
			BAIL_OUT;
		}

		// if action is permit or block, none of the options are applicable

		if((pNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)||(pNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC))
		{
			// if action = negotiate, atleast one sec method required

			if(pFilterAction->bNegPolActionSpecified && pFilterAction->dwNumSecMethodCount==0 && pNegPolData->dwSecurityMethodCount==0)
			{
				if(pFilterAction->bInpassSpecified && !pFilterAction->bNegotiateSpecified)
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERACTION_3);
					dwReturnCode=ERROR_SUCCESS;
					BAIL_OUT;
				}
				else if(!((pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)|| (pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC)))
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERACTION_4);
					dwReturnCode=ERROR_SUCCESS;
					BAIL_OUT;
				}
			}
			if(!pFilterAction->bNegotiateSpecified && (pFilterAction->dwNumSecMethodCount > 0 || pFilterAction->bSoftSpecified || pFilterAction->bQMPfsSpecified ||pFilterAction->bInpassSpecified ))
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTERACTION_3);
				dwReturnCode=ERROR_SUCCESS;
				BAIL_OUT;
			}
		}
		if(pNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU && !pFilterAction->bInpassSpecified && pFilterAction->bNegotiateSpecified)
		{
			pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU;
		}
		if((pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)||(pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC))
		{
			pFilterAction->bQMPfs=FALSE;
			pFilterAction->bQMPfsSpecified=TRUE;
			pFilterAction->bSoft=FALSE;
			pFilterAction->bSoftSpecified=TRUE;
		}

		dwReturnCode = UpdateNegotiationPolicy(pNegPolData,pFilterAction);
		if(dwReturnCode == ERROR_SUCCESS)
		{
			// call the API and update the cache also if required

			if (pNegPolData)
			{
				dwReturnCode = IPSecSetNegPolData(hPolicyStorage, pNegPolData);

				if(dwReturnCode==ERROR_SUCCESS && g_NshPolStoreHandle.GetBatchmodeStatus())
				{
					g_NshPolNegFilData.DeleteNegPolFromCache(pNegPolData->NegPolIdentifier);
				}
			}
			if (dwReturnCode != ERROR_SUCCESS)
			{
				if(pFilterAction->pszFAName)
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_FILTERACTION_1,pFilterAction->pszFAName);
				}
				else if(pFilterAction->pszGUIDStr)
				{
					PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_FILTERACTION_3,pFilterAction->pszGUIDStr);
				}
				dwReturnCode=ERROR_SUCCESS;
			}
		}
		else if(dwReturnCode == ERROR_OUTOFMEMORY)
		{
			PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
			dwReturnCode=ERROR_SUCCESS;
		}
	}
	ClosePolicyStore(hPolicyStorage);
	if(pNegPolData)
	{
		IPSecFreeNegPolData(pNegPolData);
		pNegPolData = NULL;
	}
error:  //clean up
	CleanUpLocalFilterActionDataStructure(pFilterAction);

	return dwReturnCode;
}

///////////////////////////////////////////////////////////////////////
//
//Function: FillSetFilterActionInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PFILTERACTION* ppFilterData,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticSetFilterAction
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD
FillSetFilterActionInfo(
	OUT PFILTERACTION* ppFilterData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticSetFilterAction
	)
{
	DWORD dwCount=0 , dwReturn = ERROR_SUCCESS , dwStrLength = 0;
	RPC_STATUS     RpcStat =RPC_S_OK;
	PFILTERACTION pFilterAction=new FILTERACTION;
	if(pFilterAction==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	memset(pFilterAction,0,sizeof(FILTERACTION));

	pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetFilterAction[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_DESCR		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pFilterAction->pszFADescription = new _TCHAR[dwStrLength+1];
								if(pFilterAction->pszFADescription==NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilterAction->pszFADescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
            case CMD_TOKEN_NAME			:
            				if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pFilterAction->pszFAName = new _TCHAR[dwStrLength+1];
								if(pFilterAction->pszFAName==NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilterAction->pszFAName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_NEWNAME		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pFilterAction->pszNewFAName = new _TCHAR[dwStrLength+1];
								if(pFilterAction->pszNewFAName==NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilterAction->pszNewFAName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_GUID			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pFilterAction->pszGUIDStr = new _TCHAR[dwStrLength+1];
								if(pFilterAction->pszGUIDStr==NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pFilterAction->pszGUIDStr, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
								StripGUIDBraces(pFilterAction->pszGUIDStr);
								pFilterAction->bGUIDSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_INPASS		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								if (*(BOOL *)parser.Cmd[dwCount].pArg == TRUE)
								{
									pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU;
									pFilterAction->bNegPolActionSpecified=TRUE;
									pFilterAction->bInpass=TRUE;
									pFilterAction->bInpassSpecified=TRUE;
								}
								else
								{
									pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;
									pFilterAction->bNegPolActionSpecified=TRUE;
									pFilterAction->bInpass=FALSE;
									pFilterAction->bInpassSpecified=TRUE;
								}
							}
							break;
			case CMD_TOKEN_SOFT			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterAction->bSoft = *(BOOL *)parser.Cmd[dwCount].pArg;
								pFilterAction->bSoftSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_QMPFS		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pFilterAction->bQMPfs = *(BOOL *)parser.Cmd[dwCount].pArg;
								pFilterAction->bQMPfsSpecified=TRUE;
							}
							break;

			default						:
							break;
		}
	}

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetFilterAction[parser.Cmd[dwCount].dwCmdToken].dwValue)
			{
				case CMD_TOKEN_ACTION		:
						if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						{
							pFilterAction->bNegPolActionSpecified = TRUE;

							if (*(DWORD *)parser.Cmd[dwCount].pArg == TOKEN_QMSEC_PERMIT )
							{
								pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_NO_IPSEC;
							}
							else if (*(DWORD *)parser.Cmd[dwCount].pArg == TOKEN_QMSEC_BLOCK)
							{
								pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_BLOCK;
							}
							else if (*(DWORD *)parser.Cmd[dwCount].pArg == TOKEN_QMSEC_NEGOTIATE)
							{
								pFilterAction->bNegotiateSpecified=TRUE;
							}
						}
						break;
				default							:
						break;
			}
	}

	if(!(pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC ||pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK ))
	{
		for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
		{
			switch(vtokStaticSetFilterAction[parser.Cmd[dwCount].dwCmdToken].dwValue)
			{
				case CMD_TOKEN_QMSECMETHODS		:
						if (parser.Cmd[dwCount].dwStatus > 0)
						{
							pFilterAction->bSecMethodsSpecified = TRUE;

							if(!(pFilterAction->bInpass && pFilterAction->bInpassSpecified))
								pFilterAction->NegPolAction=GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;
							pFilterAction->bNegPolActionSpecified=TRUE;

							pFilterAction->dwNumSecMethodCount=parser.Cmd[dwCount].dwStatus;

							pFilterAction->pIpsecSecMethods = new IPSEC_QM_OFFER[pFilterAction->dwNumSecMethodCount];
							if(pFilterAction->pIpsecSecMethods==NULL)
							{
								dwReturn = ERROR_OUTOFMEMORY;
								BAIL_OUT;
							}
							memset(pFilterAction->pIpsecSecMethods, 0, sizeof(IPSEC_QM_OFFER) * pFilterAction->dwNumSecMethodCount);

							for(DWORD j=0;j<pFilterAction->dwNumSecMethodCount;j++)
							{
								if ( ((IPSEC_QM_OFFER **)parser.Cmd[dwCount].pArg)[j] )
									memcpy( &(pFilterAction->pIpsecSecMethods[j]),((IPSEC_QM_OFFER **)parser.Cmd[dwCount].pArg)[j],sizeof(IPSEC_QM_OFFER));
							}

						}
						break;
				default							:
						break;
			}
		}
	}

	// check for guid conversion

	if(pFilterAction->bGUIDSpecified)
	{
		RpcStat=UuidFromString(pFilterAction->pszGUIDStr, &(pFilterAction->FAGuid));
		if(RpcStat == RPC_S_OK)
			pFilterAction->bGuidConversionOk=TRUE;
	}
error:
	*ppFilterData=pFilterAction;

	CleanUp();

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticSetRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Set Rule "
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticSetRule(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	DWORD dwRet = ERROR_SHOW_USAGE,dwStrLength = 0;
	PIPSEC_POLICY_DATA pPolicyData = NULL;
	PIPSEC_NEGPOL_DATA pNegPolData = NULL;
	PIPSEC_FILTER_DATA pFilterData = NULL;
	HANDLE hPolicyStorage = NULL;
	BOOL bPolicyExists=FALSE,bRuleExists=FALSE,bFilterExists=FALSE;
	BOOL bCreateNewRule=TRUE,bFLExists=FALSE,bFAExists=FALSE;
	PRULEDATA pRuleData=NULL;
	_TCHAR szUserInput[STRING_SIZE]={0};
	DWORD dwReturnCode   = ERROR_SUCCESS;
	PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticSetRule[] =
	{
		{ CMD_TOKEN_STR_NAME,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_ID,				NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_POLICY,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_NEWNAME,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_DESCR,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_FILTERLIST,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_FILTERACTION,	NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_TUNNEL,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_CONNTYPE,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_ACTIVATE,		NS_REQ_ZERO,	  FALSE },
		{ CMD_TOKEN_STR_KERB,	        NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_PSK,	        NS_REQ_ZERO,	  FALSE	},
	};

	const TOKEN_VALUE vtokStaticSetRule[] =
	{
		{ CMD_TOKEN_STR_NAME,			CMD_TOKEN_NAME 			},
		{ CMD_TOKEN_STR_ID,				CMD_TOKEN_ID 			},
		{ CMD_TOKEN_STR_POLICY,			CMD_TOKEN_POLICY		},
		{ CMD_TOKEN_STR_NEWNAME,		CMD_TOKEN_NEWNAME		},
		{ CMD_TOKEN_STR_DESCR,			CMD_TOKEN_DESCR			},
		{ CMD_TOKEN_STR_FILTERLIST,		CMD_TOKEN_FILTERLIST	},
		{ CMD_TOKEN_STR_FILTERACTION,	CMD_TOKEN_FILTERACTION	},
		{ CMD_TOKEN_STR_TUNNEL,			CMD_TOKEN_TUNNEL		},
		{ CMD_TOKEN_STR_CONNTYPE, 		CMD_TOKEN_CONNTYPE		},
		{ CMD_TOKEN_STR_ACTIVATE,		CMD_TOKEN_ACTIVATE	 	},
		{ CMD_TOKEN_STR_KERB,	        CMD_TOKEN_KERB          },
		{ CMD_TOKEN_STR_PSK,	        CMD_TOKEN_PSK	        },
	};

	const TOKEN_VALUE vlistStaticSetRule[] =
	{
		{ CMD_TOKEN_STR_ROOTCA,	        CMD_TOKEN_ROOTCA	    },
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <=3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticSetRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticSetRule);

	parser.ValidCmd   = vcmdStaticSetRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticSetRule);

	parser.ValidList  = vlistStaticSetRule;
	parser.MaxList    = SIZEOF_TOKEN_VALUE(vlistStaticSetRule);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the parsed output from the user

	dwRet = FillSetRuleInfo(&pRuleData,parser,vtokStaticSetRule);

	if(dwRet==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if ((!pRuleData->pszRuleName || (pRuleData->pszRuleName[0] == TEXT('\0')))&& !pRuleData->bIDSpecified)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_SUCCESS_MSG);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}
	if (!pRuleData->pszPolicyName || (pRuleData->pszPolicyName[0] == TEXT('\0')) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_MISSING_POL_NAME);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}
	if(pRuleData->bIDSpecified && pRuleData->dwRuleId==0)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_RULE_5);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	//validate tunnel addr
	if (pRuleData->bTunnel)
	{
		if(!bIsValidIPAddress(htonl(pRuleData->TunnelIPAddress),TRUE,TRUE))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_RULE_INVALID_TUNNEL);
			dwRet=ERROR_SUCCESS;
			BAIL_OUT;
		}
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);

	if (dwReturnCode != ERROR_SUCCESS)
	{
		 PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		 dwRet=ERROR_SUCCESS;
		 BAIL_OUT;
	}

	if(!(bPolicyExists=GetPolicyFromStore(&pPolicyData,pRuleData->pszPolicyName,hPolicyStorage)))
	{
		dwRet=ERROR_SUCCESS;
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_3,pRuleData->pszPolicyName);
	}
	else
	{
		if(pRuleData->bIDSpecified)  // if rule id specified
		{
			for(DWORD i=0;i<pPolicyData->dwNumNFACount;i++)
			{
				if (i==((pRuleData->dwRuleId)-1))
				{
					if(IsEqualGUID(pPolicyData->ppIpsecNFAData[i]->pIpsecNegPolData->NegPolType,GUID_NEGOTIATION_TYPE_DEFAULT))
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_RULE_3);
						dwRet=ERROR_SUCCESS;
						BAIL_OUT;
					}
					bRuleExists=TRUE;
				}
			}
		}
		else  // if name specified
		{
			for(DWORD i=0;i<pPolicyData->dwNumNFACount;i++)
			{
				if (pRuleData->pszRuleName && pPolicyData->ppIpsecNFAData[i]->pszIpsecName &&(_tcscmp(pPolicyData->ppIpsecNFAData[i]->pszIpsecName,pRuleData->pszRuleName)==0))
				{
					if(IsEqualGUID(pPolicyData->ppIpsecNFAData[i]->pIpsecNegPolData->NegPolType,GUID_NEGOTIATION_TYPE_DEFAULT))
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_RULE_3);
						dwRet=ERROR_SUCCESS;
						BAIL_OUT;
					}
					bRuleExists=TRUE;
				}
			}
		}

		if (!bRuleExists && pRuleData->pszRuleName)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_RULE_1,pRuleData->pszRuleName,pRuleData->pszPolicyName);
		}
		else if (!bRuleExists && pRuleData->bIDSpecified)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_RULE_NEW_RULE_QUERY,pRuleData->dwRuleId,pRuleData->pszPolicyName);
			dwRet=ERROR_SUCCESS;
			BAIL_OUT;
		}
		if(bRuleExists && pRuleData->pszNewRuleName && CheckForRuleExistance(pPolicyData,pRuleData->pszNewRuleName))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_RULE_NEWNAME,pRuleData->pszNewRuleName);
			dwRet=ERROR_SUCCESS;
			BAIL_OUT;
		}
	}
	if(bRuleExists)
	{
		// check for read only flag

		if(pPolicyData->dwFlags & POLSTORE_READONLY )
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_POL_READ_ONLY_OBJECT,pPolicyData->pszIpsecName);
			BAIL_OUT;
		}

		//check for other dependencies , like filterlist, filteraction

		if(!pRuleData->bFASpecified)
		{
			bFAExists=TRUE;
		}
		else if(pRuleData->pszFAName && (!(bFAExists=GetNegPolFromStore(&pNegPolData,pRuleData->pszFAName,hPolicyStorage))))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_5,pRuleData->pszFAName);
			dwRet=ERROR_SUCCESS;
			BAIL_OUT;
		}
		if(!pRuleData->bFLSpecified)
		{
			bFLExists= bFilterExists=TRUE;
		}
		else if(pRuleData->pszFLName &&(!(bFLExists=GetFilterListFromStore(&pFilterData,pRuleData->pszFLName,hPolicyStorage,bFilterExists))))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_FILTER_1,pRuleData->pszFLName);
			dwRet=ERROR_SUCCESS;
		}
		if(bFLExists && !bFilterExists)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_6,pRuleData->pszFLName);
			dwRet=ERROR_SUCCESS;
		}

		// if every thing is in place, update NFA structure

		if(bPolicyExists&&bRuleExists&&bFLExists&&bFAExists&&bFilterExists)
		{
			dwReturnCode=UpdateRule(pPolicyData, pRuleData, pNegPolData, pFilterData,hPolicyStorage ) ;
			if(dwReturnCode!=ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_RULE_2,pRuleData->pszRuleName);
			}
			else
			{
				dwRet=ERROR_SUCCESS;
			}
		}
	}

	// if the user accepted to create new rule, proceed creating
	if(bPolicyExists && !bRuleExists && bCreateNewRule && pRuleData->pszRuleName )
	{
		if(pRuleData->pszNewRuleName)
		{
			PrintMessageFromModule(g_hModule, ADD_STATIC_RULE_UPDATING_INFO,pRuleData->pszRuleName,pRuleData->pszNewRuleName);
		}
		else
		{
			PrintMessageFromModule(g_hModule, ADD_STATIC_RULE_CREATING_INFO,pRuleData->pszRuleName);
		}

		if(pRuleData->pszNewRuleName && CheckForRuleExistance(pPolicyData,pRuleData->pszNewRuleName))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_RULE_NEWNAME,pRuleData->pszNewRuleName);
			dwRet=ERROR_SUCCESS;
			BAIL_OUT;
		}

		if(pRuleData->pszRuleName && pRuleData->pszNewRuleName)
		{
			dwStrLength = _tcslen(pRuleData->pszNewRuleName);
			delete [] pRuleData->pszRuleName;
			pRuleData->pszRuleName = new TCHAR[dwStrLength+1];
			if(pRuleData->pszRuleName == NULL)
			{
				PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
				dwRet=ERROR_SUCCESS;
				BAIL_OUT;
			}
			_tcsncpy(pRuleData->pszRuleName,pRuleData->pszNewRuleName,dwStrLength+1);
		}

		// create new rule

		dwReturnCode=CreateNewRule(pRuleData);
		if(dwReturnCode==ERROR_SUCCESS)
		{
			PrintMessageFromModule(g_hModule, ADD_STATIC_RULE_SUCCESS_MSG);
			UpdateGetLastError(NULL);			// Error Success
		}
	}

	ClosePolicyStore(hPolicyStorage);
	if(pPolicyData)
	{
		IPSecFreePolicyData(pPolicyData);
	}
	dwRet = ERROR_SUCCESS;
error:  //clean up the data structures
	CleanUpLocalRuleDataStructure(pRuleData);

	return dwRet;
}

///////////////////////////////////////////////////////////////////////
//
//Function: FillSetRuleInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PRULEDATA* ppRuleData,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticSetRule,
//	IN const TOKEN_VALUE *vlistStaticSetRule
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//Revision History:
//
//Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

DWORD
FillSetRuleInfo(
	OUT PRULEDATA* ppRuleData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticSetRule
	)
{
	DWORD dwCount=0,dwReturn=ERROR_SUCCESS , dwStrLength = 0;
	PRULEDATA pRuleData=new RULEDATA;
	if (pRuleData == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	ZeroMemory(pRuleData,sizeof(RULEDATA));
	PSTA_AUTH_METHODS pKerbAuth = NULL;
	PSTA_AUTH_METHODS pPskAuth = NULL;
	PSTA_MM_AUTH_METHODS *ppRootcaMMAuth = NULL;

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszRuleName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszRuleName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszRuleName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_ID			:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pRuleData->dwRuleId=	*(DWORD *)parser.Cmd[dwCount].pArg;
								pRuleData->bIDSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_NEWNAME		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszNewRuleName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszNewRuleName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszNewRuleName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_POLICY 		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszPolicyName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszPolicyName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszPolicyName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_DESCR		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszRuleDescription = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszRuleDescription == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszRuleDescription, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
			case CMD_TOKEN_FILTERLIST 	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszFLName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszFLName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszFLName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
								pRuleData->bFLSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_FILTERACTION	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pRuleData->pszFAName = new _TCHAR[dwStrLength+1];
								if(pRuleData->pszFAName == NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pRuleData->pszFAName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
								pRuleData->bFASpecified=TRUE;
							}
							break;
			case CMD_TOKEN_TUNNEL 		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pRuleData->TunnelIPAddress = *(IPADDR *)parser.Cmd[dwCount].pArg;
								if(pRuleData->TunnelIPAddress)
									pRuleData->bTunnel=TRUE;
								else
									pRuleData->bTunnel=FALSE;
								pRuleData->bTunnelSpecified=TRUE;
							}
							else
							{
								switch(parser.Cmd[dwCount].dwStatus)
								{
									case SERVER_DNS 	:
									case SERVER_WINS	:
									case SERVER_DHCP 	:
									case SERVER_GATEWAY	:
															PrintMessageFromModule(g_hModule,ADD_STATIC_RULE_INVALID_TUNNEL);
															break;
									default:
															break;
								}
							}
							break;
			case CMD_TOKEN_CONNTYPE 	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pRuleData->ConnectionType = *(IF_TYPE *)parser.Cmd[dwCount].pArg;
								pRuleData->bConnectionTypeSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_ACTIVATE 	:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pRuleData->bActivate = *(BOOL *)parser.Cmd[dwCount].pArg;
								pRuleData->bActivateSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_KERB             :
							if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pKerbAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_PSK			:
							if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pPskAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_ROOTCA		:
							// this case is special, handled below...
							break;
			default						:
							break;
		}
	}

	size_t uiRootcaIndex = parser.MaxTok;
	if (parser.Cmd[uiRootcaIndex].dwStatus > 0)
	{
		pRuleData->bAuthMethodSpecified = TRUE;
		pRuleData->AuthInfos.dwNumAuthInfos += parser.Cmd[uiRootcaIndex].dwStatus;
		ppRootcaMMAuth = (PSTA_MM_AUTH_METHODS *)(parser.Cmd[uiRootcaIndex].pArg);
	}

	dwReturn = AddAllAuthMethods(pRuleData, pKerbAuth, pPskAuth, ppRootcaMMAuth, FALSE);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
	*ppRuleData=pRuleData;
	pRuleData = NULL;

error:   // if default auth loading failed, clean up everything and make 'pRuleData' as NULL
	CleanupAuthData(&pKerbAuth, &pPskAuth, ppRootcaMMAuth);
	CleanUpLocalRuleDataStructure(pRuleData);
	CleanUp();

	return dwReturn;
}

///////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticSetDefaultRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command "Set DefaultRule "
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticSetDefaultRule(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	DWORD dwRet = ERROR_SHOW_USAGE;
	PIPSEC_POLICY_DATA pPolicyData = NULL;
	PIPSEC_NFA_DATA pDefaultNFAData = NULL;
	HANDLE hPolicyStorage = NULL;
	BOOL bPolicyExists=FALSE;
	PDEFAULTRULE pDefRuleData= NULL;
	DWORD dwReturnCode = ERROR_SUCCESS;
	BOOL bCertConversionSuceeded=TRUE;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticSetDefaultRule[] =
	{
		{ CMD_TOKEN_STR_POLICY,			NS_REQ_PRESENT,	  FALSE	},
		{ CMD_TOKEN_STR_QMPFS,			NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_ACTIVATE,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_QMSECMETHODS,	NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_KERB,	        NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_PSK,	        NS_REQ_ZERO,	  FALSE	},
	};

	const TOKEN_VALUE vtokStaticSetDefaultRule[] =
	{
		{ CMD_TOKEN_STR_POLICY,			CMD_TOKEN_POLICY		},
		{ CMD_TOKEN_STR_QMPFS,			CMD_TOKEN_QMPFS			},
		{ CMD_TOKEN_STR_ACTIVATE,		CMD_TOKEN_ACTIVATE		},
		{ CMD_TOKEN_STR_QMSECMETHODS,	CMD_TOKEN_QMSECMETHODS	},
		{ CMD_TOKEN_STR_KERB,	        CMD_TOKEN_KERB          },
		{ CMD_TOKEN_STR_PSK,	        CMD_TOKEN_PSK	        }
	};

	const TOKEN_VALUE vlistStaticSetDefaultRule[] =
	{
		{ CMD_TOKEN_STR_ROOTCA,	        CMD_TOKEN_ROOTCA	    },
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <=3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticSetDefaultRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticSetDefaultRule);

	parser.ValidCmd   = vcmdStaticSetDefaultRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticSetDefaultRule);

	parser.ValidList  = vlistStaticSetDefaultRule;
	parser.MaxList    = SIZEOF_TAG_TYPE(vlistStaticSetDefaultRule);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);
	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	//get the parsed user input

	dwRet = FillSetDefRuleInfo(&pDefRuleData,parser,vtokStaticSetDefaultRule);

	if(dwRet==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if (!pDefRuleData->pszPolicyName || (pDefRuleData->pszPolicyName[0] == TEXT('\0')) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_POLICY_MISSING_POL_NAME);
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		 PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		 dwRet=ERROR_SUCCESS;
		 BAIL_OUT;
	}

	//get the policy from store

	if(!(bPolicyExists=GetPolicyFromStore(&pPolicyData,pDefRuleData->pszPolicyName,hPolicyStorage)))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_STATIC_RULE_3,pDefRuleData->pszPolicyName);
	}
	else
	{
		if(pPolicyData->dwFlags & POLSTORE_READONLY )
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_POL_READ_ONLY_OBJECT,pPolicyData->pszIpsecName);
			BAIL_OUT;
		}

		DWORD i;
		for(i=0;i<pPolicyData->dwNumNFACount;i++)
		{
			if (pPolicyData->ppIpsecNFAData[i]->pIpsecNegPolData->NegPolType==GUID_NEGOTIATION_TYPE_DEFAULT)
			{
				IPSecCopyNFAData(pPolicyData->ppIpsecNFAData[i],&pDefaultNFAData);
				break;
			}
		}
	}
	if(bPolicyExists && pDefaultNFAData) //this pDefaultNFAData checking is to shut the mouth of prefast. ideally it is not required
	{
		//check for readonly flag

		if(pDefaultNFAData->dwFlags & POLSTORE_READONLY )
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_POL_READ_ONLY_OBJECT,pPolicyData->pszIpsecName);
			BAIL_OUT;
		}

		dwReturnCode = UpdateDefaultResponseRule (pDefRuleData,pDefaultNFAData,bCertConversionSuceeded);
		BAIL_ON_WIN32_ERROR(dwReturnCode);

		// if cert specified and if conversion failed bail out

		if(!bCertConversionSuceeded)
		{
			dwReturnCode = ERROR_INVALID_DATA;
			BAIL_OUT;
		}

		//call the APIs in this sequence

		dwReturnCode = IPSecSetNegPolData(hPolicyStorage, pDefaultNFAData->pIpsecNegPolData);
		BAIL_ON_WIN32_ERROR(dwReturnCode);

		dwReturnCode=IPSecSetNFAData(hPolicyStorage, pPolicyData->PolicyIdentifier, pDefaultNFAData);
		BAIL_ON_WIN32_ERROR(dwReturnCode);

		dwReturnCode=IPSecSetPolicyData(hPolicyStorage, pPolicyData);

		if(dwReturnCode ==ERROR_SUCCESS && g_NshPolStoreHandle.GetBatchmodeStatus())
		{
			g_NshPolNegFilData.DeletePolicyFromCache(pPolicyData);
		}
	}

	ClosePolicyStore(hPolicyStorage);
	if(pPolicyData)
	{
		IPSecFreePolicyData(pPolicyData);
	}

error:

	if(dwReturnCode==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
	}
	else if(dwReturnCode != ERROR_SUCCESS)
	{
		if(pDefRuleData && pDefRuleData->pszPolicyName)
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_DEFRULE_2,pDefRuleData->pszPolicyName);
		}
		dwRet=ERROR_SUCCESS;
	}

	//clean up the loca structure

	CleanUpLocalDefRuleDataStructure(pDefRuleData);

	return dwRet;
}

///////////////////////////////////////////////////////////////////////
//
//Function: FillSetDefRuleInfo( )
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PDEFAULTRULE* ppRuleData,
//	IN PARSER_PKT & parser,
//	IN const TOKEN_VALUE *vtokStaticSetDefaultRule,
//	IN const TOKEN_VALUE *vlistStaticSetDefaultRule
//
//Return: DWORD
//
//Description:
//	This function fills the local structure with the information got from the parser.
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD
FillSetDefRuleInfo(
	OUT PDEFAULTRULE* ppRuleData,
	IN PARSER_PKT & parser,
	IN const TOKEN_VALUE *vtokStaticSetDefaultRule
	)
{
	DWORD dwCount=0 , dwReturn = ERROR_SUCCESS , dwStrLength = 0;
	PDEFAULTRULE pDefRuleData=new DEFAULTRULE;
	if (pDefRuleData == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	ZeroMemory(pDefRuleData,sizeof(DEFAULTRULE));
	PRULEDATA pRuleData = new RULEDATA;
	if (pRuleData == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	ZeroMemory(pRuleData,sizeof(RULEDATA));
	PSTA_AUTH_METHODS pKerbAuth = NULL;
	PSTA_AUTH_METHODS pPskAuth = NULL;
	PSTA_MM_AUTH_METHODS *ppRootcaMMAuth = NULL;

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticSetDefaultRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{

			case CMD_TOKEN_POLICY 		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

								pDefRuleData->pszPolicyName = new _TCHAR[dwStrLength+1];
								if(pDefRuleData->pszPolicyName==NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								_tcsncpy(pDefRuleData->pszPolicyName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							}
							break;
 			case CMD_TOKEN_ACTIVATE 	:
 							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pDefRuleData->bActivate = *(BOOL *)parser.Cmd[dwCount].pArg;
								pDefRuleData->bActivateSpecified=TRUE;
							}
							break;
			case CMD_TOKEN_QMPFS		:
							if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
							{
								pDefRuleData->bQMPfs = *(BOOL *)parser.Cmd[dwCount].pArg;
								pDefRuleData->bQMPfsSpecified=TRUE;

							}
							break;
			case CMD_TOKEN_QMSECMETHODS		:
							if(parser.Cmd[dwCount].dwStatus >0)
							{
								pDefRuleData->dwNumSecMethodCount=parser.Cmd[dwCount].dwStatus;
								pDefRuleData->pIpsecSecMethods = new IPSEC_QM_OFFER[pDefRuleData->dwNumSecMethodCount];
								if(pDefRuleData->pIpsecSecMethods==NULL)
								{
									dwReturn = ERROR_OUTOFMEMORY;
									BAIL_OUT;
								}
								memset(pDefRuleData->pIpsecSecMethods, 0, sizeof(IPSEC_QM_OFFER) * pDefRuleData->dwNumSecMethodCount);

								for(DWORD j=0;j< pDefRuleData->dwNumSecMethodCount;j++)
								{
									if ( ((IPSEC_QM_OFFER **)parser.Cmd[dwCount].pArg)[j] )
										memcpy( &(pDefRuleData->pIpsecSecMethods[j]),((IPSEC_QM_OFFER **)parser.Cmd[dwCount].pArg)[j],sizeof(IPSEC_QM_OFFER));
								}
							}
							break;
			case CMD_TOKEN_KERB             :
							if (parser.Cmd[dwCount].dwStatus > 0)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pKerbAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_PSK			:
							if (parser.Cmd[dwCount].dwStatus > 0)
							{
								pRuleData->bAuthMethodSpecified = TRUE;
								++pRuleData->AuthInfos.dwNumAuthInfos;
								pPskAuth = (PSTA_AUTH_METHODS)parser.Cmd[dwCount].pArg;
							}
							break;
			case CMD_TOKEN_ROOTCA		:
							// this case is special, handled below...
							break;
			default						:
							break;
		}
	}

	size_t uiRootcaIndex = parser.MaxTok;
	if (parser.Cmd[uiRootcaIndex].dwStatus > 0)
	{
		pRuleData->bAuthMethodSpecified = TRUE;
		pRuleData->AuthInfos.dwNumAuthInfos += parser.Cmd[uiRootcaIndex].dwStatus;
		ppRootcaMMAuth = (PSTA_MM_AUTH_METHODS *)(parser.Cmd[uiRootcaIndex].pArg);
	}

	dwReturn = AddAllAuthMethods(pRuleData, pKerbAuth, pPskAuth, ppRootcaMMAuth, FALSE);
	if (dwReturn != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}
	pDefRuleData->dwAuthInfos = pRuleData->dwAuthInfos;
	memcpy(&(pDefRuleData->AuthInfos), &(pRuleData->AuthInfos), sizeof(STA_AUTH_METHODS));
	pRuleData->dwAuthInfos = 0;
	pRuleData->AuthInfos.pAuthMethodInfo = NULL;
	delete pRuleData;
	pRuleData = NULL;

error:   // if default auth loading failed, clean up everything and make 'pRuleData' as NULL
	CleanupAuthData(&pKerbAuth, &pPskAuth, ppRootcaMMAuth);
	CleanUpLocalRuleDataStructure(pRuleData);

	*ppRuleData=pDefRuleData;

	CleanUp();

	return dwReturn;
}


///////////////////////////////////////////////////////////////////////
//
//Function: ReAllocNegPolMem()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN OUT PIPSEC_SECURITY_METHOD pIpsecSecurityMethods,
//	IN DWORD dwOld,
//	IN DWORD dwNew
//
//Return: PIPSEC_SECURITY_METHOD
//
//Description:
//	This function reallocates the memory for IPSEC_SECURITY_METHOD
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

PIPSEC_SECURITY_METHOD
ReAllocNegPolMem(
	IN OUT PIPSEC_SECURITY_METHOD pIpsecSecurityMethods,
	IN DWORD dwOld,
	IN DWORD dwNew
	)

{

	PIPSEC_SECURITY_METHOD pIpsecSecMethods = (IPSEC_SECURITY_METHOD *) IPSecAllocPolMem(dwNew * sizeof(IPSEC_SECURITY_METHOD));
	if(pIpsecSecMethods != NULL)
	{
		for(DWORD i=0;i<min(dwNew, dwOld);i++)
			memcpy(&pIpsecSecMethods[i],&pIpsecSecurityMethods[i],sizeof(IPSEC_SECURITY_METHOD));
	}
	IPSecFreePolMem(pIpsecSecurityMethods);
    return pIpsecSecMethods;
}

///////////////////////////////////////////////////////////////////////
//
//Function: UpdateNegotiationPolicy()
//
//Date of Creation: 21st Aug 2001
//

//Parameters:
//	IN OUT PIPSEC_NEGPOL_DATA pNegPol,
//	IN PFILTERACTION pFilterAction
//
//Return: DWORD
//
//Description:
//	This function updates the existing Neg policy based on the user input.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD
UpdateNegotiationPolicy(
	IN OUT PIPSEC_NEGPOL_DATA pNegPol,
	IN PFILTERACTION pFilterAction
	)
{

	DWORD i=0,dwNumSecMethods=0,dwReturn = ERROR_SUCCESS;
	BOOL bSoftExists=FALSE;

	for (i=0; i< pNegPol->dwSecurityMethodCount; i++)
	{
		if (CheckSoft(pNegPol->pIpsecSecurityMethods[i]))
		{
			bSoftExists=TRUE;
			break;
		}
	}

	if(pFilterAction->dwNumSecMethodCount > 0)
	{
		if(!pFilterAction->bQMPfsSpecified && pNegPol->pIpsecSecurityMethods )
		{
			pFilterAction->bQMPfs = pNegPol->pIpsecSecurityMethods[0].PfsQMRequired;
		}

		pNegPol->NegPolType = GUID_NEGOTIATION_TYPE_STANDARD;
		pNegPol->dwSecurityMethodCount = pFilterAction->dwNumSecMethodCount;

		if( (!pFilterAction->bSoftSpecified && bSoftExists)|| (pFilterAction->bSoftSpecified && pFilterAction->bSoft))
		{
			// we need to add one more offer with no security algorithms
			pNegPol->dwSecurityMethodCount++;
			dwNumSecMethods=pNegPol->dwSecurityMethodCount-1;
		}
		else
			dwNumSecMethods=pNegPol->dwSecurityMethodCount;

		if(pNegPol->pIpsecSecurityMethods)
			IPSecFreePolMem(pNegPol->pIpsecSecurityMethods);

		// allocate sec.methods
		pNegPol->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *) IPSecAllocPolMem(pNegPol->dwSecurityMethodCount * sizeof(IPSEC_SECURITY_METHOD));

		// fix up PFS, in storage it is the property of the filter action, not individual offer
		if(pNegPol->pIpsecSecurityMethods==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

		// handle sec.methods
		for (i = 0; i <  dwNumSecMethods; i++)
		{
			DWORD j;

			pNegPol->pIpsecSecurityMethods[i].Lifetime.KeyExpirationBytes = pFilterAction->pIpsecSecMethods[i].Lifetime.uKeyExpirationKBytes;
			pNegPol->pIpsecSecurityMethods[i].Lifetime.KeyExpirationTime = pFilterAction->pIpsecSecMethods[i].Lifetime.uKeyExpirationTime;
			pNegPol->pIpsecSecurityMethods[i].Flags = 0;
			pNegPol->pIpsecSecurityMethods[i].PfsQMRequired = pFilterAction->bQMPfs;
			pNegPol->pIpsecSecurityMethods[i].Count = pFilterAction->pIpsecSecMethods[i].dwNumAlgos;
			for (j = 0; j <  pNegPol->pIpsecSecurityMethods[i].Count && j < QM_MAX_ALGOS; j++)
			{
				pNegPol->pIpsecSecurityMethods[i].Algos[j].algoIdentifier = pFilterAction->pIpsecSecMethods[i].Algos[j].uAlgoIdentifier;
				pNegPol->pIpsecSecurityMethods[i].Algos[j].secondaryAlgoIdentifier = pFilterAction->pIpsecSecMethods[i].Algos[j].uSecAlgoIdentifier;
				pNegPol->pIpsecSecurityMethods[i].Algos[j].algoKeylen = pFilterAction->pIpsecSecMethods[i].Algos[j].uAlgoKeyLen;
				pNegPol->pIpsecSecurityMethods[i].Algos[j].algoRounds = pFilterAction->pIpsecSecMethods[i].Algos[j].uAlgoRounds;
				switch (pFilterAction->pIpsecSecMethods[i].Algos[j].Operation)
				{
					case AUTHENTICATION:
						pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = Auth;
						break;
					case ENCRYPTION:
						pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = Encrypt;
						break;
					default:
						pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = None;
				}
			}
		}

		// add soft
		if( (!pFilterAction->bSoftSpecified && bSoftExists)|| (pFilterAction->bSoftSpecified && pFilterAction->bSoft))
		{
			// set Count (and everything) to 0
			memset(&(pNegPol->pIpsecSecurityMethods[pNegPol->dwSecurityMethodCount - 1]), 0, sizeof(IPSEC_SECURITY_METHOD));
		}
	}
	else
	{
		for (i = 0; i < pNegPol->dwSecurityMethodCount; i++)
		{
			if(pFilterAction->bQMPfsSpecified)
			{
				pNegPol->pIpsecSecurityMethods[i].PfsQMRequired = pFilterAction->bQMPfs;
			}
		}

		if((pFilterAction->bSoftSpecified)&&(pFilterAction->bSoft)&&(!bSoftExists))
		{
			pNegPol->dwSecurityMethodCount++;
			pNegPol->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *)ReAllocNegPolMem(pNegPol->pIpsecSecurityMethods,pNegPol->dwSecurityMethodCount-1,pNegPol->dwSecurityMethodCount);
			if(pNegPol->pIpsecSecurityMethods==NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			memset(&(pNegPol->pIpsecSecurityMethods[pNegPol->dwSecurityMethodCount - 1]), 0, sizeof(IPSEC_SECURITY_METHOD));
		}


		if(((pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)||(pFilterAction->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC))&&(!((pNegPol->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)||(pNegPol->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC)))&& bSoftExists)
		{
			pNegPol->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *)ReAllocNegPolMem(pNegPol->pIpsecSecurityMethods,pNegPol->dwSecurityMethodCount,pNegPol->dwSecurityMethodCount-1);
			pNegPol->dwSecurityMethodCount--;
		}
		else if(bSoftExists && pFilterAction->bSoftSpecified && !pFilterAction->bSoft)
		{
			pNegPol->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *)ReAllocNegPolMem(pNegPol->pIpsecSecurityMethods,pNegPol->dwSecurityMethodCount,pNegPol->dwSecurityMethodCount-1);
			pNegPol->dwSecurityMethodCount--;

		}
	}
	// update name
	if(pFilterAction->pszNewFAName)
	{
		IPSecFreePolStr(pNegPol->pszIpsecName);
		pNegPol->pszIpsecName = IPSecAllocPolStr(pFilterAction->pszNewFAName);
		if (pNegPol->pszIpsecName == NULL)
		{
			dwReturn=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

	}
	// update desc
	if(pFilterAction->pszFADescription)
	{
		IPSecFreePolStr(pNegPol->pszDescription);
		pNegPol->pszDescription = IPSecAllocPolStr(pFilterAction->pszFADescription);
		if (pNegPol->pszDescription == NULL)
		{
			dwReturn=ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}
	// update negpol action
	if(pFilterAction->bNegPolActionSpecified)
	{
		pNegPol->NegPolAction=pFilterAction->NegPolAction;
	}
error:
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////
//
//Function: UpdateDefaultResponseRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PDEFAULTRULE pRuleData,
//	IN OUT PIPSEC_NFA_DATA pRule
//  IN OUT BOOL &bCertConversionSuceeded
//
//Return: DWORD
//
//Description:
//	This function updates the existing Default response rule based on the user input.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD
UpdateDefaultResponseRule (
	IN PDEFAULTRULE pRuleData,
	IN OUT PIPSEC_NFA_DATA pRule,
	IN OUT BOOL &bCertConversionSuceeded
	)
{
	DWORD dwReturn = ERROR_SUCCESS;

	pRule->dwWhenChanged = 0;

	// filter action
	dwReturn = UpdateDefaultResponseNegotiationPolicy (pRuleData,pRule);


	if(pRuleData->bActivateSpecified)
	{
		pRule->dwActiveFlag = pRuleData->bActivate;
	}

	// auth methods
	if (pRuleData->dwAuthInfos == 0)
	{
		BAIL_OUT;
	}
	//clean up first
	CleanUpAuthInfo(pRule);

	pRule->dwAuthMethodCount = pRuleData->AuthInfos.dwNumAuthInfos;

	pRule->ppAuthMethods = (PIPSEC_AUTH_METHOD *) IPSecAllocPolMem(pRule->dwAuthMethodCount * sizeof(PIPSEC_AUTH_METHOD));
	if(pRule->ppAuthMethods == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	dwReturn = LoadAuthenticationInfos(pRuleData->AuthInfos, pRule,bCertConversionSuceeded);

error:
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////
//
//Function: UpdateDefaultResponseNegotiationPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PDEFAULTRULE pRuleData,
//	IN OUT PIPSEC_NFA_DATA pRule
//
//Return: DWORD
//
//Description:
//	This function updates the existing Default response Neg Policy based on the user input.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD
UpdateDefaultResponseNegotiationPolicy (
	IN PDEFAULTRULE pRuleData,
	IN OUT PIPSEC_NFA_DATA pRule
	)
{
	DWORD i=0,dwReturn = ERROR_SUCCESS;

	if(pRuleData->dwNumSecMethodCount > 0)
	{

		if(!pRuleData->bQMPfsSpecified)
		{
			pRuleData->bQMPfs=pRule->pIpsecNegPolData->pIpsecSecurityMethods[0].PfsQMRequired;
		}
		if(pRule->pIpsecNegPolData->pIpsecSecurityMethods)
		{
			IPSecFreePolMem(pRule->pIpsecNegPolData->pIpsecSecurityMethods);
		}

		pRule->pIpsecNegPolData->dwSecurityMethodCount = pRuleData->dwNumSecMethodCount;

		// allocate sec.methods
		pRule->pIpsecNegPolData->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *) IPSecAllocPolMem(pRule->pIpsecNegPolData->dwSecurityMethodCount * sizeof(IPSEC_SECURITY_METHOD));

		// fix up PFS, in storage it is the property of the filter action, not individual offer
		if(pRule->pIpsecNegPolData->pIpsecSecurityMethods == NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

		// handle sec.methods
		for (i = 0; i <  pRule->pIpsecNegPolData->dwSecurityMethodCount; i++)
		{
			DWORD j;
			pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Lifetime.KeyExpirationBytes = pRuleData->pIpsecSecMethods[i].Lifetime.uKeyExpirationKBytes;
			pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Lifetime.KeyExpirationTime = pRuleData->pIpsecSecMethods[i].Lifetime.uKeyExpirationTime;
			pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Flags = 0;
			pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].PfsQMRequired = pRuleData->bQMPfs;
			pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Count = pRuleData->pIpsecSecMethods[i].dwNumAlgos;
			for (j = 0; j <  pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Count && j < QM_MAX_ALGOS; j++)
			{
				pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Algos[j].algoIdentifier = pRuleData->pIpsecSecMethods[i].Algos[j].uAlgoIdentifier;
				pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Algos[j].secondaryAlgoIdentifier = pRuleData->pIpsecSecMethods[i].Algos[j].uSecAlgoIdentifier;
				pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Algos[j].algoKeylen = pRuleData->pIpsecSecMethods[i].Algos[j].uAlgoKeyLen;
				pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Algos[j].algoRounds = pRuleData->pIpsecSecMethods[i].Algos[j].uAlgoRounds;
				switch (pRuleData->pIpsecSecMethods[i].Algos[j].Operation)
				{
					case AUTHENTICATION:
						pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Algos[j].operation = Auth;
						break;
					case ENCRYPTION:
						pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Algos[j].operation = Encrypt;
						break;
					default:
						pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].Algos[j].operation = None;
				}
			}
		}
	}
	else  // if no qmsec, update the other things
	{
		for (i = 0; i < pRule->pIpsecNegPolData->dwSecurityMethodCount; i++)
		{
			if(pRuleData->bQMPfsSpecified)
			{
				pRule->pIpsecNegPolData->pIpsecSecurityMethods[i].PfsQMRequired = pRuleData->bQMPfs;
			}
		}
	}

error:
	return dwReturn;
}

///////////////////////////////////////////////////////////////////////
//
//Function: GetRuleFromPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_POLICY_DATA pPolicy,
//	IN PRULEDATA pRuleData
//
//Return: PIPSEC_NFA_DATA
//
//Description:
//	This function retrieves the user specified rule info from the specified policy.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

PIPSEC_NFA_DATA
GetRuleFromPolicy(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN PRULEDATA pRuleData
	)
{
	PIPSEC_NFA_DATA pRule=NULL;

	DWORD i=0;
	if(pRuleData->bIDSpecified)  //get rule based on ID
	{
		for(i=0;i<pPolicy->dwNumNFACount;i++)
		{
			if (i==((pRuleData->dwRuleId)-1))
			{
				IPSecCopyNFAData(pPolicy->ppIpsecNFAData[i],&pRule);
			}
		}
	}
	else     					//get rule based on name
	{
		for(i=0;i<pPolicy->dwNumNFACount;i++)
		{
			if (pRuleData->pszRuleName && pPolicy->ppIpsecNFAData[i]->pszIpsecName &&(_tcscmp(pPolicy->ppIpsecNFAData[i]->pszIpsecName,pRuleData->pszRuleName)==0))
			{
				 IPSecCopyNFAData(pPolicy->ppIpsecNFAData[i],&pRule);
			}
		}
	}
	return pRule;
}

///////////////////////////////////////////////////////////////////////
//
//Function: UpdateRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_POLICY_DATA pPolicy,
//	IN PRULEDATA pRuleData,
//	IN PIPSEC_NEGPOL_DATA pNegPolData,
//	IN PIPSEC_FILTER_DATA pFilterData,
//	IN HANDLE hPolicyStorage
//
//Return: DWORD
//
//Description:
//	This function updates the specified rule based on the user input.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD
UpdateRule(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN PRULEDATA pRuleData,
	IN PIPSEC_NEGPOL_DATA pNegPolData,
	IN PIPSEC_FILTER_DATA pFilterData,
	IN HANDLE hPolicyStorage
	)
{
	BOOL bCertConversionSuceeded=TRUE;
	DWORD dwReturn = ERROR_SUCCESS;
	PIPSEC_NFA_DATA pRule = GetRuleFromPolicy(pPolicy,pRuleData);

	if(pRule==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	if(pRule->dwFlags & POLSTORE_READONLY )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_ADD_SET_RULE_READ_ONLY_OBJECT);
		BAIL_OUT;
	}

	pRule->pszInterfaceName = pRule->pszEndPointName = NULL;

	//update name

	if (pRuleData->pszNewRuleName)
	{
		if(pRule->pszIpsecName)
			IPSecFreePolStr(pRule->pszIpsecName);
		pRule->pszIpsecName = IPSecAllocPolStr(pRuleData->pszNewRuleName);
		if(pRule->pszIpsecName==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}

	//update desc

	if (pRuleData->pszRuleDescription)
	{
		if(pRule->pszDescription)
			IPSecFreePolStr(pRule->pszDescription);
		pRule->pszDescription = IPSecAllocPolStr(pRuleData->pszRuleDescription);
		if(pRule->pszDescription==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}
	}

	//update filterdata

	if(pFilterData)
	{
		pRule->pIpsecFilterData = NULL;
		pRule->FilterIdentifier = pFilterData->FilterIdentifier;
	}

	//update filteraction

	if(pNegPolData)
	{
		pRule->pIpsecNegPolData = NULL;
		pRule->NegPolIdentifier = pNegPolData->NegPolIdentifier;
	}

	//update tunnel

	if (pRuleData->bTunnelSpecified)
	{
		if(pRuleData->bTunnel)
		{
			pRule->dwTunnelFlags = 1;
			pRule->dwTunnelIpAddr = pRuleData->TunnelIPAddress;
		}
		else
		{
			pRule->dwTunnelFlags = 0;
			pRule->dwTunnelIpAddr = 0;
		}
	}

   	// interface type
	if(pRuleData->bConnectionTypeSpecified)
	{
		if (pRuleData->ConnectionType == INTERFACE_TYPE_ALL)
		{
			pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_ALL;
		}
		else if (pRuleData->ConnectionType == INTERFACE_TYPE_LAN)
		{
			pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_LAN;
		}
		else if (pRuleData->ConnectionType == INTERFACE_TYPE_DIALUP)
		{
			pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_DIALUP;
		}
		else
		{
			pRule->dwInterfaceType = (DWORD)PAS_INTERFACE_TYPE_NONE;
		}
	}

   	// active flag
	if(pRuleData->bActivateSpecified)
	{
		pRule->dwActiveFlag = pRuleData->bActivate;
	}

   	// auth methods
	if (pRuleData->dwAuthInfos>0)
	{
		//clean up first
		CleanUpAuthInfo(pRule);

		pRule->dwAuthMethodCount = pRuleData->AuthInfos.dwNumAuthInfos;

		pRule->ppAuthMethods = (PIPSEC_AUTH_METHOD *) IPSecAllocPolMem(pRule->dwAuthMethodCount * sizeof(PIPSEC_AUTH_METHOD));
		if(pRule->ppAuthMethods == NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

		dwReturn = LoadAuthenticationInfos(pRuleData->AuthInfos, pRule,bCertConversionSuceeded);

	}
	if(bCertConversionSuceeded && dwReturn != ERROR_OUTOFMEMORY)  // if success , call the API
	{
		dwReturn=IPSecSetNFAData(hPolicyStorage, pPolicy->PolicyIdentifier, pRule);

		if(dwReturn==ERROR_SUCCESS)
		{
			dwReturn=IPSecSetPolicyData(hPolicyStorage, pPolicy);

			if(dwReturn==ERROR_SUCCESS && g_NshPolStoreHandle.GetBatchmodeStatus())
			{
				g_NshPolNegFilData.DeletePolicyFromCache(pPolicy);
			}
		}
	}

error:  //clean up
 	if(dwReturn == ERROR_OUTOFMEMORY)
 	{
		dwReturn=ERROR_SUCCESS;
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		if(pRule)
		{
			CleanUpAuthInfo(pRule);  //this function frees only auth info.
			IPSecFreePolMem(pRule);  //since the above fn is used in other fns also, this free is required to cleanup other rule memory
			pRule=NULL;
		}
	}
   return dwReturn;
}

///////////////////////////////////////////////////////////////////////
//
//Function: GetPolicyFromStoreBasedOnGuid()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	OUT PIPSEC_POLICY_DATA *ppPolicy,
//	IN PPOLICYDATA pPolicyData,
//	IN HANDLE hPolicyStorage
//
//Return: BOOL
//
//Description:
//	This function retrieves the policy from store based on the guid specified.
//
//Revision History:
//
//Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

BOOL
GetPolicyFromStoreBasedOnGuid(
	OUT PIPSEC_POLICY_DATA *ppPolicy,
	IN PPOLICYDATA pPolicyData,
	IN HANDLE hPolicyStorage
	)
{

	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	BOOL bPolicyExists=FALSE;
	DWORD  dwNumPolicies = 0,i=0,j=0;
	DWORD dwReturnCode=ERROR_SUCCESS;
	RPC_STATUS RpcStat =RPC_S_OK;

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);
	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		BAIL_OUT;  							// if no policy, bail out
	}
	for (i = 0; i <  dwNumPolicies; i++)  	// pick the required policy data structure
	{
		if (UuidCompare(&(ppPolicyEnum[i]->PolicyIdentifier), &(pPolicyData->PolicyGuid), &RpcStat) == 0 && RpcStat == RPC_S_OK)
		{
			bPolicyExists=TRUE;

			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);

			if (pPolicyData->bActivateDefaultRuleSpecified && dwReturnCode == ERROR_SUCCESS)
			{
				dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
										  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));
			}
			if (dwReturnCode == ERROR_SUCCESS)
			{
				dwReturnCode = IPSecGetISAKMPData(hPolicyStorage, pPolicy->ISAKMPIdentifier, &(pPolicy->pIpsecISAKMPData));

				if(dwReturnCode==ERROR_SUCCESS && pPolicyData->bActivateDefaultRuleSpecified)
				{
					for (j = 0; j <  pPolicy->dwNumNFACount; j++)
					{
						if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->NegPolIdentifier), &RpcStat))
						{
							dwReturnCode = IPSecGetNegPolData(hPolicyStorage,
										 pPolicy->ppIpsecNFAData[j]->NegPolIdentifier,
										 &(pPolicy->ppIpsecNFAData[j]->pIpsecNegPolData));

						}
					}
				}
			}
		}
	}
	// clean it up
	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}

	if(pPolicy) *ppPolicy=pPolicy;
error:
	return bPolicyExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticsetutils.h ===
//////////////////////////////////////////////////////////////////////
// Header: staticsetutils.h
//
// Purpose: 	Defining structures and prototypes for statisetutils.cpp.
//
// Developers Name: surya
//
// History:
//
//   Date    		Author    	Comments
//	21th Aug 2001	surya		Initial Version.
//
//////////////////////////////////////////////////////////////////////

#ifndef _STATICSETUTIS_H_
#define _STATICSETUTIS_H_

const TCHAR OPEN_GUID_BRACE		=	_T('{');
const TCHAR CLOSE_GUID_BRACE	=	_T('}');

//
//  The machine is not in a W2K domain, or the DS is unavailable.
//
#define E_IDS_NO_DS                      ((HRESULT)0xCBBC0001L)
//
//  An attempt to get the ADsPath failed due to internal error.
//
#define E_IDS_NODNSTRING                 ((HRESULT)0xCBBC0002L)

#include <unknwn.h>
#include <initguid.h>

extern "C" {
#include <iads.h>
#include <adshlp.h>
#include <activeds.h>
#include <commctrl.h>
#include <ntdsapi.h>
#include <gpedit.h>
}

const UINT  IDS_MAX_FILTLEN = 1024;
const UINT  IDS_MAX_PATHLEN = 2048;

//
// Enum used by FindObject
//
enum objectClass {
   OBJCLS_ANY=0,
   OBJCLS_OU,
   OBJCLS_GPO,
   OBJCLS_IPSEC_POLICY,
   OBJCLS_CONTAINER,
   OBJCLS_COMPUTER
};
//
// ipsec snapin guids:
//
const CLSID CLSID_Snapin =    { 0xdea8afa0, 0xcc85, 0x11d0,
   { 0x9c, 0xe2, 0x0, 0x80, 0xc7, 0x22, 0x1e, 0xbd } };


const CLSID CLSID_IPSECClientEx = {0xe437bc1c, 0xaa7d, 0x11d2,
   {0xa3, 0x82, 0x0, 0xc0, 0x4f, 0x99, 0x1e, 0x27 } };
//
//Function Prototypes
//
BOOL
IsDSAvailable(
	OUT LPTSTR * pszPath
	);

HRESULT
FindObject(
	 IN    LPTSTR  szName,
	 IN    objectClass cls,
	 OUT   LPTSTR &  szPath
	 );

HRESULT
AssignIPSecPolicyToGPO(
	 IN   LPTSTR  szPolicyName,
	 IN   LPTSTR  szGPO,
	 IN   BOOL bAssign
	 );

HRESULT
GetIPSecPolicyInfo(
	 IN  LPTSTR   szPath,
	 OUT LPTSTR & szName,
	 OUT LPTSTR & szDescription
	 );

HRESULT
CreateDirectoryAndBindToObject(
    IN IDirectoryObject * pParentContainer,
    IN LPWSTR pszCommonName,
    IN LPWSTR pszObjectClass,
    OUT IDirectoryObject ** ppDirectoryObject
    );

HRESULT
CreateChildPath(
    IN LPWSTR pszParentPath,
    IN LPWSTR pszChildComponent,
    OUT BSTR * ppszChildPath
    );

HRESULT
ConvertADsPathToDN(
    IN LPWSTR pszPathName,
    OUT BSTR * ppszPolicyDN
    );

HRESULT
AddPolicyInformationToGPO(
    IN LPWSTR pszMachinePath,
    IN LPWSTR pszName,
    IN LPWSTR pszDescription,
    IN LPWSTR pszPathName
    );

HRESULT
DeletePolicyInformationFromGPO(
    IN LPWSTR pszMachinePath
    );

BOOL
IsADsPath(
    IN LPTSTR szPath
    );

VOID
StripGUIDBraces(
	IN OUT LPTSTR & pszGUIDStr
	);

DWORD
AllocBSTRMem(
	IN LPTSTR  pszStr,
	IN OUT BSTR & pbsStr
	);

VOID
CleanUpAuthInfo(
	PIPSEC_NFA_DATA &pRule
	);

VOID
CleanUpPolicy(
	PIPSEC_POLICY_DATA &pPolicy
	);

VOID
CleanUpLocalRuleDataStructure(
	PRULEDATA &pRuleData
	);

VOID
CleanUpLocalPolicyDataStructure(
	PPOLICYDATA &pPolicyData
	);

VOID
CleanUpLocalFilterActionDataStructure(
	PFILTERACTION &pFilterAction
	);

VOID
CleanUpLocalFilterDataStructure(
	PFILTERDATA &pFilter
	);

VOID
CleanUpLocalDelFilterDataStructure(
	PDELFILTERDATA &pFilter
	);

VOID
CleanUpLocalDefRuleDataStructure(
	PDEFAULTRULE &pDefRuleData
	);

#endif //   _STATICSETUTIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticshow.cpp ===
///////////////////////////////////////////////////////////////////////
//Module: Static/StaticShow.cpp
//
// Purpose: 	Static Module Implementation.
//
// Developers Name: Surya
//
// History:
//
//   Date    	Author    	Comments
//	10-8-2001	Surya		Initial Version. SCM Base line 1.0
//
///////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern STORAGELOCATION g_StorageLocation;

///////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticShowPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Show Policy "
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticShowPolicy(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	BOOL bVerbose = FALSE, bAll = FALSE, bExists = FALSE, bWide=FALSE;
	BOOL bAssigned=FALSE,bTable=FALSE, bTitlePrinted=FALSE;
	LPTSTR pszPolicyName = NULL, pszMachineName=NULL;
	DWORD dwLocation = 0, dwCount = 0, dwRet = ERROR_SHOW_USAGE, dwNumPolicies = 0,i=0,j=0;
	RPC_STATUS RpcStat=RPC_S_OK;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL;
	PIPSEC_POLICY_DATA pPolicy = NULL;
	HANDLE hPolicyStorage = NULL;
	DWORD dwReturnCode   = ERROR_SUCCESS , dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticShowPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_VERBOSE,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_FORMAT,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_WIDE,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokStaticShowPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		},
		{ CMD_TOKEN_STR_VERBOSE,	CMD_TOKEN_VERBOSE	},
		{ CMD_TOKEN_STR_FORMAT,		CMD_TOKEN_FORMAT	},
		{ CMD_TOKEN_STR_WIDE,		CMD_TOKEN_WIDE		}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}
	parser.ValidTok   = vtokStaticShowPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticShowPolicy);

	parser.ValidCmd   = vcmdStaticShowPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticShowPolicy);

	dwRet = Parser(pwszMachine, ppwcArguments, dwCurrentIndex, dwArgCount, &parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	//get parsed user input

	for(dwCount=0; dwCount<parser.MaxTok; dwCount++)
	{
		switch(vtokStaticShowPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszPolicyName = new _TCHAR[dwStrLength+1];
						if(pszPolicyName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszPolicyName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_VERBOSE 	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bVerbose = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_ALL 		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bAll = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_FORMAT	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bTable = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_WIDE		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bWide = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			default					:
					break;
		}
	}

	CleanUp(); //Cleans up the Parser output data structures

	dwReturnCode = CopyStorageInfo(&pszMachineName, dwLocation);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);
	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	//get the requested policy data structures

	for (i = 0; i <  dwNumPolicies; i++)
	{
		bAssigned=FALSE;
		if ( bAll ||((pszPolicyName)&&(_tcscmp(ppPolicyEnum[i]->pszIpsecName, pszPolicyName) == 0)))
		{
			bExists = TRUE;
			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);

			if (dwReturnCode != ERROR_SUCCESS)
			{
				dwRet=dwReturnCode;
				BAIL_OUT;
			}

			dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
						  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

			if (dwReturnCode != ERROR_SUCCESS)
			{
				dwRet=dwReturnCode;
				BAIL_OUT;
			}

			dwReturnCode = IPSecGetISAKMPData(hPolicyStorage, pPolicy->ISAKMPIdentifier, &(pPolicy->pIpsecISAKMPData));
			if(dwReturnCode != ERROR_SUCCESS)
			{
				PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_5,pPolicy->pszIpsecName);
				BAIL_OUT;
			}

			if(bVerbose) // if verbose specified, get the other related data structures
			{
				for (j = 0; j <  pPolicy->dwNumNFACount; j++)
				{
					if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->NegPolIdentifier), &RpcStat))
					{
						dwReturnCode =  IPSecGetNegPolData(hPolicyStorage, pPolicy->ppIpsecNFAData[j]->NegPolIdentifier, &(pPolicy->ppIpsecNFAData[j]->pIpsecNegPolData));
						if (dwReturnCode != ERROR_SUCCESS)
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_3,pPolicy->pszIpsecName);
							BAIL_OUT;
						}
					}
					if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->FilterIdentifier), &RpcStat))
					{
						dwReturnCode =  IPSecGetFilterData(hPolicyStorage,	pPolicy->ppIpsecNFAData[j]->FilterIdentifier,&(pPolicy->ppIpsecNFAData[j]->pIpsecFilterData));
						if (dwReturnCode != ERROR_SUCCESS)
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_4,pPolicy->pszIpsecName);
							BAIL_OUT;
						}
					}
					//if (dwReturnCode != ERROR_SUCCESS) break;
				}
			}

			if(dwReturnCode == ERROR_SUCCESS)
			{
				if(g_StorageLocation.dwLocation !=IPSEC_DIRECTORY_PROVIDER)
					dwReturnCode=IsAssigned(pPolicy,hPolicyStorage,bAssigned);
				if((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode == ERROR_FILE_NOT_FOUND))
				{
					if(bTable)  // if table output requested
					{	if(!bVerbose && !bTitlePrinted)
						{
							if(g_StorageLocation.dwLocation !=IPSEC_DIRECTORY_PROVIDER)
							{
								PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_NONVERB_TITLE);
								PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_NONVERB_UNDERLINE);
								bTitlePrinted=TRUE;
							}
							else
							{
								PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_DOMAIN_NONVERB_TITLE);
								PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_DOMAIN_NONVERB_UNDERLINE);
								bTitlePrinted=TRUE;
							}
						}
						//call the relevant table printing function
						PrintPolicyTable(pPolicy,bVerbose,bAssigned,bWide);
					}
					else
					{
						// call the list output print function
						dwReturnCode = PrintPolicyList(pPolicy,bVerbose,bAssigned,bWide);
						if(dwReturnCode == ERROR_OUTOFMEMORY)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwReturnCode=ERROR_SUCCESS;
							BAIL_OUT;
						}
					}
				}
			}
			if (pPolicy)	IPSecFreePolicyData(pPolicy);
		}
		if ((dwReturnCode != ERROR_SUCCESS)&&(dwReturnCode != ERROR_FILE_NOT_FOUND)) break;
	}

	if((!bAll) && (!bExists)&&(dwReturnCode == ERROR_SUCCESS))
		 PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_LIST_POLICY_COUNT,pszPolicyName);

	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
	// in all specified, print the count
	if (bAll)
	{
		if(bTable)
			PrintMessageFromModule(g_hModule, SHW_STATIC_TAB_POLICY_COUNT, dwNumPolicies);
		else
			PrintMessageFromModule(g_hModule, SHW_STATIC_LIST_POLICY_COUNT, dwNumPolicies);
	}

	dwRet=ERROR_SUCCESS;

	ClosePolicyStore(hPolicyStorage);

error:
	if (pszMachineName) delete [] pszMachineName;
	return dwRet;
}

///////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticShowFilterList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Show FilterList "
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticShowFilterList(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	BOOL bVerbose =FALSE,bRuleExists=FALSE;
	BOOL bResolveDNS= FALSE,bWide=FALSE;
	BOOL bAllFlist=FALSE,bTable=FALSE;
	LPTSTR pszFlistName=NULL,pszRuleName=NULL,pszMachineName=NULL;
	DWORD dwLocation = 0,dwCount = 0,dwRet = ERROR_SHOW_USAGE,dwNumPolicies = 0, j= 0;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	HANDLE hPolicyStorage = NULL;
	RPC_STATUS     RpcStat =RPC_S_OK;
	DWORD  dwReturnCode   = ERROR_SUCCESS , dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticShowFilterList[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_RULE,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_VERBOSE,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_FORMAT,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_RESDNS,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_WIDE,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokStaticShowFilterList[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		},
		{ CMD_TOKEN_STR_RULE,		CMD_TOKEN_RULE 		},
		{ CMD_TOKEN_STR_VERBOSE,	CMD_TOKEN_VERBOSE	},
		{ CMD_TOKEN_STR_FORMAT,		CMD_TOKEN_FORMAT	},
		{ CMD_TOKEN_STR_RESDNS,		CMD_TOKEN_RESDNS	},
		{ CMD_TOKEN_STR_WIDE,		CMD_TOKEN_WIDE		}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticShowFilterList;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticShowFilterList);

	parser.ValidCmd   = vcmdStaticShowFilterList;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticShowFilterList);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the user input

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticShowFilterList[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszFlistName=new _TCHAR[dwStrLength+1];
						if(pszFlistName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszFlistName,(LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_RULE		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszRuleName=new _TCHAR[dwStrLength+1];
						if(pszRuleName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszRuleName,(LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength + 1);
					}
					break;
			case CMD_TOKEN_VERBOSE	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bVerbose= *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_ALL 		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bAllFlist= *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_FORMAT	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bTable = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_RESDNS	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bResolveDNS = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_WIDE		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bWide = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			default					:
					break;
		}
	}

	CleanUp(); //Cleans up the Parser output data structures

	dwReturnCode = CopyStorageInfo(&pszMachineName,dwLocation);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if (!pszRuleName && (bAllFlist|| pszFlistName))  // if all or filterlist name specified
	{
		dwReturnCode=PrintAllFilterData(hPolicyStorage,pszFlistName,bVerbose,bTable,bResolveDNS,bWide);
		if(dwReturnCode == ERROR_OUTOFMEMORY)
		{
			PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
			dwRet= ERROR_SUCCESS;
			BAIL_OUT;
		}
		dwRet= ERROR_SUCCESS;
	}
	else if (pszRuleName) // if rule name specified, print the FL attached to the rule
	{
		dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);
		if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
			dwRet= ERROR_SUCCESS;
			BAIL_OUT;
		}
		for (j = 0; j <  dwNumPolicies; j++)
		{
			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[j], &pPolicy);
			if (dwReturnCode != ERROR_SUCCESS)
			{
				dwRet = dwReturnCode;
				BAIL_OUT;
			}

			dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
						  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));
			if (dwReturnCode == ERROR_SUCCESS)
			{
				DWORD k;
				for (k = 0; k <  pPolicy->dwNumNFACount; k++)
				{
					if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[k]->FilterIdentifier), &RpcStat))
					{
						dwReturnCode = IPSecGetFilterData(hPolicyStorage,	pPolicy->ppIpsecNFAData[k]->FilterIdentifier,&(pPolicy->ppIpsecNFAData[k]->pIpsecFilterData));
						if(dwReturnCode != ERROR_SUCCESS)
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_4,pPolicy->pszIpsecName);
					}
					if(dwReturnCode != ERROR_SUCCESS)	break;
				}
			}

			if(dwReturnCode == ERROR_SUCCESS)
				for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
					if ((pPolicy->ppIpsecNFAData[n]->pszIpsecName!=NULL)&&(pszRuleName!=NULL)&&(_tcscmp(pPolicy->ppIpsecNFAData[n]->pszIpsecName,pszRuleName)==0))
					{
						bRuleExists=TRUE;
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_FILTERLIST_POL_NAME_STR,pPolicy->pszIpsecName);
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_FILTERLIST_RULE_NAME_STR,pPolicy->ppIpsecNFAData[n]->pszIpsecName);
						if(pPolicy->ppIpsecNFAData[n]->pIpsecFilterData)
						{
							if(bTable)   // table output
							{
								if(!bVerbose)  // non verbose
								{
									PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_NONVERB_TITLE);
									PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_NONVERB_UNDERLINE);
								}
								PrintFilterDataTable(pPolicy->ppIpsecNFAData[n]->pIpsecFilterData,bVerbose,bWide);
							}
							else
							{ // else list output
								dwReturnCode = PrintFilterDataList(pPolicy->ppIpsecNFAData[n]->pIpsecFilterData,bVerbose,bResolveDNS,bWide);
								if(dwReturnCode == ERROR_OUTOFMEMORY)
								{
									PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
									dwRet=ERROR_SUCCESS;
									BAIL_OUT;
								}
							}
						}
					}
			if (pPolicy)   IPSecFreePolicyData(pPolicy);
			if(dwReturnCode != ERROR_SUCCESS)	break;
		}

		if(!bRuleExists && pszRuleName && (dwReturnCode == ERROR_SUCCESS))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_FILTERLIST_3,pszRuleName);
		}

		if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
		{
			IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
		}

		dwRet=ERROR_SUCCESS;
	}
	ClosePolicyStore(hPolicyStorage);
error:
   	if(pszMachineName) delete [] pszMachineName;
	if(pszRuleName)  delete [] pszRuleName;
	if(pszFlistName)  delete [] pszFlistName;
	return dwRet;
}

///////////////////////////////////////////////////////////////////
//Function: HandleStaticShowFilterActions()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Show FilterActions "
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticShowFilterActions(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	BOOL bVerbose =FALSE,bRuleExists=FALSE,bWide=FALSE;
	BOOL bAllFa=FALSE,bTitlePrinted=FALSE,bTable=FALSE;
	LPTSTR pszFactName=NULL,pszRuleName=NULL,pszMachineName=NULL;
	DWORD dwLocation = 0,dwRet = ERROR_SHOW_USAGE,dwNumPolicies = 0,dwCount = 0 , j = 0;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	HANDLE hPolicyStorage = NULL;
	RPC_STATUS  RpcStat =RPC_S_OK;
	DWORD  dwReturnCode   = ERROR_SUCCESS , dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticShowFilterActions[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_RULE,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_VERBOSE,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_FORMAT,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_WIDE,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokStaticShowFilterActions[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 		},
		{ CMD_TOKEN_STR_RULE,		CMD_TOKEN_RULE 		},
		{ CMD_TOKEN_STR_VERBOSE,	CMD_TOKEN_VERBOSE	},
		{ CMD_TOKEN_STR_FORMAT,		CMD_TOKEN_FORMAT	},
		{ CMD_TOKEN_STR_WIDE,		CMD_TOKEN_WIDE		}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticShowFilterActions;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticShowFilterActions);

	parser.ValidCmd   = vcmdStaticShowFilterActions;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticShowFilterActions);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// user input filling in to local variables

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticShowFilterActions[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszFactName=new _TCHAR[dwStrLength+1];
						if(pszFactName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszFactName,(LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_RULE		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszRuleName=new _TCHAR[dwStrLength+1];
						if(pszRuleName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszRuleName,(LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_VERBOSE 	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bVerbose= *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_ALL		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bAllFa= *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_FORMAT	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bTable = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_WIDE		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bWide = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			default					:
					break;
		}
	}

	CleanUp(); //Cleans up the Parser output data structures

	dwReturnCode = CopyStorageInfo(&pszMachineName,dwLocation);

	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);

	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if (!pszRuleName && (bAllFa|| pszFactName))  // if all or filteraction name specified
	{
		dwReturnCode=PrintAllFilterActionData(hPolicyStorage,pszFactName,bVerbose,bTable,bWide);
		dwRet=dwReturnCode;
	}
	else if (pszRuleName)  // if rule name specified
	{
		dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

		if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
			dwRet= ERROR_SUCCESS;
			BAIL_OUT;
		}
		for (j = 0; j <  dwNumPolicies; j++)
		{
			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[j], &pPolicy);
			if (dwReturnCode != ERROR_SUCCESS)
			{
				dwRet = dwReturnCode;
				BAIL_OUT;
			}
			dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
								  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

			if (dwReturnCode == ERROR_SUCCESS)
			{
				DWORD k;
				for (k = 0; k <  pPolicy->dwNumNFACount; k++)
				{
					if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[k]->NegPolIdentifier), &RpcStat))
					{
						IPSecGetNegPolData(hPolicyStorage, pPolicy->ppIpsecNFAData[k]->NegPolIdentifier,&(pPolicy->ppIpsecNFAData[k]->pIpsecNegPolData));
						if(dwReturnCode != ERROR_SUCCESS)
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_3,pPolicy->pszIpsecName);
					}
					if (dwReturnCode != ERROR_SUCCESS) break;
				}
			}

			if(dwReturnCode == ERROR_SUCCESS)
				for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
					if ((pPolicy->ppIpsecNFAData[n]->pszIpsecName!=NULL)&&(pszRuleName!=NULL)&&(_tcscmp(pPolicy->ppIpsecNFAData[n]->pszIpsecName,pszRuleName)==0))
					{
						bRuleExists=TRUE;
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_FILTERLIST_POL_NAME_STR,pPolicy->pszIpsecName);
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_FILTERLIST_RULE_NAME_STR,pPolicy->ppIpsecNFAData[n]->pszIpsecName);
						if(pPolicy->ppIpsecNFAData[n]->pIpsecNegPolData)
						{
							if(bTable)
							{
								if(!bVerbose && !bTitlePrinted)
								{
									PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_NONVERB_TITLE);
									PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_NONVERB_UNDERLINE);
									bTitlePrinted=TRUE;
								}
								//call the function printing in table format
								PrintNegPolDataTable(pPolicy->ppIpsecNFAData[n]->pIpsecNegPolData,bVerbose,bWide);
							}
							else
							{
								//call the function printing in list format
								PrintNegPolDataList(pPolicy->ppIpsecNFAData[n]->pIpsecNegPolData,bVerbose,bWide);
							}
						}

					}
			if (pPolicy)   IPSecFreePolicyData(pPolicy);


			if (dwReturnCode != ERROR_SUCCESS) break;
		}
		// if rule does not exists print error
		if(!bRuleExists && pszRuleName && (dwReturnCode == ERROR_SUCCESS))
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_FILTERLIST_3,pszRuleName);

		if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
		{
			IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
		}

		dwRet=dwReturnCode;

	}
	ClosePolicyStore(hPolicyStorage);

error:
	if (pszMachineName) delete [] pszMachineName;
	if (pszRuleName) delete [] pszRuleName;
	if (pszFactName) delete [] pszFactName;

	return dwRet;
}

///////////////////////////////////////////////////////////////
//
//Function: HandleStaticShowRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//    OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Show Rule "
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticShowRule(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	BOOL bVerbose =FALSE,bAll=FALSE,bExists=FALSE,bPrintDefaultRule=FALSE;
	BOOL bRuleExists=FALSE,bTitlePrinted=FALSE,bTypeSpecified=FALSE,bWide=FALSE;
	BOOL bTunnelSpecified=FALSE,bTransportSpecified=FALSE,bTable=FALSE;
	LPTSTR pszPolicyName=NULL,pszRuleName=NULL,pszMachineName=NULL;
	DWORD dwLocation = 0,dwNumPolicies = 0,dwRuleId=0,dwCount = 0;
	DWORD dwTunnelRules=0,dwTransportRules=0,i=0,dwRet = ERROR_SHOW_USAGE;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	HANDLE hPolicyStorage = NULL;
	RPC_STATUS     RpcStat =RPC_S_OK;
	_TCHAR pszGUIDStr[BUFFER_SIZE]={0};
	DWORD   dwReturnCode   = ERROR_SUCCESS , dwStrLength = 0;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticShowRule[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ID,			NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_ALL,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_DEFRESPONSE,NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_POLICY,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_TYPE,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_VERBOSE,	NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_FORMAT,		NS_REQ_ZERO,	FALSE },
		{ CMD_TOKEN_STR_WIDE,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokStaticShowRule[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME	 		},
		{ CMD_TOKEN_STR_ID,			CMD_TOKEN_ID 			},
		{ CMD_TOKEN_STR_ALL,		CMD_TOKEN_ALL 			},
		{ CMD_TOKEN_STR_DEFRESPONSE,CMD_TOKEN_DEFRESPONSE	},
		{ CMD_TOKEN_STR_POLICY,		CMD_TOKEN_POLICY		},
		{ CMD_TOKEN_STR_TYPE,		CMD_TOKEN_TYPE			},
		{ CMD_TOKEN_STR_VERBOSE,	CMD_TOKEN_VERBOSE		},
		{ CMD_TOKEN_STR_FORMAT,		CMD_TOKEN_FORMAT		},
		{ CMD_TOKEN_STR_WIDE,		CMD_TOKEN_WIDE			}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 3)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticShowRule;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticShowRule);

	parser.ValidCmd   = vcmdStaticShowRule;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticShowRule);

	dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

	if(dwRet != ERROR_SUCCESS)
	{
		CleanUp();
		if (dwRet==RETURN_NO_ERROR)
		{
			dwRet = ERROR_SUCCESS;
		}
		BAIL_OUT;
	}

	// get the user input

	for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
	{
		switch(vtokStaticShowRule[parser.Cmd[dwCount].dwCmdToken].dwValue)
		{
			case CMD_TOKEN_NAME		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszRuleName=new _TCHAR[dwStrLength+1];
						if(pszRuleName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszRuleName,(LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_POLICY	:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

						pszPolicyName=new _TCHAR[dwStrLength+1];
						if(pszPolicyName==NULL)
						{
							PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
							dwRet=ERROR_SUCCESS;
							BAIL_OUT;
						}
						_tcsncpy(pszPolicyName,(LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
					}
					break;
			case CMD_TOKEN_ID		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						dwRuleId= *(DWORD *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_VERBOSE 	:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						bVerbose= *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_ALL		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						bAll    = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_DEFRESPONSE :
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						bPrintDefaultRule    = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_FORMAT	:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						bTable = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			case CMD_TOKEN_TYPE		:
					if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
					{
						bTypeSpecified=TRUE;
						if(*(DWORD *)parser.Cmd[dwCount].pArg==2)
							bTunnelSpecified=TRUE;
						else
							bTransportSpecified=TRUE;
					}
					break;
			case CMD_TOKEN_WIDE		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bWide = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
			default					:
					break;
		}
	}

	CleanUp(); //Cleans up the Parser output data structures

	if(bPrintDefaultRule)  // if default rule is asked, deal it accordingly
	{
		PrintDefaultRule(bVerbose,bTable,pszPolicyName,bWide);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}
	if(!bAll && bTypeSpecified)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SET_STATIC_SHOW_RULE_TYPE);
		dwRet = ERROR_SUCCESS;
		BAIL_OUT;
	}
	dwReturnCode = CopyStorageInfo(&pszMachineName,dwLocation);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	if (!pszPolicyName)  // if no policyname , bail out
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_RULE_NO_POL_NAME);
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
		dwRet= ERROR_SUCCESS;
		BAIL_OUT;
	}

	// get the relevant rule data structures

	for (i = 0; i <  dwNumPolicies; i++)
	{
		if ((pszPolicyName!=NULL)&&( _tcscmp(ppPolicyEnum[i]->pszIpsecName, pszPolicyName) == 0))
		{
			if (wcscmp(ppPolicyEnum[i]->pszIpsecName, pszPolicyName) == 0)
				   bExists=TRUE;

			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
			if (dwReturnCode == ERROR_SUCCESS)
			{
				dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
											  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

				if (dwReturnCode == ERROR_SUCCESS)
				{
					DWORD j;
					for (j = 0; j <  pPolicy->dwNumNFACount; j++)
					{
						if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->NegPolIdentifier), &RpcStat))
						{
							dwReturnCode =  IPSecGetNegPolData(hPolicyStorage, pPolicy->ppIpsecNFAData[j]->NegPolIdentifier, &(pPolicy->ppIpsecNFAData[j]->pIpsecNegPolData));
							if (dwReturnCode != ERROR_SUCCESS)
							{
								PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_3,pPolicy->pszIpsecName);
							}
						}
						if (dwReturnCode == ERROR_SUCCESS)
							if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->FilterIdentifier), &RpcStat))
							{
								dwReturnCode =  IPSecGetFilterData(hPolicyStorage,	pPolicy->ppIpsecNFAData[j]->FilterIdentifier,&(pPolicy->ppIpsecNFAData[j]->pIpsecFilterData));
								if (dwReturnCode != ERROR_SUCCESS)
								{
									PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_4,pPolicy->pszIpsecName);
								}
							}
						if (dwReturnCode != ERROR_SUCCESS) break;
					}
				}
				if (dwReturnCode == ERROR_SUCCESS)
				{
					for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
					{
						if(pPolicy->ppIpsecNFAData[n] )
							if( pPolicy->ppIpsecNFAData[n]->dwTunnelFlags !=0)
								dwTunnelRules++;
							else
								dwTransportRules++;
					}
				}
				if( dwReturnCode == ERROR_SUCCESS  && !bTypeSpecified && !bAll )  // printing a specific rule
				{
					for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
					{
						if (((pPolicy->ppIpsecNFAData[n]->pszIpsecName!=NULL)&&(pszRuleName!=NULL)&&(_tcscmp(pPolicy->ppIpsecNFAData[n]->pszIpsecName,pszRuleName)==0))||((dwRuleId-1)==n))
						{
							bRuleExists=TRUE;
							if(!bTitlePrinted)
							{
								if(bTable)  // if table format requested
								{
									PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_FILTERLIST_POL_NAME_STR,pPolicy->pszIpsecName);
								}
								else
								{
									PrintMessageFromModule(g_hModule,SHW_STATIC_FILTERLIST_POL_NAME,pPolicy->pszIpsecName);
								}
								if (bVerbose)
								{
									PrintStorageInfoList(FALSE);
								}
							}
							bTitlePrinted=TRUE;
							if(pPolicy->ppIpsecNFAData[n])
							{
								i=StringFromGUID2(pPolicy->ppIpsecNFAData[n]->NFAIdentifier,pszGUIDStr,BUFFER_SIZE);
								if(bTable)
								{
									if(!bVerbose)  // nonverbose
									{
										PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TRANS_NONVERB_TITLE);
										PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TRANS_NONVERB_UNDERLINE);
									}
									else  // print ID & GUID
									{
										if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
											PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_RULE_ID_GUID,n+1,pszGUIDStr);
									}
									PrintRuleTable(pPolicy->ppIpsecNFAData[n],bVerbose,bWide);
								}
								else
								{
									if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
										PrintMessageFromModule(g_hModule,SHW_STATIC_RULE_RULE_ID_GUID,n+1,pszGUIDStr);
									PrintRuleList(pPolicy->ppIpsecNFAData[n],bVerbose,bWide);
								}
							}
						}
					}
				}
				if((dwReturnCode == ERROR_SUCCESS) && (bAll ||bTypeSpecified))
				{
					if(bAll && !bTypeSpecified)  // if all specified
					{
						bTransportSpecified=TRUE;
						bTunnelSpecified=TRUE;
					}
					if((bTunnelSpecified && dwTunnelRules) ||(bTransportSpecified && dwTransportRules ))
					{
						if(bTable && pPolicy->pszIpsecName)
							PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_FILTERLIST_POL_NAME_STR,pPolicy->pszIpsecName);
						else if(pPolicy->pszIpsecName)
							PrintMessageFromModule(g_hModule,SHW_STATIC_FILTERLIST_POL_NAME,pPolicy->pszIpsecName);
						if (bVerbose && !bTable)
						{
							PrintStorageInfoList(FALSE);
						}
						else if (bVerbose && bTable)
						{
							PrintStorageInfoTable();
						}
					}

					if(dwTransportRules && bTransportSpecified)  // if transport type rules were asked
					{
						if(bTable)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TR_RULE_COUNT,dwTransportRules);
						}
						else  // list output
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_TRANS_COUNT,dwTransportRules);
						}
						if(!bVerbose && bTable)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TRANS_NONVERB_TITLE);
							PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TRANS_NONVERB_UNDERLINE);
						}
						for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
						{
							if(pPolicy->ppIpsecNFAData[n]->dwTunnelFlags==0)
							{
								i=StringFromGUID2(pPolicy->ppIpsecNFAData[n]->NFAIdentifier,pszGUIDStr,BUFFER_SIZE);
								if(bVerbose && bTable)
								{
									if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
										PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_RULE_ID_GUID,n+1,pszGUIDStr);
								}
								else if(!bTable)
								{
										if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
											PrintMessageFromModule(g_hModule,SHW_STATIC_RULE_RULE_ID_GUID,n+1,pszGUIDStr);
								}
								if(bTable)
									PrintRuleTable(pPolicy->ppIpsecNFAData[n],bVerbose,bWide);
								else
									PrintRuleList(pPolicy->ppIpsecNFAData[n],bVerbose,bWide);
							}
						}
					}

					if(dwTunnelRules && bTunnelSpecified)   // if tunnel type specified
					{
						if(bTable)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TN_RULE_COUNT,dwTunnelRules);
						}
						else
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_TUNNEL_COUNT,dwTunnelRules);
						}
						if(!bVerbose && bTable)   // in nonverbose , different title
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TUN_NONVERB_TITLE);
							PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TUN_NONVERB_UNDERLINE);
						}
						for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
						{
							if(pPolicy->ppIpsecNFAData[n]->dwTunnelFlags)
							{
								i=StringFromGUID2(pPolicy->ppIpsecNFAData[n]->NFAIdentifier,pszGUIDStr,BUFFER_SIZE);
								if(bVerbose && bTable)   // guid print
								{
									if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
										PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_RULE_ID_GUID,n+1,pszGUIDStr);
								}
								else if(!bTable)
								{
										if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
											PrintMessageFromModule(g_hModule,SHW_STATIC_RULE_RULE_ID_GUID,n+1,pszGUIDStr);
								}
								if(bTable)
									PrintRuleTable(pPolicy->ppIpsecNFAData[n],bVerbose,bWide);
								else
									PrintRuleList(pPolicy->ppIpsecNFAData[n],bVerbose,bWide);
							}
						}
					}
					if(dwTunnelRules==0 && bTunnelSpecified && bTypeSpecified)
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_RULE_RULE_ID_GUID,pPolicy->pszIpsecName);
					}
				}
				if(!bTypeSpecified && !bAll)  // if rule does not exists, throw error messages to the user
				{
					if(!bRuleExists && pszRuleName && (dwReturnCode == ERROR_SUCCESS))
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_FILTERLIST_3,pszRuleName);
					}
					else if((!bRuleExists) && (dwReturnCode == ERROR_SUCCESS))
					{
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_RULE_3,dwRuleId);
					}
				}
				if (pPolicy)	IPSecFreePolicyData(pPolicy);
			}
		}
		if (dwReturnCode != ERROR_SUCCESS) break;
	}
	if(!bExists && (dwReturnCode == ERROR_SUCCESS) )
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_LIST_POLICY_COUNT,pszPolicyName);
	}

	// clean up the data structures

	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
	dwRet=dwReturnCode;
	if(hPolicyStorage)
	{
		ClosePolicyStore(hPolicyStorage);
	}
error:
	if(pszPolicyName) delete [] pszPolicyName;
	if(pszRuleName) delete [] pszRuleName;
	if(pszMachineName) delete [] pszMachineName;

	return dwRet;
}

///////////////////////////////////////////////////////////////////////
//
//Function: HandleStaticShowAll()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//  OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Show All "
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticShowAll(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{
	BOOL bVerbose =TRUE,bAssigned=FALSE,bTable=FALSE,bWide=FALSE;
	LPTSTR pszMachineName=NULL;
	DWORD dwLocation = 0,dwNumPolicies = 0,dwRet = ERROR_SHOW_USAGE,dwCount=0,i=0;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	HANDLE hPolicyStorage = NULL;
	RPC_STATUS     RpcStat =RPC_S_OK;
	DWORD        dwReturnCode   = ERROR_SUCCESS;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	const TAG_TYPE vcmdStaticShowAll[] =
	{
		{ CMD_TOKEN_STR_FORMAT,		NS_REQ_ZERO,	  FALSE	},
		{ CMD_TOKEN_STR_WIDE,		NS_REQ_ZERO,	  FALSE	}
	};
	const TOKEN_VALUE vtokStaticShowAll[] =
	{
		{ CMD_TOKEN_STR_FORMAT,		CMD_TOKEN_FORMAT		},
		{ CMD_TOKEN_STR_WIDE,		CMD_TOKEN_WIDE			}
	};

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 2)
	{
		dwRet = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	parser.ValidTok   = vtokStaticShowAll;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticShowAll);

	parser.ValidCmd   = vcmdStaticShowAll;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticShowAll);

	// get the parsed user input data

	if(dwArgCount > 3)
	{
		dwRet = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

		if(dwRet != ERROR_SUCCESS)
		{
			CleanUp();
			if (dwRet==RETURN_NO_ERROR)
			{
				dwRet = ERROR_SUCCESS;
			}
			BAIL_OUT;
		}

		for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
		{
			switch(vtokStaticShowAll[parser.Cmd[dwCount].dwCmdToken].dwValue)
			{
				case CMD_TOKEN_FORMAT	:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bTable = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
				case CMD_TOKEN_WIDE		:
					if (parser.Cmd[dwCount].dwStatus == VALID_TOKEN)
						bWide = *(BOOL *)parser.Cmd[dwCount].pArg;
					break;
				default					:
					break;
			}
		}
		CleanUp(); //Cleans up the Parser output data structures
	}

	dwReturnCode = CopyStorageInfo(&pszMachineName,dwLocation);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	// enum everything and prepare to show them to the user

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	if (dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		for (i = 0; i <  dwNumPolicies; i++)
		{
			bAssigned=FALSE;

			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
			if (dwReturnCode == ERROR_SUCCESS)
			{
				dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
																  , &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));
				 if (dwReturnCode == ERROR_SUCCESS)
				 {
					 DWORD j;
					 dwReturnCode=IPSecGetISAKMPData(hPolicyStorage, pPolicy->ISAKMPIdentifier, &(pPolicy->pIpsecISAKMPData));
					 if(dwReturnCode == ERROR_SUCCESS)
					 {
						 for (j = 0; j <  pPolicy->dwNumNFACount; j++)
						 {
							 if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->NegPolIdentifier), &RpcStat))
							 {
								 dwReturnCode =  IPSecGetNegPolData(hPolicyStorage, pPolicy->ppIpsecNFAData[j]->NegPolIdentifier, &(pPolicy->ppIpsecNFAData[j]->pIpsecNegPolData));
								 if (dwReturnCode != ERROR_SUCCESS)
								 {
									 PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_3,pPolicy->pszIpsecName);
								 }
							 }
							 if (dwReturnCode == ERROR_SUCCESS)
								if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->FilterIdentifier), &RpcStat))
								{
									dwReturnCode =  IPSecGetFilterData(hPolicyStorage,	pPolicy->ppIpsecNFAData[j]->FilterIdentifier,&(pPolicy->ppIpsecNFAData[j]->pIpsecFilterData));
									if (dwReturnCode != ERROR_SUCCESS)
									{
										PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_4,pPolicy->pszIpsecName);
									}
								}
							 if(dwReturnCode != ERROR_SUCCESS) break;
						 }

						 if(dwReturnCode == ERROR_SUCCESS)
						 {
							 if(g_StorageLocation.dwLocation==IPSEC_REGISTRY_PROVIDER)
								dwReturnCode=IsAssigned(pPolicy,hPolicyStorage,bAssigned);
							 if ((dwReturnCode == ERROR_SUCCESS)||(dwReturnCode == ERROR_FILE_NOT_FOUND))
							 {
								 // show them in requested format

								 if(bTable)
								 {
									PrintPolicyTable(pPolicy,bVerbose,bAssigned,bWide);
								 }
								 else
								 {
									PrintPolicyList(pPolicy,bVerbose,bAssigned,bWide);
								 }
							 }
						 }
					 }
					 else
					 {
						PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_5,pPolicy->pszIpsecName);
					 }
				}
				if(pPolicy)	IPSecFreePolicyData(pPolicy);
			}
			if((dwReturnCode != ERROR_SUCCESS)&&(dwReturnCode !=ERROR_FILE_NOT_FOUND)) break;
		}

		if(bTable)
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_POLICY_COUNT,dwNumPolicies);
		else
			PrintMessageFromModule(g_hModule,SHW_STATIC_LIST_POLICY_COUNT,dwNumPolicies);

		if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
		{
			IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
		}

	}
	else
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
		dwRet= ERROR_SUCCESS;
	}

	// now it is time to show the standalone filter actions

	PrintStandAloneFAData(hPolicyStorage,bVerbose,bTable,bWide);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}
	// now it is time to show the standalone filter lists

	dwReturnCode = PrintStandAloneFLData(hPolicyStorage,bVerbose,bTable,bWide);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	ClosePolicyStore(hPolicyStorage);
	dwRet=ERROR_SUCCESS;
	if (pszMachineName) delete [] pszMachineName;

error:
	return dwRet;
}

//////////////////////////////////////////////////////////////////
//
//Function: HandleStaticShowGPOAssignedPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN      LPCWSTR         pwszMachine,
//	IN OUT  LPWSTR          *ppwcArguments,
//	IN      DWORD           dwCurrentIndex,
//	IN      DWORD           dwArgCount,
//	IN      DWORD           dwFlags,
//	IN      LPCVOID         pvData,
//    OUT     BOOL            *pbDone
//
//Return: DWORD
//
//Description:
//	Implementation for the command " Show AssignedPolicy "
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticShowGPOAssignedPolicy(
    IN      LPCWSTR         pwszMachine,
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      DWORD           dwFlags,
    IN      LPCVOID         pvData,
    OUT     BOOL            *pbDone
    )
{

	LPTSTR pszMachineName = NULL,pszGPOName = NULL;
	BOOL bGPONameSpecified=FALSE;
	DWORD dwReturn=ERROR_SHOW_USAGE,dwCount=0,dwLocation;
	DWORD MaxStringLen=0,dwStrLength = 0;
	POLICY_INFO  m_PolicyInfo;
	PARSER_PKT parser;
	ZeroMemory(&parser, sizeof(parser));

	HRESULT hr = S_OK;

	const TAG_TYPE vcmdStaticShowGPOAssignedPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		NS_REQ_ZERO,	FALSE }
	};

	const TOKEN_VALUE vtokStaticShowGPOAssignedPolicy[] =
	{
		{ CMD_TOKEN_STR_NAME,		CMD_TOKEN_NAME 		}
	};

	parser.ValidTok   = vtokStaticShowGPOAssignedPolicy;
	parser.MaxTok     = SIZEOF_TOKEN_VALUE(vtokStaticShowGPOAssignedPolicy);

	parser.ValidCmd   = vcmdStaticShowGPOAssignedPolicy;
	parser.MaxCmd     = SIZEOF_TAG_TYPE(vcmdStaticShowGPOAssignedPolicy);

	//if the user asked for usage, delegate the responsibility to netsh

	if(dwArgCount <= 2)
	{
		dwReturn = ERROR_SHOW_USAGE;
		BAIL_OUT;
	}

	PGPO pGPO=new GPO;

	if(pGPO==NULL)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturn = ERROR_SUCCESS;
		BAIL_OUT;
	}

	memset(pGPO,0,sizeof(GPO));

	memset(&m_PolicyInfo,0,sizeof(POLICY_INFO));

	m_PolicyInfo.dwLocation=IPSEC_REGISTRY_PROVIDER;

	if(dwArgCount > 3)
	{
		dwReturn = Parser(pwszMachine,ppwcArguments,dwCurrentIndex,dwArgCount,&parser);

		if(dwReturn != ERROR_SUCCESS)
		{
			CleanUp();
			if (dwReturn==RETURN_NO_ERROR)
			{
				dwReturn = ERROR_SUCCESS;
			}
			BAIL_OUT;
		}

		for(dwCount=0;dwCount<parser.MaxTok;dwCount++)
		{
			switch(vtokStaticShowGPOAssignedPolicy[parser.Cmd[dwCount].dwCmdToken].dwValue)
			{
				case CMD_TOKEN_NAME		:
						if ((parser.Cmd[dwCount].dwStatus == VALID_TOKEN)&&(parser.Cmd[dwCount].pArg))
						{
							dwStrLength = _tcslen((LPTSTR )parser.Cmd[dwCount].pArg);

							pszGPOName = new _TCHAR[dwStrLength+1];
							if(pszGPOName==NULL)
							{
								PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
								dwReturn = ERROR_SUCCESS;
								BAIL_OUT;
							}
							_tcsncpy(pszGPOName, (LPTSTR )parser.Cmd[dwCount].pArg,dwStrLength+1);
							bGPONameSpecified=TRUE;
						}
						break;
				default					:
						break;
			}
		}

		CleanUp();
	}

	// if no gpo name specified, show the local machine's gpo policy

	if(!bGPONameSpecified && g_StorageLocation.dwLocation == IPSEC_REGISTRY_PROVIDER)
	{
		dwReturn = ShowLocalGpoPolicy(m_PolicyInfo, pGPO);
	}
	else if (bGPONameSpecified)  // if gpo name specified, deal it separately
	{
		if (g_StorageLocation.dwLocation != IPSEC_DIRECTORY_PROVIDER)
		{
			PrintErrorMessage(IPSEC_ERR, 0, ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE5);
			dwReturn = ERROR_SUCCESS;
			BAIL_OUT;
		}
		hr = CoInitialize(NULL);

	   	if (FAILED(hr))
	   	{
			BAIL_OUT;
	   	}

		ShowAssignedGpoPolicy(pszGPOName,pGPO);
		dwReturn=ERROR_SUCCESS;
	}
	else if(!bGPONameSpecified && g_StorageLocation.dwLocation != IPSEC_REGISTRY_PROVIDER)
	{
		//if no gpo, and store is not of type registry, flag error
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE4);
		dwReturn=ERROR_SUCCESS;
	}

error:
	if(pGPO)  // clean up the GPO structure
	{
		if(pGPO->pszGPODisplayName) delete [] pGPO->pszGPODisplayName;
		if(pGPO->pszGPODNName) delete [] pGPO->pszGPODNName;
		if(pGPO->pszPolicyName) delete [] pGPO->pszPolicyName;
		if(pGPO->pszLocalPolicyName) delete [] pGPO->pszLocalPolicyName;
		if(pGPO->pszPolicyDNName) delete [] pGPO->pszPolicyDNName;
		if(pGPO->pszDomainName) delete [] pGPO->pszDomainName;
		if(pGPO->pszDCName) delete [] pGPO->pszDCName;
		if(pGPO->pszOULink) delete [] pGPO->pszOULink;
		delete pGPO;
		pGPO = NULL;
	}
	return dwReturn;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Function		:	HandleStaticShowStore
//
//	Date of Creation: 	5-27-02
//
//	Parameters		:
//						IN 		LPCWSTR    pwszMachine,
//						IN OUT  LPWSTR     *ppwcArguments,
//						IN      DWORD      dwCurrentIndex,
//						IN      DWORD      dwArgCount,
//						IN      DWORD      dwFlags,
//						IN      LPCVOID    pvData,
//						OUT     BOOL       *pbDone
//	Return			: 	DWORD
//
//	Description		:  Netshell static handle for show store
//
//	Revision History:
//
//  Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
HandleStaticShowStore(
				IN 		LPCWSTR    pwszMachine,
				IN OUT  LPWSTR     *ppwcArguments,
				IN      DWORD      dwCurrentIndex,
				IN      DWORD      dwArgCount,
				IN      DWORD      dwFlags,
				IN      LPCVOID    pvData,
				OUT     BOOL       *pbDone
    			)
{
	DWORD dwReturn = ERROR_SUCCESS;

	if(dwArgCount != 3)
	{
		PrintMessageFromModule(g_hModule, ERR_INVALID_NUM_ARGS, 3);
		BAIL_OUT;
	}

    if (g_StorageLocation.dwLocation == IPSEC_REGISTRY_PROVIDER)
    {
        if (wcscmp(g_StorageLocation.pszMachineName, L"") != 0)
        {
            PrintMessageFromModule(
                g_hModule,
                SHW_STATIC_POLICY_STORE_LM_NAME_STR, 
                g_StorageLocation.pszMachineName);
        }
        else
        {
            PrintMessageFromModule(
                g_hModule,
                SHW_STATIC_POLICY_STORE_LM_STR);
        }
    }
    else if (g_StorageLocation.dwLocation == IPSEC_PERSISTENT_PROVIDER)
    {
        if (wcscmp(g_StorageLocation.pszMachineName, L"") != 0)
        {
            PrintMessageFromModule(
                g_hModule,
                SHW_STATIC_POLICY_STORE_LM_NAME_STRP,
                g_StorageLocation.pszMachineName);
        }
        else
        {
            PrintMessageFromModule(
                g_hModule,
                SHW_STATIC_POLICY_STORE_LM_STRP);
        }
    }
    else if (g_StorageLocation.dwLocation == IPSEC_DIRECTORY_PROVIDER)
    {
        if (wcscmp(g_StorageLocation.pszDomainName, L"") != 0)
        {
            PrintMessageFromModule(
                g_hModule,
                SHW_STATIC_POLICY_STORE_LD_NAME_STR,
                g_StorageLocation.pszDomainName);
        }
        else
        {
            PrintMessageFromModule(
                g_hModule,
                SHW_STATIC_POLICY_STORE_LD_STR);
        }
    }

error:

    return dwReturn;
}
////////////////////////////////////////////////////////////////////////
//
//Function: GetLocalPolicyName()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN OUT PGPO pGPO
//
//Return: DWORD
//
//Description:
//	Gets the local policy name
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////

DWORD
GetLocalPolicyName(
	IN OUT PGPO pGPO
	)
{
	LPTSTR pszMachineName=NULL;
	DWORD dwReturn = ERROR_SUCCESS , dwStrLength = 0;
	HANDLE hPolicyStorage=NULL;
	PIPSEC_POLICY_DATA pActive=NULL;
	DWORD dwReturnCode =ERROR_SUCCESS;

	// get the local active policy name

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);

	if (dwReturnCode == ERROR_SUCCESS)
	{
		dwReturnCode = IPSecGetAssignedPolicyData(hPolicyStorage, &pActive);

		if ((dwReturnCode == ERROR_SUCCESS)&& pActive && pActive->pszIpsecName)
		{
			dwStrLength = _tcslen(pActive->pszIpsecName);

			pGPO->pszLocalPolicyName= new _TCHAR[dwStrLength+1];

			if(pGPO->pszLocalPolicyName==NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
			}
			if(dwReturn == ERROR_SUCCESS)
			{
				_tcsncpy(pGPO->pszLocalPolicyName,pActive->pszIpsecName,dwStrLength+1);
			}
			if (pActive)   IPSecFreePolicyData(pActive);
		}
		ClosePolicyStore(hPolicyStorage);
	}
	return dwReturn;
}

////////////////////////////////////////////////////////////////////////
//Function: PrintDefaultRule()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN BOOL bVerbose,
//	IN BOOL bTable,
//	IN BOOL bAll,
//	IN LPTSTR pszPolicyName
//
//Return: DWORD
//
//Description:
//	This function prints the default rule details
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////

DWORD
PrintDefaultRule(
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN LPTSTR pszPolicyName,
	IN BOOL bWide
	)
{
	BOOL bExists=FALSE;
	LPTSTR pszMachineName=NULL;
	DWORD dwLocation = 0,dwNumPolicies = 0,dwRet = ERROR_SHOW_USAGE , i =0;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	HANDLE hPolicyStorage = NULL;
	RPC_STATUS     RpcStat =RPC_S_OK;
	DWORD        dwReturnCode   = ERROR_SUCCESS;

	dwReturnCode = CopyStorageInfo(&pszMachineName,dwLocation);
	if(dwReturnCode == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwRet=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	// if no policy exists in store, bail out

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
		dwRet= ERROR_SUCCESS;
		BAIL_OUT;
	}
	for (i = 0; i <  dwNumPolicies; i++)
	{
		if ( pszPolicyName &&(wcscmp(ppPolicyEnum[i]->pszIpsecName, pszPolicyName) == 0))
		{
			if ((pszPolicyName)&&(ppPolicyEnum[i]->pszIpsecName)&&(wcscmp(ppPolicyEnum[i]->pszIpsecName, pszPolicyName) == 0))
				   bExists=TRUE;

			dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
			 if (dwReturnCode == ERROR_SUCCESS)
			 {
				 dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier
												, &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));
				 if (dwReturnCode == ERROR_SUCCESS)
				 {
					 DWORD j;
					 for (j = 0; j <  pPolicy->dwNumNFACount; j++)
					 {
						 if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->NegPolIdentifier), &RpcStat))
						 {
							 dwReturnCode =  IPSecGetNegPolData(hPolicyStorage, pPolicy->ppIpsecNFAData[j]->NegPolIdentifier, &(pPolicy->ppIpsecNFAData[j]->pIpsecNegPolData));
							 if (dwReturnCode != ERROR_SUCCESS)
							 {
								 PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_3,pPolicy->pszIpsecName);
							 }
						 }
						 if(dwReturnCode == ERROR_SUCCESS)
							 if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->FilterIdentifier), &RpcStat))
							 {
								 dwReturnCode =  IPSecGetFilterData(hPolicyStorage,	pPolicy->ppIpsecNFAData[j]->FilterIdentifier,&(pPolicy->ppIpsecNFAData[j]->pIpsecFilterData));
								 if (dwReturnCode != ERROR_SUCCESS)
								 {
									PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_4,pPolicy->pszIpsecName);
								 }
							 }
						 if (dwReturnCode != ERROR_SUCCESS) break;
					 }
				 }

				 if (dwReturnCode == ERROR_SUCCESS)
				 {
					for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
					{
						if (pPolicy->ppIpsecNFAData[n]->pIpsecNegPolData->NegPolType==GUID_NEGOTIATION_TYPE_DEFAULT)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_FILTERLIST_POL_NAME_STR,ppPolicyEnum[i]->pszIpsecName);
							// print the details in requested format either in table to in list format
							if(bTable)
							{
								if(!bVerbose)   // print in requested mode (verbose/nonverbose)
								{
									PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TRANS_NONVERB_TITLE);
									PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TRANS_NONVERB_UNDERLINE);
								}
								PrintRuleTable(pPolicy->ppIpsecNFAData[n],bVerbose,bWide);
							}
							else
							{
								PrintRuleList(pPolicy->ppIpsecNFAData[n],bVerbose,bWide);
							}
						}
					}
				}
				if (pPolicy) 	IPSecFreePolicyData(pPolicy);
			 }
		  }
		  if (dwReturnCode != ERROR_SUCCESS) break;
	 }

	if( !bExists  && (dwReturnCode == ERROR_SUCCESS) && pszPolicyName )
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_LIST_POLICY_COUNT,pszPolicyName);

	// free the data structures

	 if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	 {
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	 }
	dwRet = ERROR_SUCCESS;

	ClosePolicyStore(hPolicyStorage);

	if (pszMachineName) delete [] pszMachineName;
error:
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticshow.h ===
///////////////////////////////////////////////////////////////////////
//Header: staticshow.h

// Purpose: 	Defining structures and prototypes for statishow.cpp.

// Developers Name: surya

// History:

//   Date    		Author    	Comments
//   21th Aug 2001	surya		Initial Version.
//  <creation>  <author>

//   <modification> <author>  <comments, references to code sections,
//									in case of bug fixes>

///////////////////////////////////////////////////////////////////////

#ifndef _STATICSHOW_H_
#define _STATICSHOW_H_


const DWORD BUFFER_SIZE    	  =  2048;

const _TCHAR   LocalGPOName[] = _TEXT("Local Computer Policy");

//Filter DNS IDs

const DWORD FILTER_MYADDRESS  =  111;
const DWORD FILTER_ANYADDRESS =  112;
const DWORD FILTER_DNSADDRESS =  113;
const DWORD FILTER_IPADDRESS  =  114;
const DWORD FILTER_IPSUBNET   =  115;


typedef struct _FilterDNS {
	DWORD FilterSrcNameID;
	DWORD FilterDestNameID;
} FILTERDNS, *PFILTERDNS;


//Function Declarations


VOID
PrintIPAddr(
	IN DWORD Addr
	);

VOID
GetFilterDNSDetails(
	IN PIPSEC_FILTER_SPEC pFilterData,
	IN OUT PFILTERDNS pFilterDNS
	);


BOOL
CheckSoft(
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods
	);

DWORD
GetLocalPolicyName(
	IN OUT PGPO pGPO
	);

DWORD
PrintDefaultRule(
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN LPTSTR pszPolicyName,
	IN BOOL bWide
	);
#endif //_STATICSHOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticshowlist.h ===
/*********************************************************
Header: staticshowlist.h

* Purpose: 	Defining structures and prototypes for statiadd.cpp.

* Developers Name: surya

* History:

*   Date    		Author    	Comments
	21th Aug 2001	surya		Initial Version.
*  <creation>  <author>

*   <modification> <author>  <comments, references to code sections,
									in case of bug fixes>

*********************************************************/

#ifndef _STATICSHOWLIST_H_
#define _STATICSHOWLIST_H_

extern BOOL
IsDomainMember(
	IN LPTSTR pszMachine
	);

DWORD
PrintPolicyList(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN BOOL bVerb,
	IN BOOL bAssigned,
	IN BOOL bWide
	);

DWORD
PrintRuleList(
	IN PIPSEC_NFA_DATA pIpsecNFAData,
	IN BOOL bVerb,
	IN BOOL bWide
	);

VOID
PrintNegPolDataList(
	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
	IN BOOL bVerb,
	IN BOOL bWide
	);

VOID
PrintAlgoInfoList(
	IN PIPSEC_ALGO_INFO   Algos,
	IN DWORD dwNumAlgos
	);

VOID
PrintLifeTimeList(
	IN LIFETIME LifeTime
	);

VOID
PrintAuthMethodsList(
	IN PIPSEC_AUTH_METHOD pIpsecAuthData
	);

DWORD
PrintFilterDataList(
	IN PIPSEC_FILTER_DATA pIpsecFilterData,
	IN BOOL bVerb,
	IN BOOL bResolveDNS,
	IN BOOL bWide
	);

DWORD
PrintFilterSpecList(
	IN PIPSEC_FILTER_SPEC pIpsecFilterSpec,
	IN BOOL bResolveDNS,
	IN BOOL bWide
	);

DWORD
PrintResolveDNS(
	LPWSTR pszDNSName
	);

VOID
PrintProtocolNameList(
	DWORD dwProtocol
	);

VOID
PrintISAKMPDataList(
	IN PIPSEC_ISAKMP_DATA pIpsecISAKMPData
	);

VOID
PrintISAKAMPSecurityMethodsList(
	IN CRYPTO_BUNDLE SecurityMethods
	);

VOID
PrintGPOList(
	IN PGPO pGPO
	);

VOID
PrintIPAddrList(
	IN DWORD dwAddr
	);

DWORD
PrintStorageInfoList(
	IN BOOL bDeleteAll
	);

VOID
PrintIPAddrDNS(
	IN DWORD dwAddr
	);
#endif //_STATICSHOWLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticshowlist.cpp ===
////////////////////////////////////////////////////////////////////
// Module: Static/StaticShowList.cpp
//
// Purpose: 	Static Module Implementation.
//
// Developers Name: Surya
//
// History:
//
// Date    		Author    	Comments
// 10-8-2001	Surya		Initial Version. SCM Base line 1.0
//
////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern STORAGELOCATION g_StorageLocation;

////////////////////////////////////////////////////////////////////
//
//Function: PrintPolicyList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_POLICY_DATA pPolicy,
//	IN BOOL bVerb,
//	IN BOOL bAssigned,
//	IN BOOL bWide
//Return: DWORD
//
//Description:
//	This function prints out the Policy information.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

DWORD
PrintPolicyList(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN BOOL bVerb,
	IN BOOL bAssigned,
	IN BOOL bWide
	)
{
	_TCHAR pszGUIDStr[BUFFER_SIZE]={0};
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	DWORD i=0,k=0,dwReturn = ERROR_SUCCESS;
	BOOL bDsPolAssigned = FALSE;

	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);

	// print name

	if(pPolicy->pszIpsecName)
	{
		TruncateString(pPolicy->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_NAME_STR,pszStrTruncated);
	}
	// print desc
	if(pPolicy->pszDescription)
	{
		TruncateString(pPolicy->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_STR,pszStrTruncated);
	}
	else
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_NONE);
	}

	if (bVerb)   // storage info
	{
		dwReturn = PrintStorageInfoList(FALSE);
		if(dwReturn == ERROR_OUTOFMEMORY)
		{
			BAIL_OUT;
		}
	}

	//last modified time

	FormatTime((time_t)pPolicy->dwWhenChanged, pszStrTime);
	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_LASTMODIFIED,pszStrTime);

	if(bVerb)
	{
		i=StringFromGUID2(pPolicy->PolicyIdentifier,pszGUIDStr,BUFFER_SIZE);
		if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_GUID,pszGUIDStr);
		}
	}

	//whether the policy is active

	if(g_StorageLocation.dwLocation !=IPSEC_DIRECTORY_PROVIDER)
	{
		if(bAssigned)
		{
			if (
				ERROR_SUCCESS == IPSecIsDomainPolicyAssigned(&bDsPolAssigned) &&
				g_StorageLocation.dwLocation != IPSEC_PERSISTENT_PROVIDER &&
				bDsPolAssigned
				)
			{
		    	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_ASSIGNED_AD);
			}
		    else
		    {
		    	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_ASSIGNED_YES_STR);
			}
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_ASSIGNED_NO_STR);
		}
	}

	if(!bVerb)
	{
		if(pPolicy->pIpsecISAKMPData->ISAKMPPolicy.PfsIdentityRequired)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_MMPFS_YES_STR);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_MMPFS_NO_STR);
		}
	}


	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POLL_INTERVAL, (pPolicy->dwPollingInterval)/60);

	if (bVerb)   //verbose mode
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMP_MMLIFETIME_STR,(pPolicy->pIpsecISAKMPData->pSecurityMethods[0].Lifetime.Seconds)/60 ,pPolicy->pIpsecISAKMPData->pSecurityMethods[0].QuickModeLimit);

		if(pPolicy->pIpsecISAKMPData->ISAKMPPolicy.PfsIdentityRequired)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_MMPFS_YES_STR);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_MMPFS_NO_STR);
		}

		if(pPolicy->pIpsecISAKMPData)  // print the ISAKMP data structure details
		{
			PrintISAKMPDataList(pPolicy->pIpsecISAKMPData);
		}

		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_RULE_COUNT, pPolicy->dwNumNFACount);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_RULE_DETAILS_TITLE);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_RULE_DETAILS_UNDERLINE);

		//print rule data structures

		for (DWORD j=0;j<pPolicy->dwNumNFACount;j++)
		{
			if(pPolicy->ppIpsecNFAData[j])
			{
				k=StringFromGUID2(pPolicy->ppIpsecNFAData[j]->NFAIdentifier,pszGUIDStr,BUFFER_SIZE);
				if(k>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_RULE_RULE_ID_GUID,j+1,pszGUIDStr);
				}

				dwReturn = PrintRuleList(pPolicy->ppIpsecNFAData[j],bVerb,bWide);
				if(dwReturn == ERROR_OUTOFMEMORY)
				{
					BAIL_OUT;
				}
			}
		}
	}
error:

	return dwReturn;
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintRuleList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_NFA_DATA pIpsecNFAData,
//	IN BOOL bVerb,
//	IN BOOL bWide
//
//Return: DWORD
//
//Description:
//	This function prints out the Rule information.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

DWORD
PrintRuleList(
	IN PIPSEC_NFA_DATA pIpsecNFAData,
	IN BOOL bVerb,
	IN BOOL bWide
	)
{
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	DWORD dwReturn = ERROR_SUCCESS;

	if(pIpsecNFAData->pszIpsecName)
	{
		TruncateString(pIpsecNFAData->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_RULE_NAME_STR,pszStrTruncated);
	}
	else
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_RULE_NAME_NONE);
	}

	if(bVerb)
	{
		if(pIpsecNFAData->pszDescription)
		{
			TruncateString(pIpsecNFAData->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_STR,pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_NONE);
		}
	}

	//last modified time

	FormatTime((time_t)pIpsecNFAData->dwWhenChanged, pszStrTime);
	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_LASTMODIFIED,pszStrTime);

	if(pIpsecNFAData->dwActiveFlag)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_ACTIVATED_YES_STR);
	}
	else
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_ACTIVATED_NO_STR);
	}

	if(!bVerb)  //non verbose
	{
		if(pIpsecNFAData->pIpsecFilterData && pIpsecNFAData->pIpsecFilterData->pszIpsecName)
		{
			TruncateString(pIpsecNFAData->pIpsecFilterData->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_RULE_FL_NAME_STR,pszStrTruncated);
		}
		else
			PrintMessageFromModule(g_hModule,SHW_STATIC_RULE_FL_NAME_NONE);

		if(pIpsecNFAData->pIpsecNegPolData && pIpsecNFAData->pIpsecNegPolData->pszIpsecName)
		{
			TruncateString(pIpsecNFAData->pIpsecNegPolData->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_FA_NAME_STR,pszStrTruncated);
		}
		else
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_FA_NAME_NONE);
	}
	if(pIpsecNFAData->dwTunnelIpAddr!=0)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_TUNNEL_IP);
		PrintIPAddrList(pIpsecNFAData->dwTunnelIpAddr);
	}

	//interface type

	if(pIpsecNFAData->dwInterfaceType==(DWORD)PAS_INTERFACE_TYPE_ALL)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_CONN_ALL_STR);
	}
	else if(pIpsecNFAData->dwInterfaceType==(DWORD)PAS_INTERFACE_TYPE_LAN)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_CONN_LAN_STR);
	}
	else if(pIpsecNFAData->dwInterfaceType==(DWORD)PAS_INTERFACE_TYPE_DIALUP)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_CONN_DIALUP_STR);
	}
	else
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_CONN_NONE_STR);
	}

	//auth count

	if ( pIpsecNFAData->dwAuthMethodCount)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_AUTH_TITLE,pIpsecNFAData->dwAuthMethodCount);
	}
	for (DWORD j=0;j<(pIpsecNFAData->dwAuthMethodCount);j++)
	{
		// print auth methods details
		if(pIpsecNFAData->ppAuthMethods[j])
		{
			PrintAuthMethodsList(pIpsecNFAData->ppAuthMethods[j]);
		}
	}

	if(bVerb)
	{
		//print the filter data details
		if (pIpsecNFAData->pIpsecFilterData)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_FL_DETAILS_TITLE);
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_FL_DETAILS_UNDERLINE);
			if(pIpsecNFAData->pIpsecFilterData)
			{
				dwReturn = PrintFilterDataList(pIpsecNFAData->pIpsecFilterData,bVerb,FALSE,bWide);
				if(dwReturn == ERROR_OUTOFMEMORY)
				{
					BAIL_OUT;
				}
			}
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_NO_FL_FOR_DEF_RULE);
		}

		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_FA_DETAILS_TITLE);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTRULE_FA_TITLE_UNDERLINE);
		//print the filter action details
		if(pIpsecNFAData->pIpsecNegPolData)
		{
			PrintNegPolDataList(pIpsecNFAData->pIpsecNegPolData,bVerb,bWide);
		}
	}
error:
	return dwReturn;
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintNegPolDataList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
//	IN BOOL bVerb,
//	IN BOOL bWide
//
//Return: VOID
//
//Description:
//	This function prints out the Negotiation Policy information.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintNegPolDataList(
	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
	IN BOOL bVerb,
	IN BOOL bWide
	)
{

	BOOL bSoft=FALSE;
	_TCHAR pszGUIDStr[BUFFER_SIZE]={0};
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	DWORD i=0;

	if(pIpsecNegPolData)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);

		//print filteraction name

		if(pIpsecNegPolData->pszIpsecName)
		{
			TruncateString(pIpsecNegPolData->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_FA_NAME_STR,pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_FA_NAME_NONE);
		}

		if(pIpsecNegPolData->pszDescription)
		{
			TruncateString(pIpsecNegPolData->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_STR,pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_NONE);
		}

		if(bVerb)   //storage info
		{
			PrintStorageInfoList(FALSE);
		}

		//print action

		if (!(pIpsecNegPolData->NegPolType==GUID_NEGOTIATION_TYPE_DEFAULT))
		{
			if(pIpsecNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_ACTION_PERMIT);
			}
			else if(pIpsecNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_ACTION_BLOCK);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_ACTION_NEGOTIATE);
			}
		}

		for (DWORD cnt=0;cnt<pIpsecNegPolData->dwSecurityMethodCount;cnt++)
		{
			if (CheckSoft(pIpsecNegPolData->pIpsecSecurityMethods[cnt]))  { bSoft=TRUE; break;}
		}

		//soft association

		if(bSoft)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_SOFT_YES_STR);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_SOFT_NO_STR);
		}

		if(pIpsecNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_INPASS_YES_STR);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_INPASS_NO_STR);
		}

		if(bVerb)
		{
			if (pIpsecNegPolData->dwSecurityMethodCount )
			{
				if(pIpsecNegPolData->pIpsecSecurityMethods && pIpsecNegPolData->pIpsecSecurityMethods[0].PfsQMRequired)
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_QMPFS_YES_STR);
				else
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTNEGPOL_QMPFS_NO_STR);
			}
		}

		//last modified time

		FormatTime((time_t)pIpsecNegPolData->dwWhenChanged, pszStrTime);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_LASTMODIFIED,pszStrTime);

		//print guid

		i=StringFromGUID2(pIpsecNegPolData->NegPolIdentifier,pszGUIDStr,BUFFER_SIZE);
		if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_GUID,pszGUIDStr);

		if (bVerb)
		{
			//print security methods

			if (pIpsecNegPolData->dwSecurityMethodCount)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_SEC_MTHD_TITLE);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_ALGO_TITLE);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_ALGO_UNDERLINE);
			}
			for (DWORD cnt=0;cnt<pIpsecNegPolData->dwSecurityMethodCount;cnt++)
			{
				if(pIpsecNegPolData->pIpsecSecurityMethods)
				{
					PrintSecurityMethodsTable(pIpsecNegPolData->pIpsecSecurityMethods[cnt]);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintAuthMethodsList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_AUTH_METHOD pIpsecAuthData
//
//Return: VOID
//
//Description:
//	This function prints out Authentication details.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintAuthMethodsList(
	IN PIPSEC_AUTH_METHOD pIpsecAuthData
	)
{
	if(pIpsecAuthData)
	{
		PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMF_NEWLINE_TAB);

		if(pIpsecAuthData->dwAuthType==IKE_SSPI)  //kerb
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTAUTH_KERBEROS);
		}
		else if(pIpsecAuthData->dwAuthType==IKE_RSA_SIGNATURE && pIpsecAuthData->pszAuthMethod)
		{
			DisplayCertInfo(pIpsecAuthData->pszAuthMethod, pIpsecAuthData->dwAuthFlags);
		}
		else if (pIpsecAuthData->dwAuthType==IKE_PRESHARED_KEY && pIpsecAuthData->pszAuthMethod)
		{
			//preshared key
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTAUTH_PRE_STR,pIpsecAuthData->pszAuthMethod);
		}
		else
		{
			//none
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTAUTH_NONE_STR);
		}
	}
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintFilterDataList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_DATA pIpsecFilterData,
//	IN BOOL bVerb,
//	IN BOOL bResolveDNS,
//	IN BOOL bWide
//
//Return: DWORD
//
//Description:
//	This function prints out Filter list details.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

DWORD
PrintFilterDataList(
	IN PIPSEC_FILTER_DATA pIpsecFilterData,
	IN BOOL bVerb,
	IN BOOL bResolveDNS,
	IN BOOL bWide
	)
{
	_TCHAR pszGUIDStr[BUFFER_SIZE]={0};
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	DWORD i=0 , dwReturn = ERROR_SUCCESS;

	if (pIpsecFilterData)
	{
		//name
		if(pIpsecFilterData->pszIpsecName)
		{
			TruncateString(pIpsecFilterData->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_NAME_STR,pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_NAME_NONE);
		}
		//desc
		if(pIpsecFilterData->pszDescription)
		{
			TruncateString(pIpsecFilterData->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_STR,pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_NONE);
		}

		if(bVerb)   // storage info
		{
			PrintStorageInfoList(FALSE);
		}

		if(!bVerb)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FILTERS_COUNT,pIpsecFilterData->dwNumFilterSpecs);
		}
		//last modified
		FormatTime((time_t)pIpsecFilterData->dwWhenChanged, pszStrTime);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_LASTMODIFIED,pszStrTime);

		//print guid
		i=StringFromGUID2(pIpsecFilterData->FilterIdentifier,pszGUIDStr,BUFFER_SIZE);
		if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FL_GUID,pszGUIDStr);
		}

		if(bVerb)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FILTERS_COUNT,pIpsecFilterData->dwNumFilterSpecs);
		}

		if(bVerb)
		{
			//print filter specs
			if(pIpsecFilterData->dwNumFilterSpecs)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FILTERS_TITLE);
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTERDATA_FILTERS_TITLE_UNDERLINE);
			}
			for (DWORD k=0;k<pIpsecFilterData->dwNumFilterSpecs;k++)
			{
				dwReturn = PrintFilterSpecList(pIpsecFilterData->ppFilterSpecs[k],bResolveDNS,bWide);

				if(dwReturn == ERROR_OUTOFMEMORY)
				{
					BAIL_OUT;
				}
			}
		}
 	}
error:
 	return dwReturn;
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintFilterSpecList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_SPEC pIpsecFilterSpec,
//	IN BOOL bResolveDNS,
//	IN BOOL bWide
//
//Return: DWORD
//
//Description:
//	This function prints the Filter Spec details
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

DWORD
PrintFilterSpecList(
	IN PIPSEC_FILTER_SPEC pIpsecFilterSpec,
	IN BOOL bResolveDNS,
	IN BOOL bWide
	)
{
	DWORD dwReturn = ERROR_SUCCESS;
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	PFILTERDNS pFilterDNS= new FILTERDNS ;

	if(pFilterDNS==NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	GetFilterDNSDetails(pIpsecFilterSpec, pFilterDNS);

	if (pFilterDNS)
	{
		//desc
		if ( WcsCmp0(pIpsecFilterSpec->pszDescription,_TEXT(""))!=0)
		{
			TruncateString(pIpsecFilterSpec->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_STR, pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTPOLICY_POL_DESC_NONE);
		}
		//mirrored
		if(pIpsecFilterSpec->dwMirrorFlag)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_MIR_YES_STR);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_MIR_NO_STR);
		}
		//special server  and me
		if ((pFilterDNS->FilterSrcNameID==FILTER_MYADDRESS)&&(pIpsecFilterSpec->Filter.SrcAddr==0))
		{
			if((pIpsecFilterSpec->Filter.ExType == EXT_NORMAL)||((pIpsecFilterSpec->Filter.ExType & EXT_DEST)== EXT_DEST))
			{
				//me
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCIP_ME);
			}
			else if((pIpsecFilterSpec->Filter.ExType & EXT_DEST) != EXT_DEST)
			{
				if((pIpsecFilterSpec->Filter.ExType & EXT_DEFAULT_GATEWAY)==EXT_DEFAULT_GATEWAY)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCIP_DEFGATEWAY);
				}
				else if((pIpsecFilterSpec->Filter.ExType & EXT_DHCP_SERVER)==EXT_DHCP_SERVER)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCIP_DHCPSERVER);
				}
				else if((pIpsecFilterSpec->Filter.ExType & EXT_WINS_SERVER)== EXT_WINS_SERVER)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCIP_WINSSERVER);
				}
				else if((pIpsecFilterSpec->Filter.ExType & EXT_DNS_SERVER)==EXT_DNS_SERVER)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCIP_DNSSERVER);
				}
			}
		}

		else if ((pFilterDNS->FilterSrcNameID==FILTER_ANYADDRESS)&&(pIpsecFilterSpec->Filter.SrcAddr==0))
		{
			//any
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCIP_ANY);
		}
		else
		{
			//other IP address
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCIP_STR);
			if(bResolveDNS &&  (WcsCmp0(pIpsecFilterSpec->pszSrcDNSName,_TEXT("")) != 0))
			{
				PrintIPAddrDNS(pIpsecFilterSpec->Filter.SrcAddr);
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_RESOLVES,pIpsecFilterSpec->pszSrcDNSName);
			}
			else
			{
				PrintIPAddrList(pIpsecFilterSpec->Filter.SrcAddr);
			}
		}
		//mask
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCIP_MASK);
		PrintIPAddrList(pIpsecFilterSpec->Filter.SrcMask);

		switch(pFilterDNS->FilterSrcNameID)
		{
			//dns name
			case FILTER_MYADDRESS :
				{
					if((pIpsecFilterSpec->Filter.ExType == EXT_NORMAL)||((pIpsecFilterSpec->Filter.ExType & EXT_DEST)== EXT_DEST))
					{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_ME);
					}
					else if((pIpsecFilterSpec->Filter.ExType & EXT_DEST) != EXT_DEST)
					{
						if((pIpsecFilterSpec->Filter.ExType & EXT_DEFAULT_GATEWAY)==EXT_DEFAULT_GATEWAY)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_DEFGATEWAY);
						}
						else if((pIpsecFilterSpec->Filter.ExType & EXT_DHCP_SERVER)==EXT_DHCP_SERVER)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_DHCPSERVER);
						}
						else if((pIpsecFilterSpec->Filter.ExType & EXT_WINS_SERVER)== EXT_WINS_SERVER)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_WINSSERVER);
						}
						else if((pIpsecFilterSpec->Filter.ExType & EXT_DNS_SERVER)==EXT_DNS_SERVER)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_DNSSERVER);
						}
					}
				}
				break;
			case FILTER_DNSADDRESS:
				{
					if(!bResolveDNS)
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_STR, pIpsecFilterSpec->pszSrcDNSName);
					}
					else
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_RESOLVE, pIpsecFilterSpec->pszSrcDNSName);
						dwReturn = PrintResolveDNS(pIpsecFilterSpec->pszSrcDNSName);
						if(dwReturn == ERROR_OUTOFMEMORY)
						{
							BAIL_OUT;
						}
					}
				}
				break;
			case FILTER_ANYADDRESS:
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_ANY);
				break;
			case FILTER_IPADDRESS :
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_SPECIFIC_IP);
				break;
			case FILTER_IPSUBNET  :
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_SPECIFIC_SUBNET);
				break;
			default:
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SRCDNS_ANY);
				break;
		};

		//destination details

		if ((pFilterDNS->FilterDestNameID==FILTER_MYADDRESS)&&(pIpsecFilterSpec->Filter.DestAddr==0))
		{
			if((pIpsecFilterSpec->Filter.ExType == EXT_NORMAL)||((pIpsecFilterSpec->Filter.ExType & EXT_DEST) != EXT_DEST))
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTIP_ME);
			}
			else if((pIpsecFilterSpec->Filter.ExType & EXT_DEST) == EXT_DEST)
			{
				// server types
				if((pIpsecFilterSpec->Filter.ExType & EXT_DEFAULT_GATEWAY)==EXT_DEFAULT_GATEWAY)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTIP_DEFGATEWAY);
				}
				else if((pIpsecFilterSpec->Filter.ExType & EXT_DHCP_SERVER)==EXT_DHCP_SERVER)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTIP_DHCPSERVER);
				}
				else if((pIpsecFilterSpec->Filter.ExType & EXT_WINS_SERVER)==EXT_WINS_SERVER)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTIP_WINSSERVER);
				}
				else if((pIpsecFilterSpec->Filter.ExType & EXT_DNS_SERVER)==EXT_DNS_SERVER)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTIP_DNSSERVER);
				}
			}
		}
		else if ((pFilterDNS->FilterDestNameID==FILTER_ANYADDRESS)&&(pIpsecFilterSpec->Filter.DestAddr==0))
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTIP_ANY);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTIP_STR);
			if(bResolveDNS &&  (WcsCmp0(pIpsecFilterSpec->pszDestDNSName,_TEXT("")) != 0))
			{
				PrintIPAddrDNS(pIpsecFilterSpec->Filter.DestAddr);
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_RESOLVES,pIpsecFilterSpec->pszDestDNSName);
			}
			else
			{
				PrintIPAddrList(pIpsecFilterSpec->Filter.DestAddr);
			}
		}

		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTIP_MASK);	PrintIPAddrList(pIpsecFilterSpec->Filter.DestMask);
		switch(pFilterDNS->FilterDestNameID)
		{
			case FILTER_MYADDRESS :
				{
					if((pIpsecFilterSpec->Filter.ExType == EXT_NORMAL)||((pIpsecFilterSpec->Filter.ExType & EXT_DEST) != EXT_DEST))
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_ME);
					}
					else if((pIpsecFilterSpec->Filter.ExType & EXT_DEST) == EXT_DEST)
					{
						if((pIpsecFilterSpec->Filter.ExType & EXT_DEFAULT_GATEWAY)==EXT_DEFAULT_GATEWAY)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_DEFGATEWAY);
						}
						else if((pIpsecFilterSpec->Filter.ExType & EXT_DHCP_SERVER)==EXT_DHCP_SERVER)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_DHCPSERVER);
						}
						else if((pIpsecFilterSpec->Filter.ExType & EXT_WINS_SERVER)==EXT_WINS_SERVER)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_WINSSERVER);
						}
						else if((pIpsecFilterSpec->Filter.ExType & EXT_DNS_SERVER)==EXT_DNS_SERVER)
						{
							PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_DNSSERVER);
						}
					}
				}
				break;
			case FILTER_DNSADDRESS:
				{
					if(!bResolveDNS)
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_STR, pIpsecFilterSpec->pszDestDNSName);
					}
					else  // resolve DNS address
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DST_DNS_RESOLVE, pIpsecFilterSpec->pszDestDNSName);
						dwReturn = PrintResolveDNS(pIpsecFilterSpec->pszDestDNSName);
						if(dwReturn == ERROR_OUTOFMEMORY)
						{
							BAIL_OUT;
						}

					}
				}
				break;
			case FILTER_ANYADDRESS:  //any
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_ANY);
				break;
			case FILTER_IPADDRESS :  //a specific IP
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_SPECIFIC_IP);
				break;
			case FILTER_IPSUBNET  :  //a specific IP subnet
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_SPECIFIC_SUBNET);
				break;
			default:
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_DSTDNS_ANY);
				break;
		};

		//print protocol

		PrintProtocolNameList(pIpsecFilterSpec->Filter.Protocol);

		if(pIpsecFilterSpec->Filter.SrcPort)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCPORT_STR,pIpsecFilterSpec->Filter.SrcPort);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_SRCPORT_ANY);
		}

		if(pIpsecFilterSpec->Filter.DestPort)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTPORT_STR,pIpsecFilterSpec->Filter.DestPort);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DSTPORT_ANY);
		}

		delete pFilterDNS;
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);
	}
error:
	return dwReturn;
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintProtocolNameList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//		DWORD dwProtocol
//
//Return: VOID
//
//Description:
//	This function prints protocol name corresponding to protocoll ID.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintProtocolNameList(
	DWORD dwProtocol
	)
{
	switch(dwProtocol)
	{
		case PROT_ID_ICMP   :
				PrintMessageFromModule(g_hModule, SHW_STATIC_PRTPROTOCOL_ICMP);
				break;
		case PROT_ID_TCP    :
				PrintMessageFromModule(g_hModule, SHW_STATIC_PRTPROTOCOL_TCP);
				break;
		case PROT_ID_UDP    :
				PrintMessageFromModule(g_hModule, SHW_STATIC_PRTPROTOCOL_UDP);
				break;
		case PROT_ID_RAW    :
				PrintMessageFromModule(g_hModule, SHW_STATIC_PRTPROTOCOL_RAW);
				break;
		case PROT_ID_ANY    :
				PrintMessageFromModule(g_hModule, SHW_STATIC_PRTPROTOCOL_ANY);
				break;
		default:
				PrintMessageFromModule(g_hModule, SHW_STATIC_PRTPROTOCOL_OTHER, dwProtocol);
				break;
	};
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintISAKMPDataList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_ISAKMP_DATA pIpsecISAKMPData
//
//Return: VOID
//
//Description:
//	This function prints out the ISAKMP details.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintISAKMPDataList(
	IN PIPSEC_ISAKMP_DATA pIpsecISAKMPData
	)
{
	if(pIpsecISAKMPData)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMP_MMSEC_ORDER_TITLE);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMP_ALGO_TITLE_STR);
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMP_ALGO_TITLE_UNDERLINE);
		for (DWORD Loop=0;Loop<pIpsecISAKMPData->dwNumISAKMPSecurityMethods;Loop++)
		{
			// print mmsec details
			if(pIpsecISAKMPData->pSecurityMethods)
			{
				PrintISAKAMPSecurityMethodsList(pIpsecISAKMPData->pSecurityMethods[Loop]);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintISAKAMPSecurityMethodsList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN CRYPTO_BUNDLE SecurityMethods
//
//Return: VOID
//
//Description:
//	This function prints out the ISAKMP SecurityMethods details.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintISAKAMPSecurityMethodsList(
	IN CRYPTO_BUNDLE SecurityMethods
	)
{
	// print encription detail
	if(SecurityMethods.EncryptionAlgorithm.AlgorithmIdentifier==CONF_ALGO_DES)
    {
 	   PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMPSEC_DES_STR);
   	}
    else
    {
 	   PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMPSEC_3DES_STR);
   	}

	// print hash detail

    if(SecurityMethods.HashAlgorithm.AlgorithmIdentifier==AUTH_ALGO_SHA1)
    {
       	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMPSEC_SHA1_STR);
	}
    else
    {
    	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMPSEC_MD5_STR);
	}
	// print DH group detail
    if(SecurityMethods.OakleyGroup==POTF_OAKLEY_GROUP1)
    {
       	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMPSEC_DH_LOW_STR);
	}
    else if (SecurityMethods.OakleyGroup==POTF_OAKLEY_GROUP2)
    {
    	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMPSEC_DH_MED_STR);
	}
    else
    {
    	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTISAKMPSEC_DH_2048_STR);
	}
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintGPOList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
// 		IN PGPO pGPO,
//		IN BOOL bVerb
//
//Return: VOID
//
//Description:
//	This function prints the details of GPO .
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintGPOList(
	IN PGPO pGPO
	)
{
	if(!pGPO)
	{
		BAIL_OUT;
	}

	if(_tcscmp(pGPO->pszLocalMachineName, _TEXT(""))!=0)  //machine name
	{
		PrintMessageFromModule(g_hModule, SHW_STATIC_ASSIGNEDGPO_SRCMACHINE,pGPO->pszLocalMachineName);
	}
	else if(pGPO->pszDomainName)  //domain name
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_SRCDOMAIN,pGPO->pszDomainName);
		if (pGPO->pszDCName)  //DC name
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_DC_NAME,pGPO->pszDCName);
		}
	}

	if( pGPO->pszGPODisplayName )  // gpo name
	{
		if (pGPO->bDNPolicyOverrides && pGPO->pszGPODNName)  //gpo DN
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_GPO_NAME_STR,pGPO->pszGPODNName);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_GPO_NAME_STR,pGPO->pszGPODisplayName);
		}
	}

	if(_tcscmp(pGPO->pszGPODisplayName,LocalGPOName)==0)  // policy active - status
	{
		if(pGPO->bDNPolicyOverrides && (_tcscmp(pGPO->pszGPODisplayName,LocalGPOName)==0))
		{
			if(pGPO->pszLocalPolicyName)  //local policy name
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_LOCAL_POL_NAME_STR,pGPO->pszLocalPolicyName);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_LOC_POL_NAME_NONE);
			}

			if(pGPO->pszPolicyName)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_AD_POL_NAME_STR,pGPO->pszPolicyName);
			}

			if(pGPO->pszPolicyDNName)  // policy DN
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_AD_POL_DN_NAME,pGPO->pszPolicyDNName);
			}
			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_LOC_OPOL_ACTIVE_AD);
		}
		else if (_tcscmp(pGPO->pszGPODisplayName,LocalGPOName)==0)
		{
			if(pGPO->pszPolicyName)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_LOCAL_POL_NAME_STR,pGPO->pszPolicyName);
			}
			
			if(pGPO->pszPolicyDNName)  // policy DN
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_LOC_POL_ACTIVE_STR,pGPO->pszPolicyDNName);
			}

			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_AD_POL_NAME_NONE);

			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_POL_ACTIVE_STR);
		}

	}
	else  // if domain policy is active
	{
		if(pGPO->pszGPODNName)  //gpo DN
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_GPO_DN_NAME,pGPO->pszGPODNName);
		}
		if(pGPO->pszOULink)  // OU link
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_GPO_OU_LINK,pGPO->pszOULink);
		}

		if(pGPO->pszPolicyName)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_POL_NAME_STR,pGPO->pszPolicyName);
		}

		if(pGPO->pszPolicyDNName)  //Policy DN
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_POL_DN_STR,pGPO->pszPolicyDNName);
		}
		PrintMessageFromModule(g_hModule,SHW_STATIC_ASSIGNEDGPO_POL_ACTIVE_STR);
	}

error:
	return;
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintIPAddrList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN DWORD dwAddr
//
//Return: VOID
//
//Description:
//	This function prints out IP Address.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintIPAddrList(
	IN DWORD dwAddr
	)
{
	_TCHAR szIPAddr[20]= {0};

	// not necessary to change to bounded printf

	_stprintf(szIPAddr,_T("%d.%d.%d.%d"), (dwAddr & 0x000000FFL),((dwAddr & 0x0000FF00L) >>  8),((dwAddr & 0x00FF0000L) >> 16),((dwAddr & 0xFF000000L) >> 24) );
	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_FORMAT_NEWLINE,szIPAddr);
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintStorageInfoList()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN BOOL bDeleteAll
//
//Return: DWORD
//
//Description:
//	This function prints out the the Security Methods information.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

DWORD
PrintStorageInfoList(
	IN BOOL bDeleteAll
	)
{
	DWORD dwReturn = ERROR_SUCCESS , dwStrLength = 0, dwStoreId;

	if(g_StorageLocation.dwLocation!=IPSEC_DIRECTORY_PROVIDER)  // if it is local GPO
	{
		if(_tcscmp(g_StorageLocation.pszMachineName,_TEXT(""))!=0)
		{
			if(!bDeleteAll)
			{
        	    if (g_StorageLocation.dwLocation == IPSEC_REGISTRY_PROVIDER)
        	    {
        	        dwStoreId = SHW_STATIC_POLICY_STORE_RM_NAME_STR;
        	    }
        	    else
        	    {
        	        dwStoreId = SHW_STATIC_POLICY_STORE_RM_NAME_STRP;
        	    }

				PrintMessageFromModule(g_hModule,dwStoreId,g_StorageLocation.pszMachineName);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_RM_STR,g_StorageLocation.pszMachineName);
			}
		}
		else
		{
			_TCHAR  pszLocalMachineName[MAXSTRLEN] = {0};
			DWORD MaxStringLen=MAXSTRLEN;

			// Get the computer name

			GetComputerName(pszLocalMachineName,&MaxStringLen);

			if(!bDeleteAll)
			{
				if(_tcscmp(pszLocalMachineName,_TEXT(""))!=0)
				{
            	    if (g_StorageLocation.dwLocation == IPSEC_REGISTRY_PROVIDER)
            	    {
            	        dwStoreId = SHW_STATIC_POLICY_STORE_LM_NAME_STR;
            	    }
            	    else
            	    {
            	        dwStoreId = SHW_STATIC_POLICY_STORE_LM_NAME_STRP;
            	    }

					PrintMessageFromModule(g_hModule,dwStoreId,pszLocalMachineName);
				}
				else
				{
            	    if (g_StorageLocation.dwLocation == IPSEC_REGISTRY_PROVIDER)
            	    {
            	        dwStoreId = SHW_STATIC_POLICY_STORE_LM_STR;
            	    }
            	    else
            	    {
            	        dwStoreId = SHW_STATIC_POLICY_STORE_LM_STRP;
            	    }

					PrintMessageFromModule(g_hModule,dwStoreId);
				}
			}
			else
			{
				if(_tcscmp(pszLocalMachineName,_TEXT(""))!=0)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_LM_STR,pszLocalMachineName);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_LM);
				}
			}

		}
	}
	else if(g_StorageLocation.dwLocation==IPSEC_DIRECTORY_PROVIDER)  // if remote GPO
	{
		if(_tcscmp(g_StorageLocation.pszDomainName,_TEXT(""))!=0)
		{
			if(!bDeleteAll)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_STORE_LD_NAME_STR,g_StorageLocation.pszDomainName);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_RD_STR,g_StorageLocation.pszDomainName);
			}
		}
		else
		{
			PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
			LPTSTR pszDomainName = NULL;
			DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY;

			// get the domain name and DC name

			dwReturn = DsGetDcName(NULL, //machine name
						   NULL,
						   NULL,
						   NULL,
						   Flags,
						   &pDomainControllerInfo
						   ) ;

			if(dwReturn==NO_ERROR && pDomainControllerInfo && pDomainControllerInfo->DomainName)
			{
				dwStrLength = _tcslen(pDomainControllerInfo->DomainName);
				pszDomainName= new _TCHAR[dwStrLength+1];
				if(pszDomainName == NULL)
				{
					dwReturn = ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}
				_tcsncpy(pszDomainName,pDomainControllerInfo->DomainName,dwStrLength+1);
			}

			if (pDomainControllerInfo)
			{
				NetApiBufferFree(pDomainControllerInfo);
			}
			if(!bDeleteAll)
			{
				if(pszDomainName)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_STORE_RD_NAME_STR,pszDomainName);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_STORE_LD_STR);
				}
			}
			else
			{
				if(pszDomainName)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_LD_STR,pszDomainName);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_POLICY_LD);
				}
			}

			if(pszDomainName) delete [] pszDomainName;
		}
	}
error:
	return dwReturn;
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintResolveDNS()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	LPWSTR pszDNSName,
//	IPAddr *pIpAddr
//
//Return: DWORD
//
//Description:
//	This function prints DNS resolution details
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

DWORD
PrintResolveDNS(
	LPWSTR pszDNSName
	)
{
	DNSIPADDR *pAddress=NULL;
	struct addrinfo *pAddrInfo = NULL,*pNext=NULL;
	char szDNSName[MAX_STR_LEN] = {0};
	DWORD dwBufferSize=MAX_STR_LEN;
	int iReturn=ERROR_SUCCESS;
	DWORD dwReturn = ERROR_SUCCESS;

	if(pszDNSName && _tcscmp(pszDNSName,_TEXT(""))!=0)
	{
		pAddress=new DNSIPADDR;
		if(pAddress==NULL)
		{
			dwReturn = ERROR_OUTOFMEMORY;
			BAIL_OUT;
		}

    	iReturn = WideCharToMultiByte(CP_THREAD_ACP, 0, pszDNSName, -1,
                      szDNSName,dwBufferSize,NULL,NULL);

		if(iReturn == 0)
		{
			//conversion failed due to some error. dont proceed . dive out of the function
			BAIL_OUT;
		}

		// call this to resolve DNS name

		iReturn = getaddrinfo((const char*)szDNSName,NULL,NULL,&pAddrInfo);

		if (iReturn == ERROR_SUCCESS)
		{
			pNext = pAddrInfo;
			for(DWORD i=1;pNext=pNext->ai_next;i++);

			pAddress->dwNumIpAddresses = i;

			pAddress->puIpAddr = new ULONG[pAddress->dwNumIpAddresses];

			if(pAddress->puIpAddr==NULL)
			{
				dwReturn = ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			// careful : the output of getaddrinfo is linked list not array of pointers
			pNext = pAddrInfo;

			for(DWORD n=0;pNext; n++)
			{
				memcpy(&(pAddress->puIpAddr[n]),(ULONG *) &(((sockaddr_in *)(pNext->ai_addr))->sin_addr.S_un.S_addr), sizeof(ULONG));
				PrintIPAddrDNS(pAddress->puIpAddr[n]);

				if(n<(i-1))
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_SPACE_COMMA);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);
				}

				pNext=pNext->ai_next;
			}

			// free pAddrInfo after usage

			if (pAddrInfo)
			{
				freeaddrinfo(pAddrInfo);
			}
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFILTER_DNS_FAILED);
		}
error:

		if(pAddress)
		{
			delete pAddress;
		}
	}
	return dwReturn;
}
////////////////////////////////////////////////////////////////////
//
//Function: PrintIPAddrDNS()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN DWORD dwAddr
//
//Return: VOID
//
//Description:
//	This function prints out IP Address.
//
//Revision History:
//
//Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintIPAddrDNS(
	IN DWORD dwAddr
	)
{
	_TCHAR szIPAddr[20]= {0};

	// not necessary to change to bounded printf

	_stprintf(szIPAddr,_T("%d.%d.%d.%d"), (dwAddr & 0x000000FFL),((dwAddr & 0x0000FF00L) >>  8),((dwAddr & 0x00FF0000L) >> 16),((dwAddr & 0xFF000000L) >> 24) );
	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_FORMAT_NO_NEWLINE,szIPAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticshowtable.cpp ===
////////////////////////////////////////////////////////////////////
// Module: Static/StaticShow.cpp
//
// Purpose: 	Static Module Implementation.
//
// Developers Name: Surya
//
// History:
//
// Date    		Author    	Comments
// 10-8-2001	Surya		Initial Version. SCM Base line 1.0
//
//
////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern STORAGELOCATION g_StorageLocation;

////////////////////////////////////////////////////////////////////
//Function: PrintPolicyTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_POLICY_DATA pPolicy,
//	IN BOOL bVerb,
//	IN BOOL bAssigned,
//	IN BOOL bWide
//
//Return: VOID
//
//Description:
//	This function prints out the Policy information.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintPolicyTable(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN BOOL bVerb,
	IN BOOL bAssigned,
	IN BOOL bWide
	)
{
	_TCHAR pszGUIDStr[BUFFER_SIZE]={0};
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	DWORD i =0,k=0;
	BOOL bDsPolAssigned = FALSE;

	if (bVerb)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);

		// print policy name
		if(pPolicy->pszIpsecName)
		{
			TruncateString(pPolicy->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_NAME_STR,pszStrTruncated);
		}

		// print policy desc
		if(pPolicy->pszDescription)
		{
			TruncateString(pPolicy->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_DESC_STR,pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_DESC_NONE);
		}
		//print storage info
		PrintStorageInfoTable();

		//last modified time
		FormatTime((time_t)pPolicy->dwWhenChanged, pszStrTime);
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_LASTMOD_STR,pszStrTime);

		//print GUID
		i=StringFromGUID2(pPolicy->PolicyIdentifier,pszGUIDStr,BUFFER_SIZE);
		if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_GUID_STR,pszGUIDStr);
		}

		if(g_StorageLocation.dwLocation !=IPSEC_DIRECTORY_PROVIDER)
		{
			if(bAssigned)
			{
				if (
					ERROR_SUCCESS == IPSecIsDomainPolicyAssigned(&bDsPolAssigned) &&
					g_StorageLocation.dwLocation != IPSEC_PERSISTENT_PROVIDER &&
					bDsPolAssigned
					)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_ASSIGNED_AD);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_ASSIGNED_YES);
				}
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_ASSIGNED_NO);
			}
		}

		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POLL_MIN, (pPolicy->dwPollingInterval)/60);

		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMP_MM_LIFE_FORMAT,(pPolicy->pIpsecISAKMPData->pSecurityMethods[0].Lifetime.Seconds)/60 ,pPolicy->pIpsecISAKMPData->pSecurityMethods[0].QuickModeLimit);

		if(pPolicy->pIpsecISAKMPData->ISAKMPPolicy.PfsIdentityRequired)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_MMPFS_YES);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_MMPFS_NO);
		}

		//print ISAKMP data structure

		if(pPolicy->pIpsecISAKMPData)
		{
			PrintISAKMPDataTable(pPolicy->pIpsecISAKMPData);
		}

		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_RULE_COUNT, pPolicy->dwNumNFACount);
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_RULE_TITLE);
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_RULE_UNDERLINE);

		//print NFA structure in verbose mode

		for (DWORD j=0;j<pPolicy->dwNumNFACount;j++)
		{
			if(pPolicy->ppIpsecNFAData[j])
			{
				k=StringFromGUID2(pPolicy->ppIpsecNFAData[j]->NFAIdentifier,pszGUIDStr,BUFFER_SIZE);
				if(k>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_RULE_ID_GUID,j+1,pszGUIDStr);
				}
				PrintRuleTable(pPolicy->ppIpsecNFAData[j],bVerb,bWide);
			}
		}

	}
	else
	{
		if(pPolicy->pszIpsecName)
		{
			TruncateString(pPolicy->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_NVER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_FORMAT32S,pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_NONE_STR);
		}

		// NFA count
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_IP_FORMAT_TAB,pPolicy->dwNumNFACount);

		//last modified time
		FormatTime((time_t)pPolicy->dwWhenChanged, pszStrTime);
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_RULE_FORMAT23S,pszStrTime);

		if(g_StorageLocation.dwLocation != IPSEC_DIRECTORY_PROVIDER)
		{
			if(bAssigned)
			{
				if (ERROR_SUCCESS == IPSecIsDomainPolicyAssigned(&bDsPolAssigned) && bDsPolAssigned)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_AD_POL_OVERRIDES);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_YES_STR);
				}
			}
			else
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_NO_STR);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);
		}
	}
}

////////////////////////////////////////////////////////////////////
//
//Function: IsAssigned()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_POLICY_DATA pPolicy,
//	IN HANDLE hStorageHandle
//	IN OUT BOOL &bAssigned
//
//Return: DWORD
//
//Description:
//	This function checks out whether the specified policy is assigned.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

DWORD
IsAssigned(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN HANDLE hStorageHandle,
	IN OUT BOOL &bAssigned
	)
{
	PIPSEC_POLICY_DATA pActive=NULL;

	DWORD dwReturnCode = IPSecGetAssignedPolicyData(hStorageHandle, &pActive);

	if ((dwReturnCode == ERROR_SUCCESS)&&(pActive!=NULL))
	{
		if (IsEqualGUID(pPolicy->PolicyIdentifier, pActive->PolicyIdentifier))
		{
			bAssigned=TRUE;
		}
		if (pActive)
		{
			IPSecFreePolicyData(pActive);
		}
	}

	return dwReturnCode;
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintRuleTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_NFA_DATA pIpsecNFAData,
//	IN BOOL bVerb,
//	IN BOOL bWide
//
//Return: VOID
//
//Description:
//	This function prints out the Rule information.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintRuleTable(
	IN PIPSEC_NFA_DATA pIpsecNFAData,
	IN BOOL bVerb,
	IN BOOL bWide
	)
{
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};

	if(!bVerb)
	{
		if(pIpsecNFAData->dwTunnelIpAddr==0)
		{
			//whether the rule is activated
			if(pIpsecNFAData->dwActiveFlag)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_YES_STR);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_NO_STR);
			}

			if(pIpsecNFAData->pIpsecFilterData && pIpsecNFAData->pIpsecFilterData->pszIpsecName)
			{
				TruncateString(pIpsecNFAData->pIpsecFilterData->pszIpsecName,pszStrTruncated,RUL_TRUNC_LEN_TABLE_NVER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_FORMAT23STAB,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_NONE_STR);
			}

			if(pIpsecNFAData->pIpsecNegPolData && pIpsecNFAData->pIpsecNegPolData->pszIpsecName)
			{
				TruncateString(pIpsecNFAData->pIpsecNegPolData->pszIpsecName,pszStrTruncated,RUL_TRUNC_LEN_TABLE_NVER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_FORMAT23STAB,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_NONE_STR);
			}

			// print auth

			for (DWORD j=0;j<(pIpsecNFAData->dwAuthMethodCount);j++)
			{
				if(pIpsecNFAData->ppAuthMethods[j])
				{
					if(pIpsecNFAData->ppAuthMethods[j]->dwAuthType==IKE_SSPI)
					{
						//kerb
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_KERB);
					}
					else if(pIpsecNFAData->ppAuthMethods[j]->dwAuthType==IKE_RSA_SIGNATURE)
					{
						//cert
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_CERT);
					}
					else if (pIpsecNFAData->ppAuthMethods[j]->dwAuthType==IKE_PRESHARED_KEY)
					{
						//preshared
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_PRE);
					}
					else
					{
						//none
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_NONE_STR);
					}
				}
				if(j< (pIpsecNFAData->dwAuthMethodCount-1))
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_COMMA);
				}

				if(!bWide && j==2 && (pIpsecNFAData->dwAuthMethodCount-1)>2 )
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_EXTENSION);
					break;
				}
			}
		}
		else
		{
			if(pIpsecNFAData->dwActiveFlag)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_YES_STR);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_NO_STR);
			}
			if(pIpsecNFAData->pIpsecFilterData && pIpsecNFAData->pIpsecFilterData->pszIpsecName)
			{
				TruncateString(pIpsecNFAData->pIpsecFilterData->pszIpsecName,pszStrTruncated,RUL_TRUNC_LEN_TABLE_NVER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_FORMAT23STAB,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_NONE_STR);
			}

			if(pIpsecNFAData->pIpsecNegPolData && pIpsecNFAData->pIpsecNegPolData->pszIpsecName)
			{
				TruncateString(pIpsecNFAData->pIpsecNegPolData->pszIpsecName,pszStrTruncated,RUL_TRUNC_LEN_TABLE_NVER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_FORMAT23STAB,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_NONE_STR);
			}
			//tunnel address

			PrintIPAddrTable(pIpsecNFAData->dwTunnelIpAddr);
		}

	}
	else
	{
		if(pIpsecNFAData->pszIpsecName)
		{
			TruncateString(pIpsecNFAData->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_RULE_NAME_STR,pszStrTruncated);
		}
		else if(pIpsecNFAData->pIpsecNegPolData->NegPolType == GUID_NEGOTIATION_TYPE_DEFAULT)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_RULE_NAME_NONE_STR);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_RULE_NAME_NONE);
		}

		// rule desc
		if(pIpsecNFAData->pszDescription)
		{
			TruncateString(pIpsecNFAData->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_DESC_STR,pszStrTruncated);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_DESC_NONE);
		}

		//last modified time

		FormatTime((time_t)pIpsecNFAData->dwWhenChanged, pszStrTime);
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_LASTMOD_STR,pszStrTime);

		if(pIpsecNFAData->dwActiveFlag)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_ACTIVATED_YES);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_ACTIVATED_NO);
		}
		//tunnel address
		if(pIpsecNFAData->pIpsecNegPolData->NegPolType != GUID_NEGOTIATION_TYPE_DEFAULT)
		{
			if(pIpsecNFAData->dwTunnelIpAddr==0)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TUNNEL_NONE);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_TUNNEL_IP);
				PrintIPAddrTable(pIpsecNFAData->dwTunnelIpAddr);
				PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);
			}
		}

		//interface type
		if(pIpsecNFAData->dwInterfaceType==(DWORD)PAS_INTERFACE_TYPE_ALL)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_CONN_TYPE_ALL);
		}
		else if(pIpsecNFAData->dwInterfaceType==(DWORD)PAS_INTERFACE_TYPE_LAN)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_CONN_TYPE_LAN);
		}
		else if(pIpsecNFAData->dwInterfaceType==(DWORD)PAS_INTERFACE_TYPE_DIALUP)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_CONN_TYPE_DIALUP);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_CONN_TYPE_UNKNOWN);
		}

		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_AUTH_TITLE,pIpsecNFAData->dwAuthMethodCount);
		//print auth
		for (DWORD j=0;j<(pIpsecNFAData->dwAuthMethodCount);j++)
		{
			if(pIpsecNFAData->ppAuthMethods[j])
			{
				PrintAuthMethodsTable(pIpsecNFAData->ppAuthMethods[j]);
			}
		}

		//print filter data structure
		if (pIpsecNFAData->pIpsecFilterData)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_FILTERLIST_TITLE);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_FILTERLIST_UNDERLINE);
			if(pIpsecNFAData->pIpsecFilterData)
			{
				PrintFilterDataTable(pIpsecNFAData->pIpsecFilterData,bVerb,bWide);
			}
		}

		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_FILTERACTION_TITLE);
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTRULE_FILTERACTION_UNDERLINE);
		//print filter action data structure
		if(pIpsecNFAData->pIpsecNegPolData)
		{
			PrintNegPolDataTable(pIpsecNFAData->pIpsecNegPolData,bVerb,bWide);
		}
	}
}

////////////////////////////////////////////////////////////////////
//
//Function: PrintNegPolData()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
//	IN BOOL bVerb,
//	IN BOOL bWide
//
//Return: VOID
//
//Description:
//	This function prints out the Negotiation Policy information.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintNegPolDataTable(
	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
	IN BOOL bVerb,
	IN BOOL bWide
	)
{
	BOOL bSoft=FALSE;
	_TCHAR pszGUIDStr[BUFFER_SIZE]={0};
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	DWORD i=0;

	if(pIpsecNegPolData)
	{
		if (bVerb)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);

			//filteraction name

			if(pIpsecNegPolData->pszIpsecName)
			{
				TruncateString(pIpsecNegPolData->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_FA_NAME_STR,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_FA_NAME_NONE);
			}

			//filteraction desc
			if(pIpsecNegPolData->pszDescription)
			{
				TruncateString(pIpsecNegPolData->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_DESC_STR,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_DESC_NONE);
			}

			PrintStorageInfoTable();

			//negpol action
			if (!(pIpsecNegPolData->NegPolType==GUID_NEGOTIATION_TYPE_DEFAULT))
			{
				if(pIpsecNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_ACTION_PERMIT);
				}
				else if(pIpsecNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_ACTION_BLOCK);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_ACTION_NEGOTIATE);
				}
			}
			//secmethods
			if(pIpsecNegPolData->pIpsecSecurityMethods)
			{
				for (DWORD cnt=0;cnt<pIpsecNegPolData->dwSecurityMethodCount;cnt++)
					if (CheckSoft(pIpsecNegPolData->pIpsecSecurityMethods[cnt]))
					{
						bSoft=TRUE;
						break;
					}
			}
			//inpass
			if(pIpsecNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_INPASS_YES);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_INPASS_NO);
			}
			//soft
			if(bSoft)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_SOFT_YES);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_SOFT_NO);
			}
			if (pIpsecNegPolData->dwSecurityMethodCount )
			{
				if(pIpsecNegPolData->pIpsecSecurityMethods && pIpsecNegPolData->pIpsecSecurityMethods[0].PfsQMRequired)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_QMPFS_YES);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_QMPFS_NO);
				}
			}

			//lastmodified time
			FormatTime((time_t)pIpsecNegPolData->dwWhenChanged, pszStrTime);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_LASTMOD_STR,pszStrTime);

			//guid
			i=StringFromGUID2(pIpsecNegPolData->NegPolIdentifier,pszGUIDStr,BUFFER_SIZE);
			if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_GUID_STR,pszGUIDStr);
			}

			if (pIpsecNegPolData->dwSecurityMethodCount)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_SEC_MTHD_TITLE);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_ALGO_TITLE);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_ALGO_UNDERLINE);
			}
			for (DWORD cnt=0;cnt<pIpsecNegPolData->dwSecurityMethodCount;cnt++)
			{
				//sec methods
				if(pIpsecNegPolData->pIpsecSecurityMethods)
				{
					PrintSecurityMethodsTable(pIpsecNegPolData->pIpsecSecurityMethods[cnt]);
				}
			}
		}
		else
		{
			if(pIpsecNegPolData->pszIpsecName)
			{
				TruncateString(pIpsecNegPolData->pszIpsecName,pszStrTruncated,FA_TRUNC_LEN_TABLE_NVER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_FORMAT38S,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_NONE_STR);
			}

			//negpol action

			if (!(pIpsecNegPolData->NegPolType==GUID_NEGOTIATION_TYPE_DEFAULT))
			{
				if(pIpsecNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_NO_IPSEC)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_PERMIT_STR);
				}
				else if(pIpsecNegPolData->NegPolAction==GUID_NEGOTIATION_ACTION_BLOCK)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_BLOCK_STR);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_NEGOTIATE_STR);
				}
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_ACTION_NONE_STR);
			}
			//last modified
			FormatTime((time_t)pIpsecNegPolData->dwWhenChanged, pszStrTime);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_FORMAT23SNEWLINE,pszStrTime);
		}

	}

}

////////////////////////////////////////////////////////////////////
//
//Function: PrintSecurityMethodsTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods,
//
//Return: VOID
//
//Description:
//	This function prints out the the Security Methods information.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////

VOID
PrintSecurityMethodsTable(
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods
	)
{
	if (!CheckSoft(IpsecSecurityMethods))
	{
		if(IpsecSecurityMethods.Algos)
		{
			//print algo
			PrintAlgoInfoTable(IpsecSecurityMethods.Algos,IpsecSecurityMethods.Count);
		}
		//print life
		PrintLifeTimeTable(IpsecSecurityMethods.Lifetime);
	}
}

/////////////////////////////////////////////////////////////////
//
//Function: PrintAlgoInfo()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_ALGO_INFO   Algos,
//	IN DWORD dwNumAlgos
//
//Return: VOID
//
//Description:
//	This function prints out the the Algorithm information.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////

VOID
PrintAlgoInfoTable(
	IN PIPSEC_ALGO_INFO   Algos,
	IN DWORD dwNumAlgos
	)
{
	if(dwNumAlgos==1) //if only auth or encrpt specified
	{
		//print authentication
		if (Algos[0].operation==AUTHENTICATION)
		{
			if(Algos[0].algoIdentifier==AUTH_ALGO_MD5)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_MD5);
			}
			else if(Algos[0].algoIdentifier==AUTH_ALGO_SHA1)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_SHA1);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE);
			}
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE_NONE);
		}
		else if (Algos[0].operation==ENCRYPTION)
		{
			//print encription
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE);

			if(Algos[0].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_MD5)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_MD5_COMMA);
			}
			else if(Algos[0].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_SHA1)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_SHA1_COMMA);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE_COMMA);
			}

			if(Algos[0].algoIdentifier==CONF_ALGO_DES)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_DES_TAB);
			}
			else if(Algos[0].algoIdentifier==CONF_ALGO_3_DES)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_3DES_TAB);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE_TAB);
			}
		}
	}
	else if(dwNumAlgos==2)  //if both auth and encrpt specified
	{
		//encryption

		if (Algos[0].operation==ENCRYPTION)
		{
			if (Algos[1].operation==AUTHENTICATION)
			{
				if(Algos[1].algoIdentifier==AUTH_ALGO_MD5)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_MD5);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_SHA1);
				}
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE);
			}

			if(Algos[0].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_MD5)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_MD5_COMMA);
			}
			else if(Algos[0].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_SHA1)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_SHA1_COMMA);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE_COMMA);
			}

			if(Algos[0].algoIdentifier==CONF_ALGO_DES)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_DES_TAB);
			}
			else if(Algos[0].algoIdentifier==CONF_ALGO_3_DES)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_3DES_TAB);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE_TAB);
			}
		}
		else   //authentication
		{
			if (Algos[0].operation==AUTHENTICATION)
			{
				if(Algos[0].algoIdentifier==AUTH_ALGO_MD5)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_MD5);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_SHA1);
				}
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE);
			}

			if(Algos[1].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_MD5)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_MD5_COMMA);
			}
			else if(Algos[1].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_SHA1)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_SHA1_COMMA);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE_COMMA);
			}

			if(Algos[1].algoIdentifier==CONF_ALGO_DES)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_DES_TAB);
			}
			else if(Algos[1].algoIdentifier==CONF_ALGO_3_DES)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_3DES_TAB);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALGO_NONE_TAB);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////
//
//Function: PrintLifeTimeTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LIFETIME LifeTime
//
//Return: VOID
//
//Description:
//	This function prints out the Life Time details.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////

VOID
PrintLifeTimeTable(
	IN LIFETIME LifeTime
	)
{
	PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTLIFE_FORMAT,LifeTime.KeyExpirationTime,LifeTime.KeyExpirationBytes);
}

/////////////////////////////////////////////////////////////////
//
//Function: CheckSoft()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods
//
//Return: BOOL
//
//Description:
//	This function checks whether soft association exists.
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////

BOOL
CheckSoft(
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods
	)
{
	BOOL bSoft=FALSE;

	if (IpsecSecurityMethods.Count==0)
	{
		bSoft=TRUE;
	}

	return bSoft;
}

/////////////////////////////////////////////////////////////////
//
//Function: PrintAuthMethodsTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_AUTH_METHOD pIpsecAuthData
//
//Return: VOID
//
//Description:
//	This function prints out Authentication details.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////

VOID
PrintAuthMethodsTable(
	IN PIPSEC_AUTH_METHOD pIpsecAuthData
	)
{
	if(pIpsecAuthData)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_NEWLINE);

		if(pIpsecAuthData->dwAuthType==IKE_SSPI)  //kerb
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTAUTH_KERB);
		}
		else if(pIpsecAuthData->dwAuthType==IKE_RSA_SIGNATURE && pIpsecAuthData->pszAuthMethod)
		{
			//cert
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTAUTH_ROOTCA_FORMAT,pIpsecAuthData->pszAuthMethod);
			//cert mapping flag

			if((g_StorageLocation.dwLocation != IPSEC_DIRECTORY_PROVIDER && IsDomainMember(g_StorageLocation.pszMachineName))||(g_StorageLocation.dwLocation == IPSEC_DIRECTORY_PROVIDER))
			{
				if(pIpsecAuthData->dwAuthFlags & IPSEC_MM_CERT_AUTH_ENABLE_ACCOUNT_MAP)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_POLICY_CERT_MAP_YES);
				}
				else
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_POLICY_CERT_MAP_NO);
				}
			}
			if (pIpsecAuthData->dwAuthFlags & IPSEC_MM_CERT_AUTH_DISABLE_CERT_REQUEST)
			{
				PrintMessageFromModule(g_hModule, SHW_AUTH_EXCLUDE_CA_NAME_YES_STR);
			}
			else
			{
				PrintMessageFromModule(g_hModule, SHW_AUTH_EXCLUDE_CA_NAME_NO_STR);
			}
		}
		else if (pIpsecAuthData->dwAuthType==IKE_PRESHARED_KEY && pIpsecAuthData->pszAuthMethod)
		{
			//preshared key
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTAUTH_PRE_FORMAT,pIpsecAuthData->pszAuthMethod);
		}
		else
		{
			//none
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTAUTH_NONE_AUTH_STR);
		}
	}
}

/////////////////////////////////////////////////////////////////
//
//Function: PrintFilterDataTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_DATA pIpsecFilterData,
//	IN BOOL bVerb,
//	IN BOOL bWide
//
//Return: VOID
//
//Description:
//	This function prints out Filter list details.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////

DWORD
PrintFilterDataTable(
	IN PIPSEC_FILTER_DATA pIpsecFilterData,
	IN BOOL bVerb,
	IN BOOL bWide
	)
{
	BOOL bTitlePrinted=FALSE;
	_TCHAR pszGUIDStr[BUFFER_SIZE]={0};
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	DWORD i=0,dwReturn = ERROR_SUCCESS;

	if (pIpsecFilterData)
	{
		if(bVerb)
		{
			//filterlist name
			if(pIpsecFilterData->pszIpsecName)
			{
				TruncateString(pIpsecFilterData->pszIpsecName,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_NAME_STR,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_NAME_NONE);
			}
			//filterlist desc
			if(pIpsecFilterData->pszDescription)
			{
				TruncateString(pIpsecFilterData->pszDescription,pszStrTruncated,POL_TRUNC_LEN_TABLE_VER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_DESC_STR,pszStrTruncated);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPOLICY_POL_DESC_NONE);
			}

			PrintStorageInfoTable();

			//last modified
			FormatTime((time_t)pIpsecFilterData->dwWhenChanged, pszStrTime);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_LASTMOD_STR,pszStrTime);

			//guid
			i=StringFromGUID2(pIpsecFilterData->FilterIdentifier,pszGUIDStr,BUFFER_SIZE);
			if(i>0 && (_tcscmp(pszGUIDStr,_TEXT(""))!=0))
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FL_GUID_STR,pszGUIDStr);

			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FILTER_COUNT,pIpsecFilterData->dwNumFilterSpecs);

			for (DWORD k=0;k<pIpsecFilterData->dwNumFilterSpecs;k++)
			{

				//print filter specs
				if(!bTitlePrinted)
				{
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_FILTERS_TITLE);
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_FILTER_TITLE);
					PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_FILTER_UNDERLINE);
					bTitlePrinted=TRUE;
				}
				PrintFilterSpecTable(pIpsecFilterData->ppFilterSpecs[k]);
			}
		}
		else
		{
			if(pIpsecFilterData->pszIpsecName)
			{
				TruncateString(pIpsecFilterData->pszIpsecName,pszStrTruncated,FL_TRUNC_LEN_TABLE_NVER,bWide);
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_FORMAT45S,pszStrTruncated);
			}
			else
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_NONE_TAB);

			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_FORMAT5D,pIpsecFilterData->dwNumFilterSpecs);

			//last modified
			FormatTime((time_t)pIpsecFilterData->dwWhenChanged, pszStrTime);
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_FORMATS,pszStrTime);
		}
 	}
 	return dwReturn;
}

//////////////////////////////////////////////////////////////////////////
//Function: PrintIPAddrTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN DWORD dwAddr
//
///Return: VOID
//
//Description:
//	This function prints out IP Address.
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

VOID
PrintIPAddrTable(
	IN DWORD dwAddr
	)
{
	_TCHAR szIPAddr[20]= {0};

	// not necessary to change to bounded printf

	_stprintf(szIPAddr,_T("%d.%d.%d.%d"), (dwAddr & 0x000000FFL),((dwAddr & 0x0000FF00L) >>  8),((dwAddr & 0x00FF0000L) >> 16),((dwAddr & 0xFF000000L) >> 24) );
	PrintMessageFromModule(g_hModule,SHW_STATIC_PRTFSPEC_FORMAT15S,szIPAddr);
}

//////////////////////////////////////////////////////////////////////////
//
//Function: GetFilterDNSDetails()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_SPEC pFilterData,
//	IN OUT PFILTERDNS pFilterDNS
//
//Return: VOID
//
//Description:
//	This function gets the details of DNS information.
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

VOID
GetFilterDNSDetails(
	IN PIPSEC_FILTER_SPEC pFilterData,
	IN OUT PFILTERDNS pFilterDNS
	)
 {
	 if ((pFilterData->Filter.SrcAddr == 0) && (pFilterData->Filter.SrcMask == MASK_ME) && (WcsCmp0(pFilterData->pszSrcDNSName,_TEXT("")) == 0))
	 {
		 pFilterDNS->FilterSrcNameID=FILTER_MYADDRESS;
	 }
	 else
	 {
		 if (WcsCmp0(pFilterData->pszSrcDNSName,_TEXT("")) != 0)
		 {
			 pFilterDNS->FilterSrcNameID=FILTER_DNSADDRESS;   //DNS name
		 }
		 else if ((pFilterData->Filter.SrcAddr == 0) && (pFilterData->Filter.SrcMask == 0))
		 {
			pFilterDNS->FilterSrcNameID=FILTER_ANYADDRESS;   //any
		 }
		 else if ((pFilterData->Filter.SrcAddr != 0) && (pFilterData->Filter.SrcMask == MASK_ME))
		 {
			 pFilterDNS->FilterSrcNameID=FILTER_IPADDRESS;  //a specific IP
		 }
		 else if ((pFilterData->Filter.SrcAddr != 0) && (pFilterData->Filter.SrcMask != 0))
		 {
			 pFilterDNS->FilterSrcNameID=FILTER_IPSUBNET;  //a specific IP subnet
		 }
		 else
		 {
			  pFilterDNS->FilterSrcNameID=FILTER_ANYADDRESS;  //any
		 }
	 }

	 if ((pFilterData->Filter.DestAddr == 0) && (pFilterData->Filter.DestMask == 0) && ((WcsCmp0(pFilterData->pszDestDNSName,_TEXT("")) == 0) == 0))
	 {
		 pFilterDNS->FilterDestNameID= FILTER_ANYADDRESS;  //any
	 }
	 else
	 {
		 if (WcsCmp0(pFilterData->pszDestDNSName,_TEXT("")) != 0)
		 {
			 pFilterDNS->FilterDestNameID = FILTER_DNSADDRESS;  //DNA name
		 }
		 else if ((pFilterData->Filter.DestAddr == 0) && (pFilterData->Filter.DestMask == MASK_ME))
		 {
			 pFilterDNS->FilterDestNameID = FILTER_MYADDRESS;  //me
		 }
		 else if ((pFilterData->Filter.DestAddr != 0) && (pFilterData->Filter.DestMask == MASK_ME))
		 {
			 pFilterDNS->FilterDestNameID = FILTER_IPADDRESS;  //a specifiec IP
		 }
		 else if ((pFilterData->Filter.DestAddr != 0) && (pFilterData->Filter.DestMask != 0))
		 {
			 pFilterDNS->FilterDestNameID =FILTER_IPSUBNET;  //a specific subnet
		 }
		 else
		 {
			 pFilterDNS->FilterDestNameID = FILTER_ANYADDRESS;  //any
		 }
	 }
 }

//////////////////////////////////////////////////////////////////////////
//
//Function: PrintFilterSpecTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_SPEC pIpsecFilterSpec
//
//Return: DWORD
//
//Description:
//
//	This function prints the Filter Spec details
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

DWORD
PrintFilterSpecTable(
	IN PIPSEC_FILTER_SPEC pIpsecFilterSpec
	)
{
	DWORD dwReturn = ERROR_SUCCESS;

	PFILTERDNS pFilterDNS= new FILTERDNS;
	if(pFilterDNS == NULL)
	{
		dwReturn = ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	GetFilterDNSDetails(pIpsecFilterSpec, pFilterDNS);

	if(pIpsecFilterSpec->dwMirrorFlag)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_YES_STR_TAB);
	}
	else
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFSPEC_NO_STR_TAB);
	}

	// print the filter details

	PrintFilterTable(pIpsecFilterSpec->Filter,pFilterDNS);
error:
	return dwReturn;
}

/////////////////////////////////////////////////////////////////////////
//
//Function: PrintFilterTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN IPSEC_FILTER Filter,
//	IN PFILTERDNS pFilterDNS
//
//Return: VOID
//
//Description:
//	This function prints the Filter details
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

VOID
PrintFilterTable(
	IN IPSEC_FILTER Filter,
	IN PFILTERDNS pFilterDNS
	)

{

	//Source details

	if ((pFilterDNS->FilterSrcNameID==FILTER_MYADDRESS)&&(Filter.SrcAddr==0))
	{
		if((Filter.ExType == EXT_NORMAL)||((Filter.ExType & EXT_DEST)== EXT_DEST))
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_MY_IP_ADDR);  // my IP
		}
		else if((Filter.ExType & EXT_DEST) != EXT_DEST)   //special servers
		{
			if((Filter.ExType & EXT_DEFAULT_GATEWAY) == EXT_DEFAULT_GATEWAY)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_DEFGATE_TAB);
			}
			else if((Filter.ExType & EXT_DHCP_SERVER) == EXT_DHCP_SERVER)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_DHCP_TAB);
			}
			else if((Filter.ExType & EXT_WINS_SERVER) == EXT_WINS_SERVER)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_WINS_TAB);
			}
			else if((Filter.ExType & EXT_DNS_SERVER) == EXT_DNS_SERVER)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_DNS_TAB);
			}
		}
	}

	else if ((pFilterDNS->FilterSrcNameID==FILTER_ANYADDRESS)&&(Filter.SrcAddr==0))
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_ANY_IP_ADDR);   //any IP address
	}
	else
	{
		PrintIPAddrTable(Filter.SrcAddr);   //print specific IP addr
	}

	PrintIPAddrTable(Filter.SrcMask);  //mask

	//Destination details

	if ((pFilterDNS->FilterDestNameID==FILTER_MYADDRESS)&&(Filter.DestAddr==0))
	{
		if((Filter.ExType == EXT_NORMAL)||((Filter.ExType & EXT_DEST) != EXT_DEST))  //my ip addr
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_MY_IP_ADDR);
		}
		else if((Filter.ExType & EXT_DEST) == EXT_DEST)  // special servers
		{
			if((Filter.ExType & EXT_DEFAULT_GATEWAY) == EXT_DEFAULT_GATEWAY)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_DEFGATE_TAB);
			}
			else if((Filter.ExType & EXT_DHCP_SERVER) == EXT_DHCP_SERVER)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_DHCP_TAB);
			}
			else if((Filter.ExType & EXT_WINS_SERVER) == EXT_WINS_SERVER)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_WINS_TAB);
			}
			else if((Filter.ExType & EXT_DNS_SERVER) == EXT_DNS_SERVER)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_DNS_TAB);
			}
		}
	}

	else if ((pFilterDNS->FilterDestNameID==FILTER_ANYADDRESS)&&(Filter.DestAddr==0))
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_ANY_IP_ADDR);  //any
	}
	else
	{
		PrintIPAddrTable(Filter.DestAddr);  //print specific addr
	}

	PrintIPAddrTable(Filter.DestMask);  //mask

	PrintProtocolNameTable(Filter.Protocol);

	if(Filter.SrcPort)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_IP_FORMAT_TAB,Filter.SrcPort);
	}
	else
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_ANY_STR_TAB);
	}

	if(Filter.DestPort)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_IP_FORMAT_NEWLINE,Filter.DestPort);
	}
	else
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTER_ANY_STR_NEWLINE);
	}
}

/////////////////////////////////////////////////////////////////////////
//
//Function: PrintProtocolName()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//		DWORD dwProtocol
//
//Return: VOID
//
//Description:
//	This function prints protocol name corresponding to protocoll ID.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

VOID
PrintProtocolNameTable(
	DWORD dwProtocol
	)
{
	switch(dwProtocol)
	{
		case PROT_ID_ICMP   :
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPROTOCOL_ICMP_TAB);
				break;
		case PROT_ID_TCP    :
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPROTOCOL_TCP_TAB);
				break;
		case PROT_ID_UDP    :
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPROTOCOL_UDP_TAB);
				break;
		case PROT_ID_RAW    :
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPROTOCOL_RAW_TAB);
				break;
		case PROT_ID_ANY    :
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPROTOCOL_ANY_TAB);
				break;
		default:
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTPROTOCOL_OTHER_TAB);
				break;
	};
}

/////////////////////////////////////////////////////////////////////////
//
//Function: PrintISAKMPDataTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
//
//Return: VOID
//
//Description:
//	This function prints out the ISAKMP details.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

VOID
PrintISAKMPDataTable(
	IN PIPSEC_ISAKMP_DATA pIpsecISAKMPData
	)
{
	if(pIpsecISAKMPData)
	{
		//ISAKMP details
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMP_MMSEC_TITLE);
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMP_MMSEC_MTD_TILE);
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMP_MMSEC_MTD_UNDERLINE);
		for (DWORD Loop=0;Loop<pIpsecISAKMPData->dwNumISAKMPSecurityMethods;Loop++)
		{
			if(pIpsecISAKMPData->pSecurityMethods)
			{
				PrintISAKAMPSecurityMethodsTable(pIpsecISAKMPData->pSecurityMethods[Loop]);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////
//
//Function: PrintISAKAMPSecurityMethodsTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN CRYPTO_BUNDLE SecurityMethods,
//
//Return: VOID
//
//Description:
//	This function prints out the ISAKMP SecurityMethods details.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

VOID
PrintISAKAMPSecurityMethodsTable(
	IN CRYPTO_BUNDLE SecurityMethods
	)
{
	// encription
    if(SecurityMethods.EncryptionAlgorithm.AlgorithmIdentifier==CONF_ALGO_DES)
    {
 	   PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMPSEC_DES_TAB);
   	}
    else
    {
 	   PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMPSEC_3DES_TAB);
   	}

    //hash algo
    if(SecurityMethods.HashAlgorithm.AlgorithmIdentifier==AUTH_ALGO_SHA1)
    {
       	PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMPSEC_SHA1_TAB);
	}
    else
    {
    	PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMPSEC_MD5_TAB);
	}

	//DH group
    if(SecurityMethods.OakleyGroup==POTF_OAKLEY_GROUP1)
    {
       	PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMPSEC_DH_LOW);
	}
    else if (SecurityMethods.OakleyGroup==POTF_OAKLEY_GROUP2)
    {
    	PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMPSEC_DH_MEDIUM);
	}
    else
    {
    	PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTISAKMPSEC_DH_2048);
	}
}

/////////////////////////////////////////////////////////////////////////
//
//Function: PrintStandAloneFAData()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage,
//	IN BOOL bVerbose,
//	IN BOOL bTable,
//	IN BOOL bWide
//
//Return: DWORD
//
//Description:
//	This function prints out the Filter actions details ,unattached to any of the policies.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

DWORD
PrintStandAloneFAData(
	IN HANDLE hPolicyStorage,
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN BOOL bWide
	)
{

	DWORD        dwReturnCode   = S_OK;
	BOOL bTitlePrinted=FALSE, bStandAlone=TRUE;
	PIPSEC_NEGPOL_DATA *ppNegPolEnum  = NULL,pNegPol=NULL;
	DWORD  dwNumNegPol=0;
	DWORD  cnt=0,num=1;

	dwReturnCode = IPSecEnumNegPolData(hPolicyStorage, &ppNegPolEnum, &dwNumNegPol);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumNegPol > 0 && ppNegPolEnum != NULL))
	{
		BAIL_OUT;  // if no FA , bail out of the function
	}

	for(cnt=0; cnt < dwNumNegPol;cnt++)
	{
		bStandAlone=TRUE;
		dwReturnCode = IPSecCopyNegPolData(ppNegPolEnum[cnt], &pNegPol);

		if ((dwReturnCode == ERROR_SUCCESS) && (pNegPol != NULL)&&(pNegPol->NegPolType!=GUID_NEGOTIATION_TYPE_DEFAULT))
		{
			//check whether it is stand alone
			dwReturnCode= IsStandAloneFA(pNegPol,hPolicyStorage,bStandAlone);
			if (dwReturnCode == ERROR_SUCCESS)
			{
				if(bStandAlone)  // if standalone print the details of it
				{
					if(!bTitlePrinted)
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTSAFA_STAND_ALONE_FA_TITLE);
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTSAFA_STAND_ALONE_FA_UNDERLINE);
					}
					num++;
					if(bTable)
						PrintNegPolDataTable(pNegPol,bVerbose,bWide);
					else
						PrintNegPolDataList(pNegPol,bVerbose,bWide);
					bTitlePrinted=TRUE;
				}
			}
			if(pNegPol)	IPSecFreeNegPolData(pNegPol);
		}
		if (dwReturnCode != ERROR_SUCCESS) break;
	}
	//	clean up
	if (dwNumNegPol > 0 && ppNegPolEnum != NULL)
	{
		IPSecFreeMulNegPolData(	ppNegPolEnum,dwNumNegPol);
	}
	if(num-1)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTSAFA_STAND_ALONE_FA_COUNT,num-1);
	}
error:
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////////////////
//
//Function: IsStandAloneFA()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_NEGPOL_DATA pNegPol,
//	IN HANDLE hPolicyStorage
//
//Return: VOID
//
//Description:
//	This function checks whether the specified Filter Action is unattached to any of the policies.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

DWORD
IsStandAloneFA(
	IN PIPSEC_NEGPOL_DATA pNegPol,
	IN HANDLE hPolicyStorage,
	IN OUT BOOL &bStandAlone
	)
{
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL,pPolicy=NULL;
	DWORD   dwNumPolicies = 0 , i = 0;
	RPC_STATUS     RpcStat;
	DWORD        dwReturnCode   = S_OK;

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		dwReturnCode = ERROR_SUCCESS;
		BAIL_OUT;  // if nothing exists , bail out
	}
	for (i = 0; i <  dwNumPolicies; i++)
	{
		dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
		if (dwReturnCode == ERROR_SUCCESS)
		{
			//enum rules
			dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier, &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));
			if (dwReturnCode == ERROR_SUCCESS)
			{
				DWORD j;
				for (j = 0; j <  pPolicy->dwNumNFACount; j++)
				{
					if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->NegPolIdentifier), &RpcStat))
					{
						dwReturnCode=IPSecGetNegPolData(hPolicyStorage, pPolicy->ppIpsecNFAData[j]->NegPolIdentifier,&(pPolicy->ppIpsecNFAData[j]->pIpsecNegPolData));
						if(dwReturnCode != ERROR_SUCCESS)
						{
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_3,pPolicy->pszIpsecName);
						}
					}
					if (dwReturnCode != ERROR_SUCCESS) break;

				}
			}
			if(dwReturnCode == ERROR_SUCCESS)
			{
				for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
				{
					//check whether standalone filteraction
					if (UuidCompare(&(pPolicy->ppIpsecNFAData[n]->pIpsecNegPolData->NegPolIdentifier), &(pNegPol->NegPolIdentifier), &RpcStat) == 0 && RpcStat == RPC_S_OK || (pNegPol->NegPolType==GUID_NEGOTIATION_TYPE_DEFAULT))
					{
						bStandAlone=FALSE;
						break;
					}
				}
			}
			if (pPolicy)
				IPSecFreePolicyData(pPolicy);
		}
		if ((!bStandAlone)||(dwReturnCode != ERROR_SUCCESS)) break;
	}
	//clean up
	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
error:
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////////////////
//
//Function: PrintStandAloneFLData()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage,
//	IN BOOL bVerbose
//	IN BOOL bTable,
//	IN BOOL bWide
//
//Return: VOID
//
//Description:
//	This function prints out the Filter Lists details ,unattached to any of the policies.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

DWORD
PrintStandAloneFLData(
	IN HANDLE hPolicyStorage,
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN BOOL bWide
	)
{
	DWORD	dwReturnCode   = S_OK;
	BOOL bTitlePrinted=FALSE,bStandAlone=TRUE;
	PIPSEC_FILTER_DATA *ppFilterEnum  = NULL,pFilter=NULL;
	DWORD dwNumFilter=0;
	DWORD cnt=0,num=1;

	dwReturnCode = IPSecEnumFilterData(hPolicyStorage, &ppFilterEnum, &dwNumFilter);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumFilter > 0 && ppFilterEnum != NULL))
	{
		BAIL_OUT;   // if nothing available, bail out od the function
	}
	for(cnt=0; cnt < dwNumFilter;cnt++)
	{
		bStandAlone=TRUE;

		dwReturnCode = IPSecCopyFilterData(ppFilterEnum[cnt], &pFilter);
		if ((dwReturnCode == ERROR_SUCCESS) && (pFilter != NULL))
		{
			dwReturnCode= IsStandAloneFL(pFilter,hPolicyStorage,bStandAlone);
			if (dwReturnCode == ERROR_SUCCESS)
			{
				if(bStandAlone)  // print the details, if it is standalone
				{
					if(!bTitlePrinted)
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTSAFL_STAND_ALONE_FL_TITLE);
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTSAFL_STAND_ALONE_FL_UNDERLINE);
					}
					num++;
					// print in required format
					if(bTable)
					{
						PrintFilterDataTable(pFilter,bVerbose,bWide);
					}
					else
					{
						dwReturnCode = PrintFilterDataList(pFilter,bVerbose,FALSE,bWide);
						BAIL_ON_WIN32_ERROR(dwReturnCode);
					}
					bTitlePrinted=TRUE;  // this is to print the title only once
				}
			}
			if(pFilter) IPSecFreeFilterData(pFilter);
		}

		if (dwReturnCode != ERROR_SUCCESS) break;
	}
	if(ppFilterEnum && dwNumFilter > 0)
	{
		IPSecFreeMulFilterData(	ppFilterEnum,dwNumFilter);
	}
	if(num-1)
	{
		PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTSAFL_STAND_ALONE_FL_COUNT,num-1);
	}

error:
	return dwReturnCode;
}

/////////////////////////////////////////////////////////////////////////
//
//Function: IsStandAloneFL()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN PIPSEC_FILTER_DATA pFilter,
//	IN HANDLE hPolicyStorage
//	IN OUT BOOL & bStandAlone
//
//Return: VOID
//
//Description:
//	This function checks whether the specified Filter List is unattached to any of the policies.
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

DWORD
IsStandAloneFL(
	IN PIPSEC_FILTER_DATA pFilter,
	IN HANDLE hPolicyStorage,
	IN OUT BOOL & bStandAlone
	)
{

	PIPSEC_POLICY_DATA *ppPolicyEnum = NULL,pPolicy=NULL;
	DWORD   dwNumPolicies = 0 , i =0;
	RPC_STATUS     RpcStat=RPC_S_OK;
	DWORD        dwReturnCode   = S_OK;

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		dwReturnCode = ERROR_SUCCESS;
		BAIL_OUT;  // if nothing found, bail out of the function
	}

	for (i = 0; i <  dwNumPolicies; i++)
	{
		dwReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &pPolicy);
		if (dwReturnCode == ERROR_SUCCESS)
		{
			dwReturnCode = IPSecEnumNFAData(hPolicyStorage, pPolicy->PolicyIdentifier, &(pPolicy->ppIpsecNFAData), &(pPolicy->dwNumNFACount));

			if (dwReturnCode == ERROR_SUCCESS)
			{
				DWORD j;
				for (j = 0; j <  pPolicy->dwNumNFACount; j++)
				{
					if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[j]->FilterIdentifier), &RpcStat))
					{
						dwReturnCode=IPSecGetFilterData(hPolicyStorage,	pPolicy->ppIpsecNFAData[j]->FilterIdentifier,&(pPolicy->ppIpsecNFAData[j]->pIpsecFilterData));
						if(dwReturnCode != ERROR_SUCCESS)
							PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_POLICY_4,pPolicy->pszIpsecName);
					}
					if (dwReturnCode != ERROR_SUCCESS)
					{
						bStandAlone=FALSE;
						break;
					}
				}
			}

			if(dwReturnCode == ERROR_SUCCESS)
			{
				for (DWORD n = 0; n <  pPolicy->dwNumNFACount; n++)
				{
					if (UuidCompare(&(pPolicy->ppIpsecNFAData[n]->pIpsecFilterData->FilterIdentifier), &(pFilter->FilterIdentifier), &RpcStat) == 0 && RpcStat == RPC_S_OK )
					{
						// check whether it is stand alone or used some where
						bStandAlone=FALSE;
						break;
					}
				}
			}
			if (pPolicy) IPSecFreePolicyData(pPolicy);
		}
		if ((!bStandAlone)||(dwReturnCode != ERROR_SUCCESS)) break;
	}
	//clean up
	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
error:
	return dwReturnCode;
}


//////////////////////////////////////////////////////////////////////////
//
//Function: PrintAllFilterData()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage,
//	IN LPTSTR  pszFlistName,
//	IN BOOL bVerbose,
//	IN BOOL bTable,
//	IN BOOL bResolveDNS,
//	IN BOOL bWide
//
//Return: DWORD
//
//Description:
//	This function prints out all the filter data
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

DWORD
PrintAllFilterData(
	IN HANDLE hPolicyStorage,
	IN LPTSTR  pszFlistName,
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN BOOL bResolveDNS,
	IN BOOL bWide
	)
{
	DWORD        dwReturnCode   = S_OK;
	BOOL bNoFilter=TRUE, bAll=TRUE;
	PIPSEC_FILTER_DATA *ppFilterEnum  = NULL,pFilter=NULL;
	DWORD   dwNumFilters=0;
	DWORD cnt=0;
	BOOL bTitlePrinted=FALSE;

	if (pszFlistName) bAll=FALSE;

	dwReturnCode = IPSecEnumFilterData(hPolicyStorage, &ppFilterEnum, &dwNumFilters);
	if (!(dwReturnCode == ERROR_SUCCESS && dwNumFilters > 0 && ppFilterEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_PRTALLFL_2);
		BAIL_OUT;   // if nothing exists, bail out of the function
	}
	for(cnt=0; cnt < dwNumFilters;cnt++)
	{
		dwReturnCode = IPSecCopyFilterData(ppFilterEnum[cnt], &pFilter);

		if ((dwReturnCode == ERROR_SUCCESS) && (pFilter != NULL))
		{
			//if exists , print the details
			if(bAll||((pFilter->pszIpsecName!=NULL)&&(pszFlistName!=NULL)&&(_tcscmp(pFilter->pszIpsecName,pszFlistName)==0)))
			{
				if(bTable)  // print as per the requested format
				{
					if(!bVerbose && !bTitlePrinted)
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_NONVERB_TITLE);
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTFILTERDATA_NONVERB_UNDERLINE);
						bTitlePrinted=TRUE;
					}
					PrintFilterDataTable(pFilter,bVerbose,bWide);
				}
				else
				{
					dwReturnCode = PrintFilterDataList(pFilter,bVerbose,bResolveDNS,bWide);
					BAIL_ON_WIN32_ERROR(dwReturnCode);
				}
				bNoFilter=FALSE;
			}
			if(pFilter) IPSecFreeFilterData(pFilter);
		}
		if (dwReturnCode != ERROR_SUCCESS) break;
	}

	if (bAll)  // if all is specified, print the count
	{
		if(bTable)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALLFL_FL_COUNT_TAB,dwNumFilters);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALLFL_FL_COUNT_LIST,dwNumFilters);
		}
	}

	//error message
	if (bNoFilter && pszFlistName && (dwReturnCode == ERROR_SUCCESS))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_PRTALLFL_3,pszFlistName);
	}
	//clean up
	if(ppFilterEnum && dwNumFilters>0)
	{
		IPSecFreeMulFilterData(	ppFilterEnum,dwNumFilters);
	}
error:
	return dwReturnCode;
}

//////////////////////////////////////////////////////////////////////////
//
//Function: PrintAllFilterActionData()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN HANDLE hPolicyStorage,
//	IN LPTSTR  pszFactName,
//	IN BOOL bVerbose,
//	IN BOOL bTable,
//	IN BOOL bWide
//
//Return: VOID
//
//Description:
//	This function prints out all the filter action data
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

DWORD
PrintAllFilterActionData(
	IN HANDLE hPolicyStorage,
	IN LPTSTR  pszFactName,
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN BOOL bWide
	)
{

	DWORD        dwReturnCode   = S_OK;
	PIPSEC_NEGPOL_DATA *ppNegPolEnum  = NULL,pNegPol=NULL;
	DWORD dwNumNegPol=0,dwNegPol=0;
	DWORD cnt=0;
	BOOL bAll=TRUE,bNoFilterAct=TRUE,bTitlePrinted=FALSE;

	if (pszFactName) bAll=FALSE;

	dwReturnCode = IPSecEnumNegPolData(hPolicyStorage, &ppNegPolEnum, &dwNumNegPol);

	if (!(dwReturnCode == ERROR_SUCCESS && dwNumNegPol > 0 && ppNegPolEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_PRTALLFA_6);
		BAIL_OUT;  // if nothing found, bail out
	}

	if (bAll)
	{
		for (DWORD Loop=0;Loop< dwNumNegPol;Loop++)
		{
			if(IsEqualGUID(ppNegPolEnum[Loop]->NegPolType,GUID_NEGOTIATION_TYPE_DEFAULT)) continue;
			dwNegPol++;  // ignore default filteractions
		}
	}
	for(cnt=0; cnt < dwNumNegPol ;cnt++)
	{
		dwReturnCode = IPSecCopyNegPolData(ppNegPolEnum[cnt], &pNegPol);

		if ((dwReturnCode == ERROR_SUCCESS) && (pNegPol != NULL))
		{
			//if something found, print them in requested format
			if((bAll&&(pNegPol->NegPolType!=GUID_NEGOTIATION_TYPE_DEFAULT))||((pNegPol->pszIpsecName!=NULL)&&(pszFactName!=NULL)&&(_tcscmp(pNegPol->pszIpsecName,pszFactName)==0)))
			{
				if(bTable)
				{
					if(!bVerbose && !bTitlePrinted)
					{
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_NONVERB_TITLE);
						PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTNEGPOL_NONVERB_UNDERLINE);
						bTitlePrinted=TRUE;
					}
					PrintNegPolDataTable(pNegPol,bVerbose,bWide); //table format
				}
				else
					PrintNegPolDataList(pNegPol,bVerbose,bWide); // list format
				bNoFilterAct=FALSE;
			}
			if(pNegPol) IPSecFreeNegPolData(pNegPol);
		}
		if (dwReturnCode != ERROR_SUCCESS) break;
	}
	//error messages
	if (bAll&& (dwNegPol==0) && (dwReturnCode == ERROR_SUCCESS))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_PRTALLFA_6);
	}
	else if	(bNoFilterAct&&pszFactName && (dwReturnCode == ERROR_SUCCESS))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_PRTALLFA_FA_COUNT_LIST,pszFactName);
	}

	if(dwNegPol> 0)  // negpol count printing
	{
		if(bTable)
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALLFA_FA_COUNT_TAB,dwNegPol);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_PRTALLFA_FA_COUNT_LIST,dwNegPol);
		}
	}
	//clean up
	if (dwNumNegPol > 0 && ppNegPolEnum != NULL)
	{
		IPSecFreeMulNegPolData(	ppNegPolEnum,dwNumNegPol);
	}

error:
	return dwReturnCode;
}


//////////////////////////////////////////////////////////////////////////
//
//Function: GetPolicyInfoFromDomain()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
// 		IN LPTSTR pszDirectoryName,
//		IN LPTSTR szPolicyDN
//
//Return: DWORD
//
//Description:
//	This function prints the details of GPO assigned policy from domain.
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

DWORD
GetPolicyInfoFromDomain(
	IN LPTSTR pszDirectoryName,
	IN LPTSTR szPolicyDN,
	IN OUT PGPO pGPO
	)
{

	DWORD dwReturnCode=ERROR_SUCCESS , dwStrLength = 0;
	LPTSTR pszDomainName=NULL;
	DWORD dwLocation=IPSEC_DIRECTORY_PROVIDER;
	_TCHAR szPathName[MAX_PATH] ={0};
	DWORD dwNumPolicies = 0, i =0;
	PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL ;
	HANDLE hPolicyStorage = NULL;
	LPWSTR pszPolicyIdentifier= new _TCHAR[POLICYGUID_STR_SIZE];
	if(pszPolicyIdentifier==NULL)
	{
		dwReturnCode=ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}

	PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
	DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY;

	//get domain and DC name

	DWORD hr = DsGetDcName(NULL,
				   NULL,
				   NULL,
				   NULL,
				   Flags,
				   &pDomainControllerInfo
				   ) ;
	if(hr==NO_ERROR && pDomainControllerInfo)
	{
		if(pDomainControllerInfo->DomainName)
		{
			dwStrLength = _tcslen(pDomainControllerInfo->DomainName);

			pGPO->pszDomainName= new _TCHAR[dwStrLength+1];
			if(pGPO->pszDomainName==NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			_tcsncpy(pGPO->pszDomainName,pDomainControllerInfo->DomainName,dwStrLength+1);
		}

		if(pDomainControllerInfo->DomainControllerName)
		{
			dwStrLength = _tcslen(pDomainControllerInfo->DomainControllerName);

			pGPO->pszDCName= new _TCHAR[dwStrLength+1];
			if(pGPO->pszDCName==NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			_tcsncpy(pGPO->pszDCName,pDomainControllerInfo->DomainControllerName,dwStrLength+1);
		}

		NetApiBufferFree(pDomainControllerInfo);  //free it after used
	}

	dwReturnCode = OpenPolicyStore(&hPolicyStorage);
	if (dwReturnCode != ERROR_SUCCESS)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_FAILED_POLSTORE_OPEN);
		dwReturnCode=ERROR_SUCCESS;
		BAIL_OUT;
	}

	dwReturnCode = IPSecEnumPolicyData(hPolicyStorage, &ppPolicyEnum, &dwNumPolicies);
	if (!(dwReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL))
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_NO_POLICY);
		dwReturnCode= ERROR_SUCCESS;
		BAIL_OUT;
	}

	//check for any domain policy which is assigned
	// if yes, copy the name and other details to local structure

	for (i = 0; i <  dwNumPolicies; i++)
	{
		DWORD dwReturn = StringFromGUID2(ppPolicyEnum[i]->PolicyIdentifier, pszPolicyIdentifier, POLICYGUID_STR_SIZE);
		if(dwReturn == 0)
		{
			dwReturnCode = ERROR_INVALID_DATA;
			BAIL_OUT;
		}
		ComputePolicyDN(pszDirectoryName, pszPolicyIdentifier, szPathName);

		if 	( szPathName[0] && szPolicyDN[0] && !_tcsicmp(szPolicyDN, szPathName))
		{
			pGPO->bActive=TRUE;
			if(ppPolicyEnum[i]->pszIpsecName)
			{
				dwStrLength = _tcslen(ppPolicyEnum[i]->pszIpsecName);

				pGPO->pszPolicyName = new _TCHAR[dwStrLength+1];
				if(pGPO->pszPolicyName==NULL)
				{
					dwReturnCode=ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}
				_tcsncpy(pGPO->pszPolicyName,ppPolicyEnum[i]->pszIpsecName,dwStrLength+1);
			}

			dwStrLength = _tcslen(szPolicyDN);

			pGPO->pszPolicyDNName=new _TCHAR[dwStrLength+1];
			if(pGPO->pszPolicyDNName==NULL)
			{
				dwReturnCode=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}
			_tcsncpy(pGPO->pszPolicyDNName,szPolicyDN,dwStrLength+1);
		}
	}
	// clean up
	if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
	{
		IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
	}
	if(dwReturnCode == ERROR_FILE_NOT_FOUND)
		dwReturnCode=ERROR_SUCCESS;

	ClosePolicyStore(hPolicyStorage);

error:
	if(pszPolicyIdentifier) delete []pszPolicyIdentifier;
	if(pszDomainName) delete []pszDomainName;

	return dwReturnCode;
}

//////////////////////////////////////////////////////////////////////////
//
//Function: PrintStorageInfoTable()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	VOID
//
//
//Return: DWORD
//
//Description:
//	This function prints out the the Security Methods information.
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

DWORD
PrintStorageInfoTable(
	VOID
	)
{
	DWORD dwReturn = ERROR_SUCCESS , dwStrLength = 0, dwStoreId = 0;

	if(g_StorageLocation.dwLocation!=IPSEC_DIRECTORY_PROVIDER)
	{
		if(_tcscmp(g_StorageLocation.pszMachineName,_TEXT(""))!=0)  // if name exists in global variable, print
		{
    	    if (g_StorageLocation.dwLocation == IPSEC_REGISTRY_PROVIDER)
    	    {
    	        dwStoreId = SHW_STATIC_TAB_POLICY_STORE_RM_NAME;
    	    }
    	    else
    	    {
    	        dwStoreId = SHW_STATIC_TAB_POLICY_STORE_RM_NAMEP;
    	    }

			PrintMessageFromModule(g_hModule,dwStoreId,g_StorageLocation.pszMachineName);
		}
		else  // if no name exists in global variable, get it and print
		{
			_TCHAR  pszLocalMachineName[MAXSTRLEN] = {0};
			DWORD MaxStringLen=MAXSTRLEN;

			GetComputerName(pszLocalMachineName,&MaxStringLen);  // to get the computer name

			if(_tcscmp(pszLocalMachineName,_TEXT(""))!=0)
			{
        	    if (g_StorageLocation.dwLocation == IPSEC_REGISTRY_PROVIDER)
        	    {
        	        dwStoreId = SHW_STATIC_TAB_POLICY_STORE_LM_NAME;
        	    }
        	    else
        	    {
        	        dwStoreId = SHW_STATIC_TAB_POLICY_STORE_LM_NAMEP;
        	    }

				PrintMessageFromModule(g_hModule,dwStoreId,pszLocalMachineName);
		    }
			else
			{
        	    if (g_StorageLocation.dwLocation == IPSEC_REGISTRY_PROVIDER)
        	    {
        	        dwStoreId = SHW_STATIC_TAB_POLICY_STORE_LM;
        	    }
        	    else
        	    {
        	        dwStoreId = SHW_STATIC_TAB_POLICY_STORE_LP;
        	    }

				PrintMessageFromModule(g_hModule,dwStoreId);
		    }
		}
	}
	else if(g_StorageLocation.dwLocation==IPSEC_DIRECTORY_PROVIDER)
	{
		if(_tcscmp(g_StorageLocation.pszDomainName,_TEXT(""))!=0)
		{
			// if name exists in global variable, print
			PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_POLICY_STORE_RD_NAME,g_StorageLocation.pszDomainName);
		}
		else
		{
			// if no name exists in global variable, get it and print
			PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
			LPTSTR pszDomainName = NULL;

			DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY;

			// to get the DOMAIN name

			DWORD hr = DsGetDcName(NULL,
						   NULL,
						   NULL,
						   NULL,
						   Flags,
						   &pDomainControllerInfo
						   ) ;

			if(hr==NO_ERROR && pDomainControllerInfo && pDomainControllerInfo->DomainName)
			{
				dwStrLength = _tcslen(pDomainControllerInfo->DomainName);
				pszDomainName= new _TCHAR[dwStrLength+1];
				if(pszDomainName == NULL)
				{
					dwReturn = ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}
				_tcsncpy(pszDomainName,pDomainControllerInfo->DomainName,dwStrLength+1);
			}

			if (pDomainControllerInfo)
			{
				NetApiBufferFree(pDomainControllerInfo);
			}

			if(pszDomainName)
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_POLICY_STORE_LD_NAME,pszDomainName);
			}
			else
			{
				PrintMessageFromModule(g_hModule,SHW_STATIC_TAB_POLICY_STORE_LD);
			}

			if(pszDomainName) delete [] pszDomainName;
		}
	}
error:
	return dwReturn;

}

//////////////////////////////////////////////////////////////////////////
//
//Function: TruncateString()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LPTSTR pszOriginalString,
//	IN OUT LPTSTR  &pszReturnString,
//	IN DWORD dwTruncLen,
//	IN BOOL bWide
//
//
//Return: VOID
//
//Description:
//	This function prints out the the Security Methods information.
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

VOID
TruncateString(
	IN LPTSTR pszOriginalString,
	IN OUT LPOLESTR pszReturnString,
	IN DWORD dwTruncLen,
	IN BOOL bWide
	)
{

	//this truncates the string to the requested extent
	_tcsncpy(pszReturnString,pszOriginalString,BUFFER_SIZE-1);

	if(!bWide && (DWORD)_tcslen(pszOriginalString)> dwTruncLen)
	{
		pszReturnString[dwTruncLen]= _TEXT('\0');
		pszReturnString[dwTruncLen-1]= _TEXT('.');
		pszReturnString[dwTruncLen-2]= _TEXT('.');
		pszReturnString[dwTruncLen-3]= _TEXT('.');
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticshowutils.h ===
///////////////////////////////////////////////////////////////////////////
//Header: staticshowutils.h
//
// Purpose: 	Defining structures and prototypes for statishowutils.cpp.
//
// Developers Name: surya
//
// History:
//
//   Date    		Author    	Comments
//	21th Aug 2001	surya		Initial Version.
//
///////////////////////////////////////////////////////////////////////////

#ifndef _STATICSHOWUTIS_H_
#define _STATICSHOWUTIS_H_

#define POLICYGUID_STR_SIZE 512

#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {\
        goto error; \
    }

#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) {\
        goto error; \
    }

#define MAXSTRINGLEN	(1024)
#define MAXSTRLEN	(2048)
#define STRING_SIZE 16
#define STRING_TEXT_SIZE   1024
#define STR_TEXT_SIZE   256

typedef struct
{
	int     iPolicySource;  			// one of the three constants mentioned above
	LPTSTR  pszMachineName;				//
	DWORD   dwLocation;					//
	_TCHAR   pszPolicyName[MAXSTRINGLEN]; 	// policy name
	_TCHAR   pszPolicyDesc[MAXSTRINGLEN]; 	// policy description
	_TCHAR   pszPolicyPath[MAXSTRLEN]; 	// policy path (DN or RegKey)
	_TCHAR   pszOU[MAXSTRLEN];         	// OU or GPO
	_TCHAR   pszGPOName[MAXSTRINGLEN];    	// policy path (DN or RegKey)
	GUID *  pGuid;						//
	time_t  timestamp;                	// last updated time
} POLICY_INFO, *PPOLICY_INFO;

typedef struct _GPO{
	LPTSTR pszGPODisplayName;
	LPTSTR pszGPODNName;
	LPTSTR pszPolicyName;
	LPTSTR pszLocalPolicyName;
	LPTSTR pszPolicyDNName;
	BOOL   bActive;
	BOOL   bDNPolicyOverrides;
	LPTSTR pszDomainName;
	LPTSTR pszDCName;
	LPTSTR pszOULink;
	_TCHAR  pszLocalMachineName[MAXSTRLEN];
} GPO, *PGPO;

//
// policy source constants
//
#define PS_NO_POLICY  0
#define PS_DS_POLICY  1
#define PS_LOC_POLICY 2

DWORD
ShowAssignedGpoPolicy(
	IN LPTSTR szGpoName,
	IN PGPO pGPO
	);

DWORD
ShowLocalGpoPolicy(
	POLICY_INFO &policyInfo,
	PGPO pGPO
	);

DWORD
CreateIWbemServices(
    IN LPWSTR pszIpsecWMINamespace,
    OUT IWbemServices **ppWbemServices
    );

DWORD
GetPolicyInfo (
	IN LPTSTR pszMachineName,
	OUT POLICY_INFO &m_PolicyInfo
	);

DWORD
GetMorePolicyInfo (
	IN LPTSTR pszMachineName,
	OUT POLICY_INFO &m_PolicyInfo
	);

DWORD
GetActivePolicyInfo(
	IN LPTSTR pszMachineName,
	OUT POLICY_INFO &m_PolicyInfo
	);

PGROUP_POLICY_OBJECT
GetIPSecGPO (
	IN LPTSTR pszMachineName
	);

VOID
StringToGuid(
	IN LPTSTR szValue,
	OUT GUID * pGuid
	);

DWORD
ComputePolicyDN(
    IN LPWSTR pszDirDomainName,
	IN LPWSTR pszPolicyIdentifier,
    OUT LPWSTR pszPolicyDN
    );

HRESULT
GetIPSECPolicyDN(
    IN LPWSTR pszMachinePath,
    OUT LPWSTR pszPolicyDN
    );

HRESULT
GetGpoDsPath(
	IN LPTSTR szGpoId,
	OUT LPTSTR szGpoDsPath
	);

HRESULT
FormatTime(
	IN time_t t,
	OUT LPTSTR pszTimeStr
	);

INT 
WcsCmp0(
    IN PWSTR pszString1,
    IN PWSTR pszString2);

VOID
DisplayCertInfo(
	LPTSTR pszCertName,
	DWORD dwFlags
	);
	
#endif //_STATICSHOWUTIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticshowtable.h ===
/////////////////////////////////////////////////////////////////////////////////
//Header: staticshowtable.h
//
//Purpose: 	Defining structures and prototypes for statishow.cpp.
//
//Developers Name: surya
//
//History:
//
// Date    		Author    	Comments
// 10-8-2001	Surya		Initial Version. SCM Base line 1.0
//
//
//////////////////////////////////////////////////////////////////////////////////

#ifndef _STATICSHOWTABLE_H_
#define _STATICSHOWTABLE_H_

const DWORD POL_TRUNC_LEN_TABLE_NVER 	=  39;	// Truncation for Non Verbose Mode
const DWORD POL_TRUNC_LEN_TABLE_VER 	=  54;	// Truncation for Verbose Mode
const DWORD RUL_TRUNC_LEN_TABLE_NVER 	=  23;	// Truncation for Non Verbose Mode
const DWORD FA_TRUNC_LEN_TABLE_NVER 	=  38;	// Truncation for Non Verbose Mode
const DWORD FL_TRUNC_LEN_TABLE_NVER 	=  45;	// Truncation for Non Verbose Mode

//
//Function Declarations
//
extern BOOL
IsDomainMember(
	IN LPTSTR pszMachine
	);

VOID
PrintPolicyTable(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN BOOL bVerb,
	IN BOOL bAssigned,
	IN BOOL bWide
	);

VOID
PrintIPAddrTable(
	IN DWORD dwAddr
	);

DWORD
PrintFilterDataTable(
	IN PIPSEC_FILTER_DATA pIpsecFilterData,
	IN BOOL bVerb,
	IN BOOL bWide
	);

DWORD
PrintFilterSpecTable(
	IN PIPSEC_FILTER_SPEC pIpsecFilterSpec
	);

VOID
PrintFilterTable(
	IN IPSEC_FILTER Filter,
	IN PFILTERDNS pFilterDNS
	);

VOID
GetFilterDNSDetails(
	IN PIPSEC_FILTER_SPEC pFilterData,
	IN OUT PFILTERDNS pFilterDNS
	);

VOID
PrintProtocolNameTable(
	IN  DWORD dwProtocol
	);

VOID
PrintRuleTable(
	IN PIPSEC_NFA_DATA pIpsecNFAData,
	IN BOOL bVerb,
	IN BOOL bWide
	);

VOID
PrintNegPolDataTable(
	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData,
	IN BOOL bVerb,
	IN BOOL bWide
	);

VOID
PrintAuthMethodsTable(
	IN PIPSEC_AUTH_METHOD pIpsecAuthData
	);

VOID
PrintISAKMPDataTable(
	IN PIPSEC_ISAKMP_DATA pIpsecISAKMPData
	);

VOID
PrintISAKAMPSecurityMethodsTable(
	IN CRYPTO_BUNDLE SecurityMethods
	);

VOID
PrintISAKMPPolicyTable(
	IN ISAKMP_POLICY ISAKMPPolicy,
	IN BOOL bVerb
	);

VOID
PrintLifeTimeTable(
	IN LIFETIME LifeTime
	);

VOID
PrintAlgoInfoTable(
	IN PIPSEC_ALGO_INFO   Algos,
	IN DWORD dwNumAlgos
	);

VOID
PrintSecurityMethodsTable(
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods
	);

BOOL
CheckSoft(
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods
	);

DWORD
IsAssigned(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN HANDLE hStorage,
	IN OUT BOOL &bAssigned
	);

DWORD
PrintStandAloneFAData(
	IN HANDLE hPolicyStorage,
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN BOOL bWide
	);

DWORD
IsStandAloneFA(
	IN PIPSEC_NEGPOL_DATA pNegPol,
	IN HANDLE hPolicyStorage,
	IN OUT BOOL & bStandAlone
	);

DWORD
PrintAllFilterActionData(
	IN HANDLE hPolicyStorage,
	IN LPTSTR  pszFactName,
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN BOOL bWide
	);


DWORD
PrintAllFilterData(
	IN HANDLE hPolicyStorage,
	IN LPTSTR  pszFlistName,
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN BOOL bResolveDNS,
	IN BOOL bWide
	);

DWORD
PrintStandAloneFLData(
	IN HANDLE hPolicyStorage,
	IN BOOL bVerbose,
	IN BOOL bTable,
	IN BOOL bWide
	);

DWORD
IsStandAloneFL(
	IN PIPSEC_FILTER_DATA pFilter,
	IN HANDLE hPolicyStorage,
	IN OUT BOOL & bStandAlone
	);


DWORD
GetPolicyInfoFromDomain(
	IN LPTSTR pszDirectoryName,
	IN LPTSTR szPolicyDN,
	IN OUT PGPO pGPO
	);

DWORD
PrintStorageInfoTable(
	VOID
	);

VOID
TruncateString(
	IN LPTSTR pszOriginalString,
	IN OUT LPOLESTR pszReturnString,
	IN DWORD dwTruncLen,
	IN BOOL bWide
	);

#endif //_STATICSHOWTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\dsstore.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       dsstore.c
//
//  Contents:   Policy management for directory.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

LPWSTR gpszIpSecContainer = L"CN=IP Security,CN=System,DC=ntdev,DC=microsoft,DC=com";
LPWSTR PolicyDNAttributes[] = {
                                L"ipsecID",
                                L"description",
                                L"ipsecDataType",
                                L"ipsecISAKMPReference",
                                L"ipsecData",
                                L"ipsecNFAReference",
                                L"ipsecName",
                                L"distinguishedName",
                                L"whenChanged",
                                NULL
                                };

LPWSTR NFADNAttributes[] = {
                                L"distinguishedName",
                                L"description",
                                L"ipsecName",
                                L"ipsecID",
                                L"ipsecDataType",
                                L"ipsecData",
                                L"ipsecOwnersReference",
                                L"ipsecFilterReference",
                                L"ipsecNegotiationPolicyReference",
                                L"whenChanged",
                                NULL
                                };

LPWSTR FilterDNAttributes[] = {
                                L"distinguishedName",
                                L"description",
                                L"ipsecName",
                                L"ipsecID",
                                L"ipsecDataType",
                                L"ipsecData",
                                L"ipsecOwnersReference",
                                L"whenChanged",
                                NULL
                                };

LPWSTR NegPolDNAttributes[] = {
                                L"distinguishedName",
                                L"description",
                                L"ipsecName",
                                L"ipsecID",
                                L"ipsecDataType",
                                L"ipsecData",
                                L"ipsecNegotiationPolicyAction",
                                L"ipsecNegotiationPolicyType",
                                L"ipsecOwnersReference",
                                L"whenChanged",
                                NULL
                                };

LPWSTR ISAKMPDNAttributes[] = {
                                L"distinguishedName",
                                L"ipsecName",
                                L"ipsecID",
                                L"ipsecDataType",
                                L"ipsecData",
                                L"ipsecOwnersReference",
                                L"whenChanged",
                                NULL
                                };







DWORD
OpenDirectoryServerHandle(
    LPWSTR pszDomainName,
    DWORD dwPortNumber,
    HLDAP * phLdapBindHandle
    )
{
    DWORD dwError = 0;


    *phLdapBindHandle = NULL;

    dwError = LdapOpen(
                pszDomainName,
                dwPortNumber,
                phLdapBindHandle
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapBind(
                *phLdapBindHandle
                );
    BAIL_ON_WIN32_ERROR(dwError);

    return(dwError);

error:

    if (*phLdapBindHandle) {
        CloseDirectoryServerHandle(
            *phLdapBindHandle
            );
        *phLdapBindHandle = NULL;
    }

    return(dwError);
}

DWORD
CloseDirectoryServerHandle(
    HLDAP hLdapBindHandle
    )
{

    int ldaperr = 0;

    if (hLdapBindHandle) {

        ldaperr = ldap_unbind(hLdapBindHandle);

    }

    return(0);
}



DWORD
ShallowReadPolicyObjectFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPWSTR szFilterString = L"(objectClass=*)";
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszPolicyDN,
                  LDAP_SCOPE_BASE,
                  szFilterString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject(
                    hLdapBindHandle,
                    pszPolicyDN,
                    &pIpsecPolicyObject,
                    res
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->ppIpsecNFAObjects = NULL;
    pIpsecPolicyObject->NumberofRulesReturned = 0;
    pIpsecPolicyObject->NumberofFilters = 0;
    pIpsecPolicyObject->ppIpsecFilterObjects = NULL;
    pIpsecPolicyObject->ppIpsecNegPolObjects = NULL;
    pIpsecPolicyObject->NumberofNegPols = 0;
    pIpsecPolicyObject->NumberofISAKMPs = 0;
    pIpsecPolicyObject->ppIpsecISAKMPObjects = NULL;

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:
    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;

    goto cleanup;

}

DWORD
ReadPolicyObjectFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPWSTR szFilterString = L"(objectClass=*)";
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    DWORD dwNumNFAObjectsReturned = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    LPWSTR * ppszFilterReferences = NULL;
    DWORD dwNumFilterReferences = 0;
    LPWSTR * ppszNegPolReferences = NULL;
    DWORD dwNumNegPolReferences = 0;

    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    DWORD dwNumFilterObjects = 0;

    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    DWORD dwNumNegPolObjects = 0;

    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    DWORD dwNumISAKMPObjects = 0;

    LPWSTR pszPolicyContainer = NULL;

    dwError = ComputePolicyContainerDN(
                  pszPolicyDN,
                  &pszPolicyContainer
                  );

    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszPolicyDN,
                  LDAP_SCOPE_BASE,
                  szFilterString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject(
                    hLdapBindHandle,
                    pszPolicyDN,
                    &pIpsecPolicyObject,
                    res
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadNFAObjectsFromDirectory(
                        hLdapBindHandle,
                        pszPolicyContainer,
                        pIpsecPolicyObject->pszIpsecOwnersReference,
                        pIpsecPolicyObject->ppszIpsecNFAReferences,
                        pIpsecPolicyObject->NumberofRules,
                        &ppIpsecNFAObjects,
                        &dwNumNFAObjectsReturned,
                        &ppszFilterReferences,
                        &dwNumFilterReferences,
                        &ppszNegPolReferences,
                        &dwNumNegPolReferences
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadFilterObjectsFromDirectory(
                        hLdapBindHandle,
                        pszPolicyContainer,
                        ppszFilterReferences,
                        dwNumFilterReferences,
                        &ppIpsecFilterObjects,
                        &dwNumFilterObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadNegPolObjectsFromDirectory(
                        hLdapBindHandle,
                        pszPolicyContainer,
                        ppszNegPolReferences,
                        dwNumNegPolReferences,
                        &ppIpsecNegPolObjects,
                        &dwNumNegPolObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadISAKMPObjectsFromDirectory(
                        hLdapBindHandle,
                        pszPolicyContainer,
                        &pIpsecPolicyObject->pszIpsecISAKMPReference,
                        1,
                        &ppIpsecISAKMPObjects,
                        &dwNumISAKMPObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->ppIpsecNFAObjects = ppIpsecNFAObjects;
    pIpsecPolicyObject->NumberofRulesReturned = dwNumNFAObjectsReturned;
    pIpsecPolicyObject->NumberofFilters = dwNumFilterObjects;
    pIpsecPolicyObject->ppIpsecFilterObjects = ppIpsecFilterObjects;
    pIpsecPolicyObject->ppIpsecNegPolObjects = ppIpsecNegPolObjects;
    pIpsecPolicyObject->NumberofNegPols = dwNumNegPolObjects;
    pIpsecPolicyObject->NumberofISAKMPs = dwNumISAKMPObjects;
    pIpsecPolicyObject->ppIpsecISAKMPObjects = ppIpsecISAKMPObjects;


    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (pszPolicyContainer) {
        FreePolStr(pszPolicyContainer);
    }
    
    if (res) {
        LdapMsgFree(res);
    }

    if (ppszFilterReferences) {

        FreeFilterReferences(
                ppszFilterReferences,
                dwNumFilterReferences
                );
    }

    if (ppszNegPolReferences) {

        FreeNegPolReferences(
                ppszNegPolReferences,
                dwNumNegPolReferences
                );
    }

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;

    goto cleanup;

}


DWORD
ReadNFAObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecOwnerReference,
    LPWSTR * ppszNFADNs,
    DWORD dwNumNfaObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNfaObjects,
    LPWSTR ** pppszFilterReferences,
    PDWORD pdwNumFilterReferences,
    LPWSTR ** pppszNegPolReferences,
    PDWORD pdwNumNegPolReferences
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszFilterString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    BOOL bNewNegPolReference = TRUE;    
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    LPWSTR * ppszFilterReferences = NULL;
    LPWSTR * ppszNegPolReferences = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;
    DWORD dwNumFilterReferences = 0;
    DWORD dwNumNegPolReferences = 0;




    DWORD dwNumNFAObjectsReturned = 0;

    dwError = GenerateNFAQuery(
                    ppszNFADNs,
                    dwNumNfaObjects,
                    &pszFilterString
                    );


    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecNFAObjects  = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NFA_OBJECT)*dwCount
                                            );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszFilterReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwCount
                                        );
    if (!ppszFilterReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    ppszNegPolReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwCount
                                        );
    if (!ppszNegPolReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );

        }

        dwError =UnMarshallNFAObject(
                    hLdapBindHandle,
                    e,
                    &pIpsecNFAObject,
                    &pszFilterReference,
                    &pszNegPolReference
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNFAObjects + dwNumNFAObjectsReturned) = pIpsecNFAObject;

            if (pszFilterReference) {

                *(ppszFilterReferences + dwNumFilterReferences) = pszFilterReference;
                dwNumFilterReferences++;

            }

            if (pszNegPolReference) {
                bNewNegPolReference = !(IsStringInArray(
                                            ppszNegPolReferences,
                                            pszNegPolReference,
                                            dwNumNegPolReferences
                                        ));
                
                if (bNewNegPolReference) {
                    *(ppszNegPolReferences + dwNumNegPolReferences) = pszNegPolReference;
                    dwNumNegPolReferences++;
                } else {
                    FreePolStr(pszNegPolReference);
                    pszNegPolReference = NULL;
                }    
            }

            dwNumNFAObjectsReturned++;

        }


    }

    if (dwNumNFAObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppszFilterReferences = ppszFilterReferences;
    *pppszNegPolReferences = ppszNegPolReferences;

    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNfaObjects = dwNumNFAObjectsReturned;
    *pdwNumNegPolReferences = dwNumNegPolReferences;
    *pdwNumFilterReferences = dwNumFilterReferences;

    dwError = ERROR_SUCCESS;

cleanup:


    if (res) {
        LdapMsgFree(res);
    }


    if (pszFilterString) {
        FreePolStr(pszFilterString);
    }

    return(dwError);


error:
    if (ppszNegPolReferences) {
        FreeNegPolReferences(
                ppszNegPolReferences,
                dwNumNFAObjectsReturned
                );
    }


    if (ppszFilterReferences) {
        FreeFilterReferences(
                ppszFilterReferences,
                dwNumNFAObjectsReturned
                );
    }

    if (ppIpsecNFAObjects) {

        FreeIpsecNFAObjects(
                ppIpsecNFAObjects,
                dwNumNFAObjectsReturned
                );

    }

    *pppszNegPolReferences = NULL;
    *pppszFilterReferences = NULL;
    *pdwNumNegPolReferences = 0;
    *pdwNumFilterReferences = 0;
    *pppIpsecNFAObjects = NULL;
    *pdwNumNfaObjects = 0;

    goto cleanup;
}

DWORD
ReadFilterObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszFilterString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;

    DWORD dwNumFilterObjectsReturned = 0;

    //
    // It is possible to have zero filter objects - if we have
    // a single rule with no filters in it, then we should return
    // success with zero filters.
    //

    if (!dwNumFilterObjects) {

        *pppIpsecFilterObjects = 0;
        *pdwNumFilterObjects = 0;

        return(ERROR_SUCCESS);
    }

    dwError = GenerateFilterQuery(
                    ppszFilterDNs,
                    dwNumFilterObjects,
                    &pszFilterString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  FilterDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecFilterObjects  = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_FILTER_OBJECT)*dwCount
                                            );
    if (!ppIpsecFilterObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );

        }

        dwError =UnMarshallFilterObject(
                    hLdapBindHandle,
                    e,
                    &pIpsecFilterObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;
            dwNumFilterObjectsReturned++;

        }


    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    if (res) {

        LdapMsgFree(res);
    }



    return(dwError);


error:

    if (ppIpsecFilterObjects) {

        FreeIpsecFilterObjects(
                    ppIpsecFilterObjects,
                    dwNumFilterObjectsReturned
                    );
    }

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    goto cleanup;
}

DWORD
ReadNegPolObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszNegPolString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumNegPolObjectsReturned = 0;

    dwError = GenerateNegPolQuery(
                    ppszNegPolDNs,
                    dwNumNegPolObjects,
                    &pszNegPolString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNegPolString,
                  NegPolDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecNegPolObjects  = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NEGPOL_OBJECT)*dwCount
                                            );

    if (!ppIpsecNegPolObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );

        }

        dwError =UnMarshallNegPolObject(
                    hLdapBindHandle,
                    e,
                    &pIpsecNegPolObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;
            dwNumNegPolObjectsReturned++;

        }


    }
    if (dwNumNegPolObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;


    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    if (res) {
        LdapMsgFree(res);
    }


    return(dwError);


error:

    if (ppIpsecNegPolObjects) {

        FreeIpsecNegPolObjects(
                    ppIpsecNegPolObjects,
                    dwNumNegPolObjectsReturned
                    );
    }

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    goto cleanup;
}

DWORD
ReadISAKMPObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszISAKMPString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;

    DWORD dwNumISAKMPObjectsReturned = 0;

    dwError = GenerateISAKMPQuery(
                    ppszISAKMPDNs,
                    dwNumISAKMPObjects,
                    &pszISAKMPString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszISAKMPString,
                  ISAKMPDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecISAKMPObjects  = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_ISAKMP_OBJECT)*dwCount
                                            );
    if (!ppIpsecISAKMPObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );

        }

        dwError =UnMarshallISAKMPObject(
                    hLdapBindHandle,
                    e,
                    &pIpsecISAKMPObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;

            dwNumISAKMPObjectsReturned++;

        }


    }

    if (dwNumISAKMPObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    if (res) {
        LdapMsgFree(res);
    }


    return(dwError);


error:

    if (ppIpsecISAKMPObjects) {

        FreeIpsecISAKMPObjects(
                    ppIpsecISAKMPObjects,
                    dwNumISAKMPObjectsReturned
                    );
    }

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    goto cleanup;
}



DWORD
UnMarshallPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject,
    LDAPMessage *res
    )
{
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    LDAPMessage *e = NULL;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR * ppszTemp = NULL;
    time_t t_WhenChanged = 0;

    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    dwError = LdapFirstEntry(
                    hLdapBindHandle,
                    res,
                    &e
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    /*
    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                                        pszPolicyDN
                                                        );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecPolicyObject->pszDescription = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GeneralizedTimeToTime(
                LDAPOBJECT_STRING((PLDAPOBJECT)strvalues),
                &t_WhenChanged
                );
    pIpsecPolicyObject->dwWhenChanged = TIME_T_TO_DWORD(t_WhenChanged);
    LdapValueFree(strvalues);
    BAIL_ON_WIN32_ERROR(dwError);                    

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecISAKMPReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecISAKMPReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecISAKMPReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecPolicyObject->pIpsecData = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNFAReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwCount; i++) {

        ppszTemp = (strvalues + i);
        //
        // Unmarshall all the values you can possibly have
        //
        pszIpsecNFAName = AllocPolStr(*ppszTemp);
        if (!pszIpsecNFAName) {
            dwError = ERROR_OUTOFMEMORY;

            pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
            pIpsecPolicyObject->NumberofRules = i;

            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszIpsecNFAName;

    }


    pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
    pIpsecPolicyObject->NumberofRules = dwCount;
    LdapValueFree(strvalues);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    *ppIpsecPolicyObject = NULL;

    return(dwError);
}



DWORD
UnMarshallNFAObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    )
{
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR * ppszTemp = NULL;

    LPWSTR pszTempFilterReference = NULL;
    LPWSTR pszTempNegPolReference = NULL;
    time_t t_WhenChanged = 0;

    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                sizeof(IPSEC_NFA_OBJECT)
                                );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    //
    // Client does not always write the Name for an NFA.
    //

    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecNFAObject->pszIpsecName = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecNFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecNFAObject->pszIpsecName = NULL;
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecNFAObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecNFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecNFAObject->pszDescription = NULL;
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecNFAObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

     dwError = GeneralizedTimeToTime(
                   LDAPOBJECT_STRING((PLDAPOBJECT)strvalues),
                   &t_WhenChanged
                   );
    pIpsecNFAObject->dwWhenChanged = TIME_T_TO_DWORD(t_WhenChanged);
    LdapValueFree(strvalues);                   
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecNFAObject->pIpsecData = pBuffer;
    pIpsecNFAObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecOwnersReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    //BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError && strvalues) {

        pIpsecNFAObject->pszIpsecOwnersReference = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecNFAObject->pszIpsecOwnersReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNegotiationPolicyReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->pszIpsecNegPolReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecNFAObject->pszIpsecNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecFilterReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues) {

        pIpsecNFAObject->pszIpsecFilterReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
        if (!pIpsecNFAObject->pszIpsecFilterReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }


        pszTempFilterReference = AllocPolStr(
                                pIpsecNFAObject->pszIpsecFilterReference
                                );
        if (!pszTempFilterReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        pIpsecNFAObject->pszIpsecFilterReference = NULL;
    }
    pszTempNegPolReference = AllocPolStr(
                                 pIpsecNFAObject->pszIpsecNegPolReference
                                 );
    if (!pszTempNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    *ppszFilterReference = pszTempFilterReference;
    *ppszNegPolReference = pszTempNegPolReference;

    *ppIpsecNFAObject = pIpsecNFAObject;


    return(0);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszTempFilterReference) {
        FreePolStr(pszTempFilterReference);
    }

    if (pszTempNegPolReference) {
        FreePolStr(pszTempNegPolReference);
    }

    *ppIpsecNFAObject = NULL;
    *ppszFilterReference = NULL;
    *ppszNegPolReference = NULL;

    return(dwError);
}


DWORD
UnMarshallFilterObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecFilterNames = NULL;
    LPWSTR pszIpsecFilterName = NULL;
    LPWSTR * ppszTemp = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    time_t t_WhenChanged = 0;

    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                sizeof(IPSEC_FILTER_OBJECT)
                                );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError && strvalues) {

        pIpsecFilterObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError && strvalues) {

        pIpsecFilterObject->pszIpsecName = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecFilterObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GeneralizedTimeToTime(
                    LDAPOBJECT_STRING((PLDAPOBJECT)strvalues),
                    &t_WhenChanged
                    );
    pIpsecFilterObject->dwWhenChanged = TIME_T_TO_DWORD(t_WhenChanged);
    LdapValueFree(strvalues);                    
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecFilterObject->pIpsecData = pBuffer;
    pIpsecFilterObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecOwnersReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    if (!dwError && strvalues) {

        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        for (i = 0; i < dwCount; i++) {

            ppszTemp = (strvalues + i);
            //
            // Unmarshall all the values you can possibly have
            //
            pszIpsecNFAName = AllocPolStr(*ppszTemp);
            if (!pszIpsecNFAName) {
                dwError = ERROR_OUTOFMEMORY;

                pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecFilterObject->dwNFACount = i;

                BAIL_ON_WIN32_ERROR(dwError);
            }
            *(ppszIpsecNFANames + i) = pszIpsecNFAName;

        }

        pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecFilterObject->dwNFACount = dwCount;
        LdapValueFree(strvalues);

    }

    *ppIpsecFilterObject = pIpsecFilterObject;

    return(0);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    *ppIpsecFilterObject = NULL;

    return(dwError);
}


DWORD
UnMarshallNegPolObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_NEGPOL_OBJECT * ppIpsecPolicyObject
    )
{

    PIPSEC_NEGPOL_OBJECT pIpsecPolicyObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR * ppszTemp = NULL;
    time_t t_WhenChanged = 0;
    

    pIpsecPolicyObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                sizeof(IPSEC_NEGPOL_OBJECT)
                                );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszDistinguishedName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    //
    // Names do not get written on an NegPol Object.
    //

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecPolicyObject->pszIpsecName = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecPolicyObject->pszDescription = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNegotiationPolicyAction",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecNegPolAction = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecNegPolAction) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNegotiationPolicyType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecNegPolType = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecNegPolType) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecOwnersReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );

    if (!dwError && strvalues) {

        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        for (i = 0; i < dwCount; i++) {

            ppszTemp = (strvalues + i);
            //
            // Unmarshall all the values you can possibly have
            //
            pszIpsecNFAName = AllocPolStr(*ppszTemp);
            if (!pszIpsecNFAName) {
                dwError = ERROR_OUTOFMEMORY;

                pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecPolicyObject->dwNFACount = i;


                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFANames + i) = pszIpsecNFAName;
        }

        pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecPolicyObject->dwNFACount =  dwCount;
        LdapValueFree(strvalues);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GeneralizedTimeToTime(
                    LDAPOBJECT_STRING((PLDAPOBJECT)strvalues),
                    &t_WhenChanged
                    );
    pIpsecPolicyObject->dwWhenChanged = TIME_T_TO_DWORD(t_WhenChanged);
    LdapValueFree(strvalues);
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecPolicyObject->pIpsecData = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

    return(0);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecNegPolObject(pIpsecPolicyObject);
    }

    *ppIpsecPolicyObject = NULL;

    return(dwError);
}


DWORD
UnMarshallISAKMPObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{

    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecISAKMPNames = NULL;
    LPWSTR pszIpsecISAKMPName = NULL;
    LPWSTR * ppszTemp = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    time_t t_WhenChanged = 0;

    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                sizeof(IPSEC_ISAKMP_OBJECT)
                                );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );

    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);
    //
    // Names are not set for ISAKMP objects.
    //

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecISAKMPObject->pszIpsecName = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
    } else {
        pIpsecISAKMPObject->pszIpsecName = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecISAKMPObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = GeneralizedTimeToTime(
                    LDAPOBJECT_STRING((PLDAPOBJECT)strvalues),
                    &t_WhenChanged
                    );
    pIpsecISAKMPObject->dwWhenChanged = TIME_T_TO_DWORD(t_WhenChanged);
    LdapValueFree(strvalues);                    
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecISAKMPObject->pIpsecData = pBuffer;
    pIpsecISAKMPObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecOwnersReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    //
    // ipsecOwnersReference not written.
    //

    if (!dwError && strvalues) {

        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        for (i = 0; i < dwCount; i++) {

            ppszTemp = (strvalues + i);

            //
            // Unmarshall all the values you can possibly have
            //
            pszIpsecNFAName = AllocPolStr(*ppszTemp);
            if (!pszIpsecNFAName) {
                dwError = ERROR_OUTOFMEMORY;

                pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecISAKMPObject->dwNFACount = i;

                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFANames + i) = pszIpsecNFAName;

        }

        pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecISAKMPObject->dwNFACount = dwCount;
        LdapValueFree(strvalues);
    }

    *ppIpsecISAKMPObject = pIpsecISAKMPObject;

    return(0);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }

    *ppIpsecISAKMPObject = NULL;

    return(dwError);
}


DWORD
GenerateFilterQuery(
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    LPWSTR * ppszQueryBuffer
    )
{
    DWORD i = 0;
    WCHAR szCommonName[512];
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszQueryBuffer = NULL;

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecFilter)");

    dwLength += wcslen(L"(|");

    for (i = 0; i < dwNumFilterObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszFilterDNs + i),
                        szCommonName
                        );

        dwLength += wcslen(L"(");
        dwLength += wcslen(szCommonName);
        dwLength += wcslen( L")");

    }
    dwLength += wcslen(L")");
    dwLength += wcslen(L")");

    pszQueryBuffer = (LPWSTR)AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    if (!pszQueryBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now fill in the buffer
    //



    wcscpy(pszQueryBuffer,L"(&(objectclass=ipsecFilter)");

    wcscat(pszQueryBuffer, L"(|");

    for (i = 0; i < dwNumFilterObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszFilterDNs + i),
                        szCommonName
                        );

        wcscat(pszQueryBuffer, L"(");
        wcscat(pszQueryBuffer, szCommonName);
        wcscat(pszQueryBuffer, L")");

    }
    wcscat(pszQueryBuffer, L")");

    wcscat(pszQueryBuffer, L")");

    *ppszQueryBuffer = pszQueryBuffer;

    return(0);


error:

    if (pszQueryBuffer) {

        FreePolMem(pszQueryBuffer);
    }

    *ppszQueryBuffer = NULL;
    return(dwError);
}

DWORD
GenerateNegPolQuery(
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    LPWSTR * ppszQueryBuffer
    )
{
    DWORD i = 0;
    WCHAR szCommonName[512];
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszQueryBuffer = NULL;

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecNegotiationPolicy)");

    dwLength += wcslen(L"(|");

    for (i = 0; i < dwNumNegPolObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszNegPolDNs + i),
                        szCommonName
                        );

        dwLength += wcslen(L"(");
        dwLength += wcslen(szCommonName);
        dwLength += wcslen( L")");

    }
    dwLength += wcslen(L")");
    dwLength += wcslen(L")");

    pszQueryBuffer = (LPWSTR)AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    if (!pszQueryBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now fill in the buffer
    //



    wcscpy(pszQueryBuffer,L"(&(objectclass=ipsecNegotiationPolicy)");

    wcscat(pszQueryBuffer, L"(|");

    for (i = 0; i < dwNumNegPolObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszNegPolDNs + i),
                        szCommonName
                        );

        wcscat(pszQueryBuffer, L"(");
        wcscat(pszQueryBuffer, szCommonName);
        wcscat(pszQueryBuffer, L")");

    }
    wcscat(pszQueryBuffer, L")");

    wcscat(pszQueryBuffer, L")");

    *ppszQueryBuffer = pszQueryBuffer;

    return(0);


error:

    if (pszQueryBuffer) {

        FreePolMem(pszQueryBuffer);
    }

    *ppszQueryBuffer = NULL;
    return(dwError);
}

DWORD
GenerateNFAQuery(
    LPWSTR * ppszNFADNs,
    DWORD dwNumNFAObjects,
    LPWSTR * ppszQueryBuffer
    )
{
    DWORD i = 0;
    WCHAR szCommonName[512];
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszQueryBuffer = NULL;

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecNFA)");

    dwLength += wcslen(L"(|");

    for (i = 0; i < dwNumNFAObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszNFADNs + i),
                        szCommonName
                        );

        dwLength += wcslen(L"(");
        dwLength += wcslen(szCommonName);
        dwLength += wcslen( L")");

    }
    dwLength += wcslen(L")");
    dwLength += wcslen(L")");

    pszQueryBuffer = (LPWSTR)AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    if (!pszQueryBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now fill in the buffer
    //



    wcscpy(pszQueryBuffer,L"(&(objectclass=ipsecNFA)");

    wcscat(pszQueryBuffer, L"(|");

    for (i = 0; i < dwNumNFAObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszNFADNs + i),
                        szCommonName
                        );

        wcscat(pszQueryBuffer, L"(");
        wcscat(pszQueryBuffer, szCommonName);
        wcscat(pszQueryBuffer, L")");

    }
    wcscat(pszQueryBuffer, L")");

    wcscat(pszQueryBuffer, L")");

    *ppszQueryBuffer = pszQueryBuffer;

    return(0);


error:

    if (pszQueryBuffer) {

        FreePolMem(pszQueryBuffer);
    }

    *ppszQueryBuffer = NULL;
    return(dwError);
}

DWORD
GenerateISAKMPQuery(
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    LPWSTR * ppszQueryBuffer
    )
{
    DWORD i = 0;
    WCHAR szCommonName[512];
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszQueryBuffer = NULL;

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecISAKMPPolicy)");

    dwLength += wcslen(L"(|");

    for (i = 0; i < dwNumISAKMPObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszISAKMPDNs + i),
                        szCommonName
                        );

        dwLength += wcslen(L"(");
        dwLength += wcslen(szCommonName);
        dwLength += wcslen( L")");

    }
    dwLength += wcslen(L")");
    dwLength += wcslen(L")");

    pszQueryBuffer = (LPWSTR)AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    if (!pszQueryBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now fill in the buffer
    //



    wcscpy(pszQueryBuffer,L"(&(objectclass=ipsecISAKMPPolicy)");

    wcscat(pszQueryBuffer, L"(|");

    for (i = 0; i < dwNumISAKMPObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszISAKMPDNs + i),
                        szCommonName
                        );

        wcscat(pszQueryBuffer, L"(");
        wcscat(pszQueryBuffer, szCommonName);
        wcscat(pszQueryBuffer, L")");

    }
    wcscat(pszQueryBuffer, L")");

    wcscat(pszQueryBuffer, L")");

    *ppszQueryBuffer = pszQueryBuffer;

    return(0);


error:

    if (pszQueryBuffer) {

        FreePolMem(pszQueryBuffer);
    }

    *ppszQueryBuffer = NULL;
    return(dwError);
}



DWORD
ComputePrelimCN(
    LPWSTR szNFADN,
    LPWSTR szCommonName
    )
{
    LPWSTR pszComma = NULL;

    pszComma = wcschr(szNFADN, L',');

    if (!pszComma) {
        return (ERROR_INVALID_DATA);
    }

    *pszComma = L'\0';

    wcscpy(szCommonName, szNFADN);

    *pszComma = L',';

    return(0);
}

DWORD
ComputePolicyContainerDN(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyContainerDN
    )
{
    LPWSTR pszComma = NULL;
    LPWSTR pszPolicyContainer = NULL;
    DWORD dwError = 0;

    *ppszPolicyContainerDN = NULL;
    pszComma = wcschr(pszPolicyDN, L',');

    pszPolicyContainer = AllocPolStr(
                            pszComma + 1
                            );
    if (!pszPolicyContainer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszPolicyContainerDN = pszPolicyContainer;

error:

    return(dwError);
}


DWORD
ComputeDefaultDirectory(
    LPWSTR * ppszDefaultDirectory
    )
{

    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo = NULL;
    DWORD dwError = 0;
    DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;
    LPWSTR pszDefaultDirectory = NULL;


    *ppszDefaultDirectory = NULL;

    dwError = DsGetDcNameW(
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   Flags,
                   &pDomainControllerInfo
                   ) ;
    BAIL_ON_WIN32_ERROR(dwError);


    pszDefaultDirectory = AllocPolStr(
                                pDomainControllerInfo->DomainName
                                );
    if (!pszDefaultDirectory) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszDefaultDirectory = pszDefaultDirectory;

error:

    if (pDomainControllerInfo) {

        (void) NetApiBufferFree(pDomainControllerInfo) ;
    }


    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\nshipsec\staticshowutils.cpp ===
///////////////////////////////////////////////////////////////////////////
//Module: Static/StaticShowUtils.cpp
//
// Purpose: 	Static Show auxillary functions Implementation.
//
// Developers Name: Surya
//
// History:
//
//   Date    	Author    	Comments
//	10-8-2001	Surya	Initial Version. SCM Base line 1.0
//
///////////////////////////////////////////////////////////////////////////

#include "nshipsec.h"

extern HINSTANCE g_hModule;
extern STORAGELOCATION g_StorageLocation;

// magic strings
#define IPSEC_SERVICE_NAME _TEXT("policyagent")
#define GPEXT_KEY	_TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions")

_TCHAR   pcszGPTIPSecKey[]    	= _TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\GPTIPSECPolicy");
_TCHAR   pcszGPTIPSecName[]   	= _TEXT("DSIPSECPolicyName");
_TCHAR   pcszGPTIPSecFlags[]  	= _TEXT("DSIPSECPolicyFlags");
_TCHAR   pcszGPTIPSecPath[]   	= _TEXT("DSIPSECPolicyPath");
_TCHAR   pcszLocIPSecKey[]    	= _TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\Policy\\Local");
_TCHAR   pcszLocIPSecPol[]    	= _TEXT("ActivePolicy");
_TCHAR   pcszCacheIPSecKey[]  	= _TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\Policy\\Cache");
_TCHAR   pcszIPSecPolicy[]    	= _TEXT("ipsecPolicy");
_TCHAR   pcszIPSecName[]      	= _TEXT("ipsecName");
_TCHAR   pcszIPSecDesc[]      	= _TEXT("description");
_TCHAR   pcszIPSecTimestamp[] 	= _TEXT("whenChanged");
_TCHAR   pcszIpsecClsid[] 		= _TEXT("{e437bc1c-aa7d-11d2-a382-00c04f991e27}");  //mmc snapin UUID

///////////////////////////////////////////////////////////////////////////
//
//Function: GetPolicyInfo()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LPTSTR pszMachineName,
//	OUT POLICY_INFO &m_PolicyInfo
//
//
//Return: DWORD
//
//Description:
//	This function gets the policy specified from the machine specified.
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////

DWORD
GetPolicyInfo (
	IN LPTSTR pszMachineName,
	OUT POLICY_INFO &m_PolicyInfo
	)
{
	HKEY    hRegKey=NULL, hRegHKey=NULL;
	DWORD   dwType = 0;            // for RegQueryValueEx
	DWORD   dwBufLen = 0;          // for RegQueryValueEx
	_TCHAR   pszBuf[STRING_TEXT_SIZE] = {0};
	DWORD dwError = 0;
	DWORD dwValue = 0;
	DWORD dwLength = sizeof(DWORD);

	//Initialize the m_PolicyInfo as PS_NO_POLICY assigned
	m_PolicyInfo.iPolicySource = PS_NO_POLICY;
	m_PolicyInfo.pszPolicyPath[0] = 0;
	m_PolicyInfo.pszPolicyName[0] = 0;
	m_PolicyInfo.pszPolicyDesc[0] = 0;


	dwError = RegConnectRegistry( pszMachineName,
		                          HKEY_LOCAL_MACHINE,
								  &hRegHKey);
	if(dwError != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	dwError = RegOpenKeyEx( hRegHKey,
							pcszGPTIPSecKey,
							0,
							KEY_READ,
							&hRegKey);

	if(ERROR_SUCCESS == dwError)
	{

		// query for flags, if flags aint' there or equal to 0, we don't have domain policy
		dwError = RegQueryValueEx(hRegKey,
								  pcszGPTIPSecFlags,
								  NULL,
								  &dwType,
								  (LPBYTE)&dwValue,
								  &dwLength);

		if(dwError != ERROR_SUCCESS)
		{
			if (dwValue == 0)
			{
				dwError = ERROR_FILE_NOT_FOUND;
			}
		}

		// now get name
		if (dwError == ERROR_SUCCESS)
		{
			dwBufLen = MAXSTRLEN*sizeof(_TCHAR);
			dwError = RegQueryValueEx( hRegKey,
									   pcszGPTIPSecName,
									   NULL,
									   &dwType, // will be REG_SZ
									   (LPBYTE) pszBuf,
									   &dwBufLen);
		}
	}

	if (dwError == ERROR_SUCCESS)
	{
		m_PolicyInfo.iPolicySource = PS_DS_POLICY;
		m_PolicyInfo.pszPolicyPath[0] = 0;
		_tcsncpy(m_PolicyInfo.pszPolicyName, pszBuf,MAXSTRINGLEN-1);

		dwBufLen = MAXSTRLEN*sizeof(_TCHAR);
		dwError = RegQueryValueEx( hRegKey,
								   pcszGPTIPSecPath,
								   NULL,
								   &dwType, // will be REG_SZ
								   (LPBYTE) pszBuf,
								   &dwBufLen);
		if (dwError == ERROR_SUCCESS)
		{
			_tcsncpy(m_PolicyInfo.pszPolicyPath, pszBuf,MAXSTRLEN-1);
		}

		dwError = ERROR_SUCCESS;
		BAIL_OUT;
	}
	else
	{
		if(hRegKey)
			RegCloseKey(hRegKey);
		hRegKey = NULL;
		if (dwError == ERROR_FILE_NOT_FOUND)
		{
			// DS reg key not found, check local
			dwError = RegOpenKeyEx( hRegHKey,
									pcszLocIPSecKey,
									0,
									KEY_READ,
									&hRegKey);

			if(dwError != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}


			dwBufLen = MAXSTRLEN*sizeof(_TCHAR);
			dwError = RegQueryValueEx( hRegKey,
									   pcszLocIPSecPol,
									   NULL,
									   &dwType, 			// will be REG_SZ
									   (LPBYTE) pszBuf,
									   &dwBufLen);


			if (dwError == ERROR_SUCCESS)
			{
				// read it
				if(hRegKey)
					RegCloseKey(hRegKey);
				hRegKey = NULL;
				dwError = RegOpenKeyEx( hRegHKey,
										pszBuf,
										0,
										KEY_READ,
										&hRegKey);
				_tcsncpy(m_PolicyInfo.pszPolicyPath, pszBuf,MAXSTRLEN-1);
				if (dwError == ERROR_SUCCESS)
				{
					dwBufLen = MAXSTRLEN*sizeof(_TCHAR);
					dwError = RegQueryValueEx( hRegKey,
											   pcszIPSecName,
											   NULL,
											   &dwType, 	// will be REG_SZ
											   (LPBYTE) pszBuf,
											   &dwBufLen);
				}
				if (dwError == ERROR_SUCCESS)
				{	// found it
					m_PolicyInfo.iPolicySource = PS_LOC_POLICY;
					_tcsncpy(m_PolicyInfo.pszPolicyName, pszBuf,MAXSTRINGLEN-1);
				}

				dwError = ERROR_SUCCESS;
			}
		}
	}

error:
	if (hRegKey)
	{
		RegCloseKey(hRegKey);
	}
	if (hRegHKey)
	{
		RegCloseKey(hRegHKey);
	}
	return  dwError;
}

///////////////////////////////////////////////////////////////////////////
//
//Function: GetMorePolicyInfo()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LPTSTR pszMachineName,
//	OUT POLICY_INFO &m_PolicyInfo
//
//
//Return: DWORD
//
//Description:
//	This function gets the policy specified from the machine specified.
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////

DWORD
GetMorePolicyInfo (
	IN LPTSTR pszMachineName,
	OUT POLICY_INFO &m_PolicyInfo
	)
{
	DWORD   dwError = ERROR_SUCCESS , dwStrLen = 0;
	HKEY    hRegKey = NULL, hRegHKey = NULL;

	DWORD   dwType;            // for RegQueryValueEx
	DWORD   dwBufLen = 0;      // for RegQueryValueEx
	DWORD   dwValue = 0;
	DWORD   dwLength = sizeof(DWORD);
	_TCHAR   pszBuf[STRING_TEXT_SIZE] = {0};

	PTCHAR* ppszExplodeDN = NULL;

	// set some default values
    m_PolicyInfo.pszPolicyDesc[0] = 0;
	m_PolicyInfo.timestamp  = 0;

	dwError = RegConnectRegistry( pszMachineName,
		                          HKEY_LOCAL_MACHINE,
								  &hRegHKey);

	if(dwError != ERROR_SUCCESS)
	{
		BAIL_OUT;
	}

	switch (m_PolicyInfo.iPolicySource)
	{
		case PS_LOC_POLICY:
			// open the key
			dwError = RegOpenKeyEx( hRegHKey,
									m_PolicyInfo.pszPolicyPath,
									0,
									KEY_READ,
									&hRegKey);
			if(dwError != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			// timestamp
			dwError = RegQueryValueEx(hRegKey,
					                  pcszIPSecTimestamp,
					                  NULL,
					                  &dwType,
					                  (LPBYTE)&dwValue,
					                  &dwLength);
			if(dwError != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			m_PolicyInfo.timestamp = dwValue;

			// description
			dwBufLen = MAXSTRLEN*sizeof(_TCHAR);
			dwError  = RegQueryValueEx( hRegKey,
						 			    pcszIPSecDesc,
										NULL,
										&dwType, // will be REG_SZ
										(LPBYTE) pszBuf,
										&dwBufLen);
			if(dwError != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			_tcsncpy(m_PolicyInfo.pszPolicyDesc, pszBuf,MAXSTRINGLEN-1);

			break;

		case PS_DS_POLICY:
			// get the policy name from DN
	            _tcsncpy(pszBuf, pcszCacheIPSecKey,STRING_TEXT_SIZE-1);
			ppszExplodeDN = ldap_explode_dn(m_PolicyInfo.pszPolicyPath, 1);
			if (!ppszExplodeDN)
			{
				BAIL_OUT;
			}
			dwStrLen = _tcslen(pszBuf);
			_tcsncat(pszBuf, _TEXT("\\"),STRING_TEXT_SIZE-dwStrLen-1);
			dwStrLen = _tcslen(pszBuf);
			_tcsncat(pszBuf, ppszExplodeDN[0],STRING_TEXT_SIZE-dwStrLen-1);

			// open the regkey
			dwError = RegOpenKeyEx( hRegHKey,
									pszBuf,
									0,
									KEY_READ,
									&hRegKey);
			if(dwError != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			// get the more correct name info
			dwBufLen = sizeof(pszBuf);
			dwError = RegQueryValueEx( hRegKey,
									   pcszIPSecName,
									   NULL,
									   &dwType, // will be REG_SZ
									   (LPBYTE) pszBuf,
									   &dwBufLen);
			if (dwError == ERROR_SUCCESS)
			{
				_tcscpy(m_PolicyInfo.pszPolicyName, pszBuf);
			}

			m_PolicyInfo.timestamp = 0;

			// description
			dwBufLen = MAXSTRLEN*sizeof(_TCHAR);
			dwError  = RegQueryValueEx( hRegKey,
						 			    pcszIPSecDesc,
										NULL,
										&dwType, // will be REG_SZ
										(LPBYTE) pszBuf,
										&dwBufLen);
			if(dwError != ERROR_SUCCESS)
			{
				BAIL_OUT;
			}

			_tcsncpy(m_PolicyInfo.pszPolicyDesc, pszBuf,MAXSTRINGLEN-1);

			break;
	}

error:
	if (hRegKey)
	{
		RegCloseKey(hRegKey);
	}
	if (hRegHKey)
	{
		RegCloseKey(hRegHKey);
	}
	if (ppszExplodeDN)
	{
		ldap_value_free(ppszExplodeDN);
	}
	return  dwError;
}

////////////////////////////////////////////////////////////////////////
//
//Function: GetActivePolicyInfo()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LPTSTR pszMachineName,
//	OUT POLICY_INFO &m_PolicyInfo
//
//
//Return: DWORD
//
//Description:
//	This function gets the active policy specified from the machine specified.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////

DWORD
GetActivePolicyInfo(
	IN LPTSTR pszMachineName,
	OUT POLICY_INFO &m_PolicyInfo
	)
{
	DWORD dwReturn=ERROR_SUCCESS, dwStrLen = 0;

	dwReturn = GetPolicyInfo(pszMachineName,m_PolicyInfo);

	if( dwReturn == ERROR_SUCCESS )
	{
		switch (m_PolicyInfo.iPolicySource)
		{
		case PS_NO_POLICY:
			break;

		case PS_DS_POLICY:
			{
				m_PolicyInfo.dwLocation=IPSEC_DIRECTORY_PROVIDER;

				PGROUP_POLICY_OBJECT pGPO;
				pGPO = NULL;

				GetMorePolicyInfo(pszMachineName,m_PolicyInfo);

				pGPO = GetIPSecGPO(pszMachineName);

				if (pGPO)
				{
					PGROUP_POLICY_OBJECT pLastGPO = pGPO;

					while ( 1 )
					{
						if ( pLastGPO->pNext )
							pLastGPO = pLastGPO->pNext;
						else
							break;
					}
					_tcsncpy(m_PolicyInfo.pszOU,pLastGPO->lpLink,MAXSTRLEN-1);
					_tcsncpy(m_PolicyInfo.pszGPOName, pLastGPO->lpDisplayName,MAXSTRINGLEN-1);
					FreeGPOList (pGPO);
				}

			}
			break;

		case PS_LOC_POLICY:
			m_PolicyInfo.dwLocation=IPSEC_REGISTRY_PROVIDER;
			if(pszMachineName)
			{
				dwStrLen = _tcslen(pszMachineName);
				m_PolicyInfo.pszMachineName = new _TCHAR[dwStrLen+1];
				if(m_PolicyInfo.pszMachineName==NULL)
				{
					dwReturn=ERROR_OUTOFMEMORY;
					BAIL_OUT;
				}
				_tcsncpy(m_PolicyInfo.pszMachineName,pszMachineName,dwStrLen+1);
			}
			else
				m_PolicyInfo.pszMachineName=NULL;
			GetMorePolicyInfo(pszMachineName,m_PolicyInfo);
			break;
		default :
			break;
		}
	}
error:
	return dwReturn;
}

////////////////////////////////////////////////////////////////////////
//
//Function: GetIPSecGPO()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LPTSTR pszMachineName
//
//
//Return: PGROUP_POLICY_OBJECT
//
//Description:
//	This function gets the GPO specified from the machine specified.
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////

PGROUP_POLICY_OBJECT
GetIPSecGPO (
	IN LPTSTR pszMachineName
	)
{
    HKEY hKey = NULL;
	HKEY hRegHKey = NULL;
    DWORD dwStrLen = 0;
    LONG lResult;
    _TCHAR szName[MAXSTRLEN] = {0};
    GUID guid = {0};
    PGROUP_POLICY_OBJECT pGPO = NULL;
    //
    // Enumerate the extensions
    //
	lResult = RegConnectRegistry( pszMachineName,
		                          HKEY_LOCAL_MACHINE,
								  &hRegHKey);

	if(lResult != ERROR_SUCCESS)
	{
		return NULL;
	}

	_TCHAR strGPExt[MAXSTRLEN] = {0};

	_tcsncpy(strGPExt,GPEXT_KEY,MAXSTRLEN-1);
	dwStrLen = _tcslen(strGPExt);
	_tcsncat(strGPExt , _TEXT("\\"),MAXSTRLEN- dwStrLen-1);
	dwStrLen = _tcslen(strGPExt);
	_tcsncat(strGPExt ,pcszIpsecClsid,MAXSTRLEN-dwStrLen-1);

    lResult = RegOpenKeyEx (hRegHKey, strGPExt, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
		_tcsncpy(szName,pcszIpsecClsid,MAXSTRLEN-1);

        StringToGuid(szName, &guid);
        lResult = GetAppliedGPOList (GPO_LIST_FLAG_MACHINE, pszMachineName, NULL,
                                             &guid, &pGPO);
	}

	if( hKey )
		RegCloseKey(hKey);

	if( hRegHKey )
		RegCloseKey(hRegHKey);

	return pGPO;
}

////////////////////////////////////////////////////////////////////////
//
//Function: StringToGuid()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LPTSTR szValue,
//  OUT GUID * pGuid
//
//Return: VOID
//
//Description:
//	This function gets the GUID from the string
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////

VOID
StringToGuid(
	IN LPTSTR szValue,
	OUT GUID * pGuid
	)
{
    _TCHAR wc;
    INT i=0;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == _TEXT('{') )
        szValue++;
    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //
    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = _tcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)_tcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)_tcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)_tcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)_tcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)_tcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

////////////////////////////////////////////////////////////////////////
//
//Function: GetGpoDsPath()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
//	IN LPTSTR szGpoId,
//	OUT LPTSTR szGpoDsPath
//
//Return: HRESULT
//
//Description:
//	This function gets DS path
//
//Revision History:
//
//   Date    	Author    	Comments
//
//////////////////////////////////////////////////////////////////////////

HRESULT
GetGpoDsPath(
	IN LPTSTR szGpoId,
	OUT LPTSTR szGpoDsPath
	)
{
	LPGROUPPOLICYOBJECT pGPO = NULL;
    HRESULT hr=ERROR_SUCCESS;

    hr = CoCreateInstance(CLSID_GroupPolicyObject, NULL, CLSCTX_SERVER, IID_IGroupPolicyObject, (void **)&pGPO);

    if (FAILED(hr))
    {
		BAIL_OUT;
    }

	hr = pGPO->OpenDSGPO((LPOLESTR)szGpoId,GPO_OPEN_READ_ONLY);

	if (FAILED(hr))
    {
        BAIL_OUT;
    }

	hr = pGPO->GetDSPath( GPO_SECTION_MACHINE,
                          szGpoDsPath,
                          256
                         );

	if (FAILED(hr))
    {
		BAIL_OUT;
    }

error:
	return hr;
}

////////////////////////////////////////////////////////////////////////
//
//Function: GetIPSECPolicyDN()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
// 	  IN LPWSTR pszMachinePath,
//    OUT LPWSTR pszPolicyDN
//
//Return: HRESULT
//
//Description:
//	This function gets the IPSEC policy DN
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////

HRESULT
GetIPSECPolicyDN(
    IN LPWSTR pszMachinePath,
    OUT LPWSTR pszPolicyDN
    )
{
    HRESULT hr = S_OK;
    IDirectoryObject * pIpsecObject = NULL;

    BSTR pszMicrosoftPath = NULL;
    BSTR pszIpsecPath = NULL;
    BSTR pszWindowsPath = NULL;

    LPWSTR pszOwnersReference = _TEXT("ipsecOwnersReference");

    PADS_ATTR_INFO pAttributeEntries = NULL;
    DWORD dwNumAttributesReturned = 0;

    // Build the fully qualified ADsPath for my object
    hr = CreateChildPath(
                pszMachinePath,
                _TEXT("cn=Microsoft"),
                &pszMicrosoftPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszMicrosoftPath,
                _TEXT("cn=Windows"),
                &pszWindowsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszWindowsPath,
                _TEXT("cn=ipsec"),
                &pszIpsecPath
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsGetObject(
            pszIpsecPath,
            IID_IDirectoryObject,
            (void **)&pIpsecObject
            );
    BAIL_ON_FAILURE(hr);

    //
    // Now populate our object with our data.
    //
    hr = pIpsecObject->GetObjectAttributes(
                        &pszOwnersReference,
                        1,
                        &pAttributeEntries,
                        &dwNumAttributesReturned
                        );
    BAIL_ON_FAILURE(hr);

    if (dwNumAttributesReturned != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    wcsncpy(pszPolicyDN, pAttributeEntries->pADsValues->DNString,STR_TEXT_SIZE-1);

error:

    if (pIpsecObject) {
        pIpsecObject->Release();
    }

    if (pszMicrosoftPath) {
        SysFreeString(pszMicrosoftPath);
    }

    if (pszWindowsPath) {
        SysFreeString(pszWindowsPath);
    }

    if (pszIpsecPath) {
        SysFreeString(pszIpsecPath);
    }

    return(hr);
}

////////////////////////////////////////////////////////////////////////
//
//Function: ComputePolicyDN()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
// 		IN LPWSTR pszDirDomainName,
//		IN LPWSTR pszPolicyIdentifier,
//    	OUT LPWSTR pszPolicyDN
//
//Return: DWORD
//
//Description:
//	This function computes the IPSEC policy DN
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////

DWORD
ComputePolicyDN(
    IN LPWSTR pszDirDomainName,
	IN LPWSTR pszPolicyIdentifier,
    OUT LPWSTR pszPolicyDN
    )
{
    DWORD dwError = ERROR_SUCCESS , dwStrLen = 0;

    if (!pszDirDomainName)
    {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_OUT;
    }

    wcsncpy(pszPolicyDN,_TEXT("cn=ipsecPolicy"),MAX_PATH-1);

    dwStrLen = wcslen(pszPolicyDN);
    wcsncat(pszPolicyDN,pszPolicyIdentifier,MAX_PATH-dwStrLen-1);

    dwStrLen = wcslen(pszPolicyDN);
    wcsncat(pszPolicyDN,_TEXT(",cn=IP Security,cn=System,"),MAX_PATH-dwStrLen-1);

    dwStrLen = wcslen(pszPolicyDN);
    wcsncat(pszPolicyDN, pszDirDomainName,MAX_PATH-dwStrLen-1);

error:
    return(dwError);
}

////////////////////////////////////////////////////////////////////////
//
//Function: ShowAssignedGpoPolicy()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
// 		IN LPTSTR szGpoName,
//		IN PGPO pGPO,
//		IN BOOL bVerbose
//
//Return: DWORD
//
//Description:
//	This function prints the assigned policy to the GPO
//
//Revision History:
//
//   Date    	Author    	Comments
//
////////////////////////////////////////////////////////////////////////

DWORD
ShowAssignedGpoPolicy(
	IN LPTSTR szGpoName,
	IN PGPO pGPO
	)
{

	DWORD dwError=ERROR_SUCCESS,dwStrLen = 0;
	LPTSTR szRsopNameSpace = _TEXT("root\\rsop\\computer");
	IWbemServices *pWbemServices = NULL;
	IEnumWbemClassObject * pEnum = 0;
	IWbemClassObject *pObject = 0;
	BSTR bstrLanguage,bstrQuery;
	_TCHAR szQuery[STR_TEXT_SIZE] = {0},szGpoDsPath[STR_TEXT_SIZE] = {0},szGpoId[STR_TEXT_SIZE]={0}, szPolicyDN[STR_TEXT_SIZE]={0};
	HRESULT hr=ERROR_SUCCESS;
	ULONG ulRet;
	BOOL bPolicyFound=FALSE;

	dwStrLen = _tcslen(szGpoName);
	pGPO->pszGPODisplayName=new _TCHAR[dwStrLen+1];
	if(pGPO->pszGPODisplayName == NULL)
	{
		dwError=ERROR_OUTOFMEMORY;
		BAIL_OUT;
	}
	_tcsncpy(pGPO->pszGPODisplayName,szGpoName,dwStrLen+1);

	dwError = 	CreateIWbemServices(szRsopNameSpace,&pWbemServices);

	BAIL_ON_WIN32_ERROR(dwError);

	dwError = AllocBSTRMem(_TEXT("WQL"),bstrLanguage);
	hr = HRESULT_FROM_WIN32(dwError);
	BAIL_ON_WIN32_ERROR(dwError);

	_snwprintf(szQuery,STR_TEXT_SIZE-1, _TEXT("SELECT * FROM RSOP_Gpo where name=\"%s\""), szGpoName);

	dwError = AllocBSTRMem(szQuery,bstrQuery);
	hr = HRESULT_FROM_WIN32(dwError);
	BAIL_ON_WIN32_ERROR(dwError);


	hr = pWbemServices->ExecQuery (bstrLanguage, bstrQuery,
			 WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
			 NULL, &pEnum);

	BAIL_ON_FAILURE(hr);
	//
	// Loop through the results
	//
	while ( (hr = pEnum->Next(WBEM_INFINITE, 1, &pObject, &ulRet)) == WBEM_S_NO_ERROR )
	{
		VARIANT varValue;
		BSTR bstrProp = NULL;

		dwError = AllocBSTRMem(_TEXT("id"),bstrProp);
		hr = HRESULT_FROM_WIN32(dwError);
		BAIL_ON_WIN32_ERROR(dwError);

		hr = pObject->Get (bstrProp, 0, &varValue, NULL, NULL);

		// check the HRESULT to see if the action succeeded.
		if (SUCCEEDED(hr))
		{
			LPTSTR pszDirectoryName = NULL;

			dwStrLen = _tcslen(V_BSTR(&varValue));
			pGPO->pszGPODNName=new _TCHAR[dwStrLen+1];
			if(pGPO->pszGPODNName == NULL)
			{
				dwError=ERROR_OUTOFMEMORY;
				BAIL_OUT;
			}

			_tcsncpy(pGPO->pszGPODNName,V_BSTR(&varValue),dwStrLen+1);

			_snwprintf(szGpoId,STR_TEXT_SIZE-1,_TEXT("LDAP://%s"),V_BSTR(&varValue));

			if ( ERROR_SUCCESS == GetGpoDsPath(szGpoId, szGpoDsPath))
			{
				hr = VariantClear( &varValue );

				if (FAILED(hr))
				{
				   BAIL_OUT;
				}

				if (ERROR_SUCCESS == GetIPSECPolicyDN(
					szGpoDsPath,
					szPolicyDN
					))
				{
					pszDirectoryName = wcsstr(szGpoDsPath, _TEXT("DC"));
					if(pszDirectoryName == NULL)
					{
						BAIL_OUT;
					}
					dwError=GetPolicyInfoFromDomain(pszDirectoryName,szPolicyDN,pGPO);
					if(dwError == ERROR_OUTOFMEMORY)
					{
						BAIL_OUT;
					}

					PrintGPOList(pGPO);

					bPolicyFound=TRUE;
				}
			}
		}
		pObject->Release ();
		if(bPolicyFound) break;
	}
	if(!bPolicyFound)
	{
		PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_ASSIGNEDGPO_SRCMACHINE3);
	}

	pEnum->Release();

error:
	if(dwError == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwError=ERROR_SUCCESS;
	}
	return dwError;
}


DWORD
ShowLocalGpoPolicy(
	POLICY_INFO &policyInfo,
	PGPO pGPO
	)
{
	DWORD dwReturn;
	DWORD dwLocation;
	DWORD dwStrLength = 0;
	DWORD MaxStringLen = 0;

	LPTSTR pszMachineName = NULL;

	dwReturn = CopyStorageInfo(&pszMachineName,dwLocation);
	if(dwReturn == ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturn=ERROR_SUCCESS;
		BAIL_OUT;
	}

	// get the active policy info from the machine's registry

	dwReturn=GetActivePolicyInfo (pszMachineName,policyInfo);

	if((dwReturn==ERROR_SUCCESS)||(dwReturn==ERROR_FILE_NOT_FOUND))
	{
		if (policyInfo.iPolicySource != PS_NO_POLICY)
		{
			if(policyInfo.iPolicySource==PS_DS_POLICY)
			{
				pGPO->bDNPolicyOverrides=TRUE;
				dwReturn = GetLocalPolicyName(pGPO);

				if(dwReturn == ERROR_OUTOFMEMORY)
				{
					PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
					dwReturn = ERROR_SUCCESS;
					BAIL_OUT;
				}
			}
			if (_tcscmp(policyInfo.pszGPOName , _TEXT(""))!=0 && policyInfo.iPolicySource==PS_DS_POLICY)
			{
				//copy gpo DN

				dwStrLength = _tcslen(policyInfo.pszGPOName);

				pGPO->pszGPODNName= new _TCHAR[dwStrLength+1];

				if(pGPO->pszGPODNName==NULL)
				{
					PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
					dwReturn = ERROR_SUCCESS;
					BAIL_OUT;
				}
				_tcsncpy(pGPO->pszGPODNName,policyInfo.pszGPOName,dwStrLength);
			}

			dwStrLength = _tcslen(LocalGPOName);
			pGPO->pszGPODisplayName=new _TCHAR[dwStrLength+1];

			if(pGPO->pszGPODisplayName==NULL)
			{
				PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
				dwReturn = ERROR_SUCCESS;
				BAIL_OUT;
			}
			//copy gpo display name

			_tcsncpy(pGPO->pszGPODisplayName,LocalGPOName,dwStrLength+1);

			if (_tcscmp(policyInfo.pszPolicyName , _TEXT(""))!=0)
			{
				dwStrLength = _tcslen(policyInfo.pszPolicyName);
				pGPO->pszPolicyName=new _TCHAR[dwStrLength+1];
				if(pGPO->pszPolicyName==NULL)
				{
					PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
					dwReturn = ERROR_SUCCESS;
					BAIL_OUT;
				}
				_tcsncpy(pGPO->pszPolicyName ,policyInfo.pszPolicyName,dwStrLength+1);
			}

			if (_tcscmp(policyInfo.pszPolicyPath , _TEXT(""))!=0)
			{
				//copy gpo policy DN

				dwStrLength = _tcslen(policyInfo.pszPolicyPath);
				pGPO->pszPolicyDNName=new _TCHAR[dwStrLength+1];
				if(pGPO->pszPolicyDNName==NULL)
				{
					PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
					dwReturn = ERROR_SUCCESS;
					BAIL_OUT;
				}
				_tcsncpy(pGPO->pszPolicyDNName,policyInfo.pszPolicyPath,dwStrLength+1);
			}

			pGPO->bActive=TRUE;
			MaxStringLen = (sizeof(pGPO->pszLocalMachineName) / sizeof(pGPO->pszLocalMachineName[0]));

			if(!pszMachineName)
			{
				GetComputerName(pGPO->pszLocalMachineName,&MaxStringLen);
			}
			else
			{
				_tcsncpy(pGPO->pszLocalMachineName,pszMachineName,MaxStringLen-1);
			}

			//get Domain Name & DC name

			PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
			DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY;

			dwReturn = DsGetDcName(NULL, //machine name
						   NULL,
						   NULL,
						   NULL,
						   Flags,
						   &pDomainControllerInfo
						   ) ;

			if(dwReturn==NO_ERROR && pDomainControllerInfo)
			{
				if(pDomainControllerInfo->DomainName)
				{
					dwStrLength = _tcslen(pDomainControllerInfo->DomainName);

					pGPO->pszDomainName= new _TCHAR[dwStrLength+1];
					if(pGPO->pszDomainName==NULL)
					{
						PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
						dwReturn = ERROR_SUCCESS;
						BAIL_OUT;
					}
					_tcsncpy(pGPO->pszDomainName,pDomainControllerInfo->DomainName,dwStrLength+1);
				}

				if(pDomainControllerInfo->DomainControllerName)
				{
					dwStrLength = _tcslen(pDomainControllerInfo->DomainControllerName);

					pGPO->pszDCName= new _TCHAR[dwStrLength+1];
					if(pGPO->pszDCName==NULL)
					{
						PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
						dwReturn = ERROR_SUCCESS;
						BAIL_OUT;
					}
					_tcsncpy(pGPO->pszDCName,pDomainControllerInfo->DomainControllerName,dwStrLength+1);
				}

				//free pDomainControllerInfo

				NetApiBufferFree(pDomainControllerInfo);

			}
			PrintGPOList(pGPO);
			dwReturn = ERROR_SUCCESS;
		}
		else
		{
			PrintErrorMessage(IPSEC_ERR,0,ERRCODE_SHW_STATIC_TAB_ASSIGNPOL_2);
		}

	}
	else if(dwReturn==ERROR_OUTOFMEMORY)
	{
		PrintErrorMessage(WIN32_ERR,ERROR_OUTOFMEMORY,NULL);
		dwReturn = ERROR_SUCCESS;
	}
	if(dwReturn==ERROR_FILE_NOT_FOUND)
		dwReturn=ERROR_SUCCESS;

	if(policyInfo.pszMachineName)
	{
		delete [] policyInfo.pszMachineName;
		policyInfo.pszMachineName = NULL;
	}
	if(pszMachineName)
		delete [] pszMachineName;

error:
	return dwReturn;
}

/////////////////////////////////////////////////////////////////////////
//
//Function: CreateIWbemServices()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
// 		IN LPTSTR pszIpsecWMINamespace,
//    	OUT IWbemServices **ppWbemServices
//
//Return: DWORD
//
//Description:
//
//
//Revision History:
//
//   Date    	Author    	Comments
//
/////////////////////////////////////////////////////////////////////////

DWORD
CreateIWbemServices(
    IN LPTSTR pszIpsecWMINamespace,
    OUT IWbemServices **ppWbemServices
    )
{
    DWORD dwError = ERROR_SUCCESS;
    IWbemLocator *pWbemLocator = NULL;
    HRESULT hr = S_OK;

    BSTR bstrIpsecWMIPath = NULL;

	hr = CoCreateInstance(
		CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID*)&pWbemLocator
		);

    if (FAILED(hr))
    {
		dwError = ERROR_INTERNAL_ERROR;
		BAIL_OUT;
    }

    dwError = AllocBSTRMem(pszIpsecWMINamespace,bstrIpsecWMIPath);
	BAIL_ON_WIN32_ERROR(dwError);

	hr = pWbemLocator->ConnectServer(
								bstrIpsecWMIPath,
								NULL,
								NULL,
								NULL,
								0,
								NULL, NULL,
								ppWbemServices );


    if (FAILED(hr))
    {
		dwError = ERROR_INTERNAL_ERROR;
		BAIL_OUT;
    }

    SysFreeString(bstrIpsecWMIPath);

    if(pWbemLocator)
        pWbemLocator->Release();
error:
    return (dwError);
}

/////////////////////////////////////////////////////////////////////////
//
//Function: FormatTime()
//
//Date of Creation: 21st Aug 2001
//
//Parameters:
// 		IN time_t t,
//   	OUT LPTSTR pszTimeStr
//
//Return: HRESULT
//
//Description:
//		Computes the last modified time
//
//Revision History:
//
//   Date    	Author    	Comments
//
///////////////////////////////////////////////////////////////////////////

HRESULT
FormatTime(
	IN time_t t,
	OUT LPTSTR pszTimeStr
	)

{
    time_t timeCurrent = time(NULL);
    LONGLONG llTimeDiff = 0;
    FILETIME ftCurrent = {0};
    FILETIME ftLocal = {0};
    SYSTEMTIME SysTime;
    _TCHAR szBuff[STR_TEXT_SIZE] = {0};
    DWORD dwStrLen = 0 ;

	//Here tcsncpy not required

    _tcscpy(pszTimeStr, _TEXT(""));
    GetSystemTimeAsFileTime(&ftCurrent);
    llTimeDiff = (LONGLONG)t - (LONGLONG)timeCurrent;
    llTimeDiff *= 10000000;

    *((LONGLONG UNALIGNED64 *)&ftCurrent) += llTimeDiff;
    if (!FileTimeToLocalFileTime(&ftCurrent, &ftLocal ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!FileTimeToSystemTime( &ftLocal, &SysTime ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (0 == GetDateFormat(LOCALE_USER_DEFAULT,
                        0,
                        &SysTime,
                        NULL,
                        szBuff,
                        sizeof(szBuff)/sizeof(szBuff[0]) ))  //number of characters
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    dwStrLen = _tcslen(pszTimeStr);
    _tcsncat(pszTimeStr,szBuff,BUFFER_SIZE-dwStrLen-1);
    dwStrLen = _tcslen(pszTimeStr);
    _tcsncat(pszTimeStr, _TEXT(" "),BUFFER_SIZE-dwStrLen-1);

    ZeroMemory(szBuff, sizeof(szBuff));
    if (0 == GetTimeFormat(LOCALE_USER_DEFAULT,
                        0,
                        &SysTime,
                        NULL,
                        szBuff,
                        sizeof(szBuff)/sizeof(szBuff[0])))  //number of characters
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    dwStrLen = _tcslen(pszTimeStr);
    _tcsncat(pszTimeStr,szBuff,BUFFER_SIZE-dwStrLen-1);
    return S_OK;
}

INT 
WcsCmp0(
    IN PWSTR pszString1,
    IN PWSTR pszString2)
{
    if ((pszString1 == NULL) || (pszString2 == NULL))
    {
        if (pszString1 == NULL)
        {
            if ((pszString2 == NULL) || (*pszString2 == L'\0'))
            {
                return 0;
            }
            return -1;
        }
        else
        {
            if (*pszString1 == L'\0')
            {
                return 0;
            }
            return 1;
        }
    }

    return _tcscmp(pszString1, pszString2);
}

VOID
DisplayCertInfo(
	LPTSTR pszCertName,
	DWORD dwFlags
	)
{
	ASSERT(pszCertName != NULL);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_MMSAS_FILTER_ROOTCA, pszCertName);
	PrintMessageFromModule(g_hModule, DYNAMIC_SHOW_NEWLINE);
	if((g_StorageLocation.dwLocation != IPSEC_DIRECTORY_PROVIDER && IsDomainMember(g_StorageLocation.pszMachineName))||(g_StorageLocation.dwLocation == IPSEC_DIRECTORY_PROVIDER))
	{
		if(dwFlags & IPSEC_MM_CERT_AUTH_ENABLE_ACCOUNT_MAP )
		{
			PrintMessageFromModule(g_hModule,SHW_AUTH_CERTMAP_ENABLED_YES_STR);
		}
		else
		{
			PrintMessageFromModule(g_hModule,SHW_AUTH_CERTMAP_ENABLED_NO_STR);
		}
	}
	if (dwFlags & IPSEC_MM_CERT_AUTH_DISABLE_CERT_REQUEST)
	{
		PrintMessageFromModule(g_hModule, SHW_AUTH_EXCLUDE_CA_NAME_YES_STR);
	}
	else
	{
		PrintMessageFromModule(g_hModule, SHW_AUTH_EXCLUDE_CA_NAME_NO_STR);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\dsstore.h ===
DWORD
CrackDomainName(
    IN WCHAR* pszDomain,     
    OUT BOOL* pbCracked,     
    OUT WCHAR** ppszDomain);

DWORD
OpenDirectoryServerHandle(
    LPWSTR pszDomainName,
    DWORD dwPortNumber,
    HLDAP * phLdapBindHandle
    );


DWORD
CloseDirectoryServerHandle(
    HLDAP hLdapBindHandle
    );

DWORD
ShallowReadPolicyObjectFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
ReadPolicyObjectFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );


DWORD
ReadNFAObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecOwnerReference,
    LPWSTR * ppszNFADNs,
    DWORD dwNumNfaObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNfaObjects,
    LPWSTR ** pppszFilterReferences,
    PDWORD pdwNumFilterReferences,
    LPWSTR ** pppszNegPolReferences,
    PDWORD pdwNumNegPolReferences
    );

DWORD
GenerateNFAQuery(
    LPWSTR * ppszNFADNs,
    DWORD dwNumNFAObjects,
    LPWSTR * ppszQueryBuffer
    );


DWORD
AppendCommonNameToQuery(
    LPWSTR szQueryBuffer,
    LPWSTR szCommonName
    );

DWORD
ComputePrelimCN(
    LPWSTR szNFADN,
    LPWSTR szCommonName
    );

DWORD
UnMarshallPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject,
    LDAPMessage *res
    );


DWORD
UnMarshallNFAObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    );


DWORD
GenerateISAKMPQuery(
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    LPWSTR * ppszQueryBuffer
    );

DWORD
UnMarshallISAKMPObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );

DWORD
ReadISAKMPObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );

typedef struct _ldapobject
{
    union {
        WCHAR *strVals;
        struct berval *bVals;
    } val;
} LDAPOBJECT, *PLDAPOBJECT;

#define LDAPOBJECT_STRING(pldapobject)      ((pldapobject)->val.strVals)
#define LDAPOBJECT_BERVAL(pldapobject)      ((pldapobject)->val.bVals)
#define LDAPOBJECT_BERVAL_VAL(pldapobject)  ((pldapobject)->val.bVals->bv_val)
#define LDAPOBJECT_BERVAL_LEN(pldapobject)  ((pldapobject)->val.bVals->bv_len)

void
FreeIpsecNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

void
FreeIpsecPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
UnMarshallFilterObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );


void
FreeIpsecFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );


DWORD
UnMarshallNegPolObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_NEGPOL_OBJECT * ppIpsecPolicyObject
    );


void
FreeIpsecNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
ReadFilterObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
GenerateFilterQuery(
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    LPWSTR * ppszQueryBuffer
    );

DWORD
ReadNegPolObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
GenerateNegPolQuery(
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    LPWSTR * ppszQueryBuffer
    );

DWORD
ComputePolicyContainerDN(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyContainerDN
    );

DWORD
ComputeDefaultDirectory(
    LPWSTR * ppszDefaultDirectory
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\freeobj.c ===
#include "precomp.h"

void
FreeIpsecNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    if (pIpsecNFAObject->pszDistinguishedName) {
        FreePolStr(pIpsecNFAObject->pszDistinguishedName);
    }

    if (pIpsecNFAObject->pszIpsecName) {
        FreePolStr(pIpsecNFAObject->pszIpsecName);
    }

    if (pIpsecNFAObject->pszDescription) {
        FreePolStr(pIpsecNFAObject->pszDescription);
    }

    if (pIpsecNFAObject->pszIpsecID) {
        FreePolStr(pIpsecNFAObject->pszIpsecID);
    }

    if (pIpsecNFAObject->pIpsecData) {
        FreePolMem(pIpsecNFAObject->pIpsecData);
    }

    if (pIpsecNFAObject->pszIpsecOwnersReference) {
        FreePolStr(pIpsecNFAObject->pszIpsecOwnersReference);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        FreePolStr(pIpsecNFAObject->pszIpsecFilterReference);
    }

    if (pIpsecNFAObject->pszIpsecNegPolReference) {
        FreePolStr(pIpsecNFAObject->pszIpsecNegPolReference);
    }

    FreePolMem(pIpsecNFAObject);

    return;
}


void
FreeIpsecPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    if (pIpsecPolicyObject->pszDescription) {
        FreePolStr(pIpsecPolicyObject->pszDescription);
    }

    if (pIpsecPolicyObject->pszIpsecOwnersReference) {
        FreePolStr(pIpsecPolicyObject->pszIpsecOwnersReference);
    }

    if (pIpsecPolicyObject->pszIpsecName) {
        FreePolStr(pIpsecPolicyObject->pszIpsecName);
    }

    if (pIpsecPolicyObject->pszIpsecID) {
        FreePolStr(pIpsecPolicyObject->pszIpsecID);
    }

    if (pIpsecPolicyObject->pIpsecData) {
        FreePolMem(pIpsecPolicyObject->pIpsecData);
    }

    if (pIpsecPolicyObject->pszIpsecISAKMPReference) {
        FreePolStr(pIpsecPolicyObject->pszIpsecISAKMPReference);
    }

    if (pIpsecPolicyObject->ppszIpsecNFAReferences) {
        FreeNFAReferences(
                pIpsecPolicyObject->ppszIpsecNFAReferences,
                pIpsecPolicyObject->NumberofRules
                );
    }

    if (pIpsecPolicyObject->ppIpsecNFAObjects) {
        FreeIpsecNFAObjects(
                pIpsecPolicyObject->ppIpsecNFAObjects,
                pIpsecPolicyObject->NumberofRulesReturned
                );
    }


    if (pIpsecPolicyObject->ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
                pIpsecPolicyObject->ppIpsecFilterObjects,
                pIpsecPolicyObject->NumberofFilters
                );
    }


    if (pIpsecPolicyObject->ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
                pIpsecPolicyObject->ppIpsecNegPolObjects,
                pIpsecPolicyObject->NumberofNegPols
                );
    }

    if (pIpsecPolicyObject->ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
                pIpsecPolicyObject->ppIpsecISAKMPObjects,
                pIpsecPolicyObject->NumberofISAKMPs
                );
    }

    if (pIpsecPolicyObject->pRsopInfo) {
        FreeRsopInfo(
            pIpsecPolicyObject->pRsopInfo
            );
    }
    
    FreePolMem(pIpsecPolicyObject);

    return;
}



void
FreeIpsecFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{

    if (pIpsecFilterObject->pszDistinguishedName) {
        FreePolStr(pIpsecFilterObject->pszDistinguishedName);
    }

    if (pIpsecFilterObject->pszDescription) {
        FreePolStr(pIpsecFilterObject->pszDescription);
    }

    if (pIpsecFilterObject->pszIpsecName) {
        FreePolStr(pIpsecFilterObject->pszIpsecName);
    }

    if (pIpsecFilterObject->pszIpsecID) {
        FreePolStr(pIpsecFilterObject->pszIpsecID);
    }

    if (pIpsecFilterObject->pIpsecData) {
        FreePolMem(pIpsecFilterObject->pIpsecData);
    }


    if (pIpsecFilterObject->ppszIpsecNFAReferences) {
        FreeNFAReferences(
                pIpsecFilterObject->ppszIpsecNFAReferences,
                pIpsecFilterObject->dwNFACount
                );
    }


    FreePolMem(pIpsecFilterObject);

    return;
}


void
FreeIpsecNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    if (pIpsecNegPolObject->pszDescription) {
        FreePolStr(pIpsecNegPolObject->pszDescription);
    }

    if (pIpsecNegPolObject->pszDistinguishedName) {
        FreePolStr(pIpsecNegPolObject->pszDistinguishedName);
    }

    if (pIpsecNegPolObject->pszIpsecName) {
        FreePolStr(pIpsecNegPolObject->pszIpsecName);
    }

    if (pIpsecNegPolObject->pszIpsecID) {
        FreePolStr(pIpsecNegPolObject->pszIpsecID);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolAction) {
        FreePolStr(pIpsecNegPolObject->pszIpsecNegPolAction);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolType) {
        FreePolStr(pIpsecNegPolObject->pszIpsecNegPolType);
    }

    if (pIpsecNegPolObject->pIpsecData) {
        FreePolMem(pIpsecNegPolObject->pIpsecData);
    }

    if (pIpsecNegPolObject->ppszIpsecNFAReferences) {
        FreeNFAReferences(
                pIpsecNegPolObject->ppszIpsecNFAReferences,
                pIpsecNegPolObject->dwNFACount
                );
    }


    FreePolMem(pIpsecNegPolObject);

    return;
}

void
FreeIpsecISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{

    if (pIpsecISAKMPObject->pszDistinguishedName) {
        FreePolStr(pIpsecISAKMPObject->pszDistinguishedName);
    }

    if (pIpsecISAKMPObject->pszIpsecName) {
        FreePolStr(pIpsecISAKMPObject->pszIpsecName);
    }

    if (pIpsecISAKMPObject->pszIpsecID) {
        FreePolStr(pIpsecISAKMPObject->pszIpsecID);
    }

    if (pIpsecISAKMPObject->pIpsecData) {
        FreePolMem(pIpsecISAKMPObject->pIpsecData);
    }

    if (pIpsecISAKMPObject->ppszIpsecNFAReferences) {
        FreeNFAReferences(
                pIpsecISAKMPObject->ppszIpsecNFAReferences,
                pIpsecISAKMPObject->dwNFACount
                );
    }


    FreePolMem(pIpsecISAKMPObject);

    return;
}


void
FreeNFAReferences(
    LPWSTR * ppszNFAReferences,
    DWORD dwNumNFAReferences
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumNFAReferences; i++) {

        if (*(ppszNFAReferences + i)) {

            FreePolStr(*(ppszNFAReferences + i));
        }
    }

    FreePolMem(ppszNFAReferences);
    return;
}

void
FreeFilterReferences(
    LPWSTR * ppszFilterReferences,
    DWORD dwNumFilterReferences
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumFilterReferences; i++) {

        if (*(ppszFilterReferences + i)) {

            FreePolStr(*(ppszFilterReferences + i));
        }
    }

    FreePolMem(ppszFilterReferences);
    return;
}






void
FreeNegPolReferences(
    LPWSTR * ppszNegPolReferences,
    DWORD dwNumNegPolReferences
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumNegPolReferences; i++) {

        if (*(ppszNegPolReferences + i)) {

            FreePolStr(*(ppszNegPolReferences + i));
        }
    }

    FreePolMem(ppszNegPolReferences);
    return;
}

void
FreeIpsecNFAObjects(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumNFAObjects; i++) {

        if (*(ppIpsecNFAObjects + i)) {

            FreeIpsecNFAObject(*(ppIpsecNFAObjects + i));

        }

    }

    FreePolMem(ppIpsecNFAObjects);

    return;
}

void
FreeIpsecFilterObjects(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumFilterObjects; i++) {

        if (*(ppIpsecFilterObjects + i)) {

            FreeIpsecFilterObject(*(ppIpsecFilterObjects + i));

        }

    }

    FreePolMem(ppIpsecFilterObjects);

    return;
}

void
FreeIpsecNegPolObjects(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumNegPolObjects; i++) {

        if (*(ppIpsecNegPolObjects + i)) {

            FreeIpsecNegPolObject(*(ppIpsecNegPolObjects + i));

        }

    }

    FreePolMem(ppIpsecNegPolObjects);

    return;
}

void
FreeIpsecISAKMPObjects(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        if (*(ppIpsecISAKMPObjects + i)) {

            FreeIpsecISAKMPObject(*(ppIpsecISAKMPObjects + i));

        }

    }

    FreePolMem(ppIpsecISAKMPObjects);

    return;
}


void
FreeIpsecPolicyObjects(
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects,
    DWORD dwNumPolicyObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumPolicyObjects; i++) {

        if (*(ppIpsecPolicyObjects + i)) {

            FreeIpsecPolicyObject(*(ppIpsecPolicyObjects + i));

        }

    }

    FreePolMem(ppIpsecPolicyObjects);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\ldaputil.h ===
typedef LDAP * PLDAP;

typedef PLDAP HLDAP;

DWORD
LdapOpen(
    WCHAR *domainName,
    int portno,
    HLDAP * phLdapHandle
    );


DWORD
LdapBind(
    HLDAP hLdapHandle
    );

DWORD
LdapSearchHelper(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
    );

DWORD
LdapSearchS(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    LDAPMessage **res
    );

DWORD
LdapSearchST(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
    );

DWORD
CheckAndSetExtendedError(
    HLDAP hLdapHandle,
    int ldaperr
    );


DWORD
LdapFirstEntry(
    HLDAP hLdapHandle,
    LDAPMessage *res,
    LDAPMessage **pfirst
    );

DWORD
LdapGetValues(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR *attr,
    WCHAR ***pvalues,
    int   *pcount
    );

DWORD
LdapGetValuesLen(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR *attr,
    struct berval ***pvalues,
    int   *pcount
    );

DWORD
LdapNextEntry(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    LDAPMessage **pnext
    );

int
LdapCountEntries(
    HLDAP hLdapHandle,
    LDAPMessage *res
    );

void
LdapMsgFree(
    LDAPMessage *res
);

void LdapValueFree(
    WCHAR **vals
);

void LdapValueFreeLen(
    struct berval **vals
);

DWORD
LdapAddS(
    HLDAP hLdapHandle,
    WCHAR *dn,
    LDAPModW *attrs[]
    );

DWORD
LdapModifyS(
    HLDAP hLdapHandle,
    WCHAR *dn,
    LDAPModW *mods[]
    );

DWORD
LdapDeleteS(
    HLDAP hLdapHandle,
    WCHAR *dn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\ldaputil.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       drt.cxx
//
//  Contents:   Main for OleDs DRT
//
//
//  History:    28-Oct-94  KrishnaG, created OleDs DRT
//              28-Oct-94  ChuckC, rewritten.
//
//----------------------------------------------------------------------------


#include "precomp.h"

// Description:
//
//     Ldap utilities expect the domain name to be a fully qualified dns name.
//     This function takes a flat or dns name as input, and returns the
//     fully qualified dns name as output.
//
//  Parameters:
//
//      pszDomain - caller supplied domain name to be "cracked"
//      pfCracked - TRUE if cracking was required, FALSE if the supplied domain 
//                  name was already in the corrrect form.  
//      ppszDomain - the cracked name if pfCracked is set to TRUE.  Caller 
//                   frees this string with NsuFree.
//
DWORD
CrackDomainName(
    IN WCHAR* pszDomain,     // domain name from the caller
    OUT BOOL* pbCracked,     // 
    OUT WCHAR** ppszDomain)  // will point to pszDomain or pszBuffer on success
{
    DWORD dwErr = NO_ERROR;
    PDOMAIN_CONTROLLER_INFOW pDcInfo = NULL;

    // Initialize
    //
    *pbCracked = FALSE;
    *ppszDomain = NULL;

    // NULL domain means "use default" to ldap, so no further processing is 
    // needed.
    //
    if (pszDomain == NULL) {
        return NO_ERROR;
    }

    // If the domain name contains a period, then assume, that it is already
    // a fully qualified dns name.
    //
    if (wcsstr(pszDomain, L"."))
    {
        return NO_ERROR;
    }

    // Otherwise, use DsGetDcName to discover the fully qualified domain name
    // of the supplied domain
    //
    dwErr = DsGetDcNameW(
                NULL,
                pszDomain,
                NULL,
                NULL,
                DS_IS_FLAT_NAME | DS_RETURN_DNS_NAME,
                &pDcInfo);
    NSU_BAIL_ON_ERROR(dwErr);                

    // If the domain name is not returned, then we have a problem
    //
    if ((pDcInfo == NULL) || (pDcInfo->DomainName == NULL))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        NSU_BAIL_ON_ERROR(dwErr);
    }

    // Pull out the dns name from the dc info
    //
    dwErr = NsuStringDupW(
                ppszDomain,
                4 * 1024,               // not supporting > 4k chars names
                pDcInfo->DomainName);
    NSU_BAIL_ON_ERROR(dwErr);

    *pbCracked = TRUE;

    NSU_CLEANUP:

    if (pDcInfo) {
        NetApiBufferFree(pDcInfo);
    }

    return dwErr;
}


DWORD
LdapOpen(
    WCHAR *domainName,
    int portno,
    HLDAP * phLdapHandle
    )
{
    int ldaperr = 0;
    void *ldapOption;
    HLDAP hLdapHandle = NULL;
    DWORD dwError = 0;
    WCHAR* pszCracked = NULL;
    BOOL bCracked = FALSE;

    // Discover the domain name in the form ldap expects.
    //
    // If cracking the name fails, then try to connect using the caller 
    // supplied domain name anyway before failing altogether.
    //
    dwError = CrackDomainName(domainName, &bCracked, &pszCracked);
    if (dwError == ERROR_SUCCESS) {
        if (bCracked) {
            domainName = pszCracked;
        }
    }
    dwError = ERROR_SUCCESS;    

    hLdapHandle = ldap_init(domainName, portno );

    if (hLdapHandle == NULL ) {

        dwError = ERROR_BAD_NETPATH;
        goto error;
    }

    //
    // Now process versioning
    //

    ldapOption = (void *) LDAP_VERSION3;

    ldaperr = ldap_set_option(
                  hLdapHandle,
                  LDAP_OPT_VERSION,
                  &(ldapOption)
                  );

    ldapOption = LDAP_OPT_ON;

    //
    // Ignoring errors for ldap_set_option because we can't force these on
    // non-AD directory services (e.g. NDS)
    
    ldaperr = ldap_set_option(
                    hLdapHandle,
                    LDAP_OPT_ENCRYPT,
                    &(ldapOption)
                    );

    ldaperr = ldap_set_option(
                      hLdapHandle,
                      LDAP_OPT_SIGN,
                      &(ldapOption)
                      );

    ldaperr = ldap_connect(hLdapHandle, NULL);

    if (ldaperr) {

        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

        goto error;
    }

    //
    // Disabled Callback function support and chasing external referrals
    // KrishnaG - do I need to support this.

    *phLdapHandle = hLdapHandle;

    return(dwError);

error:

    if (hLdapHandle != NULL) {

        ldaperr = ldap_unbind( hLdapHandle );

    }

    if (pszCracked != NULL) {

        NsuFree(&pszCracked);

    }

    return (dwError);
}

DWORD
LdapBind(
    HLDAP hLdapHandle
    )
{
    int ldaperr = 0;

    ldaperr = ldap_bind_s(hLdapHandle, NULL, NULL, LDAP_AUTH_SSPI);

    return (ldaperr);
}


DWORD
LdapSearchHelper(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
    )
{
    int nCount = 0;
    int j = 0;
    int ldaperr = 0;
    DWORD dwError = 0;

    if ( timeout == NULL )
    {
        ldaperr = ldap_search_s(
                        hLdapHandle,
                        base,
                        scope,
                        filter,
                        attrs,
                        attrsonly,
                        res
                        );
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    }
    else
    {
        ldaperr = ldap_search_st(
                        hLdapHandle,
                        base,
                        scope,
                        filter,
                        attrs,
                        attrsonly,
                        timeout,
                        res
                        );
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    }

    //
    // Is there an error with checking the no of results
    //

    return (dwError);
}


DWORD
LdapSearchS(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    LDAPMessage **res
    )
{

    DWORD dwError = 0;

    dwError = LdapSearchHelper(
                  hLdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  NULL,
                  res
                  );
    //
    // Is there a check needed for connection errors
    //

    return(dwError);

}

DWORD
LdapSearchST(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
    )
{
    DWORD dwError = 0;

    dwError = LdapSearchHelper(
                  hLdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  timeout,
                  res
                  );

    return(dwError);
}




















//
// Completely new functionality - block ported from YihsinS code in ADSI
//


DWORD
LdapAbandon(
    HLDAP hLdapHandle,
    int   msgid
    )
{

    // No error code, 0 if success, -1 otherwise
    return ldap_abandon( hLdapHandle, msgid );
}

DWORD
LdapResult(
    HLDAP hLdapHandle,
    int    msgid,
    int    all,
    struct l_timeval *timeout,
    LDAPMessage **res,
    int    *restype
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    *restype = ldap_result( hLdapHandle, msgid, all, timeout, res );

    if ( *restype == -1 )  // error
        ldaperr = LdapGetLastError();

    if (ldaperr) {

       if (!ldap_count_entries( hLdapHandle, *res )) {

           dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
       }
    }else {

        dwError = 0;
    }

    return(dwError);

}

void
LdapMsgFree(
    LDAPMessage *res
    )
{
    ldap_msgfree( res );  // Returns the type of message freed which
                          // is not interesting
}

int
LdapResult2Error(
    HLDAP hLdapHandle,
    LDAPMessage *res,
    int freeit
    )
{

    return ldap_result2error( hLdapHandle, res, freeit );
}

DWORD
LdapFirstEntry(
    HLDAP hLdapHandle,
    LDAPMessage *res,
    LDAPMessage **pfirst
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    *pfirst = ldap_first_entry( hLdapHandle, res );

    if ( *pfirst == NULL )
    {
        ldaperr = LdapGetLastError();

        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
    }

    return(dwError);
}

DWORD
LdapNextEntry(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    LDAPMessage **pnext
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    *pnext = ldap_next_entry( hLdapHandle, entry );

    if ( *pnext == NULL )
    {
        ldaperr = LdapGetLastError();

        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
    }

    return(dwError);
}

int
LdapCountEntries(
    HLDAP hLdapHandle,
    LDAPMessage *res
    )
{

    return ldap_count_entries( hLdapHandle, res );
}

DWORD
LdapFirstAttribute(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    void  **ptr,
    WCHAR **pattr
    )
{

    // NOTE: The return value from ldap_first_attribute is static and
    //       should not be freed

    *pattr = ldap_first_attribute( hLdapHandle, entry,
                                   (struct berelement **) ptr );  // static data

    if ( *pattr == NULL )
    {
        DWORD dwError = 0;
        int ldaperr = 0;

        // Error occurred or end of attributes

        ldaperr = LdapGetLastError();

        CheckAndSetExtendedError( hLdapHandle, ldaperr);

        return(dwError);
    }

    return NO_ERROR;

}

DWORD
LdapNextAttribute(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    void  *ptr,
    WCHAR **pattr
    )
{

    // NOTE: The return value from ldap_next_attribute is static and
    //       should not be freed
    *pattr = ldap_next_attribute( hLdapHandle, entry,
                                  (struct berelement *) ptr );  // static data

#if 0   // Ignore the error code here since at the end of the enumeration,
        // we will probably get an error code here ( both Andy and umich's
        // dll will return errors sometimes. No error returned from NTDS,
        // but errors are returned from Exchange server  )

    if ( *pattr == NULL )
    {
        DWORD hr = NO_ERROR;
        int ldaperr = 0;

        // Error occurred or end of attributes
        ldaperr = LdapGetLastError();
        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        return(dwError);
    }
#endif

    return S_OK;
}


//
// NOTE: LdapGetValues return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

DWORD
LdapGetValues(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR *attr,
    WCHAR ***pvalues,
    int   *pcount
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    *pvalues = ldap_get_values( hLdapHandle, entry, attr );

    if ( *pvalues == NULL ) {

        *pcount=0;

        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //

        ldaperr = LdapGetLastError();

        if (ldaperr) {

            dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        }

        //
        // KrishnaG if  *pvalues is NULL which means I don't get back a
        // value - return an ERROR
        //

        return(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
    }

    *pcount = ldap_count_values( *pvalues );

    return S_OK;
}


//
// NOTE: LdapGetValuesLen return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

DWORD
LdapGetValuesLen(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR *attr,
    struct berval ***pvalues,
    int   *pcount
    )
{
    //
    // NOTE: this can contain binary data as well as strings,
    //       strings are ascii, no conversion is done here
    //

    char *pszAttrA = NULL;
    DWORD dwError = 0;
    int ldaperr = 0;


    *pvalues = ldap_get_values_len( hLdapHandle, entry, attr );

    if ( *pvalues == NULL ){

        *pcount=0;

        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //

        ldaperr = LdapGetLastError();

        if (ldaperr) {

            dwError = CheckAndSetExtendedError( hLdapHandle,ldaperr);
        }

        return(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
    }

    *pcount = ldap_count_values_len( *pvalues );

    return S_OK;
}


void
LdapValueFree(
    WCHAR **vals
    )
{
    ldap_value_free( vals );
}

void
LdapValueFreeLen(
    struct berval **vals
    )
{
    ldap_value_free_len( vals );
}

void
LdapMemFree(
    WCHAR *pszString
    )
{
    ldap_memfree( pszString );
}

void
LdapAttributeFree(
    WCHAR *pszString
    )
{
    // String from ldap_first/next_attribute should not be freed,
    // so do nothing here
}

DWORD
LdapGetDn(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR **pdn
    )
{
    int ldaperr = 0;
    DWORD dwError = 0;

    *pdn = ldap_get_dn( hLdapHandle, entry );
    if ( *pdn == NULL )
    {
        // Error occurred
        ldaperr = LdapGetLastError();

        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        return(dwError);
    }

    return(dwError);
}



DWORD
CheckAndSetExtendedError(
    HLDAP hLdapHandle,
    int     ldaperr
    )
{

    DWORD dwErr = NO_ERROR;

    switch (ldaperr) {

    case LDAP_SUCCESS :
        dwErr = NO_ERROR;
        break;

    case LDAP_OPERATIONS_ERROR :
        dwErr =  ERROR_DS_OPERATIONS_ERROR;
        break;

    case LDAP_PROTOCOL_ERROR :
        dwErr =  ERROR_DS_PROTOCOL_ERROR;
        break;

    case LDAP_TIMELIMIT_EXCEEDED :
        dwErr = ERROR_DS_TIMELIMIT_EXCEEDED;
        break;

    case LDAP_SIZELIMIT_EXCEEDED :
        dwErr = ERROR_DS_SIZELIMIT_EXCEEDED;
        break;

    case LDAP_COMPARE_FALSE :
        dwErr = ERROR_DS_COMPARE_FALSE;
        break;

    case LDAP_COMPARE_TRUE :
        dwErr = ERROR_DS_COMPARE_TRUE;
        break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        dwErr = ERROR_DS_AUTH_METHOD_NOT_SUPPORTED;
        break;

    case LDAP_STRONG_AUTH_REQUIRED :
        dwErr =  ERROR_DS_STRONG_AUTH_REQUIRED;
        break;

    case LDAP_PARTIAL_RESULTS :

        //
        // Make sure we handle
        // partial results.
        //
        dwErr = ERROR_MORE_DATA;
        break;


    case LDAP_REFERRAL :
        dwErr =  ERROR_DS_REFERRAL;
        break;

    case LDAP_ADMIN_LIMIT_EXCEEDED :
        dwErr   = ERROR_DS_ADMIN_LIMIT_EXCEEDED;
        break;

    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        dwErr = ERROR_DS_UNAVAILABLE_CRIT_EXTENSION;
        break;

    case LDAP_CONFIDENTIALITY_REQUIRED :
        dwErr = ERROR_DS_CONFIDENTIALITY_REQUIRED;
        break;

    case LDAP_NO_SUCH_ATTRIBUTE :
        dwErr = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        break;

    case LDAP_UNDEFINED_TYPE :
        dwErr = ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED;
        break;

    case LDAP_INAPPROPRIATE_MATCHING :
        dwErr = ERROR_DS_INAPPROPRIATE_MATCHING;
        break;

    case LDAP_CONSTRAINT_VIOLATION :
        dwErr = ERROR_DS_CONSTRAINT_VIOLATION;
        break;

    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        dwErr = ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS;
        break;

    case LDAP_INVALID_SYNTAX :
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        break;

    case LDAP_NO_SUCH_OBJECT :
        dwErr = ERROR_DS_NO_SUCH_OBJECT;
        break;

    case LDAP_ALIAS_PROBLEM :
        dwErr = ERROR_DS_ALIAS_PROBLEM;
        break;

    case LDAP_INVALID_DN_SYNTAX :
        dwErr = ERROR_DS_INVALID_DN_SYNTAX;
        break;

    case LDAP_IS_LEAF :
        dwErr = ERROR_DS_IS_LEAF;
        break;

    case LDAP_ALIAS_DEREF_PROBLEM :
        dwErr = ERROR_DS_ALIAS_DEREF_PROBLEM;
        break;

    case LDAP_INAPPROPRIATE_AUTH :
        dwErr = ERROR_DS_INAPPROPRIATE_AUTH;
        break;

    case LDAP_INVALID_CREDENTIALS :
        dwErr = ERROR_LOGON_FAILURE;
        break;

    case LDAP_INSUFFICIENT_RIGHTS :
        dwErr = ERROR_ACCESS_DENIED;
        break;

    case LDAP_BUSY :
        dwErr = ERROR_DS_BUSY;
        break;

    case LDAP_UNAVAILABLE :
        dwErr = ERROR_DS_UNAVAILABLE;
        break;

    case LDAP_UNWILLING_TO_PERFORM :
        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
        break;

    case LDAP_LOOP_DETECT :
        dwErr = ERROR_DS_LOOP_DETECT;
        break;

    case LDAP_NAMING_VIOLATION :
        dwErr = ERROR_DS_NAMING_VIOLATION;
        break;

    case LDAP_OBJECT_CLASS_VIOLATION :
        dwErr = ERROR_DS_OBJ_CLASS_VIOLATION;
        break;

    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        dwErr = ERROR_DS_CANT_ON_NON_LEAF;
        break;

    case LDAP_NOT_ALLOWED_ON_RDN :
        dwErr = ERROR_DS_CANT_ON_RDN;
        break;

    case LDAP_ALREADY_EXISTS :
        dwErr = ERROR_OBJECT_ALREADY_EXISTS;
        break;

    case LDAP_NO_OBJECT_CLASS_MODS :
        dwErr = ERROR_DS_CANT_MOD_OBJ_CLASS;
        break;

    case LDAP_RESULTS_TOO_LARGE :
        dwErr = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        break;

    case LDAP_AFFECTS_MULTIPLE_DSAS :
        dwErr = ERROR_DS_AFFECTS_MULTIPLE_DSAS;
        break;

    case LDAP_OTHER :
        dwErr = ERROR_GEN_FAILURE;
        break;

    case LDAP_SERVER_DOWN :
        dwErr = ERROR_DS_SERVER_DOWN;
        break;

    case LDAP_LOCAL_ERROR :
        dwErr = ERROR_DS_LOCAL_ERROR;
        break;

    case LDAP_ENCODING_ERROR :
        dwErr = ERROR_DS_ENCODING_ERROR;
        break;

    case LDAP_DECODING_ERROR :
        dwErr = ERROR_DS_DECODING_ERROR;
        break;

    case LDAP_TIMEOUT :
        dwErr = ERROR_TIMEOUT;
        break;

    case LDAP_AUTH_UNKNOWN :
        dwErr = ERROR_DS_AUTH_UNKNOWN;
        break;

    case LDAP_FILTER_ERROR :
        dwErr = ERROR_DS_FILTER_UNKNOWN;
        break;

    case LDAP_USER_CANCELLED :
       dwErr = ERROR_CANCELLED;
       break;

    case LDAP_PARAM_ERROR :
        dwErr = ERROR_DS_PARAM_ERROR;
        break;

    case LDAP_NO_MEMORY :
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case LDAP_CONNECT_ERROR :
        dwErr = ERROR_CONNECTION_REFUSED;
        break;

    case LDAP_NOT_SUPPORTED :
        dwErr = ERROR_DS_NOT_SUPPORTED;
        break;

    case LDAP_NO_RESULTS_RETURNED :
        dwErr = ERROR_DS_NO_RESULTS_RETURNED;
        break;

    case LDAP_CONTROL_NOT_FOUND :
        dwErr = ERROR_DS_CONTROL_NOT_FOUND;
        break;

    case LDAP_MORE_RESULTS_TO_RETURN :
        dwErr = ERROR_MORE_DATA;
        break;

    case LDAP_CLIENT_LOOP :
        dwErr = ERROR_DS_CLIENT_LOOP;
        break;

    case LDAP_REFERRAL_LIMIT_EXCEEDED :
        dwErr = ERROR_DS_REFERRAL_LIMIT_EXCEEDED;
        break;

    default:
        dwErr = ERROR_DS_BUSY;

    }

    return(dwErr);
}




DWORD
LdapAddS(
    HLDAP hLdapHandle,
    WCHAR *dn,
    LDAPModW *attrs[]
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    ldaperr = ldap_add_s( hLdapHandle, dn, attrs );

    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    return(dwError);
}


DWORD
LdapModifyS(
    HLDAP hLdapHandle,
    WCHAR *dn,
    LDAPModW *mods[]
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;

    ldaperr = ldap_modify_s( hLdapHandle, dn, mods);

    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

 